# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_StepShape')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_StepShape')
    _StepShape = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_StepShape', [dirname(__file__)])
        except ImportError:
            import _StepShape
            return _StepShape
        try:
            _mod = imp.load_module('_StepShape', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _StepShape = swig_import_helper()
    del swig_import_helper
else:
    import _StepShape
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


class SwigPyIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _StepShape.delete_SwigPyIterator

    def value(self):
        return _StepShape.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _StepShape.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _StepShape.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _StepShape.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _StepShape.SwigPyIterator_equal(self, x)

    def copy(self):
        return _StepShape.SwigPyIterator_copy(self)

    def next(self):
        return _StepShape.SwigPyIterator_next(self)

    def __next__(self):
        return _StepShape.SwigPyIterator___next__(self)

    def previous(self):
        return _StepShape.SwigPyIterator_previous(self)

    def advance(self, n):
        return _StepShape.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _StepShape.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _StepShape.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _StepShape.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _StepShape.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _StepShape.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _StepShape.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self
SwigPyIterator_swigregister = _StepShape.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

class NCollection_CellFilter_InspectorXYZ(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _StepShape.NCollection_CellFilter_InspectorXYZ_Dimension
    Coord = staticmethod(_StepShape.NCollection_CellFilter_InspectorXYZ_Coord)

    def Shift(self, thePnt, theTol):
        return _StepShape.NCollection_CellFilter_InspectorXYZ_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _StepShape.new_NCollection_CellFilter_InspectorXYZ()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _StepShape.delete_NCollection_CellFilter_InspectorXYZ
NCollection_CellFilter_InspectorXYZ_swigregister = _StepShape.NCollection_CellFilter_InspectorXYZ_swigregister
NCollection_CellFilter_InspectorXYZ_swigregister(NCollection_CellFilter_InspectorXYZ)

def NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt):
    return _StepShape.NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt)
NCollection_CellFilter_InspectorXYZ_Coord = _StepShape.NCollection_CellFilter_InspectorXYZ_Coord

class NCollection_CellFilter_InspectorXY(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _StepShape.NCollection_CellFilter_InspectorXY_Dimension
    Coord = staticmethod(_StepShape.NCollection_CellFilter_InspectorXY_Coord)

    def Shift(self, thePnt, theTol):
        return _StepShape.NCollection_CellFilter_InspectorXY_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _StepShape.new_NCollection_CellFilter_InspectorXY()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _StepShape.delete_NCollection_CellFilter_InspectorXY
NCollection_CellFilter_InspectorXY_swigregister = _StepShape.NCollection_CellFilter_InspectorXY_swigregister
NCollection_CellFilter_InspectorXY_swigregister(NCollection_CellFilter_InspectorXY)

def NCollection_CellFilter_InspectorXY_Coord(i, thePnt):
    return _StepShape.NCollection_CellFilter_InspectorXY_Coord(i, thePnt)
NCollection_CellFilter_InspectorXY_Coord = _StepShape.NCollection_CellFilter_InspectorXY_Coord


def ptr_to_number(item):
    return _StepShape.ptr_to_number(item)
ptr_to_number = _StepShape.ptr_to_number

def HashCode(*args):
    return _StepShape.HashCode(*args)
HashCode = _StepShape.HashCode

def ptr_equal(a, b):
    return _StepShape.ptr_equal(a, b)
ptr_equal = _StepShape.ptr_equal
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import StepBasic
else:
    import StepBasic
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import NCollection
else:
    import NCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Standard
else:
    import Standard
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColStd
else:
    import TColStd
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TCollection
else:
    import TCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import StepData
else:
    import StepData
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Interface
else:
    import Interface
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import MoniTool
else:
    import MoniTool
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopoDS
else:
    import TopoDS
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopAbs
else:
    import TopAbs
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Message
else:
    import Message
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopLoc
else:
    import TopLoc
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import gp
else:
    import gp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import OSD
else:
    import OSD
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Quantity
else:
    import Quantity
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopTools
else:
    import TopTools
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Bnd
else:
    import Bnd
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColgp
else:
    import TColgp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import StepGeom
else:
    import StepGeom
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import StepRepr
else:
    import StepRepr
del _swig_python_version_info
StepShape_Equal = _StepShape.StepShape_Equal
StepShape_Large = _StepShape.StepShape_Large
StepShape_Small = _StepShape.StepShape_Small
StepShape_boDifference = _StepShape.StepShape_boDifference
StepShape_boIntersection = _StepShape.StepShape_boIntersection
StepShape_boUnion = _StepShape.StepShape_boUnion
class StepShape_TopologicalRepresentationItem(StepRepr.StepRepr_RepresentationItem):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepShape_TopologicalRepresentationItem
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepShape_TopologicalRepresentationItem(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepShape_TopologicalRepresentationItem self) -> StepShape_TopologicalRepresentationItem

        Returns a TopologicalRepresentationItem


        """
        this = _StepShape.new_StepShape_TopologicalRepresentationItem(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepShape.StepShape_TopologicalRepresentationItem_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepShape.StepShape_TopologicalRepresentationItem_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.StepShape_TopologicalRepresentationItem_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepShape.delete_StepShape_TopologicalRepresentationItem
StepShape_TopologicalRepresentationItem_swigregister = _StepShape.StepShape_TopologicalRepresentationItem_swigregister
StepShape_TopologicalRepresentationItem_swigregister(StepShape_TopologicalRepresentationItem)

def StepShape_TopologicalRepresentationItem_get_type_name(*args):
    """
    StepShape_TopologicalRepresentationItem_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepShape.StepShape_TopologicalRepresentationItem_get_type_name(*args)

def StepShape_TopologicalRepresentationItem_get_type_descriptor(*args):
    """
    StepShape_TopologicalRepresentationItem_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepShape.StepShape_TopologicalRepresentationItem_get_type_descriptor(*args)

class StepShape_Edge(StepShape_TopologicalRepresentationItem):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepShape_Edge
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepShape_Edge(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepShape_Edge self) -> StepShape_Edge

        Returns a Edge


        """
        this = _StepShape.new_StepShape_Edge(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepShape_Edge self, Handle_TCollection_HAsciiString aName, Handle_StepShape_Vertex aEdgeStart, Handle_StepShape_Vertex aEdgeEnd)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aEdgeStart: OCC.wrapper.StepShape.Handle_StepShape_Vertex
        :type aEdgeEnd: OCC.wrapper.StepShape.Handle_StepShape_Vertex

        """
        return _StepShape.StepShape_Edge_Init(self, *args)


    def SetEdgeStart(self, *args):
        """
        SetEdgeStart(StepShape_Edge self, Handle_StepShape_Vertex aEdgeStart)

        :type aEdgeStart: OCC.wrapper.StepShape.Handle_StepShape_Vertex

        """
        return _StepShape.StepShape_Edge_SetEdgeStart(self, *args)


    def EdgeStart(self, *args):
        """
        EdgeStart(StepShape_Edge self) -> Handle_StepShape_Vertex

        :rtype: OCC.wrapper.StepShape.Handle_StepShape_Vertex

        """
        return _StepShape.StepShape_Edge_EdgeStart(self, *args)


    def SetEdgeEnd(self, *args):
        """
        SetEdgeEnd(StepShape_Edge self, Handle_StepShape_Vertex aEdgeEnd)

        :type aEdgeEnd: OCC.wrapper.StepShape.Handle_StepShape_Vertex

        """
        return _StepShape.StepShape_Edge_SetEdgeEnd(self, *args)


    def EdgeEnd(self, *args):
        """
        EdgeEnd(StepShape_Edge self) -> Handle_StepShape_Vertex

        :rtype: OCC.wrapper.StepShape.Handle_StepShape_Vertex

        """
        return _StepShape.StepShape_Edge_EdgeEnd(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepShape.StepShape_Edge_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepShape.StepShape_Edge_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.StepShape_Edge_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepShape.delete_StepShape_Edge
StepShape_Edge_swigregister = _StepShape.StepShape_Edge_swigregister
StepShape_Edge_swigregister(StepShape_Edge)

def StepShape_Edge_get_type_name(*args):
    """
    StepShape_Edge_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepShape.StepShape_Edge_get_type_name(*args)

def StepShape_Edge_get_type_descriptor(*args):
    """
    StepShape_Edge_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepShape.StepShape_Edge_get_type_descriptor(*args)

class StepShape_SolidModel(StepGeom.StepGeom_GeometricRepresentationItem):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepShape_SolidModel
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepShape_SolidModel(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepShape_SolidModel self) -> StepShape_SolidModel

        Returns a SolidModel


        """
        this = _StepShape.new_StepShape_SolidModel(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepShape.StepShape_SolidModel_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepShape.StepShape_SolidModel_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.StepShape_SolidModel_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepShape.delete_StepShape_SolidModel
StepShape_SolidModel_swigregister = _StepShape.StepShape_SolidModel_swigregister
StepShape_SolidModel_swigregister(StepShape_SolidModel)

def StepShape_SolidModel_get_type_name(*args):
    """
    StepShape_SolidModel_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepShape.StepShape_SolidModel_get_type_name(*args)

def StepShape_SolidModel_get_type_descriptor(*args):
    """
    StepShape_SolidModel_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepShape.StepShape_SolidModel_get_type_descriptor(*args)

class StepShape_ConnectedFaceSet(StepShape_TopologicalRepresentationItem):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepShape_ConnectedFaceSet
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepShape_ConnectedFaceSet(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepShape_ConnectedFaceSet self) -> StepShape_ConnectedFaceSet

        Returns a ConnectedFaceSet


        """
        this = _StepShape.new_StepShape_ConnectedFaceSet(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepShape_ConnectedFaceSet self, Handle_TCollection_HAsciiString aName, Handle_StepShape_HArray1OfFace aCfsFaces)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aCfsFaces: OCC.wrapper.StepShape.Handle_StepShape_HArray1OfFace

        """
        return _StepShape.StepShape_ConnectedFaceSet_Init(self, *args)


    def SetCfsFaces(self, *args):
        """
        SetCfsFaces(StepShape_ConnectedFaceSet self, Handle_StepShape_HArray1OfFace aCfsFaces)

        :type aCfsFaces: OCC.wrapper.StepShape.Handle_StepShape_HArray1OfFace

        """
        return _StepShape.StepShape_ConnectedFaceSet_SetCfsFaces(self, *args)


    def CfsFaces(self, *args):
        """
        CfsFaces(StepShape_ConnectedFaceSet self) -> Handle_StepShape_HArray1OfFace

        :rtype: OCC.wrapper.StepShape.Handle_StepShape_HArray1OfFace

        """
        return _StepShape.StepShape_ConnectedFaceSet_CfsFaces(self, *args)


    def CfsFacesValue(self, *args):
        """
        CfsFacesValue(StepShape_ConnectedFaceSet self, Standard_Integer const num) -> Handle_StepShape_Face

        :type num: int
        :rtype: OCC.wrapper.StepShape.Handle_StepShape_Face

        """
        return _StepShape.StepShape_ConnectedFaceSet_CfsFacesValue(self, *args)


    def NbCfsFaces(self, *args):
        """
        NbCfsFaces(StepShape_ConnectedFaceSet self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.StepShape_ConnectedFaceSet_NbCfsFaces(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepShape.StepShape_ConnectedFaceSet_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepShape.StepShape_ConnectedFaceSet_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.StepShape_ConnectedFaceSet_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepShape.delete_StepShape_ConnectedFaceSet
StepShape_ConnectedFaceSet_swigregister = _StepShape.StepShape_ConnectedFaceSet_swigregister
StepShape_ConnectedFaceSet_swigregister(StepShape_ConnectedFaceSet)

def StepShape_ConnectedFaceSet_get_type_name(*args):
    """
    StepShape_ConnectedFaceSet_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepShape.StepShape_ConnectedFaceSet_get_type_name(*args)

def StepShape_ConnectedFaceSet_get_type_descriptor(*args):
    """
    StepShape_ConnectedFaceSet_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepShape.StepShape_ConnectedFaceSet_get_type_descriptor(*args)

class StepShape_DimensionalSize(Standard.Standard_Transient):
    """Representation of STEP entity DimensionalSize"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepShape_DimensionalSize
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepShape_DimensionalSize(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepShape_DimensionalSize self) -> StepShape_DimensionalSize

        Empty constructor


        """
        this = _StepShape.new_StepShape_DimensionalSize(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepShape_DimensionalSize self, Handle_StepRepr_ShapeAspect aAppliesTo, Handle_TCollection_HAsciiString aName)

        Initialize all fields (own and inherited)

        :type aAppliesTo: OCC.wrapper.StepShape.Handle_StepRepr_ShapeAspect
        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepShape.StepShape_DimensionalSize_Init(self, *args)


    def AppliesTo(self, *args):
        """
        AppliesTo(StepShape_DimensionalSize self) -> Handle_StepRepr_ShapeAspect

        Returns field AppliesTo

        :rtype: OCC.wrapper.StepShape.Handle_StepRepr_ShapeAspect

        """
        return _StepShape.StepShape_DimensionalSize_AppliesTo(self, *args)


    def SetAppliesTo(self, *args):
        """
        SetAppliesTo(StepShape_DimensionalSize self, Handle_StepRepr_ShapeAspect AppliesTo)

        Set field AppliesTo

        :type AppliesTo: OCC.wrapper.StepShape.Handle_StepRepr_ShapeAspect

        """
        return _StepShape.StepShape_DimensionalSize_SetAppliesTo(self, *args)


    def Name(self, *args):
        """
        Name(StepShape_DimensionalSize self) -> Handle_TCollection_HAsciiString

        Returns field Name

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepShape.StepShape_DimensionalSize_Name(self, *args)


    def SetName(self, *args):
        """
        SetName(StepShape_DimensionalSize self, Handle_TCollection_HAsciiString Name)

        Set field Name

        :type Name: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepShape.StepShape_DimensionalSize_SetName(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepShape.StepShape_DimensionalSize_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepShape.StepShape_DimensionalSize_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.StepShape_DimensionalSize_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepShape.delete_StepShape_DimensionalSize
StepShape_DimensionalSize_swigregister = _StepShape.StepShape_DimensionalSize_swigregister
StepShape_DimensionalSize_swigregister(StepShape_DimensionalSize)

def StepShape_DimensionalSize_get_type_name(*args):
    """
    StepShape_DimensionalSize_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepShape.StepShape_DimensionalSize_get_type_name(*args)

def StepShape_DimensionalSize_get_type_descriptor(*args):
    """
    StepShape_DimensionalSize_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepShape.StepShape_DimensionalSize_get_type_descriptor(*args)

class StepShape_DimensionalLocation(StepRepr.StepRepr_ShapeAspectRelationship):
    """Representation of STEP entity DimensionalLocation"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepShape_DimensionalLocation
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepShape_DimensionalLocation(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepShape_DimensionalLocation self) -> StepShape_DimensionalLocation

        Empty constructor


        """
        this = _StepShape.new_StepShape_DimensionalLocation(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepShape.StepShape_DimensionalLocation_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepShape.StepShape_DimensionalLocation_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.StepShape_DimensionalLocation_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepShape.delete_StepShape_DimensionalLocation
StepShape_DimensionalLocation_swigregister = _StepShape.StepShape_DimensionalLocation_swigregister
StepShape_DimensionalLocation_swigregister(StepShape_DimensionalLocation)

def StepShape_DimensionalLocation_get_type_name(*args):
    """
    StepShape_DimensionalLocation_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepShape.StepShape_DimensionalLocation_get_type_name(*args)

def StepShape_DimensionalLocation_get_type_descriptor(*args):
    """
    StepShape_DimensionalLocation_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepShape.StepShape_DimensionalLocation_get_type_descriptor(*args)

class StepShape_Loop(StepShape_TopologicalRepresentationItem):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepShape_Loop
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepShape_Loop(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepShape_Loop self) -> StepShape_Loop

        Returns a Loop


        """
        this = _StepShape.new_StepShape_Loop(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepShape.StepShape_Loop_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepShape.StepShape_Loop_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.StepShape_Loop_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepShape.delete_StepShape_Loop
StepShape_Loop_swigregister = _StepShape.StepShape_Loop_swigregister
StepShape_Loop_swigregister(StepShape_Loop)

def StepShape_Loop_get_type_name(*args):
    """
    StepShape_Loop_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepShape.StepShape_Loop_get_type_name(*args)

def StepShape_Loop_get_type_descriptor(*args):
    """
    StepShape_Loop_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepShape.StepShape_Loop_get_type_descriptor(*args)

class StepShape_SweptAreaSolid(StepShape_SolidModel):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepShape_SweptAreaSolid
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepShape_SweptAreaSolid(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepShape_SweptAreaSolid self) -> StepShape_SweptAreaSolid

        Returns a SweptAreaSolid


        """
        this = _StepShape.new_StepShape_SweptAreaSolid(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepShape_SweptAreaSolid self, Handle_TCollection_HAsciiString aName, Handle_StepGeom_CurveBoundedSurface aSweptArea)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aSweptArea: OCC.wrapper.StepShape.Handle_StepGeom_CurveBoundedSurface

        """
        return _StepShape.StepShape_SweptAreaSolid_Init(self, *args)


    def SetSweptArea(self, *args):
        """
        SetSweptArea(StepShape_SweptAreaSolid self, Handle_StepGeom_CurveBoundedSurface aSweptArea)

        :type aSweptArea: OCC.wrapper.StepShape.Handle_StepGeom_CurveBoundedSurface

        """
        return _StepShape.StepShape_SweptAreaSolid_SetSweptArea(self, *args)


    def SweptArea(self, *args):
        """
        SweptArea(StepShape_SweptAreaSolid self) -> Handle_StepGeom_CurveBoundedSurface

        :rtype: OCC.wrapper.StepShape.Handle_StepGeom_CurveBoundedSurface

        """
        return _StepShape.StepShape_SweptAreaSolid_SweptArea(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepShape.StepShape_SweptAreaSolid_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepShape.StepShape_SweptAreaSolid_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.StepShape_SweptAreaSolid_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepShape.delete_StepShape_SweptAreaSolid
StepShape_SweptAreaSolid_swigregister = _StepShape.StepShape_SweptAreaSolid_swigregister
StepShape_SweptAreaSolid_swigregister(StepShape_SweptAreaSolid)

def StepShape_SweptAreaSolid_get_type_name(*args):
    """
    StepShape_SweptAreaSolid_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepShape.StepShape_SweptAreaSolid_get_type_name(*args)

def StepShape_SweptAreaSolid_get_type_descriptor(*args):
    """
    StepShape_SweptAreaSolid_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepShape.StepShape_SweptAreaSolid_get_type_descriptor(*args)

class StepShape_ManifoldSolidBrep(StepShape_SolidModel):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepShape_ManifoldSolidBrep
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepShape_ManifoldSolidBrep(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepShape_ManifoldSolidBrep self) -> StepShape_ManifoldSolidBrep

        Returns a ManifoldSolidBrep


        """
        this = _StepShape.new_StepShape_ManifoldSolidBrep(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepShape_ManifoldSolidBrep self, Handle_TCollection_HAsciiString aName, Handle_StepShape_ClosedShell aOuter)
        Init(StepShape_ManifoldSolidBrep self, Handle_TCollection_HAsciiString aName, Handle_StepShape_ConnectedFaceSet aOuter)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aOuter: OCC.wrapper.StepShape.Handle_StepShape_ConnectedFaceSet

        """
        return _StepShape.StepShape_ManifoldSolidBrep_Init(self, *args)


    def SetOuter(self, *args):
        """
        SetOuter(StepShape_ManifoldSolidBrep self, Handle_StepShape_ConnectedFaceSet aOuter)

        :type aOuter: OCC.wrapper.StepShape.Handle_StepShape_ConnectedFaceSet

        """
        return _StepShape.StepShape_ManifoldSolidBrep_SetOuter(self, *args)


    def Outer(self, *args):
        """
        Outer(StepShape_ManifoldSolidBrep self) -> Handle_StepShape_ConnectedFaceSet

        :rtype: OCC.wrapper.StepShape.Handle_StepShape_ConnectedFaceSet

        """
        return _StepShape.StepShape_ManifoldSolidBrep_Outer(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepShape.StepShape_ManifoldSolidBrep_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepShape.StepShape_ManifoldSolidBrep_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.StepShape_ManifoldSolidBrep_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepShape.delete_StepShape_ManifoldSolidBrep
StepShape_ManifoldSolidBrep_swigregister = _StepShape.StepShape_ManifoldSolidBrep_swigregister
StepShape_ManifoldSolidBrep_swigregister(StepShape_ManifoldSolidBrep)

def StepShape_ManifoldSolidBrep_get_type_name(*args):
    """
    StepShape_ManifoldSolidBrep_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepShape.StepShape_ManifoldSolidBrep_get_type_name(*args)

def StepShape_ManifoldSolidBrep_get_type_descriptor(*args):
    """
    StepShape_ManifoldSolidBrep_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepShape.StepShape_ManifoldSolidBrep_get_type_descriptor(*args)

class StepShape_ClosedShell(StepShape_ConnectedFaceSet):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepShape_ClosedShell
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepShape_ClosedShell(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepShape_ClosedShell self) -> StepShape_ClosedShell

        Returns a ClosedShell


        """
        this = _StepShape.new_StepShape_ClosedShell(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepShape.StepShape_ClosedShell_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepShape.StepShape_ClosedShell_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.StepShape_ClosedShell_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepShape.delete_StepShape_ClosedShell
StepShape_ClosedShell_swigregister = _StepShape.StepShape_ClosedShell_swigregister
StepShape_ClosedShell_swigregister(StepShape_ClosedShell)

def StepShape_ClosedShell_get_type_name(*args):
    """
    StepShape_ClosedShell_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepShape.StepShape_ClosedShell_get_type_name(*args)

def StepShape_ClosedShell_get_type_descriptor(*args):
    """
    StepShape_ClosedShell_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepShape.StepShape_ClosedShell_get_type_descriptor(*args)

class StepShape_Sphere(StepGeom.StepGeom_GeometricRepresentationItem):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepShape_Sphere
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepShape_Sphere(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepShape_Sphere self) -> StepShape_Sphere

        Returns a Sphere


        """
        this = _StepShape.new_StepShape_Sphere(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepShape_Sphere self, Handle_TCollection_HAsciiString aName, Standard_Real const aRadius, Handle_StepGeom_Point aCentre)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aRadius: float
        :type aCentre: OCC.wrapper.StepShape.Handle_StepGeom_Point

        """
        return _StepShape.StepShape_Sphere_Init(self, *args)


    def SetRadius(self, *args):
        """
        SetRadius(StepShape_Sphere self, Standard_Real const aRadius)

        :type aRadius: float

        """
        return _StepShape.StepShape_Sphere_SetRadius(self, *args)


    def Radius(self, *args):
        """
        Radius(StepShape_Sphere self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _StepShape.StepShape_Sphere_Radius(self, *args)


    def SetCentre(self, *args):
        """
        SetCentre(StepShape_Sphere self, Handle_StepGeom_Point aCentre)

        :type aCentre: OCC.wrapper.StepShape.Handle_StepGeom_Point

        """
        return _StepShape.StepShape_Sphere_SetCentre(self, *args)


    def Centre(self, *args):
        """
        Centre(StepShape_Sphere self) -> Handle_StepGeom_Point

        :rtype: OCC.wrapper.StepShape.Handle_StepGeom_Point

        """
        return _StepShape.StepShape_Sphere_Centre(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepShape.StepShape_Sphere_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepShape.StepShape_Sphere_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.StepShape_Sphere_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepShape.delete_StepShape_Sphere
StepShape_Sphere_swigregister = _StepShape.StepShape_Sphere_swigregister
StepShape_Sphere_swigregister(StepShape_Sphere)

def StepShape_Sphere_get_type_name(*args):
    """
    StepShape_Sphere_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepShape.StepShape_Sphere_get_type_name(*args)

def StepShape_Sphere_get_type_descriptor(*args):
    """
    StepShape_Sphere_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepShape.StepShape_Sphere_get_type_descriptor(*args)

class StepShape_DimensionalSizeWithPath(StepShape_DimensionalSize):
    """Representation of STEP entity DimensionalSizeWithPath"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepShape_DimensionalSizeWithPath
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepShape_DimensionalSizeWithPath(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepShape_DimensionalSizeWithPath self) -> StepShape_DimensionalSizeWithPath

        Empty constructor


        """
        this = _StepShape.new_StepShape_DimensionalSizeWithPath(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepShape_DimensionalSizeWithPath self, Handle_StepRepr_ShapeAspect aDimensionalSize_AppliesTo, Handle_TCollection_HAsciiString aDimensionalSize_Name, Handle_StepRepr_ShapeAspect aPath)

        Initialize all fields (own and inherited)

        :type aDimensionalSize_AppliesTo: OCC.wrapper.StepShape.Handle_StepRepr_ShapeAspect
        :type aDimensionalSize_Name: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aPath: OCC.wrapper.StepShape.Handle_StepRepr_ShapeAspect

        """
        return _StepShape.StepShape_DimensionalSizeWithPath_Init(self, *args)


    def Path(self, *args):
        """
        Path(StepShape_DimensionalSizeWithPath self) -> Handle_StepRepr_ShapeAspect

        Returns field Path

        :rtype: OCC.wrapper.StepShape.Handle_StepRepr_ShapeAspect

        """
        return _StepShape.StepShape_DimensionalSizeWithPath_Path(self, *args)


    def SetPath(self, *args):
        """
        SetPath(StepShape_DimensionalSizeWithPath self, Handle_StepRepr_ShapeAspect Path)

        Set field Path

        :type Path: OCC.wrapper.StepShape.Handle_StepRepr_ShapeAspect

        """
        return _StepShape.StepShape_DimensionalSizeWithPath_SetPath(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepShape.StepShape_DimensionalSizeWithPath_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepShape.StepShape_DimensionalSizeWithPath_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.StepShape_DimensionalSizeWithPath_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepShape.delete_StepShape_DimensionalSizeWithPath
StepShape_DimensionalSizeWithPath_swigregister = _StepShape.StepShape_DimensionalSizeWithPath_swigregister
StepShape_DimensionalSizeWithPath_swigregister(StepShape_DimensionalSizeWithPath)

def StepShape_DimensionalSizeWithPath_get_type_name(*args):
    """
    StepShape_DimensionalSizeWithPath_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepShape.StepShape_DimensionalSizeWithPath_get_type_name(*args)

def StepShape_DimensionalSizeWithPath_get_type_descriptor(*args):
    """
    StepShape_DimensionalSizeWithPath_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepShape.StepShape_DimensionalSizeWithPath_get_type_descriptor(*args)

class StepShape_AngularSize(StepShape_DimensionalSize):
    """Representation of STEP entity AngularSize"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepShape_AngularSize
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepShape_AngularSize(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepShape_AngularSize self) -> StepShape_AngularSize

        Empty constructor


        """
        this = _StepShape.new_StepShape_AngularSize(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepShape_AngularSize self, Handle_StepRepr_ShapeAspect aDimensionalSize_AppliesTo, Handle_TCollection_HAsciiString aDimensionalSize_Name, StepShape_AngleRelator const aAngleSelection)

        Initialize all fields (own and inherited)

        :type aDimensionalSize_AppliesTo: OCC.wrapper.StepShape.Handle_StepRepr_ShapeAspect
        :type aDimensionalSize_Name: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aAngleSelection: OCC.wrapper.StepShape.StepShape_AngleRelator

        """
        return _StepShape.StepShape_AngularSize_Init(self, *args)


    def AngleSelection(self, *args):
        """
        AngleSelection(StepShape_AngularSize self) -> StepShape_AngleRelator

        Returns field AngleSelection

        :rtype: OCC.wrapper.StepShape.StepShape_AngleRelator

        """
        return _StepShape.StepShape_AngularSize_AngleSelection(self, *args)


    def SetAngleSelection(self, *args):
        """
        SetAngleSelection(StepShape_AngularSize self, StepShape_AngleRelator const AngleSelection)

        Set field AngleSelection

        :type AngleSelection: OCC.wrapper.StepShape.StepShape_AngleRelator

        """
        return _StepShape.StepShape_AngularSize_SetAngleSelection(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepShape.StepShape_AngularSize_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepShape.StepShape_AngularSize_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.StepShape_AngularSize_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepShape.delete_StepShape_AngularSize
StepShape_AngularSize_swigregister = _StepShape.StepShape_AngularSize_swigregister
StepShape_AngularSize_swigregister(StepShape_AngularSize)

def StepShape_AngularSize_get_type_name(*args):
    """
    StepShape_AngularSize_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepShape.StepShape_AngularSize_get_type_name(*args)

def StepShape_AngularSize_get_type_descriptor(*args):
    """
    StepShape_AngularSize_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepShape.StepShape_AngularSize_get_type_descriptor(*args)

class StepShape_OrientedEdge(StepShape_Edge):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepShape_OrientedEdge
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepShape_OrientedEdge(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepShape_OrientedEdge self) -> StepShape_OrientedEdge

        Returns a OrientedEdge


        """
        this = _StepShape.new_StepShape_OrientedEdge(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepShape_OrientedEdge self, Handle_TCollection_HAsciiString aName, Handle_StepShape_Edge aEdgeElement, Standard_Boolean const aOrientation)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aEdgeElement: OCC.wrapper.StepShape.Handle_StepShape_Edge
        :type aOrientation: bool

        """
        return _StepShape.StepShape_OrientedEdge_Init(self, *args)


    def SetEdgeElement(self, *args):
        """
        SetEdgeElement(StepShape_OrientedEdge self, Handle_StepShape_Edge aEdgeElement)

        :type aEdgeElement: OCC.wrapper.StepShape.Handle_StepShape_Edge

        """
        return _StepShape.StepShape_OrientedEdge_SetEdgeElement(self, *args)


    def EdgeElement(self, *args):
        """
        EdgeElement(StepShape_OrientedEdge self) -> Handle_StepShape_Edge

        :rtype: OCC.wrapper.StepShape.Handle_StepShape_Edge

        """
        return _StepShape.StepShape_OrientedEdge_EdgeElement(self, *args)


    def SetOrientation(self, *args):
        """
        SetOrientation(StepShape_OrientedEdge self, Standard_Boolean const aOrientation)

        :type aOrientation: bool

        """
        return _StepShape.StepShape_OrientedEdge_SetOrientation(self, *args)


    def Orientation(self, *args):
        """
        Orientation(StepShape_OrientedEdge self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.StepShape_OrientedEdge_Orientation(self, *args)


    def SetEdgeStart(self, *args):
        """
        SetEdgeStart(StepShape_OrientedEdge self, Handle_StepShape_Vertex aEdgeStart)

        :type aEdgeStart: OCC.wrapper.StepShape.Handle_StepShape_Vertex

        """
        return _StepShape.StepShape_OrientedEdge_SetEdgeStart(self, *args)


    def EdgeStart(self, *args):
        """
        EdgeStart(StepShape_OrientedEdge self) -> Handle_StepShape_Vertex

        :rtype: OCC.wrapper.StepShape.Handle_StepShape_Vertex

        """
        return _StepShape.StepShape_OrientedEdge_EdgeStart(self, *args)


    def SetEdgeEnd(self, *args):
        """
        SetEdgeEnd(StepShape_OrientedEdge self, Handle_StepShape_Vertex aEdgeEnd)

        :type aEdgeEnd: OCC.wrapper.StepShape.Handle_StepShape_Vertex

        """
        return _StepShape.StepShape_OrientedEdge_SetEdgeEnd(self, *args)


    def EdgeEnd(self, *args):
        """
        EdgeEnd(StepShape_OrientedEdge self) -> Handle_StepShape_Vertex

        :rtype: OCC.wrapper.StepShape.Handle_StepShape_Vertex

        """
        return _StepShape.StepShape_OrientedEdge_EdgeEnd(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepShape.StepShape_OrientedEdge_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepShape.StepShape_OrientedEdge_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.StepShape_OrientedEdge_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepShape.delete_StepShape_OrientedEdge
StepShape_OrientedEdge_swigregister = _StepShape.StepShape_OrientedEdge_swigregister
StepShape_OrientedEdge_swigregister(StepShape_OrientedEdge)

def StepShape_OrientedEdge_get_type_name(*args):
    """
    StepShape_OrientedEdge_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepShape.StepShape_OrientedEdge_get_type_name(*args)

def StepShape_OrientedEdge_get_type_descriptor(*args):
    """
    StepShape_OrientedEdge_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepShape.StepShape_OrientedEdge_get_type_descriptor(*args)

class StepShape_HalfSpaceSolid(StepGeom.StepGeom_GeometricRepresentationItem):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepShape_HalfSpaceSolid
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepShape_HalfSpaceSolid(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepShape_HalfSpaceSolid self) -> StepShape_HalfSpaceSolid

        Returns a HalfSpaceSolid


        """
        this = _StepShape.new_StepShape_HalfSpaceSolid(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepShape_HalfSpaceSolid self, Handle_TCollection_HAsciiString aName, Handle_StepGeom_Surface aBaseSurface, Standard_Boolean const aAgreementFlag)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aBaseSurface: OCC.wrapper.StepShape.Handle_StepGeom_Surface
        :type aAgreementFlag: bool

        """
        return _StepShape.StepShape_HalfSpaceSolid_Init(self, *args)


    def SetBaseSurface(self, *args):
        """
        SetBaseSurface(StepShape_HalfSpaceSolid self, Handle_StepGeom_Surface aBaseSurface)

        :type aBaseSurface: OCC.wrapper.StepShape.Handle_StepGeom_Surface

        """
        return _StepShape.StepShape_HalfSpaceSolid_SetBaseSurface(self, *args)


    def BaseSurface(self, *args):
        """
        BaseSurface(StepShape_HalfSpaceSolid self) -> Handle_StepGeom_Surface

        :rtype: OCC.wrapper.StepShape.Handle_StepGeom_Surface

        """
        return _StepShape.StepShape_HalfSpaceSolid_BaseSurface(self, *args)


    def SetAgreementFlag(self, *args):
        """
        SetAgreementFlag(StepShape_HalfSpaceSolid self, Standard_Boolean const aAgreementFlag)

        :type aAgreementFlag: bool

        """
        return _StepShape.StepShape_HalfSpaceSolid_SetAgreementFlag(self, *args)


    def AgreementFlag(self, *args):
        """
        AgreementFlag(StepShape_HalfSpaceSolid self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.StepShape_HalfSpaceSolid_AgreementFlag(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepShape.StepShape_HalfSpaceSolid_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepShape.StepShape_HalfSpaceSolid_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.StepShape_HalfSpaceSolid_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepShape.delete_StepShape_HalfSpaceSolid
StepShape_HalfSpaceSolid_swigregister = _StepShape.StepShape_HalfSpaceSolid_swigregister
StepShape_HalfSpaceSolid_swigregister(StepShape_HalfSpaceSolid)

def StepShape_HalfSpaceSolid_get_type_name(*args):
    """
    StepShape_HalfSpaceSolid_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepShape.StepShape_HalfSpaceSolid_get_type_name(*args)

def StepShape_HalfSpaceSolid_get_type_descriptor(*args):
    """
    StepShape_HalfSpaceSolid_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepShape.StepShape_HalfSpaceSolid_get_type_descriptor(*args)

class StepShape_FaceBound(StepShape_TopologicalRepresentationItem):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepShape_FaceBound
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepShape_FaceBound(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepShape_FaceBound self) -> StepShape_FaceBound

        Returns a FaceBound


        """
        this = _StepShape.new_StepShape_FaceBound(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepShape_FaceBound self, Handle_TCollection_HAsciiString aName, Handle_StepShape_Loop aBound, Standard_Boolean const aOrientation)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aBound: OCC.wrapper.StepShape.Handle_StepShape_Loop
        :type aOrientation: bool

        """
        return _StepShape.StepShape_FaceBound_Init(self, *args)


    def SetBound(self, *args):
        """
        SetBound(StepShape_FaceBound self, Handle_StepShape_Loop aBound)

        :type aBound: OCC.wrapper.StepShape.Handle_StepShape_Loop

        """
        return _StepShape.StepShape_FaceBound_SetBound(self, *args)


    def Bound(self, *args):
        """
        Bound(StepShape_FaceBound self) -> Handle_StepShape_Loop

        :rtype: OCC.wrapper.StepShape.Handle_StepShape_Loop

        """
        return _StepShape.StepShape_FaceBound_Bound(self, *args)


    def SetOrientation(self, *args):
        """
        SetOrientation(StepShape_FaceBound self, Standard_Boolean const aOrientation)

        :type aOrientation: bool

        """
        return _StepShape.StepShape_FaceBound_SetOrientation(self, *args)


    def Orientation(self, *args):
        """
        Orientation(StepShape_FaceBound self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.StepShape_FaceBound_Orientation(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepShape.StepShape_FaceBound_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepShape.StepShape_FaceBound_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.StepShape_FaceBound_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepShape.delete_StepShape_FaceBound
StepShape_FaceBound_swigregister = _StepShape.StepShape_FaceBound_swigregister
StepShape_FaceBound_swigregister(StepShape_FaceBound)

def StepShape_FaceBound_get_type_name(*args):
    """
    StepShape_FaceBound_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepShape.StepShape_FaceBound_get_type_name(*args)

def StepShape_FaceBound_get_type_descriptor(*args):
    """
    StepShape_FaceBound_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepShape.StepShape_FaceBound_get_type_descriptor(*args)

class StepShape_BooleanResult(StepGeom.StepGeom_GeometricRepresentationItem):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepShape_BooleanResult
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepShape_BooleanResult(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepShape_BooleanResult self) -> StepShape_BooleanResult

        Returns a BooleanResult


        """
        this = _StepShape.new_StepShape_BooleanResult(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepShape_BooleanResult self, Handle_TCollection_HAsciiString aName, StepShape_BooleanOperator const aOperator, StepShape_BooleanOperand aFirstOperand, StepShape_BooleanOperand aSecondOperand)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aOperator: OCC.wrapper.StepShape.StepShape_BooleanOperator
        :type aFirstOperand: OCC.wrapper.StepShape.StepShape_BooleanOperand
        :type aSecondOperand: OCC.wrapper.StepShape.StepShape_BooleanOperand

        """
        return _StepShape.StepShape_BooleanResult_Init(self, *args)


    def SetOperator(self, *args):
        """
        SetOperator(StepShape_BooleanResult self, StepShape_BooleanOperator const aOperator)

        :type aOperator: OCC.wrapper.StepShape.StepShape_BooleanOperator

        """
        return _StepShape.StepShape_BooleanResult_SetOperator(self, *args)


    def Operator(self, *args):
        """
        Operator(StepShape_BooleanResult self) -> StepShape_BooleanOperator

        :rtype: OCC.wrapper.StepShape.StepShape_BooleanOperator

        """
        return _StepShape.StepShape_BooleanResult_Operator(self, *args)


    def SetFirstOperand(self, *args):
        """
        SetFirstOperand(StepShape_BooleanResult self, StepShape_BooleanOperand aFirstOperand)

        :type aFirstOperand: OCC.wrapper.StepShape.StepShape_BooleanOperand

        """
        return _StepShape.StepShape_BooleanResult_SetFirstOperand(self, *args)


    def FirstOperand(self, *args):
        """
        FirstOperand(StepShape_BooleanResult self) -> StepShape_BooleanOperand

        :rtype: OCC.wrapper.StepShape.StepShape_BooleanOperand

        """
        return _StepShape.StepShape_BooleanResult_FirstOperand(self, *args)


    def SetSecondOperand(self, *args):
        """
        SetSecondOperand(StepShape_BooleanResult self, StepShape_BooleanOperand aSecondOperand)

        :type aSecondOperand: OCC.wrapper.StepShape.StepShape_BooleanOperand

        """
        return _StepShape.StepShape_BooleanResult_SetSecondOperand(self, *args)


    def SecondOperand(self, *args):
        """
        SecondOperand(StepShape_BooleanResult self) -> StepShape_BooleanOperand

        :rtype: OCC.wrapper.StepShape.StepShape_BooleanOperand

        """
        return _StepShape.StepShape_BooleanResult_SecondOperand(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepShape.StepShape_BooleanResult_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepShape.StepShape_BooleanResult_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.StepShape_BooleanResult_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepShape.delete_StepShape_BooleanResult
StepShape_BooleanResult_swigregister = _StepShape.StepShape_BooleanResult_swigregister
StepShape_BooleanResult_swigregister(StepShape_BooleanResult)

def StepShape_BooleanResult_get_type_name(*args):
    """
    StepShape_BooleanResult_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepShape.StepShape_BooleanResult_get_type_name(*args)

def StepShape_BooleanResult_get_type_descriptor(*args):
    """
    StepShape_BooleanResult_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepShape.StepShape_BooleanResult_get_type_descriptor(*args)

class StepShape_ShapeDimensionRepresentationItem(StepData.StepData_SelectType):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(StepShape_ShapeDimensionRepresentationItem self) -> StepShape_ShapeDimensionRepresentationItem

        Returns a ShapeDimensionRepresentationItem select type


        """
        this = _StepShape.new_StepShape_ShapeDimensionRepresentationItem(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def CaseNum(self, *args):
        """
        CaseNum(StepShape_ShapeDimensionRepresentationItem self, Handle_Standard_Transient ent) -> Standard_Integer

        Recognizes a ShapeDimensionRepresentationItem Kind Entity that is :
        1 -> CompoundRepresentationItem
        2 -> DescriptiveRepresentationItem
        3 -> MeasureRepresentationItem
        4 -> Placement
        0 else

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.StepShape_ShapeDimensionRepresentationItem_CaseNum(self, *args)


    def CompoundRepresentationItem(self, *args):
        """
        CompoundRepresentationItem(StepShape_ShapeDimensionRepresentationItem self) -> Handle_StepRepr_CompoundRepresentationItem

        returns Value as a CompoundRepresentationItem (Null if another type)

        :rtype: OCC.wrapper.StepShape.Handle_StepRepr_CompoundRepresentationItem

        """
        return _StepShape.StepShape_ShapeDimensionRepresentationItem_CompoundRepresentationItem(self, *args)


    def DescriptiveRepresentationItem(self, *args):
        """
        DescriptiveRepresentationItem(StepShape_ShapeDimensionRepresentationItem self) -> Handle_StepRepr_DescriptiveRepresentationItem

        returns Value as a DescriptiveRepresentationItem (Null if another type)

        :rtype: OCC.wrapper.StepShape.Handle_StepRepr_DescriptiveRepresentationItem

        """
        return _StepShape.StepShape_ShapeDimensionRepresentationItem_DescriptiveRepresentationItem(self, *args)


    def MeasureRepresentationItem(self, *args):
        """
        MeasureRepresentationItem(StepShape_ShapeDimensionRepresentationItem self) -> Handle_StepRepr_MeasureRepresentationItem

        returns Value as a MeasureRepresentationItem (Null if another type)

        :rtype: OCC.wrapper.StepShape.Handle_StepRepr_MeasureRepresentationItem

        """
        return _StepShape.StepShape_ShapeDimensionRepresentationItem_MeasureRepresentationItem(self, *args)


    def Placement(self, *args):
        """
        Placement(StepShape_ShapeDimensionRepresentationItem self) -> Handle_StepGeom_Placement

        returns Value as a Placement (Null if another type)

        :rtype: OCC.wrapper.StepShape.Handle_StepGeom_Placement

        """
        return _StepShape.StepShape_ShapeDimensionRepresentationItem_Placement(self, *args)

    __swig_destroy__ = _StepShape.delete_StepShape_ShapeDimensionRepresentationItem
StepShape_ShapeDimensionRepresentationItem_swigregister = _StepShape.StepShape_ShapeDimensionRepresentationItem_swigregister
StepShape_ShapeDimensionRepresentationItem_swigregister(StepShape_ShapeDimensionRepresentationItem)

class StepShape_Torus(StepGeom.StepGeom_GeometricRepresentationItem):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepShape_Torus
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepShape_Torus(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepShape_Torus self) -> StepShape_Torus

        Returns a Torus


        """
        this = _StepShape.new_StepShape_Torus(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepShape_Torus self, Handle_TCollection_HAsciiString aName, Handle_StepGeom_Axis1Placement aPosition, Standard_Real const aMajorRadius, Standard_Real const aMinorRadius)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aPosition: OCC.wrapper.StepShape.Handle_StepGeom_Axis1Placement
        :type aMajorRadius: float
        :type aMinorRadius: float

        """
        return _StepShape.StepShape_Torus_Init(self, *args)


    def SetPosition(self, *args):
        """
        SetPosition(StepShape_Torus self, Handle_StepGeom_Axis1Placement aPosition)

        :type aPosition: OCC.wrapper.StepShape.Handle_StepGeom_Axis1Placement

        """
        return _StepShape.StepShape_Torus_SetPosition(self, *args)


    def Position(self, *args):
        """
        Position(StepShape_Torus self) -> Handle_StepGeom_Axis1Placement

        :rtype: OCC.wrapper.StepShape.Handle_StepGeom_Axis1Placement

        """
        return _StepShape.StepShape_Torus_Position(self, *args)


    def SetMajorRadius(self, *args):
        """
        SetMajorRadius(StepShape_Torus self, Standard_Real const aMajorRadius)

        :type aMajorRadius: float

        """
        return _StepShape.StepShape_Torus_SetMajorRadius(self, *args)


    def MajorRadius(self, *args):
        """
        MajorRadius(StepShape_Torus self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _StepShape.StepShape_Torus_MajorRadius(self, *args)


    def SetMinorRadius(self, *args):
        """
        SetMinorRadius(StepShape_Torus self, Standard_Real const aMinorRadius)

        :type aMinorRadius: float

        """
        return _StepShape.StepShape_Torus_SetMinorRadius(self, *args)


    def MinorRadius(self, *args):
        """
        MinorRadius(StepShape_Torus self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _StepShape.StepShape_Torus_MinorRadius(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepShape.StepShape_Torus_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepShape.StepShape_Torus_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.StepShape_Torus_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepShape.delete_StepShape_Torus
StepShape_Torus_swigregister = _StepShape.StepShape_Torus_swigregister
StepShape_Torus_swigregister(StepShape_Torus)

def StepShape_Torus_get_type_name(*args):
    """
    StepShape_Torus_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepShape.StepShape_Torus_get_type_name(*args)

def StepShape_Torus_get_type_descriptor(*args):
    """
    StepShape_Torus_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepShape.StepShape_Torus_get_type_descriptor(*args)

class StepShape_VertexLoop(StepShape_Loop):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepShape_VertexLoop
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepShape_VertexLoop(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepShape_VertexLoop self) -> StepShape_VertexLoop

        Returns a VertexLoop


        """
        this = _StepShape.new_StepShape_VertexLoop(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepShape_VertexLoop self, Handle_TCollection_HAsciiString aName, Handle_StepShape_Vertex aLoopVertex)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aLoopVertex: OCC.wrapper.StepShape.Handle_StepShape_Vertex

        """
        return _StepShape.StepShape_VertexLoop_Init(self, *args)


    def SetLoopVertex(self, *args):
        """
        SetLoopVertex(StepShape_VertexLoop self, Handle_StepShape_Vertex aLoopVertex)

        :type aLoopVertex: OCC.wrapper.StepShape.Handle_StepShape_Vertex

        """
        return _StepShape.StepShape_VertexLoop_SetLoopVertex(self, *args)


    def LoopVertex(self, *args):
        """
        LoopVertex(StepShape_VertexLoop self) -> Handle_StepShape_Vertex

        :rtype: OCC.wrapper.StepShape.Handle_StepShape_Vertex

        """
        return _StepShape.StepShape_VertexLoop_LoopVertex(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepShape.StepShape_VertexLoop_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepShape.StepShape_VertexLoop_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.StepShape_VertexLoop_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepShape.delete_StepShape_VertexLoop
StepShape_VertexLoop_swigregister = _StepShape.StepShape_VertexLoop_swigregister
StepShape_VertexLoop_swigregister(StepShape_VertexLoop)

def StepShape_VertexLoop_get_type_name(*args):
    """
    StepShape_VertexLoop_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepShape.StepShape_VertexLoop_get_type_name(*args)

def StepShape_VertexLoop_get_type_descriptor(*args):
    """
    StepShape_VertexLoop_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepShape.StepShape_VertexLoop_get_type_descriptor(*args)

class StepShape_Path(StepShape_TopologicalRepresentationItem):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepShape_Path
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepShape_Path(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepShape_Path self) -> StepShape_Path

        Returns a Path


        """
        this = _StepShape.new_StepShape_Path(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepShape_Path self, Handle_TCollection_HAsciiString aName, Handle_StepShape_HArray1OfOrientedEdge aEdgeList)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aEdgeList: OCC.wrapper.StepShape.Handle_StepShape_HArray1OfOrientedEdge

        """
        return _StepShape.StepShape_Path_Init(self, *args)


    def SetEdgeList(self, *args):
        """
        SetEdgeList(StepShape_Path self, Handle_StepShape_HArray1OfOrientedEdge aEdgeList)

        :type aEdgeList: OCC.wrapper.StepShape.Handle_StepShape_HArray1OfOrientedEdge

        """
        return _StepShape.StepShape_Path_SetEdgeList(self, *args)


    def EdgeList(self, *args):
        """
        EdgeList(StepShape_Path self) -> Handle_StepShape_HArray1OfOrientedEdge

        :rtype: OCC.wrapper.StepShape.Handle_StepShape_HArray1OfOrientedEdge

        """
        return _StepShape.StepShape_Path_EdgeList(self, *args)


    def EdgeListValue(self, *args):
        """
        EdgeListValue(StepShape_Path self, Standard_Integer const num) -> Handle_StepShape_OrientedEdge

        :type num: int
        :rtype: OCC.wrapper.StepShape.Handle_StepShape_OrientedEdge

        """
        return _StepShape.StepShape_Path_EdgeListValue(self, *args)


    def NbEdgeList(self, *args):
        """
        NbEdgeList(StepShape_Path self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.StepShape_Path_NbEdgeList(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepShape.StepShape_Path_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepShape.StepShape_Path_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.StepShape_Path_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepShape.delete_StepShape_Path
StepShape_Path_swigregister = _StepShape.StepShape_Path_swigregister
StepShape_Path_swigregister(StepShape_Path)

def StepShape_Path_get_type_name(*args):
    """
    StepShape_Path_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepShape.StepShape_Path_get_type_name(*args)

def StepShape_Path_get_type_descriptor(*args):
    """
    StepShape_Path_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepShape.StepShape_Path_get_type_descriptor(*args)

class StepShape_CsgSolid(StepShape_SolidModel):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepShape_CsgSolid
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepShape_CsgSolid(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepShape_CsgSolid self) -> StepShape_CsgSolid

        Returns a CsgSolid


        """
        this = _StepShape.new_StepShape_CsgSolid(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepShape_CsgSolid self, Handle_TCollection_HAsciiString aName, StepShape_CsgSelect aTreeRootExpression)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aTreeRootExpression: OCC.wrapper.StepShape.StepShape_CsgSelect

        """
        return _StepShape.StepShape_CsgSolid_Init(self, *args)


    def SetTreeRootExpression(self, *args):
        """
        SetTreeRootExpression(StepShape_CsgSolid self, StepShape_CsgSelect aTreeRootExpression)

        :type aTreeRootExpression: OCC.wrapper.StepShape.StepShape_CsgSelect

        """
        return _StepShape.StepShape_CsgSolid_SetTreeRootExpression(self, *args)


    def TreeRootExpression(self, *args):
        """
        TreeRootExpression(StepShape_CsgSolid self) -> StepShape_CsgSelect

        :rtype: OCC.wrapper.StepShape.StepShape_CsgSelect

        """
        return _StepShape.StepShape_CsgSolid_TreeRootExpression(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepShape.StepShape_CsgSolid_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepShape.StepShape_CsgSolid_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.StepShape_CsgSolid_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepShape.delete_StepShape_CsgSolid
StepShape_CsgSolid_swigregister = _StepShape.StepShape_CsgSolid_swigregister
StepShape_CsgSolid_swigregister(StepShape_CsgSolid)

def StepShape_CsgSolid_get_type_name(*args):
    """
    StepShape_CsgSolid_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepShape.StepShape_CsgSolid_get_type_name(*args)

def StepShape_CsgSolid_get_type_descriptor(*args):
    """
    StepShape_CsgSolid_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepShape.StepShape_CsgSolid_get_type_descriptor(*args)

class StepShape_ConnectedFaceSubSet(StepShape_ConnectedFaceSet):
    """Representation of STEP entity ConnectedFaceSubSet"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepShape_ConnectedFaceSubSet
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepShape_ConnectedFaceSubSet(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepShape_ConnectedFaceSubSet self) -> StepShape_ConnectedFaceSubSet

        Empty constructor


        """
        this = _StepShape.new_StepShape_ConnectedFaceSubSet(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepShape_ConnectedFaceSubSet self, Handle_TCollection_HAsciiString aRepresentationItem_Name, Handle_StepShape_HArray1OfFace aConnectedFaceSet_CfsFaces, Handle_StepShape_ConnectedFaceSet aParentFaceSet)

        Initialize all fields (own and inherited)

        :type aRepresentationItem_Name: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aConnectedFaceSet_CfsFaces: OCC.wrapper.StepShape.Handle_StepShape_HArray1OfFace
        :type aParentFaceSet: OCC.wrapper.StepShape.Handle_StepShape_ConnectedFaceSet

        """
        return _StepShape.StepShape_ConnectedFaceSubSet_Init(self, *args)


    def ParentFaceSet(self, *args):
        """
        ParentFaceSet(StepShape_ConnectedFaceSubSet self) -> Handle_StepShape_ConnectedFaceSet

        Returns field ParentFaceSet

        :rtype: OCC.wrapper.StepShape.Handle_StepShape_ConnectedFaceSet

        """
        return _StepShape.StepShape_ConnectedFaceSubSet_ParentFaceSet(self, *args)


    def SetParentFaceSet(self, *args):
        """
        SetParentFaceSet(StepShape_ConnectedFaceSubSet self, Handle_StepShape_ConnectedFaceSet ParentFaceSet)

        Set field ParentFaceSet

        :type ParentFaceSet: OCC.wrapper.StepShape.Handle_StepShape_ConnectedFaceSet

        """
        return _StepShape.StepShape_ConnectedFaceSubSet_SetParentFaceSet(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepShape.StepShape_ConnectedFaceSubSet_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepShape.StepShape_ConnectedFaceSubSet_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.StepShape_ConnectedFaceSubSet_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepShape.delete_StepShape_ConnectedFaceSubSet
StepShape_ConnectedFaceSubSet_swigregister = _StepShape.StepShape_ConnectedFaceSubSet_swigregister
StepShape_ConnectedFaceSubSet_swigregister(StepShape_ConnectedFaceSubSet)

def StepShape_ConnectedFaceSubSet_get_type_name(*args):
    """
    StepShape_ConnectedFaceSubSet_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepShape.StepShape_ConnectedFaceSubSet_get_type_name(*args)

def StepShape_ConnectedFaceSubSet_get_type_descriptor(*args):
    """
    StepShape_ConnectedFaceSubSet_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepShape.StepShape_ConnectedFaceSubSet_get_type_descriptor(*args)

class StepShape_HArray1OfOrientedEdge(Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepShape_HArray1OfOrientedEdge
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepShape_HArray1OfOrientedEdge(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepShape_HArray1OfOrientedEdge self, Standard_Integer const theLower, Standard_Integer const theUpper) -> StepShape_HArray1OfOrientedEdge
        __init__(StepShape_HArray1OfOrientedEdge self, Standard_Integer const theLower, Standard_Integer const theUpper, Handle_StepShape_OrientedEdge theValue) -> StepShape_HArray1OfOrientedEdge
        __init__(StepShape_HArray1OfOrientedEdge self, NCollection_Array1_Handle_StepShape_OrientedEdge theOther) -> StepShape_HArray1OfOrientedEdge

        :type theOther: OCC.wrapper.StepShape.StepShape_Array1OfOrientedEdge

        """
        this = _StepShape.new_StepShape_HArray1OfOrientedEdge(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Array1(self, *args):
        """
        :rtype: OCC.wrapper.StepShape.StepShape_Array1OfOrientedEdge

        """
        res = _StepShape.StepShape_HArray1OfOrientedEdge_Array1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeArray1(self, *args):
        """
        ChangeArray1(StepShape_HArray1OfOrientedEdge self) -> NCollection_Array1_Handle_StepShape_OrientedEdge

        :rtype: OCC.wrapper.StepShape.StepShape_Array1OfOrientedEdge

        """
        return _StepShape.StepShape_HArray1OfOrientedEdge_ChangeArray1(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepShape.StepShape_HArray1OfOrientedEdge_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepShape.StepShape_HArray1OfOrientedEdge_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.StepShape_HArray1OfOrientedEdge_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepShape.delete_StepShape_HArray1OfOrientedEdge
StepShape_HArray1OfOrientedEdge_swigregister = _StepShape.StepShape_HArray1OfOrientedEdge_swigregister
StepShape_HArray1OfOrientedEdge_swigregister(StepShape_HArray1OfOrientedEdge)

def StepShape_HArray1OfOrientedEdge_get_type_name(*args):
    """
    StepShape_HArray1OfOrientedEdge_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepShape.StepShape_HArray1OfOrientedEdge_get_type_name(*args)

def StepShape_HArray1OfOrientedEdge_get_type_descriptor(*args):
    """
    StepShape_HArray1OfOrientedEdge_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepShape.StepShape_HArray1OfOrientedEdge_get_type_descriptor(*args)

class StepShape_Subedge(StepShape_Edge):
    """Representation of STEP entity Subedge"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepShape_Subedge
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepShape_Subedge(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepShape_Subedge self) -> StepShape_Subedge

        Empty constructor


        """
        this = _StepShape.new_StepShape_Subedge(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepShape_Subedge self, Handle_TCollection_HAsciiString aRepresentationItem_Name, Handle_StepShape_Vertex aEdge_EdgeStart, Handle_StepShape_Vertex aEdge_EdgeEnd, Handle_StepShape_Edge aParentEdge)

        Initialize all fields (own and inherited)

        :type aRepresentationItem_Name: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aEdge_EdgeStart: OCC.wrapper.StepShape.Handle_StepShape_Vertex
        :type aEdge_EdgeEnd: OCC.wrapper.StepShape.Handle_StepShape_Vertex
        :type aParentEdge: OCC.wrapper.StepShape.Handle_StepShape_Edge

        """
        return _StepShape.StepShape_Subedge_Init(self, *args)


    def ParentEdge(self, *args):
        """
        ParentEdge(StepShape_Subedge self) -> Handle_StepShape_Edge

        Returns field ParentEdge

        :rtype: OCC.wrapper.StepShape.Handle_StepShape_Edge

        """
        return _StepShape.StepShape_Subedge_ParentEdge(self, *args)


    def SetParentEdge(self, *args):
        """
        SetParentEdge(StepShape_Subedge self, Handle_StepShape_Edge ParentEdge)

        Set field ParentEdge

        :type ParentEdge: OCC.wrapper.StepShape.Handle_StepShape_Edge

        """
        return _StepShape.StepShape_Subedge_SetParentEdge(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepShape.StepShape_Subedge_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepShape.StepShape_Subedge_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.StepShape_Subedge_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepShape.delete_StepShape_Subedge
StepShape_Subedge_swigregister = _StepShape.StepShape_Subedge_swigregister
StepShape_Subedge_swigregister(StepShape_Subedge)

def StepShape_Subedge_get_type_name(*args):
    """
    StepShape_Subedge_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepShape.StepShape_Subedge_get_type_name(*args)

def StepShape_Subedge_get_type_descriptor(*args):
    """
    StepShape_Subedge_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepShape.StepShape_Subedge_get_type_descriptor(*args)

class StepShape_FacetedBrep(StepShape_ManifoldSolidBrep):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepShape_FacetedBrep
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepShape_FacetedBrep(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepShape_FacetedBrep self) -> StepShape_FacetedBrep

        Returns a FacetedBrep


        """
        this = _StepShape.new_StepShape_FacetedBrep(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepShape.StepShape_FacetedBrep_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepShape.StepShape_FacetedBrep_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.StepShape_FacetedBrep_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepShape.delete_StepShape_FacetedBrep
StepShape_FacetedBrep_swigregister = _StepShape.StepShape_FacetedBrep_swigregister
StepShape_FacetedBrep_swigregister(StepShape_FacetedBrep)

def StepShape_FacetedBrep_get_type_name(*args):
    """
    StepShape_FacetedBrep_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepShape.StepShape_FacetedBrep_get_type_name(*args)

def StepShape_FacetedBrep_get_type_descriptor(*args):
    """
    StepShape_FacetedBrep_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepShape.StepShape_FacetedBrep_get_type_descriptor(*args)

class StepShape_ShapeRepresentation(StepRepr.StepRepr_Representation):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepShape_ShapeRepresentation
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepShape_ShapeRepresentation(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepShape_ShapeRepresentation self) -> StepShape_ShapeRepresentation

        Returns a ShapeRepresentation


        """
        this = _StepShape.new_StepShape_ShapeRepresentation(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepShape.StepShape_ShapeRepresentation_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepShape.StepShape_ShapeRepresentation_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.StepShape_ShapeRepresentation_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepShape.delete_StepShape_ShapeRepresentation
StepShape_ShapeRepresentation_swigregister = _StepShape.StepShape_ShapeRepresentation_swigregister
StepShape_ShapeRepresentation_swigregister(StepShape_ShapeRepresentation)

def StepShape_ShapeRepresentation_get_type_name(*args):
    """
    StepShape_ShapeRepresentation_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepShape.StepShape_ShapeRepresentation_get_type_name(*args)

def StepShape_ShapeRepresentation_get_type_descriptor(*args):
    """
    StepShape_ShapeRepresentation_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepShape.StepShape_ShapeRepresentation_get_type_descriptor(*args)

class StepShape_HArray1OfValueQualifier(Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepShape_HArray1OfValueQualifier
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepShape_HArray1OfValueQualifier(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepShape_HArray1OfValueQualifier self, Standard_Integer const theLower, Standard_Integer const theUpper) -> StepShape_HArray1OfValueQualifier
        __init__(StepShape_HArray1OfValueQualifier self, Standard_Integer const theLower, Standard_Integer const theUpper, StepShape_ValueQualifier theValue) -> StepShape_HArray1OfValueQualifier
        __init__(StepShape_HArray1OfValueQualifier self, NCollection_Array1_StepShape_ValueQualifier theOther) -> StepShape_HArray1OfValueQualifier

        :type theOther: OCC.wrapper.StepShape.StepShape_Array1OfValueQualifier

        """
        this = _StepShape.new_StepShape_HArray1OfValueQualifier(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Array1(self, *args):
        """
        :rtype: OCC.wrapper.StepShape.StepShape_Array1OfValueQualifier

        """
        res = _StepShape.StepShape_HArray1OfValueQualifier_Array1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeArray1(self, *args):
        """
        ChangeArray1(StepShape_HArray1OfValueQualifier self) -> NCollection_Array1_StepShape_ValueQualifier

        :rtype: OCC.wrapper.StepShape.StepShape_Array1OfValueQualifier

        """
        return _StepShape.StepShape_HArray1OfValueQualifier_ChangeArray1(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepShape.StepShape_HArray1OfValueQualifier_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepShape.StepShape_HArray1OfValueQualifier_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.StepShape_HArray1OfValueQualifier_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepShape.delete_StepShape_HArray1OfValueQualifier
StepShape_HArray1OfValueQualifier_swigregister = _StepShape.StepShape_HArray1OfValueQualifier_swigregister
StepShape_HArray1OfValueQualifier_swigregister(StepShape_HArray1OfValueQualifier)

def StepShape_HArray1OfValueQualifier_get_type_name(*args):
    """
    StepShape_HArray1OfValueQualifier_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepShape.StepShape_HArray1OfValueQualifier_get_type_name(*args)

def StepShape_HArray1OfValueQualifier_get_type_descriptor(*args):
    """
    StepShape_HArray1OfValueQualifier_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepShape.StepShape_HArray1OfValueQualifier_get_type_descriptor(*args)

class StepShape_ShapeDefinitionRepresentation(StepRepr.StepRepr_PropertyDefinitionRepresentation):
    """Representation of STEP entity ShapeDefinitionRepresentation"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepShape_ShapeDefinitionRepresentation
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepShape_ShapeDefinitionRepresentation(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepShape_ShapeDefinitionRepresentation self) -> StepShape_ShapeDefinitionRepresentation

        Empty constructor


        """
        this = _StepShape.new_StepShape_ShapeDefinitionRepresentation(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepShape.StepShape_ShapeDefinitionRepresentation_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepShape.StepShape_ShapeDefinitionRepresentation_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.StepShape_ShapeDefinitionRepresentation_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepShape.delete_StepShape_ShapeDefinitionRepresentation
StepShape_ShapeDefinitionRepresentation_swigregister = _StepShape.StepShape_ShapeDefinitionRepresentation_swigregister
StepShape_ShapeDefinitionRepresentation_swigregister(StepShape_ShapeDefinitionRepresentation)

def StepShape_ShapeDefinitionRepresentation_get_type_name(*args):
    """
    StepShape_ShapeDefinitionRepresentation_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepShape.StepShape_ShapeDefinitionRepresentation_get_type_name(*args)

def StepShape_ShapeDefinitionRepresentation_get_type_descriptor(*args):
    """
    StepShape_ShapeDefinitionRepresentation_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepShape.StepShape_ShapeDefinitionRepresentation_get_type_descriptor(*args)

class StepShape_SweptFaceSolid(StepShape_SolidModel):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepShape_SweptFaceSolid
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepShape_SweptFaceSolid(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepShape_SweptFaceSolid self) -> StepShape_SweptFaceSolid

        Returns a SweptFaceSolid


        """
        this = _StepShape.new_StepShape_SweptFaceSolid(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepShape_SweptFaceSolid self, Handle_TCollection_HAsciiString aName, Handle_StepShape_FaceSurface aSweptArea)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aSweptArea: OCC.wrapper.StepShape.Handle_StepShape_FaceSurface

        """
        return _StepShape.StepShape_SweptFaceSolid_Init(self, *args)


    def SetSweptFace(self, *args):
        """
        SetSweptFace(StepShape_SweptFaceSolid self, Handle_StepShape_FaceSurface aSweptArea)

        :type aSweptArea: OCC.wrapper.StepShape.Handle_StepShape_FaceSurface

        """
        return _StepShape.StepShape_SweptFaceSolid_SetSweptFace(self, *args)


    def SweptFace(self, *args):
        """
        SweptFace(StepShape_SweptFaceSolid self) -> Handle_StepShape_FaceSurface

        :rtype: OCC.wrapper.StepShape.Handle_StepShape_FaceSurface

        """
        return _StepShape.StepShape_SweptFaceSolid_SweptFace(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepShape.StepShape_SweptFaceSolid_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepShape.StepShape_SweptFaceSolid_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.StepShape_SweptFaceSolid_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepShape.delete_StepShape_SweptFaceSolid
StepShape_SweptFaceSolid_swigregister = _StepShape.StepShape_SweptFaceSolid_swigregister
StepShape_SweptFaceSolid_swigregister(StepShape_SweptFaceSolid)

def StepShape_SweptFaceSolid_get_type_name(*args):
    """
    StepShape_SweptFaceSolid_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepShape.StepShape_SweptFaceSolid_get_type_name(*args)

def StepShape_SweptFaceSolid_get_type_descriptor(*args):
    """
    StepShape_SweptFaceSolid_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepShape.StepShape_SweptFaceSolid_get_type_descriptor(*args)

class StepShape_BrepWithVoids(StepShape_ManifoldSolidBrep):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepShape_BrepWithVoids
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepShape_BrepWithVoids(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepShape_BrepWithVoids self) -> StepShape_BrepWithVoids

        Returns a BrepWithVoids


        """
        this = _StepShape.new_StepShape_BrepWithVoids(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepShape_BrepWithVoids self, Handle_TCollection_HAsciiString aName, Handle_StepShape_ClosedShell aOuter, Handle_StepShape_HArray1OfOrientedClosedShell aVoids)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aOuter: OCC.wrapper.StepShape.Handle_StepShape_ClosedShell
        :type aVoids: OCC.wrapper.StepShape.Handle_StepShape_HArray1OfOrientedClosedShell

        """
        return _StepShape.StepShape_BrepWithVoids_Init(self, *args)


    def SetVoids(self, *args):
        """
        SetVoids(StepShape_BrepWithVoids self, Handle_StepShape_HArray1OfOrientedClosedShell aVoids)

        :type aVoids: OCC.wrapper.StepShape.Handle_StepShape_HArray1OfOrientedClosedShell

        """
        return _StepShape.StepShape_BrepWithVoids_SetVoids(self, *args)


    def Voids(self, *args):
        """
        Voids(StepShape_BrepWithVoids self) -> Handle_StepShape_HArray1OfOrientedClosedShell

        :rtype: OCC.wrapper.StepShape.Handle_StepShape_HArray1OfOrientedClosedShell

        """
        return _StepShape.StepShape_BrepWithVoids_Voids(self, *args)


    def VoidsValue(self, *args):
        """
        VoidsValue(StepShape_BrepWithVoids self, Standard_Integer const num) -> Handle_StepShape_OrientedClosedShell

        :type num: int
        :rtype: OCC.wrapper.StepShape.Handle_StepShape_OrientedClosedShell

        """
        return _StepShape.StepShape_BrepWithVoids_VoidsValue(self, *args)


    def NbVoids(self, *args):
        """
        NbVoids(StepShape_BrepWithVoids self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.StepShape_BrepWithVoids_NbVoids(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepShape.StepShape_BrepWithVoids_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepShape.StepShape_BrepWithVoids_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.StepShape_BrepWithVoids_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepShape.delete_StepShape_BrepWithVoids
StepShape_BrepWithVoids_swigregister = _StepShape.StepShape_BrepWithVoids_swigregister
StepShape_BrepWithVoids_swigregister(StepShape_BrepWithVoids)

def StepShape_BrepWithVoids_get_type_name(*args):
    """
    StepShape_BrepWithVoids_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepShape.StepShape_BrepWithVoids_get_type_name(*args)

def StepShape_BrepWithVoids_get_type_descriptor(*args):
    """
    StepShape_BrepWithVoids_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepShape.StepShape_BrepWithVoids_get_type_descriptor(*args)

class StepShape_RightCircularCylinder(StepGeom.StepGeom_GeometricRepresentationItem):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepShape_RightCircularCylinder
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepShape_RightCircularCylinder(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepShape_RightCircularCylinder self) -> StepShape_RightCircularCylinder

        Returns a RightCircularCylinder


        """
        this = _StepShape.new_StepShape_RightCircularCylinder(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepShape_RightCircularCylinder self, Handle_TCollection_HAsciiString aName, Handle_StepGeom_Axis1Placement aPosition, Standard_Real const aHeight, Standard_Real const aRadius)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aPosition: OCC.wrapper.StepShape.Handle_StepGeom_Axis1Placement
        :type aHeight: float
        :type aRadius: float

        """
        return _StepShape.StepShape_RightCircularCylinder_Init(self, *args)


    def SetPosition(self, *args):
        """
        SetPosition(StepShape_RightCircularCylinder self, Handle_StepGeom_Axis1Placement aPosition)

        :type aPosition: OCC.wrapper.StepShape.Handle_StepGeom_Axis1Placement

        """
        return _StepShape.StepShape_RightCircularCylinder_SetPosition(self, *args)


    def Position(self, *args):
        """
        Position(StepShape_RightCircularCylinder self) -> Handle_StepGeom_Axis1Placement

        :rtype: OCC.wrapper.StepShape.Handle_StepGeom_Axis1Placement

        """
        return _StepShape.StepShape_RightCircularCylinder_Position(self, *args)


    def SetHeight(self, *args):
        """
        SetHeight(StepShape_RightCircularCylinder self, Standard_Real const aHeight)

        :type aHeight: float

        """
        return _StepShape.StepShape_RightCircularCylinder_SetHeight(self, *args)


    def Height(self, *args):
        """
        Height(StepShape_RightCircularCylinder self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _StepShape.StepShape_RightCircularCylinder_Height(self, *args)


    def SetRadius(self, *args):
        """
        SetRadius(StepShape_RightCircularCylinder self, Standard_Real const aRadius)

        :type aRadius: float

        """
        return _StepShape.StepShape_RightCircularCylinder_SetRadius(self, *args)


    def Radius(self, *args):
        """
        Radius(StepShape_RightCircularCylinder self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _StepShape.StepShape_RightCircularCylinder_Radius(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepShape.StepShape_RightCircularCylinder_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepShape.StepShape_RightCircularCylinder_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.StepShape_RightCircularCylinder_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepShape.delete_StepShape_RightCircularCylinder
StepShape_RightCircularCylinder_swigregister = _StepShape.StepShape_RightCircularCylinder_swigregister
StepShape_RightCircularCylinder_swigregister(StepShape_RightCircularCylinder)

def StepShape_RightCircularCylinder_get_type_name(*args):
    """
    StepShape_RightCircularCylinder_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepShape.StepShape_RightCircularCylinder_get_type_name(*args)

def StepShape_RightCircularCylinder_get_type_descriptor(*args):
    """
    StepShape_RightCircularCylinder_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepShape.StepShape_RightCircularCylinder_get_type_descriptor(*args)

class StepShape_ShellBasedSurfaceModel(StepGeom.StepGeom_GeometricRepresentationItem):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepShape_ShellBasedSurfaceModel
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepShape_ShellBasedSurfaceModel(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepShape_ShellBasedSurfaceModel self) -> StepShape_ShellBasedSurfaceModel

        Returns a ShellBasedSurfaceModel


        """
        this = _StepShape.new_StepShape_ShellBasedSurfaceModel(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepShape_ShellBasedSurfaceModel self, Handle_TCollection_HAsciiString aName, Handle_StepShape_HArray1OfShell aSbsmBoundary)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aSbsmBoundary: OCC.wrapper.StepShape.Handle_StepShape_HArray1OfShell

        """
        return _StepShape.StepShape_ShellBasedSurfaceModel_Init(self, *args)


    def SetSbsmBoundary(self, *args):
        """
        SetSbsmBoundary(StepShape_ShellBasedSurfaceModel self, Handle_StepShape_HArray1OfShell aSbsmBoundary)

        :type aSbsmBoundary: OCC.wrapper.StepShape.Handle_StepShape_HArray1OfShell

        """
        return _StepShape.StepShape_ShellBasedSurfaceModel_SetSbsmBoundary(self, *args)


    def SbsmBoundary(self, *args):
        """
        SbsmBoundary(StepShape_ShellBasedSurfaceModel self) -> Handle_StepShape_HArray1OfShell

        :rtype: OCC.wrapper.StepShape.Handle_StepShape_HArray1OfShell

        """
        return _StepShape.StepShape_ShellBasedSurfaceModel_SbsmBoundary(self, *args)


    def SbsmBoundaryValue(self, *args):
        """
        SbsmBoundaryValue(StepShape_ShellBasedSurfaceModel self, Standard_Integer const num) -> StepShape_Shell

        :type num: int
        :rtype: OCC.wrapper.StepShape.StepShape_Shell

        """
        return _StepShape.StepShape_ShellBasedSurfaceModel_SbsmBoundaryValue(self, *args)


    def NbSbsmBoundary(self, *args):
        """
        NbSbsmBoundary(StepShape_ShellBasedSurfaceModel self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.StepShape_ShellBasedSurfaceModel_NbSbsmBoundary(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepShape.StepShape_ShellBasedSurfaceModel_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepShape.StepShape_ShellBasedSurfaceModel_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.StepShape_ShellBasedSurfaceModel_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepShape.delete_StepShape_ShellBasedSurfaceModel
StepShape_ShellBasedSurfaceModel_swigregister = _StepShape.StepShape_ShellBasedSurfaceModel_swigregister
StepShape_ShellBasedSurfaceModel_swigregister(StepShape_ShellBasedSurfaceModel)

def StepShape_ShellBasedSurfaceModel_get_type_name(*args):
    """
    StepShape_ShellBasedSurfaceModel_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepShape.StepShape_ShellBasedSurfaceModel_get_type_name(*args)

def StepShape_ShellBasedSurfaceModel_get_type_descriptor(*args):
    """
    StepShape_ShellBasedSurfaceModel_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepShape.StepShape_ShellBasedSurfaceModel_get_type_descriptor(*args)

class StepShape_HArray1OfShapeDimensionRepresentationItem(Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepShape_HArray1OfShapeDimensionRepresentationItem
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepShape_HArray1OfShapeDimensionRepresentationItem(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepShape_HArray1OfShapeDimensionRepresentationItem self, Standard_Integer const theLower, Standard_Integer const theUpper) -> StepShape_HArray1OfShapeDimensionRepresentationItem
        __init__(StepShape_HArray1OfShapeDimensionRepresentationItem self, Standard_Integer const theLower, Standard_Integer const theUpper, StepShape_ShapeDimensionRepresentationItem theValue) -> StepShape_HArray1OfShapeDimensionRepresentationItem
        __init__(StepShape_HArray1OfShapeDimensionRepresentationItem self, NCollection_Array1_StepShape_ShapeDimensionRepresentationItem theOther) -> StepShape_HArray1OfShapeDimensionRepresentationItem

        :type theOther: OCC.wrapper.StepShape.StepShape_Array1OfShapeDimensionRepresentationItem

        """
        this = _StepShape.new_StepShape_HArray1OfShapeDimensionRepresentationItem(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Array1(self, *args):
        """
        :rtype: OCC.wrapper.StepShape.StepShape_Array1OfShapeDimensionRepresentationItem

        """
        res = _StepShape.StepShape_HArray1OfShapeDimensionRepresentationItem_Array1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeArray1(self, *args):
        """
        ChangeArray1(StepShape_HArray1OfShapeDimensionRepresentationItem self) -> NCollection_Array1_StepShape_ShapeDimensionRepresentationItem

        :rtype: OCC.wrapper.StepShape.StepShape_Array1OfShapeDimensionRepresentationItem

        """
        return _StepShape.StepShape_HArray1OfShapeDimensionRepresentationItem_ChangeArray1(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepShape.StepShape_HArray1OfShapeDimensionRepresentationItem_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepShape.StepShape_HArray1OfShapeDimensionRepresentationItem_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.StepShape_HArray1OfShapeDimensionRepresentationItem_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepShape.delete_StepShape_HArray1OfShapeDimensionRepresentationItem
StepShape_HArray1OfShapeDimensionRepresentationItem_swigregister = _StepShape.StepShape_HArray1OfShapeDimensionRepresentationItem_swigregister
StepShape_HArray1OfShapeDimensionRepresentationItem_swigregister(StepShape_HArray1OfShapeDimensionRepresentationItem)

def StepShape_HArray1OfShapeDimensionRepresentationItem_get_type_name(*args):
    """
    StepShape_HArray1OfShapeDimensionRepresentationItem_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepShape.StepShape_HArray1OfShapeDimensionRepresentationItem_get_type_name(*args)

def StepShape_HArray1OfShapeDimensionRepresentationItem_get_type_descriptor(*args):
    """
    StepShape_HArray1OfShapeDimensionRepresentationItem_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepShape.StepShape_HArray1OfShapeDimensionRepresentationItem_get_type_descriptor(*args)

class StepShape_DimensionalLocationWithPath(StepShape_DimensionalLocation):
    """Representation of STEP entity DimensionalLocationWithPath"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepShape_DimensionalLocationWithPath
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepShape_DimensionalLocationWithPath(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepShape_DimensionalLocationWithPath self) -> StepShape_DimensionalLocationWithPath

        Empty constructor


        """
        this = _StepShape.new_StepShape_DimensionalLocationWithPath(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepShape_DimensionalLocationWithPath self, Handle_TCollection_HAsciiString aShapeAspectRelationship_Name, Standard_Boolean const hasShapeAspectRelationship_Description, Handle_TCollection_HAsciiString aShapeAspectRelationship_Description, Handle_StepRepr_ShapeAspect aShapeAspectRelationship_RelatingShapeAspect, Handle_StepRepr_ShapeAspect aShapeAspectRelationship_RelatedShapeAspect, Handle_StepRepr_ShapeAspect aPath)

        Initialize all fields (own and inherited)

        :type aShapeAspectRelationship_Name: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type hasShapeAspectRelationship_Description: bool
        :type aShapeAspectRelationship_Description: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aShapeAspectRelationship_RelatingShapeAspect: OCC.wrapper.StepShape.Handle_StepRepr_ShapeAspect
        :type aShapeAspectRelationship_RelatedShapeAspect: OCC.wrapper.StepShape.Handle_StepRepr_ShapeAspect
        :type aPath: OCC.wrapper.StepShape.Handle_StepRepr_ShapeAspect

        """
        return _StepShape.StepShape_DimensionalLocationWithPath_Init(self, *args)


    def Path(self, *args):
        """
        Path(StepShape_DimensionalLocationWithPath self) -> Handle_StepRepr_ShapeAspect

        Returns field Path

        :rtype: OCC.wrapper.StepShape.Handle_StepRepr_ShapeAspect

        """
        return _StepShape.StepShape_DimensionalLocationWithPath_Path(self, *args)


    def SetPath(self, *args):
        """
        SetPath(StepShape_DimensionalLocationWithPath self, Handle_StepRepr_ShapeAspect Path)

        Set field Path

        :type Path: OCC.wrapper.StepShape.Handle_StepRepr_ShapeAspect

        """
        return _StepShape.StepShape_DimensionalLocationWithPath_SetPath(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepShape.StepShape_DimensionalLocationWithPath_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepShape.StepShape_DimensionalLocationWithPath_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.StepShape_DimensionalLocationWithPath_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepShape.delete_StepShape_DimensionalLocationWithPath
StepShape_DimensionalLocationWithPath_swigregister = _StepShape.StepShape_DimensionalLocationWithPath_swigregister
StepShape_DimensionalLocationWithPath_swigregister(StepShape_DimensionalLocationWithPath)

def StepShape_DimensionalLocationWithPath_get_type_name(*args):
    """
    StepShape_DimensionalLocationWithPath_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepShape.StepShape_DimensionalLocationWithPath_get_type_name(*args)

def StepShape_DimensionalLocationWithPath_get_type_descriptor(*args):
    """
    StepShape_DimensionalLocationWithPath_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepShape.StepShape_DimensionalLocationWithPath_get_type_descriptor(*args)

class StepShape_HArray1OfFaceBound(Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepShape_HArray1OfFaceBound
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepShape_HArray1OfFaceBound(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepShape_HArray1OfFaceBound self, Standard_Integer const theLower, Standard_Integer const theUpper) -> StepShape_HArray1OfFaceBound
        __init__(StepShape_HArray1OfFaceBound self, Standard_Integer const theLower, Standard_Integer const theUpper, Handle_StepShape_FaceBound theValue) -> StepShape_HArray1OfFaceBound
        __init__(StepShape_HArray1OfFaceBound self, NCollection_Array1_Handle_StepShape_FaceBound theOther) -> StepShape_HArray1OfFaceBound

        :type theOther: OCC.wrapper.StepShape.StepShape_Array1OfFaceBound

        """
        this = _StepShape.new_StepShape_HArray1OfFaceBound(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Array1(self, *args):
        """
        :rtype: OCC.wrapper.StepShape.StepShape_Array1OfFaceBound

        """
        res = _StepShape.StepShape_HArray1OfFaceBound_Array1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeArray1(self, *args):
        """
        ChangeArray1(StepShape_HArray1OfFaceBound self) -> NCollection_Array1_Handle_StepShape_FaceBound

        :rtype: OCC.wrapper.StepShape.StepShape_Array1OfFaceBound

        """
        return _StepShape.StepShape_HArray1OfFaceBound_ChangeArray1(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepShape.StepShape_HArray1OfFaceBound_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepShape.StepShape_HArray1OfFaceBound_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.StepShape_HArray1OfFaceBound_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepShape.delete_StepShape_HArray1OfFaceBound
StepShape_HArray1OfFaceBound_swigregister = _StepShape.StepShape_HArray1OfFaceBound_swigregister
StepShape_HArray1OfFaceBound_swigregister(StepShape_HArray1OfFaceBound)

def StepShape_HArray1OfFaceBound_get_type_name(*args):
    """
    StepShape_HArray1OfFaceBound_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepShape.StepShape_HArray1OfFaceBound_get_type_name(*args)

def StepShape_HArray1OfFaceBound_get_type_descriptor(*args):
    """
    StepShape_HArray1OfFaceBound_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepShape.StepShape_HArray1OfFaceBound_get_type_descriptor(*args)

class StepShape_RightAngularWedge(StepGeom.StepGeom_GeometricRepresentationItem):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepShape_RightAngularWedge
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepShape_RightAngularWedge(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepShape_RightAngularWedge self) -> StepShape_RightAngularWedge

        Returns a RightAngularWedge


        """
        this = _StepShape.new_StepShape_RightAngularWedge(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepShape_RightAngularWedge self, Handle_TCollection_HAsciiString aName, Handle_StepGeom_Axis2Placement3d aPosition, Standard_Real const aX, Standard_Real const aY, Standard_Real const aZ, Standard_Real const aLtx)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aPosition: OCC.wrapper.StepShape.Handle_StepGeom_Axis2Placement3d
        :type aX: float
        :type aY: float
        :type aZ: float
        :type aLtx: float

        """
        return _StepShape.StepShape_RightAngularWedge_Init(self, *args)


    def SetPosition(self, *args):
        """
        SetPosition(StepShape_RightAngularWedge self, Handle_StepGeom_Axis2Placement3d aPosition)

        :type aPosition: OCC.wrapper.StepShape.Handle_StepGeom_Axis2Placement3d

        """
        return _StepShape.StepShape_RightAngularWedge_SetPosition(self, *args)


    def Position(self, *args):
        """
        Position(StepShape_RightAngularWedge self) -> Handle_StepGeom_Axis2Placement3d

        :rtype: OCC.wrapper.StepShape.Handle_StepGeom_Axis2Placement3d

        """
        return _StepShape.StepShape_RightAngularWedge_Position(self, *args)


    def SetX(self, *args):
        """
        SetX(StepShape_RightAngularWedge self, Standard_Real const aX)

        :type aX: float

        """
        return _StepShape.StepShape_RightAngularWedge_SetX(self, *args)


    def X(self, *args):
        """
        X(StepShape_RightAngularWedge self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _StepShape.StepShape_RightAngularWedge_X(self, *args)


    def SetY(self, *args):
        """
        SetY(StepShape_RightAngularWedge self, Standard_Real const aY)

        :type aY: float

        """
        return _StepShape.StepShape_RightAngularWedge_SetY(self, *args)


    def Y(self, *args):
        """
        Y(StepShape_RightAngularWedge self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _StepShape.StepShape_RightAngularWedge_Y(self, *args)


    def SetZ(self, *args):
        """
        SetZ(StepShape_RightAngularWedge self, Standard_Real const aZ)

        :type aZ: float

        """
        return _StepShape.StepShape_RightAngularWedge_SetZ(self, *args)


    def Z(self, *args):
        """
        Z(StepShape_RightAngularWedge self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _StepShape.StepShape_RightAngularWedge_Z(self, *args)


    def SetLtx(self, *args):
        """
        SetLtx(StepShape_RightAngularWedge self, Standard_Real const aLtx)

        :type aLtx: float

        """
        return _StepShape.StepShape_RightAngularWedge_SetLtx(self, *args)


    def Ltx(self, *args):
        """
        Ltx(StepShape_RightAngularWedge self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _StepShape.StepShape_RightAngularWedge_Ltx(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepShape.StepShape_RightAngularWedge_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepShape.StepShape_RightAngularWedge_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.StepShape_RightAngularWedge_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepShape.delete_StepShape_RightAngularWedge
StepShape_RightAngularWedge_swigregister = _StepShape.StepShape_RightAngularWedge_swigregister
StepShape_RightAngularWedge_swigregister(StepShape_RightAngularWedge)

def StepShape_RightAngularWedge_get_type_name(*args):
    """
    StepShape_RightAngularWedge_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepShape.StepShape_RightAngularWedge_get_type_name(*args)

def StepShape_RightAngularWedge_get_type_descriptor(*args):
    """
    StepShape_RightAngularWedge_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepShape.StepShape_RightAngularWedge_get_type_descriptor(*args)

class StepShape_LoopAndPath(StepShape_TopologicalRepresentationItem):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepShape_LoopAndPath
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepShape_LoopAndPath(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepShape_LoopAndPath self) -> StepShape_LoopAndPath

        Returns a LoopAndPath


        """
        this = _StepShape.new_StepShape_LoopAndPath(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepShape_LoopAndPath self, Handle_TCollection_HAsciiString aName, Handle_StepShape_Loop aLoop, Handle_StepShape_Path aPath)
        Init(StepShape_LoopAndPath self, Handle_TCollection_HAsciiString aName, Handle_StepShape_HArray1OfOrientedEdge aEdgeList)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aEdgeList: OCC.wrapper.StepShape.Handle_StepShape_HArray1OfOrientedEdge

        """
        return _StepShape.StepShape_LoopAndPath_Init(self, *args)


    def SetLoop(self, *args):
        """
        SetLoop(StepShape_LoopAndPath self, Handle_StepShape_Loop aLoop)

        :type aLoop: OCC.wrapper.StepShape.Handle_StepShape_Loop

        """
        return _StepShape.StepShape_LoopAndPath_SetLoop(self, *args)


    def Loop(self, *args):
        """
        Loop(StepShape_LoopAndPath self) -> Handle_StepShape_Loop

        :rtype: OCC.wrapper.StepShape.Handle_StepShape_Loop

        """
        return _StepShape.StepShape_LoopAndPath_Loop(self, *args)


    def SetPath(self, *args):
        """
        SetPath(StepShape_LoopAndPath self, Handle_StepShape_Path aPath)

        :type aPath: OCC.wrapper.StepShape.Handle_StepShape_Path

        """
        return _StepShape.StepShape_LoopAndPath_SetPath(self, *args)


    def Path(self, *args):
        """
        Path(StepShape_LoopAndPath self) -> Handle_StepShape_Path

        :rtype: OCC.wrapper.StepShape.Handle_StepShape_Path

        """
        return _StepShape.StepShape_LoopAndPath_Path(self, *args)


    def SetEdgeList(self, *args):
        """
        SetEdgeList(StepShape_LoopAndPath self, Handle_StepShape_HArray1OfOrientedEdge aEdgeList)

        :type aEdgeList: OCC.wrapper.StepShape.Handle_StepShape_HArray1OfOrientedEdge

        """
        return _StepShape.StepShape_LoopAndPath_SetEdgeList(self, *args)


    def EdgeList(self, *args):
        """
        EdgeList(StepShape_LoopAndPath self) -> Handle_StepShape_HArray1OfOrientedEdge

        :rtype: OCC.wrapper.StepShape.Handle_StepShape_HArray1OfOrientedEdge

        """
        return _StepShape.StepShape_LoopAndPath_EdgeList(self, *args)


    def EdgeListValue(self, *args):
        """
        EdgeListValue(StepShape_LoopAndPath self, Standard_Integer const num) -> Handle_StepShape_OrientedEdge

        :type num: int
        :rtype: OCC.wrapper.StepShape.Handle_StepShape_OrientedEdge

        """
        return _StepShape.StepShape_LoopAndPath_EdgeListValue(self, *args)


    def NbEdgeList(self, *args):
        """
        NbEdgeList(StepShape_LoopAndPath self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.StepShape_LoopAndPath_NbEdgeList(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepShape.StepShape_LoopAndPath_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepShape.StepShape_LoopAndPath_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.StepShape_LoopAndPath_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepShape.delete_StepShape_LoopAndPath
StepShape_LoopAndPath_swigregister = _StepShape.StepShape_LoopAndPath_swigregister
StepShape_LoopAndPath_swigregister(StepShape_LoopAndPath)

def StepShape_LoopAndPath_get_type_name(*args):
    """
    StepShape_LoopAndPath_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepShape.StepShape_LoopAndPath_get_type_name(*args)

def StepShape_LoopAndPath_get_type_descriptor(*args):
    """
    StepShape_LoopAndPath_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepShape.StepShape_LoopAndPath_get_type_descriptor(*args)

class StepShape_Face(StepShape_TopologicalRepresentationItem):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepShape_Face
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepShape_Face(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepShape_Face self) -> StepShape_Face

        Returns a Face


        """
        this = _StepShape.new_StepShape_Face(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepShape_Face self, Handle_TCollection_HAsciiString aName, Handle_StepShape_HArray1OfFaceBound aBounds)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aBounds: OCC.wrapper.StepShape.Handle_StepShape_HArray1OfFaceBound

        """
        return _StepShape.StepShape_Face_Init(self, *args)


    def SetBounds(self, *args):
        """
        SetBounds(StepShape_Face self, Handle_StepShape_HArray1OfFaceBound aBounds)

        :type aBounds: OCC.wrapper.StepShape.Handle_StepShape_HArray1OfFaceBound

        """
        return _StepShape.StepShape_Face_SetBounds(self, *args)


    def Bounds(self, *args):
        """
        Bounds(StepShape_Face self) -> Handle_StepShape_HArray1OfFaceBound

        :rtype: OCC.wrapper.StepShape.Handle_StepShape_HArray1OfFaceBound

        """
        return _StepShape.StepShape_Face_Bounds(self, *args)


    def BoundsValue(self, *args):
        """
        BoundsValue(StepShape_Face self, Standard_Integer const num) -> Handle_StepShape_FaceBound

        :type num: int
        :rtype: OCC.wrapper.StepShape.Handle_StepShape_FaceBound

        """
        return _StepShape.StepShape_Face_BoundsValue(self, *args)


    def NbBounds(self, *args):
        """
        NbBounds(StepShape_Face self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.StepShape_Face_NbBounds(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepShape.StepShape_Face_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepShape.StepShape_Face_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.StepShape_Face_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepShape.delete_StepShape_Face
StepShape_Face_swigregister = _StepShape.StepShape_Face_swigregister
StepShape_Face_swigregister(StepShape_Face)

def StepShape_Face_get_type_name(*args):
    """
    StepShape_Face_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepShape.StepShape_Face_get_type_name(*args)

def StepShape_Face_get_type_descriptor(*args):
    """
    StepShape_Face_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepShape.StepShape_Face_get_type_descriptor(*args)

class StepShape_MeasureQualification(Standard.Standard_Transient):
    """Added for Dimensional Tolerances"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepShape_MeasureQualification
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepShape_MeasureQualification(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepShape_MeasureQualification self) -> StepShape_MeasureQualification

        Added for Dimensional Tolerances
        """
        this = _StepShape.new_StepShape_MeasureQualification(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepShape_MeasureQualification self, Handle_TCollection_HAsciiString name, Handle_TCollection_HAsciiString description, Handle_StepBasic_MeasureWithUnit qualified_measure, Handle_StepShape_HArray1OfValueQualifier qualifiers)

        :type name: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type description: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type qualified_measure: OCC.wrapper.StepBasic.Handle_StepBasic_MeasureWithUnit
        :type qualifiers: OCC.wrapper.StepShape.Handle_StepShape_HArray1OfValueQualifier

        """
        return _StepShape.StepShape_MeasureQualification_Init(self, *args)


    def Name(self, *args):
        """
        Name(StepShape_MeasureQualification self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepShape.StepShape_MeasureQualification_Name(self, *args)


    def SetName(self, *args):
        """
        SetName(StepShape_MeasureQualification self, Handle_TCollection_HAsciiString name)

        :type name: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepShape.StepShape_MeasureQualification_SetName(self, *args)


    def Description(self, *args):
        """
        Description(StepShape_MeasureQualification self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepShape.StepShape_MeasureQualification_Description(self, *args)


    def SetDescription(self, *args):
        """
        SetDescription(StepShape_MeasureQualification self, Handle_TCollection_HAsciiString description)

        :type description: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepShape.StepShape_MeasureQualification_SetDescription(self, *args)


    def QualifiedMeasure(self, *args):
        """
        QualifiedMeasure(StepShape_MeasureQualification self) -> Handle_StepBasic_MeasureWithUnit

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_MeasureWithUnit

        """
        return _StepShape.StepShape_MeasureQualification_QualifiedMeasure(self, *args)


    def SetQualifiedMeasure(self, *args):
        """
        SetQualifiedMeasure(StepShape_MeasureQualification self, Handle_StepBasic_MeasureWithUnit qualified_measure)

        :type qualified_measure: OCC.wrapper.StepBasic.Handle_StepBasic_MeasureWithUnit

        """
        return _StepShape.StepShape_MeasureQualification_SetQualifiedMeasure(self, *args)


    def Qualifiers(self, *args):
        """
        Qualifiers(StepShape_MeasureQualification self) -> Handle_StepShape_HArray1OfValueQualifier

        :rtype: OCC.wrapper.StepShape.Handle_StepShape_HArray1OfValueQualifier

        """
        return _StepShape.StepShape_MeasureQualification_Qualifiers(self, *args)


    def NbQualifiers(self, *args):
        """
        NbQualifiers(StepShape_MeasureQualification self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.StepShape_MeasureQualification_NbQualifiers(self, *args)


    def SetQualifiers(self, *args):
        """
        SetQualifiers(StepShape_MeasureQualification self, Handle_StepShape_HArray1OfValueQualifier qualifiers)

        :type qualifiers: OCC.wrapper.StepShape.Handle_StepShape_HArray1OfValueQualifier

        """
        return _StepShape.StepShape_MeasureQualification_SetQualifiers(self, *args)


    def QualifiersValue(self, *args):
        """
        QualifiersValue(StepShape_MeasureQualification self, Standard_Integer const num) -> StepShape_ValueQualifier

        :type num: int
        :rtype: OCC.wrapper.StepShape.StepShape_ValueQualifier

        """
        return _StepShape.StepShape_MeasureQualification_QualifiersValue(self, *args)


    def SetQualifiersValue(self, *args):
        """
        SetQualifiersValue(StepShape_MeasureQualification self, Standard_Integer const num, StepShape_ValueQualifier aqualifier)

        :type num: int
        :type aqualifier: OCC.wrapper.StepShape.StepShape_ValueQualifier

        """
        return _StepShape.StepShape_MeasureQualification_SetQualifiersValue(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepShape.StepShape_MeasureQualification_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepShape.StepShape_MeasureQualification_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.StepShape_MeasureQualification_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepShape.delete_StepShape_MeasureQualification
StepShape_MeasureQualification_swigregister = _StepShape.StepShape_MeasureQualification_swigregister
StepShape_MeasureQualification_swigregister(StepShape_MeasureQualification)

def StepShape_MeasureQualification_get_type_name(*args):
    """
    StepShape_MeasureQualification_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepShape.StepShape_MeasureQualification_get_type_name(*args)

def StepShape_MeasureQualification_get_type_descriptor(*args):
    """
    StepShape_MeasureQualification_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepShape.StepShape_MeasureQualification_get_type_descriptor(*args)

class StepShape_FacetedBrepShapeRepresentation(StepShape_ShapeRepresentation):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepShape_FacetedBrepShapeRepresentation
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepShape_FacetedBrepShapeRepresentation(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepShape_FacetedBrepShapeRepresentation self) -> StepShape_FacetedBrepShapeRepresentation

        Returns a FacetedBrepShapeRepresentation


        """
        this = _StepShape.new_StepShape_FacetedBrepShapeRepresentation(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepShape.StepShape_FacetedBrepShapeRepresentation_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepShape.StepShape_FacetedBrepShapeRepresentation_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.StepShape_FacetedBrepShapeRepresentation_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepShape.delete_StepShape_FacetedBrepShapeRepresentation
StepShape_FacetedBrepShapeRepresentation_swigregister = _StepShape.StepShape_FacetedBrepShapeRepresentation_swigregister
StepShape_FacetedBrepShapeRepresentation_swigregister(StepShape_FacetedBrepShapeRepresentation)

def StepShape_FacetedBrepShapeRepresentation_get_type_name(*args):
    """
    StepShape_FacetedBrepShapeRepresentation_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepShape.StepShape_FacetedBrepShapeRepresentation_get_type_name(*args)

def StepShape_FacetedBrepShapeRepresentation_get_type_descriptor(*args):
    """
    StepShape_FacetedBrepShapeRepresentation_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepShape.StepShape_FacetedBrepShapeRepresentation_get_type_descriptor(*args)

class StepShape_PointRepresentation(StepShape_ShapeRepresentation):
    """Representation of STEP entity PointRepresentation"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepShape_PointRepresentation
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepShape_PointRepresentation(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepShape_PointRepresentation self) -> StepShape_PointRepresentation

        Empty constructor


        """
        this = _StepShape.new_StepShape_PointRepresentation(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepShape.StepShape_PointRepresentation_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepShape.StepShape_PointRepresentation_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.StepShape_PointRepresentation_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepShape.delete_StepShape_PointRepresentation
StepShape_PointRepresentation_swigregister = _StepShape.StepShape_PointRepresentation_swigregister
StepShape_PointRepresentation_swigregister(StepShape_PointRepresentation)

def StepShape_PointRepresentation_get_type_name(*args):
    """
    StepShape_PointRepresentation_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepShape.StepShape_PointRepresentation_get_type_name(*args)

def StepShape_PointRepresentation_get_type_descriptor(*args):
    """
    StepShape_PointRepresentation_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepShape.StepShape_PointRepresentation_get_type_descriptor(*args)

class StepShape_PlusMinusTolerance(Standard.Standard_Transient):
    """Added for Dimensional Tolerances"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepShape_PlusMinusTolerance
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepShape_PlusMinusTolerance(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepShape_PlusMinusTolerance self) -> StepShape_PlusMinusTolerance

        Added for Dimensional Tolerances
        """
        this = _StepShape.new_StepShape_PlusMinusTolerance(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepShape_PlusMinusTolerance self, StepShape_ToleranceMethodDefinition range, StepShape_DimensionalCharacteristic toleranced_dimension)

        :type range: OCC.wrapper.StepShape.StepShape_ToleranceMethodDefinition
        :type toleranced_dimension: OCC.wrapper.StepShape.StepShape_DimensionalCharacteristic

        """
        return _StepShape.StepShape_PlusMinusTolerance_Init(self, *args)


    def Range(self, *args):
        """
        Range(StepShape_PlusMinusTolerance self) -> StepShape_ToleranceMethodDefinition

        :rtype: OCC.wrapper.StepShape.StepShape_ToleranceMethodDefinition

        """
        return _StepShape.StepShape_PlusMinusTolerance_Range(self, *args)


    def SetRange(self, *args):
        """
        SetRange(StepShape_PlusMinusTolerance self, StepShape_ToleranceMethodDefinition range)

        :type range: OCC.wrapper.StepShape.StepShape_ToleranceMethodDefinition

        """
        return _StepShape.StepShape_PlusMinusTolerance_SetRange(self, *args)


    def TolerancedDimension(self, *args):
        """
        TolerancedDimension(StepShape_PlusMinusTolerance self) -> StepShape_DimensionalCharacteristic

        :rtype: OCC.wrapper.StepShape.StepShape_DimensionalCharacteristic

        """
        return _StepShape.StepShape_PlusMinusTolerance_TolerancedDimension(self, *args)


    def SetTolerancedDimension(self, *args):
        """
        SetTolerancedDimension(StepShape_PlusMinusTolerance self, StepShape_DimensionalCharacteristic toleranced_dimension)

        :type toleranced_dimension: OCC.wrapper.StepShape.StepShape_DimensionalCharacteristic

        """
        return _StepShape.StepShape_PlusMinusTolerance_SetTolerancedDimension(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepShape.StepShape_PlusMinusTolerance_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepShape.StepShape_PlusMinusTolerance_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.StepShape_PlusMinusTolerance_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepShape.delete_StepShape_PlusMinusTolerance
StepShape_PlusMinusTolerance_swigregister = _StepShape.StepShape_PlusMinusTolerance_swigregister
StepShape_PlusMinusTolerance_swigregister(StepShape_PlusMinusTolerance)

def StepShape_PlusMinusTolerance_get_type_name(*args):
    """
    StepShape_PlusMinusTolerance_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepShape.StepShape_PlusMinusTolerance_get_type_name(*args)

def StepShape_PlusMinusTolerance_get_type_descriptor(*args):
    """
    StepShape_PlusMinusTolerance_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepShape.StepShape_PlusMinusTolerance_get_type_descriptor(*args)

class StepShape_ExtrudedAreaSolid(StepShape_SweptAreaSolid):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepShape_ExtrudedAreaSolid
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepShape_ExtrudedAreaSolid(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepShape_ExtrudedAreaSolid self) -> StepShape_ExtrudedAreaSolid

        Returns a ExtrudedAreaSolid


        """
        this = _StepShape.new_StepShape_ExtrudedAreaSolid(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepShape_ExtrudedAreaSolid self, Handle_TCollection_HAsciiString aName, Handle_StepGeom_CurveBoundedSurface aSweptArea, Handle_StepGeom_Direction aExtrudedDirection, Standard_Real const aDepth)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aSweptArea: OCC.wrapper.StepShape.Handle_StepGeom_CurveBoundedSurface
        :type aExtrudedDirection: OCC.wrapper.StepShape.Handle_StepGeom_Direction
        :type aDepth: float

        """
        return _StepShape.StepShape_ExtrudedAreaSolid_Init(self, *args)


    def SetExtrudedDirection(self, *args):
        """
        SetExtrudedDirection(StepShape_ExtrudedAreaSolid self, Handle_StepGeom_Direction aExtrudedDirection)

        :type aExtrudedDirection: OCC.wrapper.StepShape.Handle_StepGeom_Direction

        """
        return _StepShape.StepShape_ExtrudedAreaSolid_SetExtrudedDirection(self, *args)


    def ExtrudedDirection(self, *args):
        """
        ExtrudedDirection(StepShape_ExtrudedAreaSolid self) -> Handle_StepGeom_Direction

        :rtype: OCC.wrapper.StepShape.Handle_StepGeom_Direction

        """
        return _StepShape.StepShape_ExtrudedAreaSolid_ExtrudedDirection(self, *args)


    def SetDepth(self, *args):
        """
        SetDepth(StepShape_ExtrudedAreaSolid self, Standard_Real const aDepth)

        :type aDepth: float

        """
        return _StepShape.StepShape_ExtrudedAreaSolid_SetDepth(self, *args)


    def Depth(self, *args):
        """
        Depth(StepShape_ExtrudedAreaSolid self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _StepShape.StepShape_ExtrudedAreaSolid_Depth(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepShape.StepShape_ExtrudedAreaSolid_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepShape.StepShape_ExtrudedAreaSolid_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.StepShape_ExtrudedAreaSolid_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepShape.delete_StepShape_ExtrudedAreaSolid
StepShape_ExtrudedAreaSolid_swigregister = _StepShape.StepShape_ExtrudedAreaSolid_swigregister
StepShape_ExtrudedAreaSolid_swigregister(StepShape_ExtrudedAreaSolid)

def StepShape_ExtrudedAreaSolid_get_type_name(*args):
    """
    StepShape_ExtrudedAreaSolid_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepShape.StepShape_ExtrudedAreaSolid_get_type_name(*args)

def StepShape_ExtrudedAreaSolid_get_type_descriptor(*args):
    """
    StepShape_ExtrudedAreaSolid_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepShape.StepShape_ExtrudedAreaSolid_get_type_descriptor(*args)

class StepShape_EdgeCurve(StepShape_Edge):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepShape_EdgeCurve
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepShape_EdgeCurve(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepShape_EdgeCurve self) -> StepShape_EdgeCurve

        Returns a EdgeCurve


        """
        this = _StepShape.new_StepShape_EdgeCurve(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepShape_EdgeCurve self, Handle_TCollection_HAsciiString aName, Handle_StepShape_Vertex aEdgeStart, Handle_StepShape_Vertex aEdgeEnd, Handle_StepGeom_Curve aEdgeGeometry, Standard_Boolean const aSameSense)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aEdgeStart: OCC.wrapper.StepShape.Handle_StepShape_Vertex
        :type aEdgeEnd: OCC.wrapper.StepShape.Handle_StepShape_Vertex
        :type aEdgeGeometry: OCC.wrapper.StepShape.Handle_StepGeom_Curve
        :type aSameSense: bool

        """
        return _StepShape.StepShape_EdgeCurve_Init(self, *args)


    def SetEdgeGeometry(self, *args):
        """
        SetEdgeGeometry(StepShape_EdgeCurve self, Handle_StepGeom_Curve aEdgeGeometry)

        :type aEdgeGeometry: OCC.wrapper.StepShape.Handle_StepGeom_Curve

        """
        return _StepShape.StepShape_EdgeCurve_SetEdgeGeometry(self, *args)


    def EdgeGeometry(self, *args):
        """
        EdgeGeometry(StepShape_EdgeCurve self) -> Handle_StepGeom_Curve

        :rtype: OCC.wrapper.StepShape.Handle_StepGeom_Curve

        """
        return _StepShape.StepShape_EdgeCurve_EdgeGeometry(self, *args)


    def SetSameSense(self, *args):
        """
        SetSameSense(StepShape_EdgeCurve self, Standard_Boolean const aSameSense)

        :type aSameSense: bool

        """
        return _StepShape.StepShape_EdgeCurve_SetSameSense(self, *args)


    def SameSense(self, *args):
        """
        SameSense(StepShape_EdgeCurve self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.StepShape_EdgeCurve_SameSense(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepShape.StepShape_EdgeCurve_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepShape.StepShape_EdgeCurve_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.StepShape_EdgeCurve_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepShape.delete_StepShape_EdgeCurve
StepShape_EdgeCurve_swigregister = _StepShape.StepShape_EdgeCurve_swigregister
StepShape_EdgeCurve_swigregister(StepShape_EdgeCurve)

def StepShape_EdgeCurve_get_type_name(*args):
    """
    StepShape_EdgeCurve_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepShape.StepShape_EdgeCurve_get_type_name(*args)

def StepShape_EdgeCurve_get_type_descriptor(*args):
    """
    StepShape_EdgeCurve_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepShape.StepShape_EdgeCurve_get_type_descriptor(*args)

class StepShape_ConnectedEdgeSet(StepShape_TopologicalRepresentationItem):
    """Representation of STEP entity ConnectedEdgeSet"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepShape_ConnectedEdgeSet
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepShape_ConnectedEdgeSet(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepShape_ConnectedEdgeSet self) -> StepShape_ConnectedEdgeSet

        Empty constructor


        """
        this = _StepShape.new_StepShape_ConnectedEdgeSet(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepShape_ConnectedEdgeSet self, Handle_TCollection_HAsciiString aRepresentationItem_Name, Handle_StepShape_HArray1OfEdge aCesEdges)

        Initialize all fields (own and inherited)

        :type aRepresentationItem_Name: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aCesEdges: OCC.wrapper.StepShape.Handle_StepShape_HArray1OfEdge

        """
        return _StepShape.StepShape_ConnectedEdgeSet_Init(self, *args)


    def CesEdges(self, *args):
        """
        CesEdges(StepShape_ConnectedEdgeSet self) -> Handle_StepShape_HArray1OfEdge

        Returns field CesEdges

        :rtype: OCC.wrapper.StepShape.Handle_StepShape_HArray1OfEdge

        """
        return _StepShape.StepShape_ConnectedEdgeSet_CesEdges(self, *args)


    def SetCesEdges(self, *args):
        """
        SetCesEdges(StepShape_ConnectedEdgeSet self, Handle_StepShape_HArray1OfEdge CesEdges)

        Set field CesEdges

        :type CesEdges: OCC.wrapper.StepShape.Handle_StepShape_HArray1OfEdge

        """
        return _StepShape.StepShape_ConnectedEdgeSet_SetCesEdges(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepShape.StepShape_ConnectedEdgeSet_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepShape.StepShape_ConnectedEdgeSet_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.StepShape_ConnectedEdgeSet_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepShape.delete_StepShape_ConnectedEdgeSet
StepShape_ConnectedEdgeSet_swigregister = _StepShape.StepShape_ConnectedEdgeSet_swigregister
StepShape_ConnectedEdgeSet_swigregister(StepShape_ConnectedEdgeSet)

def StepShape_ConnectedEdgeSet_get_type_name(*args):
    """
    StepShape_ConnectedEdgeSet_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepShape.StepShape_ConnectedEdgeSet_get_type_name(*args)

def StepShape_ConnectedEdgeSet_get_type_descriptor(*args):
    """
    StepShape_ConnectedEdgeSet_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepShape.StepShape_ConnectedEdgeSet_get_type_descriptor(*args)

class StepShape_ConnectedFaceShapeRepresentation(StepRepr.StepRepr_Representation):
    """Representation of STEP entity ConnectedFaceShapeRepresentation"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepShape_ConnectedFaceShapeRepresentation
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepShape_ConnectedFaceShapeRepresentation(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepShape_ConnectedFaceShapeRepresentation self) -> StepShape_ConnectedFaceShapeRepresentation

        Empty constructor


        """
        this = _StepShape.new_StepShape_ConnectedFaceShapeRepresentation(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepShape.StepShape_ConnectedFaceShapeRepresentation_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepShape.StepShape_ConnectedFaceShapeRepresentation_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.StepShape_ConnectedFaceShapeRepresentation_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepShape.delete_StepShape_ConnectedFaceShapeRepresentation
StepShape_ConnectedFaceShapeRepresentation_swigregister = _StepShape.StepShape_ConnectedFaceShapeRepresentation_swigregister
StepShape_ConnectedFaceShapeRepresentation_swigregister(StepShape_ConnectedFaceShapeRepresentation)

def StepShape_ConnectedFaceShapeRepresentation_get_type_name(*args):
    """
    StepShape_ConnectedFaceShapeRepresentation_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepShape.StepShape_ConnectedFaceShapeRepresentation_get_type_name(*args)

def StepShape_ConnectedFaceShapeRepresentation_get_type_descriptor(*args):
    """
    StepShape_ConnectedFaceShapeRepresentation_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepShape.StepShape_ConnectedFaceShapeRepresentation_get_type_descriptor(*args)

class StepShape_BoxDomain(Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepShape_BoxDomain
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepShape_BoxDomain(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepShape_BoxDomain self) -> StepShape_BoxDomain

        Returns a BoxDomain


        """
        this = _StepShape.new_StepShape_BoxDomain(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepShape_BoxDomain self, Handle_StepGeom_CartesianPoint aCorner, Standard_Real const aXlength, Standard_Real const aYlength, Standard_Real const aZlength)

        :type aCorner: OCC.wrapper.StepShape.Handle_StepGeom_CartesianPoint
        :type aXlength: float
        :type aYlength: float
        :type aZlength: float

        """
        return _StepShape.StepShape_BoxDomain_Init(self, *args)


    def SetCorner(self, *args):
        """
        SetCorner(StepShape_BoxDomain self, Handle_StepGeom_CartesianPoint aCorner)

        :type aCorner: OCC.wrapper.StepShape.Handle_StepGeom_CartesianPoint

        """
        return _StepShape.StepShape_BoxDomain_SetCorner(self, *args)


    def Corner(self, *args):
        """
        Corner(StepShape_BoxDomain self) -> Handle_StepGeom_CartesianPoint

        :rtype: OCC.wrapper.StepShape.Handle_StepGeom_CartesianPoint

        """
        return _StepShape.StepShape_BoxDomain_Corner(self, *args)


    def SetXlength(self, *args):
        """
        SetXlength(StepShape_BoxDomain self, Standard_Real const aXlength)

        :type aXlength: float

        """
        return _StepShape.StepShape_BoxDomain_SetXlength(self, *args)


    def Xlength(self, *args):
        """
        Xlength(StepShape_BoxDomain self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _StepShape.StepShape_BoxDomain_Xlength(self, *args)


    def SetYlength(self, *args):
        """
        SetYlength(StepShape_BoxDomain self, Standard_Real const aYlength)

        :type aYlength: float

        """
        return _StepShape.StepShape_BoxDomain_SetYlength(self, *args)


    def Ylength(self, *args):
        """
        Ylength(StepShape_BoxDomain self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _StepShape.StepShape_BoxDomain_Ylength(self, *args)


    def SetZlength(self, *args):
        """
        SetZlength(StepShape_BoxDomain self, Standard_Real const aZlength)

        :type aZlength: float

        """
        return _StepShape.StepShape_BoxDomain_SetZlength(self, *args)


    def Zlength(self, *args):
        """
        Zlength(StepShape_BoxDomain self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _StepShape.StepShape_BoxDomain_Zlength(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepShape.StepShape_BoxDomain_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepShape.StepShape_BoxDomain_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.StepShape_BoxDomain_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepShape.delete_StepShape_BoxDomain
StepShape_BoxDomain_swigregister = _StepShape.StepShape_BoxDomain_swigregister
StepShape_BoxDomain_swigregister(StepShape_BoxDomain)

def StepShape_BoxDomain_get_type_name(*args):
    """
    StepShape_BoxDomain_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepShape.StepShape_BoxDomain_get_type_name(*args)

def StepShape_BoxDomain_get_type_descriptor(*args):
    """
    StepShape_BoxDomain_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepShape.StepShape_BoxDomain_get_type_descriptor(*args)

class StepShape_QualifiedRepresentationItem(StepRepr.StepRepr_RepresentationItem):
    """Added for Dimensional Tolerances"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepShape_QualifiedRepresentationItem
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepShape_QualifiedRepresentationItem(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepShape_QualifiedRepresentationItem self) -> StepShape_QualifiedRepresentationItem

        Added for Dimensional Tolerances
        """
        this = _StepShape.new_StepShape_QualifiedRepresentationItem(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepShape_QualifiedRepresentationItem self, Handle_TCollection_HAsciiString aName, Handle_StepShape_HArray1OfValueQualifier qualifiers)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type qualifiers: OCC.wrapper.StepShape.Handle_StepShape_HArray1OfValueQualifier

        """
        return _StepShape.StepShape_QualifiedRepresentationItem_Init(self, *args)


    def Qualifiers(self, *args):
        """
        Qualifiers(StepShape_QualifiedRepresentationItem self) -> Handle_StepShape_HArray1OfValueQualifier

        :rtype: OCC.wrapper.StepShape.Handle_StepShape_HArray1OfValueQualifier

        """
        return _StepShape.StepShape_QualifiedRepresentationItem_Qualifiers(self, *args)


    def NbQualifiers(self, *args):
        """
        NbQualifiers(StepShape_QualifiedRepresentationItem self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.StepShape_QualifiedRepresentationItem_NbQualifiers(self, *args)


    def SetQualifiers(self, *args):
        """
        SetQualifiers(StepShape_QualifiedRepresentationItem self, Handle_StepShape_HArray1OfValueQualifier qualifiers)

        :type qualifiers: OCC.wrapper.StepShape.Handle_StepShape_HArray1OfValueQualifier

        """
        return _StepShape.StepShape_QualifiedRepresentationItem_SetQualifiers(self, *args)


    def QualifiersValue(self, *args):
        """
        QualifiersValue(StepShape_QualifiedRepresentationItem self, Standard_Integer const num) -> StepShape_ValueQualifier

        :type num: int
        :rtype: OCC.wrapper.StepShape.StepShape_ValueQualifier

        """
        return _StepShape.StepShape_QualifiedRepresentationItem_QualifiersValue(self, *args)


    def SetQualifiersValue(self, *args):
        """
        SetQualifiersValue(StepShape_QualifiedRepresentationItem self, Standard_Integer const num, StepShape_ValueQualifier aqualifier)

        :type num: int
        :type aqualifier: OCC.wrapper.StepShape.StepShape_ValueQualifier

        """
        return _StepShape.StepShape_QualifiedRepresentationItem_SetQualifiersValue(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepShape.StepShape_QualifiedRepresentationItem_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepShape.StepShape_QualifiedRepresentationItem_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.StepShape_QualifiedRepresentationItem_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepShape.delete_StepShape_QualifiedRepresentationItem
StepShape_QualifiedRepresentationItem_swigregister = _StepShape.StepShape_QualifiedRepresentationItem_swigregister
StepShape_QualifiedRepresentationItem_swigregister(StepShape_QualifiedRepresentationItem)

def StepShape_QualifiedRepresentationItem_get_type_name(*args):
    """
    StepShape_QualifiedRepresentationItem_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepShape.StepShape_QualifiedRepresentationItem_get_type_name(*args)

def StepShape_QualifiedRepresentationItem_get_type_descriptor(*args):
    """
    StepShape_QualifiedRepresentationItem_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepShape.StepShape_QualifiedRepresentationItem_get_type_descriptor(*args)

class StepShape_ShapeDimensionRepresentation(StepShape_ShapeRepresentation):
    """Representation of STEP entity ShapeDimensionRepresentation"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepShape_ShapeDimensionRepresentation
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepShape_ShapeDimensionRepresentation(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepShape_ShapeDimensionRepresentation self) -> StepShape_ShapeDimensionRepresentation

        Empty constructor


        """
        this = _StepShape.new_StepShape_ShapeDimensionRepresentation(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepShape_ShapeDimensionRepresentation self, Handle_TCollection_HAsciiString theName, Handle_StepRepr_HArray1OfRepresentationItem theItems, Handle_StepRepr_RepresentationContext theContextOfItems)
        Init(StepShape_ShapeDimensionRepresentation self, Handle_TCollection_HAsciiString theName, Handle_StepShape_HArray1OfShapeDimensionRepresentationItem theItems, Handle_StepRepr_RepresentationContext theContextOfItems)

        Initialize all fields AP242

        :type theName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type theItems: OCC.wrapper.StepShape.Handle_StepShape_HArray1OfShapeDimensionRepresentationItem
        :type theContextOfItems: OCC.wrapper.StepRepr.Handle_StepRepr_RepresentationContext

        """
        return _StepShape.StepShape_ShapeDimensionRepresentation_Init(self, *args)


    def SetItemsAP242(self, *args):
        """
        SetItemsAP242(StepShape_ShapeDimensionRepresentation self, Handle_StepShape_HArray1OfShapeDimensionRepresentationItem theItems)

        :type theItems: OCC.wrapper.StepShape.Handle_StepShape_HArray1OfShapeDimensionRepresentationItem

        """
        return _StepShape.StepShape_ShapeDimensionRepresentation_SetItemsAP242(self, *args)


    def ItemsAP242(self, *args):
        """
        ItemsAP242(StepShape_ShapeDimensionRepresentation self) -> Handle_StepShape_HArray1OfShapeDimensionRepresentationItem

        :rtype: OCC.wrapper.StepShape.Handle_StepShape_HArray1OfShapeDimensionRepresentationItem

        """
        return _StepShape.StepShape_ShapeDimensionRepresentation_ItemsAP242(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepShape.StepShape_ShapeDimensionRepresentation_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepShape.StepShape_ShapeDimensionRepresentation_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.StepShape_ShapeDimensionRepresentation_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepShape.delete_StepShape_ShapeDimensionRepresentation
StepShape_ShapeDimensionRepresentation_swigregister = _StepShape.StepShape_ShapeDimensionRepresentation_swigregister
StepShape_ShapeDimensionRepresentation_swigregister(StepShape_ShapeDimensionRepresentation)

def StepShape_ShapeDimensionRepresentation_get_type_name(*args):
    """
    StepShape_ShapeDimensionRepresentation_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepShape.StepShape_ShapeDimensionRepresentation_get_type_name(*args)

def StepShape_ShapeDimensionRepresentation_get_type_descriptor(*args):
    """
    StepShape_ShapeDimensionRepresentation_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepShape.StepShape_ShapeDimensionRepresentation_get_type_descriptor(*args)

class StepShape_FaceSurface(StepShape_Face):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepShape_FaceSurface
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepShape_FaceSurface(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepShape_FaceSurface self) -> StepShape_FaceSurface

        Returns a FaceSurface


        """
        this = _StepShape.new_StepShape_FaceSurface(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepShape_FaceSurface self, Handle_TCollection_HAsciiString aName, Handle_StepShape_HArray1OfFaceBound aBounds, Handle_StepGeom_Surface aFaceGeometry, Standard_Boolean const aSameSense)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aBounds: OCC.wrapper.StepShape.Handle_StepShape_HArray1OfFaceBound
        :type aFaceGeometry: OCC.wrapper.StepShape.Handle_StepGeom_Surface
        :type aSameSense: bool

        """
        return _StepShape.StepShape_FaceSurface_Init(self, *args)


    def SetFaceGeometry(self, *args):
        """
        SetFaceGeometry(StepShape_FaceSurface self, Handle_StepGeom_Surface aFaceGeometry)

        :type aFaceGeometry: OCC.wrapper.StepShape.Handle_StepGeom_Surface

        """
        return _StepShape.StepShape_FaceSurface_SetFaceGeometry(self, *args)


    def FaceGeometry(self, *args):
        """
        FaceGeometry(StepShape_FaceSurface self) -> Handle_StepGeom_Surface

        :rtype: OCC.wrapper.StepShape.Handle_StepGeom_Surface

        """
        return _StepShape.StepShape_FaceSurface_FaceGeometry(self, *args)


    def SetSameSense(self, *args):
        """
        SetSameSense(StepShape_FaceSurface self, Standard_Boolean const aSameSense)

        :type aSameSense: bool

        """
        return _StepShape.StepShape_FaceSurface_SetSameSense(self, *args)


    def SameSense(self, *args):
        """
        SameSense(StepShape_FaceSurface self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.StepShape_FaceSurface_SameSense(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepShape.StepShape_FaceSurface_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepShape.StepShape_FaceSurface_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.StepShape_FaceSurface_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepShape.delete_StepShape_FaceSurface
StepShape_FaceSurface_swigregister = _StepShape.StepShape_FaceSurface_swigregister
StepShape_FaceSurface_swigregister(StepShape_FaceSurface)

def StepShape_FaceSurface_get_type_name(*args):
    """
    StepShape_FaceSurface_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepShape.StepShape_FaceSurface_get_type_name(*args)

def StepShape_FaceSurface_get_type_descriptor(*args):
    """
    StepShape_FaceSurface_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepShape.StepShape_FaceSurface_get_type_descriptor(*args)

class StepShape_HArray1OfOrientedClosedShell(Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepShape_HArray1OfOrientedClosedShell
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepShape_HArray1OfOrientedClosedShell(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepShape_HArray1OfOrientedClosedShell self, Standard_Integer const theLower, Standard_Integer const theUpper) -> StepShape_HArray1OfOrientedClosedShell
        __init__(StepShape_HArray1OfOrientedClosedShell self, Standard_Integer const theLower, Standard_Integer const theUpper, Handle_StepShape_OrientedClosedShell theValue) -> StepShape_HArray1OfOrientedClosedShell
        __init__(StepShape_HArray1OfOrientedClosedShell self, NCollection_Array1_Handle_StepShape_OrientedClosedShell theOther) -> StepShape_HArray1OfOrientedClosedShell

        :type theOther: OCC.wrapper.StepShape.StepShape_Array1OfOrientedClosedShell

        """
        this = _StepShape.new_StepShape_HArray1OfOrientedClosedShell(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Array1(self, *args):
        """
        :rtype: OCC.wrapper.StepShape.StepShape_Array1OfOrientedClosedShell

        """
        res = _StepShape.StepShape_HArray1OfOrientedClosedShell_Array1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeArray1(self, *args):
        """
        ChangeArray1(StepShape_HArray1OfOrientedClosedShell self) -> NCollection_Array1_Handle_StepShape_OrientedClosedShell

        :rtype: OCC.wrapper.StepShape.StepShape_Array1OfOrientedClosedShell

        """
        return _StepShape.StepShape_HArray1OfOrientedClosedShell_ChangeArray1(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepShape.StepShape_HArray1OfOrientedClosedShell_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepShape.StepShape_HArray1OfOrientedClosedShell_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.StepShape_HArray1OfOrientedClosedShell_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepShape.delete_StepShape_HArray1OfOrientedClosedShell
StepShape_HArray1OfOrientedClosedShell_swigregister = _StepShape.StepShape_HArray1OfOrientedClosedShell_swigregister
StepShape_HArray1OfOrientedClosedShell_swigregister(StepShape_HArray1OfOrientedClosedShell)

def StepShape_HArray1OfOrientedClosedShell_get_type_name(*args):
    """
    StepShape_HArray1OfOrientedClosedShell_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepShape.StepShape_HArray1OfOrientedClosedShell_get_type_name(*args)

def StepShape_HArray1OfOrientedClosedShell_get_type_descriptor(*args):
    """
    StepShape_HArray1OfOrientedClosedShell_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepShape.StepShape_HArray1OfOrientedClosedShell_get_type_descriptor(*args)

class StepShape_NonManifoldSurfaceShapeRepresentation(StepShape_ShapeRepresentation):
    """Representation of STEP entity NonManifoldSurfaceShapeRepresentation"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepShape_NonManifoldSurfaceShapeRepresentation
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepShape_NonManifoldSurfaceShapeRepresentation(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepShape_NonManifoldSurfaceShapeRepresentation self) -> StepShape_NonManifoldSurfaceShapeRepresentation

        Empty constructor


        """
        this = _StepShape.new_StepShape_NonManifoldSurfaceShapeRepresentation(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepShape.StepShape_NonManifoldSurfaceShapeRepresentation_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepShape.StepShape_NonManifoldSurfaceShapeRepresentation_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.StepShape_NonManifoldSurfaceShapeRepresentation_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepShape.delete_StepShape_NonManifoldSurfaceShapeRepresentation
StepShape_NonManifoldSurfaceShapeRepresentation_swigregister = _StepShape.StepShape_NonManifoldSurfaceShapeRepresentation_swigregister
StepShape_NonManifoldSurfaceShapeRepresentation_swigregister(StepShape_NonManifoldSurfaceShapeRepresentation)

def StepShape_NonManifoldSurfaceShapeRepresentation_get_type_name(*args):
    """
    StepShape_NonManifoldSurfaceShapeRepresentation_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepShape.StepShape_NonManifoldSurfaceShapeRepresentation_get_type_name(*args)

def StepShape_NonManifoldSurfaceShapeRepresentation_get_type_descriptor(*args):
    """
    StepShape_NonManifoldSurfaceShapeRepresentation_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepShape.StepShape_NonManifoldSurfaceShapeRepresentation_get_type_descriptor(*args)

class StepShape_CsgShapeRepresentation(StepShape_ShapeRepresentation):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepShape_CsgShapeRepresentation
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepShape_CsgShapeRepresentation(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepShape_CsgShapeRepresentation self) -> StepShape_CsgShapeRepresentation

        Returns a CsgShapeRepresentation


        """
        this = _StepShape.new_StepShape_CsgShapeRepresentation(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepShape.StepShape_CsgShapeRepresentation_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepShape.StepShape_CsgShapeRepresentation_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.StepShape_CsgShapeRepresentation_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepShape.delete_StepShape_CsgShapeRepresentation
StepShape_CsgShapeRepresentation_swigregister = _StepShape.StepShape_CsgShapeRepresentation_swigregister
StepShape_CsgShapeRepresentation_swigregister(StepShape_CsgShapeRepresentation)

def StepShape_CsgShapeRepresentation_get_type_name(*args):
    """
    StepShape_CsgShapeRepresentation_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepShape.StepShape_CsgShapeRepresentation_get_type_name(*args)

def StepShape_CsgShapeRepresentation_get_type_descriptor(*args):
    """
    StepShape_CsgShapeRepresentation_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepShape.StepShape_CsgShapeRepresentation_get_type_descriptor(*args)

class StepShape_DirectedDimensionalLocation(StepShape_DimensionalLocation):
    """Representation of STEP entity DirectedDimensionalLocation"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepShape_DirectedDimensionalLocation
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepShape_DirectedDimensionalLocation(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepShape_DirectedDimensionalLocation self) -> StepShape_DirectedDimensionalLocation

        Empty constructor


        """
        this = _StepShape.new_StepShape_DirectedDimensionalLocation(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepShape.StepShape_DirectedDimensionalLocation_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepShape.StepShape_DirectedDimensionalLocation_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.StepShape_DirectedDimensionalLocation_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepShape.delete_StepShape_DirectedDimensionalLocation
StepShape_DirectedDimensionalLocation_swigregister = _StepShape.StepShape_DirectedDimensionalLocation_swigregister
StepShape_DirectedDimensionalLocation_swigregister(StepShape_DirectedDimensionalLocation)

def StepShape_DirectedDimensionalLocation_get_type_name(*args):
    """
    StepShape_DirectedDimensionalLocation_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepShape.StepShape_DirectedDimensionalLocation_get_type_name(*args)

def StepShape_DirectedDimensionalLocation_get_type_descriptor(*args):
    """
    StepShape_DirectedDimensionalLocation_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepShape.StepShape_DirectedDimensionalLocation_get_type_descriptor(*args)

class StepShape_DimensionalCharacteristicRepresentation(Standard.Standard_Transient):
    """Representation of STEP entity DimensionalCharacteristicRepresentation"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepShape_DimensionalCharacteristicRepresentation
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepShape_DimensionalCharacteristicRepresentation(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepShape_DimensionalCharacteristicRepresentation self) -> StepShape_DimensionalCharacteristicRepresentation

        Empty constructor


        """
        this = _StepShape.new_StepShape_DimensionalCharacteristicRepresentation(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepShape_DimensionalCharacteristicRepresentation self, StepShape_DimensionalCharacteristic aDimension, Handle_StepShape_ShapeDimensionRepresentation aRepresentation)

        Initialize all fields (own and inherited)

        :type aDimension: OCC.wrapper.StepShape.StepShape_DimensionalCharacteristic
        :type aRepresentation: OCC.wrapper.StepShape.Handle_StepShape_ShapeDimensionRepresentation

        """
        return _StepShape.StepShape_DimensionalCharacteristicRepresentation_Init(self, *args)


    def Dimension(self, *args):
        """
        Dimension(StepShape_DimensionalCharacteristicRepresentation self) -> StepShape_DimensionalCharacteristic

        Returns field Dimension

        :rtype: OCC.wrapper.StepShape.StepShape_DimensionalCharacteristic

        """
        return _StepShape.StepShape_DimensionalCharacteristicRepresentation_Dimension(self, *args)


    def SetDimension(self, *args):
        """
        SetDimension(StepShape_DimensionalCharacteristicRepresentation self, StepShape_DimensionalCharacteristic Dimension)

        Set field Dimension

        :type Dimension: OCC.wrapper.StepShape.StepShape_DimensionalCharacteristic

        """
        return _StepShape.StepShape_DimensionalCharacteristicRepresentation_SetDimension(self, *args)


    def Representation(self, *args):
        """
        Representation(StepShape_DimensionalCharacteristicRepresentation self) -> Handle_StepShape_ShapeDimensionRepresentation

        Returns field Representation

        :rtype: OCC.wrapper.StepShape.Handle_StepShape_ShapeDimensionRepresentation

        """
        return _StepShape.StepShape_DimensionalCharacteristicRepresentation_Representation(self, *args)


    def SetRepresentation(self, *args):
        """
        SetRepresentation(StepShape_DimensionalCharacteristicRepresentation self, Handle_StepShape_ShapeDimensionRepresentation Representation)

        Set field Representation

        :type Representation: OCC.wrapper.StepShape.Handle_StepShape_ShapeDimensionRepresentation

        """
        return _StepShape.StepShape_DimensionalCharacteristicRepresentation_SetRepresentation(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepShape.StepShape_DimensionalCharacteristicRepresentation_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepShape.StepShape_DimensionalCharacteristicRepresentation_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.StepShape_DimensionalCharacteristicRepresentation_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepShape.delete_StepShape_DimensionalCharacteristicRepresentation
StepShape_DimensionalCharacteristicRepresentation_swigregister = _StepShape.StepShape_DimensionalCharacteristicRepresentation_swigregister
StepShape_DimensionalCharacteristicRepresentation_swigregister(StepShape_DimensionalCharacteristicRepresentation)

def StepShape_DimensionalCharacteristicRepresentation_get_type_name(*args):
    """
    StepShape_DimensionalCharacteristicRepresentation_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepShape.StepShape_DimensionalCharacteristicRepresentation_get_type_name(*args)

def StepShape_DimensionalCharacteristicRepresentation_get_type_descriptor(*args):
    """
    StepShape_DimensionalCharacteristicRepresentation_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepShape.StepShape_DimensionalCharacteristicRepresentation_get_type_descriptor(*args)

class StepShape_EdgeBasedWireframeModel(StepGeom.StepGeom_GeometricRepresentationItem):
    """Representation of STEP entity EdgeBasedWireframeModel"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepShape_EdgeBasedWireframeModel
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepShape_EdgeBasedWireframeModel(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepShape_EdgeBasedWireframeModel self) -> StepShape_EdgeBasedWireframeModel

        Empty constructor


        """
        this = _StepShape.new_StepShape_EdgeBasedWireframeModel(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepShape_EdgeBasedWireframeModel self, Handle_TCollection_HAsciiString aRepresentationItem_Name, Handle_StepShape_HArray1OfConnectedEdgeSet aEbwmBoundary)

        Initialize all fields (own and inherited)

        :type aRepresentationItem_Name: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aEbwmBoundary: OCC.wrapper.StepShape.Handle_StepShape_HArray1OfConnectedEdgeSet

        """
        return _StepShape.StepShape_EdgeBasedWireframeModel_Init(self, *args)


    def EbwmBoundary(self, *args):
        """
        EbwmBoundary(StepShape_EdgeBasedWireframeModel self) -> Handle_StepShape_HArray1OfConnectedEdgeSet

        Returns field EbwmBoundary

        :rtype: OCC.wrapper.StepShape.Handle_StepShape_HArray1OfConnectedEdgeSet

        """
        return _StepShape.StepShape_EdgeBasedWireframeModel_EbwmBoundary(self, *args)


    def SetEbwmBoundary(self, *args):
        """
        SetEbwmBoundary(StepShape_EdgeBasedWireframeModel self, Handle_StepShape_HArray1OfConnectedEdgeSet EbwmBoundary)

        Set field EbwmBoundary

        :type EbwmBoundary: OCC.wrapper.StepShape.Handle_StepShape_HArray1OfConnectedEdgeSet

        """
        return _StepShape.StepShape_EdgeBasedWireframeModel_SetEbwmBoundary(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepShape.StepShape_EdgeBasedWireframeModel_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepShape.StepShape_EdgeBasedWireframeModel_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.StepShape_EdgeBasedWireframeModel_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepShape.delete_StepShape_EdgeBasedWireframeModel
StepShape_EdgeBasedWireframeModel_swigregister = _StepShape.StepShape_EdgeBasedWireframeModel_swigregister
StepShape_EdgeBasedWireframeModel_swigregister(StepShape_EdgeBasedWireframeModel)

def StepShape_EdgeBasedWireframeModel_get_type_name(*args):
    """
    StepShape_EdgeBasedWireframeModel_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepShape.StepShape_EdgeBasedWireframeModel_get_type_name(*args)

def StepShape_EdgeBasedWireframeModel_get_type_descriptor(*args):
    """
    StepShape_EdgeBasedWireframeModel_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepShape.StepShape_EdgeBasedWireframeModel_get_type_descriptor(*args)

class StepShape_OrientedClosedShell(StepShape_ClosedShell):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepShape_OrientedClosedShell
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepShape_OrientedClosedShell(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepShape_OrientedClosedShell self) -> StepShape_OrientedClosedShell

        Returns a OrientedClosedShell


        """
        this = _StepShape.new_StepShape_OrientedClosedShell(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepShape_OrientedClosedShell self, Handle_TCollection_HAsciiString aName, Handle_StepShape_ClosedShell aClosedShellElement, Standard_Boolean const aOrientation)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aClosedShellElement: OCC.wrapper.StepShape.Handle_StepShape_ClosedShell
        :type aOrientation: bool

        """
        return _StepShape.StepShape_OrientedClosedShell_Init(self, *args)


    def SetClosedShellElement(self, *args):
        """
        SetClosedShellElement(StepShape_OrientedClosedShell self, Handle_StepShape_ClosedShell aClosedShellElement)

        :type aClosedShellElement: OCC.wrapper.StepShape.Handle_StepShape_ClosedShell

        """
        return _StepShape.StepShape_OrientedClosedShell_SetClosedShellElement(self, *args)


    def ClosedShellElement(self, *args):
        """
        ClosedShellElement(StepShape_OrientedClosedShell self) -> Handle_StepShape_ClosedShell

        :rtype: OCC.wrapper.StepShape.Handle_StepShape_ClosedShell

        """
        return _StepShape.StepShape_OrientedClosedShell_ClosedShellElement(self, *args)


    def SetOrientation(self, *args):
        """
        SetOrientation(StepShape_OrientedClosedShell self, Standard_Boolean const aOrientation)

        :type aOrientation: bool

        """
        return _StepShape.StepShape_OrientedClosedShell_SetOrientation(self, *args)


    def Orientation(self, *args):
        """
        Orientation(StepShape_OrientedClosedShell self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.StepShape_OrientedClosedShell_Orientation(self, *args)


    def SetCfsFaces(self, *args):
        """
        SetCfsFaces(StepShape_OrientedClosedShell self, Handle_StepShape_HArray1OfFace aCfsFaces)

        :type aCfsFaces: OCC.wrapper.StepShape.Handle_StepShape_HArray1OfFace

        """
        return _StepShape.StepShape_OrientedClosedShell_SetCfsFaces(self, *args)


    def CfsFaces(self, *args):
        """
        CfsFaces(StepShape_OrientedClosedShell self) -> Handle_StepShape_HArray1OfFace

        :rtype: OCC.wrapper.StepShape.Handle_StepShape_HArray1OfFace

        """
        return _StepShape.StepShape_OrientedClosedShell_CfsFaces(self, *args)


    def CfsFacesValue(self, *args):
        """
        CfsFacesValue(StepShape_OrientedClosedShell self, Standard_Integer const num) -> Handle_StepShape_Face

        :type num: int
        :rtype: OCC.wrapper.StepShape.Handle_StepShape_Face

        """
        return _StepShape.StepShape_OrientedClosedShell_CfsFacesValue(self, *args)


    def NbCfsFaces(self, *args):
        """
        NbCfsFaces(StepShape_OrientedClosedShell self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.StepShape_OrientedClosedShell_NbCfsFaces(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepShape.StepShape_OrientedClosedShell_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepShape.StepShape_OrientedClosedShell_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.StepShape_OrientedClosedShell_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepShape.delete_StepShape_OrientedClosedShell
StepShape_OrientedClosedShell_swigregister = _StepShape.StepShape_OrientedClosedShell_swigregister
StepShape_OrientedClosedShell_swigregister(StepShape_OrientedClosedShell)

def StepShape_OrientedClosedShell_get_type_name(*args):
    """
    StepShape_OrientedClosedShell_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepShape.StepShape_OrientedClosedShell_get_type_name(*args)

def StepShape_OrientedClosedShell_get_type_descriptor(*args):
    """
    StepShape_OrientedClosedShell_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepShape.StepShape_OrientedClosedShell_get_type_descriptor(*args)

class StepShape_EdgeBasedWireframeShapeRepresentation(StepShape_ShapeRepresentation):
    """Representation of STEP entity EdgeBasedWireframeShapeRepresentation"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepShape_EdgeBasedWireframeShapeRepresentation
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepShape_EdgeBasedWireframeShapeRepresentation(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepShape_EdgeBasedWireframeShapeRepresentation self) -> StepShape_EdgeBasedWireframeShapeRepresentation

        Empty constructor


        """
        this = _StepShape.new_StepShape_EdgeBasedWireframeShapeRepresentation(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepShape.StepShape_EdgeBasedWireframeShapeRepresentation_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepShape.StepShape_EdgeBasedWireframeShapeRepresentation_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.StepShape_EdgeBasedWireframeShapeRepresentation_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepShape.delete_StepShape_EdgeBasedWireframeShapeRepresentation
StepShape_EdgeBasedWireframeShapeRepresentation_swigregister = _StepShape.StepShape_EdgeBasedWireframeShapeRepresentation_swigregister
StepShape_EdgeBasedWireframeShapeRepresentation_swigregister(StepShape_EdgeBasedWireframeShapeRepresentation)

def StepShape_EdgeBasedWireframeShapeRepresentation_get_type_name(*args):
    """
    StepShape_EdgeBasedWireframeShapeRepresentation_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepShape.StepShape_EdgeBasedWireframeShapeRepresentation_get_type_name(*args)

def StepShape_EdgeBasedWireframeShapeRepresentation_get_type_descriptor(*args):
    """
    StepShape_EdgeBasedWireframeShapeRepresentation_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepShape.StepShape_EdgeBasedWireframeShapeRepresentation_get_type_descriptor(*args)

class StepShape_PrecisionQualifier(Standard.Standard_Transient):
    """Added for Dimensional Tolerances"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepShape_PrecisionQualifier
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepShape_PrecisionQualifier(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepShape_PrecisionQualifier self) -> StepShape_PrecisionQualifier

        Added for Dimensional Tolerances
        """
        this = _StepShape.new_StepShape_PrecisionQualifier(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepShape_PrecisionQualifier self, Standard_Integer const precision_value)

        :type precision_value: int

        """
        return _StepShape.StepShape_PrecisionQualifier_Init(self, *args)


    def PrecisionValue(self, *args):
        """
        PrecisionValue(StepShape_PrecisionQualifier self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.StepShape_PrecisionQualifier_PrecisionValue(self, *args)


    def SetPrecisionValue(self, *args):
        """
        SetPrecisionValue(StepShape_PrecisionQualifier self, Standard_Integer const precision_value)

        :type precision_value: int

        """
        return _StepShape.StepShape_PrecisionQualifier_SetPrecisionValue(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepShape.StepShape_PrecisionQualifier_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepShape.StepShape_PrecisionQualifier_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.StepShape_PrecisionQualifier_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepShape.delete_StepShape_PrecisionQualifier
StepShape_PrecisionQualifier_swigregister = _StepShape.StepShape_PrecisionQualifier_swigregister
StepShape_PrecisionQualifier_swigregister(StepShape_PrecisionQualifier)

def StepShape_PrecisionQualifier_get_type_name(*args):
    """
    StepShape_PrecisionQualifier_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepShape.StepShape_PrecisionQualifier_get_type_name(*args)

def StepShape_PrecisionQualifier_get_type_descriptor(*args):
    """
    StepShape_PrecisionQualifier_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepShape.StepShape_PrecisionQualifier_get_type_descriptor(*args)

class StepShape_GeometricSet(StepGeom.StepGeom_GeometricRepresentationItem):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepShape_GeometricSet
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepShape_GeometricSet(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepShape_GeometricSet self) -> StepShape_GeometricSet

        Returns a GeometricSet


        """
        this = _StepShape.new_StepShape_GeometricSet(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepShape_GeometricSet self, Handle_TCollection_HAsciiString aName, Handle_StepShape_HArray1OfGeometricSetSelect aElements)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aElements: OCC.wrapper.StepShape.Handle_StepShape_HArray1OfGeometricSetSelect

        """
        return _StepShape.StepShape_GeometricSet_Init(self, *args)


    def SetElements(self, *args):
        """
        SetElements(StepShape_GeometricSet self, Handle_StepShape_HArray1OfGeometricSetSelect aElements)

        :type aElements: OCC.wrapper.StepShape.Handle_StepShape_HArray1OfGeometricSetSelect

        """
        return _StepShape.StepShape_GeometricSet_SetElements(self, *args)


    def Elements(self, *args):
        """
        Elements(StepShape_GeometricSet self) -> Handle_StepShape_HArray1OfGeometricSetSelect

        :rtype: OCC.wrapper.StepShape.Handle_StepShape_HArray1OfGeometricSetSelect

        """
        return _StepShape.StepShape_GeometricSet_Elements(self, *args)


    def ElementsValue(self, *args):
        """
        ElementsValue(StepShape_GeometricSet self, Standard_Integer const num) -> StepShape_GeometricSetSelect

        :type num: int
        :rtype: OCC.wrapper.StepShape.StepShape_GeometricSetSelect

        """
        return _StepShape.StepShape_GeometricSet_ElementsValue(self, *args)


    def NbElements(self, *args):
        """
        NbElements(StepShape_GeometricSet self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.StepShape_GeometricSet_NbElements(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepShape.StepShape_GeometricSet_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepShape.StepShape_GeometricSet_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.StepShape_GeometricSet_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepShape.delete_StepShape_GeometricSet
StepShape_GeometricSet_swigregister = _StepShape.StepShape_GeometricSet_swigregister
StepShape_GeometricSet_swigregister(StepShape_GeometricSet)

def StepShape_GeometricSet_get_type_name(*args):
    """
    StepShape_GeometricSet_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepShape.StepShape_GeometricSet_get_type_name(*args)

def StepShape_GeometricSet_get_type_descriptor(*args):
    """
    StepShape_GeometricSet_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepShape.StepShape_GeometricSet_get_type_descriptor(*args)

class StepShape_SolidReplica(StepShape_SolidModel):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepShape_SolidReplica
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepShape_SolidReplica(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepShape_SolidReplica self) -> StepShape_SolidReplica

        Returns a SolidReplica


        """
        this = _StepShape.new_StepShape_SolidReplica(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepShape_SolidReplica self, Handle_TCollection_HAsciiString aName, Handle_StepShape_SolidModel aParentSolid, Handle_StepGeom_CartesianTransformationOperator3d aTransformation)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aParentSolid: OCC.wrapper.StepShape.Handle_StepShape_SolidModel
        :type aTransformation: OCC.wrapper.StepShape.Handle_StepGeom_CartesianTransformationOperator3d

        """
        return _StepShape.StepShape_SolidReplica_Init(self, *args)


    def SetParentSolid(self, *args):
        """
        SetParentSolid(StepShape_SolidReplica self, Handle_StepShape_SolidModel aParentSolid)

        :type aParentSolid: OCC.wrapper.StepShape.Handle_StepShape_SolidModel

        """
        return _StepShape.StepShape_SolidReplica_SetParentSolid(self, *args)


    def ParentSolid(self, *args):
        """
        ParentSolid(StepShape_SolidReplica self) -> Handle_StepShape_SolidModel

        :rtype: OCC.wrapper.StepShape.Handle_StepShape_SolidModel

        """
        return _StepShape.StepShape_SolidReplica_ParentSolid(self, *args)


    def SetTransformation(self, *args):
        """
        SetTransformation(StepShape_SolidReplica self, Handle_StepGeom_CartesianTransformationOperator3d aTransformation)

        :type aTransformation: OCC.wrapper.StepShape.Handle_StepGeom_CartesianTransformationOperator3d

        """
        return _StepShape.StepShape_SolidReplica_SetTransformation(self, *args)


    def Transformation(self, *args):
        """
        Transformation(StepShape_SolidReplica self) -> Handle_StepGeom_CartesianTransformationOperator3d

        :rtype: OCC.wrapper.StepShape.Handle_StepGeom_CartesianTransformationOperator3d

        """
        return _StepShape.StepShape_SolidReplica_Transformation(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepShape.StepShape_SolidReplica_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepShape.StepShape_SolidReplica_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.StepShape_SolidReplica_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepShape.delete_StepShape_SolidReplica
StepShape_SolidReplica_swigregister = _StepShape.StepShape_SolidReplica_swigregister
StepShape_SolidReplica_swigregister(StepShape_SolidReplica)

def StepShape_SolidReplica_get_type_name(*args):
    """
    StepShape_SolidReplica_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepShape.StepShape_SolidReplica_get_type_name(*args)

def StepShape_SolidReplica_get_type_descriptor(*args):
    """
    StepShape_SolidReplica_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepShape.StepShape_SolidReplica_get_type_descriptor(*args)

class StepShape_HArray1OfConnectedFaceSet(Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepShape_HArray1OfConnectedFaceSet
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepShape_HArray1OfConnectedFaceSet(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepShape_HArray1OfConnectedFaceSet self, Standard_Integer const theLower, Standard_Integer const theUpper) -> StepShape_HArray1OfConnectedFaceSet
        __init__(StepShape_HArray1OfConnectedFaceSet self, Standard_Integer const theLower, Standard_Integer const theUpper, Handle_StepShape_ConnectedFaceSet theValue) -> StepShape_HArray1OfConnectedFaceSet
        __init__(StepShape_HArray1OfConnectedFaceSet self, NCollection_Array1_Handle_StepShape_ConnectedFaceSet theOther) -> StepShape_HArray1OfConnectedFaceSet

        :type theOther: OCC.wrapper.StepShape.StepShape_Array1OfConnectedFaceSet

        """
        this = _StepShape.new_StepShape_HArray1OfConnectedFaceSet(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Array1(self, *args):
        """
        :rtype: OCC.wrapper.StepShape.StepShape_Array1OfConnectedFaceSet

        """
        res = _StepShape.StepShape_HArray1OfConnectedFaceSet_Array1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeArray1(self, *args):
        """
        ChangeArray1(StepShape_HArray1OfConnectedFaceSet self) -> NCollection_Array1_Handle_StepShape_ConnectedFaceSet

        :rtype: OCC.wrapper.StepShape.StepShape_Array1OfConnectedFaceSet

        """
        return _StepShape.StepShape_HArray1OfConnectedFaceSet_ChangeArray1(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepShape.StepShape_HArray1OfConnectedFaceSet_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepShape.StepShape_HArray1OfConnectedFaceSet_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.StepShape_HArray1OfConnectedFaceSet_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepShape.delete_StepShape_HArray1OfConnectedFaceSet
StepShape_HArray1OfConnectedFaceSet_swigregister = _StepShape.StepShape_HArray1OfConnectedFaceSet_swigregister
StepShape_HArray1OfConnectedFaceSet_swigregister(StepShape_HArray1OfConnectedFaceSet)

def StepShape_HArray1OfConnectedFaceSet_get_type_name(*args):
    """
    StepShape_HArray1OfConnectedFaceSet_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepShape.StepShape_HArray1OfConnectedFaceSet_get_type_name(*args)

def StepShape_HArray1OfConnectedFaceSet_get_type_descriptor(*args):
    """
    StepShape_HArray1OfConnectedFaceSet_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepShape.StepShape_HArray1OfConnectedFaceSet_get_type_descriptor(*args)

class StepShape_Subface(StepShape_Face):
    """Representation of STEP entity Subface"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepShape_Subface
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepShape_Subface(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepShape_Subface self) -> StepShape_Subface

        Empty constructor


        """
        this = _StepShape.new_StepShape_Subface(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepShape_Subface self, Handle_TCollection_HAsciiString aRepresentationItem_Name, Handle_StepShape_HArray1OfFaceBound aFace_Bounds, Handle_StepShape_Face aParentFace)

        Initialize all fields (own and inherited)

        :type aRepresentationItem_Name: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aFace_Bounds: OCC.wrapper.StepShape.Handle_StepShape_HArray1OfFaceBound
        :type aParentFace: OCC.wrapper.StepShape.Handle_StepShape_Face

        """
        return _StepShape.StepShape_Subface_Init(self, *args)


    def ParentFace(self, *args):
        """
        ParentFace(StepShape_Subface self) -> Handle_StepShape_Face

        Returns field ParentFace

        :rtype: OCC.wrapper.StepShape.Handle_StepShape_Face

        """
        return _StepShape.StepShape_Subface_ParentFace(self, *args)


    def SetParentFace(self, *args):
        """
        SetParentFace(StepShape_Subface self, Handle_StepShape_Face ParentFace)

        Set field ParentFace

        :type ParentFace: OCC.wrapper.StepShape.Handle_StepShape_Face

        """
        return _StepShape.StepShape_Subface_SetParentFace(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepShape.StepShape_Subface_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepShape.StepShape_Subface_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.StepShape_Subface_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepShape.delete_StepShape_Subface
StepShape_Subface_swigregister = _StepShape.StepShape_Subface_swigregister
StepShape_Subface_swigregister(StepShape_Subface)

def StepShape_Subface_get_type_name(*args):
    """
    StepShape_Subface_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepShape.StepShape_Subface_get_type_name(*args)

def StepShape_Subface_get_type_descriptor(*args):
    """
    StepShape_Subface_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepShape.StepShape_Subface_get_type_descriptor(*args)

class StepShape_ShapeRepresentationWithParameters(StepShape_ShapeRepresentation):
    """Representation of STEP entity ShapeRepresentationWithParameters"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepShape_ShapeRepresentationWithParameters
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepShape_ShapeRepresentationWithParameters(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepShape_ShapeRepresentationWithParameters self) -> StepShape_ShapeRepresentationWithParameters

        Empty constructor


        """
        this = _StepShape.new_StepShape_ShapeRepresentationWithParameters(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepShape.StepShape_ShapeRepresentationWithParameters_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepShape.StepShape_ShapeRepresentationWithParameters_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.StepShape_ShapeRepresentationWithParameters_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepShape.delete_StepShape_ShapeRepresentationWithParameters
StepShape_ShapeRepresentationWithParameters_swigregister = _StepShape.StepShape_ShapeRepresentationWithParameters_swigregister
StepShape_ShapeRepresentationWithParameters_swigregister(StepShape_ShapeRepresentationWithParameters)

def StepShape_ShapeRepresentationWithParameters_get_type_name(*args):
    """
    StepShape_ShapeRepresentationWithParameters_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepShape.StepShape_ShapeRepresentationWithParameters_get_type_name(*args)

def StepShape_ShapeRepresentationWithParameters_get_type_descriptor(*args):
    """
    StepShape_ShapeRepresentationWithParameters_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepShape.StepShape_ShapeRepresentationWithParameters_get_type_descriptor(*args)

class StepShape_RevolvedAreaSolid(StepShape_SweptAreaSolid):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepShape_RevolvedAreaSolid
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepShape_RevolvedAreaSolid(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepShape_RevolvedAreaSolid self) -> StepShape_RevolvedAreaSolid

        Returns a RevolvedAreaSolid


        """
        this = _StepShape.new_StepShape_RevolvedAreaSolid(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepShape_RevolvedAreaSolid self, Handle_TCollection_HAsciiString aName, Handle_StepGeom_CurveBoundedSurface aSweptArea, Handle_StepGeom_Axis1Placement aAxis, Standard_Real const aAngle)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aSweptArea: OCC.wrapper.StepShape.Handle_StepGeom_CurveBoundedSurface
        :type aAxis: OCC.wrapper.StepShape.Handle_StepGeom_Axis1Placement
        :type aAngle: float

        """
        return _StepShape.StepShape_RevolvedAreaSolid_Init(self, *args)


    def SetAxis(self, *args):
        """
        SetAxis(StepShape_RevolvedAreaSolid self, Handle_StepGeom_Axis1Placement aAxis)

        :type aAxis: OCC.wrapper.StepShape.Handle_StepGeom_Axis1Placement

        """
        return _StepShape.StepShape_RevolvedAreaSolid_SetAxis(self, *args)


    def Axis(self, *args):
        """
        Axis(StepShape_RevolvedAreaSolid self) -> Handle_StepGeom_Axis1Placement

        :rtype: OCC.wrapper.StepShape.Handle_StepGeom_Axis1Placement

        """
        return _StepShape.StepShape_RevolvedAreaSolid_Axis(self, *args)


    def SetAngle(self, *args):
        """
        SetAngle(StepShape_RevolvedAreaSolid self, Standard_Real const aAngle)

        :type aAngle: float

        """
        return _StepShape.StepShape_RevolvedAreaSolid_SetAngle(self, *args)


    def Angle(self, *args):
        """
        Angle(StepShape_RevolvedAreaSolid self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _StepShape.StepShape_RevolvedAreaSolid_Angle(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepShape.StepShape_RevolvedAreaSolid_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepShape.StepShape_RevolvedAreaSolid_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.StepShape_RevolvedAreaSolid_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepShape.delete_StepShape_RevolvedAreaSolid
StepShape_RevolvedAreaSolid_swigregister = _StepShape.StepShape_RevolvedAreaSolid_swigregister
StepShape_RevolvedAreaSolid_swigregister(StepShape_RevolvedAreaSolid)

def StepShape_RevolvedAreaSolid_get_type_name(*args):
    """
    StepShape_RevolvedAreaSolid_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepShape.StepShape_RevolvedAreaSolid_get_type_name(*args)

def StepShape_RevolvedAreaSolid_get_type_descriptor(*args):
    """
    StepShape_RevolvedAreaSolid_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepShape.StepShape_RevolvedAreaSolid_get_type_descriptor(*args)

class StepShape_ValueQualifier(StepData.StepData_SelectType):
    """Added for Dimensional Tolerances"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(StepShape_ValueQualifier self) -> StepShape_ValueQualifier

        Added for Dimensional Tolerances
        """
        this = _StepShape.new_StepShape_ValueQualifier(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def CaseNum(self, *args):
        """
        CaseNum(StepShape_ValueQualifier self, Handle_Standard_Transient ent) -> Standard_Integer

        Recognizes a kind of ValueQualifier Select Type :
        1 -> PrecisionQualifier from StepShape
        2 -> TypeQualifier from StepShape
        3 -> UnceraintyQualifier .. not yet implemented
        4 -> ValueFormatTypeQualifier

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.StepShape_ValueQualifier_CaseNum(self, *args)


    def PrecisionQualifier(self, *args):
        """
        PrecisionQualifier(StepShape_ValueQualifier self) -> Handle_StepShape_PrecisionQualifier

        Returns Value as PrecisionQualifier

        :rtype: OCC.wrapper.StepShape.Handle_StepShape_PrecisionQualifier

        """
        return _StepShape.StepShape_ValueQualifier_PrecisionQualifier(self, *args)


    def TypeQualifier(self, *args):
        """
        TypeQualifier(StepShape_ValueQualifier self) -> Handle_StepShape_TypeQualifier

        Returns Value as TypeQualifier

        :rtype: OCC.wrapper.StepShape.Handle_StepShape_TypeQualifier

        """
        return _StepShape.StepShape_ValueQualifier_TypeQualifier(self, *args)


    def ValueFormatTypeQualifier(self, *args):
        """
        ValueFormatTypeQualifier(StepShape_ValueQualifier self) -> Handle_StepShape_ValueFormatTypeQualifier

        Returns Value as ValueFormatTypeQualifier

        :rtype: OCC.wrapper.StepShape.Handle_StepShape_ValueFormatTypeQualifier

        """
        return _StepShape.StepShape_ValueQualifier_ValueFormatTypeQualifier(self, *args)

    __swig_destroy__ = _StepShape.delete_StepShape_ValueQualifier
StepShape_ValueQualifier_swigregister = _StepShape.StepShape_ValueQualifier_swigregister
StepShape_ValueQualifier_swigregister(StepShape_ValueQualifier)

class StepShape_OpenShell(StepShape_ConnectedFaceSet):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepShape_OpenShell
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepShape_OpenShell(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepShape_OpenShell self) -> StepShape_OpenShell

        Returns a OpenShell


        """
        this = _StepShape.new_StepShape_OpenShell(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepShape.StepShape_OpenShell_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepShape.StepShape_OpenShell_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.StepShape_OpenShell_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepShape.delete_StepShape_OpenShell
StepShape_OpenShell_swigregister = _StepShape.StepShape_OpenShell_swigregister
StepShape_OpenShell_swigregister(StepShape_OpenShell)

def StepShape_OpenShell_get_type_name(*args):
    """
    StepShape_OpenShell_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepShape.StepShape_OpenShell_get_type_name(*args)

def StepShape_OpenShell_get_type_descriptor(*args):
    """
    StepShape_OpenShell_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepShape.StepShape_OpenShell_get_type_descriptor(*args)

class StepShape_ExtrudedFaceSolid(StepShape_SweptFaceSolid):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepShape_ExtrudedFaceSolid
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepShape_ExtrudedFaceSolid(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepShape_ExtrudedFaceSolid self) -> StepShape_ExtrudedFaceSolid

        Returns a ExtrudedFaceSolid


        """
        this = _StepShape.new_StepShape_ExtrudedFaceSolid(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepShape_ExtrudedFaceSolid self, Handle_TCollection_HAsciiString aName, Handle_StepShape_FaceSurface aSweptArea, Handle_StepGeom_Direction aExtrudedDirection, Standard_Real const aDepth)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aSweptArea: OCC.wrapper.StepShape.Handle_StepShape_FaceSurface
        :type aExtrudedDirection: OCC.wrapper.StepShape.Handle_StepGeom_Direction
        :type aDepth: float

        """
        return _StepShape.StepShape_ExtrudedFaceSolid_Init(self, *args)


    def SetExtrudedDirection(self, *args):
        """
        SetExtrudedDirection(StepShape_ExtrudedFaceSolid self, Handle_StepGeom_Direction aExtrudedDirection)

        :type aExtrudedDirection: OCC.wrapper.StepShape.Handle_StepGeom_Direction

        """
        return _StepShape.StepShape_ExtrudedFaceSolid_SetExtrudedDirection(self, *args)


    def ExtrudedDirection(self, *args):
        """
        ExtrudedDirection(StepShape_ExtrudedFaceSolid self) -> Handle_StepGeom_Direction

        :rtype: OCC.wrapper.StepShape.Handle_StepGeom_Direction

        """
        return _StepShape.StepShape_ExtrudedFaceSolid_ExtrudedDirection(self, *args)


    def SetDepth(self, *args):
        """
        SetDepth(StepShape_ExtrudedFaceSolid self, Standard_Real const aDepth)

        :type aDepth: float

        """
        return _StepShape.StepShape_ExtrudedFaceSolid_SetDepth(self, *args)


    def Depth(self, *args):
        """
        Depth(StepShape_ExtrudedFaceSolid self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _StepShape.StepShape_ExtrudedFaceSolid_Depth(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepShape.StepShape_ExtrudedFaceSolid_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepShape.StepShape_ExtrudedFaceSolid_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.StepShape_ExtrudedFaceSolid_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepShape.delete_StepShape_ExtrudedFaceSolid
StepShape_ExtrudedFaceSolid_swigregister = _StepShape.StepShape_ExtrudedFaceSolid_swigregister
StepShape_ExtrudedFaceSolid_swigregister(StepShape_ExtrudedFaceSolid)

def StepShape_ExtrudedFaceSolid_get_type_name(*args):
    """
    StepShape_ExtrudedFaceSolid_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepShape.StepShape_ExtrudedFaceSolid_get_type_name(*args)

def StepShape_ExtrudedFaceSolid_get_type_descriptor(*args):
    """
    StepShape_ExtrudedFaceSolid_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepShape.StepShape_ExtrudedFaceSolid_get_type_descriptor(*args)

class StepShape_EdgeLoop(StepShape_Loop):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepShape_EdgeLoop
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepShape_EdgeLoop(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepShape_EdgeLoop self) -> StepShape_EdgeLoop

        Returns a EdgeLoop


        """
        this = _StepShape.new_StepShape_EdgeLoop(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepShape_EdgeLoop self, Handle_TCollection_HAsciiString aName, Handle_StepShape_HArray1OfOrientedEdge aEdgeList)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aEdgeList: OCC.wrapper.StepShape.Handle_StepShape_HArray1OfOrientedEdge

        """
        return _StepShape.StepShape_EdgeLoop_Init(self, *args)


    def SetEdgeList(self, *args):
        """
        SetEdgeList(StepShape_EdgeLoop self, Handle_StepShape_HArray1OfOrientedEdge aEdgeList)

        :type aEdgeList: OCC.wrapper.StepShape.Handle_StepShape_HArray1OfOrientedEdge

        """
        return _StepShape.StepShape_EdgeLoop_SetEdgeList(self, *args)


    def EdgeList(self, *args):
        """
        EdgeList(StepShape_EdgeLoop self) -> Handle_StepShape_HArray1OfOrientedEdge

        :rtype: OCC.wrapper.StepShape.Handle_StepShape_HArray1OfOrientedEdge

        """
        return _StepShape.StepShape_EdgeLoop_EdgeList(self, *args)


    def EdgeListValue(self, *args):
        """
        EdgeListValue(StepShape_EdgeLoop self, Standard_Integer const num) -> Handle_StepShape_OrientedEdge

        :type num: int
        :rtype: OCC.wrapper.StepShape.Handle_StepShape_OrientedEdge

        """
        return _StepShape.StepShape_EdgeLoop_EdgeListValue(self, *args)


    def NbEdgeList(self, *args):
        """
        NbEdgeList(StepShape_EdgeLoop self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.StepShape_EdgeLoop_NbEdgeList(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepShape.StepShape_EdgeLoop_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepShape.StepShape_EdgeLoop_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.StepShape_EdgeLoop_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepShape.delete_StepShape_EdgeLoop
StepShape_EdgeLoop_swigregister = _StepShape.StepShape_EdgeLoop_swigregister
StepShape_EdgeLoop_swigregister(StepShape_EdgeLoop)

def StepShape_EdgeLoop_get_type_name(*args):
    """
    StepShape_EdgeLoop_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepShape.StepShape_EdgeLoop_get_type_name(*args)

def StepShape_EdgeLoop_get_type_descriptor(*args):
    """
    StepShape_EdgeLoop_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepShape.StepShape_EdgeLoop_get_type_descriptor(*args)

class StepShape_CompoundShapeRepresentation(StepShape_ShapeRepresentation):
    """Representation of STEP entity CompoundShapeRepresentation"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepShape_CompoundShapeRepresentation
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepShape_CompoundShapeRepresentation(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepShape_CompoundShapeRepresentation self) -> StepShape_CompoundShapeRepresentation

        Empty constructor


        """
        this = _StepShape.new_StepShape_CompoundShapeRepresentation(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepShape.StepShape_CompoundShapeRepresentation_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepShape.StepShape_CompoundShapeRepresentation_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.StepShape_CompoundShapeRepresentation_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepShape.delete_StepShape_CompoundShapeRepresentation
StepShape_CompoundShapeRepresentation_swigregister = _StepShape.StepShape_CompoundShapeRepresentation_swigregister
StepShape_CompoundShapeRepresentation_swigregister(StepShape_CompoundShapeRepresentation)

def StepShape_CompoundShapeRepresentation_get_type_name(*args):
    """
    StepShape_CompoundShapeRepresentation_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepShape.StepShape_CompoundShapeRepresentation_get_type_name(*args)

def StepShape_CompoundShapeRepresentation_get_type_descriptor(*args):
    """
    StepShape_CompoundShapeRepresentation_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepShape.StepShape_CompoundShapeRepresentation_get_type_descriptor(*args)

class StepShape_AdvancedFace(StepShape_FaceSurface):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepShape_AdvancedFace
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepShape_AdvancedFace(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepShape_AdvancedFace self) -> StepShape_AdvancedFace

        Returns a AdvancedFace


        """
        this = _StepShape.new_StepShape_AdvancedFace(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepShape.StepShape_AdvancedFace_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepShape.StepShape_AdvancedFace_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.StepShape_AdvancedFace_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepShape.delete_StepShape_AdvancedFace
StepShape_AdvancedFace_swigregister = _StepShape.StepShape_AdvancedFace_swigregister
StepShape_AdvancedFace_swigregister(StepShape_AdvancedFace)

def StepShape_AdvancedFace_get_type_name(*args):
    """
    StepShape_AdvancedFace_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepShape.StepShape_AdvancedFace_get_type_name(*args)

def StepShape_AdvancedFace_get_type_descriptor(*args):
    """
    StepShape_AdvancedFace_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepShape.StepShape_AdvancedFace_get_type_descriptor(*args)

class StepShape_TransitionalShapeRepresentation(StepShape_ShapeRepresentation):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepShape_TransitionalShapeRepresentation
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepShape_TransitionalShapeRepresentation(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepShape_TransitionalShapeRepresentation self) -> StepShape_TransitionalShapeRepresentation

        Returns a TransitionalShapeRepresentation


        """
        this = _StepShape.new_StepShape_TransitionalShapeRepresentation(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepShape.StepShape_TransitionalShapeRepresentation_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepShape.StepShape_TransitionalShapeRepresentation_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.StepShape_TransitionalShapeRepresentation_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepShape.delete_StepShape_TransitionalShapeRepresentation
StepShape_TransitionalShapeRepresentation_swigregister = _StepShape.StepShape_TransitionalShapeRepresentation_swigregister
StepShape_TransitionalShapeRepresentation_swigregister(StepShape_TransitionalShapeRepresentation)

def StepShape_TransitionalShapeRepresentation_get_type_name(*args):
    """
    StepShape_TransitionalShapeRepresentation_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepShape.StepShape_TransitionalShapeRepresentation_get_type_name(*args)

def StepShape_TransitionalShapeRepresentation_get_type_descriptor(*args):
    """
    StepShape_TransitionalShapeRepresentation_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepShape.StepShape_TransitionalShapeRepresentation_get_type_descriptor(*args)

class StepShape_HArray1OfGeometricSetSelect(Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepShape_HArray1OfGeometricSetSelect
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepShape_HArray1OfGeometricSetSelect(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepShape_HArray1OfGeometricSetSelect self, Standard_Integer const theLower, Standard_Integer const theUpper) -> StepShape_HArray1OfGeometricSetSelect
        __init__(StepShape_HArray1OfGeometricSetSelect self, Standard_Integer const theLower, Standard_Integer const theUpper, StepShape_GeometricSetSelect theValue) -> StepShape_HArray1OfGeometricSetSelect
        __init__(StepShape_HArray1OfGeometricSetSelect self, NCollection_Array1_StepShape_GeometricSetSelect theOther) -> StepShape_HArray1OfGeometricSetSelect

        :type theOther: OCC.wrapper.StepShape.StepShape_Array1OfGeometricSetSelect

        """
        this = _StepShape.new_StepShape_HArray1OfGeometricSetSelect(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Array1(self, *args):
        """
        :rtype: OCC.wrapper.StepShape.StepShape_Array1OfGeometricSetSelect

        """
        res = _StepShape.StepShape_HArray1OfGeometricSetSelect_Array1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeArray1(self, *args):
        """
        ChangeArray1(StepShape_HArray1OfGeometricSetSelect self) -> NCollection_Array1_StepShape_GeometricSetSelect

        :rtype: OCC.wrapper.StepShape.StepShape_Array1OfGeometricSetSelect

        """
        return _StepShape.StepShape_HArray1OfGeometricSetSelect_ChangeArray1(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepShape.StepShape_HArray1OfGeometricSetSelect_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepShape.StepShape_HArray1OfGeometricSetSelect_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.StepShape_HArray1OfGeometricSetSelect_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepShape.delete_StepShape_HArray1OfGeometricSetSelect
StepShape_HArray1OfGeometricSetSelect_swigregister = _StepShape.StepShape_HArray1OfGeometricSetSelect_swigregister
StepShape_HArray1OfGeometricSetSelect_swigregister(StepShape_HArray1OfGeometricSetSelect)

def StepShape_HArray1OfGeometricSetSelect_get_type_name(*args):
    """
    StepShape_HArray1OfGeometricSetSelect_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepShape.StepShape_HArray1OfGeometricSetSelect_get_type_name(*args)

def StepShape_HArray1OfGeometricSetSelect_get_type_descriptor(*args):
    """
    StepShape_HArray1OfGeometricSetSelect_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepShape.StepShape_HArray1OfGeometricSetSelect_get_type_descriptor(*args)

class StepShape_Vertex(StepShape_TopologicalRepresentationItem):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepShape_Vertex
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepShape_Vertex(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepShape_Vertex self) -> StepShape_Vertex

        Returns a Vertex


        """
        this = _StepShape.new_StepShape_Vertex(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepShape.StepShape_Vertex_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepShape.StepShape_Vertex_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.StepShape_Vertex_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepShape.delete_StepShape_Vertex
StepShape_Vertex_swigregister = _StepShape.StepShape_Vertex_swigregister
StepShape_Vertex_swigregister(StepShape_Vertex)

def StepShape_Vertex_get_type_name(*args):
    """
    StepShape_Vertex_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepShape.StepShape_Vertex_get_type_name(*args)

def StepShape_Vertex_get_type_descriptor(*args):
    """
    StepShape_Vertex_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepShape.StepShape_Vertex_get_type_descriptor(*args)

class StepShape_OrientedPath(StepShape_Path):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepShape_OrientedPath
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepShape_OrientedPath(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepShape_OrientedPath self) -> StepShape_OrientedPath

        Returns a OrientedPath


        """
        this = _StepShape.new_StepShape_OrientedPath(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepShape_OrientedPath self, Handle_TCollection_HAsciiString aName, Handle_StepShape_EdgeLoop aPathElement, Standard_Boolean const aOrientation)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aPathElement: OCC.wrapper.StepShape.Handle_StepShape_EdgeLoop
        :type aOrientation: bool

        """
        return _StepShape.StepShape_OrientedPath_Init(self, *args)


    def SetPathElement(self, *args):
        """
        SetPathElement(StepShape_OrientedPath self, Handle_StepShape_EdgeLoop aPathElement)

        :type aPathElement: OCC.wrapper.StepShape.Handle_StepShape_EdgeLoop

        """
        return _StepShape.StepShape_OrientedPath_SetPathElement(self, *args)


    def PathElement(self, *args):
        """
        PathElement(StepShape_OrientedPath self) -> Handle_StepShape_EdgeLoop

        :rtype: OCC.wrapper.StepShape.Handle_StepShape_EdgeLoop

        """
        return _StepShape.StepShape_OrientedPath_PathElement(self, *args)


    def SetOrientation(self, *args):
        """
        SetOrientation(StepShape_OrientedPath self, Standard_Boolean const aOrientation)

        :type aOrientation: bool

        """
        return _StepShape.StepShape_OrientedPath_SetOrientation(self, *args)


    def Orientation(self, *args):
        """
        Orientation(StepShape_OrientedPath self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.StepShape_OrientedPath_Orientation(self, *args)


    def SetEdgeList(self, *args):
        """
        SetEdgeList(StepShape_OrientedPath self, Handle_StepShape_HArray1OfOrientedEdge aEdgeList)

        :type aEdgeList: OCC.wrapper.StepShape.Handle_StepShape_HArray1OfOrientedEdge

        """
        return _StepShape.StepShape_OrientedPath_SetEdgeList(self, *args)


    def EdgeList(self, *args):
        """
        EdgeList(StepShape_OrientedPath self) -> Handle_StepShape_HArray1OfOrientedEdge

        :rtype: OCC.wrapper.StepShape.Handle_StepShape_HArray1OfOrientedEdge

        """
        return _StepShape.StepShape_OrientedPath_EdgeList(self, *args)


    def EdgeListValue(self, *args):
        """
        EdgeListValue(StepShape_OrientedPath self, Standard_Integer const num) -> Handle_StepShape_OrientedEdge

        :type num: int
        :rtype: OCC.wrapper.StepShape.Handle_StepShape_OrientedEdge

        """
        return _StepShape.StepShape_OrientedPath_EdgeListValue(self, *args)


    def NbEdgeList(self, *args):
        """
        NbEdgeList(StepShape_OrientedPath self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.StepShape_OrientedPath_NbEdgeList(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepShape.StepShape_OrientedPath_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepShape.StepShape_OrientedPath_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.StepShape_OrientedPath_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepShape.delete_StepShape_OrientedPath
StepShape_OrientedPath_swigregister = _StepShape.StepShape_OrientedPath_swigregister
StepShape_OrientedPath_swigregister(StepShape_OrientedPath)

def StepShape_OrientedPath_get_type_name(*args):
    """
    StepShape_OrientedPath_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepShape.StepShape_OrientedPath_get_type_name(*args)

def StepShape_OrientedPath_get_type_descriptor(*args):
    """
    StepShape_OrientedPath_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepShape.StepShape_OrientedPath_get_type_descriptor(*args)

class StepShape_RightCircularCone(StepGeom.StepGeom_GeometricRepresentationItem):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepShape_RightCircularCone
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepShape_RightCircularCone(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepShape_RightCircularCone self) -> StepShape_RightCircularCone

        Returns a RightCircularCone


        """
        this = _StepShape.new_StepShape_RightCircularCone(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepShape_RightCircularCone self, Handle_TCollection_HAsciiString aName, Handle_StepGeom_Axis1Placement aPosition, Standard_Real const aHeight, Standard_Real const aRadius, Standard_Real const aSemiAngle)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aPosition: OCC.wrapper.StepShape.Handle_StepGeom_Axis1Placement
        :type aHeight: float
        :type aRadius: float
        :type aSemiAngle: float

        """
        return _StepShape.StepShape_RightCircularCone_Init(self, *args)


    def SetPosition(self, *args):
        """
        SetPosition(StepShape_RightCircularCone self, Handle_StepGeom_Axis1Placement aPosition)

        :type aPosition: OCC.wrapper.StepShape.Handle_StepGeom_Axis1Placement

        """
        return _StepShape.StepShape_RightCircularCone_SetPosition(self, *args)


    def Position(self, *args):
        """
        Position(StepShape_RightCircularCone self) -> Handle_StepGeom_Axis1Placement

        :rtype: OCC.wrapper.StepShape.Handle_StepGeom_Axis1Placement

        """
        return _StepShape.StepShape_RightCircularCone_Position(self, *args)


    def SetHeight(self, *args):
        """
        SetHeight(StepShape_RightCircularCone self, Standard_Real const aHeight)

        :type aHeight: float

        """
        return _StepShape.StepShape_RightCircularCone_SetHeight(self, *args)


    def Height(self, *args):
        """
        Height(StepShape_RightCircularCone self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _StepShape.StepShape_RightCircularCone_Height(self, *args)


    def SetRadius(self, *args):
        """
        SetRadius(StepShape_RightCircularCone self, Standard_Real const aRadius)

        :type aRadius: float

        """
        return _StepShape.StepShape_RightCircularCone_SetRadius(self, *args)


    def Radius(self, *args):
        """
        Radius(StepShape_RightCircularCone self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _StepShape.StepShape_RightCircularCone_Radius(self, *args)


    def SetSemiAngle(self, *args):
        """
        SetSemiAngle(StepShape_RightCircularCone self, Standard_Real const aSemiAngle)

        :type aSemiAngle: float

        """
        return _StepShape.StepShape_RightCircularCone_SetSemiAngle(self, *args)


    def SemiAngle(self, *args):
        """
        SemiAngle(StepShape_RightCircularCone self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _StepShape.StepShape_RightCircularCone_SemiAngle(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepShape.StepShape_RightCircularCone_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepShape.StepShape_RightCircularCone_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.StepShape_RightCircularCone_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepShape.delete_StepShape_RightCircularCone
StepShape_RightCircularCone_swigregister = _StepShape.StepShape_RightCircularCone_swigregister
StepShape_RightCircularCone_swigregister(StepShape_RightCircularCone)

def StepShape_RightCircularCone_get_type_name(*args):
    """
    StepShape_RightCircularCone_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepShape.StepShape_RightCircularCone_get_type_name(*args)

def StepShape_RightCircularCone_get_type_descriptor(*args):
    """
    StepShape_RightCircularCone_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepShape.StepShape_RightCircularCone_get_type_descriptor(*args)

class Handle_StepShape_Loop(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepShape_Loop self)

        Nullify the handle


        """
        return _StepShape.Handle_StepShape_Loop_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepShape_Loop self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepShape.Handle_StepShape_Loop_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepShape_Loop self, StepShape_Loop thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepShape.Handle_StepShape_Loop_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepShape_Loop self, Handle_StepShape_Loop theHandle) -> Handle_StepShape_Loop
        assign(Handle_StepShape_Loop self, StepShape_Loop thePtr) -> Handle_StepShape_Loop
        assign(Handle_StepShape_Loop self, Handle_StepShape_Loop theHandle) -> Handle_StepShape_Loop

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepShape.Handle_StepShape_Loop_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepShape_Loop self) -> StepShape_Loop

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepShape.Handle_StepShape_Loop_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepShape_Loop self) -> StepShape_Loop

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepShape.Handle_StepShape_Loop___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepShape_Loop self) -> StepShape_Loop

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepShape.Handle_StepShape_Loop___ref__(self, *args)


    def __hash__(self):
        return _StepShape.Handle_StepShape_Loop___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepShape.Handle_StepShape_Loop___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepShape.new_Handle_StepShape_Loop(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepShape.Handle_StepShape_Loop_DownCast)
    __swig_destroy__ = _StepShape.delete_Handle_StepShape_Loop

    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepShape_Loop self) -> char const *

        :rtype: const char *

        """
        return _StepShape.Handle_StepShape_Loop_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.Handle_StepShape_Loop_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.Handle_StepShape_Loop_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Init(self, *args):
        """
        Init(Handle_StepShape_Loop self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepShape.Handle_StepShape_Loop_Init(self, *args)


    def SetName(self, *args):
        """
        SetName(Handle_StepShape_Loop self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepShape.Handle_StepShape_Loop_SetName(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepShape_Loop self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepShape.Handle_StepShape_Loop_Name(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepShape_Loop self)

        Memory deallocator for transient classes


        """
        return _StepShape.Handle_StepShape_Loop_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepShape_Loop self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepShape_Loop self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.Handle_StepShape_Loop_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepShape_Loop self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepShape_Loop self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.Handle_StepShape_Loop_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepShape_Loop self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepShape.Handle_StepShape_Loop_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepShape_Loop self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_Loop_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepShape_Loop self)

        Increments the reference counter of this object


        """
        return _StepShape.Handle_StepShape_Loop_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepShape_Loop self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_Loop_DecrementRefCounter(self, *args)

Handle_StepShape_Loop_swigregister = _StepShape.Handle_StepShape_Loop_swigregister
Handle_StepShape_Loop_swigregister(Handle_StepShape_Loop)

def Handle_StepShape_Loop_DownCast(thing):
    return _StepShape.Handle_StepShape_Loop_DownCast(thing)
Handle_StepShape_Loop_DownCast = _StepShape.Handle_StepShape_Loop_DownCast

class Handle_StepShape_ExtrudedFaceSolid(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepShape_ExtrudedFaceSolid self)

        Nullify the handle


        """
        return _StepShape.Handle_StepShape_ExtrudedFaceSolid_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepShape_ExtrudedFaceSolid self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepShape.Handle_StepShape_ExtrudedFaceSolid_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepShape_ExtrudedFaceSolid self, StepShape_ExtrudedFaceSolid thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepShape.Handle_StepShape_ExtrudedFaceSolid_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepShape_ExtrudedFaceSolid self, Handle_StepShape_ExtrudedFaceSolid theHandle) -> Handle_StepShape_ExtrudedFaceSolid
        assign(Handle_StepShape_ExtrudedFaceSolid self, StepShape_ExtrudedFaceSolid thePtr) -> Handle_StepShape_ExtrudedFaceSolid
        assign(Handle_StepShape_ExtrudedFaceSolid self, Handle_StepShape_ExtrudedFaceSolid theHandle) -> Handle_StepShape_ExtrudedFaceSolid

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepShape.Handle_StepShape_ExtrudedFaceSolid_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepShape_ExtrudedFaceSolid self) -> StepShape_ExtrudedFaceSolid

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepShape.Handle_StepShape_ExtrudedFaceSolid_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepShape_ExtrudedFaceSolid self) -> StepShape_ExtrudedFaceSolid

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepShape.Handle_StepShape_ExtrudedFaceSolid___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepShape_ExtrudedFaceSolid self) -> StepShape_ExtrudedFaceSolid

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepShape.Handle_StepShape_ExtrudedFaceSolid___ref__(self, *args)


    def __hash__(self):
        return _StepShape.Handle_StepShape_ExtrudedFaceSolid___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepShape.Handle_StepShape_ExtrudedFaceSolid___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepShape.new_Handle_StepShape_ExtrudedFaceSolid(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepShape.Handle_StepShape_ExtrudedFaceSolid_DownCast)
    __swig_destroy__ = _StepShape.delete_Handle_StepShape_ExtrudedFaceSolid

    def Init(self, *args):
        """
        Init(Handle_StepShape_ExtrudedFaceSolid self, Handle_TCollection_HAsciiString aName, Handle_StepShape_FaceSurface aSweptArea, Handle_StepGeom_Direction aExtrudedDirection, Standard_Real const aDepth)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aSweptArea: OCC.wrapper.StepShape.Handle_StepShape_FaceSurface
        :type aExtrudedDirection: OCC.wrapper.StepShape.Handle_StepGeom_Direction
        :type aDepth: float

        """
        return _StepShape.Handle_StepShape_ExtrudedFaceSolid_Init(self, *args)


    def SetExtrudedDirection(self, *args):
        """
        SetExtrudedDirection(Handle_StepShape_ExtrudedFaceSolid self, Handle_StepGeom_Direction aExtrudedDirection)

        :type aExtrudedDirection: OCC.wrapper.StepShape.Handle_StepGeom_Direction

        """
        return _StepShape.Handle_StepShape_ExtrudedFaceSolid_SetExtrudedDirection(self, *args)


    def ExtrudedDirection(self, *args):
        """
        ExtrudedDirection(Handle_StepShape_ExtrudedFaceSolid self) -> Handle_StepGeom_Direction

        :rtype: OCC.wrapper.StepShape.Handle_StepGeom_Direction

        """
        return _StepShape.Handle_StepShape_ExtrudedFaceSolid_ExtrudedDirection(self, *args)


    def SetDepth(self, *args):
        """
        SetDepth(Handle_StepShape_ExtrudedFaceSolid self, Standard_Real const aDepth)

        :type aDepth: float

        """
        return _StepShape.Handle_StepShape_ExtrudedFaceSolid_SetDepth(self, *args)


    def Depth(self, *args):
        """
        Depth(Handle_StepShape_ExtrudedFaceSolid self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _StepShape.Handle_StepShape_ExtrudedFaceSolid_Depth(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepShape_ExtrudedFaceSolid self) -> char const *

        :rtype: const char *

        """
        return _StepShape.Handle_StepShape_ExtrudedFaceSolid_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.Handle_StepShape_ExtrudedFaceSolid_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.Handle_StepShape_ExtrudedFaceSolid_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetSweptFace(self, *args):
        """
        SetSweptFace(Handle_StepShape_ExtrudedFaceSolid self, Handle_StepShape_FaceSurface aSweptArea)

        :type aSweptArea: OCC.wrapper.StepShape.Handle_StepShape_FaceSurface

        """
        return _StepShape.Handle_StepShape_ExtrudedFaceSolid_SetSweptFace(self, *args)


    def SweptFace(self, *args):
        """
        SweptFace(Handle_StepShape_ExtrudedFaceSolid self) -> Handle_StepShape_FaceSurface

        :rtype: OCC.wrapper.StepShape.Handle_StepShape_FaceSurface

        """
        return _StepShape.Handle_StepShape_ExtrudedFaceSolid_SweptFace(self, *args)


    def SetName(self, *args):
        """
        SetName(Handle_StepShape_ExtrudedFaceSolid self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepShape.Handle_StepShape_ExtrudedFaceSolid_SetName(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepShape_ExtrudedFaceSolid self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepShape.Handle_StepShape_ExtrudedFaceSolid_Name(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepShape_ExtrudedFaceSolid self)

        Memory deallocator for transient classes


        """
        return _StepShape.Handle_StepShape_ExtrudedFaceSolid_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepShape_ExtrudedFaceSolid self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepShape_ExtrudedFaceSolid self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.Handle_StepShape_ExtrudedFaceSolid_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepShape_ExtrudedFaceSolid self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepShape_ExtrudedFaceSolid self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.Handle_StepShape_ExtrudedFaceSolid_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepShape_ExtrudedFaceSolid self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepShape.Handle_StepShape_ExtrudedFaceSolid_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepShape_ExtrudedFaceSolid self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_ExtrudedFaceSolid_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepShape_ExtrudedFaceSolid self)

        Increments the reference counter of this object


        """
        return _StepShape.Handle_StepShape_ExtrudedFaceSolid_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepShape_ExtrudedFaceSolid self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_ExtrudedFaceSolid_DecrementRefCounter(self, *args)

Handle_StepShape_ExtrudedFaceSolid_swigregister = _StepShape.Handle_StepShape_ExtrudedFaceSolid_swigregister
Handle_StepShape_ExtrudedFaceSolid_swigregister(Handle_StepShape_ExtrudedFaceSolid)

def Handle_StepShape_ExtrudedFaceSolid_DownCast(thing):
    return _StepShape.Handle_StepShape_ExtrudedFaceSolid_DownCast(thing)
Handle_StepShape_ExtrudedFaceSolid_DownCast = _StepShape.Handle_StepShape_ExtrudedFaceSolid_DownCast

class StepShape_ManifoldSurfaceShapeRepresentation(StepShape_ShapeRepresentation):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepShape_ManifoldSurfaceShapeRepresentation
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepShape_ManifoldSurfaceShapeRepresentation(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepShape_ManifoldSurfaceShapeRepresentation self) -> StepShape_ManifoldSurfaceShapeRepresentation

        Returns a ManifoldSurfaceShapeRepresentation


        """
        this = _StepShape.new_StepShape_ManifoldSurfaceShapeRepresentation(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepShape.StepShape_ManifoldSurfaceShapeRepresentation_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepShape.StepShape_ManifoldSurfaceShapeRepresentation_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.StepShape_ManifoldSurfaceShapeRepresentation_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepShape.delete_StepShape_ManifoldSurfaceShapeRepresentation
StepShape_ManifoldSurfaceShapeRepresentation_swigregister = _StepShape.StepShape_ManifoldSurfaceShapeRepresentation_swigregister
StepShape_ManifoldSurfaceShapeRepresentation_swigregister(StepShape_ManifoldSurfaceShapeRepresentation)

def StepShape_ManifoldSurfaceShapeRepresentation_get_type_name(*args):
    """
    StepShape_ManifoldSurfaceShapeRepresentation_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepShape.StepShape_ManifoldSurfaceShapeRepresentation_get_type_name(*args)

def StepShape_ManifoldSurfaceShapeRepresentation_get_type_descriptor(*args):
    """
    StepShape_ManifoldSurfaceShapeRepresentation_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepShape.StepShape_ManifoldSurfaceShapeRepresentation_get_type_descriptor(*args)

class StepShape_GeometricallyBoundedSurfaceShapeRepresentation(StepShape_ShapeRepresentation):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepShape_GeometricallyBoundedSurfaceShapeRepresentation
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepShape_GeometricallyBoundedSurfaceShapeRepresentation(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepShape_GeometricallyBoundedSurfaceShapeRepresentation self) -> StepShape_GeometricallyBoundedSurfaceShapeRepresentation

        Returns a GeometricallyBoundedSurfaceShapeRepresentation


        """
        this = _StepShape.new_StepShape_GeometricallyBoundedSurfaceShapeRepresentation(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepShape.StepShape_GeometricallyBoundedSurfaceShapeRepresentation_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepShape.StepShape_GeometricallyBoundedSurfaceShapeRepresentation_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.StepShape_GeometricallyBoundedSurfaceShapeRepresentation_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepShape.delete_StepShape_GeometricallyBoundedSurfaceShapeRepresentation
StepShape_GeometricallyBoundedSurfaceShapeRepresentation_swigregister = _StepShape.StepShape_GeometricallyBoundedSurfaceShapeRepresentation_swigregister
StepShape_GeometricallyBoundedSurfaceShapeRepresentation_swigregister(StepShape_GeometricallyBoundedSurfaceShapeRepresentation)

def StepShape_GeometricallyBoundedSurfaceShapeRepresentation_get_type_name(*args):
    """
    StepShape_GeometricallyBoundedSurfaceShapeRepresentation_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepShape.StepShape_GeometricallyBoundedSurfaceShapeRepresentation_get_type_name(*args)

def StepShape_GeometricallyBoundedSurfaceShapeRepresentation_get_type_descriptor(*args):
    """
    StepShape_GeometricallyBoundedSurfaceShapeRepresentation_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepShape.StepShape_GeometricallyBoundedSurfaceShapeRepresentation_get_type_descriptor(*args)

class Handle_StepShape_RightCircularCone(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepShape_RightCircularCone self)

        Nullify the handle


        """
        return _StepShape.Handle_StepShape_RightCircularCone_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepShape_RightCircularCone self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepShape.Handle_StepShape_RightCircularCone_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepShape_RightCircularCone self, StepShape_RightCircularCone thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepShape.Handle_StepShape_RightCircularCone_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepShape_RightCircularCone self, Handle_StepShape_RightCircularCone theHandle) -> Handle_StepShape_RightCircularCone
        assign(Handle_StepShape_RightCircularCone self, StepShape_RightCircularCone thePtr) -> Handle_StepShape_RightCircularCone
        assign(Handle_StepShape_RightCircularCone self, Handle_StepShape_RightCircularCone theHandle) -> Handle_StepShape_RightCircularCone

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepShape.Handle_StepShape_RightCircularCone_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepShape_RightCircularCone self) -> StepShape_RightCircularCone

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepShape.Handle_StepShape_RightCircularCone_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepShape_RightCircularCone self) -> StepShape_RightCircularCone

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepShape.Handle_StepShape_RightCircularCone___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepShape_RightCircularCone self) -> StepShape_RightCircularCone

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepShape.Handle_StepShape_RightCircularCone___ref__(self, *args)


    def __hash__(self):
        return _StepShape.Handle_StepShape_RightCircularCone___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepShape.Handle_StepShape_RightCircularCone___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepShape.new_Handle_StepShape_RightCircularCone(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepShape.Handle_StepShape_RightCircularCone_DownCast)
    __swig_destroy__ = _StepShape.delete_Handle_StepShape_RightCircularCone

    def Init(self, *args):
        """
        Init(Handle_StepShape_RightCircularCone self, Handle_TCollection_HAsciiString aName, Handle_StepGeom_Axis1Placement aPosition, Standard_Real const aHeight, Standard_Real const aRadius, Standard_Real const aSemiAngle)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aPosition: OCC.wrapper.StepShape.Handle_StepGeom_Axis1Placement
        :type aHeight: float
        :type aRadius: float
        :type aSemiAngle: float

        """
        return _StepShape.Handle_StepShape_RightCircularCone_Init(self, *args)


    def SetPosition(self, *args):
        """
        SetPosition(Handle_StepShape_RightCircularCone self, Handle_StepGeom_Axis1Placement aPosition)

        :type aPosition: OCC.wrapper.StepShape.Handle_StepGeom_Axis1Placement

        """
        return _StepShape.Handle_StepShape_RightCircularCone_SetPosition(self, *args)


    def Position(self, *args):
        """
        Position(Handle_StepShape_RightCircularCone self) -> Handle_StepGeom_Axis1Placement

        :rtype: OCC.wrapper.StepShape.Handle_StepGeom_Axis1Placement

        """
        return _StepShape.Handle_StepShape_RightCircularCone_Position(self, *args)


    def SetHeight(self, *args):
        """
        SetHeight(Handle_StepShape_RightCircularCone self, Standard_Real const aHeight)

        :type aHeight: float

        """
        return _StepShape.Handle_StepShape_RightCircularCone_SetHeight(self, *args)


    def Height(self, *args):
        """
        Height(Handle_StepShape_RightCircularCone self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _StepShape.Handle_StepShape_RightCircularCone_Height(self, *args)


    def SetRadius(self, *args):
        """
        SetRadius(Handle_StepShape_RightCircularCone self, Standard_Real const aRadius)

        :type aRadius: float

        """
        return _StepShape.Handle_StepShape_RightCircularCone_SetRadius(self, *args)


    def Radius(self, *args):
        """
        Radius(Handle_StepShape_RightCircularCone self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _StepShape.Handle_StepShape_RightCircularCone_Radius(self, *args)


    def SetSemiAngle(self, *args):
        """
        SetSemiAngle(Handle_StepShape_RightCircularCone self, Standard_Real const aSemiAngle)

        :type aSemiAngle: float

        """
        return _StepShape.Handle_StepShape_RightCircularCone_SetSemiAngle(self, *args)


    def SemiAngle(self, *args):
        """
        SemiAngle(Handle_StepShape_RightCircularCone self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _StepShape.Handle_StepShape_RightCircularCone_SemiAngle(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepShape_RightCircularCone self) -> char const *

        :rtype: const char *

        """
        return _StepShape.Handle_StepShape_RightCircularCone_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.Handle_StepShape_RightCircularCone_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.Handle_StepShape_RightCircularCone_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetName(self, *args):
        """
        SetName(Handle_StepShape_RightCircularCone self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepShape.Handle_StepShape_RightCircularCone_SetName(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepShape_RightCircularCone self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepShape.Handle_StepShape_RightCircularCone_Name(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepShape_RightCircularCone self)

        Memory deallocator for transient classes


        """
        return _StepShape.Handle_StepShape_RightCircularCone_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepShape_RightCircularCone self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepShape_RightCircularCone self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.Handle_StepShape_RightCircularCone_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepShape_RightCircularCone self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepShape_RightCircularCone self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.Handle_StepShape_RightCircularCone_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepShape_RightCircularCone self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepShape.Handle_StepShape_RightCircularCone_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepShape_RightCircularCone self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_RightCircularCone_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepShape_RightCircularCone self)

        Increments the reference counter of this object


        """
        return _StepShape.Handle_StepShape_RightCircularCone_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepShape_RightCircularCone self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_RightCircularCone_DecrementRefCounter(self, *args)

Handle_StepShape_RightCircularCone_swigregister = _StepShape.Handle_StepShape_RightCircularCone_swigregister
Handle_StepShape_RightCircularCone_swigregister(Handle_StepShape_RightCircularCone)

def Handle_StepShape_RightCircularCone_DownCast(thing):
    return _StepShape.Handle_StepShape_RightCircularCone_DownCast(thing)
Handle_StepShape_RightCircularCone_DownCast = _StepShape.Handle_StepShape_RightCircularCone_DownCast

class StepShape_Shell(StepData.StepData_SelectType):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(StepShape_Shell self) -> StepShape_Shell

        Returns a Shell SelectType


        """
        this = _StepShape.new_StepShape_Shell(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def CaseNum(self, *args):
        """
        CaseNum(StepShape_Shell self, Handle_Standard_Transient ent) -> Standard_Integer

        Recognizes a Shell Kind Entity that is :
        1 -> OpenShell
        2 -> ClosedShell
        0 else

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.StepShape_Shell_CaseNum(self, *args)


    def OpenShell(self, *args):
        """
        OpenShell(StepShape_Shell self) -> Handle_StepShape_OpenShell

        returns Value as a OpenShell (Null if another type)

        :rtype: OCC.wrapper.StepShape.Handle_StepShape_OpenShell

        """
        return _StepShape.StepShape_Shell_OpenShell(self, *args)


    def ClosedShell(self, *args):
        """
        ClosedShell(StepShape_Shell self) -> Handle_StepShape_ClosedShell

        returns Value as a ClosedShell (Null if another type)

        :rtype: OCC.wrapper.StepShape.Handle_StepShape_ClosedShell

        """
        return _StepShape.StepShape_Shell_ClosedShell(self, *args)

    __swig_destroy__ = _StepShape.delete_StepShape_Shell
StepShape_Shell_swigregister = _StepShape.StepShape_Shell_swigregister
StepShape_Shell_swigregister(StepShape_Shell)

class Handle_StepShape_BooleanResult(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepShape_BooleanResult self)

        Nullify the handle


        """
        return _StepShape.Handle_StepShape_BooleanResult_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepShape_BooleanResult self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepShape.Handle_StepShape_BooleanResult_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepShape_BooleanResult self, StepShape_BooleanResult thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepShape.Handle_StepShape_BooleanResult_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepShape_BooleanResult self, Handle_StepShape_BooleanResult theHandle) -> Handle_StepShape_BooleanResult
        assign(Handle_StepShape_BooleanResult self, StepShape_BooleanResult thePtr) -> Handle_StepShape_BooleanResult
        assign(Handle_StepShape_BooleanResult self, Handle_StepShape_BooleanResult theHandle) -> Handle_StepShape_BooleanResult

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepShape.Handle_StepShape_BooleanResult_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepShape_BooleanResult self) -> StepShape_BooleanResult

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepShape.Handle_StepShape_BooleanResult_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepShape_BooleanResult self) -> StepShape_BooleanResult

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepShape.Handle_StepShape_BooleanResult___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepShape_BooleanResult self) -> StepShape_BooleanResult

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepShape.Handle_StepShape_BooleanResult___ref__(self, *args)


    def __hash__(self):
        return _StepShape.Handle_StepShape_BooleanResult___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepShape.Handle_StepShape_BooleanResult___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepShape.new_Handle_StepShape_BooleanResult(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepShape.Handle_StepShape_BooleanResult_DownCast)
    __swig_destroy__ = _StepShape.delete_Handle_StepShape_BooleanResult

    def Init(self, *args):
        """
        Init(Handle_StepShape_BooleanResult self, Handle_TCollection_HAsciiString aName, StepShape_BooleanOperator const aOperator, StepShape_BooleanOperand aFirstOperand, StepShape_BooleanOperand aSecondOperand)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aOperator: OCC.wrapper.StepShape.StepShape_BooleanOperator
        :type aFirstOperand: OCC.wrapper.StepShape.StepShape_BooleanOperand
        :type aSecondOperand: OCC.wrapper.StepShape.StepShape_BooleanOperand

        """
        return _StepShape.Handle_StepShape_BooleanResult_Init(self, *args)


    def SetOperator(self, *args):
        """
        SetOperator(Handle_StepShape_BooleanResult self, StepShape_BooleanOperator const aOperator)

        :type aOperator: OCC.wrapper.StepShape.StepShape_BooleanOperator

        """
        return _StepShape.Handle_StepShape_BooleanResult_SetOperator(self, *args)


    def Operator(self, *args):
        """
        Operator(Handle_StepShape_BooleanResult self) -> StepShape_BooleanOperator

        :rtype: OCC.wrapper.StepShape.StepShape_BooleanOperator

        """
        return _StepShape.Handle_StepShape_BooleanResult_Operator(self, *args)


    def SetFirstOperand(self, *args):
        """
        SetFirstOperand(Handle_StepShape_BooleanResult self, StepShape_BooleanOperand aFirstOperand)

        :type aFirstOperand: OCC.wrapper.StepShape.StepShape_BooleanOperand

        """
        return _StepShape.Handle_StepShape_BooleanResult_SetFirstOperand(self, *args)


    def FirstOperand(self, *args):
        """
        FirstOperand(Handle_StepShape_BooleanResult self) -> StepShape_BooleanOperand

        :rtype: OCC.wrapper.StepShape.StepShape_BooleanOperand

        """
        return _StepShape.Handle_StepShape_BooleanResult_FirstOperand(self, *args)


    def SetSecondOperand(self, *args):
        """
        SetSecondOperand(Handle_StepShape_BooleanResult self, StepShape_BooleanOperand aSecondOperand)

        :type aSecondOperand: OCC.wrapper.StepShape.StepShape_BooleanOperand

        """
        return _StepShape.Handle_StepShape_BooleanResult_SetSecondOperand(self, *args)


    def SecondOperand(self, *args):
        """
        SecondOperand(Handle_StepShape_BooleanResult self) -> StepShape_BooleanOperand

        :rtype: OCC.wrapper.StepShape.StepShape_BooleanOperand

        """
        return _StepShape.Handle_StepShape_BooleanResult_SecondOperand(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepShape_BooleanResult self) -> char const *

        :rtype: const char *

        """
        return _StepShape.Handle_StepShape_BooleanResult_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.Handle_StepShape_BooleanResult_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.Handle_StepShape_BooleanResult_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetName(self, *args):
        """
        SetName(Handle_StepShape_BooleanResult self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepShape.Handle_StepShape_BooleanResult_SetName(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepShape_BooleanResult self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepShape.Handle_StepShape_BooleanResult_Name(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepShape_BooleanResult self)

        Memory deallocator for transient classes


        """
        return _StepShape.Handle_StepShape_BooleanResult_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepShape_BooleanResult self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepShape_BooleanResult self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.Handle_StepShape_BooleanResult_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepShape_BooleanResult self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepShape_BooleanResult self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.Handle_StepShape_BooleanResult_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepShape_BooleanResult self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepShape.Handle_StepShape_BooleanResult_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepShape_BooleanResult self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_BooleanResult_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepShape_BooleanResult self)

        Increments the reference counter of this object


        """
        return _StepShape.Handle_StepShape_BooleanResult_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepShape_BooleanResult self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_BooleanResult_DecrementRefCounter(self, *args)

Handle_StepShape_BooleanResult_swigregister = _StepShape.Handle_StepShape_BooleanResult_swigregister
Handle_StepShape_BooleanResult_swigregister(Handle_StepShape_BooleanResult)

def Handle_StepShape_BooleanResult_DownCast(thing):
    return _StepShape.Handle_StepShape_BooleanResult_DownCast(thing)
Handle_StepShape_BooleanResult_DownCast = _StepShape.Handle_StepShape_BooleanResult_DownCast

class Handle_StepShape_Subedge(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepShape_Subedge self)

        Nullify the handle


        """
        return _StepShape.Handle_StepShape_Subedge_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepShape_Subedge self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepShape.Handle_StepShape_Subedge_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepShape_Subedge self, StepShape_Subedge thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepShape.Handle_StepShape_Subedge_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepShape_Subedge self, Handle_StepShape_Subedge theHandle) -> Handle_StepShape_Subedge
        assign(Handle_StepShape_Subedge self, StepShape_Subedge thePtr) -> Handle_StepShape_Subedge
        assign(Handle_StepShape_Subedge self, Handle_StepShape_Subedge theHandle) -> Handle_StepShape_Subedge

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepShape.Handle_StepShape_Subedge_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepShape_Subedge self) -> StepShape_Subedge

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepShape.Handle_StepShape_Subedge_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepShape_Subedge self) -> StepShape_Subedge

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepShape.Handle_StepShape_Subedge___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepShape_Subedge self) -> StepShape_Subedge

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepShape.Handle_StepShape_Subedge___ref__(self, *args)


    def __hash__(self):
        return _StepShape.Handle_StepShape_Subedge___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepShape.Handle_StepShape_Subedge___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepShape.new_Handle_StepShape_Subedge(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepShape.Handle_StepShape_Subedge_DownCast)
    __swig_destroy__ = _StepShape.delete_Handle_StepShape_Subedge

    def Init(self, *args):
        """
        Init(Handle_StepShape_Subedge self, Handle_TCollection_HAsciiString aRepresentationItem_Name, Handle_StepShape_Vertex aEdge_EdgeStart, Handle_StepShape_Vertex aEdge_EdgeEnd, Handle_StepShape_Edge aParentEdge)

        Initialize all fields (own and inherited)

        :type aRepresentationItem_Name: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aEdge_EdgeStart: OCC.wrapper.StepShape.Handle_StepShape_Vertex
        :type aEdge_EdgeEnd: OCC.wrapper.StepShape.Handle_StepShape_Vertex
        :type aParentEdge: OCC.wrapper.StepShape.Handle_StepShape_Edge

        """
        return _StepShape.Handle_StepShape_Subedge_Init(self, *args)


    def ParentEdge(self, *args):
        """
        ParentEdge(Handle_StepShape_Subedge self) -> Handle_StepShape_Edge

        Returns field ParentEdge

        :rtype: OCC.wrapper.StepShape.Handle_StepShape_Edge

        """
        return _StepShape.Handle_StepShape_Subedge_ParentEdge(self, *args)


    def SetParentEdge(self, *args):
        """
        SetParentEdge(Handle_StepShape_Subedge self, Handle_StepShape_Edge ParentEdge)

        Set field ParentEdge

        :type ParentEdge: OCC.wrapper.StepShape.Handle_StepShape_Edge

        """
        return _StepShape.Handle_StepShape_Subedge_SetParentEdge(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepShape_Subedge self) -> char const *

        :rtype: const char *

        """
        return _StepShape.Handle_StepShape_Subedge_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.Handle_StepShape_Subedge_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.Handle_StepShape_Subedge_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetEdgeStart(self, *args):
        """
        SetEdgeStart(Handle_StepShape_Subedge self, Handle_StepShape_Vertex aEdgeStart)

        :type aEdgeStart: OCC.wrapper.StepShape.Handle_StepShape_Vertex

        """
        return _StepShape.Handle_StepShape_Subedge_SetEdgeStart(self, *args)


    def EdgeStart(self, *args):
        """
        EdgeStart(Handle_StepShape_Subedge self) -> Handle_StepShape_Vertex

        :rtype: OCC.wrapper.StepShape.Handle_StepShape_Vertex

        """
        return _StepShape.Handle_StepShape_Subedge_EdgeStart(self, *args)


    def SetEdgeEnd(self, *args):
        """
        SetEdgeEnd(Handle_StepShape_Subedge self, Handle_StepShape_Vertex aEdgeEnd)

        :type aEdgeEnd: OCC.wrapper.StepShape.Handle_StepShape_Vertex

        """
        return _StepShape.Handle_StepShape_Subedge_SetEdgeEnd(self, *args)


    def EdgeEnd(self, *args):
        """
        EdgeEnd(Handle_StepShape_Subedge self) -> Handle_StepShape_Vertex

        :rtype: OCC.wrapper.StepShape.Handle_StepShape_Vertex

        """
        return _StepShape.Handle_StepShape_Subedge_EdgeEnd(self, *args)


    def SetName(self, *args):
        """
        SetName(Handle_StepShape_Subedge self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepShape.Handle_StepShape_Subedge_SetName(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepShape_Subedge self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepShape.Handle_StepShape_Subedge_Name(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepShape_Subedge self)

        Memory deallocator for transient classes


        """
        return _StepShape.Handle_StepShape_Subedge_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepShape_Subedge self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepShape_Subedge self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.Handle_StepShape_Subedge_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepShape_Subedge self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepShape_Subedge self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.Handle_StepShape_Subedge_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepShape_Subedge self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepShape.Handle_StepShape_Subedge_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepShape_Subedge self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_Subedge_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepShape_Subedge self)

        Increments the reference counter of this object


        """
        return _StepShape.Handle_StepShape_Subedge_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepShape_Subedge self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_Subedge_DecrementRefCounter(self, *args)

Handle_StepShape_Subedge_swigregister = _StepShape.Handle_StepShape_Subedge_swigregister
Handle_StepShape_Subedge_swigregister(Handle_StepShape_Subedge)

def Handle_StepShape_Subedge_DownCast(thing):
    return _StepShape.Handle_StepShape_Subedge_DownCast(thing)
Handle_StepShape_Subedge_DownCast = _StepShape.Handle_StepShape_Subedge_DownCast

class Handle_StepShape_AngularSize(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepShape_AngularSize self)

        Nullify the handle


        """
        return _StepShape.Handle_StepShape_AngularSize_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepShape_AngularSize self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepShape.Handle_StepShape_AngularSize_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepShape_AngularSize self, StepShape_AngularSize thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepShape.Handle_StepShape_AngularSize_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepShape_AngularSize self, Handle_StepShape_AngularSize theHandle) -> Handle_StepShape_AngularSize
        assign(Handle_StepShape_AngularSize self, StepShape_AngularSize thePtr) -> Handle_StepShape_AngularSize
        assign(Handle_StepShape_AngularSize self, Handle_StepShape_AngularSize theHandle) -> Handle_StepShape_AngularSize

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepShape.Handle_StepShape_AngularSize_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepShape_AngularSize self) -> StepShape_AngularSize

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepShape.Handle_StepShape_AngularSize_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepShape_AngularSize self) -> StepShape_AngularSize

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepShape.Handle_StepShape_AngularSize___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepShape_AngularSize self) -> StepShape_AngularSize

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepShape.Handle_StepShape_AngularSize___ref__(self, *args)


    def __hash__(self):
        return _StepShape.Handle_StepShape_AngularSize___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepShape.Handle_StepShape_AngularSize___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepShape.new_Handle_StepShape_AngularSize(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepShape.Handle_StepShape_AngularSize_DownCast)
    __swig_destroy__ = _StepShape.delete_Handle_StepShape_AngularSize

    def Init(self, *args):
        """
        Init(Handle_StepShape_AngularSize self, Handle_StepRepr_ShapeAspect aDimensionalSize_AppliesTo, Handle_TCollection_HAsciiString aDimensionalSize_Name, StepShape_AngleRelator const aAngleSelection)

        Initialize all fields (own and inherited)

        :type aDimensionalSize_AppliesTo: OCC.wrapper.StepShape.Handle_StepRepr_ShapeAspect
        :type aDimensionalSize_Name: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aAngleSelection: OCC.wrapper.StepShape.StepShape_AngleRelator

        """
        return _StepShape.Handle_StepShape_AngularSize_Init(self, *args)


    def AngleSelection(self, *args):
        """
        AngleSelection(Handle_StepShape_AngularSize self) -> StepShape_AngleRelator

        Returns field AngleSelection

        :rtype: OCC.wrapper.StepShape.StepShape_AngleRelator

        """
        return _StepShape.Handle_StepShape_AngularSize_AngleSelection(self, *args)


    def SetAngleSelection(self, *args):
        """
        SetAngleSelection(Handle_StepShape_AngularSize self, StepShape_AngleRelator const AngleSelection)

        Set field AngleSelection

        :type AngleSelection: OCC.wrapper.StepShape.StepShape_AngleRelator

        """
        return _StepShape.Handle_StepShape_AngularSize_SetAngleSelection(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepShape_AngularSize self) -> char const *

        :rtype: const char *

        """
        return _StepShape.Handle_StepShape_AngularSize_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.Handle_StepShape_AngularSize_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.Handle_StepShape_AngularSize_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def AppliesTo(self, *args):
        """
        AppliesTo(Handle_StepShape_AngularSize self) -> Handle_StepRepr_ShapeAspect

        Returns field AppliesTo

        :rtype: OCC.wrapper.StepShape.Handle_StepRepr_ShapeAspect

        """
        return _StepShape.Handle_StepShape_AngularSize_AppliesTo(self, *args)


    def SetAppliesTo(self, *args):
        """
        SetAppliesTo(Handle_StepShape_AngularSize self, Handle_StepRepr_ShapeAspect AppliesTo)

        Set field AppliesTo

        :type AppliesTo: OCC.wrapper.StepShape.Handle_StepRepr_ShapeAspect

        """
        return _StepShape.Handle_StepShape_AngularSize_SetAppliesTo(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepShape_AngularSize self) -> Handle_TCollection_HAsciiString

        Returns field Name

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepShape.Handle_StepShape_AngularSize_Name(self, *args)


    def SetName(self, *args):
        """
        SetName(Handle_StepShape_AngularSize self, Handle_TCollection_HAsciiString Name)

        Set field Name

        :type Name: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepShape.Handle_StepShape_AngularSize_SetName(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepShape_AngularSize self)

        Memory deallocator for transient classes


        """
        return _StepShape.Handle_StepShape_AngularSize_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepShape_AngularSize self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepShape_AngularSize self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.Handle_StepShape_AngularSize_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepShape_AngularSize self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepShape_AngularSize self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.Handle_StepShape_AngularSize_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepShape_AngularSize self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepShape.Handle_StepShape_AngularSize_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepShape_AngularSize self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_AngularSize_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepShape_AngularSize self)

        Increments the reference counter of this object


        """
        return _StepShape.Handle_StepShape_AngularSize_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepShape_AngularSize self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_AngularSize_DecrementRefCounter(self, *args)

Handle_StepShape_AngularSize_swigregister = _StepShape.Handle_StepShape_AngularSize_swigregister
Handle_StepShape_AngularSize_swigregister(Handle_StepShape_AngularSize)

def Handle_StepShape_AngularSize_DownCast(thing):
    return _StepShape.Handle_StepShape_AngularSize_DownCast(thing)
Handle_StepShape_AngularSize_DownCast = _StepShape.Handle_StepShape_AngularSize_DownCast

class StepShape_HArray1OfFace(Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepShape_HArray1OfFace
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepShape_HArray1OfFace(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepShape_HArray1OfFace self, Standard_Integer const theLower, Standard_Integer const theUpper) -> StepShape_HArray1OfFace
        __init__(StepShape_HArray1OfFace self, Standard_Integer const theLower, Standard_Integer const theUpper, Handle_StepShape_Face theValue) -> StepShape_HArray1OfFace
        __init__(StepShape_HArray1OfFace self, NCollection_Array1_Handle_StepShape_Face theOther) -> StepShape_HArray1OfFace

        :type theOther: OCC.wrapper.StepShape.StepShape_Array1OfFace

        """
        this = _StepShape.new_StepShape_HArray1OfFace(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Array1(self, *args):
        """
        :rtype: OCC.wrapper.StepShape.StepShape_Array1OfFace

        """
        res = _StepShape.StepShape_HArray1OfFace_Array1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeArray1(self, *args):
        """
        ChangeArray1(StepShape_HArray1OfFace self) -> NCollection_Array1_Handle_StepShape_Face

        :rtype: OCC.wrapper.StepShape.StepShape_Array1OfFace

        """
        return _StepShape.StepShape_HArray1OfFace_ChangeArray1(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepShape.StepShape_HArray1OfFace_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepShape.StepShape_HArray1OfFace_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.StepShape_HArray1OfFace_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepShape.delete_StepShape_HArray1OfFace
StepShape_HArray1OfFace_swigregister = _StepShape.StepShape_HArray1OfFace_swigregister
StepShape_HArray1OfFace_swigregister(StepShape_HArray1OfFace)

def StepShape_HArray1OfFace_get_type_name(*args):
    """
    StepShape_HArray1OfFace_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepShape.StepShape_HArray1OfFace_get_type_name(*args)

def StepShape_HArray1OfFace_get_type_descriptor(*args):
    """
    StepShape_HArray1OfFace_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepShape.StepShape_HArray1OfFace_get_type_descriptor(*args)

class StepShape_Block(StepGeom.StepGeom_GeometricRepresentationItem):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepShape_Block
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepShape_Block(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepShape_Block self) -> StepShape_Block

        Returns a Block


        """
        this = _StepShape.new_StepShape_Block(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepShape_Block self, Handle_TCollection_HAsciiString aName, Handle_StepGeom_Axis2Placement3d aPosition, Standard_Real const aX, Standard_Real const aY, Standard_Real const aZ)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aPosition: OCC.wrapper.StepShape.Handle_StepGeom_Axis2Placement3d
        :type aX: float
        :type aY: float
        :type aZ: float

        """
        return _StepShape.StepShape_Block_Init(self, *args)


    def SetPosition(self, *args):
        """
        SetPosition(StepShape_Block self, Handle_StepGeom_Axis2Placement3d aPosition)

        :type aPosition: OCC.wrapper.StepShape.Handle_StepGeom_Axis2Placement3d

        """
        return _StepShape.StepShape_Block_SetPosition(self, *args)


    def Position(self, *args):
        """
        Position(StepShape_Block self) -> Handle_StepGeom_Axis2Placement3d

        :rtype: OCC.wrapper.StepShape.Handle_StepGeom_Axis2Placement3d

        """
        return _StepShape.StepShape_Block_Position(self, *args)


    def SetX(self, *args):
        """
        SetX(StepShape_Block self, Standard_Real const aX)

        :type aX: float

        """
        return _StepShape.StepShape_Block_SetX(self, *args)


    def X(self, *args):
        """
        X(StepShape_Block self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _StepShape.StepShape_Block_X(self, *args)


    def SetY(self, *args):
        """
        SetY(StepShape_Block self, Standard_Real const aY)

        :type aY: float

        """
        return _StepShape.StepShape_Block_SetY(self, *args)


    def Y(self, *args):
        """
        Y(StepShape_Block self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _StepShape.StepShape_Block_Y(self, *args)


    def SetZ(self, *args):
        """
        SetZ(StepShape_Block self, Standard_Real const aZ)

        :type aZ: float

        """
        return _StepShape.StepShape_Block_SetZ(self, *args)


    def Z(self, *args):
        """
        Z(StepShape_Block self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _StepShape.StepShape_Block_Z(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepShape.StepShape_Block_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepShape.StepShape_Block_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.StepShape_Block_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepShape.delete_StepShape_Block
StepShape_Block_swigregister = _StepShape.StepShape_Block_swigregister
StepShape_Block_swigregister(StepShape_Block)

def StepShape_Block_get_type_name(*args):
    """
    StepShape_Block_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepShape.StepShape_Block_get_type_name(*args)

def StepShape_Block_get_type_descriptor(*args):
    """
    StepShape_Block_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepShape.StepShape_Block_get_type_descriptor(*args)

class Handle_StepShape_Sphere(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepShape_Sphere self)

        Nullify the handle


        """
        return _StepShape.Handle_StepShape_Sphere_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepShape_Sphere self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepShape.Handle_StepShape_Sphere_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepShape_Sphere self, StepShape_Sphere thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepShape.Handle_StepShape_Sphere_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepShape_Sphere self, Handle_StepShape_Sphere theHandle) -> Handle_StepShape_Sphere
        assign(Handle_StepShape_Sphere self, StepShape_Sphere thePtr) -> Handle_StepShape_Sphere
        assign(Handle_StepShape_Sphere self, Handle_StepShape_Sphere theHandle) -> Handle_StepShape_Sphere

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepShape.Handle_StepShape_Sphere_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepShape_Sphere self) -> StepShape_Sphere

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepShape.Handle_StepShape_Sphere_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepShape_Sphere self) -> StepShape_Sphere

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepShape.Handle_StepShape_Sphere___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepShape_Sphere self) -> StepShape_Sphere

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepShape.Handle_StepShape_Sphere___ref__(self, *args)


    def __hash__(self):
        return _StepShape.Handle_StepShape_Sphere___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepShape.Handle_StepShape_Sphere___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepShape.new_Handle_StepShape_Sphere(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepShape.Handle_StepShape_Sphere_DownCast)
    __swig_destroy__ = _StepShape.delete_Handle_StepShape_Sphere

    def Init(self, *args):
        """
        Init(Handle_StepShape_Sphere self, Handle_TCollection_HAsciiString aName, Standard_Real const aRadius, Handle_StepGeom_Point aCentre)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aRadius: float
        :type aCentre: OCC.wrapper.StepShape.Handle_StepGeom_Point

        """
        return _StepShape.Handle_StepShape_Sphere_Init(self, *args)


    def SetRadius(self, *args):
        """
        SetRadius(Handle_StepShape_Sphere self, Standard_Real const aRadius)

        :type aRadius: float

        """
        return _StepShape.Handle_StepShape_Sphere_SetRadius(self, *args)


    def Radius(self, *args):
        """
        Radius(Handle_StepShape_Sphere self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _StepShape.Handle_StepShape_Sphere_Radius(self, *args)


    def SetCentre(self, *args):
        """
        SetCentre(Handle_StepShape_Sphere self, Handle_StepGeom_Point aCentre)

        :type aCentre: OCC.wrapper.StepShape.Handle_StepGeom_Point

        """
        return _StepShape.Handle_StepShape_Sphere_SetCentre(self, *args)


    def Centre(self, *args):
        """
        Centre(Handle_StepShape_Sphere self) -> Handle_StepGeom_Point

        :rtype: OCC.wrapper.StepShape.Handle_StepGeom_Point

        """
        return _StepShape.Handle_StepShape_Sphere_Centre(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepShape_Sphere self) -> char const *

        :rtype: const char *

        """
        return _StepShape.Handle_StepShape_Sphere_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.Handle_StepShape_Sphere_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.Handle_StepShape_Sphere_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetName(self, *args):
        """
        SetName(Handle_StepShape_Sphere self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepShape.Handle_StepShape_Sphere_SetName(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepShape_Sphere self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepShape.Handle_StepShape_Sphere_Name(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepShape_Sphere self)

        Memory deallocator for transient classes


        """
        return _StepShape.Handle_StepShape_Sphere_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepShape_Sphere self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepShape_Sphere self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.Handle_StepShape_Sphere_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepShape_Sphere self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepShape_Sphere self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.Handle_StepShape_Sphere_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepShape_Sphere self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepShape.Handle_StepShape_Sphere_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepShape_Sphere self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_Sphere_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepShape_Sphere self)

        Increments the reference counter of this object


        """
        return _StepShape.Handle_StepShape_Sphere_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepShape_Sphere self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_Sphere_DecrementRefCounter(self, *args)

Handle_StepShape_Sphere_swigregister = _StepShape.Handle_StepShape_Sphere_swigregister
Handle_StepShape_Sphere_swigregister(Handle_StepShape_Sphere)

def Handle_StepShape_Sphere_DownCast(thing):
    return _StepShape.Handle_StepShape_Sphere_DownCast(thing)
Handle_StepShape_Sphere_DownCast = _StepShape.Handle_StepShape_Sphere_DownCast

class Handle_StepShape_DimensionalSizeWithPath(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepShape_DimensionalSizeWithPath self)

        Nullify the handle


        """
        return _StepShape.Handle_StepShape_DimensionalSizeWithPath_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepShape_DimensionalSizeWithPath self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepShape.Handle_StepShape_DimensionalSizeWithPath_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepShape_DimensionalSizeWithPath self, StepShape_DimensionalSizeWithPath thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepShape.Handle_StepShape_DimensionalSizeWithPath_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepShape_DimensionalSizeWithPath self, Handle_StepShape_DimensionalSizeWithPath theHandle) -> Handle_StepShape_DimensionalSizeWithPath
        assign(Handle_StepShape_DimensionalSizeWithPath self, StepShape_DimensionalSizeWithPath thePtr) -> Handle_StepShape_DimensionalSizeWithPath
        assign(Handle_StepShape_DimensionalSizeWithPath self, Handle_StepShape_DimensionalSizeWithPath theHandle) -> Handle_StepShape_DimensionalSizeWithPath

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepShape.Handle_StepShape_DimensionalSizeWithPath_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepShape_DimensionalSizeWithPath self) -> StepShape_DimensionalSizeWithPath

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepShape.Handle_StepShape_DimensionalSizeWithPath_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepShape_DimensionalSizeWithPath self) -> StepShape_DimensionalSizeWithPath

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepShape.Handle_StepShape_DimensionalSizeWithPath___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepShape_DimensionalSizeWithPath self) -> StepShape_DimensionalSizeWithPath

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepShape.Handle_StepShape_DimensionalSizeWithPath___ref__(self, *args)


    def __hash__(self):
        return _StepShape.Handle_StepShape_DimensionalSizeWithPath___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepShape.Handle_StepShape_DimensionalSizeWithPath___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepShape.new_Handle_StepShape_DimensionalSizeWithPath(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepShape.Handle_StepShape_DimensionalSizeWithPath_DownCast)
    __swig_destroy__ = _StepShape.delete_Handle_StepShape_DimensionalSizeWithPath

    def Init(self, *args):
        """
        Init(Handle_StepShape_DimensionalSizeWithPath self, Handle_StepRepr_ShapeAspect aDimensionalSize_AppliesTo, Handle_TCollection_HAsciiString aDimensionalSize_Name, Handle_StepRepr_ShapeAspect aPath)

        Initialize all fields (own and inherited)

        :type aDimensionalSize_AppliesTo: OCC.wrapper.StepShape.Handle_StepRepr_ShapeAspect
        :type aDimensionalSize_Name: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aPath: OCC.wrapper.StepShape.Handle_StepRepr_ShapeAspect

        """
        return _StepShape.Handle_StepShape_DimensionalSizeWithPath_Init(self, *args)


    def Path(self, *args):
        """
        Path(Handle_StepShape_DimensionalSizeWithPath self) -> Handle_StepRepr_ShapeAspect

        Returns field Path

        :rtype: OCC.wrapper.StepShape.Handle_StepRepr_ShapeAspect

        """
        return _StepShape.Handle_StepShape_DimensionalSizeWithPath_Path(self, *args)


    def SetPath(self, *args):
        """
        SetPath(Handle_StepShape_DimensionalSizeWithPath self, Handle_StepRepr_ShapeAspect Path)

        Set field Path

        :type Path: OCC.wrapper.StepShape.Handle_StepRepr_ShapeAspect

        """
        return _StepShape.Handle_StepShape_DimensionalSizeWithPath_SetPath(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepShape_DimensionalSizeWithPath self) -> char const *

        :rtype: const char *

        """
        return _StepShape.Handle_StepShape_DimensionalSizeWithPath_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.Handle_StepShape_DimensionalSizeWithPath_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.Handle_StepShape_DimensionalSizeWithPath_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def AppliesTo(self, *args):
        """
        AppliesTo(Handle_StepShape_DimensionalSizeWithPath self) -> Handle_StepRepr_ShapeAspect

        Returns field AppliesTo

        :rtype: OCC.wrapper.StepShape.Handle_StepRepr_ShapeAspect

        """
        return _StepShape.Handle_StepShape_DimensionalSizeWithPath_AppliesTo(self, *args)


    def SetAppliesTo(self, *args):
        """
        SetAppliesTo(Handle_StepShape_DimensionalSizeWithPath self, Handle_StepRepr_ShapeAspect AppliesTo)

        Set field AppliesTo

        :type AppliesTo: OCC.wrapper.StepShape.Handle_StepRepr_ShapeAspect

        """
        return _StepShape.Handle_StepShape_DimensionalSizeWithPath_SetAppliesTo(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepShape_DimensionalSizeWithPath self) -> Handle_TCollection_HAsciiString

        Returns field Name

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepShape.Handle_StepShape_DimensionalSizeWithPath_Name(self, *args)


    def SetName(self, *args):
        """
        SetName(Handle_StepShape_DimensionalSizeWithPath self, Handle_TCollection_HAsciiString Name)

        Set field Name

        :type Name: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepShape.Handle_StepShape_DimensionalSizeWithPath_SetName(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepShape_DimensionalSizeWithPath self)

        Memory deallocator for transient classes


        """
        return _StepShape.Handle_StepShape_DimensionalSizeWithPath_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepShape_DimensionalSizeWithPath self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepShape_DimensionalSizeWithPath self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.Handle_StepShape_DimensionalSizeWithPath_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepShape_DimensionalSizeWithPath self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepShape_DimensionalSizeWithPath self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.Handle_StepShape_DimensionalSizeWithPath_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepShape_DimensionalSizeWithPath self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepShape.Handle_StepShape_DimensionalSizeWithPath_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepShape_DimensionalSizeWithPath self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_DimensionalSizeWithPath_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepShape_DimensionalSizeWithPath self)

        Increments the reference counter of this object


        """
        return _StepShape.Handle_StepShape_DimensionalSizeWithPath_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepShape_DimensionalSizeWithPath self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_DimensionalSizeWithPath_DecrementRefCounter(self, *args)

Handle_StepShape_DimensionalSizeWithPath_swigregister = _StepShape.Handle_StepShape_DimensionalSizeWithPath_swigregister
Handle_StepShape_DimensionalSizeWithPath_swigregister(Handle_StepShape_DimensionalSizeWithPath)

def Handle_StepShape_DimensionalSizeWithPath_DownCast(thing):
    return _StepShape.Handle_StepShape_DimensionalSizeWithPath_DownCast(thing)
Handle_StepShape_DimensionalSizeWithPath_DownCast = _StepShape.Handle_StepShape_DimensionalSizeWithPath_DownCast

class Handle_StepShape_FacetedBrepShapeRepresentation(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepShape_FacetedBrepShapeRepresentation self)

        Nullify the handle


        """
        return _StepShape.Handle_StepShape_FacetedBrepShapeRepresentation_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepShape_FacetedBrepShapeRepresentation self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepShape.Handle_StepShape_FacetedBrepShapeRepresentation_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepShape_FacetedBrepShapeRepresentation self, StepShape_FacetedBrepShapeRepresentation thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepShape.Handle_StepShape_FacetedBrepShapeRepresentation_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepShape_FacetedBrepShapeRepresentation self, Handle_StepShape_FacetedBrepShapeRepresentation theHandle) -> Handle_StepShape_FacetedBrepShapeRepresentation
        assign(Handle_StepShape_FacetedBrepShapeRepresentation self, StepShape_FacetedBrepShapeRepresentation thePtr) -> Handle_StepShape_FacetedBrepShapeRepresentation
        assign(Handle_StepShape_FacetedBrepShapeRepresentation self, Handle_StepShape_FacetedBrepShapeRepresentation theHandle) -> Handle_StepShape_FacetedBrepShapeRepresentation

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepShape.Handle_StepShape_FacetedBrepShapeRepresentation_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepShape_FacetedBrepShapeRepresentation self) -> StepShape_FacetedBrepShapeRepresentation

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepShape.Handle_StepShape_FacetedBrepShapeRepresentation_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepShape_FacetedBrepShapeRepresentation self) -> StepShape_FacetedBrepShapeRepresentation

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepShape.Handle_StepShape_FacetedBrepShapeRepresentation___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepShape_FacetedBrepShapeRepresentation self) -> StepShape_FacetedBrepShapeRepresentation

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepShape.Handle_StepShape_FacetedBrepShapeRepresentation___ref__(self, *args)


    def __hash__(self):
        return _StepShape.Handle_StepShape_FacetedBrepShapeRepresentation___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepShape.Handle_StepShape_FacetedBrepShapeRepresentation___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepShape.new_Handle_StepShape_FacetedBrepShapeRepresentation(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepShape.Handle_StepShape_FacetedBrepShapeRepresentation_DownCast)
    __swig_destroy__ = _StepShape.delete_Handle_StepShape_FacetedBrepShapeRepresentation

    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepShape_FacetedBrepShapeRepresentation self) -> char const *

        :rtype: const char *

        """
        return _StepShape.Handle_StepShape_FacetedBrepShapeRepresentation_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.Handle_StepShape_FacetedBrepShapeRepresentation_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.Handle_StepShape_FacetedBrepShapeRepresentation_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Init(self, *args):
        """
        Init(Handle_StepShape_FacetedBrepShapeRepresentation self, Handle_TCollection_HAsciiString aName, Handle_StepRepr_HArray1OfRepresentationItem aItems, Handle_StepRepr_RepresentationContext aContextOfItems)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aItems: OCC.wrapper.StepRepr.Handle_StepRepr_HArray1OfRepresentationItem
        :type aContextOfItems: OCC.wrapper.StepRepr.Handle_StepRepr_RepresentationContext

        """
        return _StepShape.Handle_StepShape_FacetedBrepShapeRepresentation_Init(self, *args)


    def SetName(self, *args):
        """
        SetName(Handle_StepShape_FacetedBrepShapeRepresentation self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepShape.Handle_StepShape_FacetedBrepShapeRepresentation_SetName(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepShape_FacetedBrepShapeRepresentation self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepShape.Handle_StepShape_FacetedBrepShapeRepresentation_Name(self, *args)


    def SetItems(self, *args):
        """
        SetItems(Handle_StepShape_FacetedBrepShapeRepresentation self, Handle_StepRepr_HArray1OfRepresentationItem aItems)

        :type aItems: OCC.wrapper.StepRepr.Handle_StepRepr_HArray1OfRepresentationItem

        """
        return _StepShape.Handle_StepShape_FacetedBrepShapeRepresentation_SetItems(self, *args)


    def Items(self, *args):
        """
        Items(Handle_StepShape_FacetedBrepShapeRepresentation self) -> Handle_StepRepr_HArray1OfRepresentationItem

        :rtype: OCC.wrapper.StepRepr.Handle_StepRepr_HArray1OfRepresentationItem

        """
        return _StepShape.Handle_StepShape_FacetedBrepShapeRepresentation_Items(self, *args)


    def ItemsValue(self, *args):
        """
        ItemsValue(Handle_StepShape_FacetedBrepShapeRepresentation self, Standard_Integer const num) -> Handle_StepRepr_RepresentationItem

        :type num: int
        :rtype: OCC.wrapper.StepRepr.Handle_StepRepr_RepresentationItem

        """
        return _StepShape.Handle_StepShape_FacetedBrepShapeRepresentation_ItemsValue(self, *args)


    def NbItems(self, *args):
        """
        NbItems(Handle_StepShape_FacetedBrepShapeRepresentation self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_FacetedBrepShapeRepresentation_NbItems(self, *args)


    def SetContextOfItems(self, *args):
        """
        SetContextOfItems(Handle_StepShape_FacetedBrepShapeRepresentation self, Handle_StepRepr_RepresentationContext aContextOfItems)

        :type aContextOfItems: OCC.wrapper.StepRepr.Handle_StepRepr_RepresentationContext

        """
        return _StepShape.Handle_StepShape_FacetedBrepShapeRepresentation_SetContextOfItems(self, *args)


    def ContextOfItems(self, *args):
        """
        ContextOfItems(Handle_StepShape_FacetedBrepShapeRepresentation self) -> Handle_StepRepr_RepresentationContext

        :rtype: OCC.wrapper.StepRepr.Handle_StepRepr_RepresentationContext

        """
        return _StepShape.Handle_StepShape_FacetedBrepShapeRepresentation_ContextOfItems(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepShape_FacetedBrepShapeRepresentation self)

        Memory deallocator for transient classes


        """
        return _StepShape.Handle_StepShape_FacetedBrepShapeRepresentation_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepShape_FacetedBrepShapeRepresentation self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepShape_FacetedBrepShapeRepresentation self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.Handle_StepShape_FacetedBrepShapeRepresentation_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepShape_FacetedBrepShapeRepresentation self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepShape_FacetedBrepShapeRepresentation self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.Handle_StepShape_FacetedBrepShapeRepresentation_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepShape_FacetedBrepShapeRepresentation self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepShape.Handle_StepShape_FacetedBrepShapeRepresentation_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepShape_FacetedBrepShapeRepresentation self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_FacetedBrepShapeRepresentation_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepShape_FacetedBrepShapeRepresentation self)

        Increments the reference counter of this object


        """
        return _StepShape.Handle_StepShape_FacetedBrepShapeRepresentation_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepShape_FacetedBrepShapeRepresentation self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_FacetedBrepShapeRepresentation_DecrementRefCounter(self, *args)

Handle_StepShape_FacetedBrepShapeRepresentation_swigregister = _StepShape.Handle_StepShape_FacetedBrepShapeRepresentation_swigregister
Handle_StepShape_FacetedBrepShapeRepresentation_swigregister(Handle_StepShape_FacetedBrepShapeRepresentation)

def Handle_StepShape_FacetedBrepShapeRepresentation_DownCast(thing):
    return _StepShape.Handle_StepShape_FacetedBrepShapeRepresentation_DownCast(thing)
Handle_StepShape_FacetedBrepShapeRepresentation_DownCast = _StepShape.Handle_StepShape_FacetedBrepShapeRepresentation_DownCast

class StepShape_AngularLocation(StepShape_DimensionalLocation):
    """Representation of STEP entity AngularLocation"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepShape_AngularLocation
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepShape_AngularLocation(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepShape_AngularLocation self) -> StepShape_AngularLocation

        Empty constructor


        """
        this = _StepShape.new_StepShape_AngularLocation(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepShape_AngularLocation self, Handle_TCollection_HAsciiString aShapeAspectRelationship_Name, Standard_Boolean const hasShapeAspectRelationship_Description, Handle_TCollection_HAsciiString aShapeAspectRelationship_Description, Handle_StepRepr_ShapeAspect aShapeAspectRelationship_RelatingShapeAspect, Handle_StepRepr_ShapeAspect aShapeAspectRelationship_RelatedShapeAspect, StepShape_AngleRelator const aAngleSelection)

        Initialize all fields (own and inherited)

        :type aShapeAspectRelationship_Name: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type hasShapeAspectRelationship_Description: bool
        :type aShapeAspectRelationship_Description: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aShapeAspectRelationship_RelatingShapeAspect: OCC.wrapper.StepShape.Handle_StepRepr_ShapeAspect
        :type aShapeAspectRelationship_RelatedShapeAspect: OCC.wrapper.StepShape.Handle_StepRepr_ShapeAspect
        :type aAngleSelection: OCC.wrapper.StepShape.StepShape_AngleRelator

        """
        return _StepShape.StepShape_AngularLocation_Init(self, *args)


    def AngleSelection(self, *args):
        """
        AngleSelection(StepShape_AngularLocation self) -> StepShape_AngleRelator

        Returns field AngleSelection

        :rtype: OCC.wrapper.StepShape.StepShape_AngleRelator

        """
        return _StepShape.StepShape_AngularLocation_AngleSelection(self, *args)


    def SetAngleSelection(self, *args):
        """
        SetAngleSelection(StepShape_AngularLocation self, StepShape_AngleRelator const AngleSelection)

        Set field AngleSelection

        :type AngleSelection: OCC.wrapper.StepShape.StepShape_AngleRelator

        """
        return _StepShape.StepShape_AngularLocation_SetAngleSelection(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepShape.StepShape_AngularLocation_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepShape.StepShape_AngularLocation_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.StepShape_AngularLocation_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepShape.delete_StepShape_AngularLocation
StepShape_AngularLocation_swigregister = _StepShape.StepShape_AngularLocation_swigregister
StepShape_AngularLocation_swigregister(StepShape_AngularLocation)

def StepShape_AngularLocation_get_type_name(*args):
    """
    StepShape_AngularLocation_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepShape.StepShape_AngularLocation_get_type_name(*args)

def StepShape_AngularLocation_get_type_descriptor(*args):
    """
    StepShape_AngularLocation_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepShape.StepShape_AngularLocation_get_type_descriptor(*args)

class Handle_StepShape_MeasureQualification(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepShape_MeasureQualification self)

        Nullify the handle


        """
        return _StepShape.Handle_StepShape_MeasureQualification_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepShape_MeasureQualification self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepShape.Handle_StepShape_MeasureQualification_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepShape_MeasureQualification self, StepShape_MeasureQualification thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepShape.Handle_StepShape_MeasureQualification_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepShape_MeasureQualification self, Handle_StepShape_MeasureQualification theHandle) -> Handle_StepShape_MeasureQualification
        assign(Handle_StepShape_MeasureQualification self, StepShape_MeasureQualification thePtr) -> Handle_StepShape_MeasureQualification
        assign(Handle_StepShape_MeasureQualification self, Handle_StepShape_MeasureQualification theHandle) -> Handle_StepShape_MeasureQualification

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepShape.Handle_StepShape_MeasureQualification_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepShape_MeasureQualification self) -> StepShape_MeasureQualification

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepShape.Handle_StepShape_MeasureQualification_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepShape_MeasureQualification self) -> StepShape_MeasureQualification

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepShape.Handle_StepShape_MeasureQualification___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepShape_MeasureQualification self) -> StepShape_MeasureQualification

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepShape.Handle_StepShape_MeasureQualification___ref__(self, *args)


    def __hash__(self):
        return _StepShape.Handle_StepShape_MeasureQualification___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepShape.Handle_StepShape_MeasureQualification___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepShape.new_Handle_StepShape_MeasureQualification(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepShape.Handle_StepShape_MeasureQualification_DownCast)
    __swig_destroy__ = _StepShape.delete_Handle_StepShape_MeasureQualification

    def Init(self, *args):
        """
        Init(Handle_StepShape_MeasureQualification self, Handle_TCollection_HAsciiString name, Handle_TCollection_HAsciiString description, Handle_StepBasic_MeasureWithUnit qualified_measure, Handle_StepShape_HArray1OfValueQualifier qualifiers)

        :type name: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type description: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type qualified_measure: OCC.wrapper.StepBasic.Handle_StepBasic_MeasureWithUnit
        :type qualifiers: OCC.wrapper.StepShape.Handle_StepShape_HArray1OfValueQualifier

        """
        return _StepShape.Handle_StepShape_MeasureQualification_Init(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepShape_MeasureQualification self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepShape.Handle_StepShape_MeasureQualification_Name(self, *args)


    def SetName(self, *args):
        """
        SetName(Handle_StepShape_MeasureQualification self, Handle_TCollection_HAsciiString name)

        :type name: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepShape.Handle_StepShape_MeasureQualification_SetName(self, *args)


    def Description(self, *args):
        """
        Description(Handle_StepShape_MeasureQualification self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepShape.Handle_StepShape_MeasureQualification_Description(self, *args)


    def SetDescription(self, *args):
        """
        SetDescription(Handle_StepShape_MeasureQualification self, Handle_TCollection_HAsciiString description)

        :type description: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepShape.Handle_StepShape_MeasureQualification_SetDescription(self, *args)


    def QualifiedMeasure(self, *args):
        """
        QualifiedMeasure(Handle_StepShape_MeasureQualification self) -> Handle_StepBasic_MeasureWithUnit

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_MeasureWithUnit

        """
        return _StepShape.Handle_StepShape_MeasureQualification_QualifiedMeasure(self, *args)


    def SetQualifiedMeasure(self, *args):
        """
        SetQualifiedMeasure(Handle_StepShape_MeasureQualification self, Handle_StepBasic_MeasureWithUnit qualified_measure)

        :type qualified_measure: OCC.wrapper.StepBasic.Handle_StepBasic_MeasureWithUnit

        """
        return _StepShape.Handle_StepShape_MeasureQualification_SetQualifiedMeasure(self, *args)


    def Qualifiers(self, *args):
        """
        Qualifiers(Handle_StepShape_MeasureQualification self) -> Handle_StepShape_HArray1OfValueQualifier

        :rtype: OCC.wrapper.StepShape.Handle_StepShape_HArray1OfValueQualifier

        """
        return _StepShape.Handle_StepShape_MeasureQualification_Qualifiers(self, *args)


    def NbQualifiers(self, *args):
        """
        NbQualifiers(Handle_StepShape_MeasureQualification self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_MeasureQualification_NbQualifiers(self, *args)


    def SetQualifiers(self, *args):
        """
        SetQualifiers(Handle_StepShape_MeasureQualification self, Handle_StepShape_HArray1OfValueQualifier qualifiers)

        :type qualifiers: OCC.wrapper.StepShape.Handle_StepShape_HArray1OfValueQualifier

        """
        return _StepShape.Handle_StepShape_MeasureQualification_SetQualifiers(self, *args)


    def QualifiersValue(self, *args):
        """
        QualifiersValue(Handle_StepShape_MeasureQualification self, Standard_Integer const num) -> StepShape_ValueQualifier

        :type num: int
        :rtype: OCC.wrapper.StepShape.StepShape_ValueQualifier

        """
        return _StepShape.Handle_StepShape_MeasureQualification_QualifiersValue(self, *args)


    def SetQualifiersValue(self, *args):
        """
        SetQualifiersValue(Handle_StepShape_MeasureQualification self, Standard_Integer const num, StepShape_ValueQualifier aqualifier)

        :type num: int
        :type aqualifier: OCC.wrapper.StepShape.StepShape_ValueQualifier

        """
        return _StepShape.Handle_StepShape_MeasureQualification_SetQualifiersValue(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepShape_MeasureQualification self) -> char const *

        :rtype: const char *

        """
        return _StepShape.Handle_StepShape_MeasureQualification_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.Handle_StepShape_MeasureQualification_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.Handle_StepShape_MeasureQualification_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_StepShape_MeasureQualification self)

        Memory deallocator for transient classes


        """
        return _StepShape.Handle_StepShape_MeasureQualification_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepShape_MeasureQualification self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepShape_MeasureQualification self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.Handle_StepShape_MeasureQualification_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepShape_MeasureQualification self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepShape_MeasureQualification self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.Handle_StepShape_MeasureQualification_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepShape_MeasureQualification self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepShape.Handle_StepShape_MeasureQualification_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepShape_MeasureQualification self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_MeasureQualification_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepShape_MeasureQualification self)

        Increments the reference counter of this object


        """
        return _StepShape.Handle_StepShape_MeasureQualification_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepShape_MeasureQualification self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_MeasureQualification_DecrementRefCounter(self, *args)

Handle_StepShape_MeasureQualification_swigregister = _StepShape.Handle_StepShape_MeasureQualification_swigregister
Handle_StepShape_MeasureQualification_swigregister(Handle_StepShape_MeasureQualification)

def Handle_StepShape_MeasureQualification_DownCast(thing):
    return _StepShape.Handle_StepShape_MeasureQualification_DownCast(thing)
Handle_StepShape_MeasureQualification_DownCast = _StepShape.Handle_StepShape_MeasureQualification_DownCast

class Handle_StepShape_OpenShell(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepShape_OpenShell self)

        Nullify the handle


        """
        return _StepShape.Handle_StepShape_OpenShell_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepShape_OpenShell self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepShape.Handle_StepShape_OpenShell_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepShape_OpenShell self, StepShape_OpenShell thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepShape.Handle_StepShape_OpenShell_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepShape_OpenShell self, Handle_StepShape_OpenShell theHandle) -> Handle_StepShape_OpenShell
        assign(Handle_StepShape_OpenShell self, StepShape_OpenShell thePtr) -> Handle_StepShape_OpenShell
        assign(Handle_StepShape_OpenShell self, Handle_StepShape_OpenShell theHandle) -> Handle_StepShape_OpenShell

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepShape.Handle_StepShape_OpenShell_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepShape_OpenShell self) -> StepShape_OpenShell

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepShape.Handle_StepShape_OpenShell_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepShape_OpenShell self) -> StepShape_OpenShell

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepShape.Handle_StepShape_OpenShell___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepShape_OpenShell self) -> StepShape_OpenShell

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepShape.Handle_StepShape_OpenShell___ref__(self, *args)


    def __hash__(self):
        return _StepShape.Handle_StepShape_OpenShell___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepShape.Handle_StepShape_OpenShell___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepShape.new_Handle_StepShape_OpenShell(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepShape.Handle_StepShape_OpenShell_DownCast)
    __swig_destroy__ = _StepShape.delete_Handle_StepShape_OpenShell

    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepShape_OpenShell self) -> char const *

        :rtype: const char *

        """
        return _StepShape.Handle_StepShape_OpenShell_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.Handle_StepShape_OpenShell_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.Handle_StepShape_OpenShell_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Init(self, *args):
        """
        Init(Handle_StepShape_OpenShell self, Handle_TCollection_HAsciiString aName, Handle_StepShape_HArray1OfFace aCfsFaces)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aCfsFaces: OCC.wrapper.StepShape.Handle_StepShape_HArray1OfFace

        """
        return _StepShape.Handle_StepShape_OpenShell_Init(self, *args)


    def SetCfsFaces(self, *args):
        """
        SetCfsFaces(Handle_StepShape_OpenShell self, Handle_StepShape_HArray1OfFace aCfsFaces)

        :type aCfsFaces: OCC.wrapper.StepShape.Handle_StepShape_HArray1OfFace

        """
        return _StepShape.Handle_StepShape_OpenShell_SetCfsFaces(self, *args)


    def CfsFaces(self, *args):
        """
        CfsFaces(Handle_StepShape_OpenShell self) -> Handle_StepShape_HArray1OfFace

        :rtype: OCC.wrapper.StepShape.Handle_StepShape_HArray1OfFace

        """
        return _StepShape.Handle_StepShape_OpenShell_CfsFaces(self, *args)


    def CfsFacesValue(self, *args):
        """
        CfsFacesValue(Handle_StepShape_OpenShell self, Standard_Integer const num) -> Handle_StepShape_Face

        :type num: int
        :rtype: OCC.wrapper.StepShape.Handle_StepShape_Face

        """
        return _StepShape.Handle_StepShape_OpenShell_CfsFacesValue(self, *args)


    def NbCfsFaces(self, *args):
        """
        NbCfsFaces(Handle_StepShape_OpenShell self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_OpenShell_NbCfsFaces(self, *args)


    def SetName(self, *args):
        """
        SetName(Handle_StepShape_OpenShell self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepShape.Handle_StepShape_OpenShell_SetName(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepShape_OpenShell self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepShape.Handle_StepShape_OpenShell_Name(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepShape_OpenShell self)

        Memory deallocator for transient classes


        """
        return _StepShape.Handle_StepShape_OpenShell_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepShape_OpenShell self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepShape_OpenShell self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.Handle_StepShape_OpenShell_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepShape_OpenShell self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepShape_OpenShell self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.Handle_StepShape_OpenShell_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepShape_OpenShell self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepShape.Handle_StepShape_OpenShell_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepShape_OpenShell self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_OpenShell_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepShape_OpenShell self)

        Increments the reference counter of this object


        """
        return _StepShape.Handle_StepShape_OpenShell_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepShape_OpenShell self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_OpenShell_DecrementRefCounter(self, *args)

Handle_StepShape_OpenShell_swigregister = _StepShape.Handle_StepShape_OpenShell_swigregister
Handle_StepShape_OpenShell_swigregister(Handle_StepShape_OpenShell)

def Handle_StepShape_OpenShell_DownCast(thing):
    return _StepShape.Handle_StepShape_OpenShell_DownCast(thing)
Handle_StepShape_OpenShell_DownCast = _StepShape.Handle_StepShape_OpenShell_DownCast

class NCollection_Array1_StepShape_ShapeDimensionRepresentationItem(object):
    """
    Purpose:     The class Array1 represents unidimensional arrays 
    of fixed size known at run time. 
    The range of the index is user defined.
    An array1 can be constructed with a "C array".
    This functionality is useful to call methods expecting
    an Array1. It allows to carry the bounds inside the arrays.

    Examples:    Item tab[100]; //  An example with a C array
    Array1OfItem ttab (tab[0],1,100);

    Array1OfItem tttab (ttab(10),10,20); // a slice of ttab

    If you want to reindex an array from 1 to Length do :

    Array1 tab1(tab(tab.Lower()),1,tab.Length());

    Warning:     Programs client of such a class must be independant
    of the range of the first element. Then, a C++ for
    loop must be written like this

    for (i = A.Lower(); i <= A.Upper(); i++)

    Changes:     In  comparison  to  TCollection  the  flag  isAllocated  was
    renamed into myDeletable (alike in  the Array2).  For naming
    compatibility the method IsAllocated remained in class along
    with IsDeletable.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Array1_StepShape_ShapeDimensionRepresentationItem self) -> NCollection_Array1< StepShape_ShapeDimensionRepresentationItem >::iterator

        Returns an iterator pointing to the first element in the array.

        :rtype: iterator

        """
        return _StepShape.NCollection_Array1_StepShape_ShapeDimensionRepresentationItem_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Array1_StepShape_ShapeDimensionRepresentationItem self) -> NCollection_Array1< StepShape_ShapeDimensionRepresentationItem >::iterator

        Returns an iterator referring to the past-the-end element in the array.

        :rtype: iterator

        """
        return _StepShape.NCollection_Array1_StepShape_ShapeDimensionRepresentationItem_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Array1_StepShape_ShapeDimensionRepresentationItem self) -> NCollection_Array1< StepShape_ShapeDimensionRepresentationItem >::const_iterator

        Returns a const iterator pointing to the first element in the array.

        :rtype: const_iterator

        """
        return _StepShape.NCollection_Array1_StepShape_ShapeDimensionRepresentationItem_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Array1_StepShape_ShapeDimensionRepresentationItem self) -> NCollection_Array1< StepShape_ShapeDimensionRepresentationItem >::const_iterator

        Returns a const iterator referring to the past-the-end element in the array.

        :rtype: const_iterator

        """
        return _StepShape.NCollection_Array1_StepShape_ShapeDimensionRepresentationItem_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     The class Array1 represents unidimensional arrays 
        of fixed size known at run time. 
        The range of the index is user defined.
        An array1 can be constructed with a "C array".
        This functionality is useful to call methods expecting
        an Array1. It allows to carry the bounds inside the arrays.

        Examples:    Item tab[100]; //  An example with a C array
        Array1OfItem ttab (tab[0],1,100);

        Array1OfItem tttab (ttab(10),10,20); // a slice of ttab

        If you want to reindex an array from 1 to Length do :

        Array1 tab1(tab(tab.Lower()),1,tab.Length());

        Warning:     Programs client of such a class must be independant
        of the range of the first element. Then, a C++ for
        loop must be written like this

        for (i = A.Lower(); i <= A.Upper(); i++)

        Changes:     In  comparison  to  TCollection  the  flag  isAllocated  was
        renamed into myDeletable (alike in  the Array2).  For naming
        compatibility the method IsAllocated remained in class along
        with IsDeletable.
        """
        this = _StepShape.new_NCollection_Array1_StepShape_ShapeDimensionRepresentationItem(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(NCollection_Array1_StepShape_ShapeDimensionRepresentationItem self, StepShape_ShapeDimensionRepresentationItem theValue)

        Initialise the items with theValue

        :type theValue: const TheItemType &

        """
        return _StepShape.NCollection_Array1_StepShape_ShapeDimensionRepresentationItem_Init(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_Array1_StepShape_ShapeDimensionRepresentationItem self) -> Standard_Integer

        Size query

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.NCollection_Array1_StepShape_ShapeDimensionRepresentationItem_Size(self, *args)


    def Length(self, *args):
        """
        Length(NCollection_Array1_StepShape_ShapeDimensionRepresentationItem self) -> Standard_Integer

        Length query (the same)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.NCollection_Array1_StepShape_ShapeDimensionRepresentationItem_Length(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Array1_StepShape_ShapeDimensionRepresentationItem self) -> Standard_Boolean

        Return TRUE if array has zero length.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.NCollection_Array1_StepShape_ShapeDimensionRepresentationItem_IsEmpty(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Array1_StepShape_ShapeDimensionRepresentationItem self) -> Standard_Integer

        Lower bound

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.NCollection_Array1_StepShape_ShapeDimensionRepresentationItem_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Array1_StepShape_ShapeDimensionRepresentationItem self) -> Standard_Integer

        Upper bound

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.NCollection_Array1_StepShape_ShapeDimensionRepresentationItem_Upper(self, *args)


    def IsDeletable(self, *args):
        """
        IsDeletable(NCollection_Array1_StepShape_ShapeDimensionRepresentationItem self) -> Standard_Boolean

        myDeletable flag

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.NCollection_Array1_StepShape_ShapeDimensionRepresentationItem_IsDeletable(self, *args)


    def IsAllocated(self, *args):
        """
        IsAllocated(NCollection_Array1_StepShape_ShapeDimensionRepresentationItem self) -> Standard_Boolean

        IsAllocated flag - for naming compatibility

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.NCollection_Array1_StepShape_ShapeDimensionRepresentationItem_IsAllocated(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Array1_StepShape_ShapeDimensionRepresentationItem self, NCollection_Array1_StepShape_ShapeDimensionRepresentationItem theOther) -> NCollection_Array1_StepShape_ShapeDimensionRepresentationItem

        Copies data of theOther array to this.
        This array should be pre-allocated and have the same length as theOther;
        otherwise exception Standard_DimensionMismatch is thrown.

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _StepShape.NCollection_Array1_StepShape_ShapeDimensionRepresentationItem_Assign(self, *args)


    def Move(self, *args):
        """
        Move(NCollection_Array1_StepShape_ShapeDimensionRepresentationItem self, NCollection_Array1_StepShape_ShapeDimensionRepresentationItem theOther) -> NCollection_Array1_StepShape_ShapeDimensionRepresentationItem

        Move assignment.
        This array will borrow all the data from theOther.
        The moved object will keep pointer to the memory buffer and
        range, but it will not free the buffer on destruction.

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _StepShape.NCollection_Array1_StepShape_ShapeDimensionRepresentationItem_Move(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Array1_StepShape_ShapeDimensionRepresentationItem self, NCollection_Array1_StepShape_ShapeDimensionRepresentationItem theOther) -> NCollection_Array1_StepShape_ShapeDimensionRepresentationItem
        assign(NCollection_Array1_StepShape_ShapeDimensionRepresentationItem self, NCollection_Array1_StepShape_ShapeDimensionRepresentationItem theOther) -> NCollection_Array1_StepShape_ShapeDimensionRepresentationItem

        Move assignment operator; @sa Move()

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1<TheItemType> &&
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _StepShape.NCollection_Array1_StepShape_ShapeDimensionRepresentationItem_assign(self, *args)


    def First(self, *args):
        """
        @return first element

        :rtype: const TheItemType &

        """
        res = _StepShape.NCollection_Array1_StepShape_ShapeDimensionRepresentationItem_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Array1_StepShape_ShapeDimensionRepresentationItem self) -> StepShape_ShapeDimensionRepresentationItem

        @return first element

        :rtype: TheItemType &

        """
        return _StepShape.NCollection_Array1_StepShape_ShapeDimensionRepresentationItem_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        @return last element

        :rtype: const TheItemType &

        """
        res = _StepShape.NCollection_Array1_StepShape_ShapeDimensionRepresentationItem_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Array1_StepShape_ShapeDimensionRepresentationItem self) -> StepShape_ShapeDimensionRepresentationItem

        @return last element

        :rtype: TheItemType &

        """
        return _StepShape.NCollection_Array1_StepShape_ShapeDimensionRepresentationItem_ChangeLast(self, *args)


    def Value(self, *args):
        """
        Constant value access

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _StepShape.NCollection_Array1_StepShape_ShapeDimensionRepresentationItem_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Array1_StepShape_ShapeDimensionRepresentationItem self, Standard_Integer const theIndex) -> StepShape_ShapeDimensionRepresentationItem

        Variable value access

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _StepShape.NCollection_Array1_StepShape_ShapeDimensionRepresentationItem_ChangeValue(self, *args)


    def __call__(self, *args):
        """
        operator() - alias to Value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _StepShape.NCollection_Array1_StepShape_ShapeDimensionRepresentationItem___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __getitem__(self, *args):
        """
        operator[] - alias to Value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _StepShape.NCollection_Array1_StepShape_ShapeDimensionRepresentationItem_at(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetValue(self, *args):
        """
        SetValue(NCollection_Array1_StepShape_ShapeDimensionRepresentationItem self, Standard_Integer const theIndex, StepShape_ShapeDimensionRepresentationItem theItem)

        Set value 

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _StepShape.NCollection_Array1_StepShape_ShapeDimensionRepresentationItem_SetValue(self, *args)


    def Resize(self, *args):
        """
        Resize(NCollection_Array1_StepShape_ShapeDimensionRepresentationItem self, Standard_Integer const theLower, Standard_Integer const theUpper, Standard_Boolean const theToCopyData)

        Resizes the array to specified bounds.
        No re-allocation will be done if length of array does not change,
        but existing values will not be discarded if theToCopyData set to FALSE.
        @param theLower new lower bound of array
        @param theUpper new upper bound of array
        @param theToCopyData flag to copy existing data into new array

        :type theLower: int
        :type theUpper: int
        :type theToCopyData: bool

        """
        return _StepShape.NCollection_Array1_StepShape_ShapeDimensionRepresentationItem_Resize(self, *args)

    __swig_destroy__ = _StepShape.delete_NCollection_Array1_StepShape_ShapeDimensionRepresentationItem
NCollection_Array1_StepShape_ShapeDimensionRepresentationItem_swigregister = _StepShape.NCollection_Array1_StepShape_ShapeDimensionRepresentationItem_swigregister
NCollection_Array1_StepShape_ShapeDimensionRepresentationItem_swigregister(NCollection_Array1_StepShape_ShapeDimensionRepresentationItem)


try:
	StepShape_Array1OfShapeDimensionRepresentationItem = NCollection_Array1_StepShape_ShapeDimensionRepresentationItem
except NameError:
	pass # does not exist, probably ignored

class Handle_StepShape_HalfSpaceSolid(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepShape_HalfSpaceSolid self)

        Nullify the handle


        """
        return _StepShape.Handle_StepShape_HalfSpaceSolid_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepShape_HalfSpaceSolid self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepShape.Handle_StepShape_HalfSpaceSolid_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepShape_HalfSpaceSolid self, StepShape_HalfSpaceSolid thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepShape.Handle_StepShape_HalfSpaceSolid_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepShape_HalfSpaceSolid self, Handle_StepShape_HalfSpaceSolid theHandle) -> Handle_StepShape_HalfSpaceSolid
        assign(Handle_StepShape_HalfSpaceSolid self, StepShape_HalfSpaceSolid thePtr) -> Handle_StepShape_HalfSpaceSolid
        assign(Handle_StepShape_HalfSpaceSolid self, Handle_StepShape_HalfSpaceSolid theHandle) -> Handle_StepShape_HalfSpaceSolid

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepShape.Handle_StepShape_HalfSpaceSolid_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepShape_HalfSpaceSolid self) -> StepShape_HalfSpaceSolid

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepShape.Handle_StepShape_HalfSpaceSolid_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepShape_HalfSpaceSolid self) -> StepShape_HalfSpaceSolid

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepShape.Handle_StepShape_HalfSpaceSolid___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepShape_HalfSpaceSolid self) -> StepShape_HalfSpaceSolid

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepShape.Handle_StepShape_HalfSpaceSolid___ref__(self, *args)


    def __hash__(self):
        return _StepShape.Handle_StepShape_HalfSpaceSolid___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepShape.Handle_StepShape_HalfSpaceSolid___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepShape.new_Handle_StepShape_HalfSpaceSolid(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepShape.Handle_StepShape_HalfSpaceSolid_DownCast)
    __swig_destroy__ = _StepShape.delete_Handle_StepShape_HalfSpaceSolid

    def Init(self, *args):
        """
        Init(Handle_StepShape_HalfSpaceSolid self, Handle_TCollection_HAsciiString aName, Handle_StepGeom_Surface aBaseSurface, Standard_Boolean const aAgreementFlag)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aBaseSurface: OCC.wrapper.StepShape.Handle_StepGeom_Surface
        :type aAgreementFlag: bool

        """
        return _StepShape.Handle_StepShape_HalfSpaceSolid_Init(self, *args)


    def SetBaseSurface(self, *args):
        """
        SetBaseSurface(Handle_StepShape_HalfSpaceSolid self, Handle_StepGeom_Surface aBaseSurface)

        :type aBaseSurface: OCC.wrapper.StepShape.Handle_StepGeom_Surface

        """
        return _StepShape.Handle_StepShape_HalfSpaceSolid_SetBaseSurface(self, *args)


    def BaseSurface(self, *args):
        """
        BaseSurface(Handle_StepShape_HalfSpaceSolid self) -> Handle_StepGeom_Surface

        :rtype: OCC.wrapper.StepShape.Handle_StepGeom_Surface

        """
        return _StepShape.Handle_StepShape_HalfSpaceSolid_BaseSurface(self, *args)


    def SetAgreementFlag(self, *args):
        """
        SetAgreementFlag(Handle_StepShape_HalfSpaceSolid self, Standard_Boolean const aAgreementFlag)

        :type aAgreementFlag: bool

        """
        return _StepShape.Handle_StepShape_HalfSpaceSolid_SetAgreementFlag(self, *args)


    def AgreementFlag(self, *args):
        """
        AgreementFlag(Handle_StepShape_HalfSpaceSolid self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.Handle_StepShape_HalfSpaceSolid_AgreementFlag(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepShape_HalfSpaceSolid self) -> char const *

        :rtype: const char *

        """
        return _StepShape.Handle_StepShape_HalfSpaceSolid_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.Handle_StepShape_HalfSpaceSolid_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.Handle_StepShape_HalfSpaceSolid_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetName(self, *args):
        """
        SetName(Handle_StepShape_HalfSpaceSolid self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepShape.Handle_StepShape_HalfSpaceSolid_SetName(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepShape_HalfSpaceSolid self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepShape.Handle_StepShape_HalfSpaceSolid_Name(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepShape_HalfSpaceSolid self)

        Memory deallocator for transient classes


        """
        return _StepShape.Handle_StepShape_HalfSpaceSolid_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepShape_HalfSpaceSolid self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepShape_HalfSpaceSolid self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.Handle_StepShape_HalfSpaceSolid_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepShape_HalfSpaceSolid self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepShape_HalfSpaceSolid self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.Handle_StepShape_HalfSpaceSolid_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepShape_HalfSpaceSolid self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepShape.Handle_StepShape_HalfSpaceSolid_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepShape_HalfSpaceSolid self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_HalfSpaceSolid_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepShape_HalfSpaceSolid self)

        Increments the reference counter of this object


        """
        return _StepShape.Handle_StepShape_HalfSpaceSolid_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepShape_HalfSpaceSolid self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_HalfSpaceSolid_DecrementRefCounter(self, *args)

Handle_StepShape_HalfSpaceSolid_swigregister = _StepShape.Handle_StepShape_HalfSpaceSolid_swigregister
Handle_StepShape_HalfSpaceSolid_swigregister(Handle_StepShape_HalfSpaceSolid)

def Handle_StepShape_HalfSpaceSolid_DownCast(thing):
    return _StepShape.Handle_StepShape_HalfSpaceSolid_DownCast(thing)
Handle_StepShape_HalfSpaceSolid_DownCast = _StepShape.Handle_StepShape_HalfSpaceSolid_DownCast

class StepShape_GeometricallyBoundedWireframeShapeRepresentation(StepShape_ShapeRepresentation):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepShape_GeometricallyBoundedWireframeShapeRepresentation
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepShape_GeometricallyBoundedWireframeShapeRepresentation(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepShape_GeometricallyBoundedWireframeShapeRepresentation self) -> StepShape_GeometricallyBoundedWireframeShapeRepresentation

        Returns a GeometricallyBoundedWireframeShapeRepresentation


        """
        this = _StepShape.new_StepShape_GeometricallyBoundedWireframeShapeRepresentation(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepShape.StepShape_GeometricallyBoundedWireframeShapeRepresentation_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepShape.StepShape_GeometricallyBoundedWireframeShapeRepresentation_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.StepShape_GeometricallyBoundedWireframeShapeRepresentation_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepShape.delete_StepShape_GeometricallyBoundedWireframeShapeRepresentation
StepShape_GeometricallyBoundedWireframeShapeRepresentation_swigregister = _StepShape.StepShape_GeometricallyBoundedWireframeShapeRepresentation_swigregister
StepShape_GeometricallyBoundedWireframeShapeRepresentation_swigregister(StepShape_GeometricallyBoundedWireframeShapeRepresentation)

def StepShape_GeometricallyBoundedWireframeShapeRepresentation_get_type_name(*args):
    """
    StepShape_GeometricallyBoundedWireframeShapeRepresentation_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepShape.StepShape_GeometricallyBoundedWireframeShapeRepresentation_get_type_name(*args)

def StepShape_GeometricallyBoundedWireframeShapeRepresentation_get_type_descriptor(*args):
    """
    StepShape_GeometricallyBoundedWireframeShapeRepresentation_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepShape.StepShape_GeometricallyBoundedWireframeShapeRepresentation_get_type_descriptor(*args)

class StepShape_FaceOuterBound(StepShape_FaceBound):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepShape_FaceOuterBound
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepShape_FaceOuterBound(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepShape_FaceOuterBound self) -> StepShape_FaceOuterBound

        Returns a FaceOuterBound


        """
        this = _StepShape.new_StepShape_FaceOuterBound(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepShape.StepShape_FaceOuterBound_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepShape.StepShape_FaceOuterBound_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.StepShape_FaceOuterBound_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepShape.delete_StepShape_FaceOuterBound
StepShape_FaceOuterBound_swigregister = _StepShape.StepShape_FaceOuterBound_swigregister
StepShape_FaceOuterBound_swigregister(StepShape_FaceOuterBound)

def StepShape_FaceOuterBound_get_type_name(*args):
    """
    StepShape_FaceOuterBound_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepShape.StepShape_FaceOuterBound_get_type_name(*args)

def StepShape_FaceOuterBound_get_type_descriptor(*args):
    """
    StepShape_FaceOuterBound_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepShape.StepShape_FaceOuterBound_get_type_descriptor(*args)

class Handle_StepShape_PrecisionQualifier(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepShape_PrecisionQualifier self)

        Nullify the handle


        """
        return _StepShape.Handle_StepShape_PrecisionQualifier_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepShape_PrecisionQualifier self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepShape.Handle_StepShape_PrecisionQualifier_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepShape_PrecisionQualifier self, StepShape_PrecisionQualifier thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepShape.Handle_StepShape_PrecisionQualifier_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepShape_PrecisionQualifier self, Handle_StepShape_PrecisionQualifier theHandle) -> Handle_StepShape_PrecisionQualifier
        assign(Handle_StepShape_PrecisionQualifier self, StepShape_PrecisionQualifier thePtr) -> Handle_StepShape_PrecisionQualifier
        assign(Handle_StepShape_PrecisionQualifier self, Handle_StepShape_PrecisionQualifier theHandle) -> Handle_StepShape_PrecisionQualifier

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepShape.Handle_StepShape_PrecisionQualifier_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepShape_PrecisionQualifier self) -> StepShape_PrecisionQualifier

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepShape.Handle_StepShape_PrecisionQualifier_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepShape_PrecisionQualifier self) -> StepShape_PrecisionQualifier

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepShape.Handle_StepShape_PrecisionQualifier___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepShape_PrecisionQualifier self) -> StepShape_PrecisionQualifier

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepShape.Handle_StepShape_PrecisionQualifier___ref__(self, *args)


    def __hash__(self):
        return _StepShape.Handle_StepShape_PrecisionQualifier___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepShape.Handle_StepShape_PrecisionQualifier___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepShape.new_Handle_StepShape_PrecisionQualifier(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepShape.Handle_StepShape_PrecisionQualifier_DownCast)
    __swig_destroy__ = _StepShape.delete_Handle_StepShape_PrecisionQualifier

    def Init(self, *args):
        """
        Init(Handle_StepShape_PrecisionQualifier self, Standard_Integer const precision_value)

        :type precision_value: int

        """
        return _StepShape.Handle_StepShape_PrecisionQualifier_Init(self, *args)


    def PrecisionValue(self, *args):
        """
        PrecisionValue(Handle_StepShape_PrecisionQualifier self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_PrecisionQualifier_PrecisionValue(self, *args)


    def SetPrecisionValue(self, *args):
        """
        SetPrecisionValue(Handle_StepShape_PrecisionQualifier self, Standard_Integer const precision_value)

        :type precision_value: int

        """
        return _StepShape.Handle_StepShape_PrecisionQualifier_SetPrecisionValue(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepShape_PrecisionQualifier self) -> char const *

        :rtype: const char *

        """
        return _StepShape.Handle_StepShape_PrecisionQualifier_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.Handle_StepShape_PrecisionQualifier_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.Handle_StepShape_PrecisionQualifier_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_StepShape_PrecisionQualifier self)

        Memory deallocator for transient classes


        """
        return _StepShape.Handle_StepShape_PrecisionQualifier_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepShape_PrecisionQualifier self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepShape_PrecisionQualifier self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.Handle_StepShape_PrecisionQualifier_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepShape_PrecisionQualifier self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepShape_PrecisionQualifier self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.Handle_StepShape_PrecisionQualifier_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepShape_PrecisionQualifier self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepShape.Handle_StepShape_PrecisionQualifier_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepShape_PrecisionQualifier self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_PrecisionQualifier_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepShape_PrecisionQualifier self)

        Increments the reference counter of this object


        """
        return _StepShape.Handle_StepShape_PrecisionQualifier_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepShape_PrecisionQualifier self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_PrecisionQualifier_DecrementRefCounter(self, *args)

Handle_StepShape_PrecisionQualifier_swigregister = _StepShape.Handle_StepShape_PrecisionQualifier_swigregister
Handle_StepShape_PrecisionQualifier_swigregister(Handle_StepShape_PrecisionQualifier)

def Handle_StepShape_PrecisionQualifier_DownCast(thing):
    return _StepShape.Handle_StepShape_PrecisionQualifier_DownCast(thing)
Handle_StepShape_PrecisionQualifier_DownCast = _StepShape.Handle_StepShape_PrecisionQualifier_DownCast

class Handle_StepShape_FaceSurface(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepShape_FaceSurface self)

        Nullify the handle


        """
        return _StepShape.Handle_StepShape_FaceSurface_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepShape_FaceSurface self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepShape.Handle_StepShape_FaceSurface_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepShape_FaceSurface self, StepShape_FaceSurface thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepShape.Handle_StepShape_FaceSurface_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepShape_FaceSurface self, Handle_StepShape_FaceSurface theHandle) -> Handle_StepShape_FaceSurface
        assign(Handle_StepShape_FaceSurface self, StepShape_FaceSurface thePtr) -> Handle_StepShape_FaceSurface
        assign(Handle_StepShape_FaceSurface self, Handle_StepShape_FaceSurface theHandle) -> Handle_StepShape_FaceSurface

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepShape.Handle_StepShape_FaceSurface_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepShape_FaceSurface self) -> StepShape_FaceSurface

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepShape.Handle_StepShape_FaceSurface_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepShape_FaceSurface self) -> StepShape_FaceSurface

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepShape.Handle_StepShape_FaceSurface___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepShape_FaceSurface self) -> StepShape_FaceSurface

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepShape.Handle_StepShape_FaceSurface___ref__(self, *args)


    def __hash__(self):
        return _StepShape.Handle_StepShape_FaceSurface___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepShape.Handle_StepShape_FaceSurface___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepShape.new_Handle_StepShape_FaceSurface(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepShape.Handle_StepShape_FaceSurface_DownCast)
    __swig_destroy__ = _StepShape.delete_Handle_StepShape_FaceSurface

    def Init(self, *args):
        """
        Init(Handle_StepShape_FaceSurface self, Handle_TCollection_HAsciiString aName, Handle_StepShape_HArray1OfFaceBound aBounds, Handle_StepGeom_Surface aFaceGeometry, Standard_Boolean const aSameSense)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aBounds: OCC.wrapper.StepShape.Handle_StepShape_HArray1OfFaceBound
        :type aFaceGeometry: OCC.wrapper.StepShape.Handle_StepGeom_Surface
        :type aSameSense: bool

        """
        return _StepShape.Handle_StepShape_FaceSurface_Init(self, *args)


    def SetFaceGeometry(self, *args):
        """
        SetFaceGeometry(Handle_StepShape_FaceSurface self, Handle_StepGeom_Surface aFaceGeometry)

        :type aFaceGeometry: OCC.wrapper.StepShape.Handle_StepGeom_Surface

        """
        return _StepShape.Handle_StepShape_FaceSurface_SetFaceGeometry(self, *args)


    def FaceGeometry(self, *args):
        """
        FaceGeometry(Handle_StepShape_FaceSurface self) -> Handle_StepGeom_Surface

        :rtype: OCC.wrapper.StepShape.Handle_StepGeom_Surface

        """
        return _StepShape.Handle_StepShape_FaceSurface_FaceGeometry(self, *args)


    def SetSameSense(self, *args):
        """
        SetSameSense(Handle_StepShape_FaceSurface self, Standard_Boolean const aSameSense)

        :type aSameSense: bool

        """
        return _StepShape.Handle_StepShape_FaceSurface_SetSameSense(self, *args)


    def SameSense(self, *args):
        """
        SameSense(Handle_StepShape_FaceSurface self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.Handle_StepShape_FaceSurface_SameSense(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepShape_FaceSurface self) -> char const *

        :rtype: const char *

        """
        return _StepShape.Handle_StepShape_FaceSurface_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.Handle_StepShape_FaceSurface_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.Handle_StepShape_FaceSurface_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetBounds(self, *args):
        """
        SetBounds(Handle_StepShape_FaceSurface self, Handle_StepShape_HArray1OfFaceBound aBounds)

        :type aBounds: OCC.wrapper.StepShape.Handle_StepShape_HArray1OfFaceBound

        """
        return _StepShape.Handle_StepShape_FaceSurface_SetBounds(self, *args)


    def Bounds(self, *args):
        """
        Bounds(Handle_StepShape_FaceSurface self) -> Handle_StepShape_HArray1OfFaceBound

        :rtype: OCC.wrapper.StepShape.Handle_StepShape_HArray1OfFaceBound

        """
        return _StepShape.Handle_StepShape_FaceSurface_Bounds(self, *args)


    def BoundsValue(self, *args):
        """
        BoundsValue(Handle_StepShape_FaceSurface self, Standard_Integer const num) -> Handle_StepShape_FaceBound

        :type num: int
        :rtype: OCC.wrapper.StepShape.Handle_StepShape_FaceBound

        """
        return _StepShape.Handle_StepShape_FaceSurface_BoundsValue(self, *args)


    def NbBounds(self, *args):
        """
        NbBounds(Handle_StepShape_FaceSurface self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_FaceSurface_NbBounds(self, *args)


    def SetName(self, *args):
        """
        SetName(Handle_StepShape_FaceSurface self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepShape.Handle_StepShape_FaceSurface_SetName(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepShape_FaceSurface self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepShape.Handle_StepShape_FaceSurface_Name(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepShape_FaceSurface self)

        Memory deallocator for transient classes


        """
        return _StepShape.Handle_StepShape_FaceSurface_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepShape_FaceSurface self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepShape_FaceSurface self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.Handle_StepShape_FaceSurface_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepShape_FaceSurface self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepShape_FaceSurface self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.Handle_StepShape_FaceSurface_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepShape_FaceSurface self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepShape.Handle_StepShape_FaceSurface_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepShape_FaceSurface self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_FaceSurface_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepShape_FaceSurface self)

        Increments the reference counter of this object


        """
        return _StepShape.Handle_StepShape_FaceSurface_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepShape_FaceSurface self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_FaceSurface_DecrementRefCounter(self, *args)

Handle_StepShape_FaceSurface_swigregister = _StepShape.Handle_StepShape_FaceSurface_swigregister
Handle_StepShape_FaceSurface_swigregister(Handle_StepShape_FaceSurface)

def Handle_StepShape_FaceSurface_DownCast(thing):
    return _StepShape.Handle_StepShape_FaceSurface_DownCast(thing)
Handle_StepShape_FaceSurface_DownCast = _StepShape.Handle_StepShape_FaceSurface_DownCast

class Handle_StepShape_RightAngularWedge(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepShape_RightAngularWedge self)

        Nullify the handle


        """
        return _StepShape.Handle_StepShape_RightAngularWedge_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepShape_RightAngularWedge self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepShape.Handle_StepShape_RightAngularWedge_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepShape_RightAngularWedge self, StepShape_RightAngularWedge thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepShape.Handle_StepShape_RightAngularWedge_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepShape_RightAngularWedge self, Handle_StepShape_RightAngularWedge theHandle) -> Handle_StepShape_RightAngularWedge
        assign(Handle_StepShape_RightAngularWedge self, StepShape_RightAngularWedge thePtr) -> Handle_StepShape_RightAngularWedge
        assign(Handle_StepShape_RightAngularWedge self, Handle_StepShape_RightAngularWedge theHandle) -> Handle_StepShape_RightAngularWedge

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepShape.Handle_StepShape_RightAngularWedge_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepShape_RightAngularWedge self) -> StepShape_RightAngularWedge

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepShape.Handle_StepShape_RightAngularWedge_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepShape_RightAngularWedge self) -> StepShape_RightAngularWedge

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepShape.Handle_StepShape_RightAngularWedge___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepShape_RightAngularWedge self) -> StepShape_RightAngularWedge

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepShape.Handle_StepShape_RightAngularWedge___ref__(self, *args)


    def __hash__(self):
        return _StepShape.Handle_StepShape_RightAngularWedge___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepShape.Handle_StepShape_RightAngularWedge___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepShape.new_Handle_StepShape_RightAngularWedge(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepShape.Handle_StepShape_RightAngularWedge_DownCast)
    __swig_destroy__ = _StepShape.delete_Handle_StepShape_RightAngularWedge

    def Init(self, *args):
        """
        Init(Handle_StepShape_RightAngularWedge self, Handle_TCollection_HAsciiString aName, Handle_StepGeom_Axis2Placement3d aPosition, Standard_Real const aX, Standard_Real const aY, Standard_Real const aZ, Standard_Real const aLtx)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aPosition: OCC.wrapper.StepShape.Handle_StepGeom_Axis2Placement3d
        :type aX: float
        :type aY: float
        :type aZ: float
        :type aLtx: float

        """
        return _StepShape.Handle_StepShape_RightAngularWedge_Init(self, *args)


    def SetPosition(self, *args):
        """
        SetPosition(Handle_StepShape_RightAngularWedge self, Handle_StepGeom_Axis2Placement3d aPosition)

        :type aPosition: OCC.wrapper.StepShape.Handle_StepGeom_Axis2Placement3d

        """
        return _StepShape.Handle_StepShape_RightAngularWedge_SetPosition(self, *args)


    def Position(self, *args):
        """
        Position(Handle_StepShape_RightAngularWedge self) -> Handle_StepGeom_Axis2Placement3d

        :rtype: OCC.wrapper.StepShape.Handle_StepGeom_Axis2Placement3d

        """
        return _StepShape.Handle_StepShape_RightAngularWedge_Position(self, *args)


    def SetX(self, *args):
        """
        SetX(Handle_StepShape_RightAngularWedge self, Standard_Real const aX)

        :type aX: float

        """
        return _StepShape.Handle_StepShape_RightAngularWedge_SetX(self, *args)


    def X(self, *args):
        """
        X(Handle_StepShape_RightAngularWedge self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _StepShape.Handle_StepShape_RightAngularWedge_X(self, *args)


    def SetY(self, *args):
        """
        SetY(Handle_StepShape_RightAngularWedge self, Standard_Real const aY)

        :type aY: float

        """
        return _StepShape.Handle_StepShape_RightAngularWedge_SetY(self, *args)


    def Y(self, *args):
        """
        Y(Handle_StepShape_RightAngularWedge self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _StepShape.Handle_StepShape_RightAngularWedge_Y(self, *args)


    def SetZ(self, *args):
        """
        SetZ(Handle_StepShape_RightAngularWedge self, Standard_Real const aZ)

        :type aZ: float

        """
        return _StepShape.Handle_StepShape_RightAngularWedge_SetZ(self, *args)


    def Z(self, *args):
        """
        Z(Handle_StepShape_RightAngularWedge self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _StepShape.Handle_StepShape_RightAngularWedge_Z(self, *args)


    def SetLtx(self, *args):
        """
        SetLtx(Handle_StepShape_RightAngularWedge self, Standard_Real const aLtx)

        :type aLtx: float

        """
        return _StepShape.Handle_StepShape_RightAngularWedge_SetLtx(self, *args)


    def Ltx(self, *args):
        """
        Ltx(Handle_StepShape_RightAngularWedge self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _StepShape.Handle_StepShape_RightAngularWedge_Ltx(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepShape_RightAngularWedge self) -> char const *

        :rtype: const char *

        """
        return _StepShape.Handle_StepShape_RightAngularWedge_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.Handle_StepShape_RightAngularWedge_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.Handle_StepShape_RightAngularWedge_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetName(self, *args):
        """
        SetName(Handle_StepShape_RightAngularWedge self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepShape.Handle_StepShape_RightAngularWedge_SetName(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepShape_RightAngularWedge self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepShape.Handle_StepShape_RightAngularWedge_Name(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepShape_RightAngularWedge self)

        Memory deallocator for transient classes


        """
        return _StepShape.Handle_StepShape_RightAngularWedge_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepShape_RightAngularWedge self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepShape_RightAngularWedge self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.Handle_StepShape_RightAngularWedge_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepShape_RightAngularWedge self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepShape_RightAngularWedge self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.Handle_StepShape_RightAngularWedge_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepShape_RightAngularWedge self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepShape.Handle_StepShape_RightAngularWedge_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepShape_RightAngularWedge self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_RightAngularWedge_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepShape_RightAngularWedge self)

        Increments the reference counter of this object


        """
        return _StepShape.Handle_StepShape_RightAngularWedge_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepShape_RightAngularWedge self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_RightAngularWedge_DecrementRefCounter(self, *args)

Handle_StepShape_RightAngularWedge_swigregister = _StepShape.Handle_StepShape_RightAngularWedge_swigregister
Handle_StepShape_RightAngularWedge_swigregister(Handle_StepShape_RightAngularWedge)

def Handle_StepShape_RightAngularWedge_DownCast(thing):
    return _StepShape.Handle_StepShape_RightAngularWedge_DownCast(thing)
Handle_StepShape_RightAngularWedge_DownCast = _StepShape.Handle_StepShape_RightAngularWedge_DownCast

class StepShape_HArray1OfEdge(Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepShape_HArray1OfEdge
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepShape_HArray1OfEdge(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepShape_HArray1OfEdge self, Standard_Integer const theLower, Standard_Integer const theUpper) -> StepShape_HArray1OfEdge
        __init__(StepShape_HArray1OfEdge self, Standard_Integer const theLower, Standard_Integer const theUpper, Handle_StepShape_Edge theValue) -> StepShape_HArray1OfEdge
        __init__(StepShape_HArray1OfEdge self, NCollection_Array1_Handle_StepShape_Edge theOther) -> StepShape_HArray1OfEdge

        :type theOther: OCC.wrapper.StepShape.StepShape_Array1OfEdge

        """
        this = _StepShape.new_StepShape_HArray1OfEdge(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Array1(self, *args):
        """
        :rtype: OCC.wrapper.StepShape.StepShape_Array1OfEdge

        """
        res = _StepShape.StepShape_HArray1OfEdge_Array1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeArray1(self, *args):
        """
        ChangeArray1(StepShape_HArray1OfEdge self) -> NCollection_Array1_Handle_StepShape_Edge

        :rtype: OCC.wrapper.StepShape.StepShape_Array1OfEdge

        """
        return _StepShape.StepShape_HArray1OfEdge_ChangeArray1(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepShape.StepShape_HArray1OfEdge_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepShape.StepShape_HArray1OfEdge_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.StepShape_HArray1OfEdge_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepShape.delete_StepShape_HArray1OfEdge
StepShape_HArray1OfEdge_swigregister = _StepShape.StepShape_HArray1OfEdge_swigregister
StepShape_HArray1OfEdge_swigregister(StepShape_HArray1OfEdge)

def StepShape_HArray1OfEdge_get_type_name(*args):
    """
    StepShape_HArray1OfEdge_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepShape.StepShape_HArray1OfEdge_get_type_name(*args)

def StepShape_HArray1OfEdge_get_type_descriptor(*args):
    """
    StepShape_HArray1OfEdge_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepShape.StepShape_HArray1OfEdge_get_type_descriptor(*args)

class Handle_StepShape_OrientedEdge(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepShape_OrientedEdge self)

        Nullify the handle


        """
        return _StepShape.Handle_StepShape_OrientedEdge_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepShape_OrientedEdge self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepShape.Handle_StepShape_OrientedEdge_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepShape_OrientedEdge self, StepShape_OrientedEdge thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepShape.Handle_StepShape_OrientedEdge_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepShape_OrientedEdge self, Handle_StepShape_OrientedEdge theHandle) -> Handle_StepShape_OrientedEdge
        assign(Handle_StepShape_OrientedEdge self, StepShape_OrientedEdge thePtr) -> Handle_StepShape_OrientedEdge
        assign(Handle_StepShape_OrientedEdge self, Handle_StepShape_OrientedEdge theHandle) -> Handle_StepShape_OrientedEdge

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepShape.Handle_StepShape_OrientedEdge_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepShape_OrientedEdge self) -> StepShape_OrientedEdge

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepShape.Handle_StepShape_OrientedEdge_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepShape_OrientedEdge self) -> StepShape_OrientedEdge

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepShape.Handle_StepShape_OrientedEdge___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepShape_OrientedEdge self) -> StepShape_OrientedEdge

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepShape.Handle_StepShape_OrientedEdge___ref__(self, *args)


    def __hash__(self):
        return _StepShape.Handle_StepShape_OrientedEdge___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepShape.Handle_StepShape_OrientedEdge___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepShape.new_Handle_StepShape_OrientedEdge(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepShape.Handle_StepShape_OrientedEdge_DownCast)
    __swig_destroy__ = _StepShape.delete_Handle_StepShape_OrientedEdge

    def Init(self, *args):
        """
        Init(Handle_StepShape_OrientedEdge self, Handle_TCollection_HAsciiString aName, Handle_StepShape_Edge aEdgeElement, Standard_Boolean const aOrientation)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aEdgeElement: OCC.wrapper.StepShape.Handle_StepShape_Edge
        :type aOrientation: bool

        """
        return _StepShape.Handle_StepShape_OrientedEdge_Init(self, *args)


    def SetEdgeElement(self, *args):
        """
        SetEdgeElement(Handle_StepShape_OrientedEdge self, Handle_StepShape_Edge aEdgeElement)

        :type aEdgeElement: OCC.wrapper.StepShape.Handle_StepShape_Edge

        """
        return _StepShape.Handle_StepShape_OrientedEdge_SetEdgeElement(self, *args)


    def EdgeElement(self, *args):
        """
        EdgeElement(Handle_StepShape_OrientedEdge self) -> Handle_StepShape_Edge

        :rtype: OCC.wrapper.StepShape.Handle_StepShape_Edge

        """
        return _StepShape.Handle_StepShape_OrientedEdge_EdgeElement(self, *args)


    def SetOrientation(self, *args):
        """
        SetOrientation(Handle_StepShape_OrientedEdge self, Standard_Boolean const aOrientation)

        :type aOrientation: bool

        """
        return _StepShape.Handle_StepShape_OrientedEdge_SetOrientation(self, *args)


    def Orientation(self, *args):
        """
        Orientation(Handle_StepShape_OrientedEdge self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.Handle_StepShape_OrientedEdge_Orientation(self, *args)


    def SetEdgeStart(self, *args):
        """
        SetEdgeStart(Handle_StepShape_OrientedEdge self, Handle_StepShape_Vertex aEdgeStart)

        :type aEdgeStart: OCC.wrapper.StepShape.Handle_StepShape_Vertex

        """
        return _StepShape.Handle_StepShape_OrientedEdge_SetEdgeStart(self, *args)


    def EdgeStart(self, *args):
        """
        EdgeStart(Handle_StepShape_OrientedEdge self) -> Handle_StepShape_Vertex

        :rtype: OCC.wrapper.StepShape.Handle_StepShape_Vertex

        """
        return _StepShape.Handle_StepShape_OrientedEdge_EdgeStart(self, *args)


    def SetEdgeEnd(self, *args):
        """
        SetEdgeEnd(Handle_StepShape_OrientedEdge self, Handle_StepShape_Vertex aEdgeEnd)

        :type aEdgeEnd: OCC.wrapper.StepShape.Handle_StepShape_Vertex

        """
        return _StepShape.Handle_StepShape_OrientedEdge_SetEdgeEnd(self, *args)


    def EdgeEnd(self, *args):
        """
        EdgeEnd(Handle_StepShape_OrientedEdge self) -> Handle_StepShape_Vertex

        :rtype: OCC.wrapper.StepShape.Handle_StepShape_Vertex

        """
        return _StepShape.Handle_StepShape_OrientedEdge_EdgeEnd(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepShape_OrientedEdge self) -> char const *

        :rtype: const char *

        """
        return _StepShape.Handle_StepShape_OrientedEdge_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.Handle_StepShape_OrientedEdge_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.Handle_StepShape_OrientedEdge_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetName(self, *args):
        """
        SetName(Handle_StepShape_OrientedEdge self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepShape.Handle_StepShape_OrientedEdge_SetName(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepShape_OrientedEdge self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepShape.Handle_StepShape_OrientedEdge_Name(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepShape_OrientedEdge self)

        Memory deallocator for transient classes


        """
        return _StepShape.Handle_StepShape_OrientedEdge_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepShape_OrientedEdge self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepShape_OrientedEdge self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.Handle_StepShape_OrientedEdge_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepShape_OrientedEdge self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepShape_OrientedEdge self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.Handle_StepShape_OrientedEdge_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepShape_OrientedEdge self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepShape.Handle_StepShape_OrientedEdge_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepShape_OrientedEdge self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_OrientedEdge_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepShape_OrientedEdge self)

        Increments the reference counter of this object


        """
        return _StepShape.Handle_StepShape_OrientedEdge_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepShape_OrientedEdge self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_OrientedEdge_DecrementRefCounter(self, *args)

Handle_StepShape_OrientedEdge_swigregister = _StepShape.Handle_StepShape_OrientedEdge_swigregister
Handle_StepShape_OrientedEdge_swigregister(Handle_StepShape_OrientedEdge)

def Handle_StepShape_OrientedEdge_DownCast(thing):
    return _StepShape.Handle_StepShape_OrientedEdge_DownCast(thing)
Handle_StepShape_OrientedEdge_DownCast = _StepShape.Handle_StepShape_OrientedEdge_DownCast

class Handle_StepShape_EdgeBasedWireframeShapeRepresentation(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepShape_EdgeBasedWireframeShapeRepresentation self)

        Nullify the handle


        """
        return _StepShape.Handle_StepShape_EdgeBasedWireframeShapeRepresentation_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepShape_EdgeBasedWireframeShapeRepresentation self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepShape.Handle_StepShape_EdgeBasedWireframeShapeRepresentation_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepShape_EdgeBasedWireframeShapeRepresentation self, StepShape_EdgeBasedWireframeShapeRepresentation thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepShape.Handle_StepShape_EdgeBasedWireframeShapeRepresentation_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepShape_EdgeBasedWireframeShapeRepresentation self, Handle_StepShape_EdgeBasedWireframeShapeRepresentation theHandle) -> Handle_StepShape_EdgeBasedWireframeShapeRepresentation
        assign(Handle_StepShape_EdgeBasedWireframeShapeRepresentation self, StepShape_EdgeBasedWireframeShapeRepresentation thePtr) -> Handle_StepShape_EdgeBasedWireframeShapeRepresentation
        assign(Handle_StepShape_EdgeBasedWireframeShapeRepresentation self, Handle_StepShape_EdgeBasedWireframeShapeRepresentation theHandle) -> Handle_StepShape_EdgeBasedWireframeShapeRepresentation

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepShape.Handle_StepShape_EdgeBasedWireframeShapeRepresentation_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepShape_EdgeBasedWireframeShapeRepresentation self) -> StepShape_EdgeBasedWireframeShapeRepresentation

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepShape.Handle_StepShape_EdgeBasedWireframeShapeRepresentation_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepShape_EdgeBasedWireframeShapeRepresentation self) -> StepShape_EdgeBasedWireframeShapeRepresentation

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepShape.Handle_StepShape_EdgeBasedWireframeShapeRepresentation___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepShape_EdgeBasedWireframeShapeRepresentation self) -> StepShape_EdgeBasedWireframeShapeRepresentation

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepShape.Handle_StepShape_EdgeBasedWireframeShapeRepresentation___ref__(self, *args)


    def __hash__(self):
        return _StepShape.Handle_StepShape_EdgeBasedWireframeShapeRepresentation___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepShape.Handle_StepShape_EdgeBasedWireframeShapeRepresentation___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepShape.new_Handle_StepShape_EdgeBasedWireframeShapeRepresentation(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepShape.Handle_StepShape_EdgeBasedWireframeShapeRepresentation_DownCast)
    __swig_destroy__ = _StepShape.delete_Handle_StepShape_EdgeBasedWireframeShapeRepresentation

    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepShape_EdgeBasedWireframeShapeRepresentation self) -> char const *

        :rtype: const char *

        """
        return _StepShape.Handle_StepShape_EdgeBasedWireframeShapeRepresentation_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.Handle_StepShape_EdgeBasedWireframeShapeRepresentation_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.Handle_StepShape_EdgeBasedWireframeShapeRepresentation_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Init(self, *args):
        """
        Init(Handle_StepShape_EdgeBasedWireframeShapeRepresentation self, Handle_TCollection_HAsciiString aName, Handle_StepRepr_HArray1OfRepresentationItem aItems, Handle_StepRepr_RepresentationContext aContextOfItems)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aItems: OCC.wrapper.StepRepr.Handle_StepRepr_HArray1OfRepresentationItem
        :type aContextOfItems: OCC.wrapper.StepRepr.Handle_StepRepr_RepresentationContext

        """
        return _StepShape.Handle_StepShape_EdgeBasedWireframeShapeRepresentation_Init(self, *args)


    def SetName(self, *args):
        """
        SetName(Handle_StepShape_EdgeBasedWireframeShapeRepresentation self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepShape.Handle_StepShape_EdgeBasedWireframeShapeRepresentation_SetName(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepShape_EdgeBasedWireframeShapeRepresentation self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepShape.Handle_StepShape_EdgeBasedWireframeShapeRepresentation_Name(self, *args)


    def SetItems(self, *args):
        """
        SetItems(Handle_StepShape_EdgeBasedWireframeShapeRepresentation self, Handle_StepRepr_HArray1OfRepresentationItem aItems)

        :type aItems: OCC.wrapper.StepRepr.Handle_StepRepr_HArray1OfRepresentationItem

        """
        return _StepShape.Handle_StepShape_EdgeBasedWireframeShapeRepresentation_SetItems(self, *args)


    def Items(self, *args):
        """
        Items(Handle_StepShape_EdgeBasedWireframeShapeRepresentation self) -> Handle_StepRepr_HArray1OfRepresentationItem

        :rtype: OCC.wrapper.StepRepr.Handle_StepRepr_HArray1OfRepresentationItem

        """
        return _StepShape.Handle_StepShape_EdgeBasedWireframeShapeRepresentation_Items(self, *args)


    def ItemsValue(self, *args):
        """
        ItemsValue(Handle_StepShape_EdgeBasedWireframeShapeRepresentation self, Standard_Integer const num) -> Handle_StepRepr_RepresentationItem

        :type num: int
        :rtype: OCC.wrapper.StepRepr.Handle_StepRepr_RepresentationItem

        """
        return _StepShape.Handle_StepShape_EdgeBasedWireframeShapeRepresentation_ItemsValue(self, *args)


    def NbItems(self, *args):
        """
        NbItems(Handle_StepShape_EdgeBasedWireframeShapeRepresentation self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_EdgeBasedWireframeShapeRepresentation_NbItems(self, *args)


    def SetContextOfItems(self, *args):
        """
        SetContextOfItems(Handle_StepShape_EdgeBasedWireframeShapeRepresentation self, Handle_StepRepr_RepresentationContext aContextOfItems)

        :type aContextOfItems: OCC.wrapper.StepRepr.Handle_StepRepr_RepresentationContext

        """
        return _StepShape.Handle_StepShape_EdgeBasedWireframeShapeRepresentation_SetContextOfItems(self, *args)


    def ContextOfItems(self, *args):
        """
        ContextOfItems(Handle_StepShape_EdgeBasedWireframeShapeRepresentation self) -> Handle_StepRepr_RepresentationContext

        :rtype: OCC.wrapper.StepRepr.Handle_StepRepr_RepresentationContext

        """
        return _StepShape.Handle_StepShape_EdgeBasedWireframeShapeRepresentation_ContextOfItems(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepShape_EdgeBasedWireframeShapeRepresentation self)

        Memory deallocator for transient classes


        """
        return _StepShape.Handle_StepShape_EdgeBasedWireframeShapeRepresentation_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepShape_EdgeBasedWireframeShapeRepresentation self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepShape_EdgeBasedWireframeShapeRepresentation self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.Handle_StepShape_EdgeBasedWireframeShapeRepresentation_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepShape_EdgeBasedWireframeShapeRepresentation self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepShape_EdgeBasedWireframeShapeRepresentation self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.Handle_StepShape_EdgeBasedWireframeShapeRepresentation_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepShape_EdgeBasedWireframeShapeRepresentation self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepShape.Handle_StepShape_EdgeBasedWireframeShapeRepresentation_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepShape_EdgeBasedWireframeShapeRepresentation self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_EdgeBasedWireframeShapeRepresentation_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepShape_EdgeBasedWireframeShapeRepresentation self)

        Increments the reference counter of this object


        """
        return _StepShape.Handle_StepShape_EdgeBasedWireframeShapeRepresentation_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepShape_EdgeBasedWireframeShapeRepresentation self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_EdgeBasedWireframeShapeRepresentation_DecrementRefCounter(self, *args)

Handle_StepShape_EdgeBasedWireframeShapeRepresentation_swigregister = _StepShape.Handle_StepShape_EdgeBasedWireframeShapeRepresentation_swigregister
Handle_StepShape_EdgeBasedWireframeShapeRepresentation_swigregister(Handle_StepShape_EdgeBasedWireframeShapeRepresentation)

def Handle_StepShape_EdgeBasedWireframeShapeRepresentation_DownCast(thing):
    return _StepShape.Handle_StepShape_EdgeBasedWireframeShapeRepresentation_DownCast(thing)
Handle_StepShape_EdgeBasedWireframeShapeRepresentation_DownCast = _StepShape.Handle_StepShape_EdgeBasedWireframeShapeRepresentation_DownCast

class StepShape_SurfaceModel(StepData.StepData_SelectType):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(StepShape_SurfaceModel self) -> StepShape_SurfaceModel

        Returns a SurfaceModel SelectType


        """
        this = _StepShape.new_StepShape_SurfaceModel(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def CaseNum(self, *args):
        """
        CaseNum(StepShape_SurfaceModel self, Handle_Standard_Transient ent) -> Standard_Integer

        Recognizes a SurfaceModel Kind Entity that is :
        1 -> ShellBasedSurfaceModel
        2 -> FaceBasedSurfaceModel
        0 else

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.StepShape_SurfaceModel_CaseNum(self, *args)


    def ShellBasedSurfaceModel(self, *args):
        """
        ShellBasedSurfaceModel(StepShape_SurfaceModel self) -> Handle_StepShape_ShellBasedSurfaceModel

        returns Value as a ShellBasedSurfaceModel (Null if another type)

        :rtype: OCC.wrapper.StepShape.Handle_StepShape_ShellBasedSurfaceModel

        """
        return _StepShape.StepShape_SurfaceModel_ShellBasedSurfaceModel(self, *args)

    __swig_destroy__ = _StepShape.delete_StepShape_SurfaceModel
StepShape_SurfaceModel_swigregister = _StepShape.StepShape_SurfaceModel_swigregister
StepShape_SurfaceModel_swigregister(StepShape_SurfaceModel)

class Handle_StepShape_HArray1OfValueQualifier(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepShape_HArray1OfValueQualifier self)

        Nullify the handle


        """
        return _StepShape.Handle_StepShape_HArray1OfValueQualifier_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepShape_HArray1OfValueQualifier self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepShape.Handle_StepShape_HArray1OfValueQualifier_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepShape_HArray1OfValueQualifier self, StepShape_HArray1OfValueQualifier thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepShape.Handle_StepShape_HArray1OfValueQualifier_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepShape_HArray1OfValueQualifier self, Handle_StepShape_HArray1OfValueQualifier theHandle) -> Handle_StepShape_HArray1OfValueQualifier
        assign(Handle_StepShape_HArray1OfValueQualifier self, StepShape_HArray1OfValueQualifier thePtr) -> Handle_StepShape_HArray1OfValueQualifier
        assign(Handle_StepShape_HArray1OfValueQualifier self, Handle_StepShape_HArray1OfValueQualifier theHandle) -> Handle_StepShape_HArray1OfValueQualifier

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepShape.Handle_StepShape_HArray1OfValueQualifier_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepShape_HArray1OfValueQualifier self) -> StepShape_HArray1OfValueQualifier

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepShape.Handle_StepShape_HArray1OfValueQualifier_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepShape_HArray1OfValueQualifier self) -> StepShape_HArray1OfValueQualifier

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepShape.Handle_StepShape_HArray1OfValueQualifier___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepShape_HArray1OfValueQualifier self) -> StepShape_HArray1OfValueQualifier

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepShape.Handle_StepShape_HArray1OfValueQualifier___ref__(self, *args)


    def __hash__(self):
        return _StepShape.Handle_StepShape_HArray1OfValueQualifier___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepShape.Handle_StepShape_HArray1OfValueQualifier___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepShape.new_Handle_StepShape_HArray1OfValueQualifier(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepShape.Handle_StepShape_HArray1OfValueQualifier_DownCast)
    __swig_destroy__ = _StepShape.delete_Handle_StepShape_HArray1OfValueQualifier

    def Array1(self, *args):
        """
        :rtype: OCC.wrapper.StepShape.StepShape_Array1OfValueQualifier

        """
        res = _StepShape.Handle_StepShape_HArray1OfValueQualifier_Array1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeArray1(self, *args):
        """
        ChangeArray1(Handle_StepShape_HArray1OfValueQualifier self) -> NCollection_Array1_StepShape_ValueQualifier

        :rtype: OCC.wrapper.StepShape.StepShape_Array1OfValueQualifier

        """
        return _StepShape.Handle_StepShape_HArray1OfValueQualifier_ChangeArray1(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepShape_HArray1OfValueQualifier self) -> char const *

        :rtype: const char *

        """
        return _StepShape.Handle_StepShape_HArray1OfValueQualifier_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.Handle_StepShape_HArray1OfValueQualifier_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.Handle_StepShape_HArray1OfValueQualifier_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_StepShape_HArray1OfValueQualifier self)

        Memory deallocator for transient classes


        """
        return _StepShape.Handle_StepShape_HArray1OfValueQualifier_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepShape_HArray1OfValueQualifier self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepShape_HArray1OfValueQualifier self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.Handle_StepShape_HArray1OfValueQualifier_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepShape_HArray1OfValueQualifier self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepShape_HArray1OfValueQualifier self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.Handle_StepShape_HArray1OfValueQualifier_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepShape_HArray1OfValueQualifier self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepShape.Handle_StepShape_HArray1OfValueQualifier_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepShape_HArray1OfValueQualifier self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_HArray1OfValueQualifier_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepShape_HArray1OfValueQualifier self)

        Increments the reference counter of this object


        """
        return _StepShape.Handle_StepShape_HArray1OfValueQualifier_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepShape_HArray1OfValueQualifier self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_HArray1OfValueQualifier_DecrementRefCounter(self, *args)

Handle_StepShape_HArray1OfValueQualifier_swigregister = _StepShape.Handle_StepShape_HArray1OfValueQualifier_swigregister
Handle_StepShape_HArray1OfValueQualifier_swigregister(Handle_StepShape_HArray1OfValueQualifier)

def Handle_StepShape_HArray1OfValueQualifier_DownCast(thing):
    return _StepShape.Handle_StepShape_HArray1OfValueQualifier_DownCast(thing)
Handle_StepShape_HArray1OfValueQualifier_DownCast = _StepShape.Handle_StepShape_HArray1OfValueQualifier_DownCast

class Handle_StepShape_EdgeCurve(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepShape_EdgeCurve self)

        Nullify the handle


        """
        return _StepShape.Handle_StepShape_EdgeCurve_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepShape_EdgeCurve self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepShape.Handle_StepShape_EdgeCurve_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepShape_EdgeCurve self, StepShape_EdgeCurve thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepShape.Handle_StepShape_EdgeCurve_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepShape_EdgeCurve self, Handle_StepShape_EdgeCurve theHandle) -> Handle_StepShape_EdgeCurve
        assign(Handle_StepShape_EdgeCurve self, StepShape_EdgeCurve thePtr) -> Handle_StepShape_EdgeCurve
        assign(Handle_StepShape_EdgeCurve self, Handle_StepShape_EdgeCurve theHandle) -> Handle_StepShape_EdgeCurve

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepShape.Handle_StepShape_EdgeCurve_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepShape_EdgeCurve self) -> StepShape_EdgeCurve

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepShape.Handle_StepShape_EdgeCurve_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepShape_EdgeCurve self) -> StepShape_EdgeCurve

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepShape.Handle_StepShape_EdgeCurve___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepShape_EdgeCurve self) -> StepShape_EdgeCurve

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepShape.Handle_StepShape_EdgeCurve___ref__(self, *args)


    def __hash__(self):
        return _StepShape.Handle_StepShape_EdgeCurve___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepShape.Handle_StepShape_EdgeCurve___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepShape.new_Handle_StepShape_EdgeCurve(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepShape.Handle_StepShape_EdgeCurve_DownCast)
    __swig_destroy__ = _StepShape.delete_Handle_StepShape_EdgeCurve

    def Init(self, *args):
        """
        Init(Handle_StepShape_EdgeCurve self, Handle_TCollection_HAsciiString aName, Handle_StepShape_Vertex aEdgeStart, Handle_StepShape_Vertex aEdgeEnd, Handle_StepGeom_Curve aEdgeGeometry, Standard_Boolean const aSameSense)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aEdgeStart: OCC.wrapper.StepShape.Handle_StepShape_Vertex
        :type aEdgeEnd: OCC.wrapper.StepShape.Handle_StepShape_Vertex
        :type aEdgeGeometry: OCC.wrapper.StepShape.Handle_StepGeom_Curve
        :type aSameSense: bool

        """
        return _StepShape.Handle_StepShape_EdgeCurve_Init(self, *args)


    def SetEdgeGeometry(self, *args):
        """
        SetEdgeGeometry(Handle_StepShape_EdgeCurve self, Handle_StepGeom_Curve aEdgeGeometry)

        :type aEdgeGeometry: OCC.wrapper.StepShape.Handle_StepGeom_Curve

        """
        return _StepShape.Handle_StepShape_EdgeCurve_SetEdgeGeometry(self, *args)


    def EdgeGeometry(self, *args):
        """
        EdgeGeometry(Handle_StepShape_EdgeCurve self) -> Handle_StepGeom_Curve

        :rtype: OCC.wrapper.StepShape.Handle_StepGeom_Curve

        """
        return _StepShape.Handle_StepShape_EdgeCurve_EdgeGeometry(self, *args)


    def SetSameSense(self, *args):
        """
        SetSameSense(Handle_StepShape_EdgeCurve self, Standard_Boolean const aSameSense)

        :type aSameSense: bool

        """
        return _StepShape.Handle_StepShape_EdgeCurve_SetSameSense(self, *args)


    def SameSense(self, *args):
        """
        SameSense(Handle_StepShape_EdgeCurve self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.Handle_StepShape_EdgeCurve_SameSense(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepShape_EdgeCurve self) -> char const *

        :rtype: const char *

        """
        return _StepShape.Handle_StepShape_EdgeCurve_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.Handle_StepShape_EdgeCurve_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.Handle_StepShape_EdgeCurve_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetEdgeStart(self, *args):
        """
        SetEdgeStart(Handle_StepShape_EdgeCurve self, Handle_StepShape_Vertex aEdgeStart)

        :type aEdgeStart: OCC.wrapper.StepShape.Handle_StepShape_Vertex

        """
        return _StepShape.Handle_StepShape_EdgeCurve_SetEdgeStart(self, *args)


    def EdgeStart(self, *args):
        """
        EdgeStart(Handle_StepShape_EdgeCurve self) -> Handle_StepShape_Vertex

        :rtype: OCC.wrapper.StepShape.Handle_StepShape_Vertex

        """
        return _StepShape.Handle_StepShape_EdgeCurve_EdgeStart(self, *args)


    def SetEdgeEnd(self, *args):
        """
        SetEdgeEnd(Handle_StepShape_EdgeCurve self, Handle_StepShape_Vertex aEdgeEnd)

        :type aEdgeEnd: OCC.wrapper.StepShape.Handle_StepShape_Vertex

        """
        return _StepShape.Handle_StepShape_EdgeCurve_SetEdgeEnd(self, *args)


    def EdgeEnd(self, *args):
        """
        EdgeEnd(Handle_StepShape_EdgeCurve self) -> Handle_StepShape_Vertex

        :rtype: OCC.wrapper.StepShape.Handle_StepShape_Vertex

        """
        return _StepShape.Handle_StepShape_EdgeCurve_EdgeEnd(self, *args)


    def SetName(self, *args):
        """
        SetName(Handle_StepShape_EdgeCurve self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepShape.Handle_StepShape_EdgeCurve_SetName(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepShape_EdgeCurve self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepShape.Handle_StepShape_EdgeCurve_Name(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepShape_EdgeCurve self)

        Memory deallocator for transient classes


        """
        return _StepShape.Handle_StepShape_EdgeCurve_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepShape_EdgeCurve self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepShape_EdgeCurve self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.Handle_StepShape_EdgeCurve_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepShape_EdgeCurve self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepShape_EdgeCurve self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.Handle_StepShape_EdgeCurve_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepShape_EdgeCurve self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepShape.Handle_StepShape_EdgeCurve_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepShape_EdgeCurve self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_EdgeCurve_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepShape_EdgeCurve self)

        Increments the reference counter of this object


        """
        return _StepShape.Handle_StepShape_EdgeCurve_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepShape_EdgeCurve self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_EdgeCurve_DecrementRefCounter(self, *args)

Handle_StepShape_EdgeCurve_swigregister = _StepShape.Handle_StepShape_EdgeCurve_swigregister
Handle_StepShape_EdgeCurve_swigregister(Handle_StepShape_EdgeCurve)

def Handle_StepShape_EdgeCurve_DownCast(thing):
    return _StepShape.Handle_StepShape_EdgeCurve_DownCast(thing)
Handle_StepShape_EdgeCurve_DownCast = _StepShape.Handle_StepShape_EdgeCurve_DownCast

class NCollection_Array1_Handle_StepShape_FaceBound(object):
    """
    Purpose:     The class Array1 represents unidimensional arrays 
    of fixed size known at run time. 
    The range of the index is user defined.
    An array1 can be constructed with a "C array".
    This functionality is useful to call methods expecting
    an Array1. It allows to carry the bounds inside the arrays.

    Examples:    Item tab[100]; //  An example with a C array
    Array1OfItem ttab (tab[0],1,100);

    Array1OfItem tttab (ttab(10),10,20); // a slice of ttab

    If you want to reindex an array from 1 to Length do :

    Array1 tab1(tab(tab.Lower()),1,tab.Length());

    Warning:     Programs client of such a class must be independant
    of the range of the first element. Then, a C++ for
    loop must be written like this

    for (i = A.Lower(); i <= A.Upper(); i++)

    Changes:     In  comparison  to  TCollection  the  flag  isAllocated  was
    renamed into myDeletable (alike in  the Array2).  For naming
    compatibility the method IsAllocated remained in class along
    with IsDeletable.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Array1_Handle_StepShape_FaceBound self) -> NCollection_Array1< opencascade::handle< StepShape_FaceBound > >::iterator

        Returns an iterator pointing to the first element in the array.

        :rtype: iterator

        """
        return _StepShape.NCollection_Array1_Handle_StepShape_FaceBound_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Array1_Handle_StepShape_FaceBound self) -> NCollection_Array1< opencascade::handle< StepShape_FaceBound > >::iterator

        Returns an iterator referring to the past-the-end element in the array.

        :rtype: iterator

        """
        return _StepShape.NCollection_Array1_Handle_StepShape_FaceBound_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Array1_Handle_StepShape_FaceBound self) -> NCollection_Array1< opencascade::handle< StepShape_FaceBound > >::const_iterator

        Returns a const iterator pointing to the first element in the array.

        :rtype: const_iterator

        """
        return _StepShape.NCollection_Array1_Handle_StepShape_FaceBound_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Array1_Handle_StepShape_FaceBound self) -> NCollection_Array1< opencascade::handle< StepShape_FaceBound > >::const_iterator

        Returns a const iterator referring to the past-the-end element in the array.

        :rtype: const_iterator

        """
        return _StepShape.NCollection_Array1_Handle_StepShape_FaceBound_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     The class Array1 represents unidimensional arrays 
        of fixed size known at run time. 
        The range of the index is user defined.
        An array1 can be constructed with a "C array".
        This functionality is useful to call methods expecting
        an Array1. It allows to carry the bounds inside the arrays.

        Examples:    Item tab[100]; //  An example with a C array
        Array1OfItem ttab (tab[0],1,100);

        Array1OfItem tttab (ttab(10),10,20); // a slice of ttab

        If you want to reindex an array from 1 to Length do :

        Array1 tab1(tab(tab.Lower()),1,tab.Length());

        Warning:     Programs client of such a class must be independant
        of the range of the first element. Then, a C++ for
        loop must be written like this

        for (i = A.Lower(); i <= A.Upper(); i++)

        Changes:     In  comparison  to  TCollection  the  flag  isAllocated  was
        renamed into myDeletable (alike in  the Array2).  For naming
        compatibility the method IsAllocated remained in class along
        with IsDeletable.
        """
        this = _StepShape.new_NCollection_Array1_Handle_StepShape_FaceBound(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(NCollection_Array1_Handle_StepShape_FaceBound self, Handle_StepShape_FaceBound theValue)

        Initialise the items with theValue

        :type theValue: const TheItemType &

        """
        return _StepShape.NCollection_Array1_Handle_StepShape_FaceBound_Init(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_Array1_Handle_StepShape_FaceBound self) -> Standard_Integer

        Size query

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.NCollection_Array1_Handle_StepShape_FaceBound_Size(self, *args)


    def Length(self, *args):
        """
        Length(NCollection_Array1_Handle_StepShape_FaceBound self) -> Standard_Integer

        Length query (the same)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.NCollection_Array1_Handle_StepShape_FaceBound_Length(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Array1_Handle_StepShape_FaceBound self) -> Standard_Boolean

        Return TRUE if array has zero length.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.NCollection_Array1_Handle_StepShape_FaceBound_IsEmpty(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Array1_Handle_StepShape_FaceBound self) -> Standard_Integer

        Lower bound

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.NCollection_Array1_Handle_StepShape_FaceBound_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Array1_Handle_StepShape_FaceBound self) -> Standard_Integer

        Upper bound

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.NCollection_Array1_Handle_StepShape_FaceBound_Upper(self, *args)


    def IsDeletable(self, *args):
        """
        IsDeletable(NCollection_Array1_Handle_StepShape_FaceBound self) -> Standard_Boolean

        myDeletable flag

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.NCollection_Array1_Handle_StepShape_FaceBound_IsDeletable(self, *args)


    def IsAllocated(self, *args):
        """
        IsAllocated(NCollection_Array1_Handle_StepShape_FaceBound self) -> Standard_Boolean

        IsAllocated flag - for naming compatibility

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.NCollection_Array1_Handle_StepShape_FaceBound_IsAllocated(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Array1_Handle_StepShape_FaceBound self, NCollection_Array1_Handle_StepShape_FaceBound theOther) -> NCollection_Array1_Handle_StepShape_FaceBound

        Copies data of theOther array to this.
        This array should be pre-allocated and have the same length as theOther;
        otherwise exception Standard_DimensionMismatch is thrown.

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _StepShape.NCollection_Array1_Handle_StepShape_FaceBound_Assign(self, *args)


    def Move(self, *args):
        """
        Move(NCollection_Array1_Handle_StepShape_FaceBound self, NCollection_Array1_Handle_StepShape_FaceBound theOther) -> NCollection_Array1_Handle_StepShape_FaceBound

        Move assignment.
        This array will borrow all the data from theOther.
        The moved object will keep pointer to the memory buffer and
        range, but it will not free the buffer on destruction.

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _StepShape.NCollection_Array1_Handle_StepShape_FaceBound_Move(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Array1_Handle_StepShape_FaceBound self, NCollection_Array1_Handle_StepShape_FaceBound theOther) -> NCollection_Array1_Handle_StepShape_FaceBound
        assign(NCollection_Array1_Handle_StepShape_FaceBound self, NCollection_Array1_Handle_StepShape_FaceBound theOther) -> NCollection_Array1_Handle_StepShape_FaceBound

        Move assignment operator; @sa Move()

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1<TheItemType> &&
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _StepShape.NCollection_Array1_Handle_StepShape_FaceBound_assign(self, *args)


    def First(self, *args):
        """
        @return first element

        :rtype: const TheItemType &

        """
        res = _StepShape.NCollection_Array1_Handle_StepShape_FaceBound_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Array1_Handle_StepShape_FaceBound self) -> Handle_StepShape_FaceBound

        @return first element

        :rtype: TheItemType &

        """
        return _StepShape.NCollection_Array1_Handle_StepShape_FaceBound_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        @return last element

        :rtype: const TheItemType &

        """
        res = _StepShape.NCollection_Array1_Handle_StepShape_FaceBound_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Array1_Handle_StepShape_FaceBound self) -> Handle_StepShape_FaceBound

        @return last element

        :rtype: TheItemType &

        """
        return _StepShape.NCollection_Array1_Handle_StepShape_FaceBound_ChangeLast(self, *args)


    def Value(self, *args):
        """
        Constant value access

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _StepShape.NCollection_Array1_Handle_StepShape_FaceBound_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Array1_Handle_StepShape_FaceBound self, Standard_Integer const theIndex) -> Handle_StepShape_FaceBound

        Variable value access

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _StepShape.NCollection_Array1_Handle_StepShape_FaceBound_ChangeValue(self, *args)


    def __call__(self, *args):
        """
        operator() - alias to Value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _StepShape.NCollection_Array1_Handle_StepShape_FaceBound___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __getitem__(self, *args):
        """
        operator[] - alias to Value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _StepShape.NCollection_Array1_Handle_StepShape_FaceBound_at(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetValue(self, *args):
        """
        SetValue(NCollection_Array1_Handle_StepShape_FaceBound self, Standard_Integer const theIndex, Handle_StepShape_FaceBound theItem)

        Set value 

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _StepShape.NCollection_Array1_Handle_StepShape_FaceBound_SetValue(self, *args)


    def Resize(self, *args):
        """
        Resize(NCollection_Array1_Handle_StepShape_FaceBound self, Standard_Integer const theLower, Standard_Integer const theUpper, Standard_Boolean const theToCopyData)

        Resizes the array to specified bounds.
        No re-allocation will be done if length of array does not change,
        but existing values will not be discarded if theToCopyData set to FALSE.
        @param theLower new lower bound of array
        @param theUpper new upper bound of array
        @param theToCopyData flag to copy existing data into new array

        :type theLower: int
        :type theUpper: int
        :type theToCopyData: bool

        """
        return _StepShape.NCollection_Array1_Handle_StepShape_FaceBound_Resize(self, *args)

    __swig_destroy__ = _StepShape.delete_NCollection_Array1_Handle_StepShape_FaceBound
NCollection_Array1_Handle_StepShape_FaceBound_swigregister = _StepShape.NCollection_Array1_Handle_StepShape_FaceBound_swigregister
NCollection_Array1_Handle_StepShape_FaceBound_swigregister(NCollection_Array1_Handle_StepShape_FaceBound)


try:
	StepShape_Array1OfFaceBound = NCollection_Array1_Handle_StepShape_FaceBound
except NameError:
	pass # does not exist, probably ignored

class StepShape_BoxedHalfSpace(StepShape_HalfSpaceSolid):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepShape_BoxedHalfSpace
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepShape_BoxedHalfSpace(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepShape_BoxedHalfSpace self) -> StepShape_BoxedHalfSpace

        Returns a BoxedHalfSpace


        """
        this = _StepShape.new_StepShape_BoxedHalfSpace(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepShape_BoxedHalfSpace self, Handle_TCollection_HAsciiString aName, Handle_StepGeom_Surface aBaseSurface, Standard_Boolean const aAgreementFlag, Handle_StepShape_BoxDomain aEnclosure)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aBaseSurface: OCC.wrapper.StepShape.Handle_StepGeom_Surface
        :type aAgreementFlag: bool
        :type aEnclosure: OCC.wrapper.StepShape.Handle_StepShape_BoxDomain

        """
        return _StepShape.StepShape_BoxedHalfSpace_Init(self, *args)


    def SetEnclosure(self, *args):
        """
        SetEnclosure(StepShape_BoxedHalfSpace self, Handle_StepShape_BoxDomain aEnclosure)

        :type aEnclosure: OCC.wrapper.StepShape.Handle_StepShape_BoxDomain

        """
        return _StepShape.StepShape_BoxedHalfSpace_SetEnclosure(self, *args)


    def Enclosure(self, *args):
        """
        Enclosure(StepShape_BoxedHalfSpace self) -> Handle_StepShape_BoxDomain

        :rtype: OCC.wrapper.StepShape.Handle_StepShape_BoxDomain

        """
        return _StepShape.StepShape_BoxedHalfSpace_Enclosure(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepShape.StepShape_BoxedHalfSpace_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepShape.StepShape_BoxedHalfSpace_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.StepShape_BoxedHalfSpace_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepShape.delete_StepShape_BoxedHalfSpace
StepShape_BoxedHalfSpace_swigregister = _StepShape.StepShape_BoxedHalfSpace_swigregister
StepShape_BoxedHalfSpace_swigregister(StepShape_BoxedHalfSpace)

def StepShape_BoxedHalfSpace_get_type_name(*args):
    """
    StepShape_BoxedHalfSpace_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepShape.StepShape_BoxedHalfSpace_get_type_name(*args)

def StepShape_BoxedHalfSpace_get_type_descriptor(*args):
    """
    StepShape_BoxedHalfSpace_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepShape.StepShape_BoxedHalfSpace_get_type_descriptor(*args)

class StepShape_AdvancedBrepShapeRepresentation(StepShape_ShapeRepresentation):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepShape_AdvancedBrepShapeRepresentation
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepShape_AdvancedBrepShapeRepresentation(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepShape_AdvancedBrepShapeRepresentation self) -> StepShape_AdvancedBrepShapeRepresentation

        Returns a AdvancedBrepShapeRepresentation


        """
        this = _StepShape.new_StepShape_AdvancedBrepShapeRepresentation(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepShape.StepShape_AdvancedBrepShapeRepresentation_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepShape.StepShape_AdvancedBrepShapeRepresentation_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.StepShape_AdvancedBrepShapeRepresentation_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepShape.delete_StepShape_AdvancedBrepShapeRepresentation
StepShape_AdvancedBrepShapeRepresentation_swigregister = _StepShape.StepShape_AdvancedBrepShapeRepresentation_swigregister
StepShape_AdvancedBrepShapeRepresentation_swigregister(StepShape_AdvancedBrepShapeRepresentation)

def StepShape_AdvancedBrepShapeRepresentation_get_type_name(*args):
    """
    StepShape_AdvancedBrepShapeRepresentation_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepShape.StepShape_AdvancedBrepShapeRepresentation_get_type_name(*args)

def StepShape_AdvancedBrepShapeRepresentation_get_type_descriptor(*args):
    """
    StepShape_AdvancedBrepShapeRepresentation_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepShape.StepShape_AdvancedBrepShapeRepresentation_get_type_descriptor(*args)

class Handle_StepShape_TransitionalShapeRepresentation(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepShape_TransitionalShapeRepresentation self)

        Nullify the handle


        """
        return _StepShape.Handle_StepShape_TransitionalShapeRepresentation_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepShape_TransitionalShapeRepresentation self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepShape.Handle_StepShape_TransitionalShapeRepresentation_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepShape_TransitionalShapeRepresentation self, StepShape_TransitionalShapeRepresentation thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepShape.Handle_StepShape_TransitionalShapeRepresentation_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepShape_TransitionalShapeRepresentation self, Handle_StepShape_TransitionalShapeRepresentation theHandle) -> Handle_StepShape_TransitionalShapeRepresentation
        assign(Handle_StepShape_TransitionalShapeRepresentation self, StepShape_TransitionalShapeRepresentation thePtr) -> Handle_StepShape_TransitionalShapeRepresentation
        assign(Handle_StepShape_TransitionalShapeRepresentation self, Handle_StepShape_TransitionalShapeRepresentation theHandle) -> Handle_StepShape_TransitionalShapeRepresentation

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepShape.Handle_StepShape_TransitionalShapeRepresentation_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepShape_TransitionalShapeRepresentation self) -> StepShape_TransitionalShapeRepresentation

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepShape.Handle_StepShape_TransitionalShapeRepresentation_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepShape_TransitionalShapeRepresentation self) -> StepShape_TransitionalShapeRepresentation

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepShape.Handle_StepShape_TransitionalShapeRepresentation___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepShape_TransitionalShapeRepresentation self) -> StepShape_TransitionalShapeRepresentation

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepShape.Handle_StepShape_TransitionalShapeRepresentation___ref__(self, *args)


    def __hash__(self):
        return _StepShape.Handle_StepShape_TransitionalShapeRepresentation___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepShape.Handle_StepShape_TransitionalShapeRepresentation___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepShape.new_Handle_StepShape_TransitionalShapeRepresentation(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepShape.Handle_StepShape_TransitionalShapeRepresentation_DownCast)
    __swig_destroy__ = _StepShape.delete_Handle_StepShape_TransitionalShapeRepresentation

    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepShape_TransitionalShapeRepresentation self) -> char const *

        :rtype: const char *

        """
        return _StepShape.Handle_StepShape_TransitionalShapeRepresentation_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.Handle_StepShape_TransitionalShapeRepresentation_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.Handle_StepShape_TransitionalShapeRepresentation_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Init(self, *args):
        """
        Init(Handle_StepShape_TransitionalShapeRepresentation self, Handle_TCollection_HAsciiString aName, Handle_StepRepr_HArray1OfRepresentationItem aItems, Handle_StepRepr_RepresentationContext aContextOfItems)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aItems: OCC.wrapper.StepRepr.Handle_StepRepr_HArray1OfRepresentationItem
        :type aContextOfItems: OCC.wrapper.StepRepr.Handle_StepRepr_RepresentationContext

        """
        return _StepShape.Handle_StepShape_TransitionalShapeRepresentation_Init(self, *args)


    def SetName(self, *args):
        """
        SetName(Handle_StepShape_TransitionalShapeRepresentation self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepShape.Handle_StepShape_TransitionalShapeRepresentation_SetName(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepShape_TransitionalShapeRepresentation self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepShape.Handle_StepShape_TransitionalShapeRepresentation_Name(self, *args)


    def SetItems(self, *args):
        """
        SetItems(Handle_StepShape_TransitionalShapeRepresentation self, Handle_StepRepr_HArray1OfRepresentationItem aItems)

        :type aItems: OCC.wrapper.StepRepr.Handle_StepRepr_HArray1OfRepresentationItem

        """
        return _StepShape.Handle_StepShape_TransitionalShapeRepresentation_SetItems(self, *args)


    def Items(self, *args):
        """
        Items(Handle_StepShape_TransitionalShapeRepresentation self) -> Handle_StepRepr_HArray1OfRepresentationItem

        :rtype: OCC.wrapper.StepRepr.Handle_StepRepr_HArray1OfRepresentationItem

        """
        return _StepShape.Handle_StepShape_TransitionalShapeRepresentation_Items(self, *args)


    def ItemsValue(self, *args):
        """
        ItemsValue(Handle_StepShape_TransitionalShapeRepresentation self, Standard_Integer const num) -> Handle_StepRepr_RepresentationItem

        :type num: int
        :rtype: OCC.wrapper.StepRepr.Handle_StepRepr_RepresentationItem

        """
        return _StepShape.Handle_StepShape_TransitionalShapeRepresentation_ItemsValue(self, *args)


    def NbItems(self, *args):
        """
        NbItems(Handle_StepShape_TransitionalShapeRepresentation self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_TransitionalShapeRepresentation_NbItems(self, *args)


    def SetContextOfItems(self, *args):
        """
        SetContextOfItems(Handle_StepShape_TransitionalShapeRepresentation self, Handle_StepRepr_RepresentationContext aContextOfItems)

        :type aContextOfItems: OCC.wrapper.StepRepr.Handle_StepRepr_RepresentationContext

        """
        return _StepShape.Handle_StepShape_TransitionalShapeRepresentation_SetContextOfItems(self, *args)


    def ContextOfItems(self, *args):
        """
        ContextOfItems(Handle_StepShape_TransitionalShapeRepresentation self) -> Handle_StepRepr_RepresentationContext

        :rtype: OCC.wrapper.StepRepr.Handle_StepRepr_RepresentationContext

        """
        return _StepShape.Handle_StepShape_TransitionalShapeRepresentation_ContextOfItems(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepShape_TransitionalShapeRepresentation self)

        Memory deallocator for transient classes


        """
        return _StepShape.Handle_StepShape_TransitionalShapeRepresentation_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepShape_TransitionalShapeRepresentation self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepShape_TransitionalShapeRepresentation self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.Handle_StepShape_TransitionalShapeRepresentation_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepShape_TransitionalShapeRepresentation self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepShape_TransitionalShapeRepresentation self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.Handle_StepShape_TransitionalShapeRepresentation_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepShape_TransitionalShapeRepresentation self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepShape.Handle_StepShape_TransitionalShapeRepresentation_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepShape_TransitionalShapeRepresentation self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_TransitionalShapeRepresentation_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepShape_TransitionalShapeRepresentation self)

        Increments the reference counter of this object


        """
        return _StepShape.Handle_StepShape_TransitionalShapeRepresentation_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepShape_TransitionalShapeRepresentation self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_TransitionalShapeRepresentation_DecrementRefCounter(self, *args)

Handle_StepShape_TransitionalShapeRepresentation_swigregister = _StepShape.Handle_StepShape_TransitionalShapeRepresentation_swigregister
Handle_StepShape_TransitionalShapeRepresentation_swigregister(Handle_StepShape_TransitionalShapeRepresentation)

def Handle_StepShape_TransitionalShapeRepresentation_DownCast(thing):
    return _StepShape.Handle_StepShape_TransitionalShapeRepresentation_DownCast(thing)
Handle_StepShape_TransitionalShapeRepresentation_DownCast = _StepShape.Handle_StepShape_TransitionalShapeRepresentation_DownCast

class Handle_StepShape_ShellBasedSurfaceModel(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepShape_ShellBasedSurfaceModel self)

        Nullify the handle


        """
        return _StepShape.Handle_StepShape_ShellBasedSurfaceModel_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepShape_ShellBasedSurfaceModel self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepShape.Handle_StepShape_ShellBasedSurfaceModel_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepShape_ShellBasedSurfaceModel self, StepShape_ShellBasedSurfaceModel thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepShape.Handle_StepShape_ShellBasedSurfaceModel_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepShape_ShellBasedSurfaceModel self, Handle_StepShape_ShellBasedSurfaceModel theHandle) -> Handle_StepShape_ShellBasedSurfaceModel
        assign(Handle_StepShape_ShellBasedSurfaceModel self, StepShape_ShellBasedSurfaceModel thePtr) -> Handle_StepShape_ShellBasedSurfaceModel
        assign(Handle_StepShape_ShellBasedSurfaceModel self, Handle_StepShape_ShellBasedSurfaceModel theHandle) -> Handle_StepShape_ShellBasedSurfaceModel

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepShape.Handle_StepShape_ShellBasedSurfaceModel_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepShape_ShellBasedSurfaceModel self) -> StepShape_ShellBasedSurfaceModel

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepShape.Handle_StepShape_ShellBasedSurfaceModel_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepShape_ShellBasedSurfaceModel self) -> StepShape_ShellBasedSurfaceModel

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepShape.Handle_StepShape_ShellBasedSurfaceModel___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepShape_ShellBasedSurfaceModel self) -> StepShape_ShellBasedSurfaceModel

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepShape.Handle_StepShape_ShellBasedSurfaceModel___ref__(self, *args)


    def __hash__(self):
        return _StepShape.Handle_StepShape_ShellBasedSurfaceModel___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepShape.Handle_StepShape_ShellBasedSurfaceModel___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepShape.new_Handle_StepShape_ShellBasedSurfaceModel(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepShape.Handle_StepShape_ShellBasedSurfaceModel_DownCast)
    __swig_destroy__ = _StepShape.delete_Handle_StepShape_ShellBasedSurfaceModel

    def Init(self, *args):
        """
        Init(Handle_StepShape_ShellBasedSurfaceModel self, Handle_TCollection_HAsciiString aName, Handle_StepShape_HArray1OfShell aSbsmBoundary)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aSbsmBoundary: OCC.wrapper.StepShape.Handle_StepShape_HArray1OfShell

        """
        return _StepShape.Handle_StepShape_ShellBasedSurfaceModel_Init(self, *args)


    def SetSbsmBoundary(self, *args):
        """
        SetSbsmBoundary(Handle_StepShape_ShellBasedSurfaceModel self, Handle_StepShape_HArray1OfShell aSbsmBoundary)

        :type aSbsmBoundary: OCC.wrapper.StepShape.Handle_StepShape_HArray1OfShell

        """
        return _StepShape.Handle_StepShape_ShellBasedSurfaceModel_SetSbsmBoundary(self, *args)


    def SbsmBoundary(self, *args):
        """
        SbsmBoundary(Handle_StepShape_ShellBasedSurfaceModel self) -> Handle_StepShape_HArray1OfShell

        :rtype: OCC.wrapper.StepShape.Handle_StepShape_HArray1OfShell

        """
        return _StepShape.Handle_StepShape_ShellBasedSurfaceModel_SbsmBoundary(self, *args)


    def SbsmBoundaryValue(self, *args):
        """
        SbsmBoundaryValue(Handle_StepShape_ShellBasedSurfaceModel self, Standard_Integer const num) -> StepShape_Shell

        :type num: int
        :rtype: OCC.wrapper.StepShape.StepShape_Shell

        """
        return _StepShape.Handle_StepShape_ShellBasedSurfaceModel_SbsmBoundaryValue(self, *args)


    def NbSbsmBoundary(self, *args):
        """
        NbSbsmBoundary(Handle_StepShape_ShellBasedSurfaceModel self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_ShellBasedSurfaceModel_NbSbsmBoundary(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepShape_ShellBasedSurfaceModel self) -> char const *

        :rtype: const char *

        """
        return _StepShape.Handle_StepShape_ShellBasedSurfaceModel_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.Handle_StepShape_ShellBasedSurfaceModel_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.Handle_StepShape_ShellBasedSurfaceModel_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetName(self, *args):
        """
        SetName(Handle_StepShape_ShellBasedSurfaceModel self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepShape.Handle_StepShape_ShellBasedSurfaceModel_SetName(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepShape_ShellBasedSurfaceModel self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepShape.Handle_StepShape_ShellBasedSurfaceModel_Name(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepShape_ShellBasedSurfaceModel self)

        Memory deallocator for transient classes


        """
        return _StepShape.Handle_StepShape_ShellBasedSurfaceModel_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepShape_ShellBasedSurfaceModel self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepShape_ShellBasedSurfaceModel self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.Handle_StepShape_ShellBasedSurfaceModel_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepShape_ShellBasedSurfaceModel self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepShape_ShellBasedSurfaceModel self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.Handle_StepShape_ShellBasedSurfaceModel_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepShape_ShellBasedSurfaceModel self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepShape.Handle_StepShape_ShellBasedSurfaceModel_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepShape_ShellBasedSurfaceModel self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_ShellBasedSurfaceModel_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepShape_ShellBasedSurfaceModel self)

        Increments the reference counter of this object


        """
        return _StepShape.Handle_StepShape_ShellBasedSurfaceModel_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepShape_ShellBasedSurfaceModel self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_ShellBasedSurfaceModel_DecrementRefCounter(self, *args)

Handle_StepShape_ShellBasedSurfaceModel_swigregister = _StepShape.Handle_StepShape_ShellBasedSurfaceModel_swigregister
Handle_StepShape_ShellBasedSurfaceModel_swigregister(Handle_StepShape_ShellBasedSurfaceModel)

def Handle_StepShape_ShellBasedSurfaceModel_DownCast(thing):
    return _StepShape.Handle_StepShape_ShellBasedSurfaceModel_DownCast(thing)
Handle_StepShape_ShellBasedSurfaceModel_DownCast = _StepShape.Handle_StepShape_ShellBasedSurfaceModel_DownCast

class StepShape_LimitsAndFits(Standard.Standard_Transient):
    """Added for Dimensional Tolerances"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepShape_LimitsAndFits
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepShape_LimitsAndFits(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepShape_LimitsAndFits self) -> StepShape_LimitsAndFits

        Added for Dimensional Tolerances
        """
        this = _StepShape.new_StepShape_LimitsAndFits(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepShape_LimitsAndFits self, Handle_TCollection_HAsciiString form_variance, Handle_TCollection_HAsciiString zone_variance, Handle_TCollection_HAsciiString grade, Handle_TCollection_HAsciiString source)

        :type form_variance: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type zone_variance: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type grade: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type source: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepShape.StepShape_LimitsAndFits_Init(self, *args)


    def FormVariance(self, *args):
        """
        FormVariance(StepShape_LimitsAndFits self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepShape.StepShape_LimitsAndFits_FormVariance(self, *args)


    def SetFormVariance(self, *args):
        """
        SetFormVariance(StepShape_LimitsAndFits self, Handle_TCollection_HAsciiString form_variance)

        :type form_variance: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepShape.StepShape_LimitsAndFits_SetFormVariance(self, *args)


    def ZoneVariance(self, *args):
        """
        ZoneVariance(StepShape_LimitsAndFits self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepShape.StepShape_LimitsAndFits_ZoneVariance(self, *args)


    def SetZoneVariance(self, *args):
        """
        SetZoneVariance(StepShape_LimitsAndFits self, Handle_TCollection_HAsciiString zone_variance)

        :type zone_variance: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepShape.StepShape_LimitsAndFits_SetZoneVariance(self, *args)


    def Grade(self, *args):
        """
        Grade(StepShape_LimitsAndFits self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepShape.StepShape_LimitsAndFits_Grade(self, *args)


    def SetGrade(self, *args):
        """
        SetGrade(StepShape_LimitsAndFits self, Handle_TCollection_HAsciiString grade)

        :type grade: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepShape.StepShape_LimitsAndFits_SetGrade(self, *args)


    def Source(self, *args):
        """
        Source(StepShape_LimitsAndFits self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepShape.StepShape_LimitsAndFits_Source(self, *args)


    def SetSource(self, *args):
        """
        SetSource(StepShape_LimitsAndFits self, Handle_TCollection_HAsciiString source)

        :type source: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepShape.StepShape_LimitsAndFits_SetSource(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepShape.StepShape_LimitsAndFits_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepShape.StepShape_LimitsAndFits_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.StepShape_LimitsAndFits_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepShape.delete_StepShape_LimitsAndFits
StepShape_LimitsAndFits_swigregister = _StepShape.StepShape_LimitsAndFits_swigregister
StepShape_LimitsAndFits_swigregister(StepShape_LimitsAndFits)

def StepShape_LimitsAndFits_get_type_name(*args):
    """
    StepShape_LimitsAndFits_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepShape.StepShape_LimitsAndFits_get_type_name(*args)

def StepShape_LimitsAndFits_get_type_descriptor(*args):
    """
    StepShape_LimitsAndFits_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepShape.StepShape_LimitsAndFits_get_type_descriptor(*args)

class Handle_StepShape_RightCircularCylinder(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepShape_RightCircularCylinder self)

        Nullify the handle


        """
        return _StepShape.Handle_StepShape_RightCircularCylinder_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepShape_RightCircularCylinder self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepShape.Handle_StepShape_RightCircularCylinder_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepShape_RightCircularCylinder self, StepShape_RightCircularCylinder thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepShape.Handle_StepShape_RightCircularCylinder_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepShape_RightCircularCylinder self, Handle_StepShape_RightCircularCylinder theHandle) -> Handle_StepShape_RightCircularCylinder
        assign(Handle_StepShape_RightCircularCylinder self, StepShape_RightCircularCylinder thePtr) -> Handle_StepShape_RightCircularCylinder
        assign(Handle_StepShape_RightCircularCylinder self, Handle_StepShape_RightCircularCylinder theHandle) -> Handle_StepShape_RightCircularCylinder

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepShape.Handle_StepShape_RightCircularCylinder_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepShape_RightCircularCylinder self) -> StepShape_RightCircularCylinder

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepShape.Handle_StepShape_RightCircularCylinder_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepShape_RightCircularCylinder self) -> StepShape_RightCircularCylinder

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepShape.Handle_StepShape_RightCircularCylinder___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepShape_RightCircularCylinder self) -> StepShape_RightCircularCylinder

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepShape.Handle_StepShape_RightCircularCylinder___ref__(self, *args)


    def __hash__(self):
        return _StepShape.Handle_StepShape_RightCircularCylinder___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepShape.Handle_StepShape_RightCircularCylinder___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepShape.new_Handle_StepShape_RightCircularCylinder(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepShape.Handle_StepShape_RightCircularCylinder_DownCast)
    __swig_destroy__ = _StepShape.delete_Handle_StepShape_RightCircularCylinder

    def Init(self, *args):
        """
        Init(Handle_StepShape_RightCircularCylinder self, Handle_TCollection_HAsciiString aName, Handle_StepGeom_Axis1Placement aPosition, Standard_Real const aHeight, Standard_Real const aRadius)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aPosition: OCC.wrapper.StepShape.Handle_StepGeom_Axis1Placement
        :type aHeight: float
        :type aRadius: float

        """
        return _StepShape.Handle_StepShape_RightCircularCylinder_Init(self, *args)


    def SetPosition(self, *args):
        """
        SetPosition(Handle_StepShape_RightCircularCylinder self, Handle_StepGeom_Axis1Placement aPosition)

        :type aPosition: OCC.wrapper.StepShape.Handle_StepGeom_Axis1Placement

        """
        return _StepShape.Handle_StepShape_RightCircularCylinder_SetPosition(self, *args)


    def Position(self, *args):
        """
        Position(Handle_StepShape_RightCircularCylinder self) -> Handle_StepGeom_Axis1Placement

        :rtype: OCC.wrapper.StepShape.Handle_StepGeom_Axis1Placement

        """
        return _StepShape.Handle_StepShape_RightCircularCylinder_Position(self, *args)


    def SetHeight(self, *args):
        """
        SetHeight(Handle_StepShape_RightCircularCylinder self, Standard_Real const aHeight)

        :type aHeight: float

        """
        return _StepShape.Handle_StepShape_RightCircularCylinder_SetHeight(self, *args)


    def Height(self, *args):
        """
        Height(Handle_StepShape_RightCircularCylinder self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _StepShape.Handle_StepShape_RightCircularCylinder_Height(self, *args)


    def SetRadius(self, *args):
        """
        SetRadius(Handle_StepShape_RightCircularCylinder self, Standard_Real const aRadius)

        :type aRadius: float

        """
        return _StepShape.Handle_StepShape_RightCircularCylinder_SetRadius(self, *args)


    def Radius(self, *args):
        """
        Radius(Handle_StepShape_RightCircularCylinder self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _StepShape.Handle_StepShape_RightCircularCylinder_Radius(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepShape_RightCircularCylinder self) -> char const *

        :rtype: const char *

        """
        return _StepShape.Handle_StepShape_RightCircularCylinder_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.Handle_StepShape_RightCircularCylinder_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.Handle_StepShape_RightCircularCylinder_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetName(self, *args):
        """
        SetName(Handle_StepShape_RightCircularCylinder self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepShape.Handle_StepShape_RightCircularCylinder_SetName(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepShape_RightCircularCylinder self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepShape.Handle_StepShape_RightCircularCylinder_Name(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepShape_RightCircularCylinder self)

        Memory deallocator for transient classes


        """
        return _StepShape.Handle_StepShape_RightCircularCylinder_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepShape_RightCircularCylinder self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepShape_RightCircularCylinder self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.Handle_StepShape_RightCircularCylinder_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepShape_RightCircularCylinder self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepShape_RightCircularCylinder self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.Handle_StepShape_RightCircularCylinder_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepShape_RightCircularCylinder self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepShape.Handle_StepShape_RightCircularCylinder_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepShape_RightCircularCylinder self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_RightCircularCylinder_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepShape_RightCircularCylinder self)

        Increments the reference counter of this object


        """
        return _StepShape.Handle_StepShape_RightCircularCylinder_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepShape_RightCircularCylinder self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_RightCircularCylinder_DecrementRefCounter(self, *args)

Handle_StepShape_RightCircularCylinder_swigregister = _StepShape.Handle_StepShape_RightCircularCylinder_swigregister
Handle_StepShape_RightCircularCylinder_swigregister(Handle_StepShape_RightCircularCylinder)

def Handle_StepShape_RightCircularCylinder_DownCast(thing):
    return _StepShape.Handle_StepShape_RightCircularCylinder_DownCast(thing)
Handle_StepShape_RightCircularCylinder_DownCast = _StepShape.Handle_StepShape_RightCircularCylinder_DownCast

class StepShape_PolyLoop(StepShape_Loop):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepShape_PolyLoop
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepShape_PolyLoop(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepShape_PolyLoop self) -> StepShape_PolyLoop

        Returns a PolyLoop


        """
        this = _StepShape.new_StepShape_PolyLoop(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepShape_PolyLoop self, Handle_TCollection_HAsciiString aName, Handle_StepGeom_HArray1OfCartesianPoint aPolygon)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aPolygon: OCC.wrapper.StepShape.Handle_StepGeom_HArray1OfCartesianPoint

        """
        return _StepShape.StepShape_PolyLoop_Init(self, *args)


    def SetPolygon(self, *args):
        """
        SetPolygon(StepShape_PolyLoop self, Handle_StepGeom_HArray1OfCartesianPoint aPolygon)

        :type aPolygon: OCC.wrapper.StepShape.Handle_StepGeom_HArray1OfCartesianPoint

        """
        return _StepShape.StepShape_PolyLoop_SetPolygon(self, *args)


    def Polygon(self, *args):
        """
        Polygon(StepShape_PolyLoop self) -> Handle_StepGeom_HArray1OfCartesianPoint

        :rtype: OCC.wrapper.StepShape.Handle_StepGeom_HArray1OfCartesianPoint

        """
        return _StepShape.StepShape_PolyLoop_Polygon(self, *args)


    def PolygonValue(self, *args):
        """
        PolygonValue(StepShape_PolyLoop self, Standard_Integer const num) -> Handle_StepGeom_CartesianPoint

        :type num: int
        :rtype: OCC.wrapper.StepShape.Handle_StepGeom_CartesianPoint

        """
        return _StepShape.StepShape_PolyLoop_PolygonValue(self, *args)


    def NbPolygon(self, *args):
        """
        NbPolygon(StepShape_PolyLoop self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.StepShape_PolyLoop_NbPolygon(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepShape.StepShape_PolyLoop_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepShape.StepShape_PolyLoop_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.StepShape_PolyLoop_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepShape.delete_StepShape_PolyLoop
StepShape_PolyLoop_swigregister = _StepShape.StepShape_PolyLoop_swigregister
StepShape_PolyLoop_swigregister(StepShape_PolyLoop)

def StepShape_PolyLoop_get_type_name(*args):
    """
    StepShape_PolyLoop_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepShape.StepShape_PolyLoop_get_type_name(*args)

def StepShape_PolyLoop_get_type_descriptor(*args):
    """
    StepShape_PolyLoop_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepShape.StepShape_PolyLoop_get_type_descriptor(*args)

class StepShape_HArray1OfConnectedEdgeSet(Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepShape_HArray1OfConnectedEdgeSet
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepShape_HArray1OfConnectedEdgeSet(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepShape_HArray1OfConnectedEdgeSet self, Standard_Integer const theLower, Standard_Integer const theUpper) -> StepShape_HArray1OfConnectedEdgeSet
        __init__(StepShape_HArray1OfConnectedEdgeSet self, Standard_Integer const theLower, Standard_Integer const theUpper, Handle_StepShape_ConnectedEdgeSet theValue) -> StepShape_HArray1OfConnectedEdgeSet
        __init__(StepShape_HArray1OfConnectedEdgeSet self, NCollection_Array1_Handle_StepShape_ConnectedEdgeSet theOther) -> StepShape_HArray1OfConnectedEdgeSet

        :type theOther: OCC.wrapper.StepShape.StepShape_Array1OfConnectedEdgeSet

        """
        this = _StepShape.new_StepShape_HArray1OfConnectedEdgeSet(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Array1(self, *args):
        """
        :rtype: OCC.wrapper.StepShape.StepShape_Array1OfConnectedEdgeSet

        """
        res = _StepShape.StepShape_HArray1OfConnectedEdgeSet_Array1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeArray1(self, *args):
        """
        ChangeArray1(StepShape_HArray1OfConnectedEdgeSet self) -> NCollection_Array1_Handle_StepShape_ConnectedEdgeSet

        :rtype: OCC.wrapper.StepShape.StepShape_Array1OfConnectedEdgeSet

        """
        return _StepShape.StepShape_HArray1OfConnectedEdgeSet_ChangeArray1(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepShape.StepShape_HArray1OfConnectedEdgeSet_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepShape.StepShape_HArray1OfConnectedEdgeSet_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.StepShape_HArray1OfConnectedEdgeSet_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepShape.delete_StepShape_HArray1OfConnectedEdgeSet
StepShape_HArray1OfConnectedEdgeSet_swigregister = _StepShape.StepShape_HArray1OfConnectedEdgeSet_swigregister
StepShape_HArray1OfConnectedEdgeSet_swigregister(StepShape_HArray1OfConnectedEdgeSet)

def StepShape_HArray1OfConnectedEdgeSet_get_type_name(*args):
    """
    StepShape_HArray1OfConnectedEdgeSet_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepShape.StepShape_HArray1OfConnectedEdgeSet_get_type_name(*args)

def StepShape_HArray1OfConnectedEdgeSet_get_type_descriptor(*args):
    """
    StepShape_HArray1OfConnectedEdgeSet_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepShape.StepShape_HArray1OfConnectedEdgeSet_get_type_descriptor(*args)

class Handle_StepShape_LoopAndPath(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepShape_LoopAndPath self)

        Nullify the handle


        """
        return _StepShape.Handle_StepShape_LoopAndPath_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepShape_LoopAndPath self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepShape.Handle_StepShape_LoopAndPath_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepShape_LoopAndPath self, StepShape_LoopAndPath thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepShape.Handle_StepShape_LoopAndPath_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepShape_LoopAndPath self, Handle_StepShape_LoopAndPath theHandle) -> Handle_StepShape_LoopAndPath
        assign(Handle_StepShape_LoopAndPath self, StepShape_LoopAndPath thePtr) -> Handle_StepShape_LoopAndPath
        assign(Handle_StepShape_LoopAndPath self, Handle_StepShape_LoopAndPath theHandle) -> Handle_StepShape_LoopAndPath

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepShape.Handle_StepShape_LoopAndPath_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepShape_LoopAndPath self) -> StepShape_LoopAndPath

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepShape.Handle_StepShape_LoopAndPath_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepShape_LoopAndPath self) -> StepShape_LoopAndPath

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepShape.Handle_StepShape_LoopAndPath___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepShape_LoopAndPath self) -> StepShape_LoopAndPath

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepShape.Handle_StepShape_LoopAndPath___ref__(self, *args)


    def __hash__(self):
        return _StepShape.Handle_StepShape_LoopAndPath___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepShape.Handle_StepShape_LoopAndPath___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepShape.new_Handle_StepShape_LoopAndPath(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepShape.Handle_StepShape_LoopAndPath_DownCast)
    __swig_destroy__ = _StepShape.delete_Handle_StepShape_LoopAndPath

    def Init(self, *args):
        """
        Init(Handle_StepShape_LoopAndPath self, Handle_TCollection_HAsciiString aName, Handle_StepShape_Loop aLoop, Handle_StepShape_Path aPath)
        Init(Handle_StepShape_LoopAndPath self, Handle_TCollection_HAsciiString aName, Handle_StepShape_HArray1OfOrientedEdge aEdgeList)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aEdgeList: OCC.wrapper.StepShape.Handle_StepShape_HArray1OfOrientedEdge

        """
        return _StepShape.Handle_StepShape_LoopAndPath_Init(self, *args)


    def SetLoop(self, *args):
        """
        SetLoop(Handle_StepShape_LoopAndPath self, Handle_StepShape_Loop aLoop)

        :type aLoop: OCC.wrapper.StepShape.Handle_StepShape_Loop

        """
        return _StepShape.Handle_StepShape_LoopAndPath_SetLoop(self, *args)


    def Loop(self, *args):
        """
        Loop(Handle_StepShape_LoopAndPath self) -> Handle_StepShape_Loop

        :rtype: OCC.wrapper.StepShape.Handle_StepShape_Loop

        """
        return _StepShape.Handle_StepShape_LoopAndPath_Loop(self, *args)


    def SetPath(self, *args):
        """
        SetPath(Handle_StepShape_LoopAndPath self, Handle_StepShape_Path aPath)

        :type aPath: OCC.wrapper.StepShape.Handle_StepShape_Path

        """
        return _StepShape.Handle_StepShape_LoopAndPath_SetPath(self, *args)


    def Path(self, *args):
        """
        Path(Handle_StepShape_LoopAndPath self) -> Handle_StepShape_Path

        :rtype: OCC.wrapper.StepShape.Handle_StepShape_Path

        """
        return _StepShape.Handle_StepShape_LoopAndPath_Path(self, *args)


    def SetEdgeList(self, *args):
        """
        SetEdgeList(Handle_StepShape_LoopAndPath self, Handle_StepShape_HArray1OfOrientedEdge aEdgeList)

        :type aEdgeList: OCC.wrapper.StepShape.Handle_StepShape_HArray1OfOrientedEdge

        """
        return _StepShape.Handle_StepShape_LoopAndPath_SetEdgeList(self, *args)


    def EdgeList(self, *args):
        """
        EdgeList(Handle_StepShape_LoopAndPath self) -> Handle_StepShape_HArray1OfOrientedEdge

        :rtype: OCC.wrapper.StepShape.Handle_StepShape_HArray1OfOrientedEdge

        """
        return _StepShape.Handle_StepShape_LoopAndPath_EdgeList(self, *args)


    def EdgeListValue(self, *args):
        """
        EdgeListValue(Handle_StepShape_LoopAndPath self, Standard_Integer const num) -> Handle_StepShape_OrientedEdge

        :type num: int
        :rtype: OCC.wrapper.StepShape.Handle_StepShape_OrientedEdge

        """
        return _StepShape.Handle_StepShape_LoopAndPath_EdgeListValue(self, *args)


    def NbEdgeList(self, *args):
        """
        NbEdgeList(Handle_StepShape_LoopAndPath self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_LoopAndPath_NbEdgeList(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepShape_LoopAndPath self) -> char const *

        :rtype: const char *

        """
        return _StepShape.Handle_StepShape_LoopAndPath_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.Handle_StepShape_LoopAndPath_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.Handle_StepShape_LoopAndPath_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetName(self, *args):
        """
        SetName(Handle_StepShape_LoopAndPath self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepShape.Handle_StepShape_LoopAndPath_SetName(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepShape_LoopAndPath self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepShape.Handle_StepShape_LoopAndPath_Name(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepShape_LoopAndPath self)

        Memory deallocator for transient classes


        """
        return _StepShape.Handle_StepShape_LoopAndPath_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepShape_LoopAndPath self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepShape_LoopAndPath self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.Handle_StepShape_LoopAndPath_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepShape_LoopAndPath self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepShape_LoopAndPath self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.Handle_StepShape_LoopAndPath_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepShape_LoopAndPath self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepShape.Handle_StepShape_LoopAndPath_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepShape_LoopAndPath self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_LoopAndPath_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepShape_LoopAndPath self)

        Increments the reference counter of this object


        """
        return _StepShape.Handle_StepShape_LoopAndPath_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepShape_LoopAndPath self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_LoopAndPath_DecrementRefCounter(self, *args)

Handle_StepShape_LoopAndPath_swigregister = _StepShape.Handle_StepShape_LoopAndPath_swigregister
Handle_StepShape_LoopAndPath_swigregister(Handle_StepShape_LoopAndPath)

def Handle_StepShape_LoopAndPath_DownCast(thing):
    return _StepShape.Handle_StepShape_LoopAndPath_DownCast(thing)
Handle_StepShape_LoopAndPath_DownCast = _StepShape.Handle_StepShape_LoopAndPath_DownCast

class Handle_StepShape_BoxedHalfSpace(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepShape_BoxedHalfSpace self)

        Nullify the handle


        """
        return _StepShape.Handle_StepShape_BoxedHalfSpace_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepShape_BoxedHalfSpace self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepShape.Handle_StepShape_BoxedHalfSpace_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepShape_BoxedHalfSpace self, StepShape_BoxedHalfSpace thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepShape.Handle_StepShape_BoxedHalfSpace_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepShape_BoxedHalfSpace self, Handle_StepShape_BoxedHalfSpace theHandle) -> Handle_StepShape_BoxedHalfSpace
        assign(Handle_StepShape_BoxedHalfSpace self, StepShape_BoxedHalfSpace thePtr) -> Handle_StepShape_BoxedHalfSpace
        assign(Handle_StepShape_BoxedHalfSpace self, Handle_StepShape_BoxedHalfSpace theHandle) -> Handle_StepShape_BoxedHalfSpace

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepShape.Handle_StepShape_BoxedHalfSpace_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepShape_BoxedHalfSpace self) -> StepShape_BoxedHalfSpace

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepShape.Handle_StepShape_BoxedHalfSpace_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepShape_BoxedHalfSpace self) -> StepShape_BoxedHalfSpace

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepShape.Handle_StepShape_BoxedHalfSpace___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepShape_BoxedHalfSpace self) -> StepShape_BoxedHalfSpace

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepShape.Handle_StepShape_BoxedHalfSpace___ref__(self, *args)


    def __hash__(self):
        return _StepShape.Handle_StepShape_BoxedHalfSpace___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepShape.Handle_StepShape_BoxedHalfSpace___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepShape.new_Handle_StepShape_BoxedHalfSpace(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepShape.Handle_StepShape_BoxedHalfSpace_DownCast)
    __swig_destroy__ = _StepShape.delete_Handle_StepShape_BoxedHalfSpace

    def Init(self, *args):
        """
        Init(Handle_StepShape_BoxedHalfSpace self, Handle_TCollection_HAsciiString aName, Handle_StepGeom_Surface aBaseSurface, Standard_Boolean const aAgreementFlag, Handle_StepShape_BoxDomain aEnclosure)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aBaseSurface: OCC.wrapper.StepShape.Handle_StepGeom_Surface
        :type aAgreementFlag: bool
        :type aEnclosure: OCC.wrapper.StepShape.Handle_StepShape_BoxDomain

        """
        return _StepShape.Handle_StepShape_BoxedHalfSpace_Init(self, *args)


    def SetEnclosure(self, *args):
        """
        SetEnclosure(Handle_StepShape_BoxedHalfSpace self, Handle_StepShape_BoxDomain aEnclosure)

        :type aEnclosure: OCC.wrapper.StepShape.Handle_StepShape_BoxDomain

        """
        return _StepShape.Handle_StepShape_BoxedHalfSpace_SetEnclosure(self, *args)


    def Enclosure(self, *args):
        """
        Enclosure(Handle_StepShape_BoxedHalfSpace self) -> Handle_StepShape_BoxDomain

        :rtype: OCC.wrapper.StepShape.Handle_StepShape_BoxDomain

        """
        return _StepShape.Handle_StepShape_BoxedHalfSpace_Enclosure(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepShape_BoxedHalfSpace self) -> char const *

        :rtype: const char *

        """
        return _StepShape.Handle_StepShape_BoxedHalfSpace_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.Handle_StepShape_BoxedHalfSpace_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.Handle_StepShape_BoxedHalfSpace_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetBaseSurface(self, *args):
        """
        SetBaseSurface(Handle_StepShape_BoxedHalfSpace self, Handle_StepGeom_Surface aBaseSurface)

        :type aBaseSurface: OCC.wrapper.StepShape.Handle_StepGeom_Surface

        """
        return _StepShape.Handle_StepShape_BoxedHalfSpace_SetBaseSurface(self, *args)


    def BaseSurface(self, *args):
        """
        BaseSurface(Handle_StepShape_BoxedHalfSpace self) -> Handle_StepGeom_Surface

        :rtype: OCC.wrapper.StepShape.Handle_StepGeom_Surface

        """
        return _StepShape.Handle_StepShape_BoxedHalfSpace_BaseSurface(self, *args)


    def SetAgreementFlag(self, *args):
        """
        SetAgreementFlag(Handle_StepShape_BoxedHalfSpace self, Standard_Boolean const aAgreementFlag)

        :type aAgreementFlag: bool

        """
        return _StepShape.Handle_StepShape_BoxedHalfSpace_SetAgreementFlag(self, *args)


    def AgreementFlag(self, *args):
        """
        AgreementFlag(Handle_StepShape_BoxedHalfSpace self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.Handle_StepShape_BoxedHalfSpace_AgreementFlag(self, *args)


    def SetName(self, *args):
        """
        SetName(Handle_StepShape_BoxedHalfSpace self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepShape.Handle_StepShape_BoxedHalfSpace_SetName(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepShape_BoxedHalfSpace self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepShape.Handle_StepShape_BoxedHalfSpace_Name(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepShape_BoxedHalfSpace self)

        Memory deallocator for transient classes


        """
        return _StepShape.Handle_StepShape_BoxedHalfSpace_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepShape_BoxedHalfSpace self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepShape_BoxedHalfSpace self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.Handle_StepShape_BoxedHalfSpace_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepShape_BoxedHalfSpace self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepShape_BoxedHalfSpace self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.Handle_StepShape_BoxedHalfSpace_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepShape_BoxedHalfSpace self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepShape.Handle_StepShape_BoxedHalfSpace_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepShape_BoxedHalfSpace self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_BoxedHalfSpace_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepShape_BoxedHalfSpace self)

        Increments the reference counter of this object


        """
        return _StepShape.Handle_StepShape_BoxedHalfSpace_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepShape_BoxedHalfSpace self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_BoxedHalfSpace_DecrementRefCounter(self, *args)

Handle_StepShape_BoxedHalfSpace_swigregister = _StepShape.Handle_StepShape_BoxedHalfSpace_swigregister
Handle_StepShape_BoxedHalfSpace_swigregister(Handle_StepShape_BoxedHalfSpace)

def Handle_StepShape_BoxedHalfSpace_DownCast(thing):
    return _StepShape.Handle_StepShape_BoxedHalfSpace_DownCast(thing)
Handle_StepShape_BoxedHalfSpace_DownCast = _StepShape.Handle_StepShape_BoxedHalfSpace_DownCast

class Handle_StepShape_CsgSolid(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepShape_CsgSolid self)

        Nullify the handle


        """
        return _StepShape.Handle_StepShape_CsgSolid_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepShape_CsgSolid self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepShape.Handle_StepShape_CsgSolid_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepShape_CsgSolid self, StepShape_CsgSolid thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepShape.Handle_StepShape_CsgSolid_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepShape_CsgSolid self, Handle_StepShape_CsgSolid theHandle) -> Handle_StepShape_CsgSolid
        assign(Handle_StepShape_CsgSolid self, StepShape_CsgSolid thePtr) -> Handle_StepShape_CsgSolid
        assign(Handle_StepShape_CsgSolid self, Handle_StepShape_CsgSolid theHandle) -> Handle_StepShape_CsgSolid

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepShape.Handle_StepShape_CsgSolid_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepShape_CsgSolid self) -> StepShape_CsgSolid

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepShape.Handle_StepShape_CsgSolid_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepShape_CsgSolid self) -> StepShape_CsgSolid

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepShape.Handle_StepShape_CsgSolid___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepShape_CsgSolid self) -> StepShape_CsgSolid

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepShape.Handle_StepShape_CsgSolid___ref__(self, *args)


    def __hash__(self):
        return _StepShape.Handle_StepShape_CsgSolid___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepShape.Handle_StepShape_CsgSolid___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepShape.new_Handle_StepShape_CsgSolid(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepShape.Handle_StepShape_CsgSolid_DownCast)
    __swig_destroy__ = _StepShape.delete_Handle_StepShape_CsgSolid

    def Init(self, *args):
        """
        Init(Handle_StepShape_CsgSolid self, Handle_TCollection_HAsciiString aName, StepShape_CsgSelect aTreeRootExpression)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aTreeRootExpression: OCC.wrapper.StepShape.StepShape_CsgSelect

        """
        return _StepShape.Handle_StepShape_CsgSolid_Init(self, *args)


    def SetTreeRootExpression(self, *args):
        """
        SetTreeRootExpression(Handle_StepShape_CsgSolid self, StepShape_CsgSelect aTreeRootExpression)

        :type aTreeRootExpression: OCC.wrapper.StepShape.StepShape_CsgSelect

        """
        return _StepShape.Handle_StepShape_CsgSolid_SetTreeRootExpression(self, *args)


    def TreeRootExpression(self, *args):
        """
        TreeRootExpression(Handle_StepShape_CsgSolid self) -> StepShape_CsgSelect

        :rtype: OCC.wrapper.StepShape.StepShape_CsgSelect

        """
        return _StepShape.Handle_StepShape_CsgSolid_TreeRootExpression(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepShape_CsgSolid self) -> char const *

        :rtype: const char *

        """
        return _StepShape.Handle_StepShape_CsgSolid_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.Handle_StepShape_CsgSolid_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.Handle_StepShape_CsgSolid_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetName(self, *args):
        """
        SetName(Handle_StepShape_CsgSolid self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepShape.Handle_StepShape_CsgSolid_SetName(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepShape_CsgSolid self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepShape.Handle_StepShape_CsgSolid_Name(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepShape_CsgSolid self)

        Memory deallocator for transient classes


        """
        return _StepShape.Handle_StepShape_CsgSolid_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepShape_CsgSolid self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepShape_CsgSolid self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.Handle_StepShape_CsgSolid_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepShape_CsgSolid self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepShape_CsgSolid self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.Handle_StepShape_CsgSolid_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepShape_CsgSolid self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepShape.Handle_StepShape_CsgSolid_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepShape_CsgSolid self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_CsgSolid_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepShape_CsgSolid self)

        Increments the reference counter of this object


        """
        return _StepShape.Handle_StepShape_CsgSolid_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepShape_CsgSolid self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_CsgSolid_DecrementRefCounter(self, *args)

Handle_StepShape_CsgSolid_swigregister = _StepShape.Handle_StepShape_CsgSolid_swigregister
Handle_StepShape_CsgSolid_swigregister(Handle_StepShape_CsgSolid)

def Handle_StepShape_CsgSolid_DownCast(thing):
    return _StepShape.Handle_StepShape_CsgSolid_DownCast(thing)
Handle_StepShape_CsgSolid_DownCast = _StepShape.Handle_StepShape_CsgSolid_DownCast

class Handle_StepShape_CompoundShapeRepresentation(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepShape_CompoundShapeRepresentation self)

        Nullify the handle


        """
        return _StepShape.Handle_StepShape_CompoundShapeRepresentation_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepShape_CompoundShapeRepresentation self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepShape.Handle_StepShape_CompoundShapeRepresentation_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepShape_CompoundShapeRepresentation self, StepShape_CompoundShapeRepresentation thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepShape.Handle_StepShape_CompoundShapeRepresentation_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepShape_CompoundShapeRepresentation self, Handle_StepShape_CompoundShapeRepresentation theHandle) -> Handle_StepShape_CompoundShapeRepresentation
        assign(Handle_StepShape_CompoundShapeRepresentation self, StepShape_CompoundShapeRepresentation thePtr) -> Handle_StepShape_CompoundShapeRepresentation
        assign(Handle_StepShape_CompoundShapeRepresentation self, Handle_StepShape_CompoundShapeRepresentation theHandle) -> Handle_StepShape_CompoundShapeRepresentation

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepShape.Handle_StepShape_CompoundShapeRepresentation_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepShape_CompoundShapeRepresentation self) -> StepShape_CompoundShapeRepresentation

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepShape.Handle_StepShape_CompoundShapeRepresentation_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepShape_CompoundShapeRepresentation self) -> StepShape_CompoundShapeRepresentation

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepShape.Handle_StepShape_CompoundShapeRepresentation___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepShape_CompoundShapeRepresentation self) -> StepShape_CompoundShapeRepresentation

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepShape.Handle_StepShape_CompoundShapeRepresentation___ref__(self, *args)


    def __hash__(self):
        return _StepShape.Handle_StepShape_CompoundShapeRepresentation___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepShape.Handle_StepShape_CompoundShapeRepresentation___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepShape.new_Handle_StepShape_CompoundShapeRepresentation(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepShape.Handle_StepShape_CompoundShapeRepresentation_DownCast)
    __swig_destroy__ = _StepShape.delete_Handle_StepShape_CompoundShapeRepresentation

    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepShape_CompoundShapeRepresentation self) -> char const *

        :rtype: const char *

        """
        return _StepShape.Handle_StepShape_CompoundShapeRepresentation_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.Handle_StepShape_CompoundShapeRepresentation_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.Handle_StepShape_CompoundShapeRepresentation_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Init(self, *args):
        """
        Init(Handle_StepShape_CompoundShapeRepresentation self, Handle_TCollection_HAsciiString aName, Handle_StepRepr_HArray1OfRepresentationItem aItems, Handle_StepRepr_RepresentationContext aContextOfItems)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aItems: OCC.wrapper.StepRepr.Handle_StepRepr_HArray1OfRepresentationItem
        :type aContextOfItems: OCC.wrapper.StepRepr.Handle_StepRepr_RepresentationContext

        """
        return _StepShape.Handle_StepShape_CompoundShapeRepresentation_Init(self, *args)


    def SetName(self, *args):
        """
        SetName(Handle_StepShape_CompoundShapeRepresentation self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepShape.Handle_StepShape_CompoundShapeRepresentation_SetName(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepShape_CompoundShapeRepresentation self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepShape.Handle_StepShape_CompoundShapeRepresentation_Name(self, *args)


    def SetItems(self, *args):
        """
        SetItems(Handle_StepShape_CompoundShapeRepresentation self, Handle_StepRepr_HArray1OfRepresentationItem aItems)

        :type aItems: OCC.wrapper.StepRepr.Handle_StepRepr_HArray1OfRepresentationItem

        """
        return _StepShape.Handle_StepShape_CompoundShapeRepresentation_SetItems(self, *args)


    def Items(self, *args):
        """
        Items(Handle_StepShape_CompoundShapeRepresentation self) -> Handle_StepRepr_HArray1OfRepresentationItem

        :rtype: OCC.wrapper.StepRepr.Handle_StepRepr_HArray1OfRepresentationItem

        """
        return _StepShape.Handle_StepShape_CompoundShapeRepresentation_Items(self, *args)


    def ItemsValue(self, *args):
        """
        ItemsValue(Handle_StepShape_CompoundShapeRepresentation self, Standard_Integer const num) -> Handle_StepRepr_RepresentationItem

        :type num: int
        :rtype: OCC.wrapper.StepRepr.Handle_StepRepr_RepresentationItem

        """
        return _StepShape.Handle_StepShape_CompoundShapeRepresentation_ItemsValue(self, *args)


    def NbItems(self, *args):
        """
        NbItems(Handle_StepShape_CompoundShapeRepresentation self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_CompoundShapeRepresentation_NbItems(self, *args)


    def SetContextOfItems(self, *args):
        """
        SetContextOfItems(Handle_StepShape_CompoundShapeRepresentation self, Handle_StepRepr_RepresentationContext aContextOfItems)

        :type aContextOfItems: OCC.wrapper.StepRepr.Handle_StepRepr_RepresentationContext

        """
        return _StepShape.Handle_StepShape_CompoundShapeRepresentation_SetContextOfItems(self, *args)


    def ContextOfItems(self, *args):
        """
        ContextOfItems(Handle_StepShape_CompoundShapeRepresentation self) -> Handle_StepRepr_RepresentationContext

        :rtype: OCC.wrapper.StepRepr.Handle_StepRepr_RepresentationContext

        """
        return _StepShape.Handle_StepShape_CompoundShapeRepresentation_ContextOfItems(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepShape_CompoundShapeRepresentation self)

        Memory deallocator for transient classes


        """
        return _StepShape.Handle_StepShape_CompoundShapeRepresentation_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepShape_CompoundShapeRepresentation self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepShape_CompoundShapeRepresentation self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.Handle_StepShape_CompoundShapeRepresentation_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepShape_CompoundShapeRepresentation self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepShape_CompoundShapeRepresentation self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.Handle_StepShape_CompoundShapeRepresentation_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepShape_CompoundShapeRepresentation self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepShape.Handle_StepShape_CompoundShapeRepresentation_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepShape_CompoundShapeRepresentation self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_CompoundShapeRepresentation_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepShape_CompoundShapeRepresentation self)

        Increments the reference counter of this object


        """
        return _StepShape.Handle_StepShape_CompoundShapeRepresentation_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepShape_CompoundShapeRepresentation self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_CompoundShapeRepresentation_DecrementRefCounter(self, *args)

Handle_StepShape_CompoundShapeRepresentation_swigregister = _StepShape.Handle_StepShape_CompoundShapeRepresentation_swigregister
Handle_StepShape_CompoundShapeRepresentation_swigregister(Handle_StepShape_CompoundShapeRepresentation)

def Handle_StepShape_CompoundShapeRepresentation_DownCast(thing):
    return _StepShape.Handle_StepShape_CompoundShapeRepresentation_DownCast(thing)
Handle_StepShape_CompoundShapeRepresentation_DownCast = _StepShape.Handle_StepShape_CompoundShapeRepresentation_DownCast

class Handle_StepShape_HArray1OfOrientedEdge(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepShape_HArray1OfOrientedEdge self)

        Nullify the handle


        """
        return _StepShape.Handle_StepShape_HArray1OfOrientedEdge_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepShape_HArray1OfOrientedEdge self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepShape.Handle_StepShape_HArray1OfOrientedEdge_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepShape_HArray1OfOrientedEdge self, StepShape_HArray1OfOrientedEdge thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepShape.Handle_StepShape_HArray1OfOrientedEdge_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepShape_HArray1OfOrientedEdge self, Handle_StepShape_HArray1OfOrientedEdge theHandle) -> Handle_StepShape_HArray1OfOrientedEdge
        assign(Handle_StepShape_HArray1OfOrientedEdge self, StepShape_HArray1OfOrientedEdge thePtr) -> Handle_StepShape_HArray1OfOrientedEdge
        assign(Handle_StepShape_HArray1OfOrientedEdge self, Handle_StepShape_HArray1OfOrientedEdge theHandle) -> Handle_StepShape_HArray1OfOrientedEdge

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepShape.Handle_StepShape_HArray1OfOrientedEdge_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepShape_HArray1OfOrientedEdge self) -> StepShape_HArray1OfOrientedEdge

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepShape.Handle_StepShape_HArray1OfOrientedEdge_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepShape_HArray1OfOrientedEdge self) -> StepShape_HArray1OfOrientedEdge

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepShape.Handle_StepShape_HArray1OfOrientedEdge___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepShape_HArray1OfOrientedEdge self) -> StepShape_HArray1OfOrientedEdge

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepShape.Handle_StepShape_HArray1OfOrientedEdge___ref__(self, *args)


    def __hash__(self):
        return _StepShape.Handle_StepShape_HArray1OfOrientedEdge___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepShape.Handle_StepShape_HArray1OfOrientedEdge___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepShape.new_Handle_StepShape_HArray1OfOrientedEdge(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepShape.Handle_StepShape_HArray1OfOrientedEdge_DownCast)
    __swig_destroy__ = _StepShape.delete_Handle_StepShape_HArray1OfOrientedEdge

    def Array1(self, *args):
        """
        :rtype: OCC.wrapper.StepShape.StepShape_Array1OfOrientedEdge

        """
        res = _StepShape.Handle_StepShape_HArray1OfOrientedEdge_Array1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeArray1(self, *args):
        """
        ChangeArray1(Handle_StepShape_HArray1OfOrientedEdge self) -> NCollection_Array1_Handle_StepShape_OrientedEdge

        :rtype: OCC.wrapper.StepShape.StepShape_Array1OfOrientedEdge

        """
        return _StepShape.Handle_StepShape_HArray1OfOrientedEdge_ChangeArray1(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepShape_HArray1OfOrientedEdge self) -> char const *

        :rtype: const char *

        """
        return _StepShape.Handle_StepShape_HArray1OfOrientedEdge_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.Handle_StepShape_HArray1OfOrientedEdge_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.Handle_StepShape_HArray1OfOrientedEdge_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_StepShape_HArray1OfOrientedEdge self)

        Memory deallocator for transient classes


        """
        return _StepShape.Handle_StepShape_HArray1OfOrientedEdge_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepShape_HArray1OfOrientedEdge self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepShape_HArray1OfOrientedEdge self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.Handle_StepShape_HArray1OfOrientedEdge_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepShape_HArray1OfOrientedEdge self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepShape_HArray1OfOrientedEdge self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.Handle_StepShape_HArray1OfOrientedEdge_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepShape_HArray1OfOrientedEdge self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepShape.Handle_StepShape_HArray1OfOrientedEdge_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepShape_HArray1OfOrientedEdge self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_HArray1OfOrientedEdge_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepShape_HArray1OfOrientedEdge self)

        Increments the reference counter of this object


        """
        return _StepShape.Handle_StepShape_HArray1OfOrientedEdge_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepShape_HArray1OfOrientedEdge self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_HArray1OfOrientedEdge_DecrementRefCounter(self, *args)

Handle_StepShape_HArray1OfOrientedEdge_swigregister = _StepShape.Handle_StepShape_HArray1OfOrientedEdge_swigregister
Handle_StepShape_HArray1OfOrientedEdge_swigregister(Handle_StepShape_HArray1OfOrientedEdge)

def Handle_StepShape_HArray1OfOrientedEdge_DownCast(thing):
    return _StepShape.Handle_StepShape_HArray1OfOrientedEdge_DownCast(thing)
Handle_StepShape_HArray1OfOrientedEdge_DownCast = _StepShape.Handle_StepShape_HArray1OfOrientedEdge_DownCast

class NCollection_Array1_Handle_StepShape_ConnectedEdgeSet(object):
    """
    Purpose:     The class Array1 represents unidimensional arrays 
    of fixed size known at run time. 
    The range of the index is user defined.
    An array1 can be constructed with a "C array".
    This functionality is useful to call methods expecting
    an Array1. It allows to carry the bounds inside the arrays.

    Examples:    Item tab[100]; //  An example with a C array
    Array1OfItem ttab (tab[0],1,100);

    Array1OfItem tttab (ttab(10),10,20); // a slice of ttab

    If you want to reindex an array from 1 to Length do :

    Array1 tab1(tab(tab.Lower()),1,tab.Length());

    Warning:     Programs client of such a class must be independant
    of the range of the first element. Then, a C++ for
    loop must be written like this

    for (i = A.Lower(); i <= A.Upper(); i++)

    Changes:     In  comparison  to  TCollection  the  flag  isAllocated  was
    renamed into myDeletable (alike in  the Array2).  For naming
    compatibility the method IsAllocated remained in class along
    with IsDeletable.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Array1_Handle_StepShape_ConnectedEdgeSet self) -> NCollection_Array1< opencascade::handle< StepShape_ConnectedEdgeSet > >::iterator

        Returns an iterator pointing to the first element in the array.

        :rtype: iterator

        """
        return _StepShape.NCollection_Array1_Handle_StepShape_ConnectedEdgeSet_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Array1_Handle_StepShape_ConnectedEdgeSet self) -> NCollection_Array1< opencascade::handle< StepShape_ConnectedEdgeSet > >::iterator

        Returns an iterator referring to the past-the-end element in the array.

        :rtype: iterator

        """
        return _StepShape.NCollection_Array1_Handle_StepShape_ConnectedEdgeSet_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Array1_Handle_StepShape_ConnectedEdgeSet self) -> NCollection_Array1< opencascade::handle< StepShape_ConnectedEdgeSet > >::const_iterator

        Returns a const iterator pointing to the first element in the array.

        :rtype: const_iterator

        """
        return _StepShape.NCollection_Array1_Handle_StepShape_ConnectedEdgeSet_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Array1_Handle_StepShape_ConnectedEdgeSet self) -> NCollection_Array1< opencascade::handle< StepShape_ConnectedEdgeSet > >::const_iterator

        Returns a const iterator referring to the past-the-end element in the array.

        :rtype: const_iterator

        """
        return _StepShape.NCollection_Array1_Handle_StepShape_ConnectedEdgeSet_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     The class Array1 represents unidimensional arrays 
        of fixed size known at run time. 
        The range of the index is user defined.
        An array1 can be constructed with a "C array".
        This functionality is useful to call methods expecting
        an Array1. It allows to carry the bounds inside the arrays.

        Examples:    Item tab[100]; //  An example with a C array
        Array1OfItem ttab (tab[0],1,100);

        Array1OfItem tttab (ttab(10),10,20); // a slice of ttab

        If you want to reindex an array from 1 to Length do :

        Array1 tab1(tab(tab.Lower()),1,tab.Length());

        Warning:     Programs client of such a class must be independant
        of the range of the first element. Then, a C++ for
        loop must be written like this

        for (i = A.Lower(); i <= A.Upper(); i++)

        Changes:     In  comparison  to  TCollection  the  flag  isAllocated  was
        renamed into myDeletable (alike in  the Array2).  For naming
        compatibility the method IsAllocated remained in class along
        with IsDeletable.
        """
        this = _StepShape.new_NCollection_Array1_Handle_StepShape_ConnectedEdgeSet(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(NCollection_Array1_Handle_StepShape_ConnectedEdgeSet self, Handle_StepShape_ConnectedEdgeSet theValue)

        Initialise the items with theValue

        :type theValue: const TheItemType &

        """
        return _StepShape.NCollection_Array1_Handle_StepShape_ConnectedEdgeSet_Init(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_Array1_Handle_StepShape_ConnectedEdgeSet self) -> Standard_Integer

        Size query

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.NCollection_Array1_Handle_StepShape_ConnectedEdgeSet_Size(self, *args)


    def Length(self, *args):
        """
        Length(NCollection_Array1_Handle_StepShape_ConnectedEdgeSet self) -> Standard_Integer

        Length query (the same)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.NCollection_Array1_Handle_StepShape_ConnectedEdgeSet_Length(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Array1_Handle_StepShape_ConnectedEdgeSet self) -> Standard_Boolean

        Return TRUE if array has zero length.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.NCollection_Array1_Handle_StepShape_ConnectedEdgeSet_IsEmpty(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Array1_Handle_StepShape_ConnectedEdgeSet self) -> Standard_Integer

        Lower bound

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.NCollection_Array1_Handle_StepShape_ConnectedEdgeSet_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Array1_Handle_StepShape_ConnectedEdgeSet self) -> Standard_Integer

        Upper bound

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.NCollection_Array1_Handle_StepShape_ConnectedEdgeSet_Upper(self, *args)


    def IsDeletable(self, *args):
        """
        IsDeletable(NCollection_Array1_Handle_StepShape_ConnectedEdgeSet self) -> Standard_Boolean

        myDeletable flag

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.NCollection_Array1_Handle_StepShape_ConnectedEdgeSet_IsDeletable(self, *args)


    def IsAllocated(self, *args):
        """
        IsAllocated(NCollection_Array1_Handle_StepShape_ConnectedEdgeSet self) -> Standard_Boolean

        IsAllocated flag - for naming compatibility

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.NCollection_Array1_Handle_StepShape_ConnectedEdgeSet_IsAllocated(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Array1_Handle_StepShape_ConnectedEdgeSet self, NCollection_Array1_Handle_StepShape_ConnectedEdgeSet theOther) -> NCollection_Array1_Handle_StepShape_ConnectedEdgeSet

        Copies data of theOther array to this.
        This array should be pre-allocated and have the same length as theOther;
        otherwise exception Standard_DimensionMismatch is thrown.

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _StepShape.NCollection_Array1_Handle_StepShape_ConnectedEdgeSet_Assign(self, *args)


    def Move(self, *args):
        """
        Move(NCollection_Array1_Handle_StepShape_ConnectedEdgeSet self, NCollection_Array1_Handle_StepShape_ConnectedEdgeSet theOther) -> NCollection_Array1_Handle_StepShape_ConnectedEdgeSet

        Move assignment.
        This array will borrow all the data from theOther.
        The moved object will keep pointer to the memory buffer and
        range, but it will not free the buffer on destruction.

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _StepShape.NCollection_Array1_Handle_StepShape_ConnectedEdgeSet_Move(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Array1_Handle_StepShape_ConnectedEdgeSet self, NCollection_Array1_Handle_StepShape_ConnectedEdgeSet theOther) -> NCollection_Array1_Handle_StepShape_ConnectedEdgeSet
        assign(NCollection_Array1_Handle_StepShape_ConnectedEdgeSet self, NCollection_Array1_Handle_StepShape_ConnectedEdgeSet theOther) -> NCollection_Array1_Handle_StepShape_ConnectedEdgeSet

        Move assignment operator; @sa Move()

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1<TheItemType> &&
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _StepShape.NCollection_Array1_Handle_StepShape_ConnectedEdgeSet_assign(self, *args)


    def First(self, *args):
        """
        @return first element

        :rtype: const TheItemType &

        """
        res = _StepShape.NCollection_Array1_Handle_StepShape_ConnectedEdgeSet_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Array1_Handle_StepShape_ConnectedEdgeSet self) -> Handle_StepShape_ConnectedEdgeSet

        @return first element

        :rtype: TheItemType &

        """
        return _StepShape.NCollection_Array1_Handle_StepShape_ConnectedEdgeSet_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        @return last element

        :rtype: const TheItemType &

        """
        res = _StepShape.NCollection_Array1_Handle_StepShape_ConnectedEdgeSet_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Array1_Handle_StepShape_ConnectedEdgeSet self) -> Handle_StepShape_ConnectedEdgeSet

        @return last element

        :rtype: TheItemType &

        """
        return _StepShape.NCollection_Array1_Handle_StepShape_ConnectedEdgeSet_ChangeLast(self, *args)


    def Value(self, *args):
        """
        Constant value access

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _StepShape.NCollection_Array1_Handle_StepShape_ConnectedEdgeSet_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Array1_Handle_StepShape_ConnectedEdgeSet self, Standard_Integer const theIndex) -> Handle_StepShape_ConnectedEdgeSet

        Variable value access

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _StepShape.NCollection_Array1_Handle_StepShape_ConnectedEdgeSet_ChangeValue(self, *args)


    def __call__(self, *args):
        """
        operator() - alias to Value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _StepShape.NCollection_Array1_Handle_StepShape_ConnectedEdgeSet___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __getitem__(self, *args):
        """
        operator[] - alias to Value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _StepShape.NCollection_Array1_Handle_StepShape_ConnectedEdgeSet_at(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetValue(self, *args):
        """
        SetValue(NCollection_Array1_Handle_StepShape_ConnectedEdgeSet self, Standard_Integer const theIndex, Handle_StepShape_ConnectedEdgeSet theItem)

        Set value 

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _StepShape.NCollection_Array1_Handle_StepShape_ConnectedEdgeSet_SetValue(self, *args)


    def Resize(self, *args):
        """
        Resize(NCollection_Array1_Handle_StepShape_ConnectedEdgeSet self, Standard_Integer const theLower, Standard_Integer const theUpper, Standard_Boolean const theToCopyData)

        Resizes the array to specified bounds.
        No re-allocation will be done if length of array does not change,
        but existing values will not be discarded if theToCopyData set to FALSE.
        @param theLower new lower bound of array
        @param theUpper new upper bound of array
        @param theToCopyData flag to copy existing data into new array

        :type theLower: int
        :type theUpper: int
        :type theToCopyData: bool

        """
        return _StepShape.NCollection_Array1_Handle_StepShape_ConnectedEdgeSet_Resize(self, *args)

    __swig_destroy__ = _StepShape.delete_NCollection_Array1_Handle_StepShape_ConnectedEdgeSet
NCollection_Array1_Handle_StepShape_ConnectedEdgeSet_swigregister = _StepShape.NCollection_Array1_Handle_StepShape_ConnectedEdgeSet_swigregister
NCollection_Array1_Handle_StepShape_ConnectedEdgeSet_swigregister(NCollection_Array1_Handle_StepShape_ConnectedEdgeSet)


try:
	StepShape_Array1OfConnectedEdgeSet = NCollection_Array1_Handle_StepShape_ConnectedEdgeSet
except NameError:
	pass # does not exist, probably ignored

class Handle_StepShape_SolidReplica(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepShape_SolidReplica self)

        Nullify the handle


        """
        return _StepShape.Handle_StepShape_SolidReplica_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepShape_SolidReplica self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepShape.Handle_StepShape_SolidReplica_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepShape_SolidReplica self, StepShape_SolidReplica thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepShape.Handle_StepShape_SolidReplica_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepShape_SolidReplica self, Handle_StepShape_SolidReplica theHandle) -> Handle_StepShape_SolidReplica
        assign(Handle_StepShape_SolidReplica self, StepShape_SolidReplica thePtr) -> Handle_StepShape_SolidReplica
        assign(Handle_StepShape_SolidReplica self, Handle_StepShape_SolidReplica theHandle) -> Handle_StepShape_SolidReplica

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepShape.Handle_StepShape_SolidReplica_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepShape_SolidReplica self) -> StepShape_SolidReplica

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepShape.Handle_StepShape_SolidReplica_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepShape_SolidReplica self) -> StepShape_SolidReplica

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepShape.Handle_StepShape_SolidReplica___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepShape_SolidReplica self) -> StepShape_SolidReplica

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepShape.Handle_StepShape_SolidReplica___ref__(self, *args)


    def __hash__(self):
        return _StepShape.Handle_StepShape_SolidReplica___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepShape.Handle_StepShape_SolidReplica___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepShape.new_Handle_StepShape_SolidReplica(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepShape.Handle_StepShape_SolidReplica_DownCast)
    __swig_destroy__ = _StepShape.delete_Handle_StepShape_SolidReplica

    def Init(self, *args):
        """
        Init(Handle_StepShape_SolidReplica self, Handle_TCollection_HAsciiString aName, Handle_StepShape_SolidModel aParentSolid, Handle_StepGeom_CartesianTransformationOperator3d aTransformation)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aParentSolid: OCC.wrapper.StepShape.Handle_StepShape_SolidModel
        :type aTransformation: OCC.wrapper.StepShape.Handle_StepGeom_CartesianTransformationOperator3d

        """
        return _StepShape.Handle_StepShape_SolidReplica_Init(self, *args)


    def SetParentSolid(self, *args):
        """
        SetParentSolid(Handle_StepShape_SolidReplica self, Handle_StepShape_SolidModel aParentSolid)

        :type aParentSolid: OCC.wrapper.StepShape.Handle_StepShape_SolidModel

        """
        return _StepShape.Handle_StepShape_SolidReplica_SetParentSolid(self, *args)


    def ParentSolid(self, *args):
        """
        ParentSolid(Handle_StepShape_SolidReplica self) -> Handle_StepShape_SolidModel

        :rtype: OCC.wrapper.StepShape.Handle_StepShape_SolidModel

        """
        return _StepShape.Handle_StepShape_SolidReplica_ParentSolid(self, *args)


    def SetTransformation(self, *args):
        """
        SetTransformation(Handle_StepShape_SolidReplica self, Handle_StepGeom_CartesianTransformationOperator3d aTransformation)

        :type aTransformation: OCC.wrapper.StepShape.Handle_StepGeom_CartesianTransformationOperator3d

        """
        return _StepShape.Handle_StepShape_SolidReplica_SetTransformation(self, *args)


    def Transformation(self, *args):
        """
        Transformation(Handle_StepShape_SolidReplica self) -> Handle_StepGeom_CartesianTransformationOperator3d

        :rtype: OCC.wrapper.StepShape.Handle_StepGeom_CartesianTransformationOperator3d

        """
        return _StepShape.Handle_StepShape_SolidReplica_Transformation(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepShape_SolidReplica self) -> char const *

        :rtype: const char *

        """
        return _StepShape.Handle_StepShape_SolidReplica_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.Handle_StepShape_SolidReplica_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.Handle_StepShape_SolidReplica_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetName(self, *args):
        """
        SetName(Handle_StepShape_SolidReplica self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepShape.Handle_StepShape_SolidReplica_SetName(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepShape_SolidReplica self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepShape.Handle_StepShape_SolidReplica_Name(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepShape_SolidReplica self)

        Memory deallocator for transient classes


        """
        return _StepShape.Handle_StepShape_SolidReplica_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepShape_SolidReplica self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepShape_SolidReplica self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.Handle_StepShape_SolidReplica_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepShape_SolidReplica self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepShape_SolidReplica self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.Handle_StepShape_SolidReplica_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepShape_SolidReplica self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepShape.Handle_StepShape_SolidReplica_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepShape_SolidReplica self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_SolidReplica_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepShape_SolidReplica self)

        Increments the reference counter of this object


        """
        return _StepShape.Handle_StepShape_SolidReplica_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepShape_SolidReplica self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_SolidReplica_DecrementRefCounter(self, *args)

Handle_StepShape_SolidReplica_swigregister = _StepShape.Handle_StepShape_SolidReplica_swigregister
Handle_StepShape_SolidReplica_swigregister(Handle_StepShape_SolidReplica)

def Handle_StepShape_SolidReplica_DownCast(thing):
    return _StepShape.Handle_StepShape_SolidReplica_DownCast(thing)
Handle_StepShape_SolidReplica_DownCast = _StepShape.Handle_StepShape_SolidReplica_DownCast

class Handle_StepShape_ShapeDimensionRepresentation(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepShape_ShapeDimensionRepresentation self)

        Nullify the handle


        """
        return _StepShape.Handle_StepShape_ShapeDimensionRepresentation_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepShape_ShapeDimensionRepresentation self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepShape.Handle_StepShape_ShapeDimensionRepresentation_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepShape_ShapeDimensionRepresentation self, StepShape_ShapeDimensionRepresentation thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepShape.Handle_StepShape_ShapeDimensionRepresentation_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepShape_ShapeDimensionRepresentation self, Handle_StepShape_ShapeDimensionRepresentation theHandle) -> Handle_StepShape_ShapeDimensionRepresentation
        assign(Handle_StepShape_ShapeDimensionRepresentation self, StepShape_ShapeDimensionRepresentation thePtr) -> Handle_StepShape_ShapeDimensionRepresentation
        assign(Handle_StepShape_ShapeDimensionRepresentation self, Handle_StepShape_ShapeDimensionRepresentation theHandle) -> Handle_StepShape_ShapeDimensionRepresentation

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepShape.Handle_StepShape_ShapeDimensionRepresentation_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepShape_ShapeDimensionRepresentation self) -> StepShape_ShapeDimensionRepresentation

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepShape.Handle_StepShape_ShapeDimensionRepresentation_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepShape_ShapeDimensionRepresentation self) -> StepShape_ShapeDimensionRepresentation

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepShape.Handle_StepShape_ShapeDimensionRepresentation___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepShape_ShapeDimensionRepresentation self) -> StepShape_ShapeDimensionRepresentation

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepShape.Handle_StepShape_ShapeDimensionRepresentation___ref__(self, *args)


    def __hash__(self):
        return _StepShape.Handle_StepShape_ShapeDimensionRepresentation___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepShape.Handle_StepShape_ShapeDimensionRepresentation___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepShape.new_Handle_StepShape_ShapeDimensionRepresentation(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepShape.Handle_StepShape_ShapeDimensionRepresentation_DownCast)
    __swig_destroy__ = _StepShape.delete_Handle_StepShape_ShapeDimensionRepresentation

    def Init(self, *args):
        """
        Init(Handle_StepShape_ShapeDimensionRepresentation self, Handle_TCollection_HAsciiString theName, Handle_StepRepr_HArray1OfRepresentationItem theItems, Handle_StepRepr_RepresentationContext theContextOfItems)
        Init(Handle_StepShape_ShapeDimensionRepresentation self, Handle_TCollection_HAsciiString theName, Handle_StepShape_HArray1OfShapeDimensionRepresentationItem theItems, Handle_StepRepr_RepresentationContext theContextOfItems)

        Initialize all fields AP242

        :type theName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type theItems: OCC.wrapper.StepShape.Handle_StepShape_HArray1OfShapeDimensionRepresentationItem
        :type theContextOfItems: OCC.wrapper.StepRepr.Handle_StepRepr_RepresentationContext

        """
        return _StepShape.Handle_StepShape_ShapeDimensionRepresentation_Init(self, *args)


    def SetItemsAP242(self, *args):
        """
        SetItemsAP242(Handle_StepShape_ShapeDimensionRepresentation self, Handle_StepShape_HArray1OfShapeDimensionRepresentationItem theItems)

        :type theItems: OCC.wrapper.StepShape.Handle_StepShape_HArray1OfShapeDimensionRepresentationItem

        """
        return _StepShape.Handle_StepShape_ShapeDimensionRepresentation_SetItemsAP242(self, *args)


    def ItemsAP242(self, *args):
        """
        ItemsAP242(Handle_StepShape_ShapeDimensionRepresentation self) -> Handle_StepShape_HArray1OfShapeDimensionRepresentationItem

        :rtype: OCC.wrapper.StepShape.Handle_StepShape_HArray1OfShapeDimensionRepresentationItem

        """
        return _StepShape.Handle_StepShape_ShapeDimensionRepresentation_ItemsAP242(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepShape_ShapeDimensionRepresentation self) -> char const *

        :rtype: const char *

        """
        return _StepShape.Handle_StepShape_ShapeDimensionRepresentation_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.Handle_StepShape_ShapeDimensionRepresentation_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.Handle_StepShape_ShapeDimensionRepresentation_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetName(self, *args):
        """
        SetName(Handle_StepShape_ShapeDimensionRepresentation self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepShape.Handle_StepShape_ShapeDimensionRepresentation_SetName(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepShape_ShapeDimensionRepresentation self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepShape.Handle_StepShape_ShapeDimensionRepresentation_Name(self, *args)


    def SetItems(self, *args):
        """
        SetItems(Handle_StepShape_ShapeDimensionRepresentation self, Handle_StepRepr_HArray1OfRepresentationItem aItems)

        :type aItems: OCC.wrapper.StepRepr.Handle_StepRepr_HArray1OfRepresentationItem

        """
        return _StepShape.Handle_StepShape_ShapeDimensionRepresentation_SetItems(self, *args)


    def Items(self, *args):
        """
        Items(Handle_StepShape_ShapeDimensionRepresentation self) -> Handle_StepRepr_HArray1OfRepresentationItem

        :rtype: OCC.wrapper.StepRepr.Handle_StepRepr_HArray1OfRepresentationItem

        """
        return _StepShape.Handle_StepShape_ShapeDimensionRepresentation_Items(self, *args)


    def ItemsValue(self, *args):
        """
        ItemsValue(Handle_StepShape_ShapeDimensionRepresentation self, Standard_Integer const num) -> Handle_StepRepr_RepresentationItem

        :type num: int
        :rtype: OCC.wrapper.StepRepr.Handle_StepRepr_RepresentationItem

        """
        return _StepShape.Handle_StepShape_ShapeDimensionRepresentation_ItemsValue(self, *args)


    def NbItems(self, *args):
        """
        NbItems(Handle_StepShape_ShapeDimensionRepresentation self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_ShapeDimensionRepresentation_NbItems(self, *args)


    def SetContextOfItems(self, *args):
        """
        SetContextOfItems(Handle_StepShape_ShapeDimensionRepresentation self, Handle_StepRepr_RepresentationContext aContextOfItems)

        :type aContextOfItems: OCC.wrapper.StepRepr.Handle_StepRepr_RepresentationContext

        """
        return _StepShape.Handle_StepShape_ShapeDimensionRepresentation_SetContextOfItems(self, *args)


    def ContextOfItems(self, *args):
        """
        ContextOfItems(Handle_StepShape_ShapeDimensionRepresentation self) -> Handle_StepRepr_RepresentationContext

        :rtype: OCC.wrapper.StepRepr.Handle_StepRepr_RepresentationContext

        """
        return _StepShape.Handle_StepShape_ShapeDimensionRepresentation_ContextOfItems(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepShape_ShapeDimensionRepresentation self)

        Memory deallocator for transient classes


        """
        return _StepShape.Handle_StepShape_ShapeDimensionRepresentation_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepShape_ShapeDimensionRepresentation self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepShape_ShapeDimensionRepresentation self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.Handle_StepShape_ShapeDimensionRepresentation_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepShape_ShapeDimensionRepresentation self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepShape_ShapeDimensionRepresentation self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.Handle_StepShape_ShapeDimensionRepresentation_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepShape_ShapeDimensionRepresentation self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepShape.Handle_StepShape_ShapeDimensionRepresentation_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepShape_ShapeDimensionRepresentation self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_ShapeDimensionRepresentation_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepShape_ShapeDimensionRepresentation self)

        Increments the reference counter of this object


        """
        return _StepShape.Handle_StepShape_ShapeDimensionRepresentation_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepShape_ShapeDimensionRepresentation self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_ShapeDimensionRepresentation_DecrementRefCounter(self, *args)

Handle_StepShape_ShapeDimensionRepresentation_swigregister = _StepShape.Handle_StepShape_ShapeDimensionRepresentation_swigregister
Handle_StepShape_ShapeDimensionRepresentation_swigregister(Handle_StepShape_ShapeDimensionRepresentation)

def Handle_StepShape_ShapeDimensionRepresentation_DownCast(thing):
    return _StepShape.Handle_StepShape_ShapeDimensionRepresentation_DownCast(thing)
Handle_StepShape_ShapeDimensionRepresentation_DownCast = _StepShape.Handle_StepShape_ShapeDimensionRepresentation_DownCast

class Handle_StepShape_BoxDomain(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepShape_BoxDomain self)

        Nullify the handle


        """
        return _StepShape.Handle_StepShape_BoxDomain_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepShape_BoxDomain self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepShape.Handle_StepShape_BoxDomain_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepShape_BoxDomain self, StepShape_BoxDomain thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepShape.Handle_StepShape_BoxDomain_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepShape_BoxDomain self, Handle_StepShape_BoxDomain theHandle) -> Handle_StepShape_BoxDomain
        assign(Handle_StepShape_BoxDomain self, StepShape_BoxDomain thePtr) -> Handle_StepShape_BoxDomain
        assign(Handle_StepShape_BoxDomain self, Handle_StepShape_BoxDomain theHandle) -> Handle_StepShape_BoxDomain

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepShape.Handle_StepShape_BoxDomain_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepShape_BoxDomain self) -> StepShape_BoxDomain

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepShape.Handle_StepShape_BoxDomain_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepShape_BoxDomain self) -> StepShape_BoxDomain

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepShape.Handle_StepShape_BoxDomain___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepShape_BoxDomain self) -> StepShape_BoxDomain

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepShape.Handle_StepShape_BoxDomain___ref__(self, *args)


    def __hash__(self):
        return _StepShape.Handle_StepShape_BoxDomain___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepShape.Handle_StepShape_BoxDomain___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepShape.new_Handle_StepShape_BoxDomain(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepShape.Handle_StepShape_BoxDomain_DownCast)
    __swig_destroy__ = _StepShape.delete_Handle_StepShape_BoxDomain

    def Init(self, *args):
        """
        Init(Handle_StepShape_BoxDomain self, Handle_StepGeom_CartesianPoint aCorner, Standard_Real const aXlength, Standard_Real const aYlength, Standard_Real const aZlength)

        :type aCorner: OCC.wrapper.StepShape.Handle_StepGeom_CartesianPoint
        :type aXlength: float
        :type aYlength: float
        :type aZlength: float

        """
        return _StepShape.Handle_StepShape_BoxDomain_Init(self, *args)


    def SetCorner(self, *args):
        """
        SetCorner(Handle_StepShape_BoxDomain self, Handle_StepGeom_CartesianPoint aCorner)

        :type aCorner: OCC.wrapper.StepShape.Handle_StepGeom_CartesianPoint

        """
        return _StepShape.Handle_StepShape_BoxDomain_SetCorner(self, *args)


    def Corner(self, *args):
        """
        Corner(Handle_StepShape_BoxDomain self) -> Handle_StepGeom_CartesianPoint

        :rtype: OCC.wrapper.StepShape.Handle_StepGeom_CartesianPoint

        """
        return _StepShape.Handle_StepShape_BoxDomain_Corner(self, *args)


    def SetXlength(self, *args):
        """
        SetXlength(Handle_StepShape_BoxDomain self, Standard_Real const aXlength)

        :type aXlength: float

        """
        return _StepShape.Handle_StepShape_BoxDomain_SetXlength(self, *args)


    def Xlength(self, *args):
        """
        Xlength(Handle_StepShape_BoxDomain self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _StepShape.Handle_StepShape_BoxDomain_Xlength(self, *args)


    def SetYlength(self, *args):
        """
        SetYlength(Handle_StepShape_BoxDomain self, Standard_Real const aYlength)

        :type aYlength: float

        """
        return _StepShape.Handle_StepShape_BoxDomain_SetYlength(self, *args)


    def Ylength(self, *args):
        """
        Ylength(Handle_StepShape_BoxDomain self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _StepShape.Handle_StepShape_BoxDomain_Ylength(self, *args)


    def SetZlength(self, *args):
        """
        SetZlength(Handle_StepShape_BoxDomain self, Standard_Real const aZlength)

        :type aZlength: float

        """
        return _StepShape.Handle_StepShape_BoxDomain_SetZlength(self, *args)


    def Zlength(self, *args):
        """
        Zlength(Handle_StepShape_BoxDomain self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _StepShape.Handle_StepShape_BoxDomain_Zlength(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepShape_BoxDomain self) -> char const *

        :rtype: const char *

        """
        return _StepShape.Handle_StepShape_BoxDomain_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.Handle_StepShape_BoxDomain_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.Handle_StepShape_BoxDomain_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_StepShape_BoxDomain self)

        Memory deallocator for transient classes


        """
        return _StepShape.Handle_StepShape_BoxDomain_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepShape_BoxDomain self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepShape_BoxDomain self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.Handle_StepShape_BoxDomain_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepShape_BoxDomain self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepShape_BoxDomain self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.Handle_StepShape_BoxDomain_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepShape_BoxDomain self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepShape.Handle_StepShape_BoxDomain_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepShape_BoxDomain self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_BoxDomain_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepShape_BoxDomain self)

        Increments the reference counter of this object


        """
        return _StepShape.Handle_StepShape_BoxDomain_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepShape_BoxDomain self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_BoxDomain_DecrementRefCounter(self, *args)

Handle_StepShape_BoxDomain_swigregister = _StepShape.Handle_StepShape_BoxDomain_swigregister
Handle_StepShape_BoxDomain_swigregister(Handle_StepShape_BoxDomain)

def Handle_StepShape_BoxDomain_DownCast(thing):
    return _StepShape.Handle_StepShape_BoxDomain_DownCast(thing)
Handle_StepShape_BoxDomain_DownCast = _StepShape.Handle_StepShape_BoxDomain_DownCast

class StepShape_ReversibleTopologyItem(StepData.StepData_SelectType):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(StepShape_ReversibleTopologyItem self) -> StepShape_ReversibleTopologyItem

        Returns a ReversibleTopologyItem SelectType


        """
        this = _StepShape.new_StepShape_ReversibleTopologyItem(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def CaseNum(self, *args):
        """
        CaseNum(StepShape_ReversibleTopologyItem self, Handle_Standard_Transient ent) -> Standard_Integer

        Recognizes a ReversibleTopologyItem Kind Entity that is :
        1 -> Edge
        2 -> Path
        3 -> Face
        4 -> FaceBound
        5 -> ClosedShell
        6 -> OpenShell
        0 else

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.StepShape_ReversibleTopologyItem_CaseNum(self, *args)


    def Edge(self, *args):
        """
        Edge(StepShape_ReversibleTopologyItem self) -> Handle_StepShape_Edge

        returns Value as a Edge (Null if another type)

        :rtype: OCC.wrapper.StepShape.Handle_StepShape_Edge

        """
        return _StepShape.StepShape_ReversibleTopologyItem_Edge(self, *args)


    def Path(self, *args):
        """
        Path(StepShape_ReversibleTopologyItem self) -> Handle_StepShape_Path

        returns Value as a Path (Null if another type)

        :rtype: OCC.wrapper.StepShape.Handle_StepShape_Path

        """
        return _StepShape.StepShape_ReversibleTopologyItem_Path(self, *args)


    def Face(self, *args):
        """
        Face(StepShape_ReversibleTopologyItem self) -> Handle_StepShape_Face

        returns Value as a Face (Null if another type)

        :rtype: OCC.wrapper.StepShape.Handle_StepShape_Face

        """
        return _StepShape.StepShape_ReversibleTopologyItem_Face(self, *args)


    def FaceBound(self, *args):
        """
        FaceBound(StepShape_ReversibleTopologyItem self) -> Handle_StepShape_FaceBound

        returns Value as a FaceBound (Null if another type)

        :rtype: OCC.wrapper.StepShape.Handle_StepShape_FaceBound

        """
        return _StepShape.StepShape_ReversibleTopologyItem_FaceBound(self, *args)


    def ClosedShell(self, *args):
        """
        ClosedShell(StepShape_ReversibleTopologyItem self) -> Handle_StepShape_ClosedShell

        returns Value as a ClosedShell (Null if another type)

        :rtype: OCC.wrapper.StepShape.Handle_StepShape_ClosedShell

        """
        return _StepShape.StepShape_ReversibleTopologyItem_ClosedShell(self, *args)


    def OpenShell(self, *args):
        """
        OpenShell(StepShape_ReversibleTopologyItem self) -> Handle_StepShape_OpenShell

        returns Value as a OpenShell (Null if another type)

        :rtype: OCC.wrapper.StepShape.Handle_StepShape_OpenShell

        """
        return _StepShape.StepShape_ReversibleTopologyItem_OpenShell(self, *args)

    __swig_destroy__ = _StepShape.delete_StepShape_ReversibleTopologyItem
StepShape_ReversibleTopologyItem_swigregister = _StepShape.StepShape_ReversibleTopologyItem_swigregister
StepShape_ReversibleTopologyItem_swigregister(StepShape_ReversibleTopologyItem)

class Handle_StepShape_FacetedBrep(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepShape_FacetedBrep self)

        Nullify the handle


        """
        return _StepShape.Handle_StepShape_FacetedBrep_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepShape_FacetedBrep self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepShape.Handle_StepShape_FacetedBrep_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepShape_FacetedBrep self, StepShape_FacetedBrep thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepShape.Handle_StepShape_FacetedBrep_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepShape_FacetedBrep self, Handle_StepShape_FacetedBrep theHandle) -> Handle_StepShape_FacetedBrep
        assign(Handle_StepShape_FacetedBrep self, StepShape_FacetedBrep thePtr) -> Handle_StepShape_FacetedBrep
        assign(Handle_StepShape_FacetedBrep self, Handle_StepShape_FacetedBrep theHandle) -> Handle_StepShape_FacetedBrep

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepShape.Handle_StepShape_FacetedBrep_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepShape_FacetedBrep self) -> StepShape_FacetedBrep

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepShape.Handle_StepShape_FacetedBrep_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepShape_FacetedBrep self) -> StepShape_FacetedBrep

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepShape.Handle_StepShape_FacetedBrep___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepShape_FacetedBrep self) -> StepShape_FacetedBrep

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepShape.Handle_StepShape_FacetedBrep___ref__(self, *args)


    def __hash__(self):
        return _StepShape.Handle_StepShape_FacetedBrep___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepShape.Handle_StepShape_FacetedBrep___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepShape.new_Handle_StepShape_FacetedBrep(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepShape.Handle_StepShape_FacetedBrep_DownCast)
    __swig_destroy__ = _StepShape.delete_Handle_StepShape_FacetedBrep

    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepShape_FacetedBrep self) -> char const *

        :rtype: const char *

        """
        return _StepShape.Handle_StepShape_FacetedBrep_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.Handle_StepShape_FacetedBrep_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.Handle_StepShape_FacetedBrep_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Init(self, *args):
        """
        Init(Handle_StepShape_FacetedBrep self, Handle_TCollection_HAsciiString aName, Handle_StepShape_ClosedShell aOuter)
        Init(Handle_StepShape_FacetedBrep self, Handle_TCollection_HAsciiString aName, Handle_StepShape_ConnectedFaceSet aOuter)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aOuter: OCC.wrapper.StepShape.Handle_StepShape_ConnectedFaceSet

        """
        return _StepShape.Handle_StepShape_FacetedBrep_Init(self, *args)


    def SetOuter(self, *args):
        """
        SetOuter(Handle_StepShape_FacetedBrep self, Handle_StepShape_ConnectedFaceSet aOuter)

        :type aOuter: OCC.wrapper.StepShape.Handle_StepShape_ConnectedFaceSet

        """
        return _StepShape.Handle_StepShape_FacetedBrep_SetOuter(self, *args)


    def Outer(self, *args):
        """
        Outer(Handle_StepShape_FacetedBrep self) -> Handle_StepShape_ConnectedFaceSet

        :rtype: OCC.wrapper.StepShape.Handle_StepShape_ConnectedFaceSet

        """
        return _StepShape.Handle_StepShape_FacetedBrep_Outer(self, *args)


    def SetName(self, *args):
        """
        SetName(Handle_StepShape_FacetedBrep self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepShape.Handle_StepShape_FacetedBrep_SetName(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepShape_FacetedBrep self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepShape.Handle_StepShape_FacetedBrep_Name(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepShape_FacetedBrep self)

        Memory deallocator for transient classes


        """
        return _StepShape.Handle_StepShape_FacetedBrep_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepShape_FacetedBrep self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepShape_FacetedBrep self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.Handle_StepShape_FacetedBrep_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepShape_FacetedBrep self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepShape_FacetedBrep self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.Handle_StepShape_FacetedBrep_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepShape_FacetedBrep self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepShape.Handle_StepShape_FacetedBrep_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepShape_FacetedBrep self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_FacetedBrep_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepShape_FacetedBrep self)

        Increments the reference counter of this object


        """
        return _StepShape.Handle_StepShape_FacetedBrep_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepShape_FacetedBrep self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_FacetedBrep_DecrementRefCounter(self, *args)

Handle_StepShape_FacetedBrep_swigregister = _StepShape.Handle_StepShape_FacetedBrep_swigregister
Handle_StepShape_FacetedBrep_swigregister(Handle_StepShape_FacetedBrep)

def Handle_StepShape_FacetedBrep_DownCast(thing):
    return _StepShape.Handle_StepShape_FacetedBrep_DownCast(thing)
Handle_StepShape_FacetedBrep_DownCast = _StepShape.Handle_StepShape_FacetedBrep_DownCast

class Handle_StepShape_SweptFaceSolid(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepShape_SweptFaceSolid self)

        Nullify the handle


        """
        return _StepShape.Handle_StepShape_SweptFaceSolid_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepShape_SweptFaceSolid self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepShape.Handle_StepShape_SweptFaceSolid_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepShape_SweptFaceSolid self, StepShape_SweptFaceSolid thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepShape.Handle_StepShape_SweptFaceSolid_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepShape_SweptFaceSolid self, Handle_StepShape_SweptFaceSolid theHandle) -> Handle_StepShape_SweptFaceSolid
        assign(Handle_StepShape_SweptFaceSolid self, StepShape_SweptFaceSolid thePtr) -> Handle_StepShape_SweptFaceSolid
        assign(Handle_StepShape_SweptFaceSolid self, Handle_StepShape_SweptFaceSolid theHandle) -> Handle_StepShape_SweptFaceSolid

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepShape.Handle_StepShape_SweptFaceSolid_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepShape_SweptFaceSolid self) -> StepShape_SweptFaceSolid

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepShape.Handle_StepShape_SweptFaceSolid_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepShape_SweptFaceSolid self) -> StepShape_SweptFaceSolid

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepShape.Handle_StepShape_SweptFaceSolid___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepShape_SweptFaceSolid self) -> StepShape_SweptFaceSolid

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepShape.Handle_StepShape_SweptFaceSolid___ref__(self, *args)


    def __hash__(self):
        return _StepShape.Handle_StepShape_SweptFaceSolid___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepShape.Handle_StepShape_SweptFaceSolid___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepShape.new_Handle_StepShape_SweptFaceSolid(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepShape.Handle_StepShape_SweptFaceSolid_DownCast)
    __swig_destroy__ = _StepShape.delete_Handle_StepShape_SweptFaceSolid

    def Init(self, *args):
        """
        Init(Handle_StepShape_SweptFaceSolid self, Handle_TCollection_HAsciiString aName, Handle_StepShape_FaceSurface aSweptArea)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aSweptArea: OCC.wrapper.StepShape.Handle_StepShape_FaceSurface

        """
        return _StepShape.Handle_StepShape_SweptFaceSolid_Init(self, *args)


    def SetSweptFace(self, *args):
        """
        SetSweptFace(Handle_StepShape_SweptFaceSolid self, Handle_StepShape_FaceSurface aSweptArea)

        :type aSweptArea: OCC.wrapper.StepShape.Handle_StepShape_FaceSurface

        """
        return _StepShape.Handle_StepShape_SweptFaceSolid_SetSweptFace(self, *args)


    def SweptFace(self, *args):
        """
        SweptFace(Handle_StepShape_SweptFaceSolid self) -> Handle_StepShape_FaceSurface

        :rtype: OCC.wrapper.StepShape.Handle_StepShape_FaceSurface

        """
        return _StepShape.Handle_StepShape_SweptFaceSolid_SweptFace(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepShape_SweptFaceSolid self) -> char const *

        :rtype: const char *

        """
        return _StepShape.Handle_StepShape_SweptFaceSolid_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.Handle_StepShape_SweptFaceSolid_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.Handle_StepShape_SweptFaceSolid_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetName(self, *args):
        """
        SetName(Handle_StepShape_SweptFaceSolid self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepShape.Handle_StepShape_SweptFaceSolid_SetName(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepShape_SweptFaceSolid self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepShape.Handle_StepShape_SweptFaceSolid_Name(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepShape_SweptFaceSolid self)

        Memory deallocator for transient classes


        """
        return _StepShape.Handle_StepShape_SweptFaceSolid_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepShape_SweptFaceSolid self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepShape_SweptFaceSolid self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.Handle_StepShape_SweptFaceSolid_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepShape_SweptFaceSolid self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepShape_SweptFaceSolid self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.Handle_StepShape_SweptFaceSolid_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepShape_SweptFaceSolid self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepShape.Handle_StepShape_SweptFaceSolid_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepShape_SweptFaceSolid self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_SweptFaceSolid_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepShape_SweptFaceSolid self)

        Increments the reference counter of this object


        """
        return _StepShape.Handle_StepShape_SweptFaceSolid_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepShape_SweptFaceSolid self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_SweptFaceSolid_DecrementRefCounter(self, *args)

Handle_StepShape_SweptFaceSolid_swigregister = _StepShape.Handle_StepShape_SweptFaceSolid_swigregister
Handle_StepShape_SweptFaceSolid_swigregister(Handle_StepShape_SweptFaceSolid)

def Handle_StepShape_SweptFaceSolid_DownCast(thing):
    return _StepShape.Handle_StepShape_SweptFaceSolid_DownCast(thing)
Handle_StepShape_SweptFaceSolid_DownCast = _StepShape.Handle_StepShape_SweptFaceSolid_DownCast

class Handle_StepShape_DimensionalLocationWithPath(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepShape_DimensionalLocationWithPath self)

        Nullify the handle


        """
        return _StepShape.Handle_StepShape_DimensionalLocationWithPath_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepShape_DimensionalLocationWithPath self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepShape.Handle_StepShape_DimensionalLocationWithPath_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepShape_DimensionalLocationWithPath self, StepShape_DimensionalLocationWithPath thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepShape.Handle_StepShape_DimensionalLocationWithPath_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepShape_DimensionalLocationWithPath self, Handle_StepShape_DimensionalLocationWithPath theHandle) -> Handle_StepShape_DimensionalLocationWithPath
        assign(Handle_StepShape_DimensionalLocationWithPath self, StepShape_DimensionalLocationWithPath thePtr) -> Handle_StepShape_DimensionalLocationWithPath
        assign(Handle_StepShape_DimensionalLocationWithPath self, Handle_StepShape_DimensionalLocationWithPath theHandle) -> Handle_StepShape_DimensionalLocationWithPath

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepShape.Handle_StepShape_DimensionalLocationWithPath_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepShape_DimensionalLocationWithPath self) -> StepShape_DimensionalLocationWithPath

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepShape.Handle_StepShape_DimensionalLocationWithPath_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepShape_DimensionalLocationWithPath self) -> StepShape_DimensionalLocationWithPath

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepShape.Handle_StepShape_DimensionalLocationWithPath___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepShape_DimensionalLocationWithPath self) -> StepShape_DimensionalLocationWithPath

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepShape.Handle_StepShape_DimensionalLocationWithPath___ref__(self, *args)


    def __hash__(self):
        return _StepShape.Handle_StepShape_DimensionalLocationWithPath___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepShape.Handle_StepShape_DimensionalLocationWithPath___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepShape.new_Handle_StepShape_DimensionalLocationWithPath(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepShape.Handle_StepShape_DimensionalLocationWithPath_DownCast)
    __swig_destroy__ = _StepShape.delete_Handle_StepShape_DimensionalLocationWithPath

    def Init(self, *args):
        """
        Init(Handle_StepShape_DimensionalLocationWithPath self, Handle_TCollection_HAsciiString aShapeAspectRelationship_Name, Standard_Boolean const hasShapeAspectRelationship_Description, Handle_TCollection_HAsciiString aShapeAspectRelationship_Description, Handle_StepRepr_ShapeAspect aShapeAspectRelationship_RelatingShapeAspect, Handle_StepRepr_ShapeAspect aShapeAspectRelationship_RelatedShapeAspect, Handle_StepRepr_ShapeAspect aPath)

        Initialize all fields (own and inherited)

        :type aShapeAspectRelationship_Name: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type hasShapeAspectRelationship_Description: bool
        :type aShapeAspectRelationship_Description: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aShapeAspectRelationship_RelatingShapeAspect: OCC.wrapper.StepShape.Handle_StepRepr_ShapeAspect
        :type aShapeAspectRelationship_RelatedShapeAspect: OCC.wrapper.StepShape.Handle_StepRepr_ShapeAspect
        :type aPath: OCC.wrapper.StepShape.Handle_StepRepr_ShapeAspect

        """
        return _StepShape.Handle_StepShape_DimensionalLocationWithPath_Init(self, *args)


    def Path(self, *args):
        """
        Path(Handle_StepShape_DimensionalLocationWithPath self) -> Handle_StepRepr_ShapeAspect

        Returns field Path

        :rtype: OCC.wrapper.StepShape.Handle_StepRepr_ShapeAspect

        """
        return _StepShape.Handle_StepShape_DimensionalLocationWithPath_Path(self, *args)


    def SetPath(self, *args):
        """
        SetPath(Handle_StepShape_DimensionalLocationWithPath self, Handle_StepRepr_ShapeAspect Path)

        Set field Path

        :type Path: OCC.wrapper.StepShape.Handle_StepRepr_ShapeAspect

        """
        return _StepShape.Handle_StepShape_DimensionalLocationWithPath_SetPath(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepShape_DimensionalLocationWithPath self) -> char const *

        :rtype: const char *

        """
        return _StepShape.Handle_StepShape_DimensionalLocationWithPath_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.Handle_StepShape_DimensionalLocationWithPath_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.Handle_StepShape_DimensionalLocationWithPath_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Name(self, *args):
        """
        Name(Handle_StepShape_DimensionalLocationWithPath self) -> Handle_TCollection_HAsciiString

        Returns field Name

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepShape.Handle_StepShape_DimensionalLocationWithPath_Name(self, *args)


    def SetName(self, *args):
        """
        SetName(Handle_StepShape_DimensionalLocationWithPath self, Handle_TCollection_HAsciiString Name)

        Set field Name

        :type Name: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepShape.Handle_StepShape_DimensionalLocationWithPath_SetName(self, *args)


    def Description(self, *args):
        """
        Description(Handle_StepShape_DimensionalLocationWithPath self) -> Handle_TCollection_HAsciiString

        Returns field Description

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepShape.Handle_StepShape_DimensionalLocationWithPath_Description(self, *args)


    def SetDescription(self, *args):
        """
        SetDescription(Handle_StepShape_DimensionalLocationWithPath self, Handle_TCollection_HAsciiString Description)

        Set field Description

        :type Description: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepShape.Handle_StepShape_DimensionalLocationWithPath_SetDescription(self, *args)


    def HasDescription(self, *args):
        """
        HasDescription(Handle_StepShape_DimensionalLocationWithPath self) -> Standard_Boolean

        Returns True if optional field Description is defined

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.Handle_StepShape_DimensionalLocationWithPath_HasDescription(self, *args)


    def RelatingShapeAspect(self, *args):
        """
        RelatingShapeAspect(Handle_StepShape_DimensionalLocationWithPath self) -> Handle_StepRepr_ShapeAspect

        Returns field RelatingShapeAspect

        :rtype: OCC.wrapper.StepRepr.Handle_StepRepr_ShapeAspect

        """
        return _StepShape.Handle_StepShape_DimensionalLocationWithPath_RelatingShapeAspect(self, *args)


    def SetRelatingShapeAspect(self, *args):
        """
        SetRelatingShapeAspect(Handle_StepShape_DimensionalLocationWithPath self, Handle_StepRepr_ShapeAspect RelatingShapeAspect)

        Set field RelatingShapeAspect

        :type RelatingShapeAspect: OCC.wrapper.StepRepr.Handle_StepRepr_ShapeAspect

        """
        return _StepShape.Handle_StepShape_DimensionalLocationWithPath_SetRelatingShapeAspect(self, *args)


    def RelatedShapeAspect(self, *args):
        """
        RelatedShapeAspect(Handle_StepShape_DimensionalLocationWithPath self) -> Handle_StepRepr_ShapeAspect

        Returns field RelatedShapeAspect

        :rtype: OCC.wrapper.StepRepr.Handle_StepRepr_ShapeAspect

        """
        return _StepShape.Handle_StepShape_DimensionalLocationWithPath_RelatedShapeAspect(self, *args)


    def SetRelatedShapeAspect(self, *args):
        """
        SetRelatedShapeAspect(Handle_StepShape_DimensionalLocationWithPath self, Handle_StepRepr_ShapeAspect RelatedShapeAspect)

        Set field RelatedShapeAspect

        :type RelatedShapeAspect: OCC.wrapper.StepRepr.Handle_StepRepr_ShapeAspect

        """
        return _StepShape.Handle_StepShape_DimensionalLocationWithPath_SetRelatedShapeAspect(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepShape_DimensionalLocationWithPath self)

        Memory deallocator for transient classes


        """
        return _StepShape.Handle_StepShape_DimensionalLocationWithPath_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepShape_DimensionalLocationWithPath self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepShape_DimensionalLocationWithPath self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.Handle_StepShape_DimensionalLocationWithPath_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepShape_DimensionalLocationWithPath self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepShape_DimensionalLocationWithPath self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.Handle_StepShape_DimensionalLocationWithPath_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepShape_DimensionalLocationWithPath self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepShape.Handle_StepShape_DimensionalLocationWithPath_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepShape_DimensionalLocationWithPath self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_DimensionalLocationWithPath_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepShape_DimensionalLocationWithPath self)

        Increments the reference counter of this object


        """
        return _StepShape.Handle_StepShape_DimensionalLocationWithPath_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepShape_DimensionalLocationWithPath self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_DimensionalLocationWithPath_DecrementRefCounter(self, *args)

Handle_StepShape_DimensionalLocationWithPath_swigregister = _StepShape.Handle_StepShape_DimensionalLocationWithPath_swigregister
Handle_StepShape_DimensionalLocationWithPath_swigregister(Handle_StepShape_DimensionalLocationWithPath)

def Handle_StepShape_DimensionalLocationWithPath_DownCast(thing):
    return _StepShape.Handle_StepShape_DimensionalLocationWithPath_DownCast(thing)
Handle_StepShape_DimensionalLocationWithPath_DownCast = _StepShape.Handle_StepShape_DimensionalLocationWithPath_DownCast

class Handle_StepShape_FaceOuterBound(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepShape_FaceOuterBound self)

        Nullify the handle


        """
        return _StepShape.Handle_StepShape_FaceOuterBound_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepShape_FaceOuterBound self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepShape.Handle_StepShape_FaceOuterBound_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepShape_FaceOuterBound self, StepShape_FaceOuterBound thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepShape.Handle_StepShape_FaceOuterBound_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepShape_FaceOuterBound self, Handle_StepShape_FaceOuterBound theHandle) -> Handle_StepShape_FaceOuterBound
        assign(Handle_StepShape_FaceOuterBound self, StepShape_FaceOuterBound thePtr) -> Handle_StepShape_FaceOuterBound
        assign(Handle_StepShape_FaceOuterBound self, Handle_StepShape_FaceOuterBound theHandle) -> Handle_StepShape_FaceOuterBound

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepShape.Handle_StepShape_FaceOuterBound_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepShape_FaceOuterBound self) -> StepShape_FaceOuterBound

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepShape.Handle_StepShape_FaceOuterBound_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepShape_FaceOuterBound self) -> StepShape_FaceOuterBound

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepShape.Handle_StepShape_FaceOuterBound___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepShape_FaceOuterBound self) -> StepShape_FaceOuterBound

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepShape.Handle_StepShape_FaceOuterBound___ref__(self, *args)


    def __hash__(self):
        return _StepShape.Handle_StepShape_FaceOuterBound___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepShape.Handle_StepShape_FaceOuterBound___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepShape.new_Handle_StepShape_FaceOuterBound(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepShape.Handle_StepShape_FaceOuterBound_DownCast)
    __swig_destroy__ = _StepShape.delete_Handle_StepShape_FaceOuterBound

    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepShape_FaceOuterBound self) -> char const *

        :rtype: const char *

        """
        return _StepShape.Handle_StepShape_FaceOuterBound_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.Handle_StepShape_FaceOuterBound_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.Handle_StepShape_FaceOuterBound_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Init(self, *args):
        """
        Init(Handle_StepShape_FaceOuterBound self, Handle_TCollection_HAsciiString aName, Handle_StepShape_Loop aBound, Standard_Boolean const aOrientation)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aBound: OCC.wrapper.StepShape.Handle_StepShape_Loop
        :type aOrientation: bool

        """
        return _StepShape.Handle_StepShape_FaceOuterBound_Init(self, *args)


    def SetBound(self, *args):
        """
        SetBound(Handle_StepShape_FaceOuterBound self, Handle_StepShape_Loop aBound)

        :type aBound: OCC.wrapper.StepShape.Handle_StepShape_Loop

        """
        return _StepShape.Handle_StepShape_FaceOuterBound_SetBound(self, *args)


    def Bound(self, *args):
        """
        Bound(Handle_StepShape_FaceOuterBound self) -> Handle_StepShape_Loop

        :rtype: OCC.wrapper.StepShape.Handle_StepShape_Loop

        """
        return _StepShape.Handle_StepShape_FaceOuterBound_Bound(self, *args)


    def SetOrientation(self, *args):
        """
        SetOrientation(Handle_StepShape_FaceOuterBound self, Standard_Boolean const aOrientation)

        :type aOrientation: bool

        """
        return _StepShape.Handle_StepShape_FaceOuterBound_SetOrientation(self, *args)


    def Orientation(self, *args):
        """
        Orientation(Handle_StepShape_FaceOuterBound self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.Handle_StepShape_FaceOuterBound_Orientation(self, *args)


    def SetName(self, *args):
        """
        SetName(Handle_StepShape_FaceOuterBound self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepShape.Handle_StepShape_FaceOuterBound_SetName(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepShape_FaceOuterBound self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepShape.Handle_StepShape_FaceOuterBound_Name(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepShape_FaceOuterBound self)

        Memory deallocator for transient classes


        """
        return _StepShape.Handle_StepShape_FaceOuterBound_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepShape_FaceOuterBound self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepShape_FaceOuterBound self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.Handle_StepShape_FaceOuterBound_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepShape_FaceOuterBound self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepShape_FaceOuterBound self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.Handle_StepShape_FaceOuterBound_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepShape_FaceOuterBound self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepShape.Handle_StepShape_FaceOuterBound_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepShape_FaceOuterBound self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_FaceOuterBound_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepShape_FaceOuterBound self)

        Increments the reference counter of this object


        """
        return _StepShape.Handle_StepShape_FaceOuterBound_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepShape_FaceOuterBound self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_FaceOuterBound_DecrementRefCounter(self, *args)

Handle_StepShape_FaceOuterBound_swigregister = _StepShape.Handle_StepShape_FaceOuterBound_swigregister
Handle_StepShape_FaceOuterBound_swigregister(Handle_StepShape_FaceOuterBound)

def Handle_StepShape_FaceOuterBound_DownCast(thing):
    return _StepShape.Handle_StepShape_FaceOuterBound_DownCast(thing)
Handle_StepShape_FaceOuterBound_DownCast = _StepShape.Handle_StepShape_FaceOuterBound_DownCast

class Handle_StepShape_HArray1OfFaceBound(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepShape_HArray1OfFaceBound self)

        Nullify the handle


        """
        return _StepShape.Handle_StepShape_HArray1OfFaceBound_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepShape_HArray1OfFaceBound self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepShape.Handle_StepShape_HArray1OfFaceBound_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepShape_HArray1OfFaceBound self, StepShape_HArray1OfFaceBound thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepShape.Handle_StepShape_HArray1OfFaceBound_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepShape_HArray1OfFaceBound self, Handle_StepShape_HArray1OfFaceBound theHandle) -> Handle_StepShape_HArray1OfFaceBound
        assign(Handle_StepShape_HArray1OfFaceBound self, StepShape_HArray1OfFaceBound thePtr) -> Handle_StepShape_HArray1OfFaceBound
        assign(Handle_StepShape_HArray1OfFaceBound self, Handle_StepShape_HArray1OfFaceBound theHandle) -> Handle_StepShape_HArray1OfFaceBound

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepShape.Handle_StepShape_HArray1OfFaceBound_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepShape_HArray1OfFaceBound self) -> StepShape_HArray1OfFaceBound

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepShape.Handle_StepShape_HArray1OfFaceBound_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepShape_HArray1OfFaceBound self) -> StepShape_HArray1OfFaceBound

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepShape.Handle_StepShape_HArray1OfFaceBound___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepShape_HArray1OfFaceBound self) -> StepShape_HArray1OfFaceBound

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepShape.Handle_StepShape_HArray1OfFaceBound___ref__(self, *args)


    def __hash__(self):
        return _StepShape.Handle_StepShape_HArray1OfFaceBound___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepShape.Handle_StepShape_HArray1OfFaceBound___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepShape.new_Handle_StepShape_HArray1OfFaceBound(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepShape.Handle_StepShape_HArray1OfFaceBound_DownCast)
    __swig_destroy__ = _StepShape.delete_Handle_StepShape_HArray1OfFaceBound

    def Array1(self, *args):
        """
        :rtype: OCC.wrapper.StepShape.StepShape_Array1OfFaceBound

        """
        res = _StepShape.Handle_StepShape_HArray1OfFaceBound_Array1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeArray1(self, *args):
        """
        ChangeArray1(Handle_StepShape_HArray1OfFaceBound self) -> NCollection_Array1_Handle_StepShape_FaceBound

        :rtype: OCC.wrapper.StepShape.StepShape_Array1OfFaceBound

        """
        return _StepShape.Handle_StepShape_HArray1OfFaceBound_ChangeArray1(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepShape_HArray1OfFaceBound self) -> char const *

        :rtype: const char *

        """
        return _StepShape.Handle_StepShape_HArray1OfFaceBound_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.Handle_StepShape_HArray1OfFaceBound_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.Handle_StepShape_HArray1OfFaceBound_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_StepShape_HArray1OfFaceBound self)

        Memory deallocator for transient classes


        """
        return _StepShape.Handle_StepShape_HArray1OfFaceBound_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepShape_HArray1OfFaceBound self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepShape_HArray1OfFaceBound self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.Handle_StepShape_HArray1OfFaceBound_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepShape_HArray1OfFaceBound self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepShape_HArray1OfFaceBound self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.Handle_StepShape_HArray1OfFaceBound_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepShape_HArray1OfFaceBound self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepShape.Handle_StepShape_HArray1OfFaceBound_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepShape_HArray1OfFaceBound self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_HArray1OfFaceBound_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepShape_HArray1OfFaceBound self)

        Increments the reference counter of this object


        """
        return _StepShape.Handle_StepShape_HArray1OfFaceBound_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepShape_HArray1OfFaceBound self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_HArray1OfFaceBound_DecrementRefCounter(self, *args)

Handle_StepShape_HArray1OfFaceBound_swigregister = _StepShape.Handle_StepShape_HArray1OfFaceBound_swigregister
Handle_StepShape_HArray1OfFaceBound_swigregister(Handle_StepShape_HArray1OfFaceBound)

def Handle_StepShape_HArray1OfFaceBound_DownCast(thing):
    return _StepShape.Handle_StepShape_HArray1OfFaceBound_DownCast(thing)
Handle_StepShape_HArray1OfFaceBound_DownCast = _StepShape.Handle_StepShape_HArray1OfFaceBound_DownCast

class Handle_StepShape_OrientedClosedShell(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepShape_OrientedClosedShell self)

        Nullify the handle


        """
        return _StepShape.Handle_StepShape_OrientedClosedShell_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepShape_OrientedClosedShell self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepShape.Handle_StepShape_OrientedClosedShell_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepShape_OrientedClosedShell self, StepShape_OrientedClosedShell thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepShape.Handle_StepShape_OrientedClosedShell_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepShape_OrientedClosedShell self, Handle_StepShape_OrientedClosedShell theHandle) -> Handle_StepShape_OrientedClosedShell
        assign(Handle_StepShape_OrientedClosedShell self, StepShape_OrientedClosedShell thePtr) -> Handle_StepShape_OrientedClosedShell
        assign(Handle_StepShape_OrientedClosedShell self, Handle_StepShape_OrientedClosedShell theHandle) -> Handle_StepShape_OrientedClosedShell

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepShape.Handle_StepShape_OrientedClosedShell_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepShape_OrientedClosedShell self) -> StepShape_OrientedClosedShell

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepShape.Handle_StepShape_OrientedClosedShell_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepShape_OrientedClosedShell self) -> StepShape_OrientedClosedShell

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepShape.Handle_StepShape_OrientedClosedShell___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepShape_OrientedClosedShell self) -> StepShape_OrientedClosedShell

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepShape.Handle_StepShape_OrientedClosedShell___ref__(self, *args)


    def __hash__(self):
        return _StepShape.Handle_StepShape_OrientedClosedShell___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepShape.Handle_StepShape_OrientedClosedShell___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepShape.new_Handle_StepShape_OrientedClosedShell(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepShape.Handle_StepShape_OrientedClosedShell_DownCast)
    __swig_destroy__ = _StepShape.delete_Handle_StepShape_OrientedClosedShell

    def Init(self, *args):
        """
        Init(Handle_StepShape_OrientedClosedShell self, Handle_TCollection_HAsciiString aName, Handle_StepShape_ClosedShell aClosedShellElement, Standard_Boolean const aOrientation)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aClosedShellElement: OCC.wrapper.StepShape.Handle_StepShape_ClosedShell
        :type aOrientation: bool

        """
        return _StepShape.Handle_StepShape_OrientedClosedShell_Init(self, *args)


    def SetClosedShellElement(self, *args):
        """
        SetClosedShellElement(Handle_StepShape_OrientedClosedShell self, Handle_StepShape_ClosedShell aClosedShellElement)

        :type aClosedShellElement: OCC.wrapper.StepShape.Handle_StepShape_ClosedShell

        """
        return _StepShape.Handle_StepShape_OrientedClosedShell_SetClosedShellElement(self, *args)


    def ClosedShellElement(self, *args):
        """
        ClosedShellElement(Handle_StepShape_OrientedClosedShell self) -> Handle_StepShape_ClosedShell

        :rtype: OCC.wrapper.StepShape.Handle_StepShape_ClosedShell

        """
        return _StepShape.Handle_StepShape_OrientedClosedShell_ClosedShellElement(self, *args)


    def SetOrientation(self, *args):
        """
        SetOrientation(Handle_StepShape_OrientedClosedShell self, Standard_Boolean const aOrientation)

        :type aOrientation: bool

        """
        return _StepShape.Handle_StepShape_OrientedClosedShell_SetOrientation(self, *args)


    def Orientation(self, *args):
        """
        Orientation(Handle_StepShape_OrientedClosedShell self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.Handle_StepShape_OrientedClosedShell_Orientation(self, *args)


    def SetCfsFaces(self, *args):
        """
        SetCfsFaces(Handle_StepShape_OrientedClosedShell self, Handle_StepShape_HArray1OfFace aCfsFaces)

        :type aCfsFaces: OCC.wrapper.StepShape.Handle_StepShape_HArray1OfFace

        """
        return _StepShape.Handle_StepShape_OrientedClosedShell_SetCfsFaces(self, *args)


    def CfsFaces(self, *args):
        """
        CfsFaces(Handle_StepShape_OrientedClosedShell self) -> Handle_StepShape_HArray1OfFace

        :rtype: OCC.wrapper.StepShape.Handle_StepShape_HArray1OfFace

        """
        return _StepShape.Handle_StepShape_OrientedClosedShell_CfsFaces(self, *args)


    def CfsFacesValue(self, *args):
        """
        CfsFacesValue(Handle_StepShape_OrientedClosedShell self, Standard_Integer const num) -> Handle_StepShape_Face

        :type num: int
        :rtype: OCC.wrapper.StepShape.Handle_StepShape_Face

        """
        return _StepShape.Handle_StepShape_OrientedClosedShell_CfsFacesValue(self, *args)


    def NbCfsFaces(self, *args):
        """
        NbCfsFaces(Handle_StepShape_OrientedClosedShell self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_OrientedClosedShell_NbCfsFaces(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepShape_OrientedClosedShell self) -> char const *

        :rtype: const char *

        """
        return _StepShape.Handle_StepShape_OrientedClosedShell_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.Handle_StepShape_OrientedClosedShell_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.Handle_StepShape_OrientedClosedShell_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetName(self, *args):
        """
        SetName(Handle_StepShape_OrientedClosedShell self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepShape.Handle_StepShape_OrientedClosedShell_SetName(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepShape_OrientedClosedShell self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepShape.Handle_StepShape_OrientedClosedShell_Name(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepShape_OrientedClosedShell self)

        Memory deallocator for transient classes


        """
        return _StepShape.Handle_StepShape_OrientedClosedShell_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepShape_OrientedClosedShell self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepShape_OrientedClosedShell self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.Handle_StepShape_OrientedClosedShell_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepShape_OrientedClosedShell self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepShape_OrientedClosedShell self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.Handle_StepShape_OrientedClosedShell_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepShape_OrientedClosedShell self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepShape.Handle_StepShape_OrientedClosedShell_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepShape_OrientedClosedShell self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_OrientedClosedShell_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepShape_OrientedClosedShell self)

        Increments the reference counter of this object


        """
        return _StepShape.Handle_StepShape_OrientedClosedShell_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepShape_OrientedClosedShell self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_OrientedClosedShell_DecrementRefCounter(self, *args)

Handle_StepShape_OrientedClosedShell_swigregister = _StepShape.Handle_StepShape_OrientedClosedShell_swigregister
Handle_StepShape_OrientedClosedShell_swigregister(Handle_StepShape_OrientedClosedShell)

def Handle_StepShape_OrientedClosedShell_DownCast(thing):
    return _StepShape.Handle_StepShape_OrientedClosedShell_DownCast(thing)
Handle_StepShape_OrientedClosedShell_DownCast = _StepShape.Handle_StepShape_OrientedClosedShell_DownCast

class Handle_StepShape_AngularLocation(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepShape_AngularLocation self)

        Nullify the handle


        """
        return _StepShape.Handle_StepShape_AngularLocation_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepShape_AngularLocation self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepShape.Handle_StepShape_AngularLocation_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepShape_AngularLocation self, StepShape_AngularLocation thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepShape.Handle_StepShape_AngularLocation_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepShape_AngularLocation self, Handle_StepShape_AngularLocation theHandle) -> Handle_StepShape_AngularLocation
        assign(Handle_StepShape_AngularLocation self, StepShape_AngularLocation thePtr) -> Handle_StepShape_AngularLocation
        assign(Handle_StepShape_AngularLocation self, Handle_StepShape_AngularLocation theHandle) -> Handle_StepShape_AngularLocation

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepShape.Handle_StepShape_AngularLocation_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepShape_AngularLocation self) -> StepShape_AngularLocation

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepShape.Handle_StepShape_AngularLocation_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepShape_AngularLocation self) -> StepShape_AngularLocation

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepShape.Handle_StepShape_AngularLocation___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepShape_AngularLocation self) -> StepShape_AngularLocation

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepShape.Handle_StepShape_AngularLocation___ref__(self, *args)


    def __hash__(self):
        return _StepShape.Handle_StepShape_AngularLocation___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepShape.Handle_StepShape_AngularLocation___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepShape.new_Handle_StepShape_AngularLocation(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepShape.Handle_StepShape_AngularLocation_DownCast)
    __swig_destroy__ = _StepShape.delete_Handle_StepShape_AngularLocation

    def Init(self, *args):
        """
        Init(Handle_StepShape_AngularLocation self, Handle_TCollection_HAsciiString aShapeAspectRelationship_Name, Standard_Boolean const hasShapeAspectRelationship_Description, Handle_TCollection_HAsciiString aShapeAspectRelationship_Description, Handle_StepRepr_ShapeAspect aShapeAspectRelationship_RelatingShapeAspect, Handle_StepRepr_ShapeAspect aShapeAspectRelationship_RelatedShapeAspect, StepShape_AngleRelator const aAngleSelection)

        Initialize all fields (own and inherited)

        :type aShapeAspectRelationship_Name: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type hasShapeAspectRelationship_Description: bool
        :type aShapeAspectRelationship_Description: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aShapeAspectRelationship_RelatingShapeAspect: OCC.wrapper.StepShape.Handle_StepRepr_ShapeAspect
        :type aShapeAspectRelationship_RelatedShapeAspect: OCC.wrapper.StepShape.Handle_StepRepr_ShapeAspect
        :type aAngleSelection: OCC.wrapper.StepShape.StepShape_AngleRelator

        """
        return _StepShape.Handle_StepShape_AngularLocation_Init(self, *args)


    def AngleSelection(self, *args):
        """
        AngleSelection(Handle_StepShape_AngularLocation self) -> StepShape_AngleRelator

        Returns field AngleSelection

        :rtype: OCC.wrapper.StepShape.StepShape_AngleRelator

        """
        return _StepShape.Handle_StepShape_AngularLocation_AngleSelection(self, *args)


    def SetAngleSelection(self, *args):
        """
        SetAngleSelection(Handle_StepShape_AngularLocation self, StepShape_AngleRelator const AngleSelection)

        Set field AngleSelection

        :type AngleSelection: OCC.wrapper.StepShape.StepShape_AngleRelator

        """
        return _StepShape.Handle_StepShape_AngularLocation_SetAngleSelection(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepShape_AngularLocation self) -> char const *

        :rtype: const char *

        """
        return _StepShape.Handle_StepShape_AngularLocation_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.Handle_StepShape_AngularLocation_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.Handle_StepShape_AngularLocation_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Name(self, *args):
        """
        Name(Handle_StepShape_AngularLocation self) -> Handle_TCollection_HAsciiString

        Returns field Name

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepShape.Handle_StepShape_AngularLocation_Name(self, *args)


    def SetName(self, *args):
        """
        SetName(Handle_StepShape_AngularLocation self, Handle_TCollection_HAsciiString Name)

        Set field Name

        :type Name: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepShape.Handle_StepShape_AngularLocation_SetName(self, *args)


    def Description(self, *args):
        """
        Description(Handle_StepShape_AngularLocation self) -> Handle_TCollection_HAsciiString

        Returns field Description

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepShape.Handle_StepShape_AngularLocation_Description(self, *args)


    def SetDescription(self, *args):
        """
        SetDescription(Handle_StepShape_AngularLocation self, Handle_TCollection_HAsciiString Description)

        Set field Description

        :type Description: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepShape.Handle_StepShape_AngularLocation_SetDescription(self, *args)


    def HasDescription(self, *args):
        """
        HasDescription(Handle_StepShape_AngularLocation self) -> Standard_Boolean

        Returns True if optional field Description is defined

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.Handle_StepShape_AngularLocation_HasDescription(self, *args)


    def RelatingShapeAspect(self, *args):
        """
        RelatingShapeAspect(Handle_StepShape_AngularLocation self) -> Handle_StepRepr_ShapeAspect

        Returns field RelatingShapeAspect

        :rtype: OCC.wrapper.StepRepr.Handle_StepRepr_ShapeAspect

        """
        return _StepShape.Handle_StepShape_AngularLocation_RelatingShapeAspect(self, *args)


    def SetRelatingShapeAspect(self, *args):
        """
        SetRelatingShapeAspect(Handle_StepShape_AngularLocation self, Handle_StepRepr_ShapeAspect RelatingShapeAspect)

        Set field RelatingShapeAspect

        :type RelatingShapeAspect: OCC.wrapper.StepRepr.Handle_StepRepr_ShapeAspect

        """
        return _StepShape.Handle_StepShape_AngularLocation_SetRelatingShapeAspect(self, *args)


    def RelatedShapeAspect(self, *args):
        """
        RelatedShapeAspect(Handle_StepShape_AngularLocation self) -> Handle_StepRepr_ShapeAspect

        Returns field RelatedShapeAspect

        :rtype: OCC.wrapper.StepRepr.Handle_StepRepr_ShapeAspect

        """
        return _StepShape.Handle_StepShape_AngularLocation_RelatedShapeAspect(self, *args)


    def SetRelatedShapeAspect(self, *args):
        """
        SetRelatedShapeAspect(Handle_StepShape_AngularLocation self, Handle_StepRepr_ShapeAspect RelatedShapeAspect)

        Set field RelatedShapeAspect

        :type RelatedShapeAspect: OCC.wrapper.StepRepr.Handle_StepRepr_ShapeAspect

        """
        return _StepShape.Handle_StepShape_AngularLocation_SetRelatedShapeAspect(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepShape_AngularLocation self)

        Memory deallocator for transient classes


        """
        return _StepShape.Handle_StepShape_AngularLocation_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepShape_AngularLocation self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepShape_AngularLocation self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.Handle_StepShape_AngularLocation_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepShape_AngularLocation self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepShape_AngularLocation self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.Handle_StepShape_AngularLocation_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepShape_AngularLocation self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepShape.Handle_StepShape_AngularLocation_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepShape_AngularLocation self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_AngularLocation_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepShape_AngularLocation self)

        Increments the reference counter of this object


        """
        return _StepShape.Handle_StepShape_AngularLocation_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepShape_AngularLocation self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_AngularLocation_DecrementRefCounter(self, *args)

Handle_StepShape_AngularLocation_swigregister = _StepShape.Handle_StepShape_AngularLocation_swigregister
Handle_StepShape_AngularLocation_swigregister(Handle_StepShape_AngularLocation)

def Handle_StepShape_AngularLocation_DownCast(thing):
    return _StepShape.Handle_StepShape_AngularLocation_DownCast(thing)
Handle_StepShape_AngularLocation_DownCast = _StepShape.Handle_StepShape_AngularLocation_DownCast

class Handle_StepShape_OrientedPath(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepShape_OrientedPath self)

        Nullify the handle


        """
        return _StepShape.Handle_StepShape_OrientedPath_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepShape_OrientedPath self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepShape.Handle_StepShape_OrientedPath_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepShape_OrientedPath self, StepShape_OrientedPath thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepShape.Handle_StepShape_OrientedPath_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepShape_OrientedPath self, Handle_StepShape_OrientedPath theHandle) -> Handle_StepShape_OrientedPath
        assign(Handle_StepShape_OrientedPath self, StepShape_OrientedPath thePtr) -> Handle_StepShape_OrientedPath
        assign(Handle_StepShape_OrientedPath self, Handle_StepShape_OrientedPath theHandle) -> Handle_StepShape_OrientedPath

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepShape.Handle_StepShape_OrientedPath_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepShape_OrientedPath self) -> StepShape_OrientedPath

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepShape.Handle_StepShape_OrientedPath_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepShape_OrientedPath self) -> StepShape_OrientedPath

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepShape.Handle_StepShape_OrientedPath___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepShape_OrientedPath self) -> StepShape_OrientedPath

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepShape.Handle_StepShape_OrientedPath___ref__(self, *args)


    def __hash__(self):
        return _StepShape.Handle_StepShape_OrientedPath___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepShape.Handle_StepShape_OrientedPath___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepShape.new_Handle_StepShape_OrientedPath(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepShape.Handle_StepShape_OrientedPath_DownCast)
    __swig_destroy__ = _StepShape.delete_Handle_StepShape_OrientedPath

    def Init(self, *args):
        """
        Init(Handle_StepShape_OrientedPath self, Handle_TCollection_HAsciiString aName, Handle_StepShape_EdgeLoop aPathElement, Standard_Boolean const aOrientation)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aPathElement: OCC.wrapper.StepShape.Handle_StepShape_EdgeLoop
        :type aOrientation: bool

        """
        return _StepShape.Handle_StepShape_OrientedPath_Init(self, *args)


    def SetPathElement(self, *args):
        """
        SetPathElement(Handle_StepShape_OrientedPath self, Handle_StepShape_EdgeLoop aPathElement)

        :type aPathElement: OCC.wrapper.StepShape.Handle_StepShape_EdgeLoop

        """
        return _StepShape.Handle_StepShape_OrientedPath_SetPathElement(self, *args)


    def PathElement(self, *args):
        """
        PathElement(Handle_StepShape_OrientedPath self) -> Handle_StepShape_EdgeLoop

        :rtype: OCC.wrapper.StepShape.Handle_StepShape_EdgeLoop

        """
        return _StepShape.Handle_StepShape_OrientedPath_PathElement(self, *args)


    def SetOrientation(self, *args):
        """
        SetOrientation(Handle_StepShape_OrientedPath self, Standard_Boolean const aOrientation)

        :type aOrientation: bool

        """
        return _StepShape.Handle_StepShape_OrientedPath_SetOrientation(self, *args)


    def Orientation(self, *args):
        """
        Orientation(Handle_StepShape_OrientedPath self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.Handle_StepShape_OrientedPath_Orientation(self, *args)


    def SetEdgeList(self, *args):
        """
        SetEdgeList(Handle_StepShape_OrientedPath self, Handle_StepShape_HArray1OfOrientedEdge aEdgeList)

        :type aEdgeList: OCC.wrapper.StepShape.Handle_StepShape_HArray1OfOrientedEdge

        """
        return _StepShape.Handle_StepShape_OrientedPath_SetEdgeList(self, *args)


    def EdgeList(self, *args):
        """
        EdgeList(Handle_StepShape_OrientedPath self) -> Handle_StepShape_HArray1OfOrientedEdge

        :rtype: OCC.wrapper.StepShape.Handle_StepShape_HArray1OfOrientedEdge

        """
        return _StepShape.Handle_StepShape_OrientedPath_EdgeList(self, *args)


    def EdgeListValue(self, *args):
        """
        EdgeListValue(Handle_StepShape_OrientedPath self, Standard_Integer const num) -> Handle_StepShape_OrientedEdge

        :type num: int
        :rtype: OCC.wrapper.StepShape.Handle_StepShape_OrientedEdge

        """
        return _StepShape.Handle_StepShape_OrientedPath_EdgeListValue(self, *args)


    def NbEdgeList(self, *args):
        """
        NbEdgeList(Handle_StepShape_OrientedPath self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_OrientedPath_NbEdgeList(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepShape_OrientedPath self) -> char const *

        :rtype: const char *

        """
        return _StepShape.Handle_StepShape_OrientedPath_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.Handle_StepShape_OrientedPath_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.Handle_StepShape_OrientedPath_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetName(self, *args):
        """
        SetName(Handle_StepShape_OrientedPath self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepShape.Handle_StepShape_OrientedPath_SetName(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepShape_OrientedPath self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepShape.Handle_StepShape_OrientedPath_Name(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepShape_OrientedPath self)

        Memory deallocator for transient classes


        """
        return _StepShape.Handle_StepShape_OrientedPath_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepShape_OrientedPath self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepShape_OrientedPath self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.Handle_StepShape_OrientedPath_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepShape_OrientedPath self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepShape_OrientedPath self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.Handle_StepShape_OrientedPath_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepShape_OrientedPath self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepShape.Handle_StepShape_OrientedPath_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepShape_OrientedPath self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_OrientedPath_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepShape_OrientedPath self)

        Increments the reference counter of this object


        """
        return _StepShape.Handle_StepShape_OrientedPath_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepShape_OrientedPath self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_OrientedPath_DecrementRefCounter(self, *args)

Handle_StepShape_OrientedPath_swigregister = _StepShape.Handle_StepShape_OrientedPath_swigregister
Handle_StepShape_OrientedPath_swigregister(Handle_StepShape_OrientedPath)

def Handle_StepShape_OrientedPath_DownCast(thing):
    return _StepShape.Handle_StepShape_OrientedPath_DownCast(thing)
Handle_StepShape_OrientedPath_DownCast = _StepShape.Handle_StepShape_OrientedPath_DownCast

class Handle_StepShape_BrepWithVoids(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepShape_BrepWithVoids self)

        Nullify the handle


        """
        return _StepShape.Handle_StepShape_BrepWithVoids_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepShape_BrepWithVoids self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepShape.Handle_StepShape_BrepWithVoids_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepShape_BrepWithVoids self, StepShape_BrepWithVoids thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepShape.Handle_StepShape_BrepWithVoids_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepShape_BrepWithVoids self, Handle_StepShape_BrepWithVoids theHandle) -> Handle_StepShape_BrepWithVoids
        assign(Handle_StepShape_BrepWithVoids self, StepShape_BrepWithVoids thePtr) -> Handle_StepShape_BrepWithVoids
        assign(Handle_StepShape_BrepWithVoids self, Handle_StepShape_BrepWithVoids theHandle) -> Handle_StepShape_BrepWithVoids

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepShape.Handle_StepShape_BrepWithVoids_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepShape_BrepWithVoids self) -> StepShape_BrepWithVoids

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepShape.Handle_StepShape_BrepWithVoids_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepShape_BrepWithVoids self) -> StepShape_BrepWithVoids

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepShape.Handle_StepShape_BrepWithVoids___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepShape_BrepWithVoids self) -> StepShape_BrepWithVoids

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepShape.Handle_StepShape_BrepWithVoids___ref__(self, *args)


    def __hash__(self):
        return _StepShape.Handle_StepShape_BrepWithVoids___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepShape.Handle_StepShape_BrepWithVoids___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepShape.new_Handle_StepShape_BrepWithVoids(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepShape.Handle_StepShape_BrepWithVoids_DownCast)
    __swig_destroy__ = _StepShape.delete_Handle_StepShape_BrepWithVoids

    def Init(self, *args):
        """
        Init(Handle_StepShape_BrepWithVoids self, Handle_TCollection_HAsciiString aName, Handle_StepShape_ClosedShell aOuter, Handle_StepShape_HArray1OfOrientedClosedShell aVoids)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aOuter: OCC.wrapper.StepShape.Handle_StepShape_ClosedShell
        :type aVoids: OCC.wrapper.StepShape.Handle_StepShape_HArray1OfOrientedClosedShell

        """
        return _StepShape.Handle_StepShape_BrepWithVoids_Init(self, *args)


    def SetVoids(self, *args):
        """
        SetVoids(Handle_StepShape_BrepWithVoids self, Handle_StepShape_HArray1OfOrientedClosedShell aVoids)

        :type aVoids: OCC.wrapper.StepShape.Handle_StepShape_HArray1OfOrientedClosedShell

        """
        return _StepShape.Handle_StepShape_BrepWithVoids_SetVoids(self, *args)


    def Voids(self, *args):
        """
        Voids(Handle_StepShape_BrepWithVoids self) -> Handle_StepShape_HArray1OfOrientedClosedShell

        :rtype: OCC.wrapper.StepShape.Handle_StepShape_HArray1OfOrientedClosedShell

        """
        return _StepShape.Handle_StepShape_BrepWithVoids_Voids(self, *args)


    def VoidsValue(self, *args):
        """
        VoidsValue(Handle_StepShape_BrepWithVoids self, Standard_Integer const num) -> Handle_StepShape_OrientedClosedShell

        :type num: int
        :rtype: OCC.wrapper.StepShape.Handle_StepShape_OrientedClosedShell

        """
        return _StepShape.Handle_StepShape_BrepWithVoids_VoidsValue(self, *args)


    def NbVoids(self, *args):
        """
        NbVoids(Handle_StepShape_BrepWithVoids self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_BrepWithVoids_NbVoids(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepShape_BrepWithVoids self) -> char const *

        :rtype: const char *

        """
        return _StepShape.Handle_StepShape_BrepWithVoids_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.Handle_StepShape_BrepWithVoids_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.Handle_StepShape_BrepWithVoids_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetOuter(self, *args):
        """
        SetOuter(Handle_StepShape_BrepWithVoids self, Handle_StepShape_ConnectedFaceSet aOuter)

        :type aOuter: OCC.wrapper.StepShape.Handle_StepShape_ConnectedFaceSet

        """
        return _StepShape.Handle_StepShape_BrepWithVoids_SetOuter(self, *args)


    def Outer(self, *args):
        """
        Outer(Handle_StepShape_BrepWithVoids self) -> Handle_StepShape_ConnectedFaceSet

        :rtype: OCC.wrapper.StepShape.Handle_StepShape_ConnectedFaceSet

        """
        return _StepShape.Handle_StepShape_BrepWithVoids_Outer(self, *args)


    def SetName(self, *args):
        """
        SetName(Handle_StepShape_BrepWithVoids self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepShape.Handle_StepShape_BrepWithVoids_SetName(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepShape_BrepWithVoids self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepShape.Handle_StepShape_BrepWithVoids_Name(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepShape_BrepWithVoids self)

        Memory deallocator for transient classes


        """
        return _StepShape.Handle_StepShape_BrepWithVoids_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepShape_BrepWithVoids self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepShape_BrepWithVoids self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.Handle_StepShape_BrepWithVoids_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepShape_BrepWithVoids self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepShape_BrepWithVoids self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.Handle_StepShape_BrepWithVoids_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepShape_BrepWithVoids self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepShape.Handle_StepShape_BrepWithVoids_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepShape_BrepWithVoids self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_BrepWithVoids_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepShape_BrepWithVoids self)

        Increments the reference counter of this object


        """
        return _StepShape.Handle_StepShape_BrepWithVoids_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepShape_BrepWithVoids self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_BrepWithVoids_DecrementRefCounter(self, *args)

Handle_StepShape_BrepWithVoids_swigregister = _StepShape.Handle_StepShape_BrepWithVoids_swigregister
Handle_StepShape_BrepWithVoids_swigregister(Handle_StepShape_BrepWithVoids)

def Handle_StepShape_BrepWithVoids_DownCast(thing):
    return _StepShape.Handle_StepShape_BrepWithVoids_DownCast(thing)
Handle_StepShape_BrepWithVoids_DownCast = _StepShape.Handle_StepShape_BrepWithVoids_DownCast

class Handle_StepShape_HArray1OfConnectedFaceSet(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepShape_HArray1OfConnectedFaceSet self)

        Nullify the handle


        """
        return _StepShape.Handle_StepShape_HArray1OfConnectedFaceSet_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepShape_HArray1OfConnectedFaceSet self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepShape.Handle_StepShape_HArray1OfConnectedFaceSet_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepShape_HArray1OfConnectedFaceSet self, StepShape_HArray1OfConnectedFaceSet thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepShape.Handle_StepShape_HArray1OfConnectedFaceSet_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepShape_HArray1OfConnectedFaceSet self, Handle_StepShape_HArray1OfConnectedFaceSet theHandle) -> Handle_StepShape_HArray1OfConnectedFaceSet
        assign(Handle_StepShape_HArray1OfConnectedFaceSet self, StepShape_HArray1OfConnectedFaceSet thePtr) -> Handle_StepShape_HArray1OfConnectedFaceSet
        assign(Handle_StepShape_HArray1OfConnectedFaceSet self, Handle_StepShape_HArray1OfConnectedFaceSet theHandle) -> Handle_StepShape_HArray1OfConnectedFaceSet

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepShape.Handle_StepShape_HArray1OfConnectedFaceSet_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepShape_HArray1OfConnectedFaceSet self) -> StepShape_HArray1OfConnectedFaceSet

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepShape.Handle_StepShape_HArray1OfConnectedFaceSet_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepShape_HArray1OfConnectedFaceSet self) -> StepShape_HArray1OfConnectedFaceSet

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepShape.Handle_StepShape_HArray1OfConnectedFaceSet___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepShape_HArray1OfConnectedFaceSet self) -> StepShape_HArray1OfConnectedFaceSet

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepShape.Handle_StepShape_HArray1OfConnectedFaceSet___ref__(self, *args)


    def __hash__(self):
        return _StepShape.Handle_StepShape_HArray1OfConnectedFaceSet___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepShape.Handle_StepShape_HArray1OfConnectedFaceSet___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepShape.new_Handle_StepShape_HArray1OfConnectedFaceSet(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepShape.Handle_StepShape_HArray1OfConnectedFaceSet_DownCast)
    __swig_destroy__ = _StepShape.delete_Handle_StepShape_HArray1OfConnectedFaceSet

    def Array1(self, *args):
        """
        :rtype: OCC.wrapper.StepShape.StepShape_Array1OfConnectedFaceSet

        """
        res = _StepShape.Handle_StepShape_HArray1OfConnectedFaceSet_Array1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeArray1(self, *args):
        """
        ChangeArray1(Handle_StepShape_HArray1OfConnectedFaceSet self) -> NCollection_Array1_Handle_StepShape_ConnectedFaceSet

        :rtype: OCC.wrapper.StepShape.StepShape_Array1OfConnectedFaceSet

        """
        return _StepShape.Handle_StepShape_HArray1OfConnectedFaceSet_ChangeArray1(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepShape_HArray1OfConnectedFaceSet self) -> char const *

        :rtype: const char *

        """
        return _StepShape.Handle_StepShape_HArray1OfConnectedFaceSet_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.Handle_StepShape_HArray1OfConnectedFaceSet_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.Handle_StepShape_HArray1OfConnectedFaceSet_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_StepShape_HArray1OfConnectedFaceSet self)

        Memory deallocator for transient classes


        """
        return _StepShape.Handle_StepShape_HArray1OfConnectedFaceSet_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepShape_HArray1OfConnectedFaceSet self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepShape_HArray1OfConnectedFaceSet self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.Handle_StepShape_HArray1OfConnectedFaceSet_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepShape_HArray1OfConnectedFaceSet self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepShape_HArray1OfConnectedFaceSet self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.Handle_StepShape_HArray1OfConnectedFaceSet_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepShape_HArray1OfConnectedFaceSet self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepShape.Handle_StepShape_HArray1OfConnectedFaceSet_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepShape_HArray1OfConnectedFaceSet self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_HArray1OfConnectedFaceSet_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepShape_HArray1OfConnectedFaceSet self)

        Increments the reference counter of this object


        """
        return _StepShape.Handle_StepShape_HArray1OfConnectedFaceSet_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepShape_HArray1OfConnectedFaceSet self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_HArray1OfConnectedFaceSet_DecrementRefCounter(self, *args)

Handle_StepShape_HArray1OfConnectedFaceSet_swigregister = _StepShape.Handle_StepShape_HArray1OfConnectedFaceSet_swigregister
Handle_StepShape_HArray1OfConnectedFaceSet_swigregister(Handle_StepShape_HArray1OfConnectedFaceSet)

def Handle_StepShape_HArray1OfConnectedFaceSet_DownCast(thing):
    return _StepShape.Handle_StepShape_HArray1OfConnectedFaceSet_DownCast(thing)
Handle_StepShape_HArray1OfConnectedFaceSet_DownCast = _StepShape.Handle_StepShape_HArray1OfConnectedFaceSet_DownCast

class Handle_StepShape_ShapeRepresentationWithParameters(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepShape_ShapeRepresentationWithParameters self)

        Nullify the handle


        """
        return _StepShape.Handle_StepShape_ShapeRepresentationWithParameters_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepShape_ShapeRepresentationWithParameters self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepShape.Handle_StepShape_ShapeRepresentationWithParameters_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepShape_ShapeRepresentationWithParameters self, StepShape_ShapeRepresentationWithParameters thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepShape.Handle_StepShape_ShapeRepresentationWithParameters_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepShape_ShapeRepresentationWithParameters self, Handle_StepShape_ShapeRepresentationWithParameters theHandle) -> Handle_StepShape_ShapeRepresentationWithParameters
        assign(Handle_StepShape_ShapeRepresentationWithParameters self, StepShape_ShapeRepresentationWithParameters thePtr) -> Handle_StepShape_ShapeRepresentationWithParameters
        assign(Handle_StepShape_ShapeRepresentationWithParameters self, Handle_StepShape_ShapeRepresentationWithParameters theHandle) -> Handle_StepShape_ShapeRepresentationWithParameters

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepShape.Handle_StepShape_ShapeRepresentationWithParameters_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepShape_ShapeRepresentationWithParameters self) -> StepShape_ShapeRepresentationWithParameters

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepShape.Handle_StepShape_ShapeRepresentationWithParameters_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepShape_ShapeRepresentationWithParameters self) -> StepShape_ShapeRepresentationWithParameters

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepShape.Handle_StepShape_ShapeRepresentationWithParameters___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepShape_ShapeRepresentationWithParameters self) -> StepShape_ShapeRepresentationWithParameters

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepShape.Handle_StepShape_ShapeRepresentationWithParameters___ref__(self, *args)


    def __hash__(self):
        return _StepShape.Handle_StepShape_ShapeRepresentationWithParameters___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepShape.Handle_StepShape_ShapeRepresentationWithParameters___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepShape.new_Handle_StepShape_ShapeRepresentationWithParameters(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepShape.Handle_StepShape_ShapeRepresentationWithParameters_DownCast)
    __swig_destroy__ = _StepShape.delete_Handle_StepShape_ShapeRepresentationWithParameters

    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepShape_ShapeRepresentationWithParameters self) -> char const *

        :rtype: const char *

        """
        return _StepShape.Handle_StepShape_ShapeRepresentationWithParameters_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.Handle_StepShape_ShapeRepresentationWithParameters_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.Handle_StepShape_ShapeRepresentationWithParameters_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Init(self, *args):
        """
        Init(Handle_StepShape_ShapeRepresentationWithParameters self, Handle_TCollection_HAsciiString aName, Handle_StepRepr_HArray1OfRepresentationItem aItems, Handle_StepRepr_RepresentationContext aContextOfItems)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aItems: OCC.wrapper.StepRepr.Handle_StepRepr_HArray1OfRepresentationItem
        :type aContextOfItems: OCC.wrapper.StepRepr.Handle_StepRepr_RepresentationContext

        """
        return _StepShape.Handle_StepShape_ShapeRepresentationWithParameters_Init(self, *args)


    def SetName(self, *args):
        """
        SetName(Handle_StepShape_ShapeRepresentationWithParameters self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepShape.Handle_StepShape_ShapeRepresentationWithParameters_SetName(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepShape_ShapeRepresentationWithParameters self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepShape.Handle_StepShape_ShapeRepresentationWithParameters_Name(self, *args)


    def SetItems(self, *args):
        """
        SetItems(Handle_StepShape_ShapeRepresentationWithParameters self, Handle_StepRepr_HArray1OfRepresentationItem aItems)

        :type aItems: OCC.wrapper.StepRepr.Handle_StepRepr_HArray1OfRepresentationItem

        """
        return _StepShape.Handle_StepShape_ShapeRepresentationWithParameters_SetItems(self, *args)


    def Items(self, *args):
        """
        Items(Handle_StepShape_ShapeRepresentationWithParameters self) -> Handle_StepRepr_HArray1OfRepresentationItem

        :rtype: OCC.wrapper.StepRepr.Handle_StepRepr_HArray1OfRepresentationItem

        """
        return _StepShape.Handle_StepShape_ShapeRepresentationWithParameters_Items(self, *args)


    def ItemsValue(self, *args):
        """
        ItemsValue(Handle_StepShape_ShapeRepresentationWithParameters self, Standard_Integer const num) -> Handle_StepRepr_RepresentationItem

        :type num: int
        :rtype: OCC.wrapper.StepRepr.Handle_StepRepr_RepresentationItem

        """
        return _StepShape.Handle_StepShape_ShapeRepresentationWithParameters_ItemsValue(self, *args)


    def NbItems(self, *args):
        """
        NbItems(Handle_StepShape_ShapeRepresentationWithParameters self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_ShapeRepresentationWithParameters_NbItems(self, *args)


    def SetContextOfItems(self, *args):
        """
        SetContextOfItems(Handle_StepShape_ShapeRepresentationWithParameters self, Handle_StepRepr_RepresentationContext aContextOfItems)

        :type aContextOfItems: OCC.wrapper.StepRepr.Handle_StepRepr_RepresentationContext

        """
        return _StepShape.Handle_StepShape_ShapeRepresentationWithParameters_SetContextOfItems(self, *args)


    def ContextOfItems(self, *args):
        """
        ContextOfItems(Handle_StepShape_ShapeRepresentationWithParameters self) -> Handle_StepRepr_RepresentationContext

        :rtype: OCC.wrapper.StepRepr.Handle_StepRepr_RepresentationContext

        """
        return _StepShape.Handle_StepShape_ShapeRepresentationWithParameters_ContextOfItems(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepShape_ShapeRepresentationWithParameters self)

        Memory deallocator for transient classes


        """
        return _StepShape.Handle_StepShape_ShapeRepresentationWithParameters_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepShape_ShapeRepresentationWithParameters self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepShape_ShapeRepresentationWithParameters self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.Handle_StepShape_ShapeRepresentationWithParameters_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepShape_ShapeRepresentationWithParameters self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepShape_ShapeRepresentationWithParameters self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.Handle_StepShape_ShapeRepresentationWithParameters_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepShape_ShapeRepresentationWithParameters self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepShape.Handle_StepShape_ShapeRepresentationWithParameters_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepShape_ShapeRepresentationWithParameters self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_ShapeRepresentationWithParameters_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepShape_ShapeRepresentationWithParameters self)

        Increments the reference counter of this object


        """
        return _StepShape.Handle_StepShape_ShapeRepresentationWithParameters_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepShape_ShapeRepresentationWithParameters self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_ShapeRepresentationWithParameters_DecrementRefCounter(self, *args)

Handle_StepShape_ShapeRepresentationWithParameters_swigregister = _StepShape.Handle_StepShape_ShapeRepresentationWithParameters_swigregister
Handle_StepShape_ShapeRepresentationWithParameters_swigregister(Handle_StepShape_ShapeRepresentationWithParameters)

def Handle_StepShape_ShapeRepresentationWithParameters_DownCast(thing):
    return _StepShape.Handle_StepShape_ShapeRepresentationWithParameters_DownCast(thing)
Handle_StepShape_ShapeRepresentationWithParameters_DownCast = _StepShape.Handle_StepShape_ShapeRepresentationWithParameters_DownCast

class NCollection_Array1_Handle_StepShape_Face(object):
    """
    Purpose:     The class Array1 represents unidimensional arrays 
    of fixed size known at run time. 
    The range of the index is user defined.
    An array1 can be constructed with a "C array".
    This functionality is useful to call methods expecting
    an Array1. It allows to carry the bounds inside the arrays.

    Examples:    Item tab[100]; //  An example with a C array
    Array1OfItem ttab (tab[0],1,100);

    Array1OfItem tttab (ttab(10),10,20); // a slice of ttab

    If you want to reindex an array from 1 to Length do :

    Array1 tab1(tab(tab.Lower()),1,tab.Length());

    Warning:     Programs client of such a class must be independant
    of the range of the first element. Then, a C++ for
    loop must be written like this

    for (i = A.Lower(); i <= A.Upper(); i++)

    Changes:     In  comparison  to  TCollection  the  flag  isAllocated  was
    renamed into myDeletable (alike in  the Array2).  For naming
    compatibility the method IsAllocated remained in class along
    with IsDeletable.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Array1_Handle_StepShape_Face self) -> NCollection_Array1< opencascade::handle< StepShape_Face > >::iterator

        Returns an iterator pointing to the first element in the array.

        :rtype: iterator

        """
        return _StepShape.NCollection_Array1_Handle_StepShape_Face_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Array1_Handle_StepShape_Face self) -> NCollection_Array1< opencascade::handle< StepShape_Face > >::iterator

        Returns an iterator referring to the past-the-end element in the array.

        :rtype: iterator

        """
        return _StepShape.NCollection_Array1_Handle_StepShape_Face_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Array1_Handle_StepShape_Face self) -> NCollection_Array1< opencascade::handle< StepShape_Face > >::const_iterator

        Returns a const iterator pointing to the first element in the array.

        :rtype: const_iterator

        """
        return _StepShape.NCollection_Array1_Handle_StepShape_Face_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Array1_Handle_StepShape_Face self) -> NCollection_Array1< opencascade::handle< StepShape_Face > >::const_iterator

        Returns a const iterator referring to the past-the-end element in the array.

        :rtype: const_iterator

        """
        return _StepShape.NCollection_Array1_Handle_StepShape_Face_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     The class Array1 represents unidimensional arrays 
        of fixed size known at run time. 
        The range of the index is user defined.
        An array1 can be constructed with a "C array".
        This functionality is useful to call methods expecting
        an Array1. It allows to carry the bounds inside the arrays.

        Examples:    Item tab[100]; //  An example with a C array
        Array1OfItem ttab (tab[0],1,100);

        Array1OfItem tttab (ttab(10),10,20); // a slice of ttab

        If you want to reindex an array from 1 to Length do :

        Array1 tab1(tab(tab.Lower()),1,tab.Length());

        Warning:     Programs client of such a class must be independant
        of the range of the first element. Then, a C++ for
        loop must be written like this

        for (i = A.Lower(); i <= A.Upper(); i++)

        Changes:     In  comparison  to  TCollection  the  flag  isAllocated  was
        renamed into myDeletable (alike in  the Array2).  For naming
        compatibility the method IsAllocated remained in class along
        with IsDeletable.
        """
        this = _StepShape.new_NCollection_Array1_Handle_StepShape_Face(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(NCollection_Array1_Handle_StepShape_Face self, Handle_StepShape_Face theValue)

        Initialise the items with theValue

        :type theValue: const TheItemType &

        """
        return _StepShape.NCollection_Array1_Handle_StepShape_Face_Init(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_Array1_Handle_StepShape_Face self) -> Standard_Integer

        Size query

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.NCollection_Array1_Handle_StepShape_Face_Size(self, *args)


    def Length(self, *args):
        """
        Length(NCollection_Array1_Handle_StepShape_Face self) -> Standard_Integer

        Length query (the same)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.NCollection_Array1_Handle_StepShape_Face_Length(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Array1_Handle_StepShape_Face self) -> Standard_Boolean

        Return TRUE if array has zero length.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.NCollection_Array1_Handle_StepShape_Face_IsEmpty(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Array1_Handle_StepShape_Face self) -> Standard_Integer

        Lower bound

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.NCollection_Array1_Handle_StepShape_Face_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Array1_Handle_StepShape_Face self) -> Standard_Integer

        Upper bound

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.NCollection_Array1_Handle_StepShape_Face_Upper(self, *args)


    def IsDeletable(self, *args):
        """
        IsDeletable(NCollection_Array1_Handle_StepShape_Face self) -> Standard_Boolean

        myDeletable flag

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.NCollection_Array1_Handle_StepShape_Face_IsDeletable(self, *args)


    def IsAllocated(self, *args):
        """
        IsAllocated(NCollection_Array1_Handle_StepShape_Face self) -> Standard_Boolean

        IsAllocated flag - for naming compatibility

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.NCollection_Array1_Handle_StepShape_Face_IsAllocated(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Array1_Handle_StepShape_Face self, NCollection_Array1_Handle_StepShape_Face theOther) -> NCollection_Array1_Handle_StepShape_Face

        Copies data of theOther array to this.
        This array should be pre-allocated and have the same length as theOther;
        otherwise exception Standard_DimensionMismatch is thrown.

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _StepShape.NCollection_Array1_Handle_StepShape_Face_Assign(self, *args)


    def Move(self, *args):
        """
        Move(NCollection_Array1_Handle_StepShape_Face self, NCollection_Array1_Handle_StepShape_Face theOther) -> NCollection_Array1_Handle_StepShape_Face

        Move assignment.
        This array will borrow all the data from theOther.
        The moved object will keep pointer to the memory buffer and
        range, but it will not free the buffer on destruction.

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _StepShape.NCollection_Array1_Handle_StepShape_Face_Move(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Array1_Handle_StepShape_Face self, NCollection_Array1_Handle_StepShape_Face theOther) -> NCollection_Array1_Handle_StepShape_Face
        assign(NCollection_Array1_Handle_StepShape_Face self, NCollection_Array1_Handle_StepShape_Face theOther) -> NCollection_Array1_Handle_StepShape_Face

        Move assignment operator; @sa Move()

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1<TheItemType> &&
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _StepShape.NCollection_Array1_Handle_StepShape_Face_assign(self, *args)


    def First(self, *args):
        """
        @return first element

        :rtype: const TheItemType &

        """
        res = _StepShape.NCollection_Array1_Handle_StepShape_Face_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Array1_Handle_StepShape_Face self) -> Handle_StepShape_Face

        @return first element

        :rtype: TheItemType &

        """
        return _StepShape.NCollection_Array1_Handle_StepShape_Face_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        @return last element

        :rtype: const TheItemType &

        """
        res = _StepShape.NCollection_Array1_Handle_StepShape_Face_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Array1_Handle_StepShape_Face self) -> Handle_StepShape_Face

        @return last element

        :rtype: TheItemType &

        """
        return _StepShape.NCollection_Array1_Handle_StepShape_Face_ChangeLast(self, *args)


    def Value(self, *args):
        """
        Constant value access

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _StepShape.NCollection_Array1_Handle_StepShape_Face_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Array1_Handle_StepShape_Face self, Standard_Integer const theIndex) -> Handle_StepShape_Face

        Variable value access

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _StepShape.NCollection_Array1_Handle_StepShape_Face_ChangeValue(self, *args)


    def __call__(self, *args):
        """
        operator() - alias to Value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _StepShape.NCollection_Array1_Handle_StepShape_Face___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __getitem__(self, *args):
        """
        operator[] - alias to Value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _StepShape.NCollection_Array1_Handle_StepShape_Face_at(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetValue(self, *args):
        """
        SetValue(NCollection_Array1_Handle_StepShape_Face self, Standard_Integer const theIndex, Handle_StepShape_Face theItem)

        Set value 

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _StepShape.NCollection_Array1_Handle_StepShape_Face_SetValue(self, *args)


    def Resize(self, *args):
        """
        Resize(NCollection_Array1_Handle_StepShape_Face self, Standard_Integer const theLower, Standard_Integer const theUpper, Standard_Boolean const theToCopyData)

        Resizes the array to specified bounds.
        No re-allocation will be done if length of array does not change,
        but existing values will not be discarded if theToCopyData set to FALSE.
        @param theLower new lower bound of array
        @param theUpper new upper bound of array
        @param theToCopyData flag to copy existing data into new array

        :type theLower: int
        :type theUpper: int
        :type theToCopyData: bool

        """
        return _StepShape.NCollection_Array1_Handle_StepShape_Face_Resize(self, *args)

    __swig_destroy__ = _StepShape.delete_NCollection_Array1_Handle_StepShape_Face
NCollection_Array1_Handle_StepShape_Face_swigregister = _StepShape.NCollection_Array1_Handle_StepShape_Face_swigregister
NCollection_Array1_Handle_StepShape_Face_swigregister(NCollection_Array1_Handle_StepShape_Face)


try:
	StepShape_Array1OfFace = NCollection_Array1_Handle_StepShape_Face
except NameError:
	pass # does not exist, probably ignored

class Handle_StepShape_SolidModel(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepShape_SolidModel self)

        Nullify the handle


        """
        return _StepShape.Handle_StepShape_SolidModel_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepShape_SolidModel self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepShape.Handle_StepShape_SolidModel_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepShape_SolidModel self, StepShape_SolidModel thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepShape.Handle_StepShape_SolidModel_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepShape_SolidModel self, Handle_StepShape_SolidModel theHandle) -> Handle_StepShape_SolidModel
        assign(Handle_StepShape_SolidModel self, StepShape_SolidModel thePtr) -> Handle_StepShape_SolidModel
        assign(Handle_StepShape_SolidModel self, Handle_StepShape_SolidModel theHandle) -> Handle_StepShape_SolidModel

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepShape.Handle_StepShape_SolidModel_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepShape_SolidModel self) -> StepShape_SolidModel

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepShape.Handle_StepShape_SolidModel_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepShape_SolidModel self) -> StepShape_SolidModel

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepShape.Handle_StepShape_SolidModel___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepShape_SolidModel self) -> StepShape_SolidModel

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepShape.Handle_StepShape_SolidModel___ref__(self, *args)


    def __hash__(self):
        return _StepShape.Handle_StepShape_SolidModel___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepShape.Handle_StepShape_SolidModel___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepShape.new_Handle_StepShape_SolidModel(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepShape.Handle_StepShape_SolidModel_DownCast)
    __swig_destroy__ = _StepShape.delete_Handle_StepShape_SolidModel

    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepShape_SolidModel self) -> char const *

        :rtype: const char *

        """
        return _StepShape.Handle_StepShape_SolidModel_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.Handle_StepShape_SolidModel_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.Handle_StepShape_SolidModel_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Init(self, *args):
        """
        Init(Handle_StepShape_SolidModel self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepShape.Handle_StepShape_SolidModel_Init(self, *args)


    def SetName(self, *args):
        """
        SetName(Handle_StepShape_SolidModel self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepShape.Handle_StepShape_SolidModel_SetName(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepShape_SolidModel self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepShape.Handle_StepShape_SolidModel_Name(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepShape_SolidModel self)

        Memory deallocator for transient classes


        """
        return _StepShape.Handle_StepShape_SolidModel_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepShape_SolidModel self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepShape_SolidModel self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.Handle_StepShape_SolidModel_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepShape_SolidModel self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepShape_SolidModel self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.Handle_StepShape_SolidModel_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepShape_SolidModel self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepShape.Handle_StepShape_SolidModel_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepShape_SolidModel self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_SolidModel_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepShape_SolidModel self)

        Increments the reference counter of this object


        """
        return _StepShape.Handle_StepShape_SolidModel_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepShape_SolidModel self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_SolidModel_DecrementRefCounter(self, *args)

Handle_StepShape_SolidModel_swigregister = _StepShape.Handle_StepShape_SolidModel_swigregister
Handle_StepShape_SolidModel_swigregister(Handle_StepShape_SolidModel)

def Handle_StepShape_SolidModel_DownCast(thing):
    return _StepShape.Handle_StepShape_SolidModel_DownCast(thing)
Handle_StepShape_SolidModel_DownCast = _StepShape.Handle_StepShape_SolidModel_DownCast

class StepShape_GeometricCurveSet(StepShape_GeometricSet):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepShape_GeometricCurveSet
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepShape_GeometricCurveSet(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepShape_GeometricCurveSet self) -> StepShape_GeometricCurveSet

        Returns a GeometricCurveSet


        """
        this = _StepShape.new_StepShape_GeometricCurveSet(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepShape.StepShape_GeometricCurveSet_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepShape.StepShape_GeometricCurveSet_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.StepShape_GeometricCurveSet_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepShape.delete_StepShape_GeometricCurveSet
StepShape_GeometricCurveSet_swigregister = _StepShape.StepShape_GeometricCurveSet_swigregister
StepShape_GeometricCurveSet_swigregister(StepShape_GeometricCurveSet)

def StepShape_GeometricCurveSet_get_type_name(*args):
    """
    StepShape_GeometricCurveSet_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepShape.StepShape_GeometricCurveSet_get_type_name(*args)

def StepShape_GeometricCurveSet_get_type_descriptor(*args):
    """
    StepShape_GeometricCurveSet_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepShape.StepShape_GeometricCurveSet_get_type_descriptor(*args)

class Handle_StepShape_VertexLoop(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepShape_VertexLoop self)

        Nullify the handle


        """
        return _StepShape.Handle_StepShape_VertexLoop_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepShape_VertexLoop self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepShape.Handle_StepShape_VertexLoop_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepShape_VertexLoop self, StepShape_VertexLoop thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepShape.Handle_StepShape_VertexLoop_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepShape_VertexLoop self, Handle_StepShape_VertexLoop theHandle) -> Handle_StepShape_VertexLoop
        assign(Handle_StepShape_VertexLoop self, StepShape_VertexLoop thePtr) -> Handle_StepShape_VertexLoop
        assign(Handle_StepShape_VertexLoop self, Handle_StepShape_VertexLoop theHandle) -> Handle_StepShape_VertexLoop

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepShape.Handle_StepShape_VertexLoop_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepShape_VertexLoop self) -> StepShape_VertexLoop

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepShape.Handle_StepShape_VertexLoop_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepShape_VertexLoop self) -> StepShape_VertexLoop

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepShape.Handle_StepShape_VertexLoop___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepShape_VertexLoop self) -> StepShape_VertexLoop

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepShape.Handle_StepShape_VertexLoop___ref__(self, *args)


    def __hash__(self):
        return _StepShape.Handle_StepShape_VertexLoop___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepShape.Handle_StepShape_VertexLoop___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepShape.new_Handle_StepShape_VertexLoop(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepShape.Handle_StepShape_VertexLoop_DownCast)
    __swig_destroy__ = _StepShape.delete_Handle_StepShape_VertexLoop

    def Init(self, *args):
        """
        Init(Handle_StepShape_VertexLoop self, Handle_TCollection_HAsciiString aName, Handle_StepShape_Vertex aLoopVertex)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aLoopVertex: OCC.wrapper.StepShape.Handle_StepShape_Vertex

        """
        return _StepShape.Handle_StepShape_VertexLoop_Init(self, *args)


    def SetLoopVertex(self, *args):
        """
        SetLoopVertex(Handle_StepShape_VertexLoop self, Handle_StepShape_Vertex aLoopVertex)

        :type aLoopVertex: OCC.wrapper.StepShape.Handle_StepShape_Vertex

        """
        return _StepShape.Handle_StepShape_VertexLoop_SetLoopVertex(self, *args)


    def LoopVertex(self, *args):
        """
        LoopVertex(Handle_StepShape_VertexLoop self) -> Handle_StepShape_Vertex

        :rtype: OCC.wrapper.StepShape.Handle_StepShape_Vertex

        """
        return _StepShape.Handle_StepShape_VertexLoop_LoopVertex(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepShape_VertexLoop self) -> char const *

        :rtype: const char *

        """
        return _StepShape.Handle_StepShape_VertexLoop_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.Handle_StepShape_VertexLoop_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.Handle_StepShape_VertexLoop_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetName(self, *args):
        """
        SetName(Handle_StepShape_VertexLoop self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepShape.Handle_StepShape_VertexLoop_SetName(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepShape_VertexLoop self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepShape.Handle_StepShape_VertexLoop_Name(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepShape_VertexLoop self)

        Memory deallocator for transient classes


        """
        return _StepShape.Handle_StepShape_VertexLoop_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepShape_VertexLoop self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepShape_VertexLoop self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.Handle_StepShape_VertexLoop_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepShape_VertexLoop self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepShape_VertexLoop self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.Handle_StepShape_VertexLoop_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepShape_VertexLoop self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepShape.Handle_StepShape_VertexLoop_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepShape_VertexLoop self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_VertexLoop_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepShape_VertexLoop self)

        Increments the reference counter of this object


        """
        return _StepShape.Handle_StepShape_VertexLoop_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepShape_VertexLoop self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_VertexLoop_DecrementRefCounter(self, *args)

Handle_StepShape_VertexLoop_swigregister = _StepShape.Handle_StepShape_VertexLoop_swigregister
Handle_StepShape_VertexLoop_swigregister(Handle_StepShape_VertexLoop)

def Handle_StepShape_VertexLoop_DownCast(thing):
    return _StepShape.Handle_StepShape_VertexLoop_DownCast(thing)
Handle_StepShape_VertexLoop_DownCast = _StepShape.Handle_StepShape_VertexLoop_DownCast

class StepShape_OrientedOpenShell(StepShape_OpenShell):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepShape_OrientedOpenShell
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepShape_OrientedOpenShell(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepShape_OrientedOpenShell self) -> StepShape_OrientedOpenShell

        Returns a OrientedOpenShell


        """
        this = _StepShape.new_StepShape_OrientedOpenShell(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepShape_OrientedOpenShell self, Handle_TCollection_HAsciiString aName, Handle_StepShape_OpenShell aOpenShellElement, Standard_Boolean const aOrientation)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aOpenShellElement: OCC.wrapper.StepShape.Handle_StepShape_OpenShell
        :type aOrientation: bool

        """
        return _StepShape.StepShape_OrientedOpenShell_Init(self, *args)


    def SetOpenShellElement(self, *args):
        """
        SetOpenShellElement(StepShape_OrientedOpenShell self, Handle_StepShape_OpenShell aOpenShellElement)

        :type aOpenShellElement: OCC.wrapper.StepShape.Handle_StepShape_OpenShell

        """
        return _StepShape.StepShape_OrientedOpenShell_SetOpenShellElement(self, *args)


    def OpenShellElement(self, *args):
        """
        OpenShellElement(StepShape_OrientedOpenShell self) -> Handle_StepShape_OpenShell

        :rtype: OCC.wrapper.StepShape.Handle_StepShape_OpenShell

        """
        return _StepShape.StepShape_OrientedOpenShell_OpenShellElement(self, *args)


    def SetOrientation(self, *args):
        """
        SetOrientation(StepShape_OrientedOpenShell self, Standard_Boolean const aOrientation)

        :type aOrientation: bool

        """
        return _StepShape.StepShape_OrientedOpenShell_SetOrientation(self, *args)


    def Orientation(self, *args):
        """
        Orientation(StepShape_OrientedOpenShell self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.StepShape_OrientedOpenShell_Orientation(self, *args)


    def SetCfsFaces(self, *args):
        """
        SetCfsFaces(StepShape_OrientedOpenShell self, Handle_StepShape_HArray1OfFace aCfsFaces)

        :type aCfsFaces: OCC.wrapper.StepShape.Handle_StepShape_HArray1OfFace

        """
        return _StepShape.StepShape_OrientedOpenShell_SetCfsFaces(self, *args)


    def CfsFaces(self, *args):
        """
        CfsFaces(StepShape_OrientedOpenShell self) -> Handle_StepShape_HArray1OfFace

        :rtype: OCC.wrapper.StepShape.Handle_StepShape_HArray1OfFace

        """
        return _StepShape.StepShape_OrientedOpenShell_CfsFaces(self, *args)


    def CfsFacesValue(self, *args):
        """
        CfsFacesValue(StepShape_OrientedOpenShell self, Standard_Integer const num) -> Handle_StepShape_Face

        :type num: int
        :rtype: OCC.wrapper.StepShape.Handle_StepShape_Face

        """
        return _StepShape.StepShape_OrientedOpenShell_CfsFacesValue(self, *args)


    def NbCfsFaces(self, *args):
        """
        NbCfsFaces(StepShape_OrientedOpenShell self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.StepShape_OrientedOpenShell_NbCfsFaces(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepShape.StepShape_OrientedOpenShell_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepShape.StepShape_OrientedOpenShell_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.StepShape_OrientedOpenShell_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepShape.delete_StepShape_OrientedOpenShell
StepShape_OrientedOpenShell_swigregister = _StepShape.StepShape_OrientedOpenShell_swigregister
StepShape_OrientedOpenShell_swigregister(StepShape_OrientedOpenShell)

def StepShape_OrientedOpenShell_get_type_name(*args):
    """
    StepShape_OrientedOpenShell_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepShape.StepShape_OrientedOpenShell_get_type_name(*args)

def StepShape_OrientedOpenShell_get_type_descriptor(*args):
    """
    StepShape_OrientedOpenShell_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepShape.StepShape_OrientedOpenShell_get_type_descriptor(*args)

class Handle_StepShape_Torus(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepShape_Torus self)

        Nullify the handle


        """
        return _StepShape.Handle_StepShape_Torus_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepShape_Torus self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepShape.Handle_StepShape_Torus_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepShape_Torus self, StepShape_Torus thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepShape.Handle_StepShape_Torus_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepShape_Torus self, Handle_StepShape_Torus theHandle) -> Handle_StepShape_Torus
        assign(Handle_StepShape_Torus self, StepShape_Torus thePtr) -> Handle_StepShape_Torus
        assign(Handle_StepShape_Torus self, Handle_StepShape_Torus theHandle) -> Handle_StepShape_Torus

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepShape.Handle_StepShape_Torus_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepShape_Torus self) -> StepShape_Torus

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepShape.Handle_StepShape_Torus_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepShape_Torus self) -> StepShape_Torus

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepShape.Handle_StepShape_Torus___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepShape_Torus self) -> StepShape_Torus

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepShape.Handle_StepShape_Torus___ref__(self, *args)


    def __hash__(self):
        return _StepShape.Handle_StepShape_Torus___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepShape.Handle_StepShape_Torus___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepShape.new_Handle_StepShape_Torus(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepShape.Handle_StepShape_Torus_DownCast)
    __swig_destroy__ = _StepShape.delete_Handle_StepShape_Torus

    def Init(self, *args):
        """
        Init(Handle_StepShape_Torus self, Handle_TCollection_HAsciiString aName, Handle_StepGeom_Axis1Placement aPosition, Standard_Real const aMajorRadius, Standard_Real const aMinorRadius)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aPosition: OCC.wrapper.StepShape.Handle_StepGeom_Axis1Placement
        :type aMajorRadius: float
        :type aMinorRadius: float

        """
        return _StepShape.Handle_StepShape_Torus_Init(self, *args)


    def SetPosition(self, *args):
        """
        SetPosition(Handle_StepShape_Torus self, Handle_StepGeom_Axis1Placement aPosition)

        :type aPosition: OCC.wrapper.StepShape.Handle_StepGeom_Axis1Placement

        """
        return _StepShape.Handle_StepShape_Torus_SetPosition(self, *args)


    def Position(self, *args):
        """
        Position(Handle_StepShape_Torus self) -> Handle_StepGeom_Axis1Placement

        :rtype: OCC.wrapper.StepShape.Handle_StepGeom_Axis1Placement

        """
        return _StepShape.Handle_StepShape_Torus_Position(self, *args)


    def SetMajorRadius(self, *args):
        """
        SetMajorRadius(Handle_StepShape_Torus self, Standard_Real const aMajorRadius)

        :type aMajorRadius: float

        """
        return _StepShape.Handle_StepShape_Torus_SetMajorRadius(self, *args)


    def MajorRadius(self, *args):
        """
        MajorRadius(Handle_StepShape_Torus self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _StepShape.Handle_StepShape_Torus_MajorRadius(self, *args)


    def SetMinorRadius(self, *args):
        """
        SetMinorRadius(Handle_StepShape_Torus self, Standard_Real const aMinorRadius)

        :type aMinorRadius: float

        """
        return _StepShape.Handle_StepShape_Torus_SetMinorRadius(self, *args)


    def MinorRadius(self, *args):
        """
        MinorRadius(Handle_StepShape_Torus self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _StepShape.Handle_StepShape_Torus_MinorRadius(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepShape_Torus self) -> char const *

        :rtype: const char *

        """
        return _StepShape.Handle_StepShape_Torus_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.Handle_StepShape_Torus_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.Handle_StepShape_Torus_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetName(self, *args):
        """
        SetName(Handle_StepShape_Torus self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepShape.Handle_StepShape_Torus_SetName(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepShape_Torus self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepShape.Handle_StepShape_Torus_Name(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepShape_Torus self)

        Memory deallocator for transient classes


        """
        return _StepShape.Handle_StepShape_Torus_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepShape_Torus self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepShape_Torus self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.Handle_StepShape_Torus_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepShape_Torus self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepShape_Torus self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.Handle_StepShape_Torus_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepShape_Torus self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepShape.Handle_StepShape_Torus_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepShape_Torus self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_Torus_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepShape_Torus self)

        Increments the reference counter of this object


        """
        return _StepShape.Handle_StepShape_Torus_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepShape_Torus self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_Torus_DecrementRefCounter(self, *args)

Handle_StepShape_Torus_swigregister = _StepShape.Handle_StepShape_Torus_swigregister
Handle_StepShape_Torus_swigregister(Handle_StepShape_Torus)

def Handle_StepShape_Torus_DownCast(thing):
    return _StepShape.Handle_StepShape_Torus_DownCast(thing)
Handle_StepShape_Torus_DownCast = _StepShape.Handle_StepShape_Torus_DownCast

class StepShape_BooleanOperand(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(StepShape_BooleanOperand self) -> StepShape_BooleanOperand

        Returns a BooleanOperand SelectType


        """
        this = _StepShape.new_StepShape_BooleanOperand(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def SetTypeOfContent(self, *args):
        """
        SetTypeOfContent(StepShape_BooleanOperand self, Standard_Integer const aTypeOfContent)

        :type aTypeOfContent: int

        """
        return _StepShape.StepShape_BooleanOperand_SetTypeOfContent(self, *args)


    def TypeOfContent(self, *args):
        """
        TypeOfContent(StepShape_BooleanOperand self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.StepShape_BooleanOperand_TypeOfContent(self, *args)


    def SolidModel(self, *args):
        """
        SolidModel(StepShape_BooleanOperand self) -> Handle_StepShape_SolidModel

        returns Value as a SolidModel (Null if another
        type)

        :rtype: OCC.wrapper.StepShape.Handle_StepShape_SolidModel

        """
        return _StepShape.StepShape_BooleanOperand_SolidModel(self, *args)


    def SetSolidModel(self, *args):
        """
        SetSolidModel(StepShape_BooleanOperand self, Handle_StepShape_SolidModel aSolidModel)

        :type aSolidModel: OCC.wrapper.StepShape.Handle_StepShape_SolidModel

        """
        return _StepShape.StepShape_BooleanOperand_SetSolidModel(self, *args)


    def HalfSpaceSolid(self, *args):
        """
        HalfSpaceSolid(StepShape_BooleanOperand self) -> Handle_StepShape_HalfSpaceSolid

        returns Value as a HalfSpaceSolid (Null if
        another type)

        :rtype: OCC.wrapper.StepShape.Handle_StepShape_HalfSpaceSolid

        """
        return _StepShape.StepShape_BooleanOperand_HalfSpaceSolid(self, *args)


    def SetHalfSpaceSolid(self, *args):
        """
        SetHalfSpaceSolid(StepShape_BooleanOperand self, Handle_StepShape_HalfSpaceSolid aHalfSpaceSolid)

        :type aHalfSpaceSolid: OCC.wrapper.StepShape.Handle_StepShape_HalfSpaceSolid

        """
        return _StepShape.StepShape_BooleanOperand_SetHalfSpaceSolid(self, *args)


    def CsgPrimitive(self, *args):
        """
        CsgPrimitive(StepShape_BooleanOperand self) -> StepShape_CsgPrimitive

        returns Value as a CsgPrimitive (Null if another
        type)
        CsgPrimitive is another Select Type

        :rtype: OCC.wrapper.StepShape.StepShape_CsgPrimitive

        """
        return _StepShape.StepShape_BooleanOperand_CsgPrimitive(self, *args)


    def SetCsgPrimitive(self, *args):
        """
        SetCsgPrimitive(StepShape_BooleanOperand self, StepShape_CsgPrimitive aCsgPrimitive)

        :type aCsgPrimitive: OCC.wrapper.StepShape.StepShape_CsgPrimitive

        """
        return _StepShape.StepShape_BooleanOperand_SetCsgPrimitive(self, *args)


    def BooleanResult(self, *args):
        """
        BooleanResult(StepShape_BooleanOperand self) -> Handle_StepShape_BooleanResult

        returns Value as a BooleanResult (Null if another
        type)

        :rtype: OCC.wrapper.StepShape.Handle_StepShape_BooleanResult

        """
        return _StepShape.StepShape_BooleanOperand_BooleanResult(self, *args)


    def SetBooleanResult(self, *args):
        """
        SetBooleanResult(StepShape_BooleanOperand self, Handle_StepShape_BooleanResult aBooleanResult)

        :type aBooleanResult: OCC.wrapper.StepShape.Handle_StepShape_BooleanResult

        """
        return _StepShape.StepShape_BooleanOperand_SetBooleanResult(self, *args)

    __swig_destroy__ = _StepShape.delete_StepShape_BooleanOperand
StepShape_BooleanOperand_swigregister = _StepShape.StepShape_BooleanOperand_swigregister
StepShape_BooleanOperand_swigregister(StepShape_BooleanOperand)

class StepShape_GeometricSetSelect(StepData.StepData_SelectType):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(StepShape_GeometricSetSelect self) -> StepShape_GeometricSetSelect

        Returns a GeometricSetSelect SelectType


        """
        this = _StepShape.new_StepShape_GeometricSetSelect(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def CaseNum(self, *args):
        """
        CaseNum(StepShape_GeometricSetSelect self, Handle_Standard_Transient ent) -> Standard_Integer

        Recognizes a GeometricSetSelect Kind Entity that is :
        1 -> Point
        2 -> Curve
        3 -> Surface
        0 else

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.StepShape_GeometricSetSelect_CaseNum(self, *args)


    def Point(self, *args):
        """
        Point(StepShape_GeometricSetSelect self) -> Handle_StepGeom_Point

        returns Value as a Point (Null if another type)

        :rtype: OCC.wrapper.StepShape.Handle_StepGeom_Point

        """
        return _StepShape.StepShape_GeometricSetSelect_Point(self, *args)


    def Curve(self, *args):
        """
        Curve(StepShape_GeometricSetSelect self) -> Handle_StepGeom_Curve

        returns Value as a Curve (Null if another type)

        :rtype: OCC.wrapper.StepShape.Handle_StepGeom_Curve

        """
        return _StepShape.StepShape_GeometricSetSelect_Curve(self, *args)


    def Surface(self, *args):
        """
        Surface(StepShape_GeometricSetSelect self) -> Handle_StepGeom_Surface

        returns Value as a Surface (Null if another type)

        :rtype: OCC.wrapper.StepShape.Handle_StepGeom_Surface

        """
        return _StepShape.StepShape_GeometricSetSelect_Surface(self, *args)

    __swig_destroy__ = _StepShape.delete_StepShape_GeometricSetSelect
StepShape_GeometricSetSelect_swigregister = _StepShape.StepShape_GeometricSetSelect_swigregister
StepShape_GeometricSetSelect_swigregister(StepShape_GeometricSetSelect)

class StepShape_ToleranceValue(Standard.Standard_Transient):
    """Added for Dimensional Tolerances"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepShape_ToleranceValue
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepShape_ToleranceValue(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepShape_ToleranceValue self) -> StepShape_ToleranceValue

        Added for Dimensional Tolerances
        """
        this = _StepShape.new_StepShape_ToleranceValue(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepShape_ToleranceValue self, Handle_StepBasic_MeasureWithUnit lower_bound, Handle_StepBasic_MeasureWithUnit upper_bound)

        :type lower_bound: OCC.wrapper.StepBasic.Handle_StepBasic_MeasureWithUnit
        :type upper_bound: OCC.wrapper.StepBasic.Handle_StepBasic_MeasureWithUnit

        """
        return _StepShape.StepShape_ToleranceValue_Init(self, *args)


    def LowerBound(self, *args):
        """
        LowerBound(StepShape_ToleranceValue self) -> Handle_StepBasic_MeasureWithUnit

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_MeasureWithUnit

        """
        return _StepShape.StepShape_ToleranceValue_LowerBound(self, *args)


    def SetLowerBound(self, *args):
        """
        SetLowerBound(StepShape_ToleranceValue self, Handle_StepBasic_MeasureWithUnit lower_bound)

        :type lower_bound: OCC.wrapper.StepBasic.Handle_StepBasic_MeasureWithUnit

        """
        return _StepShape.StepShape_ToleranceValue_SetLowerBound(self, *args)


    def UpperBound(self, *args):
        """
        UpperBound(StepShape_ToleranceValue self) -> Handle_StepBasic_MeasureWithUnit

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_MeasureWithUnit

        """
        return _StepShape.StepShape_ToleranceValue_UpperBound(self, *args)


    def SetUpperBound(self, *args):
        """
        SetUpperBound(StepShape_ToleranceValue self, Handle_StepBasic_MeasureWithUnit upper_bound)

        :type upper_bound: OCC.wrapper.StepBasic.Handle_StepBasic_MeasureWithUnit

        """
        return _StepShape.StepShape_ToleranceValue_SetUpperBound(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepShape.StepShape_ToleranceValue_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepShape.StepShape_ToleranceValue_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.StepShape_ToleranceValue_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepShape.delete_StepShape_ToleranceValue
StepShape_ToleranceValue_swigregister = _StepShape.StepShape_ToleranceValue_swigregister
StepShape_ToleranceValue_swigregister(StepShape_ToleranceValue)

def StepShape_ToleranceValue_get_type_name(*args):
    """
    StepShape_ToleranceValue_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepShape.StepShape_ToleranceValue_get_type_name(*args)

def StepShape_ToleranceValue_get_type_descriptor(*args):
    """
    StepShape_ToleranceValue_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepShape.StepShape_ToleranceValue_get_type_descriptor(*args)

class Handle_StepShape_Vertex(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepShape_Vertex self)

        Nullify the handle


        """
        return _StepShape.Handle_StepShape_Vertex_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepShape_Vertex self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepShape.Handle_StepShape_Vertex_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepShape_Vertex self, StepShape_Vertex thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepShape.Handle_StepShape_Vertex_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepShape_Vertex self, Handle_StepShape_Vertex theHandle) -> Handle_StepShape_Vertex
        assign(Handle_StepShape_Vertex self, StepShape_Vertex thePtr) -> Handle_StepShape_Vertex
        assign(Handle_StepShape_Vertex self, Handle_StepShape_Vertex theHandle) -> Handle_StepShape_Vertex

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepShape.Handle_StepShape_Vertex_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepShape_Vertex self) -> StepShape_Vertex

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepShape.Handle_StepShape_Vertex_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepShape_Vertex self) -> StepShape_Vertex

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepShape.Handle_StepShape_Vertex___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepShape_Vertex self) -> StepShape_Vertex

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepShape.Handle_StepShape_Vertex___ref__(self, *args)


    def __hash__(self):
        return _StepShape.Handle_StepShape_Vertex___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepShape.Handle_StepShape_Vertex___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepShape.new_Handle_StepShape_Vertex(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepShape.Handle_StepShape_Vertex_DownCast)
    __swig_destroy__ = _StepShape.delete_Handle_StepShape_Vertex

    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepShape_Vertex self) -> char const *

        :rtype: const char *

        """
        return _StepShape.Handle_StepShape_Vertex_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.Handle_StepShape_Vertex_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.Handle_StepShape_Vertex_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Init(self, *args):
        """
        Init(Handle_StepShape_Vertex self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepShape.Handle_StepShape_Vertex_Init(self, *args)


    def SetName(self, *args):
        """
        SetName(Handle_StepShape_Vertex self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepShape.Handle_StepShape_Vertex_SetName(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepShape_Vertex self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepShape.Handle_StepShape_Vertex_Name(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepShape_Vertex self)

        Memory deallocator for transient classes


        """
        return _StepShape.Handle_StepShape_Vertex_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepShape_Vertex self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepShape_Vertex self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.Handle_StepShape_Vertex_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepShape_Vertex self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepShape_Vertex self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.Handle_StepShape_Vertex_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepShape_Vertex self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepShape.Handle_StepShape_Vertex_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepShape_Vertex self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_Vertex_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepShape_Vertex self)

        Increments the reference counter of this object


        """
        return _StepShape.Handle_StepShape_Vertex_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepShape_Vertex self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_Vertex_DecrementRefCounter(self, *args)

Handle_StepShape_Vertex_swigregister = _StepShape.Handle_StepShape_Vertex_swigregister
Handle_StepShape_Vertex_swigregister(Handle_StepShape_Vertex)

def Handle_StepShape_Vertex_DownCast(thing):
    return _StepShape.Handle_StepShape_Vertex_DownCast(thing)
Handle_StepShape_Vertex_DownCast = _StepShape.Handle_StepShape_Vertex_DownCast

class Handle_StepShape_ConnectedFaceSubSet(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepShape_ConnectedFaceSubSet self)

        Nullify the handle


        """
        return _StepShape.Handle_StepShape_ConnectedFaceSubSet_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepShape_ConnectedFaceSubSet self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepShape.Handle_StepShape_ConnectedFaceSubSet_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepShape_ConnectedFaceSubSet self, StepShape_ConnectedFaceSubSet thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepShape.Handle_StepShape_ConnectedFaceSubSet_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepShape_ConnectedFaceSubSet self, Handle_StepShape_ConnectedFaceSubSet theHandle) -> Handle_StepShape_ConnectedFaceSubSet
        assign(Handle_StepShape_ConnectedFaceSubSet self, StepShape_ConnectedFaceSubSet thePtr) -> Handle_StepShape_ConnectedFaceSubSet
        assign(Handle_StepShape_ConnectedFaceSubSet self, Handle_StepShape_ConnectedFaceSubSet theHandle) -> Handle_StepShape_ConnectedFaceSubSet

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepShape.Handle_StepShape_ConnectedFaceSubSet_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepShape_ConnectedFaceSubSet self) -> StepShape_ConnectedFaceSubSet

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepShape.Handle_StepShape_ConnectedFaceSubSet_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepShape_ConnectedFaceSubSet self) -> StepShape_ConnectedFaceSubSet

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepShape.Handle_StepShape_ConnectedFaceSubSet___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepShape_ConnectedFaceSubSet self) -> StepShape_ConnectedFaceSubSet

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepShape.Handle_StepShape_ConnectedFaceSubSet___ref__(self, *args)


    def __hash__(self):
        return _StepShape.Handle_StepShape_ConnectedFaceSubSet___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepShape.Handle_StepShape_ConnectedFaceSubSet___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepShape.new_Handle_StepShape_ConnectedFaceSubSet(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepShape.Handle_StepShape_ConnectedFaceSubSet_DownCast)
    __swig_destroy__ = _StepShape.delete_Handle_StepShape_ConnectedFaceSubSet

    def Init(self, *args):
        """
        Init(Handle_StepShape_ConnectedFaceSubSet self, Handle_TCollection_HAsciiString aRepresentationItem_Name, Handle_StepShape_HArray1OfFace aConnectedFaceSet_CfsFaces, Handle_StepShape_ConnectedFaceSet aParentFaceSet)

        Initialize all fields (own and inherited)

        :type aRepresentationItem_Name: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aConnectedFaceSet_CfsFaces: OCC.wrapper.StepShape.Handle_StepShape_HArray1OfFace
        :type aParentFaceSet: OCC.wrapper.StepShape.Handle_StepShape_ConnectedFaceSet

        """
        return _StepShape.Handle_StepShape_ConnectedFaceSubSet_Init(self, *args)


    def ParentFaceSet(self, *args):
        """
        ParentFaceSet(Handle_StepShape_ConnectedFaceSubSet self) -> Handle_StepShape_ConnectedFaceSet

        Returns field ParentFaceSet

        :rtype: OCC.wrapper.StepShape.Handle_StepShape_ConnectedFaceSet

        """
        return _StepShape.Handle_StepShape_ConnectedFaceSubSet_ParentFaceSet(self, *args)


    def SetParentFaceSet(self, *args):
        """
        SetParentFaceSet(Handle_StepShape_ConnectedFaceSubSet self, Handle_StepShape_ConnectedFaceSet ParentFaceSet)

        Set field ParentFaceSet

        :type ParentFaceSet: OCC.wrapper.StepShape.Handle_StepShape_ConnectedFaceSet

        """
        return _StepShape.Handle_StepShape_ConnectedFaceSubSet_SetParentFaceSet(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepShape_ConnectedFaceSubSet self) -> char const *

        :rtype: const char *

        """
        return _StepShape.Handle_StepShape_ConnectedFaceSubSet_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.Handle_StepShape_ConnectedFaceSubSet_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.Handle_StepShape_ConnectedFaceSubSet_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetCfsFaces(self, *args):
        """
        SetCfsFaces(Handle_StepShape_ConnectedFaceSubSet self, Handle_StepShape_HArray1OfFace aCfsFaces)

        :type aCfsFaces: OCC.wrapper.StepShape.Handle_StepShape_HArray1OfFace

        """
        return _StepShape.Handle_StepShape_ConnectedFaceSubSet_SetCfsFaces(self, *args)


    def CfsFaces(self, *args):
        """
        CfsFaces(Handle_StepShape_ConnectedFaceSubSet self) -> Handle_StepShape_HArray1OfFace

        :rtype: OCC.wrapper.StepShape.Handle_StepShape_HArray1OfFace

        """
        return _StepShape.Handle_StepShape_ConnectedFaceSubSet_CfsFaces(self, *args)


    def CfsFacesValue(self, *args):
        """
        CfsFacesValue(Handle_StepShape_ConnectedFaceSubSet self, Standard_Integer const num) -> Handle_StepShape_Face

        :type num: int
        :rtype: OCC.wrapper.StepShape.Handle_StepShape_Face

        """
        return _StepShape.Handle_StepShape_ConnectedFaceSubSet_CfsFacesValue(self, *args)


    def NbCfsFaces(self, *args):
        """
        NbCfsFaces(Handle_StepShape_ConnectedFaceSubSet self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_ConnectedFaceSubSet_NbCfsFaces(self, *args)


    def SetName(self, *args):
        """
        SetName(Handle_StepShape_ConnectedFaceSubSet self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepShape.Handle_StepShape_ConnectedFaceSubSet_SetName(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepShape_ConnectedFaceSubSet self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepShape.Handle_StepShape_ConnectedFaceSubSet_Name(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepShape_ConnectedFaceSubSet self)

        Memory deallocator for transient classes


        """
        return _StepShape.Handle_StepShape_ConnectedFaceSubSet_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepShape_ConnectedFaceSubSet self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepShape_ConnectedFaceSubSet self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.Handle_StepShape_ConnectedFaceSubSet_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepShape_ConnectedFaceSubSet self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepShape_ConnectedFaceSubSet self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.Handle_StepShape_ConnectedFaceSubSet_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepShape_ConnectedFaceSubSet self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepShape.Handle_StepShape_ConnectedFaceSubSet_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepShape_ConnectedFaceSubSet self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_ConnectedFaceSubSet_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepShape_ConnectedFaceSubSet self)

        Increments the reference counter of this object


        """
        return _StepShape.Handle_StepShape_ConnectedFaceSubSet_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepShape_ConnectedFaceSubSet self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_ConnectedFaceSubSet_DecrementRefCounter(self, *args)

Handle_StepShape_ConnectedFaceSubSet_swigregister = _StepShape.Handle_StepShape_ConnectedFaceSubSet_swigregister
Handle_StepShape_ConnectedFaceSubSet_swigregister(Handle_StepShape_ConnectedFaceSubSet)

def Handle_StepShape_ConnectedFaceSubSet_DownCast(thing):
    return _StepShape.Handle_StepShape_ConnectedFaceSubSet_DownCast(thing)
Handle_StepShape_ConnectedFaceSubSet_DownCast = _StepShape.Handle_StepShape_ConnectedFaceSubSet_DownCast

class StepShape_TypeQualifier(Standard.Standard_Transient):
    """Added for Dimensional Tolerances"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepShape_TypeQualifier
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepShape_TypeQualifier(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepShape_TypeQualifier self) -> StepShape_TypeQualifier

        Added for Dimensional Tolerances
        """
        this = _StepShape.new_StepShape_TypeQualifier(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepShape_TypeQualifier self, Handle_TCollection_HAsciiString name)

        :type name: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepShape.StepShape_TypeQualifier_Init(self, *args)


    def Name(self, *args):
        """
        Name(StepShape_TypeQualifier self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepShape.StepShape_TypeQualifier_Name(self, *args)


    def SetName(self, *args):
        """
        SetName(StepShape_TypeQualifier self, Handle_TCollection_HAsciiString name)

        :type name: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepShape.StepShape_TypeQualifier_SetName(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepShape.StepShape_TypeQualifier_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepShape.StepShape_TypeQualifier_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.StepShape_TypeQualifier_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepShape.delete_StepShape_TypeQualifier
StepShape_TypeQualifier_swigregister = _StepShape.StepShape_TypeQualifier_swigregister
StepShape_TypeQualifier_swigregister(StepShape_TypeQualifier)

def StepShape_TypeQualifier_get_type_name(*args):
    """
    StepShape_TypeQualifier_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepShape.StepShape_TypeQualifier_get_type_name(*args)

def StepShape_TypeQualifier_get_type_descriptor(*args):
    """
    StepShape_TypeQualifier_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepShape.StepShape_TypeQualifier_get_type_descriptor(*args)

class Handle_StepShape_HArray1OfFace(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepShape_HArray1OfFace self)

        Nullify the handle


        """
        return _StepShape.Handle_StepShape_HArray1OfFace_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepShape_HArray1OfFace self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepShape.Handle_StepShape_HArray1OfFace_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepShape_HArray1OfFace self, StepShape_HArray1OfFace thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepShape.Handle_StepShape_HArray1OfFace_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepShape_HArray1OfFace self, Handle_StepShape_HArray1OfFace theHandle) -> Handle_StepShape_HArray1OfFace
        assign(Handle_StepShape_HArray1OfFace self, StepShape_HArray1OfFace thePtr) -> Handle_StepShape_HArray1OfFace
        assign(Handle_StepShape_HArray1OfFace self, Handle_StepShape_HArray1OfFace theHandle) -> Handle_StepShape_HArray1OfFace

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepShape.Handle_StepShape_HArray1OfFace_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepShape_HArray1OfFace self) -> StepShape_HArray1OfFace

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepShape.Handle_StepShape_HArray1OfFace_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepShape_HArray1OfFace self) -> StepShape_HArray1OfFace

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepShape.Handle_StepShape_HArray1OfFace___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepShape_HArray1OfFace self) -> StepShape_HArray1OfFace

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepShape.Handle_StepShape_HArray1OfFace___ref__(self, *args)


    def __hash__(self):
        return _StepShape.Handle_StepShape_HArray1OfFace___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepShape.Handle_StepShape_HArray1OfFace___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepShape.new_Handle_StepShape_HArray1OfFace(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepShape.Handle_StepShape_HArray1OfFace_DownCast)
    __swig_destroy__ = _StepShape.delete_Handle_StepShape_HArray1OfFace

    def Array1(self, *args):
        """
        :rtype: OCC.wrapper.StepShape.StepShape_Array1OfFace

        """
        res = _StepShape.Handle_StepShape_HArray1OfFace_Array1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeArray1(self, *args):
        """
        ChangeArray1(Handle_StepShape_HArray1OfFace self) -> NCollection_Array1_Handle_StepShape_Face

        :rtype: OCC.wrapper.StepShape.StepShape_Array1OfFace

        """
        return _StepShape.Handle_StepShape_HArray1OfFace_ChangeArray1(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepShape_HArray1OfFace self) -> char const *

        :rtype: const char *

        """
        return _StepShape.Handle_StepShape_HArray1OfFace_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.Handle_StepShape_HArray1OfFace_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.Handle_StepShape_HArray1OfFace_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_StepShape_HArray1OfFace self)

        Memory deallocator for transient classes


        """
        return _StepShape.Handle_StepShape_HArray1OfFace_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepShape_HArray1OfFace self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepShape_HArray1OfFace self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.Handle_StepShape_HArray1OfFace_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepShape_HArray1OfFace self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepShape_HArray1OfFace self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.Handle_StepShape_HArray1OfFace_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepShape_HArray1OfFace self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepShape.Handle_StepShape_HArray1OfFace_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepShape_HArray1OfFace self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_HArray1OfFace_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepShape_HArray1OfFace self)

        Increments the reference counter of this object


        """
        return _StepShape.Handle_StepShape_HArray1OfFace_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepShape_HArray1OfFace self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_HArray1OfFace_DecrementRefCounter(self, *args)

Handle_StepShape_HArray1OfFace_swigregister = _StepShape.Handle_StepShape_HArray1OfFace_swigregister
Handle_StepShape_HArray1OfFace_swigregister(Handle_StepShape_HArray1OfFace)

def Handle_StepShape_HArray1OfFace_DownCast(thing):
    return _StepShape.Handle_StepShape_HArray1OfFace_DownCast(thing)
Handle_StepShape_HArray1OfFace_DownCast = _StepShape.Handle_StepShape_HArray1OfFace_DownCast

class Handle_StepShape_HArray1OfOrientedClosedShell(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepShape_HArray1OfOrientedClosedShell self)

        Nullify the handle


        """
        return _StepShape.Handle_StepShape_HArray1OfOrientedClosedShell_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepShape_HArray1OfOrientedClosedShell self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepShape.Handle_StepShape_HArray1OfOrientedClosedShell_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepShape_HArray1OfOrientedClosedShell self, StepShape_HArray1OfOrientedClosedShell thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepShape.Handle_StepShape_HArray1OfOrientedClosedShell_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepShape_HArray1OfOrientedClosedShell self, Handle_StepShape_HArray1OfOrientedClosedShell theHandle) -> Handle_StepShape_HArray1OfOrientedClosedShell
        assign(Handle_StepShape_HArray1OfOrientedClosedShell self, StepShape_HArray1OfOrientedClosedShell thePtr) -> Handle_StepShape_HArray1OfOrientedClosedShell
        assign(Handle_StepShape_HArray1OfOrientedClosedShell self, Handle_StepShape_HArray1OfOrientedClosedShell theHandle) -> Handle_StepShape_HArray1OfOrientedClosedShell

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepShape.Handle_StepShape_HArray1OfOrientedClosedShell_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepShape_HArray1OfOrientedClosedShell self) -> StepShape_HArray1OfOrientedClosedShell

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepShape.Handle_StepShape_HArray1OfOrientedClosedShell_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepShape_HArray1OfOrientedClosedShell self) -> StepShape_HArray1OfOrientedClosedShell

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepShape.Handle_StepShape_HArray1OfOrientedClosedShell___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepShape_HArray1OfOrientedClosedShell self) -> StepShape_HArray1OfOrientedClosedShell

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepShape.Handle_StepShape_HArray1OfOrientedClosedShell___ref__(self, *args)


    def __hash__(self):
        return _StepShape.Handle_StepShape_HArray1OfOrientedClosedShell___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepShape.Handle_StepShape_HArray1OfOrientedClosedShell___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepShape.new_Handle_StepShape_HArray1OfOrientedClosedShell(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepShape.Handle_StepShape_HArray1OfOrientedClosedShell_DownCast)
    __swig_destroy__ = _StepShape.delete_Handle_StepShape_HArray1OfOrientedClosedShell

    def Array1(self, *args):
        """
        :rtype: OCC.wrapper.StepShape.StepShape_Array1OfOrientedClosedShell

        """
        res = _StepShape.Handle_StepShape_HArray1OfOrientedClosedShell_Array1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeArray1(self, *args):
        """
        ChangeArray1(Handle_StepShape_HArray1OfOrientedClosedShell self) -> NCollection_Array1_Handle_StepShape_OrientedClosedShell

        :rtype: OCC.wrapper.StepShape.StepShape_Array1OfOrientedClosedShell

        """
        return _StepShape.Handle_StepShape_HArray1OfOrientedClosedShell_ChangeArray1(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepShape_HArray1OfOrientedClosedShell self) -> char const *

        :rtype: const char *

        """
        return _StepShape.Handle_StepShape_HArray1OfOrientedClosedShell_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.Handle_StepShape_HArray1OfOrientedClosedShell_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.Handle_StepShape_HArray1OfOrientedClosedShell_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_StepShape_HArray1OfOrientedClosedShell self)

        Memory deallocator for transient classes


        """
        return _StepShape.Handle_StepShape_HArray1OfOrientedClosedShell_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepShape_HArray1OfOrientedClosedShell self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepShape_HArray1OfOrientedClosedShell self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.Handle_StepShape_HArray1OfOrientedClosedShell_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepShape_HArray1OfOrientedClosedShell self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepShape_HArray1OfOrientedClosedShell self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.Handle_StepShape_HArray1OfOrientedClosedShell_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepShape_HArray1OfOrientedClosedShell self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepShape.Handle_StepShape_HArray1OfOrientedClosedShell_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepShape_HArray1OfOrientedClosedShell self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_HArray1OfOrientedClosedShell_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepShape_HArray1OfOrientedClosedShell self)

        Increments the reference counter of this object


        """
        return _StepShape.Handle_StepShape_HArray1OfOrientedClosedShell_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepShape_HArray1OfOrientedClosedShell self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_HArray1OfOrientedClosedShell_DecrementRefCounter(self, *args)

Handle_StepShape_HArray1OfOrientedClosedShell_swigregister = _StepShape.Handle_StepShape_HArray1OfOrientedClosedShell_swigregister
Handle_StepShape_HArray1OfOrientedClosedShell_swigregister(Handle_StepShape_HArray1OfOrientedClosedShell)

def Handle_StepShape_HArray1OfOrientedClosedShell_DownCast(thing):
    return _StepShape.Handle_StepShape_HArray1OfOrientedClosedShell_DownCast(thing)
Handle_StepShape_HArray1OfOrientedClosedShell_DownCast = _StepShape.Handle_StepShape_HArray1OfOrientedClosedShell_DownCast

class Handle_StepShape_Edge(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepShape_Edge self)

        Nullify the handle


        """
        return _StepShape.Handle_StepShape_Edge_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepShape_Edge self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepShape.Handle_StepShape_Edge_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepShape_Edge self, StepShape_Edge thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepShape.Handle_StepShape_Edge_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepShape_Edge self, Handle_StepShape_Edge theHandle) -> Handle_StepShape_Edge
        assign(Handle_StepShape_Edge self, StepShape_Edge thePtr) -> Handle_StepShape_Edge
        assign(Handle_StepShape_Edge self, Handle_StepShape_Edge theHandle) -> Handle_StepShape_Edge

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepShape.Handle_StepShape_Edge_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepShape_Edge self) -> StepShape_Edge

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepShape.Handle_StepShape_Edge_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepShape_Edge self) -> StepShape_Edge

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepShape.Handle_StepShape_Edge___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepShape_Edge self) -> StepShape_Edge

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepShape.Handle_StepShape_Edge___ref__(self, *args)


    def __hash__(self):
        return _StepShape.Handle_StepShape_Edge___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepShape.Handle_StepShape_Edge___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepShape.new_Handle_StepShape_Edge(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepShape.Handle_StepShape_Edge_DownCast)
    __swig_destroy__ = _StepShape.delete_Handle_StepShape_Edge

    def Init(self, *args):
        """
        Init(Handle_StepShape_Edge self, Handle_TCollection_HAsciiString aName, Handle_StepShape_Vertex aEdgeStart, Handle_StepShape_Vertex aEdgeEnd)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aEdgeStart: OCC.wrapper.StepShape.Handle_StepShape_Vertex
        :type aEdgeEnd: OCC.wrapper.StepShape.Handle_StepShape_Vertex

        """
        return _StepShape.Handle_StepShape_Edge_Init(self, *args)


    def SetEdgeStart(self, *args):
        """
        SetEdgeStart(Handle_StepShape_Edge self, Handle_StepShape_Vertex aEdgeStart)

        :type aEdgeStart: OCC.wrapper.StepShape.Handle_StepShape_Vertex

        """
        return _StepShape.Handle_StepShape_Edge_SetEdgeStart(self, *args)


    def EdgeStart(self, *args):
        """
        EdgeStart(Handle_StepShape_Edge self) -> Handle_StepShape_Vertex

        :rtype: OCC.wrapper.StepShape.Handle_StepShape_Vertex

        """
        return _StepShape.Handle_StepShape_Edge_EdgeStart(self, *args)


    def SetEdgeEnd(self, *args):
        """
        SetEdgeEnd(Handle_StepShape_Edge self, Handle_StepShape_Vertex aEdgeEnd)

        :type aEdgeEnd: OCC.wrapper.StepShape.Handle_StepShape_Vertex

        """
        return _StepShape.Handle_StepShape_Edge_SetEdgeEnd(self, *args)


    def EdgeEnd(self, *args):
        """
        EdgeEnd(Handle_StepShape_Edge self) -> Handle_StepShape_Vertex

        :rtype: OCC.wrapper.StepShape.Handle_StepShape_Vertex

        """
        return _StepShape.Handle_StepShape_Edge_EdgeEnd(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepShape_Edge self) -> char const *

        :rtype: const char *

        """
        return _StepShape.Handle_StepShape_Edge_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.Handle_StepShape_Edge_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.Handle_StepShape_Edge_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetName(self, *args):
        """
        SetName(Handle_StepShape_Edge self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepShape.Handle_StepShape_Edge_SetName(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepShape_Edge self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepShape.Handle_StepShape_Edge_Name(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepShape_Edge self)

        Memory deallocator for transient classes


        """
        return _StepShape.Handle_StepShape_Edge_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepShape_Edge self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepShape_Edge self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.Handle_StepShape_Edge_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepShape_Edge self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepShape_Edge self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.Handle_StepShape_Edge_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepShape_Edge self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepShape.Handle_StepShape_Edge_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepShape_Edge self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_Edge_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepShape_Edge self)

        Increments the reference counter of this object


        """
        return _StepShape.Handle_StepShape_Edge_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepShape_Edge self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_Edge_DecrementRefCounter(self, *args)

Handle_StepShape_Edge_swigregister = _StepShape.Handle_StepShape_Edge_swigregister
Handle_StepShape_Edge_swigregister(Handle_StepShape_Edge)

def Handle_StepShape_Edge_DownCast(thing):
    return _StepShape.Handle_StepShape_Edge_DownCast(thing)
Handle_StepShape_Edge_DownCast = _StepShape.Handle_StepShape_Edge_DownCast

class Handle_StepShape_PointRepresentation(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepShape_PointRepresentation self)

        Nullify the handle


        """
        return _StepShape.Handle_StepShape_PointRepresentation_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepShape_PointRepresentation self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepShape.Handle_StepShape_PointRepresentation_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepShape_PointRepresentation self, StepShape_PointRepresentation thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepShape.Handle_StepShape_PointRepresentation_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepShape_PointRepresentation self, Handle_StepShape_PointRepresentation theHandle) -> Handle_StepShape_PointRepresentation
        assign(Handle_StepShape_PointRepresentation self, StepShape_PointRepresentation thePtr) -> Handle_StepShape_PointRepresentation
        assign(Handle_StepShape_PointRepresentation self, Handle_StepShape_PointRepresentation theHandle) -> Handle_StepShape_PointRepresentation

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepShape.Handle_StepShape_PointRepresentation_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepShape_PointRepresentation self) -> StepShape_PointRepresentation

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepShape.Handle_StepShape_PointRepresentation_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepShape_PointRepresentation self) -> StepShape_PointRepresentation

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepShape.Handle_StepShape_PointRepresentation___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepShape_PointRepresentation self) -> StepShape_PointRepresentation

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepShape.Handle_StepShape_PointRepresentation___ref__(self, *args)


    def __hash__(self):
        return _StepShape.Handle_StepShape_PointRepresentation___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepShape.Handle_StepShape_PointRepresentation___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepShape.new_Handle_StepShape_PointRepresentation(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepShape.Handle_StepShape_PointRepresentation_DownCast)
    __swig_destroy__ = _StepShape.delete_Handle_StepShape_PointRepresentation

    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepShape_PointRepresentation self) -> char const *

        :rtype: const char *

        """
        return _StepShape.Handle_StepShape_PointRepresentation_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.Handle_StepShape_PointRepresentation_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.Handle_StepShape_PointRepresentation_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Init(self, *args):
        """
        Init(Handle_StepShape_PointRepresentation self, Handle_TCollection_HAsciiString aName, Handle_StepRepr_HArray1OfRepresentationItem aItems, Handle_StepRepr_RepresentationContext aContextOfItems)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aItems: OCC.wrapper.StepRepr.Handle_StepRepr_HArray1OfRepresentationItem
        :type aContextOfItems: OCC.wrapper.StepRepr.Handle_StepRepr_RepresentationContext

        """
        return _StepShape.Handle_StepShape_PointRepresentation_Init(self, *args)


    def SetName(self, *args):
        """
        SetName(Handle_StepShape_PointRepresentation self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepShape.Handle_StepShape_PointRepresentation_SetName(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepShape_PointRepresentation self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepShape.Handle_StepShape_PointRepresentation_Name(self, *args)


    def SetItems(self, *args):
        """
        SetItems(Handle_StepShape_PointRepresentation self, Handle_StepRepr_HArray1OfRepresentationItem aItems)

        :type aItems: OCC.wrapper.StepRepr.Handle_StepRepr_HArray1OfRepresentationItem

        """
        return _StepShape.Handle_StepShape_PointRepresentation_SetItems(self, *args)


    def Items(self, *args):
        """
        Items(Handle_StepShape_PointRepresentation self) -> Handle_StepRepr_HArray1OfRepresentationItem

        :rtype: OCC.wrapper.StepRepr.Handle_StepRepr_HArray1OfRepresentationItem

        """
        return _StepShape.Handle_StepShape_PointRepresentation_Items(self, *args)


    def ItemsValue(self, *args):
        """
        ItemsValue(Handle_StepShape_PointRepresentation self, Standard_Integer const num) -> Handle_StepRepr_RepresentationItem

        :type num: int
        :rtype: OCC.wrapper.StepRepr.Handle_StepRepr_RepresentationItem

        """
        return _StepShape.Handle_StepShape_PointRepresentation_ItemsValue(self, *args)


    def NbItems(self, *args):
        """
        NbItems(Handle_StepShape_PointRepresentation self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_PointRepresentation_NbItems(self, *args)


    def SetContextOfItems(self, *args):
        """
        SetContextOfItems(Handle_StepShape_PointRepresentation self, Handle_StepRepr_RepresentationContext aContextOfItems)

        :type aContextOfItems: OCC.wrapper.StepRepr.Handle_StepRepr_RepresentationContext

        """
        return _StepShape.Handle_StepShape_PointRepresentation_SetContextOfItems(self, *args)


    def ContextOfItems(self, *args):
        """
        ContextOfItems(Handle_StepShape_PointRepresentation self) -> Handle_StepRepr_RepresentationContext

        :rtype: OCC.wrapper.StepRepr.Handle_StepRepr_RepresentationContext

        """
        return _StepShape.Handle_StepShape_PointRepresentation_ContextOfItems(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepShape_PointRepresentation self)

        Memory deallocator for transient classes


        """
        return _StepShape.Handle_StepShape_PointRepresentation_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepShape_PointRepresentation self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepShape_PointRepresentation self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.Handle_StepShape_PointRepresentation_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepShape_PointRepresentation self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepShape_PointRepresentation self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.Handle_StepShape_PointRepresentation_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepShape_PointRepresentation self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepShape.Handle_StepShape_PointRepresentation_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepShape_PointRepresentation self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_PointRepresentation_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepShape_PointRepresentation self)

        Increments the reference counter of this object


        """
        return _StepShape.Handle_StepShape_PointRepresentation_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepShape_PointRepresentation self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_PointRepresentation_DecrementRefCounter(self, *args)

Handle_StepShape_PointRepresentation_swigregister = _StepShape.Handle_StepShape_PointRepresentation_swigregister
Handle_StepShape_PointRepresentation_swigregister(Handle_StepShape_PointRepresentation)

def Handle_StepShape_PointRepresentation_DownCast(thing):
    return _StepShape.Handle_StepShape_PointRepresentation_DownCast(thing)
Handle_StepShape_PointRepresentation_DownCast = _StepShape.Handle_StepShape_PointRepresentation_DownCast

class Handle_StepShape_NonManifoldSurfaceShapeRepresentation(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepShape_NonManifoldSurfaceShapeRepresentation self)

        Nullify the handle


        """
        return _StepShape.Handle_StepShape_NonManifoldSurfaceShapeRepresentation_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepShape_NonManifoldSurfaceShapeRepresentation self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepShape.Handle_StepShape_NonManifoldSurfaceShapeRepresentation_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepShape_NonManifoldSurfaceShapeRepresentation self, StepShape_NonManifoldSurfaceShapeRepresentation thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepShape.Handle_StepShape_NonManifoldSurfaceShapeRepresentation_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepShape_NonManifoldSurfaceShapeRepresentation self, Handle_StepShape_NonManifoldSurfaceShapeRepresentation theHandle) -> Handle_StepShape_NonManifoldSurfaceShapeRepresentation
        assign(Handle_StepShape_NonManifoldSurfaceShapeRepresentation self, StepShape_NonManifoldSurfaceShapeRepresentation thePtr) -> Handle_StepShape_NonManifoldSurfaceShapeRepresentation
        assign(Handle_StepShape_NonManifoldSurfaceShapeRepresentation self, Handle_StepShape_NonManifoldSurfaceShapeRepresentation theHandle) -> Handle_StepShape_NonManifoldSurfaceShapeRepresentation

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepShape.Handle_StepShape_NonManifoldSurfaceShapeRepresentation_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepShape_NonManifoldSurfaceShapeRepresentation self) -> StepShape_NonManifoldSurfaceShapeRepresentation

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepShape.Handle_StepShape_NonManifoldSurfaceShapeRepresentation_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepShape_NonManifoldSurfaceShapeRepresentation self) -> StepShape_NonManifoldSurfaceShapeRepresentation

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepShape.Handle_StepShape_NonManifoldSurfaceShapeRepresentation___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepShape_NonManifoldSurfaceShapeRepresentation self) -> StepShape_NonManifoldSurfaceShapeRepresentation

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepShape.Handle_StepShape_NonManifoldSurfaceShapeRepresentation___ref__(self, *args)


    def __hash__(self):
        return _StepShape.Handle_StepShape_NonManifoldSurfaceShapeRepresentation___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepShape.Handle_StepShape_NonManifoldSurfaceShapeRepresentation___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepShape.new_Handle_StepShape_NonManifoldSurfaceShapeRepresentation(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepShape.Handle_StepShape_NonManifoldSurfaceShapeRepresentation_DownCast)
    __swig_destroy__ = _StepShape.delete_Handle_StepShape_NonManifoldSurfaceShapeRepresentation

    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepShape_NonManifoldSurfaceShapeRepresentation self) -> char const *

        :rtype: const char *

        """
        return _StepShape.Handle_StepShape_NonManifoldSurfaceShapeRepresentation_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.Handle_StepShape_NonManifoldSurfaceShapeRepresentation_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.Handle_StepShape_NonManifoldSurfaceShapeRepresentation_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Init(self, *args):
        """
        Init(Handle_StepShape_NonManifoldSurfaceShapeRepresentation self, Handle_TCollection_HAsciiString aName, Handle_StepRepr_HArray1OfRepresentationItem aItems, Handle_StepRepr_RepresentationContext aContextOfItems)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aItems: OCC.wrapper.StepRepr.Handle_StepRepr_HArray1OfRepresentationItem
        :type aContextOfItems: OCC.wrapper.StepRepr.Handle_StepRepr_RepresentationContext

        """
        return _StepShape.Handle_StepShape_NonManifoldSurfaceShapeRepresentation_Init(self, *args)


    def SetName(self, *args):
        """
        SetName(Handle_StepShape_NonManifoldSurfaceShapeRepresentation self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepShape.Handle_StepShape_NonManifoldSurfaceShapeRepresentation_SetName(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepShape_NonManifoldSurfaceShapeRepresentation self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepShape.Handle_StepShape_NonManifoldSurfaceShapeRepresentation_Name(self, *args)


    def SetItems(self, *args):
        """
        SetItems(Handle_StepShape_NonManifoldSurfaceShapeRepresentation self, Handle_StepRepr_HArray1OfRepresentationItem aItems)

        :type aItems: OCC.wrapper.StepRepr.Handle_StepRepr_HArray1OfRepresentationItem

        """
        return _StepShape.Handle_StepShape_NonManifoldSurfaceShapeRepresentation_SetItems(self, *args)


    def Items(self, *args):
        """
        Items(Handle_StepShape_NonManifoldSurfaceShapeRepresentation self) -> Handle_StepRepr_HArray1OfRepresentationItem

        :rtype: OCC.wrapper.StepRepr.Handle_StepRepr_HArray1OfRepresentationItem

        """
        return _StepShape.Handle_StepShape_NonManifoldSurfaceShapeRepresentation_Items(self, *args)


    def ItemsValue(self, *args):
        """
        ItemsValue(Handle_StepShape_NonManifoldSurfaceShapeRepresentation self, Standard_Integer const num) -> Handle_StepRepr_RepresentationItem

        :type num: int
        :rtype: OCC.wrapper.StepRepr.Handle_StepRepr_RepresentationItem

        """
        return _StepShape.Handle_StepShape_NonManifoldSurfaceShapeRepresentation_ItemsValue(self, *args)


    def NbItems(self, *args):
        """
        NbItems(Handle_StepShape_NonManifoldSurfaceShapeRepresentation self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_NonManifoldSurfaceShapeRepresentation_NbItems(self, *args)


    def SetContextOfItems(self, *args):
        """
        SetContextOfItems(Handle_StepShape_NonManifoldSurfaceShapeRepresentation self, Handle_StepRepr_RepresentationContext aContextOfItems)

        :type aContextOfItems: OCC.wrapper.StepRepr.Handle_StepRepr_RepresentationContext

        """
        return _StepShape.Handle_StepShape_NonManifoldSurfaceShapeRepresentation_SetContextOfItems(self, *args)


    def ContextOfItems(self, *args):
        """
        ContextOfItems(Handle_StepShape_NonManifoldSurfaceShapeRepresentation self) -> Handle_StepRepr_RepresentationContext

        :rtype: OCC.wrapper.StepRepr.Handle_StepRepr_RepresentationContext

        """
        return _StepShape.Handle_StepShape_NonManifoldSurfaceShapeRepresentation_ContextOfItems(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepShape_NonManifoldSurfaceShapeRepresentation self)

        Memory deallocator for transient classes


        """
        return _StepShape.Handle_StepShape_NonManifoldSurfaceShapeRepresentation_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepShape_NonManifoldSurfaceShapeRepresentation self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepShape_NonManifoldSurfaceShapeRepresentation self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.Handle_StepShape_NonManifoldSurfaceShapeRepresentation_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepShape_NonManifoldSurfaceShapeRepresentation self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepShape_NonManifoldSurfaceShapeRepresentation self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.Handle_StepShape_NonManifoldSurfaceShapeRepresentation_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepShape_NonManifoldSurfaceShapeRepresentation self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepShape.Handle_StepShape_NonManifoldSurfaceShapeRepresentation_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepShape_NonManifoldSurfaceShapeRepresentation self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_NonManifoldSurfaceShapeRepresentation_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepShape_NonManifoldSurfaceShapeRepresentation self)

        Increments the reference counter of this object


        """
        return _StepShape.Handle_StepShape_NonManifoldSurfaceShapeRepresentation_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepShape_NonManifoldSurfaceShapeRepresentation self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_NonManifoldSurfaceShapeRepresentation_DecrementRefCounter(self, *args)

Handle_StepShape_NonManifoldSurfaceShapeRepresentation_swigregister = _StepShape.Handle_StepShape_NonManifoldSurfaceShapeRepresentation_swigregister
Handle_StepShape_NonManifoldSurfaceShapeRepresentation_swigregister(Handle_StepShape_NonManifoldSurfaceShapeRepresentation)

def Handle_StepShape_NonManifoldSurfaceShapeRepresentation_DownCast(thing):
    return _StepShape.Handle_StepShape_NonManifoldSurfaceShapeRepresentation_DownCast(thing)
Handle_StepShape_NonManifoldSurfaceShapeRepresentation_DownCast = _StepShape.Handle_StepShape_NonManifoldSurfaceShapeRepresentation_DownCast

class Handle_StepShape_HArray1OfShapeDimensionRepresentationItem(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepShape_HArray1OfShapeDimensionRepresentationItem self)

        Nullify the handle


        """
        return _StepShape.Handle_StepShape_HArray1OfShapeDimensionRepresentationItem_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepShape_HArray1OfShapeDimensionRepresentationItem self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepShape.Handle_StepShape_HArray1OfShapeDimensionRepresentationItem_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepShape_HArray1OfShapeDimensionRepresentationItem self, StepShape_HArray1OfShapeDimensionRepresentationItem thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepShape.Handle_StepShape_HArray1OfShapeDimensionRepresentationItem_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepShape_HArray1OfShapeDimensionRepresentationItem self, Handle_StepShape_HArray1OfShapeDimensionRepresentationItem theHandle) -> Handle_StepShape_HArray1OfShapeDimensionRepresentationItem
        assign(Handle_StepShape_HArray1OfShapeDimensionRepresentationItem self, StepShape_HArray1OfShapeDimensionRepresentationItem thePtr) -> Handle_StepShape_HArray1OfShapeDimensionRepresentationItem
        assign(Handle_StepShape_HArray1OfShapeDimensionRepresentationItem self, Handle_StepShape_HArray1OfShapeDimensionRepresentationItem theHandle) -> Handle_StepShape_HArray1OfShapeDimensionRepresentationItem

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepShape.Handle_StepShape_HArray1OfShapeDimensionRepresentationItem_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepShape_HArray1OfShapeDimensionRepresentationItem self) -> StepShape_HArray1OfShapeDimensionRepresentationItem

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepShape.Handle_StepShape_HArray1OfShapeDimensionRepresentationItem_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepShape_HArray1OfShapeDimensionRepresentationItem self) -> StepShape_HArray1OfShapeDimensionRepresentationItem

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepShape.Handle_StepShape_HArray1OfShapeDimensionRepresentationItem___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepShape_HArray1OfShapeDimensionRepresentationItem self) -> StepShape_HArray1OfShapeDimensionRepresentationItem

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepShape.Handle_StepShape_HArray1OfShapeDimensionRepresentationItem___ref__(self, *args)


    def __hash__(self):
        return _StepShape.Handle_StepShape_HArray1OfShapeDimensionRepresentationItem___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepShape.Handle_StepShape_HArray1OfShapeDimensionRepresentationItem___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepShape.new_Handle_StepShape_HArray1OfShapeDimensionRepresentationItem(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepShape.Handle_StepShape_HArray1OfShapeDimensionRepresentationItem_DownCast)
    __swig_destroy__ = _StepShape.delete_Handle_StepShape_HArray1OfShapeDimensionRepresentationItem

    def Array1(self, *args):
        """
        :rtype: OCC.wrapper.StepShape.StepShape_Array1OfShapeDimensionRepresentationItem

        """
        res = _StepShape.Handle_StepShape_HArray1OfShapeDimensionRepresentationItem_Array1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeArray1(self, *args):
        """
        ChangeArray1(Handle_StepShape_HArray1OfShapeDimensionRepresentationItem self) -> NCollection_Array1_StepShape_ShapeDimensionRepresentationItem

        :rtype: OCC.wrapper.StepShape.StepShape_Array1OfShapeDimensionRepresentationItem

        """
        return _StepShape.Handle_StepShape_HArray1OfShapeDimensionRepresentationItem_ChangeArray1(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepShape_HArray1OfShapeDimensionRepresentationItem self) -> char const *

        :rtype: const char *

        """
        return _StepShape.Handle_StepShape_HArray1OfShapeDimensionRepresentationItem_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.Handle_StepShape_HArray1OfShapeDimensionRepresentationItem_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.Handle_StepShape_HArray1OfShapeDimensionRepresentationItem_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_StepShape_HArray1OfShapeDimensionRepresentationItem self)

        Memory deallocator for transient classes


        """
        return _StepShape.Handle_StepShape_HArray1OfShapeDimensionRepresentationItem_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepShape_HArray1OfShapeDimensionRepresentationItem self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepShape_HArray1OfShapeDimensionRepresentationItem self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.Handle_StepShape_HArray1OfShapeDimensionRepresentationItem_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepShape_HArray1OfShapeDimensionRepresentationItem self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepShape_HArray1OfShapeDimensionRepresentationItem self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.Handle_StepShape_HArray1OfShapeDimensionRepresentationItem_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepShape_HArray1OfShapeDimensionRepresentationItem self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepShape.Handle_StepShape_HArray1OfShapeDimensionRepresentationItem_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepShape_HArray1OfShapeDimensionRepresentationItem self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_HArray1OfShapeDimensionRepresentationItem_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepShape_HArray1OfShapeDimensionRepresentationItem self)

        Increments the reference counter of this object


        """
        return _StepShape.Handle_StepShape_HArray1OfShapeDimensionRepresentationItem_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepShape_HArray1OfShapeDimensionRepresentationItem self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_HArray1OfShapeDimensionRepresentationItem_DecrementRefCounter(self, *args)

Handle_StepShape_HArray1OfShapeDimensionRepresentationItem_swigregister = _StepShape.Handle_StepShape_HArray1OfShapeDimensionRepresentationItem_swigregister
Handle_StepShape_HArray1OfShapeDimensionRepresentationItem_swigregister(Handle_StepShape_HArray1OfShapeDimensionRepresentationItem)

def Handle_StepShape_HArray1OfShapeDimensionRepresentationItem_DownCast(thing):
    return _StepShape.Handle_StepShape_HArray1OfShapeDimensionRepresentationItem_DownCast(thing)
Handle_StepShape_HArray1OfShapeDimensionRepresentationItem_DownCast = _StepShape.Handle_StepShape_HArray1OfShapeDimensionRepresentationItem_DownCast

class StepShape_ContextDependentShapeRepresentation(Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepShape_ContextDependentShapeRepresentation
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepShape_ContextDependentShapeRepresentation(self) 
            return h


    def __init__(self, *args):
        """__init__(StepShape_ContextDependentShapeRepresentation self) -> StepShape_ContextDependentShapeRepresentation"""
        this = _StepShape.new_StepShape_ContextDependentShapeRepresentation(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepShape_ContextDependentShapeRepresentation self, Handle_StepRepr_ShapeRepresentationRelationship aRepRel, Handle_StepRepr_ProductDefinitionShape aProRel)

        :type aRepRel: OCC.wrapper.StepShape.Handle_StepRepr_ShapeRepresentationRelationship
        :type aProRel: OCC.wrapper.StepShape.Handle_StepRepr_ProductDefinitionShape

        """
        return _StepShape.StepShape_ContextDependentShapeRepresentation_Init(self, *args)


    def RepresentationRelation(self, *args):
        """
        RepresentationRelation(StepShape_ContextDependentShapeRepresentation self) -> Handle_StepRepr_ShapeRepresentationRelationship

        :rtype: OCC.wrapper.StepShape.Handle_StepRepr_ShapeRepresentationRelationship

        """
        return _StepShape.StepShape_ContextDependentShapeRepresentation_RepresentationRelation(self, *args)


    def SetRepresentationRelation(self, *args):
        """
        SetRepresentationRelation(StepShape_ContextDependentShapeRepresentation self, Handle_StepRepr_ShapeRepresentationRelationship aRepRel)

        :type aRepRel: OCC.wrapper.StepShape.Handle_StepRepr_ShapeRepresentationRelationship

        """
        return _StepShape.StepShape_ContextDependentShapeRepresentation_SetRepresentationRelation(self, *args)


    def RepresentedProductRelation(self, *args):
        """
        RepresentedProductRelation(StepShape_ContextDependentShapeRepresentation self) -> Handle_StepRepr_ProductDefinitionShape

        :rtype: OCC.wrapper.StepShape.Handle_StepRepr_ProductDefinitionShape

        """
        return _StepShape.StepShape_ContextDependentShapeRepresentation_RepresentedProductRelation(self, *args)


    def SetRepresentedProductRelation(self, *args):
        """
        SetRepresentedProductRelation(StepShape_ContextDependentShapeRepresentation self, Handle_StepRepr_ProductDefinitionShape aProRel)

        :type aProRel: OCC.wrapper.StepShape.Handle_StepRepr_ProductDefinitionShape

        """
        return _StepShape.StepShape_ContextDependentShapeRepresentation_SetRepresentedProductRelation(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepShape.StepShape_ContextDependentShapeRepresentation_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepShape.StepShape_ContextDependentShapeRepresentation_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.StepShape_ContextDependentShapeRepresentation_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepShape.delete_StepShape_ContextDependentShapeRepresentation
StepShape_ContextDependentShapeRepresentation_swigregister = _StepShape.StepShape_ContextDependentShapeRepresentation_swigregister
StepShape_ContextDependentShapeRepresentation_swigregister(StepShape_ContextDependentShapeRepresentation)

def StepShape_ContextDependentShapeRepresentation_get_type_name(*args):
    """
    StepShape_ContextDependentShapeRepresentation_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepShape.StepShape_ContextDependentShapeRepresentation_get_type_name(*args)

def StepShape_ContextDependentShapeRepresentation_get_type_descriptor(*args):
    """
    StepShape_ContextDependentShapeRepresentation_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepShape.StepShape_ContextDependentShapeRepresentation_get_type_descriptor(*args)

class StepShape_RevolvedFaceSolid(StepShape_SweptFaceSolid):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepShape_RevolvedFaceSolid
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepShape_RevolvedFaceSolid(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepShape_RevolvedFaceSolid self) -> StepShape_RevolvedFaceSolid

        Returns a RevolvedFaceSolid


        """
        this = _StepShape.new_StepShape_RevolvedFaceSolid(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepShape_RevolvedFaceSolid self, Handle_TCollection_HAsciiString aName, Handle_StepShape_FaceSurface aSweptArea)
        Init(StepShape_RevolvedFaceSolid self, Handle_TCollection_HAsciiString aName, Handle_StepShape_FaceSurface aSweptArea, Handle_StepGeom_Axis1Placement aAxis, Standard_Real const aAngle)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aSweptArea: OCC.wrapper.StepShape.Handle_StepShape_FaceSurface
        :type aAxis: OCC.wrapper.StepShape.Handle_StepGeom_Axis1Placement
        :type aAngle: float

        """
        return _StepShape.StepShape_RevolvedFaceSolid_Init(self, *args)


    def SetAxis(self, *args):
        """
        SetAxis(StepShape_RevolvedFaceSolid self, Handle_StepGeom_Axis1Placement aAxis)

        :type aAxis: OCC.wrapper.StepShape.Handle_StepGeom_Axis1Placement

        """
        return _StepShape.StepShape_RevolvedFaceSolid_SetAxis(self, *args)


    def Axis(self, *args):
        """
        Axis(StepShape_RevolvedFaceSolid self) -> Handle_StepGeom_Axis1Placement

        :rtype: OCC.wrapper.StepShape.Handle_StepGeom_Axis1Placement

        """
        return _StepShape.StepShape_RevolvedFaceSolid_Axis(self, *args)


    def SetAngle(self, *args):
        """
        SetAngle(StepShape_RevolvedFaceSolid self, Standard_Real const aAngle)

        :type aAngle: float

        """
        return _StepShape.StepShape_RevolvedFaceSolid_SetAngle(self, *args)


    def Angle(self, *args):
        """
        Angle(StepShape_RevolvedFaceSolid self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _StepShape.StepShape_RevolvedFaceSolid_Angle(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepShape.StepShape_RevolvedFaceSolid_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepShape.StepShape_RevolvedFaceSolid_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.StepShape_RevolvedFaceSolid_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepShape.delete_StepShape_RevolvedFaceSolid
StepShape_RevolvedFaceSolid_swigregister = _StepShape.StepShape_RevolvedFaceSolid_swigregister
StepShape_RevolvedFaceSolid_swigregister(StepShape_RevolvedFaceSolid)

def StepShape_RevolvedFaceSolid_get_type_name(*args):
    """
    StepShape_RevolvedFaceSolid_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepShape.StepShape_RevolvedFaceSolid_get_type_name(*args)

def StepShape_RevolvedFaceSolid_get_type_descriptor(*args):
    """
    StepShape_RevolvedFaceSolid_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepShape.StepShape_RevolvedFaceSolid_get_type_descriptor(*args)

class Handle_StepShape_ShapeDefinitionRepresentation(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepShape_ShapeDefinitionRepresentation self)

        Nullify the handle


        """
        return _StepShape.Handle_StepShape_ShapeDefinitionRepresentation_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepShape_ShapeDefinitionRepresentation self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepShape.Handle_StepShape_ShapeDefinitionRepresentation_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepShape_ShapeDefinitionRepresentation self, StepShape_ShapeDefinitionRepresentation thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepShape.Handle_StepShape_ShapeDefinitionRepresentation_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepShape_ShapeDefinitionRepresentation self, Handle_StepShape_ShapeDefinitionRepresentation theHandle) -> Handle_StepShape_ShapeDefinitionRepresentation
        assign(Handle_StepShape_ShapeDefinitionRepresentation self, StepShape_ShapeDefinitionRepresentation thePtr) -> Handle_StepShape_ShapeDefinitionRepresentation
        assign(Handle_StepShape_ShapeDefinitionRepresentation self, Handle_StepShape_ShapeDefinitionRepresentation theHandle) -> Handle_StepShape_ShapeDefinitionRepresentation

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepShape.Handle_StepShape_ShapeDefinitionRepresentation_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepShape_ShapeDefinitionRepresentation self) -> StepShape_ShapeDefinitionRepresentation

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepShape.Handle_StepShape_ShapeDefinitionRepresentation_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepShape_ShapeDefinitionRepresentation self) -> StepShape_ShapeDefinitionRepresentation

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepShape.Handle_StepShape_ShapeDefinitionRepresentation___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepShape_ShapeDefinitionRepresentation self) -> StepShape_ShapeDefinitionRepresentation

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepShape.Handle_StepShape_ShapeDefinitionRepresentation___ref__(self, *args)


    def __hash__(self):
        return _StepShape.Handle_StepShape_ShapeDefinitionRepresentation___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepShape.Handle_StepShape_ShapeDefinitionRepresentation___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepShape.new_Handle_StepShape_ShapeDefinitionRepresentation(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepShape.Handle_StepShape_ShapeDefinitionRepresentation_DownCast)
    __swig_destroy__ = _StepShape.delete_Handle_StepShape_ShapeDefinitionRepresentation

    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepShape_ShapeDefinitionRepresentation self) -> char const *

        :rtype: const char *

        """
        return _StepShape.Handle_StepShape_ShapeDefinitionRepresentation_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.Handle_StepShape_ShapeDefinitionRepresentation_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.Handle_StepShape_ShapeDefinitionRepresentation_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Init(self, *args):
        """
        Init(Handle_StepShape_ShapeDefinitionRepresentation self, StepRepr_RepresentedDefinition aDefinition, Handle_StepRepr_Representation aUsedRepresentation)

        Initialize all fields (own and inherited)

        :type aDefinition: OCC.wrapper.StepRepr.StepRepr_RepresentedDefinition
        :type aUsedRepresentation: OCC.wrapper.StepRepr.Handle_StepRepr_Representation

        """
        return _StepShape.Handle_StepShape_ShapeDefinitionRepresentation_Init(self, *args)


    def Definition(self, *args):
        """
        Definition(Handle_StepShape_ShapeDefinitionRepresentation self) -> StepRepr_RepresentedDefinition

        Returns field Definition

        :rtype: OCC.wrapper.StepRepr.StepRepr_RepresentedDefinition

        """
        return _StepShape.Handle_StepShape_ShapeDefinitionRepresentation_Definition(self, *args)


    def SetDefinition(self, *args):
        """
        SetDefinition(Handle_StepShape_ShapeDefinitionRepresentation self, StepRepr_RepresentedDefinition Definition)

        Set field Definition

        :type Definition: OCC.wrapper.StepRepr.StepRepr_RepresentedDefinition

        """
        return _StepShape.Handle_StepShape_ShapeDefinitionRepresentation_SetDefinition(self, *args)


    def UsedRepresentation(self, *args):
        """
        UsedRepresentation(Handle_StepShape_ShapeDefinitionRepresentation self) -> Handle_StepRepr_Representation

        Returns field UsedRepresentation

        :rtype: OCC.wrapper.StepRepr.Handle_StepRepr_Representation

        """
        return _StepShape.Handle_StepShape_ShapeDefinitionRepresentation_UsedRepresentation(self, *args)


    def SetUsedRepresentation(self, *args):
        """
        SetUsedRepresentation(Handle_StepShape_ShapeDefinitionRepresentation self, Handle_StepRepr_Representation UsedRepresentation)

        Set field UsedRepresentation

        :type UsedRepresentation: OCC.wrapper.StepRepr.Handle_StepRepr_Representation

        """
        return _StepShape.Handle_StepShape_ShapeDefinitionRepresentation_SetUsedRepresentation(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepShape_ShapeDefinitionRepresentation self)

        Memory deallocator for transient classes


        """
        return _StepShape.Handle_StepShape_ShapeDefinitionRepresentation_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepShape_ShapeDefinitionRepresentation self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepShape_ShapeDefinitionRepresentation self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.Handle_StepShape_ShapeDefinitionRepresentation_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepShape_ShapeDefinitionRepresentation self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepShape_ShapeDefinitionRepresentation self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.Handle_StepShape_ShapeDefinitionRepresentation_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepShape_ShapeDefinitionRepresentation self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepShape.Handle_StepShape_ShapeDefinitionRepresentation_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepShape_ShapeDefinitionRepresentation self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_ShapeDefinitionRepresentation_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepShape_ShapeDefinitionRepresentation self)

        Increments the reference counter of this object


        """
        return _StepShape.Handle_StepShape_ShapeDefinitionRepresentation_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepShape_ShapeDefinitionRepresentation self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_ShapeDefinitionRepresentation_DecrementRefCounter(self, *args)

Handle_StepShape_ShapeDefinitionRepresentation_swigregister = _StepShape.Handle_StepShape_ShapeDefinitionRepresentation_swigregister
Handle_StepShape_ShapeDefinitionRepresentation_swigregister(Handle_StepShape_ShapeDefinitionRepresentation)

def Handle_StepShape_ShapeDefinitionRepresentation_DownCast(thing):
    return _StepShape.Handle_StepShape_ShapeDefinitionRepresentation_DownCast(thing)
Handle_StepShape_ShapeDefinitionRepresentation_DownCast = _StepShape.Handle_StepShape_ShapeDefinitionRepresentation_DownCast

class Handle_StepShape_DimensionalSize(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepShape_DimensionalSize self)

        Nullify the handle


        """
        return _StepShape.Handle_StepShape_DimensionalSize_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepShape_DimensionalSize self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepShape.Handle_StepShape_DimensionalSize_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepShape_DimensionalSize self, StepShape_DimensionalSize thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepShape.Handle_StepShape_DimensionalSize_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepShape_DimensionalSize self, Handle_StepShape_DimensionalSize theHandle) -> Handle_StepShape_DimensionalSize
        assign(Handle_StepShape_DimensionalSize self, StepShape_DimensionalSize thePtr) -> Handle_StepShape_DimensionalSize
        assign(Handle_StepShape_DimensionalSize self, Handle_StepShape_DimensionalSize theHandle) -> Handle_StepShape_DimensionalSize

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepShape.Handle_StepShape_DimensionalSize_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepShape_DimensionalSize self) -> StepShape_DimensionalSize

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepShape.Handle_StepShape_DimensionalSize_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepShape_DimensionalSize self) -> StepShape_DimensionalSize

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepShape.Handle_StepShape_DimensionalSize___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepShape_DimensionalSize self) -> StepShape_DimensionalSize

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepShape.Handle_StepShape_DimensionalSize___ref__(self, *args)


    def __hash__(self):
        return _StepShape.Handle_StepShape_DimensionalSize___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepShape.Handle_StepShape_DimensionalSize___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepShape.new_Handle_StepShape_DimensionalSize(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepShape.Handle_StepShape_DimensionalSize_DownCast)
    __swig_destroy__ = _StepShape.delete_Handle_StepShape_DimensionalSize

    def Init(self, *args):
        """
        Init(Handle_StepShape_DimensionalSize self, Handle_StepRepr_ShapeAspect aAppliesTo, Handle_TCollection_HAsciiString aName)

        Initialize all fields (own and inherited)

        :type aAppliesTo: OCC.wrapper.StepShape.Handle_StepRepr_ShapeAspect
        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepShape.Handle_StepShape_DimensionalSize_Init(self, *args)


    def AppliesTo(self, *args):
        """
        AppliesTo(Handle_StepShape_DimensionalSize self) -> Handle_StepRepr_ShapeAspect

        Returns field AppliesTo

        :rtype: OCC.wrapper.StepShape.Handle_StepRepr_ShapeAspect

        """
        return _StepShape.Handle_StepShape_DimensionalSize_AppliesTo(self, *args)


    def SetAppliesTo(self, *args):
        """
        SetAppliesTo(Handle_StepShape_DimensionalSize self, Handle_StepRepr_ShapeAspect AppliesTo)

        Set field AppliesTo

        :type AppliesTo: OCC.wrapper.StepShape.Handle_StepRepr_ShapeAspect

        """
        return _StepShape.Handle_StepShape_DimensionalSize_SetAppliesTo(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepShape_DimensionalSize self) -> Handle_TCollection_HAsciiString

        Returns field Name

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepShape.Handle_StepShape_DimensionalSize_Name(self, *args)


    def SetName(self, *args):
        """
        SetName(Handle_StepShape_DimensionalSize self, Handle_TCollection_HAsciiString Name)

        Set field Name

        :type Name: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepShape.Handle_StepShape_DimensionalSize_SetName(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepShape_DimensionalSize self) -> char const *

        :rtype: const char *

        """
        return _StepShape.Handle_StepShape_DimensionalSize_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.Handle_StepShape_DimensionalSize_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.Handle_StepShape_DimensionalSize_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_StepShape_DimensionalSize self)

        Memory deallocator for transient classes


        """
        return _StepShape.Handle_StepShape_DimensionalSize_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepShape_DimensionalSize self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepShape_DimensionalSize self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.Handle_StepShape_DimensionalSize_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepShape_DimensionalSize self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepShape_DimensionalSize self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.Handle_StepShape_DimensionalSize_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepShape_DimensionalSize self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepShape.Handle_StepShape_DimensionalSize_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepShape_DimensionalSize self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_DimensionalSize_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepShape_DimensionalSize self)

        Increments the reference counter of this object


        """
        return _StepShape.Handle_StepShape_DimensionalSize_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepShape_DimensionalSize self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_DimensionalSize_DecrementRefCounter(self, *args)

Handle_StepShape_DimensionalSize_swigregister = _StepShape.Handle_StepShape_DimensionalSize_swigregister
Handle_StepShape_DimensionalSize_swigregister(Handle_StepShape_DimensionalSize)

def Handle_StepShape_DimensionalSize_DownCast(thing):
    return _StepShape.Handle_StepShape_DimensionalSize_DownCast(thing)
Handle_StepShape_DimensionalSize_DownCast = _StepShape.Handle_StepShape_DimensionalSize_DownCast

class Handle_StepShape_ConnectedEdgeSet(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepShape_ConnectedEdgeSet self)

        Nullify the handle


        """
        return _StepShape.Handle_StepShape_ConnectedEdgeSet_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepShape_ConnectedEdgeSet self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepShape.Handle_StepShape_ConnectedEdgeSet_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepShape_ConnectedEdgeSet self, StepShape_ConnectedEdgeSet thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepShape.Handle_StepShape_ConnectedEdgeSet_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepShape_ConnectedEdgeSet self, Handle_StepShape_ConnectedEdgeSet theHandle) -> Handle_StepShape_ConnectedEdgeSet
        assign(Handle_StepShape_ConnectedEdgeSet self, StepShape_ConnectedEdgeSet thePtr) -> Handle_StepShape_ConnectedEdgeSet
        assign(Handle_StepShape_ConnectedEdgeSet self, Handle_StepShape_ConnectedEdgeSet theHandle) -> Handle_StepShape_ConnectedEdgeSet

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepShape.Handle_StepShape_ConnectedEdgeSet_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepShape_ConnectedEdgeSet self) -> StepShape_ConnectedEdgeSet

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepShape.Handle_StepShape_ConnectedEdgeSet_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepShape_ConnectedEdgeSet self) -> StepShape_ConnectedEdgeSet

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepShape.Handle_StepShape_ConnectedEdgeSet___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepShape_ConnectedEdgeSet self) -> StepShape_ConnectedEdgeSet

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepShape.Handle_StepShape_ConnectedEdgeSet___ref__(self, *args)


    def __hash__(self):
        return _StepShape.Handle_StepShape_ConnectedEdgeSet___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepShape.Handle_StepShape_ConnectedEdgeSet___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepShape.new_Handle_StepShape_ConnectedEdgeSet(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepShape.Handle_StepShape_ConnectedEdgeSet_DownCast)
    __swig_destroy__ = _StepShape.delete_Handle_StepShape_ConnectedEdgeSet

    def Init(self, *args):
        """
        Init(Handle_StepShape_ConnectedEdgeSet self, Handle_TCollection_HAsciiString aRepresentationItem_Name, Handle_StepShape_HArray1OfEdge aCesEdges)

        Initialize all fields (own and inherited)

        :type aRepresentationItem_Name: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aCesEdges: OCC.wrapper.StepShape.Handle_StepShape_HArray1OfEdge

        """
        return _StepShape.Handle_StepShape_ConnectedEdgeSet_Init(self, *args)


    def CesEdges(self, *args):
        """
        CesEdges(Handle_StepShape_ConnectedEdgeSet self) -> Handle_StepShape_HArray1OfEdge

        Returns field CesEdges

        :rtype: OCC.wrapper.StepShape.Handle_StepShape_HArray1OfEdge

        """
        return _StepShape.Handle_StepShape_ConnectedEdgeSet_CesEdges(self, *args)


    def SetCesEdges(self, *args):
        """
        SetCesEdges(Handle_StepShape_ConnectedEdgeSet self, Handle_StepShape_HArray1OfEdge CesEdges)

        Set field CesEdges

        :type CesEdges: OCC.wrapper.StepShape.Handle_StepShape_HArray1OfEdge

        """
        return _StepShape.Handle_StepShape_ConnectedEdgeSet_SetCesEdges(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepShape_ConnectedEdgeSet self) -> char const *

        :rtype: const char *

        """
        return _StepShape.Handle_StepShape_ConnectedEdgeSet_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.Handle_StepShape_ConnectedEdgeSet_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.Handle_StepShape_ConnectedEdgeSet_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetName(self, *args):
        """
        SetName(Handle_StepShape_ConnectedEdgeSet self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepShape.Handle_StepShape_ConnectedEdgeSet_SetName(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepShape_ConnectedEdgeSet self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepShape.Handle_StepShape_ConnectedEdgeSet_Name(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepShape_ConnectedEdgeSet self)

        Memory deallocator for transient classes


        """
        return _StepShape.Handle_StepShape_ConnectedEdgeSet_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepShape_ConnectedEdgeSet self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepShape_ConnectedEdgeSet self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.Handle_StepShape_ConnectedEdgeSet_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepShape_ConnectedEdgeSet self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepShape_ConnectedEdgeSet self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.Handle_StepShape_ConnectedEdgeSet_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepShape_ConnectedEdgeSet self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepShape.Handle_StepShape_ConnectedEdgeSet_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepShape_ConnectedEdgeSet self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_ConnectedEdgeSet_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepShape_ConnectedEdgeSet self)

        Increments the reference counter of this object


        """
        return _StepShape.Handle_StepShape_ConnectedEdgeSet_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepShape_ConnectedEdgeSet self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_ConnectedEdgeSet_DecrementRefCounter(self, *args)

Handle_StepShape_ConnectedEdgeSet_swigregister = _StepShape.Handle_StepShape_ConnectedEdgeSet_swigregister
Handle_StepShape_ConnectedEdgeSet_swigregister(Handle_StepShape_ConnectedEdgeSet)

def Handle_StepShape_ConnectedEdgeSet_DownCast(thing):
    return _StepShape.Handle_StepShape_ConnectedEdgeSet_DownCast(thing)
Handle_StepShape_ConnectedEdgeSet_DownCast = _StepShape.Handle_StepShape_ConnectedEdgeSet_DownCast

class NCollection_Array1_Handle_StepShape_OrientedEdge(object):
    """
    Purpose:     The class Array1 represents unidimensional arrays 
    of fixed size known at run time. 
    The range of the index is user defined.
    An array1 can be constructed with a "C array".
    This functionality is useful to call methods expecting
    an Array1. It allows to carry the bounds inside the arrays.

    Examples:    Item tab[100]; //  An example with a C array
    Array1OfItem ttab (tab[0],1,100);

    Array1OfItem tttab (ttab(10),10,20); // a slice of ttab

    If you want to reindex an array from 1 to Length do :

    Array1 tab1(tab(tab.Lower()),1,tab.Length());

    Warning:     Programs client of such a class must be independant
    of the range of the first element. Then, a C++ for
    loop must be written like this

    for (i = A.Lower(); i <= A.Upper(); i++)

    Changes:     In  comparison  to  TCollection  the  flag  isAllocated  was
    renamed into myDeletable (alike in  the Array2).  For naming
    compatibility the method IsAllocated remained in class along
    with IsDeletable.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Array1_Handle_StepShape_OrientedEdge self) -> NCollection_Array1< opencascade::handle< StepShape_OrientedEdge > >::iterator

        Returns an iterator pointing to the first element in the array.

        :rtype: iterator

        """
        return _StepShape.NCollection_Array1_Handle_StepShape_OrientedEdge_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Array1_Handle_StepShape_OrientedEdge self) -> NCollection_Array1< opencascade::handle< StepShape_OrientedEdge > >::iterator

        Returns an iterator referring to the past-the-end element in the array.

        :rtype: iterator

        """
        return _StepShape.NCollection_Array1_Handle_StepShape_OrientedEdge_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Array1_Handle_StepShape_OrientedEdge self) -> NCollection_Array1< opencascade::handle< StepShape_OrientedEdge > >::const_iterator

        Returns a const iterator pointing to the first element in the array.

        :rtype: const_iterator

        """
        return _StepShape.NCollection_Array1_Handle_StepShape_OrientedEdge_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Array1_Handle_StepShape_OrientedEdge self) -> NCollection_Array1< opencascade::handle< StepShape_OrientedEdge > >::const_iterator

        Returns a const iterator referring to the past-the-end element in the array.

        :rtype: const_iterator

        """
        return _StepShape.NCollection_Array1_Handle_StepShape_OrientedEdge_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     The class Array1 represents unidimensional arrays 
        of fixed size known at run time. 
        The range of the index is user defined.
        An array1 can be constructed with a "C array".
        This functionality is useful to call methods expecting
        an Array1. It allows to carry the bounds inside the arrays.

        Examples:    Item tab[100]; //  An example with a C array
        Array1OfItem ttab (tab[0],1,100);

        Array1OfItem tttab (ttab(10),10,20); // a slice of ttab

        If you want to reindex an array from 1 to Length do :

        Array1 tab1(tab(tab.Lower()),1,tab.Length());

        Warning:     Programs client of such a class must be independant
        of the range of the first element. Then, a C++ for
        loop must be written like this

        for (i = A.Lower(); i <= A.Upper(); i++)

        Changes:     In  comparison  to  TCollection  the  flag  isAllocated  was
        renamed into myDeletable (alike in  the Array2).  For naming
        compatibility the method IsAllocated remained in class along
        with IsDeletable.
        """
        this = _StepShape.new_NCollection_Array1_Handle_StepShape_OrientedEdge(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(NCollection_Array1_Handle_StepShape_OrientedEdge self, Handle_StepShape_OrientedEdge theValue)

        Initialise the items with theValue

        :type theValue: const TheItemType &

        """
        return _StepShape.NCollection_Array1_Handle_StepShape_OrientedEdge_Init(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_Array1_Handle_StepShape_OrientedEdge self) -> Standard_Integer

        Size query

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.NCollection_Array1_Handle_StepShape_OrientedEdge_Size(self, *args)


    def Length(self, *args):
        """
        Length(NCollection_Array1_Handle_StepShape_OrientedEdge self) -> Standard_Integer

        Length query (the same)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.NCollection_Array1_Handle_StepShape_OrientedEdge_Length(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Array1_Handle_StepShape_OrientedEdge self) -> Standard_Boolean

        Return TRUE if array has zero length.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.NCollection_Array1_Handle_StepShape_OrientedEdge_IsEmpty(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Array1_Handle_StepShape_OrientedEdge self) -> Standard_Integer

        Lower bound

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.NCollection_Array1_Handle_StepShape_OrientedEdge_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Array1_Handle_StepShape_OrientedEdge self) -> Standard_Integer

        Upper bound

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.NCollection_Array1_Handle_StepShape_OrientedEdge_Upper(self, *args)


    def IsDeletable(self, *args):
        """
        IsDeletable(NCollection_Array1_Handle_StepShape_OrientedEdge self) -> Standard_Boolean

        myDeletable flag

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.NCollection_Array1_Handle_StepShape_OrientedEdge_IsDeletable(self, *args)


    def IsAllocated(self, *args):
        """
        IsAllocated(NCollection_Array1_Handle_StepShape_OrientedEdge self) -> Standard_Boolean

        IsAllocated flag - for naming compatibility

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.NCollection_Array1_Handle_StepShape_OrientedEdge_IsAllocated(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Array1_Handle_StepShape_OrientedEdge self, NCollection_Array1_Handle_StepShape_OrientedEdge theOther) -> NCollection_Array1_Handle_StepShape_OrientedEdge

        Copies data of theOther array to this.
        This array should be pre-allocated and have the same length as theOther;
        otherwise exception Standard_DimensionMismatch is thrown.

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _StepShape.NCollection_Array1_Handle_StepShape_OrientedEdge_Assign(self, *args)


    def Move(self, *args):
        """
        Move(NCollection_Array1_Handle_StepShape_OrientedEdge self, NCollection_Array1_Handle_StepShape_OrientedEdge theOther) -> NCollection_Array1_Handle_StepShape_OrientedEdge

        Move assignment.
        This array will borrow all the data from theOther.
        The moved object will keep pointer to the memory buffer and
        range, but it will not free the buffer on destruction.

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _StepShape.NCollection_Array1_Handle_StepShape_OrientedEdge_Move(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Array1_Handle_StepShape_OrientedEdge self, NCollection_Array1_Handle_StepShape_OrientedEdge theOther) -> NCollection_Array1_Handle_StepShape_OrientedEdge
        assign(NCollection_Array1_Handle_StepShape_OrientedEdge self, NCollection_Array1_Handle_StepShape_OrientedEdge theOther) -> NCollection_Array1_Handle_StepShape_OrientedEdge

        Move assignment operator; @sa Move()

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1<TheItemType> &&
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _StepShape.NCollection_Array1_Handle_StepShape_OrientedEdge_assign(self, *args)


    def First(self, *args):
        """
        @return first element

        :rtype: const TheItemType &

        """
        res = _StepShape.NCollection_Array1_Handle_StepShape_OrientedEdge_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Array1_Handle_StepShape_OrientedEdge self) -> Handle_StepShape_OrientedEdge

        @return first element

        :rtype: TheItemType &

        """
        return _StepShape.NCollection_Array1_Handle_StepShape_OrientedEdge_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        @return last element

        :rtype: const TheItemType &

        """
        res = _StepShape.NCollection_Array1_Handle_StepShape_OrientedEdge_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Array1_Handle_StepShape_OrientedEdge self) -> Handle_StepShape_OrientedEdge

        @return last element

        :rtype: TheItemType &

        """
        return _StepShape.NCollection_Array1_Handle_StepShape_OrientedEdge_ChangeLast(self, *args)


    def Value(self, *args):
        """
        Constant value access

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _StepShape.NCollection_Array1_Handle_StepShape_OrientedEdge_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Array1_Handle_StepShape_OrientedEdge self, Standard_Integer const theIndex) -> Handle_StepShape_OrientedEdge

        Variable value access

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _StepShape.NCollection_Array1_Handle_StepShape_OrientedEdge_ChangeValue(self, *args)


    def __call__(self, *args):
        """
        operator() - alias to Value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _StepShape.NCollection_Array1_Handle_StepShape_OrientedEdge___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __getitem__(self, *args):
        """
        operator[] - alias to Value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _StepShape.NCollection_Array1_Handle_StepShape_OrientedEdge_at(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetValue(self, *args):
        """
        SetValue(NCollection_Array1_Handle_StepShape_OrientedEdge self, Standard_Integer const theIndex, Handle_StepShape_OrientedEdge theItem)

        Set value 

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _StepShape.NCollection_Array1_Handle_StepShape_OrientedEdge_SetValue(self, *args)


    def Resize(self, *args):
        """
        Resize(NCollection_Array1_Handle_StepShape_OrientedEdge self, Standard_Integer const theLower, Standard_Integer const theUpper, Standard_Boolean const theToCopyData)

        Resizes the array to specified bounds.
        No re-allocation will be done if length of array does not change,
        but existing values will not be discarded if theToCopyData set to FALSE.
        @param theLower new lower bound of array
        @param theUpper new upper bound of array
        @param theToCopyData flag to copy existing data into new array

        :type theLower: int
        :type theUpper: int
        :type theToCopyData: bool

        """
        return _StepShape.NCollection_Array1_Handle_StepShape_OrientedEdge_Resize(self, *args)

    __swig_destroy__ = _StepShape.delete_NCollection_Array1_Handle_StepShape_OrientedEdge
NCollection_Array1_Handle_StepShape_OrientedEdge_swigregister = _StepShape.NCollection_Array1_Handle_StepShape_OrientedEdge_swigregister
NCollection_Array1_Handle_StepShape_OrientedEdge_swigregister(NCollection_Array1_Handle_StepShape_OrientedEdge)


try:
	StepShape_Array1OfOrientedEdge = NCollection_Array1_Handle_StepShape_OrientedEdge
except NameError:
	pass # does not exist, probably ignored

class Handle_StepShape_HArray1OfEdge(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepShape_HArray1OfEdge self)

        Nullify the handle


        """
        return _StepShape.Handle_StepShape_HArray1OfEdge_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepShape_HArray1OfEdge self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepShape.Handle_StepShape_HArray1OfEdge_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepShape_HArray1OfEdge self, StepShape_HArray1OfEdge thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepShape.Handle_StepShape_HArray1OfEdge_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepShape_HArray1OfEdge self, Handle_StepShape_HArray1OfEdge theHandle) -> Handle_StepShape_HArray1OfEdge
        assign(Handle_StepShape_HArray1OfEdge self, StepShape_HArray1OfEdge thePtr) -> Handle_StepShape_HArray1OfEdge
        assign(Handle_StepShape_HArray1OfEdge self, Handle_StepShape_HArray1OfEdge theHandle) -> Handle_StepShape_HArray1OfEdge

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepShape.Handle_StepShape_HArray1OfEdge_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepShape_HArray1OfEdge self) -> StepShape_HArray1OfEdge

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepShape.Handle_StepShape_HArray1OfEdge_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepShape_HArray1OfEdge self) -> StepShape_HArray1OfEdge

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepShape.Handle_StepShape_HArray1OfEdge___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepShape_HArray1OfEdge self) -> StepShape_HArray1OfEdge

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepShape.Handle_StepShape_HArray1OfEdge___ref__(self, *args)


    def __hash__(self):
        return _StepShape.Handle_StepShape_HArray1OfEdge___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepShape.Handle_StepShape_HArray1OfEdge___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepShape.new_Handle_StepShape_HArray1OfEdge(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepShape.Handle_StepShape_HArray1OfEdge_DownCast)
    __swig_destroy__ = _StepShape.delete_Handle_StepShape_HArray1OfEdge

    def Array1(self, *args):
        """
        :rtype: OCC.wrapper.StepShape.StepShape_Array1OfEdge

        """
        res = _StepShape.Handle_StepShape_HArray1OfEdge_Array1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeArray1(self, *args):
        """
        ChangeArray1(Handle_StepShape_HArray1OfEdge self) -> NCollection_Array1_Handle_StepShape_Edge

        :rtype: OCC.wrapper.StepShape.StepShape_Array1OfEdge

        """
        return _StepShape.Handle_StepShape_HArray1OfEdge_ChangeArray1(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepShape_HArray1OfEdge self) -> char const *

        :rtype: const char *

        """
        return _StepShape.Handle_StepShape_HArray1OfEdge_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.Handle_StepShape_HArray1OfEdge_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.Handle_StepShape_HArray1OfEdge_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_StepShape_HArray1OfEdge self)

        Memory deallocator for transient classes


        """
        return _StepShape.Handle_StepShape_HArray1OfEdge_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepShape_HArray1OfEdge self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepShape_HArray1OfEdge self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.Handle_StepShape_HArray1OfEdge_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepShape_HArray1OfEdge self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepShape_HArray1OfEdge self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.Handle_StepShape_HArray1OfEdge_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepShape_HArray1OfEdge self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepShape.Handle_StepShape_HArray1OfEdge_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepShape_HArray1OfEdge self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_HArray1OfEdge_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepShape_HArray1OfEdge self)

        Increments the reference counter of this object


        """
        return _StepShape.Handle_StepShape_HArray1OfEdge_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepShape_HArray1OfEdge self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_HArray1OfEdge_DecrementRefCounter(self, *args)

Handle_StepShape_HArray1OfEdge_swigregister = _StepShape.Handle_StepShape_HArray1OfEdge_swigregister
Handle_StepShape_HArray1OfEdge_swigregister(Handle_StepShape_HArray1OfEdge)

def Handle_StepShape_HArray1OfEdge_DownCast(thing):
    return _StepShape.Handle_StepShape_HArray1OfEdge_DownCast(thing)
Handle_StepShape_HArray1OfEdge_DownCast = _StepShape.Handle_StepShape_HArray1OfEdge_DownCast

class Handle_StepShape_ExtrudedAreaSolid(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepShape_ExtrudedAreaSolid self)

        Nullify the handle


        """
        return _StepShape.Handle_StepShape_ExtrudedAreaSolid_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepShape_ExtrudedAreaSolid self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepShape.Handle_StepShape_ExtrudedAreaSolid_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepShape_ExtrudedAreaSolid self, StepShape_ExtrudedAreaSolid thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepShape.Handle_StepShape_ExtrudedAreaSolid_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepShape_ExtrudedAreaSolid self, Handle_StepShape_ExtrudedAreaSolid theHandle) -> Handle_StepShape_ExtrudedAreaSolid
        assign(Handle_StepShape_ExtrudedAreaSolid self, StepShape_ExtrudedAreaSolid thePtr) -> Handle_StepShape_ExtrudedAreaSolid
        assign(Handle_StepShape_ExtrudedAreaSolid self, Handle_StepShape_ExtrudedAreaSolid theHandle) -> Handle_StepShape_ExtrudedAreaSolid

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepShape.Handle_StepShape_ExtrudedAreaSolid_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepShape_ExtrudedAreaSolid self) -> StepShape_ExtrudedAreaSolid

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepShape.Handle_StepShape_ExtrudedAreaSolid_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepShape_ExtrudedAreaSolid self) -> StepShape_ExtrudedAreaSolid

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepShape.Handle_StepShape_ExtrudedAreaSolid___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepShape_ExtrudedAreaSolid self) -> StepShape_ExtrudedAreaSolid

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepShape.Handle_StepShape_ExtrudedAreaSolid___ref__(self, *args)


    def __hash__(self):
        return _StepShape.Handle_StepShape_ExtrudedAreaSolid___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepShape.Handle_StepShape_ExtrudedAreaSolid___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepShape.new_Handle_StepShape_ExtrudedAreaSolid(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepShape.Handle_StepShape_ExtrudedAreaSolid_DownCast)
    __swig_destroy__ = _StepShape.delete_Handle_StepShape_ExtrudedAreaSolid

    def Init(self, *args):
        """
        Init(Handle_StepShape_ExtrudedAreaSolid self, Handle_TCollection_HAsciiString aName, Handle_StepGeom_CurveBoundedSurface aSweptArea, Handle_StepGeom_Direction aExtrudedDirection, Standard_Real const aDepth)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aSweptArea: OCC.wrapper.StepShape.Handle_StepGeom_CurveBoundedSurface
        :type aExtrudedDirection: OCC.wrapper.StepShape.Handle_StepGeom_Direction
        :type aDepth: float

        """
        return _StepShape.Handle_StepShape_ExtrudedAreaSolid_Init(self, *args)


    def SetExtrudedDirection(self, *args):
        """
        SetExtrudedDirection(Handle_StepShape_ExtrudedAreaSolid self, Handle_StepGeom_Direction aExtrudedDirection)

        :type aExtrudedDirection: OCC.wrapper.StepShape.Handle_StepGeom_Direction

        """
        return _StepShape.Handle_StepShape_ExtrudedAreaSolid_SetExtrudedDirection(self, *args)


    def ExtrudedDirection(self, *args):
        """
        ExtrudedDirection(Handle_StepShape_ExtrudedAreaSolid self) -> Handle_StepGeom_Direction

        :rtype: OCC.wrapper.StepShape.Handle_StepGeom_Direction

        """
        return _StepShape.Handle_StepShape_ExtrudedAreaSolid_ExtrudedDirection(self, *args)


    def SetDepth(self, *args):
        """
        SetDepth(Handle_StepShape_ExtrudedAreaSolid self, Standard_Real const aDepth)

        :type aDepth: float

        """
        return _StepShape.Handle_StepShape_ExtrudedAreaSolid_SetDepth(self, *args)


    def Depth(self, *args):
        """
        Depth(Handle_StepShape_ExtrudedAreaSolid self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _StepShape.Handle_StepShape_ExtrudedAreaSolid_Depth(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepShape_ExtrudedAreaSolid self) -> char const *

        :rtype: const char *

        """
        return _StepShape.Handle_StepShape_ExtrudedAreaSolid_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.Handle_StepShape_ExtrudedAreaSolid_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.Handle_StepShape_ExtrudedAreaSolid_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetSweptArea(self, *args):
        """
        SetSweptArea(Handle_StepShape_ExtrudedAreaSolid self, Handle_StepGeom_CurveBoundedSurface aSweptArea)

        :type aSweptArea: OCC.wrapper.StepShape.Handle_StepGeom_CurveBoundedSurface

        """
        return _StepShape.Handle_StepShape_ExtrudedAreaSolid_SetSweptArea(self, *args)


    def SweptArea(self, *args):
        """
        SweptArea(Handle_StepShape_ExtrudedAreaSolid self) -> Handle_StepGeom_CurveBoundedSurface

        :rtype: OCC.wrapper.StepShape.Handle_StepGeom_CurveBoundedSurface

        """
        return _StepShape.Handle_StepShape_ExtrudedAreaSolid_SweptArea(self, *args)


    def SetName(self, *args):
        """
        SetName(Handle_StepShape_ExtrudedAreaSolid self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepShape.Handle_StepShape_ExtrudedAreaSolid_SetName(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepShape_ExtrudedAreaSolid self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepShape.Handle_StepShape_ExtrudedAreaSolid_Name(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepShape_ExtrudedAreaSolid self)

        Memory deallocator for transient classes


        """
        return _StepShape.Handle_StepShape_ExtrudedAreaSolid_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepShape_ExtrudedAreaSolid self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepShape_ExtrudedAreaSolid self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.Handle_StepShape_ExtrudedAreaSolid_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepShape_ExtrudedAreaSolid self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepShape_ExtrudedAreaSolid self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.Handle_StepShape_ExtrudedAreaSolid_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepShape_ExtrudedAreaSolid self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepShape.Handle_StepShape_ExtrudedAreaSolid_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepShape_ExtrudedAreaSolid self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_ExtrudedAreaSolid_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepShape_ExtrudedAreaSolid self)

        Increments the reference counter of this object


        """
        return _StepShape.Handle_StepShape_ExtrudedAreaSolid_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepShape_ExtrudedAreaSolid self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_ExtrudedAreaSolid_DecrementRefCounter(self, *args)

Handle_StepShape_ExtrudedAreaSolid_swigregister = _StepShape.Handle_StepShape_ExtrudedAreaSolid_swigregister
Handle_StepShape_ExtrudedAreaSolid_swigregister(Handle_StepShape_ExtrudedAreaSolid)

def Handle_StepShape_ExtrudedAreaSolid_DownCast(thing):
    return _StepShape.Handle_StepShape_ExtrudedAreaSolid_DownCast(thing)
Handle_StepShape_ExtrudedAreaSolid_DownCast = _StepShape.Handle_StepShape_ExtrudedAreaSolid_DownCast

class StepShape_SeamEdge(StepShape_OrientedEdge):
    """Representation of STEP entity SeamEdge"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepShape_SeamEdge
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepShape_SeamEdge(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepShape_SeamEdge self) -> StepShape_SeamEdge

        Empty constructor


        """
        this = _StepShape.new_StepShape_SeamEdge(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepShape_SeamEdge self, Handle_TCollection_HAsciiString aRepresentationItem_Name, Handle_StepShape_Edge aOrientedEdge_EdgeElement, Standard_Boolean const aOrientedEdge_Orientation, Handle_StepGeom_Pcurve aPcurveReference)

        Initialize all fields (own and inherited)

        :type aRepresentationItem_Name: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aOrientedEdge_EdgeElement: OCC.wrapper.StepShape.Handle_StepShape_Edge
        :type aOrientedEdge_Orientation: bool
        :type aPcurveReference: OCC.wrapper.StepShape.Handle_StepGeom_Pcurve

        """
        return _StepShape.StepShape_SeamEdge_Init(self, *args)


    def PcurveReference(self, *args):
        """
        PcurveReference(StepShape_SeamEdge self) -> Handle_StepGeom_Pcurve

        Returns field PcurveReference

        :rtype: OCC.wrapper.StepShape.Handle_StepGeom_Pcurve

        """
        return _StepShape.StepShape_SeamEdge_PcurveReference(self, *args)


    def SetPcurveReference(self, *args):
        """
        SetPcurveReference(StepShape_SeamEdge self, Handle_StepGeom_Pcurve PcurveReference)

        Set field PcurveReference

        :type PcurveReference: OCC.wrapper.StepShape.Handle_StepGeom_Pcurve

        """
        return _StepShape.StepShape_SeamEdge_SetPcurveReference(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepShape.StepShape_SeamEdge_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepShape.StepShape_SeamEdge_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.StepShape_SeamEdge_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepShape.delete_StepShape_SeamEdge
StepShape_SeamEdge_swigregister = _StepShape.StepShape_SeamEdge_swigregister
StepShape_SeamEdge_swigregister(StepShape_SeamEdge)

def StepShape_SeamEdge_get_type_name(*args):
    """
    StepShape_SeamEdge_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepShape.StepShape_SeamEdge_get_type_name(*args)

def StepShape_SeamEdge_get_type_descriptor(*args):
    """
    StepShape_SeamEdge_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepShape.StepShape_SeamEdge_get_type_descriptor(*args)

class Handle_StepShape_DimensionalCharacteristicRepresentation(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepShape_DimensionalCharacteristicRepresentation self)

        Nullify the handle


        """
        return _StepShape.Handle_StepShape_DimensionalCharacteristicRepresentation_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepShape_DimensionalCharacteristicRepresentation self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepShape.Handle_StepShape_DimensionalCharacteristicRepresentation_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepShape_DimensionalCharacteristicRepresentation self, StepShape_DimensionalCharacteristicRepresentation thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepShape.Handle_StepShape_DimensionalCharacteristicRepresentation_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepShape_DimensionalCharacteristicRepresentation self, Handle_StepShape_DimensionalCharacteristicRepresentation theHandle) -> Handle_StepShape_DimensionalCharacteristicRepresentation
        assign(Handle_StepShape_DimensionalCharacteristicRepresentation self, StepShape_DimensionalCharacteristicRepresentation thePtr) -> Handle_StepShape_DimensionalCharacteristicRepresentation
        assign(Handle_StepShape_DimensionalCharacteristicRepresentation self, Handle_StepShape_DimensionalCharacteristicRepresentation theHandle) -> Handle_StepShape_DimensionalCharacteristicRepresentation

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepShape.Handle_StepShape_DimensionalCharacteristicRepresentation_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepShape_DimensionalCharacteristicRepresentation self) -> StepShape_DimensionalCharacteristicRepresentation

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepShape.Handle_StepShape_DimensionalCharacteristicRepresentation_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepShape_DimensionalCharacteristicRepresentation self) -> StepShape_DimensionalCharacteristicRepresentation

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepShape.Handle_StepShape_DimensionalCharacteristicRepresentation___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepShape_DimensionalCharacteristicRepresentation self) -> StepShape_DimensionalCharacteristicRepresentation

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepShape.Handle_StepShape_DimensionalCharacteristicRepresentation___ref__(self, *args)


    def __hash__(self):
        return _StepShape.Handle_StepShape_DimensionalCharacteristicRepresentation___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepShape.Handle_StepShape_DimensionalCharacteristicRepresentation___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepShape.new_Handle_StepShape_DimensionalCharacteristicRepresentation(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepShape.Handle_StepShape_DimensionalCharacteristicRepresentation_DownCast)
    __swig_destroy__ = _StepShape.delete_Handle_StepShape_DimensionalCharacteristicRepresentation

    def Init(self, *args):
        """
        Init(Handle_StepShape_DimensionalCharacteristicRepresentation self, StepShape_DimensionalCharacteristic aDimension, Handle_StepShape_ShapeDimensionRepresentation aRepresentation)

        Initialize all fields (own and inherited)

        :type aDimension: OCC.wrapper.StepShape.StepShape_DimensionalCharacteristic
        :type aRepresentation: OCC.wrapper.StepShape.Handle_StepShape_ShapeDimensionRepresentation

        """
        return _StepShape.Handle_StepShape_DimensionalCharacteristicRepresentation_Init(self, *args)


    def Dimension(self, *args):
        """
        Dimension(Handle_StepShape_DimensionalCharacteristicRepresentation self) -> StepShape_DimensionalCharacteristic

        Returns field Dimension

        :rtype: OCC.wrapper.StepShape.StepShape_DimensionalCharacteristic

        """
        return _StepShape.Handle_StepShape_DimensionalCharacteristicRepresentation_Dimension(self, *args)


    def SetDimension(self, *args):
        """
        SetDimension(Handle_StepShape_DimensionalCharacteristicRepresentation self, StepShape_DimensionalCharacteristic Dimension)

        Set field Dimension

        :type Dimension: OCC.wrapper.StepShape.StepShape_DimensionalCharacteristic

        """
        return _StepShape.Handle_StepShape_DimensionalCharacteristicRepresentation_SetDimension(self, *args)


    def Representation(self, *args):
        """
        Representation(Handle_StepShape_DimensionalCharacteristicRepresentation self) -> Handle_StepShape_ShapeDimensionRepresentation

        Returns field Representation

        :rtype: OCC.wrapper.StepShape.Handle_StepShape_ShapeDimensionRepresentation

        """
        return _StepShape.Handle_StepShape_DimensionalCharacteristicRepresentation_Representation(self, *args)


    def SetRepresentation(self, *args):
        """
        SetRepresentation(Handle_StepShape_DimensionalCharacteristicRepresentation self, Handle_StepShape_ShapeDimensionRepresentation Representation)

        Set field Representation

        :type Representation: OCC.wrapper.StepShape.Handle_StepShape_ShapeDimensionRepresentation

        """
        return _StepShape.Handle_StepShape_DimensionalCharacteristicRepresentation_SetRepresentation(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepShape_DimensionalCharacteristicRepresentation self) -> char const *

        :rtype: const char *

        """
        return _StepShape.Handle_StepShape_DimensionalCharacteristicRepresentation_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.Handle_StepShape_DimensionalCharacteristicRepresentation_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.Handle_StepShape_DimensionalCharacteristicRepresentation_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_StepShape_DimensionalCharacteristicRepresentation self)

        Memory deallocator for transient classes


        """
        return _StepShape.Handle_StepShape_DimensionalCharacteristicRepresentation_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepShape_DimensionalCharacteristicRepresentation self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepShape_DimensionalCharacteristicRepresentation self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.Handle_StepShape_DimensionalCharacteristicRepresentation_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepShape_DimensionalCharacteristicRepresentation self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepShape_DimensionalCharacteristicRepresentation self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.Handle_StepShape_DimensionalCharacteristicRepresentation_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepShape_DimensionalCharacteristicRepresentation self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepShape.Handle_StepShape_DimensionalCharacteristicRepresentation_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepShape_DimensionalCharacteristicRepresentation self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_DimensionalCharacteristicRepresentation_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepShape_DimensionalCharacteristicRepresentation self)

        Increments the reference counter of this object


        """
        return _StepShape.Handle_StepShape_DimensionalCharacteristicRepresentation_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepShape_DimensionalCharacteristicRepresentation self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_DimensionalCharacteristicRepresentation_DecrementRefCounter(self, *args)

Handle_StepShape_DimensionalCharacteristicRepresentation_swigregister = _StepShape.Handle_StepShape_DimensionalCharacteristicRepresentation_swigregister
Handle_StepShape_DimensionalCharacteristicRepresentation_swigregister(Handle_StepShape_DimensionalCharacteristicRepresentation)

def Handle_StepShape_DimensionalCharacteristicRepresentation_DownCast(thing):
    return _StepShape.Handle_StepShape_DimensionalCharacteristicRepresentation_DownCast(thing)
Handle_StepShape_DimensionalCharacteristicRepresentation_DownCast = _StepShape.Handle_StepShape_DimensionalCharacteristicRepresentation_DownCast

class StepShape_MeasureRepresentationItemAndQualifiedRepresentationItem(StepRepr.StepRepr_RepresentationItem):
    """
    Added for Dimensional Tolerances
    Complex Type between MeasureRepresentationItem and
    QualifiedRepresentationItem
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepShape_MeasureRepresentationItemAndQualifiedRepresentationItem
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepShape_MeasureRepresentationItemAndQualifiedRepresentationItem(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepShape_MeasureRepresentationItemAndQualifiedRepresentationItem self) -> StepShape_MeasureRepresentationItemAndQualifiedRepresentationItem

        Added for Dimensional Tolerances
        Complex Type between MeasureRepresentationItem and
        QualifiedRepresentationItem
        """
        this = _StepShape.new_StepShape_MeasureRepresentationItemAndQualifiedRepresentationItem(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepShape_MeasureRepresentationItemAndQualifiedRepresentationItem self, Handle_TCollection_HAsciiString aName, Handle_StepBasic_MeasureValueMember aValueComponent, StepBasic_Unit aUnitComponent, Handle_StepShape_HArray1OfValueQualifier qualifiers)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aValueComponent: OCC.wrapper.StepBasic.Handle_StepBasic_MeasureValueMember
        :type aUnitComponent: OCC.wrapper.StepBasic.StepBasic_Unit
        :type qualifiers: OCC.wrapper.StepShape.Handle_StepShape_HArray1OfValueQualifier

        """
        return _StepShape.StepShape_MeasureRepresentationItemAndQualifiedRepresentationItem_Init(self, *args)


    def SetMeasure(self, *args):
        """
        SetMeasure(StepShape_MeasureRepresentationItemAndQualifiedRepresentationItem self, Handle_StepBasic_MeasureWithUnit Measure)

        :type Measure: OCC.wrapper.StepBasic.Handle_StepBasic_MeasureWithUnit

        """
        return _StepShape.StepShape_MeasureRepresentationItemAndQualifiedRepresentationItem_SetMeasure(self, *args)


    def Measure(self, *args):
        """
        Measure(StepShape_MeasureRepresentationItemAndQualifiedRepresentationItem self) -> Handle_StepBasic_MeasureWithUnit

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_MeasureWithUnit

        """
        return _StepShape.StepShape_MeasureRepresentationItemAndQualifiedRepresentationItem_Measure(self, *args)


    def Qualifiers(self, *args):
        """
        Qualifiers(StepShape_MeasureRepresentationItemAndQualifiedRepresentationItem self) -> Handle_StepShape_HArray1OfValueQualifier

        :rtype: OCC.wrapper.StepShape.Handle_StepShape_HArray1OfValueQualifier

        """
        return _StepShape.StepShape_MeasureRepresentationItemAndQualifiedRepresentationItem_Qualifiers(self, *args)


    def NbQualifiers(self, *args):
        """
        NbQualifiers(StepShape_MeasureRepresentationItemAndQualifiedRepresentationItem self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.StepShape_MeasureRepresentationItemAndQualifiedRepresentationItem_NbQualifiers(self, *args)


    def SetQualifiers(self, *args):
        """
        SetQualifiers(StepShape_MeasureRepresentationItemAndQualifiedRepresentationItem self, Handle_StepShape_HArray1OfValueQualifier qualifiers)

        :type qualifiers: OCC.wrapper.StepShape.Handle_StepShape_HArray1OfValueQualifier

        """
        return _StepShape.StepShape_MeasureRepresentationItemAndQualifiedRepresentationItem_SetQualifiers(self, *args)


    def QualifiersValue(self, *args):
        """
        QualifiersValue(StepShape_MeasureRepresentationItemAndQualifiedRepresentationItem self, Standard_Integer const num) -> StepShape_ValueQualifier

        :type num: int
        :rtype: OCC.wrapper.StepShape.StepShape_ValueQualifier

        """
        return _StepShape.StepShape_MeasureRepresentationItemAndQualifiedRepresentationItem_QualifiersValue(self, *args)


    def SetQualifiersValue(self, *args):
        """
        SetQualifiersValue(StepShape_MeasureRepresentationItemAndQualifiedRepresentationItem self, Standard_Integer const num, StepShape_ValueQualifier aqualifier)

        :type num: int
        :type aqualifier: OCC.wrapper.StepShape.StepShape_ValueQualifier

        """
        return _StepShape.StepShape_MeasureRepresentationItemAndQualifiedRepresentationItem_SetQualifiersValue(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepShape.StepShape_MeasureRepresentationItemAndQualifiedRepresentationItem_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepShape.StepShape_MeasureRepresentationItemAndQualifiedRepresentationItem_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.StepShape_MeasureRepresentationItemAndQualifiedRepresentationItem_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepShape.delete_StepShape_MeasureRepresentationItemAndQualifiedRepresentationItem
StepShape_MeasureRepresentationItemAndQualifiedRepresentationItem_swigregister = _StepShape.StepShape_MeasureRepresentationItemAndQualifiedRepresentationItem_swigregister
StepShape_MeasureRepresentationItemAndQualifiedRepresentationItem_swigregister(StepShape_MeasureRepresentationItemAndQualifiedRepresentationItem)

def StepShape_MeasureRepresentationItemAndQualifiedRepresentationItem_get_type_name(*args):
    """
    StepShape_MeasureRepresentationItemAndQualifiedRepresentationItem_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepShape.StepShape_MeasureRepresentationItemAndQualifiedRepresentationItem_get_type_name(*args)

def StepShape_MeasureRepresentationItemAndQualifiedRepresentationItem_get_type_descriptor(*args):
    """
    StepShape_MeasureRepresentationItemAndQualifiedRepresentationItem_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepShape.StepShape_MeasureRepresentationItemAndQualifiedRepresentationItem_get_type_descriptor(*args)

class NCollection_Array1_Handle_StepShape_OrientedClosedShell(object):
    """
    Purpose:     The class Array1 represents unidimensional arrays 
    of fixed size known at run time. 
    The range of the index is user defined.
    An array1 can be constructed with a "C array".
    This functionality is useful to call methods expecting
    an Array1. It allows to carry the bounds inside the arrays.

    Examples:    Item tab[100]; //  An example with a C array
    Array1OfItem ttab (tab[0],1,100);

    Array1OfItem tttab (ttab(10),10,20); // a slice of ttab

    If you want to reindex an array from 1 to Length do :

    Array1 tab1(tab(tab.Lower()),1,tab.Length());

    Warning:     Programs client of such a class must be independant
    of the range of the first element. Then, a C++ for
    loop must be written like this

    for (i = A.Lower(); i <= A.Upper(); i++)

    Changes:     In  comparison  to  TCollection  the  flag  isAllocated  was
    renamed into myDeletable (alike in  the Array2).  For naming
    compatibility the method IsAllocated remained in class along
    with IsDeletable.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Array1_Handle_StepShape_OrientedClosedShell self) -> NCollection_Array1< opencascade::handle< StepShape_OrientedClosedShell > >::iterator

        Returns an iterator pointing to the first element in the array.

        :rtype: iterator

        """
        return _StepShape.NCollection_Array1_Handle_StepShape_OrientedClosedShell_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Array1_Handle_StepShape_OrientedClosedShell self) -> NCollection_Array1< opencascade::handle< StepShape_OrientedClosedShell > >::iterator

        Returns an iterator referring to the past-the-end element in the array.

        :rtype: iterator

        """
        return _StepShape.NCollection_Array1_Handle_StepShape_OrientedClosedShell_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Array1_Handle_StepShape_OrientedClosedShell self) -> NCollection_Array1< opencascade::handle< StepShape_OrientedClosedShell > >::const_iterator

        Returns a const iterator pointing to the first element in the array.

        :rtype: const_iterator

        """
        return _StepShape.NCollection_Array1_Handle_StepShape_OrientedClosedShell_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Array1_Handle_StepShape_OrientedClosedShell self) -> NCollection_Array1< opencascade::handle< StepShape_OrientedClosedShell > >::const_iterator

        Returns a const iterator referring to the past-the-end element in the array.

        :rtype: const_iterator

        """
        return _StepShape.NCollection_Array1_Handle_StepShape_OrientedClosedShell_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     The class Array1 represents unidimensional arrays 
        of fixed size known at run time. 
        The range of the index is user defined.
        An array1 can be constructed with a "C array".
        This functionality is useful to call methods expecting
        an Array1. It allows to carry the bounds inside the arrays.

        Examples:    Item tab[100]; //  An example with a C array
        Array1OfItem ttab (tab[0],1,100);

        Array1OfItem tttab (ttab(10),10,20); // a slice of ttab

        If you want to reindex an array from 1 to Length do :

        Array1 tab1(tab(tab.Lower()),1,tab.Length());

        Warning:     Programs client of such a class must be independant
        of the range of the first element. Then, a C++ for
        loop must be written like this

        for (i = A.Lower(); i <= A.Upper(); i++)

        Changes:     In  comparison  to  TCollection  the  flag  isAllocated  was
        renamed into myDeletable (alike in  the Array2).  For naming
        compatibility the method IsAllocated remained in class along
        with IsDeletable.
        """
        this = _StepShape.new_NCollection_Array1_Handle_StepShape_OrientedClosedShell(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(NCollection_Array1_Handle_StepShape_OrientedClosedShell self, Handle_StepShape_OrientedClosedShell theValue)

        Initialise the items with theValue

        :type theValue: const TheItemType &

        """
        return _StepShape.NCollection_Array1_Handle_StepShape_OrientedClosedShell_Init(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_Array1_Handle_StepShape_OrientedClosedShell self) -> Standard_Integer

        Size query

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.NCollection_Array1_Handle_StepShape_OrientedClosedShell_Size(self, *args)


    def Length(self, *args):
        """
        Length(NCollection_Array1_Handle_StepShape_OrientedClosedShell self) -> Standard_Integer

        Length query (the same)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.NCollection_Array1_Handle_StepShape_OrientedClosedShell_Length(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Array1_Handle_StepShape_OrientedClosedShell self) -> Standard_Boolean

        Return TRUE if array has zero length.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.NCollection_Array1_Handle_StepShape_OrientedClosedShell_IsEmpty(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Array1_Handle_StepShape_OrientedClosedShell self) -> Standard_Integer

        Lower bound

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.NCollection_Array1_Handle_StepShape_OrientedClosedShell_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Array1_Handle_StepShape_OrientedClosedShell self) -> Standard_Integer

        Upper bound

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.NCollection_Array1_Handle_StepShape_OrientedClosedShell_Upper(self, *args)


    def IsDeletable(self, *args):
        """
        IsDeletable(NCollection_Array1_Handle_StepShape_OrientedClosedShell self) -> Standard_Boolean

        myDeletable flag

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.NCollection_Array1_Handle_StepShape_OrientedClosedShell_IsDeletable(self, *args)


    def IsAllocated(self, *args):
        """
        IsAllocated(NCollection_Array1_Handle_StepShape_OrientedClosedShell self) -> Standard_Boolean

        IsAllocated flag - for naming compatibility

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.NCollection_Array1_Handle_StepShape_OrientedClosedShell_IsAllocated(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Array1_Handle_StepShape_OrientedClosedShell self, NCollection_Array1_Handle_StepShape_OrientedClosedShell theOther) -> NCollection_Array1_Handle_StepShape_OrientedClosedShell

        Copies data of theOther array to this.
        This array should be pre-allocated and have the same length as theOther;
        otherwise exception Standard_DimensionMismatch is thrown.

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _StepShape.NCollection_Array1_Handle_StepShape_OrientedClosedShell_Assign(self, *args)


    def Move(self, *args):
        """
        Move(NCollection_Array1_Handle_StepShape_OrientedClosedShell self, NCollection_Array1_Handle_StepShape_OrientedClosedShell theOther) -> NCollection_Array1_Handle_StepShape_OrientedClosedShell

        Move assignment.
        This array will borrow all the data from theOther.
        The moved object will keep pointer to the memory buffer and
        range, but it will not free the buffer on destruction.

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _StepShape.NCollection_Array1_Handle_StepShape_OrientedClosedShell_Move(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Array1_Handle_StepShape_OrientedClosedShell self, NCollection_Array1_Handle_StepShape_OrientedClosedShell theOther) -> NCollection_Array1_Handle_StepShape_OrientedClosedShell
        assign(NCollection_Array1_Handle_StepShape_OrientedClosedShell self, NCollection_Array1_Handle_StepShape_OrientedClosedShell theOther) -> NCollection_Array1_Handle_StepShape_OrientedClosedShell

        Move assignment operator; @sa Move()

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1<TheItemType> &&
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _StepShape.NCollection_Array1_Handle_StepShape_OrientedClosedShell_assign(self, *args)


    def First(self, *args):
        """
        @return first element

        :rtype: const TheItemType &

        """
        res = _StepShape.NCollection_Array1_Handle_StepShape_OrientedClosedShell_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Array1_Handle_StepShape_OrientedClosedShell self) -> Handle_StepShape_OrientedClosedShell

        @return first element

        :rtype: TheItemType &

        """
        return _StepShape.NCollection_Array1_Handle_StepShape_OrientedClosedShell_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        @return last element

        :rtype: const TheItemType &

        """
        res = _StepShape.NCollection_Array1_Handle_StepShape_OrientedClosedShell_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Array1_Handle_StepShape_OrientedClosedShell self) -> Handle_StepShape_OrientedClosedShell

        @return last element

        :rtype: TheItemType &

        """
        return _StepShape.NCollection_Array1_Handle_StepShape_OrientedClosedShell_ChangeLast(self, *args)


    def Value(self, *args):
        """
        Constant value access

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _StepShape.NCollection_Array1_Handle_StepShape_OrientedClosedShell_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Array1_Handle_StepShape_OrientedClosedShell self, Standard_Integer const theIndex) -> Handle_StepShape_OrientedClosedShell

        Variable value access

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _StepShape.NCollection_Array1_Handle_StepShape_OrientedClosedShell_ChangeValue(self, *args)


    def __call__(self, *args):
        """
        operator() - alias to Value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _StepShape.NCollection_Array1_Handle_StepShape_OrientedClosedShell___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __getitem__(self, *args):
        """
        operator[] - alias to Value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _StepShape.NCollection_Array1_Handle_StepShape_OrientedClosedShell_at(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetValue(self, *args):
        """
        SetValue(NCollection_Array1_Handle_StepShape_OrientedClosedShell self, Standard_Integer const theIndex, Handle_StepShape_OrientedClosedShell theItem)

        Set value 

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _StepShape.NCollection_Array1_Handle_StepShape_OrientedClosedShell_SetValue(self, *args)


    def Resize(self, *args):
        """
        Resize(NCollection_Array1_Handle_StepShape_OrientedClosedShell self, Standard_Integer const theLower, Standard_Integer const theUpper, Standard_Boolean const theToCopyData)

        Resizes the array to specified bounds.
        No re-allocation will be done if length of array does not change,
        but existing values will not be discarded if theToCopyData set to FALSE.
        @param theLower new lower bound of array
        @param theUpper new upper bound of array
        @param theToCopyData flag to copy existing data into new array

        :type theLower: int
        :type theUpper: int
        :type theToCopyData: bool

        """
        return _StepShape.NCollection_Array1_Handle_StepShape_OrientedClosedShell_Resize(self, *args)

    __swig_destroy__ = _StepShape.delete_NCollection_Array1_Handle_StepShape_OrientedClosedShell
NCollection_Array1_Handle_StepShape_OrientedClosedShell_swigregister = _StepShape.NCollection_Array1_Handle_StepShape_OrientedClosedShell_swigregister
NCollection_Array1_Handle_StepShape_OrientedClosedShell_swigregister(NCollection_Array1_Handle_StepShape_OrientedClosedShell)


try:
	StepShape_Array1OfOrientedClosedShell = NCollection_Array1_Handle_StepShape_OrientedClosedShell
except NameError:
	pass # does not exist, probably ignored

class NCollection_Array1_Handle_StepShape_Edge(object):
    """
    Purpose:     The class Array1 represents unidimensional arrays 
    of fixed size known at run time. 
    The range of the index is user defined.
    An array1 can be constructed with a "C array".
    This functionality is useful to call methods expecting
    an Array1. It allows to carry the bounds inside the arrays.

    Examples:    Item tab[100]; //  An example with a C array
    Array1OfItem ttab (tab[0],1,100);

    Array1OfItem tttab (ttab(10),10,20); // a slice of ttab

    If you want to reindex an array from 1 to Length do :

    Array1 tab1(tab(tab.Lower()),1,tab.Length());

    Warning:     Programs client of such a class must be independant
    of the range of the first element. Then, a C++ for
    loop must be written like this

    for (i = A.Lower(); i <= A.Upper(); i++)

    Changes:     In  comparison  to  TCollection  the  flag  isAllocated  was
    renamed into myDeletable (alike in  the Array2).  For naming
    compatibility the method IsAllocated remained in class along
    with IsDeletable.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Array1_Handle_StepShape_Edge self) -> NCollection_Array1< opencascade::handle< StepShape_Edge > >::iterator

        Returns an iterator pointing to the first element in the array.

        :rtype: iterator

        """
        return _StepShape.NCollection_Array1_Handle_StepShape_Edge_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Array1_Handle_StepShape_Edge self) -> NCollection_Array1< opencascade::handle< StepShape_Edge > >::iterator

        Returns an iterator referring to the past-the-end element in the array.

        :rtype: iterator

        """
        return _StepShape.NCollection_Array1_Handle_StepShape_Edge_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Array1_Handle_StepShape_Edge self) -> NCollection_Array1< opencascade::handle< StepShape_Edge > >::const_iterator

        Returns a const iterator pointing to the first element in the array.

        :rtype: const_iterator

        """
        return _StepShape.NCollection_Array1_Handle_StepShape_Edge_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Array1_Handle_StepShape_Edge self) -> NCollection_Array1< opencascade::handle< StepShape_Edge > >::const_iterator

        Returns a const iterator referring to the past-the-end element in the array.

        :rtype: const_iterator

        """
        return _StepShape.NCollection_Array1_Handle_StepShape_Edge_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     The class Array1 represents unidimensional arrays 
        of fixed size known at run time. 
        The range of the index is user defined.
        An array1 can be constructed with a "C array".
        This functionality is useful to call methods expecting
        an Array1. It allows to carry the bounds inside the arrays.

        Examples:    Item tab[100]; //  An example with a C array
        Array1OfItem ttab (tab[0],1,100);

        Array1OfItem tttab (ttab(10),10,20); // a slice of ttab

        If you want to reindex an array from 1 to Length do :

        Array1 tab1(tab(tab.Lower()),1,tab.Length());

        Warning:     Programs client of such a class must be independant
        of the range of the first element. Then, a C++ for
        loop must be written like this

        for (i = A.Lower(); i <= A.Upper(); i++)

        Changes:     In  comparison  to  TCollection  the  flag  isAllocated  was
        renamed into myDeletable (alike in  the Array2).  For naming
        compatibility the method IsAllocated remained in class along
        with IsDeletable.
        """
        this = _StepShape.new_NCollection_Array1_Handle_StepShape_Edge(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(NCollection_Array1_Handle_StepShape_Edge self, Handle_StepShape_Edge theValue)

        Initialise the items with theValue

        :type theValue: const TheItemType &

        """
        return _StepShape.NCollection_Array1_Handle_StepShape_Edge_Init(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_Array1_Handle_StepShape_Edge self) -> Standard_Integer

        Size query

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.NCollection_Array1_Handle_StepShape_Edge_Size(self, *args)


    def Length(self, *args):
        """
        Length(NCollection_Array1_Handle_StepShape_Edge self) -> Standard_Integer

        Length query (the same)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.NCollection_Array1_Handle_StepShape_Edge_Length(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Array1_Handle_StepShape_Edge self) -> Standard_Boolean

        Return TRUE if array has zero length.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.NCollection_Array1_Handle_StepShape_Edge_IsEmpty(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Array1_Handle_StepShape_Edge self) -> Standard_Integer

        Lower bound

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.NCollection_Array1_Handle_StepShape_Edge_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Array1_Handle_StepShape_Edge self) -> Standard_Integer

        Upper bound

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.NCollection_Array1_Handle_StepShape_Edge_Upper(self, *args)


    def IsDeletable(self, *args):
        """
        IsDeletable(NCollection_Array1_Handle_StepShape_Edge self) -> Standard_Boolean

        myDeletable flag

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.NCollection_Array1_Handle_StepShape_Edge_IsDeletable(self, *args)


    def IsAllocated(self, *args):
        """
        IsAllocated(NCollection_Array1_Handle_StepShape_Edge self) -> Standard_Boolean

        IsAllocated flag - for naming compatibility

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.NCollection_Array1_Handle_StepShape_Edge_IsAllocated(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Array1_Handle_StepShape_Edge self, NCollection_Array1_Handle_StepShape_Edge theOther) -> NCollection_Array1_Handle_StepShape_Edge

        Copies data of theOther array to this.
        This array should be pre-allocated and have the same length as theOther;
        otherwise exception Standard_DimensionMismatch is thrown.

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _StepShape.NCollection_Array1_Handle_StepShape_Edge_Assign(self, *args)


    def Move(self, *args):
        """
        Move(NCollection_Array1_Handle_StepShape_Edge self, NCollection_Array1_Handle_StepShape_Edge theOther) -> NCollection_Array1_Handle_StepShape_Edge

        Move assignment.
        This array will borrow all the data from theOther.
        The moved object will keep pointer to the memory buffer and
        range, but it will not free the buffer on destruction.

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _StepShape.NCollection_Array1_Handle_StepShape_Edge_Move(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Array1_Handle_StepShape_Edge self, NCollection_Array1_Handle_StepShape_Edge theOther) -> NCollection_Array1_Handle_StepShape_Edge
        assign(NCollection_Array1_Handle_StepShape_Edge self, NCollection_Array1_Handle_StepShape_Edge theOther) -> NCollection_Array1_Handle_StepShape_Edge

        Move assignment operator; @sa Move()

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1<TheItemType> &&
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _StepShape.NCollection_Array1_Handle_StepShape_Edge_assign(self, *args)


    def First(self, *args):
        """
        @return first element

        :rtype: const TheItemType &

        """
        res = _StepShape.NCollection_Array1_Handle_StepShape_Edge_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Array1_Handle_StepShape_Edge self) -> Handle_StepShape_Edge

        @return first element

        :rtype: TheItemType &

        """
        return _StepShape.NCollection_Array1_Handle_StepShape_Edge_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        @return last element

        :rtype: const TheItemType &

        """
        res = _StepShape.NCollection_Array1_Handle_StepShape_Edge_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Array1_Handle_StepShape_Edge self) -> Handle_StepShape_Edge

        @return last element

        :rtype: TheItemType &

        """
        return _StepShape.NCollection_Array1_Handle_StepShape_Edge_ChangeLast(self, *args)


    def Value(self, *args):
        """
        Constant value access

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _StepShape.NCollection_Array1_Handle_StepShape_Edge_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Array1_Handle_StepShape_Edge self, Standard_Integer const theIndex) -> Handle_StepShape_Edge

        Variable value access

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _StepShape.NCollection_Array1_Handle_StepShape_Edge_ChangeValue(self, *args)


    def __call__(self, *args):
        """
        operator() - alias to Value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _StepShape.NCollection_Array1_Handle_StepShape_Edge___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __getitem__(self, *args):
        """
        operator[] - alias to Value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _StepShape.NCollection_Array1_Handle_StepShape_Edge_at(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetValue(self, *args):
        """
        SetValue(NCollection_Array1_Handle_StepShape_Edge self, Standard_Integer const theIndex, Handle_StepShape_Edge theItem)

        Set value 

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _StepShape.NCollection_Array1_Handle_StepShape_Edge_SetValue(self, *args)


    def Resize(self, *args):
        """
        Resize(NCollection_Array1_Handle_StepShape_Edge self, Standard_Integer const theLower, Standard_Integer const theUpper, Standard_Boolean const theToCopyData)

        Resizes the array to specified bounds.
        No re-allocation will be done if length of array does not change,
        but existing values will not be discarded if theToCopyData set to FALSE.
        @param theLower new lower bound of array
        @param theUpper new upper bound of array
        @param theToCopyData flag to copy existing data into new array

        :type theLower: int
        :type theUpper: int
        :type theToCopyData: bool

        """
        return _StepShape.NCollection_Array1_Handle_StepShape_Edge_Resize(self, *args)

    __swig_destroy__ = _StepShape.delete_NCollection_Array1_Handle_StepShape_Edge
NCollection_Array1_Handle_StepShape_Edge_swigregister = _StepShape.NCollection_Array1_Handle_StepShape_Edge_swigregister
NCollection_Array1_Handle_StepShape_Edge_swigregister(NCollection_Array1_Handle_StepShape_Edge)


try:
	StepShape_Array1OfEdge = NCollection_Array1_Handle_StepShape_Edge
except NameError:
	pass # does not exist, probably ignored

class Handle_StepShape_RevolvedAreaSolid(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepShape_RevolvedAreaSolid self)

        Nullify the handle


        """
        return _StepShape.Handle_StepShape_RevolvedAreaSolid_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepShape_RevolvedAreaSolid self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepShape.Handle_StepShape_RevolvedAreaSolid_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepShape_RevolvedAreaSolid self, StepShape_RevolvedAreaSolid thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepShape.Handle_StepShape_RevolvedAreaSolid_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepShape_RevolvedAreaSolid self, Handle_StepShape_RevolvedAreaSolid theHandle) -> Handle_StepShape_RevolvedAreaSolid
        assign(Handle_StepShape_RevolvedAreaSolid self, StepShape_RevolvedAreaSolid thePtr) -> Handle_StepShape_RevolvedAreaSolid
        assign(Handle_StepShape_RevolvedAreaSolid self, Handle_StepShape_RevolvedAreaSolid theHandle) -> Handle_StepShape_RevolvedAreaSolid

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepShape.Handle_StepShape_RevolvedAreaSolid_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepShape_RevolvedAreaSolid self) -> StepShape_RevolvedAreaSolid

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepShape.Handle_StepShape_RevolvedAreaSolid_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepShape_RevolvedAreaSolid self) -> StepShape_RevolvedAreaSolid

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepShape.Handle_StepShape_RevolvedAreaSolid___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepShape_RevolvedAreaSolid self) -> StepShape_RevolvedAreaSolid

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepShape.Handle_StepShape_RevolvedAreaSolid___ref__(self, *args)


    def __hash__(self):
        return _StepShape.Handle_StepShape_RevolvedAreaSolid___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepShape.Handle_StepShape_RevolvedAreaSolid___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepShape.new_Handle_StepShape_RevolvedAreaSolid(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepShape.Handle_StepShape_RevolvedAreaSolid_DownCast)
    __swig_destroy__ = _StepShape.delete_Handle_StepShape_RevolvedAreaSolid

    def Init(self, *args):
        """
        Init(Handle_StepShape_RevolvedAreaSolid self, Handle_TCollection_HAsciiString aName, Handle_StepGeom_CurveBoundedSurface aSweptArea, Handle_StepGeom_Axis1Placement aAxis, Standard_Real const aAngle)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aSweptArea: OCC.wrapper.StepShape.Handle_StepGeom_CurveBoundedSurface
        :type aAxis: OCC.wrapper.StepShape.Handle_StepGeom_Axis1Placement
        :type aAngle: float

        """
        return _StepShape.Handle_StepShape_RevolvedAreaSolid_Init(self, *args)


    def SetAxis(self, *args):
        """
        SetAxis(Handle_StepShape_RevolvedAreaSolid self, Handle_StepGeom_Axis1Placement aAxis)

        :type aAxis: OCC.wrapper.StepShape.Handle_StepGeom_Axis1Placement

        """
        return _StepShape.Handle_StepShape_RevolvedAreaSolid_SetAxis(self, *args)


    def Axis(self, *args):
        """
        Axis(Handle_StepShape_RevolvedAreaSolid self) -> Handle_StepGeom_Axis1Placement

        :rtype: OCC.wrapper.StepShape.Handle_StepGeom_Axis1Placement

        """
        return _StepShape.Handle_StepShape_RevolvedAreaSolid_Axis(self, *args)


    def SetAngle(self, *args):
        """
        SetAngle(Handle_StepShape_RevolvedAreaSolid self, Standard_Real const aAngle)

        :type aAngle: float

        """
        return _StepShape.Handle_StepShape_RevolvedAreaSolid_SetAngle(self, *args)


    def Angle(self, *args):
        """
        Angle(Handle_StepShape_RevolvedAreaSolid self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _StepShape.Handle_StepShape_RevolvedAreaSolid_Angle(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepShape_RevolvedAreaSolid self) -> char const *

        :rtype: const char *

        """
        return _StepShape.Handle_StepShape_RevolvedAreaSolid_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.Handle_StepShape_RevolvedAreaSolid_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.Handle_StepShape_RevolvedAreaSolid_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetSweptArea(self, *args):
        """
        SetSweptArea(Handle_StepShape_RevolvedAreaSolid self, Handle_StepGeom_CurveBoundedSurface aSweptArea)

        :type aSweptArea: OCC.wrapper.StepShape.Handle_StepGeom_CurveBoundedSurface

        """
        return _StepShape.Handle_StepShape_RevolvedAreaSolid_SetSweptArea(self, *args)


    def SweptArea(self, *args):
        """
        SweptArea(Handle_StepShape_RevolvedAreaSolid self) -> Handle_StepGeom_CurveBoundedSurface

        :rtype: OCC.wrapper.StepShape.Handle_StepGeom_CurveBoundedSurface

        """
        return _StepShape.Handle_StepShape_RevolvedAreaSolid_SweptArea(self, *args)


    def SetName(self, *args):
        """
        SetName(Handle_StepShape_RevolvedAreaSolid self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepShape.Handle_StepShape_RevolvedAreaSolid_SetName(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepShape_RevolvedAreaSolid self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepShape.Handle_StepShape_RevolvedAreaSolid_Name(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepShape_RevolvedAreaSolid self)

        Memory deallocator for transient classes


        """
        return _StepShape.Handle_StepShape_RevolvedAreaSolid_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepShape_RevolvedAreaSolid self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepShape_RevolvedAreaSolid self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.Handle_StepShape_RevolvedAreaSolid_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepShape_RevolvedAreaSolid self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepShape_RevolvedAreaSolid self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.Handle_StepShape_RevolvedAreaSolid_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepShape_RevolvedAreaSolid self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepShape.Handle_StepShape_RevolvedAreaSolid_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepShape_RevolvedAreaSolid self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_RevolvedAreaSolid_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepShape_RevolvedAreaSolid self)

        Increments the reference counter of this object


        """
        return _StepShape.Handle_StepShape_RevolvedAreaSolid_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepShape_RevolvedAreaSolid self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_RevolvedAreaSolid_DecrementRefCounter(self, *args)

Handle_StepShape_RevolvedAreaSolid_swigregister = _StepShape.Handle_StepShape_RevolvedAreaSolid_swigregister
Handle_StepShape_RevolvedAreaSolid_swigregister(Handle_StepShape_RevolvedAreaSolid)

def Handle_StepShape_RevolvedAreaSolid_DownCast(thing):
    return _StepShape.Handle_StepShape_RevolvedAreaSolid_DownCast(thing)
Handle_StepShape_RevolvedAreaSolid_DownCast = _StepShape.Handle_StepShape_RevolvedAreaSolid_DownCast

class StepShape_FacetedBrepAndBrepWithVoids(StepShape_ManifoldSolidBrep):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepShape_FacetedBrepAndBrepWithVoids
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepShape_FacetedBrepAndBrepWithVoids(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepShape_FacetedBrepAndBrepWithVoids self) -> StepShape_FacetedBrepAndBrepWithVoids

        Returns a FacetedBrepAndBrepWithVoids


        """
        this = _StepShape.new_StepShape_FacetedBrepAndBrepWithVoids(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepShape_FacetedBrepAndBrepWithVoids self, Handle_TCollection_HAsciiString aName, Handle_StepShape_ClosedShell aOuter, Handle_StepShape_FacetedBrep aFacetedBrep, Handle_StepShape_BrepWithVoids aBrepWithVoids)
        Init(StepShape_FacetedBrepAndBrepWithVoids self, Handle_TCollection_HAsciiString aName, Handle_StepShape_ClosedShell aOuter, Handle_StepShape_HArray1OfOrientedClosedShell aVoids)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aOuter: OCC.wrapper.StepShape.Handle_StepShape_ClosedShell
        :type aVoids: OCC.wrapper.StepShape.Handle_StepShape_HArray1OfOrientedClosedShell

        """
        return _StepShape.StepShape_FacetedBrepAndBrepWithVoids_Init(self, *args)


    def SetFacetedBrep(self, *args):
        """
        SetFacetedBrep(StepShape_FacetedBrepAndBrepWithVoids self, Handle_StepShape_FacetedBrep aFacetedBrep)

        :type aFacetedBrep: OCC.wrapper.StepShape.Handle_StepShape_FacetedBrep

        """
        return _StepShape.StepShape_FacetedBrepAndBrepWithVoids_SetFacetedBrep(self, *args)


    def FacetedBrep(self, *args):
        """
        FacetedBrep(StepShape_FacetedBrepAndBrepWithVoids self) -> Handle_StepShape_FacetedBrep

        :rtype: OCC.wrapper.StepShape.Handle_StepShape_FacetedBrep

        """
        return _StepShape.StepShape_FacetedBrepAndBrepWithVoids_FacetedBrep(self, *args)


    def SetBrepWithVoids(self, *args):
        """
        SetBrepWithVoids(StepShape_FacetedBrepAndBrepWithVoids self, Handle_StepShape_BrepWithVoids aBrepWithVoids)

        :type aBrepWithVoids: OCC.wrapper.StepShape.Handle_StepShape_BrepWithVoids

        """
        return _StepShape.StepShape_FacetedBrepAndBrepWithVoids_SetBrepWithVoids(self, *args)


    def BrepWithVoids(self, *args):
        """
        BrepWithVoids(StepShape_FacetedBrepAndBrepWithVoids self) -> Handle_StepShape_BrepWithVoids

        :rtype: OCC.wrapper.StepShape.Handle_StepShape_BrepWithVoids

        """
        return _StepShape.StepShape_FacetedBrepAndBrepWithVoids_BrepWithVoids(self, *args)


    def SetVoids(self, *args):
        """
        SetVoids(StepShape_FacetedBrepAndBrepWithVoids self, Handle_StepShape_HArray1OfOrientedClosedShell aVoids)

        :type aVoids: OCC.wrapper.StepShape.Handle_StepShape_HArray1OfOrientedClosedShell

        """
        return _StepShape.StepShape_FacetedBrepAndBrepWithVoids_SetVoids(self, *args)


    def Voids(self, *args):
        """
        Voids(StepShape_FacetedBrepAndBrepWithVoids self) -> Handle_StepShape_HArray1OfOrientedClosedShell

        :rtype: OCC.wrapper.StepShape.Handle_StepShape_HArray1OfOrientedClosedShell

        """
        return _StepShape.StepShape_FacetedBrepAndBrepWithVoids_Voids(self, *args)


    def VoidsValue(self, *args):
        """
        VoidsValue(StepShape_FacetedBrepAndBrepWithVoids self, Standard_Integer const num) -> Handle_StepShape_OrientedClosedShell

        :type num: int
        :rtype: OCC.wrapper.StepShape.Handle_StepShape_OrientedClosedShell

        """
        return _StepShape.StepShape_FacetedBrepAndBrepWithVoids_VoidsValue(self, *args)


    def NbVoids(self, *args):
        """
        NbVoids(StepShape_FacetedBrepAndBrepWithVoids self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.StepShape_FacetedBrepAndBrepWithVoids_NbVoids(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepShape.StepShape_FacetedBrepAndBrepWithVoids_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepShape.StepShape_FacetedBrepAndBrepWithVoids_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.StepShape_FacetedBrepAndBrepWithVoids_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepShape.delete_StepShape_FacetedBrepAndBrepWithVoids
StepShape_FacetedBrepAndBrepWithVoids_swigregister = _StepShape.StepShape_FacetedBrepAndBrepWithVoids_swigregister
StepShape_FacetedBrepAndBrepWithVoids_swigregister(StepShape_FacetedBrepAndBrepWithVoids)

def StepShape_FacetedBrepAndBrepWithVoids_get_type_name(*args):
    """
    StepShape_FacetedBrepAndBrepWithVoids_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepShape.StepShape_FacetedBrepAndBrepWithVoids_get_type_name(*args)

def StepShape_FacetedBrepAndBrepWithVoids_get_type_descriptor(*args):
    """
    StepShape_FacetedBrepAndBrepWithVoids_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepShape.StepShape_FacetedBrepAndBrepWithVoids_get_type_descriptor(*args)

class Handle_StepShape_GeometricSet(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepShape_GeometricSet self)

        Nullify the handle


        """
        return _StepShape.Handle_StepShape_GeometricSet_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepShape_GeometricSet self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepShape.Handle_StepShape_GeometricSet_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepShape_GeometricSet self, StepShape_GeometricSet thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepShape.Handle_StepShape_GeometricSet_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepShape_GeometricSet self, Handle_StepShape_GeometricSet theHandle) -> Handle_StepShape_GeometricSet
        assign(Handle_StepShape_GeometricSet self, StepShape_GeometricSet thePtr) -> Handle_StepShape_GeometricSet
        assign(Handle_StepShape_GeometricSet self, Handle_StepShape_GeometricSet theHandle) -> Handle_StepShape_GeometricSet

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepShape.Handle_StepShape_GeometricSet_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepShape_GeometricSet self) -> StepShape_GeometricSet

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepShape.Handle_StepShape_GeometricSet_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepShape_GeometricSet self) -> StepShape_GeometricSet

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepShape.Handle_StepShape_GeometricSet___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepShape_GeometricSet self) -> StepShape_GeometricSet

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepShape.Handle_StepShape_GeometricSet___ref__(self, *args)


    def __hash__(self):
        return _StepShape.Handle_StepShape_GeometricSet___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepShape.Handle_StepShape_GeometricSet___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepShape.new_Handle_StepShape_GeometricSet(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepShape.Handle_StepShape_GeometricSet_DownCast)
    __swig_destroy__ = _StepShape.delete_Handle_StepShape_GeometricSet

    def Init(self, *args):
        """
        Init(Handle_StepShape_GeometricSet self, Handle_TCollection_HAsciiString aName, Handle_StepShape_HArray1OfGeometricSetSelect aElements)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aElements: OCC.wrapper.StepShape.Handle_StepShape_HArray1OfGeometricSetSelect

        """
        return _StepShape.Handle_StepShape_GeometricSet_Init(self, *args)


    def SetElements(self, *args):
        """
        SetElements(Handle_StepShape_GeometricSet self, Handle_StepShape_HArray1OfGeometricSetSelect aElements)

        :type aElements: OCC.wrapper.StepShape.Handle_StepShape_HArray1OfGeometricSetSelect

        """
        return _StepShape.Handle_StepShape_GeometricSet_SetElements(self, *args)


    def Elements(self, *args):
        """
        Elements(Handle_StepShape_GeometricSet self) -> Handle_StepShape_HArray1OfGeometricSetSelect

        :rtype: OCC.wrapper.StepShape.Handle_StepShape_HArray1OfGeometricSetSelect

        """
        return _StepShape.Handle_StepShape_GeometricSet_Elements(self, *args)


    def ElementsValue(self, *args):
        """
        ElementsValue(Handle_StepShape_GeometricSet self, Standard_Integer const num) -> StepShape_GeometricSetSelect

        :type num: int
        :rtype: OCC.wrapper.StepShape.StepShape_GeometricSetSelect

        """
        return _StepShape.Handle_StepShape_GeometricSet_ElementsValue(self, *args)


    def NbElements(self, *args):
        """
        NbElements(Handle_StepShape_GeometricSet self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_GeometricSet_NbElements(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepShape_GeometricSet self) -> char const *

        :rtype: const char *

        """
        return _StepShape.Handle_StepShape_GeometricSet_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.Handle_StepShape_GeometricSet_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.Handle_StepShape_GeometricSet_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetName(self, *args):
        """
        SetName(Handle_StepShape_GeometricSet self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepShape.Handle_StepShape_GeometricSet_SetName(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepShape_GeometricSet self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepShape.Handle_StepShape_GeometricSet_Name(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepShape_GeometricSet self)

        Memory deallocator for transient classes


        """
        return _StepShape.Handle_StepShape_GeometricSet_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepShape_GeometricSet self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepShape_GeometricSet self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.Handle_StepShape_GeometricSet_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepShape_GeometricSet self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepShape_GeometricSet self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.Handle_StepShape_GeometricSet_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepShape_GeometricSet self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepShape.Handle_StepShape_GeometricSet_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepShape_GeometricSet self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_GeometricSet_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepShape_GeometricSet self)

        Increments the reference counter of this object


        """
        return _StepShape.Handle_StepShape_GeometricSet_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepShape_GeometricSet self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_GeometricSet_DecrementRefCounter(self, *args)

Handle_StepShape_GeometricSet_swigregister = _StepShape.Handle_StepShape_GeometricSet_swigregister
Handle_StepShape_GeometricSet_swigregister(Handle_StepShape_GeometricSet)

def Handle_StepShape_GeometricSet_DownCast(thing):
    return _StepShape.Handle_StepShape_GeometricSet_DownCast(thing)
Handle_StepShape_GeometricSet_DownCast = _StepShape.Handle_StepShape_GeometricSet_DownCast

class StepShape_OrientedFace(StepShape_Face):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepShape_OrientedFace
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepShape_OrientedFace(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepShape_OrientedFace self) -> StepShape_OrientedFace

        Returns a OrientedFace


        """
        this = _StepShape.new_StepShape_OrientedFace(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepShape_OrientedFace self, Handle_TCollection_HAsciiString aName, Handle_StepShape_Face aFaceElement, Standard_Boolean const aOrientation)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aFaceElement: OCC.wrapper.StepShape.Handle_StepShape_Face
        :type aOrientation: bool

        """
        return _StepShape.StepShape_OrientedFace_Init(self, *args)


    def SetFaceElement(self, *args):
        """
        SetFaceElement(StepShape_OrientedFace self, Handle_StepShape_Face aFaceElement)

        :type aFaceElement: OCC.wrapper.StepShape.Handle_StepShape_Face

        """
        return _StepShape.StepShape_OrientedFace_SetFaceElement(self, *args)


    def FaceElement(self, *args):
        """
        FaceElement(StepShape_OrientedFace self) -> Handle_StepShape_Face

        :rtype: OCC.wrapper.StepShape.Handle_StepShape_Face

        """
        return _StepShape.StepShape_OrientedFace_FaceElement(self, *args)


    def SetOrientation(self, *args):
        """
        SetOrientation(StepShape_OrientedFace self, Standard_Boolean const aOrientation)

        :type aOrientation: bool

        """
        return _StepShape.StepShape_OrientedFace_SetOrientation(self, *args)


    def Orientation(self, *args):
        """
        Orientation(StepShape_OrientedFace self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.StepShape_OrientedFace_Orientation(self, *args)


    def SetBounds(self, *args):
        """
        SetBounds(StepShape_OrientedFace self, Handle_StepShape_HArray1OfFaceBound aBounds)

        :type aBounds: OCC.wrapper.StepShape.Handle_StepShape_HArray1OfFaceBound

        """
        return _StepShape.StepShape_OrientedFace_SetBounds(self, *args)


    def Bounds(self, *args):
        """
        Bounds(StepShape_OrientedFace self) -> Handle_StepShape_HArray1OfFaceBound

        :rtype: OCC.wrapper.StepShape.Handle_StepShape_HArray1OfFaceBound

        """
        return _StepShape.StepShape_OrientedFace_Bounds(self, *args)


    def BoundsValue(self, *args):
        """
        BoundsValue(StepShape_OrientedFace self, Standard_Integer const num) -> Handle_StepShape_FaceBound

        :type num: int
        :rtype: OCC.wrapper.StepShape.Handle_StepShape_FaceBound

        """
        return _StepShape.StepShape_OrientedFace_BoundsValue(self, *args)


    def NbBounds(self, *args):
        """
        NbBounds(StepShape_OrientedFace self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.StepShape_OrientedFace_NbBounds(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepShape.StepShape_OrientedFace_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepShape.StepShape_OrientedFace_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.StepShape_OrientedFace_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepShape.delete_StepShape_OrientedFace
StepShape_OrientedFace_swigregister = _StepShape.StepShape_OrientedFace_swigregister
StepShape_OrientedFace_swigregister(StepShape_OrientedFace)

def StepShape_OrientedFace_get_type_name(*args):
    """
    StepShape_OrientedFace_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepShape.StepShape_OrientedFace_get_type_name(*args)

def StepShape_OrientedFace_get_type_descriptor(*args):
    """
    StepShape_OrientedFace_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepShape.StepShape_OrientedFace_get_type_descriptor(*args)

class Handle_StepShape_ConnectedFaceSet(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepShape_ConnectedFaceSet self)

        Nullify the handle


        """
        return _StepShape.Handle_StepShape_ConnectedFaceSet_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepShape_ConnectedFaceSet self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepShape.Handle_StepShape_ConnectedFaceSet_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepShape_ConnectedFaceSet self, StepShape_ConnectedFaceSet thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepShape.Handle_StepShape_ConnectedFaceSet_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepShape_ConnectedFaceSet self, Handle_StepShape_ConnectedFaceSet theHandle) -> Handle_StepShape_ConnectedFaceSet
        assign(Handle_StepShape_ConnectedFaceSet self, StepShape_ConnectedFaceSet thePtr) -> Handle_StepShape_ConnectedFaceSet
        assign(Handle_StepShape_ConnectedFaceSet self, Handle_StepShape_ConnectedFaceSet theHandle) -> Handle_StepShape_ConnectedFaceSet

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepShape.Handle_StepShape_ConnectedFaceSet_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepShape_ConnectedFaceSet self) -> StepShape_ConnectedFaceSet

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepShape.Handle_StepShape_ConnectedFaceSet_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepShape_ConnectedFaceSet self) -> StepShape_ConnectedFaceSet

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepShape.Handle_StepShape_ConnectedFaceSet___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepShape_ConnectedFaceSet self) -> StepShape_ConnectedFaceSet

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepShape.Handle_StepShape_ConnectedFaceSet___ref__(self, *args)


    def __hash__(self):
        return _StepShape.Handle_StepShape_ConnectedFaceSet___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepShape.Handle_StepShape_ConnectedFaceSet___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepShape.new_Handle_StepShape_ConnectedFaceSet(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepShape.Handle_StepShape_ConnectedFaceSet_DownCast)
    __swig_destroy__ = _StepShape.delete_Handle_StepShape_ConnectedFaceSet

    def Init(self, *args):
        """
        Init(Handle_StepShape_ConnectedFaceSet self, Handle_TCollection_HAsciiString aName, Handle_StepShape_HArray1OfFace aCfsFaces)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aCfsFaces: OCC.wrapper.StepShape.Handle_StepShape_HArray1OfFace

        """
        return _StepShape.Handle_StepShape_ConnectedFaceSet_Init(self, *args)


    def SetCfsFaces(self, *args):
        """
        SetCfsFaces(Handle_StepShape_ConnectedFaceSet self, Handle_StepShape_HArray1OfFace aCfsFaces)

        :type aCfsFaces: OCC.wrapper.StepShape.Handle_StepShape_HArray1OfFace

        """
        return _StepShape.Handle_StepShape_ConnectedFaceSet_SetCfsFaces(self, *args)


    def CfsFaces(self, *args):
        """
        CfsFaces(Handle_StepShape_ConnectedFaceSet self) -> Handle_StepShape_HArray1OfFace

        :rtype: OCC.wrapper.StepShape.Handle_StepShape_HArray1OfFace

        """
        return _StepShape.Handle_StepShape_ConnectedFaceSet_CfsFaces(self, *args)


    def CfsFacesValue(self, *args):
        """
        CfsFacesValue(Handle_StepShape_ConnectedFaceSet self, Standard_Integer const num) -> Handle_StepShape_Face

        :type num: int
        :rtype: OCC.wrapper.StepShape.Handle_StepShape_Face

        """
        return _StepShape.Handle_StepShape_ConnectedFaceSet_CfsFacesValue(self, *args)


    def NbCfsFaces(self, *args):
        """
        NbCfsFaces(Handle_StepShape_ConnectedFaceSet self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_ConnectedFaceSet_NbCfsFaces(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepShape_ConnectedFaceSet self) -> char const *

        :rtype: const char *

        """
        return _StepShape.Handle_StepShape_ConnectedFaceSet_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.Handle_StepShape_ConnectedFaceSet_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.Handle_StepShape_ConnectedFaceSet_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetName(self, *args):
        """
        SetName(Handle_StepShape_ConnectedFaceSet self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepShape.Handle_StepShape_ConnectedFaceSet_SetName(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepShape_ConnectedFaceSet self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepShape.Handle_StepShape_ConnectedFaceSet_Name(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepShape_ConnectedFaceSet self)

        Memory deallocator for transient classes


        """
        return _StepShape.Handle_StepShape_ConnectedFaceSet_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepShape_ConnectedFaceSet self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepShape_ConnectedFaceSet self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.Handle_StepShape_ConnectedFaceSet_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepShape_ConnectedFaceSet self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepShape_ConnectedFaceSet self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.Handle_StepShape_ConnectedFaceSet_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepShape_ConnectedFaceSet self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepShape.Handle_StepShape_ConnectedFaceSet_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepShape_ConnectedFaceSet self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_ConnectedFaceSet_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepShape_ConnectedFaceSet self)

        Increments the reference counter of this object


        """
        return _StepShape.Handle_StepShape_ConnectedFaceSet_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepShape_ConnectedFaceSet self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_ConnectedFaceSet_DecrementRefCounter(self, *args)

Handle_StepShape_ConnectedFaceSet_swigregister = _StepShape.Handle_StepShape_ConnectedFaceSet_swigregister
Handle_StepShape_ConnectedFaceSet_swigregister(Handle_StepShape_ConnectedFaceSet)

def Handle_StepShape_ConnectedFaceSet_DownCast(thing):
    return _StepShape.Handle_StepShape_ConnectedFaceSet_DownCast(thing)
Handle_StepShape_ConnectedFaceSet_DownCast = _StepShape.Handle_StepShape_ConnectedFaceSet_DownCast

class Handle_StepShape_CsgShapeRepresentation(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepShape_CsgShapeRepresentation self)

        Nullify the handle


        """
        return _StepShape.Handle_StepShape_CsgShapeRepresentation_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepShape_CsgShapeRepresentation self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepShape.Handle_StepShape_CsgShapeRepresentation_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepShape_CsgShapeRepresentation self, StepShape_CsgShapeRepresentation thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepShape.Handle_StepShape_CsgShapeRepresentation_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepShape_CsgShapeRepresentation self, Handle_StepShape_CsgShapeRepresentation theHandle) -> Handle_StepShape_CsgShapeRepresentation
        assign(Handle_StepShape_CsgShapeRepresentation self, StepShape_CsgShapeRepresentation thePtr) -> Handle_StepShape_CsgShapeRepresentation
        assign(Handle_StepShape_CsgShapeRepresentation self, Handle_StepShape_CsgShapeRepresentation theHandle) -> Handle_StepShape_CsgShapeRepresentation

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepShape.Handle_StepShape_CsgShapeRepresentation_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepShape_CsgShapeRepresentation self) -> StepShape_CsgShapeRepresentation

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepShape.Handle_StepShape_CsgShapeRepresentation_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepShape_CsgShapeRepresentation self) -> StepShape_CsgShapeRepresentation

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepShape.Handle_StepShape_CsgShapeRepresentation___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepShape_CsgShapeRepresentation self) -> StepShape_CsgShapeRepresentation

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepShape.Handle_StepShape_CsgShapeRepresentation___ref__(self, *args)


    def __hash__(self):
        return _StepShape.Handle_StepShape_CsgShapeRepresentation___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepShape.Handle_StepShape_CsgShapeRepresentation___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepShape.new_Handle_StepShape_CsgShapeRepresentation(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepShape.Handle_StepShape_CsgShapeRepresentation_DownCast)
    __swig_destroy__ = _StepShape.delete_Handle_StepShape_CsgShapeRepresentation

    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepShape_CsgShapeRepresentation self) -> char const *

        :rtype: const char *

        """
        return _StepShape.Handle_StepShape_CsgShapeRepresentation_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.Handle_StepShape_CsgShapeRepresentation_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.Handle_StepShape_CsgShapeRepresentation_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Init(self, *args):
        """
        Init(Handle_StepShape_CsgShapeRepresentation self, Handle_TCollection_HAsciiString aName, Handle_StepRepr_HArray1OfRepresentationItem aItems, Handle_StepRepr_RepresentationContext aContextOfItems)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aItems: OCC.wrapper.StepRepr.Handle_StepRepr_HArray1OfRepresentationItem
        :type aContextOfItems: OCC.wrapper.StepRepr.Handle_StepRepr_RepresentationContext

        """
        return _StepShape.Handle_StepShape_CsgShapeRepresentation_Init(self, *args)


    def SetName(self, *args):
        """
        SetName(Handle_StepShape_CsgShapeRepresentation self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepShape.Handle_StepShape_CsgShapeRepresentation_SetName(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepShape_CsgShapeRepresentation self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepShape.Handle_StepShape_CsgShapeRepresentation_Name(self, *args)


    def SetItems(self, *args):
        """
        SetItems(Handle_StepShape_CsgShapeRepresentation self, Handle_StepRepr_HArray1OfRepresentationItem aItems)

        :type aItems: OCC.wrapper.StepRepr.Handle_StepRepr_HArray1OfRepresentationItem

        """
        return _StepShape.Handle_StepShape_CsgShapeRepresentation_SetItems(self, *args)


    def Items(self, *args):
        """
        Items(Handle_StepShape_CsgShapeRepresentation self) -> Handle_StepRepr_HArray1OfRepresentationItem

        :rtype: OCC.wrapper.StepRepr.Handle_StepRepr_HArray1OfRepresentationItem

        """
        return _StepShape.Handle_StepShape_CsgShapeRepresentation_Items(self, *args)


    def ItemsValue(self, *args):
        """
        ItemsValue(Handle_StepShape_CsgShapeRepresentation self, Standard_Integer const num) -> Handle_StepRepr_RepresentationItem

        :type num: int
        :rtype: OCC.wrapper.StepRepr.Handle_StepRepr_RepresentationItem

        """
        return _StepShape.Handle_StepShape_CsgShapeRepresentation_ItemsValue(self, *args)


    def NbItems(self, *args):
        """
        NbItems(Handle_StepShape_CsgShapeRepresentation self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_CsgShapeRepresentation_NbItems(self, *args)


    def SetContextOfItems(self, *args):
        """
        SetContextOfItems(Handle_StepShape_CsgShapeRepresentation self, Handle_StepRepr_RepresentationContext aContextOfItems)

        :type aContextOfItems: OCC.wrapper.StepRepr.Handle_StepRepr_RepresentationContext

        """
        return _StepShape.Handle_StepShape_CsgShapeRepresentation_SetContextOfItems(self, *args)


    def ContextOfItems(self, *args):
        """
        ContextOfItems(Handle_StepShape_CsgShapeRepresentation self) -> Handle_StepRepr_RepresentationContext

        :rtype: OCC.wrapper.StepRepr.Handle_StepRepr_RepresentationContext

        """
        return _StepShape.Handle_StepShape_CsgShapeRepresentation_ContextOfItems(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepShape_CsgShapeRepresentation self)

        Memory deallocator for transient classes


        """
        return _StepShape.Handle_StepShape_CsgShapeRepresentation_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepShape_CsgShapeRepresentation self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepShape_CsgShapeRepresentation self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.Handle_StepShape_CsgShapeRepresentation_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepShape_CsgShapeRepresentation self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepShape_CsgShapeRepresentation self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.Handle_StepShape_CsgShapeRepresentation_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepShape_CsgShapeRepresentation self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepShape.Handle_StepShape_CsgShapeRepresentation_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepShape_CsgShapeRepresentation self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_CsgShapeRepresentation_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepShape_CsgShapeRepresentation self)

        Increments the reference counter of this object


        """
        return _StepShape.Handle_StepShape_CsgShapeRepresentation_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepShape_CsgShapeRepresentation self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_CsgShapeRepresentation_DecrementRefCounter(self, *args)

Handle_StepShape_CsgShapeRepresentation_swigregister = _StepShape.Handle_StepShape_CsgShapeRepresentation_swigregister
Handle_StepShape_CsgShapeRepresentation_swigregister(Handle_StepShape_CsgShapeRepresentation)

def Handle_StepShape_CsgShapeRepresentation_DownCast(thing):
    return _StepShape.Handle_StepShape_CsgShapeRepresentation_DownCast(thing)
Handle_StepShape_CsgShapeRepresentation_DownCast = _StepShape.Handle_StepShape_CsgShapeRepresentation_DownCast

class Handle_StepShape_ConnectedFaceShapeRepresentation(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepShape_ConnectedFaceShapeRepresentation self)

        Nullify the handle


        """
        return _StepShape.Handle_StepShape_ConnectedFaceShapeRepresentation_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepShape_ConnectedFaceShapeRepresentation self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepShape.Handle_StepShape_ConnectedFaceShapeRepresentation_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepShape_ConnectedFaceShapeRepresentation self, StepShape_ConnectedFaceShapeRepresentation thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepShape.Handle_StepShape_ConnectedFaceShapeRepresentation_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepShape_ConnectedFaceShapeRepresentation self, Handle_StepShape_ConnectedFaceShapeRepresentation theHandle) -> Handle_StepShape_ConnectedFaceShapeRepresentation
        assign(Handle_StepShape_ConnectedFaceShapeRepresentation self, StepShape_ConnectedFaceShapeRepresentation thePtr) -> Handle_StepShape_ConnectedFaceShapeRepresentation
        assign(Handle_StepShape_ConnectedFaceShapeRepresentation self, Handle_StepShape_ConnectedFaceShapeRepresentation theHandle) -> Handle_StepShape_ConnectedFaceShapeRepresentation

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepShape.Handle_StepShape_ConnectedFaceShapeRepresentation_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepShape_ConnectedFaceShapeRepresentation self) -> StepShape_ConnectedFaceShapeRepresentation

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepShape.Handle_StepShape_ConnectedFaceShapeRepresentation_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepShape_ConnectedFaceShapeRepresentation self) -> StepShape_ConnectedFaceShapeRepresentation

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepShape.Handle_StepShape_ConnectedFaceShapeRepresentation___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepShape_ConnectedFaceShapeRepresentation self) -> StepShape_ConnectedFaceShapeRepresentation

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepShape.Handle_StepShape_ConnectedFaceShapeRepresentation___ref__(self, *args)


    def __hash__(self):
        return _StepShape.Handle_StepShape_ConnectedFaceShapeRepresentation___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepShape.Handle_StepShape_ConnectedFaceShapeRepresentation___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepShape.new_Handle_StepShape_ConnectedFaceShapeRepresentation(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepShape.Handle_StepShape_ConnectedFaceShapeRepresentation_DownCast)
    __swig_destroy__ = _StepShape.delete_Handle_StepShape_ConnectedFaceShapeRepresentation

    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepShape_ConnectedFaceShapeRepresentation self) -> char const *

        :rtype: const char *

        """
        return _StepShape.Handle_StepShape_ConnectedFaceShapeRepresentation_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.Handle_StepShape_ConnectedFaceShapeRepresentation_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.Handle_StepShape_ConnectedFaceShapeRepresentation_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Init(self, *args):
        """
        Init(Handle_StepShape_ConnectedFaceShapeRepresentation self, Handle_TCollection_HAsciiString aName, Handle_StepRepr_HArray1OfRepresentationItem aItems, Handle_StepRepr_RepresentationContext aContextOfItems)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aItems: OCC.wrapper.StepRepr.Handle_StepRepr_HArray1OfRepresentationItem
        :type aContextOfItems: OCC.wrapper.StepRepr.Handle_StepRepr_RepresentationContext

        """
        return _StepShape.Handle_StepShape_ConnectedFaceShapeRepresentation_Init(self, *args)


    def SetName(self, *args):
        """
        SetName(Handle_StepShape_ConnectedFaceShapeRepresentation self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepShape.Handle_StepShape_ConnectedFaceShapeRepresentation_SetName(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepShape_ConnectedFaceShapeRepresentation self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepShape.Handle_StepShape_ConnectedFaceShapeRepresentation_Name(self, *args)


    def SetItems(self, *args):
        """
        SetItems(Handle_StepShape_ConnectedFaceShapeRepresentation self, Handle_StepRepr_HArray1OfRepresentationItem aItems)

        :type aItems: OCC.wrapper.StepRepr.Handle_StepRepr_HArray1OfRepresentationItem

        """
        return _StepShape.Handle_StepShape_ConnectedFaceShapeRepresentation_SetItems(self, *args)


    def Items(self, *args):
        """
        Items(Handle_StepShape_ConnectedFaceShapeRepresentation self) -> Handle_StepRepr_HArray1OfRepresentationItem

        :rtype: OCC.wrapper.StepRepr.Handle_StepRepr_HArray1OfRepresentationItem

        """
        return _StepShape.Handle_StepShape_ConnectedFaceShapeRepresentation_Items(self, *args)


    def ItemsValue(self, *args):
        """
        ItemsValue(Handle_StepShape_ConnectedFaceShapeRepresentation self, Standard_Integer const num) -> Handle_StepRepr_RepresentationItem

        :type num: int
        :rtype: OCC.wrapper.StepRepr.Handle_StepRepr_RepresentationItem

        """
        return _StepShape.Handle_StepShape_ConnectedFaceShapeRepresentation_ItemsValue(self, *args)


    def NbItems(self, *args):
        """
        NbItems(Handle_StepShape_ConnectedFaceShapeRepresentation self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_ConnectedFaceShapeRepresentation_NbItems(self, *args)


    def SetContextOfItems(self, *args):
        """
        SetContextOfItems(Handle_StepShape_ConnectedFaceShapeRepresentation self, Handle_StepRepr_RepresentationContext aContextOfItems)

        :type aContextOfItems: OCC.wrapper.StepRepr.Handle_StepRepr_RepresentationContext

        """
        return _StepShape.Handle_StepShape_ConnectedFaceShapeRepresentation_SetContextOfItems(self, *args)


    def ContextOfItems(self, *args):
        """
        ContextOfItems(Handle_StepShape_ConnectedFaceShapeRepresentation self) -> Handle_StepRepr_RepresentationContext

        :rtype: OCC.wrapper.StepRepr.Handle_StepRepr_RepresentationContext

        """
        return _StepShape.Handle_StepShape_ConnectedFaceShapeRepresentation_ContextOfItems(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepShape_ConnectedFaceShapeRepresentation self)

        Memory deallocator for transient classes


        """
        return _StepShape.Handle_StepShape_ConnectedFaceShapeRepresentation_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepShape_ConnectedFaceShapeRepresentation self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepShape_ConnectedFaceShapeRepresentation self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.Handle_StepShape_ConnectedFaceShapeRepresentation_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepShape_ConnectedFaceShapeRepresentation self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepShape_ConnectedFaceShapeRepresentation self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.Handle_StepShape_ConnectedFaceShapeRepresentation_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepShape_ConnectedFaceShapeRepresentation self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepShape.Handle_StepShape_ConnectedFaceShapeRepresentation_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepShape_ConnectedFaceShapeRepresentation self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_ConnectedFaceShapeRepresentation_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepShape_ConnectedFaceShapeRepresentation self)

        Increments the reference counter of this object


        """
        return _StepShape.Handle_StepShape_ConnectedFaceShapeRepresentation_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepShape_ConnectedFaceShapeRepresentation self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_ConnectedFaceShapeRepresentation_DecrementRefCounter(self, *args)

Handle_StepShape_ConnectedFaceShapeRepresentation_swigregister = _StepShape.Handle_StepShape_ConnectedFaceShapeRepresentation_swigregister
Handle_StepShape_ConnectedFaceShapeRepresentation_swigregister(Handle_StepShape_ConnectedFaceShapeRepresentation)

def Handle_StepShape_ConnectedFaceShapeRepresentation_DownCast(thing):
    return _StepShape.Handle_StepShape_ConnectedFaceShapeRepresentation_DownCast(thing)
Handle_StepShape_ConnectedFaceShapeRepresentation_DownCast = _StepShape.Handle_StepShape_ConnectedFaceShapeRepresentation_DownCast

class Handle_StepShape_DirectedDimensionalLocation(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepShape_DirectedDimensionalLocation self)

        Nullify the handle


        """
        return _StepShape.Handle_StepShape_DirectedDimensionalLocation_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepShape_DirectedDimensionalLocation self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepShape.Handle_StepShape_DirectedDimensionalLocation_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepShape_DirectedDimensionalLocation self, StepShape_DirectedDimensionalLocation thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepShape.Handle_StepShape_DirectedDimensionalLocation_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepShape_DirectedDimensionalLocation self, Handle_StepShape_DirectedDimensionalLocation theHandle) -> Handle_StepShape_DirectedDimensionalLocation
        assign(Handle_StepShape_DirectedDimensionalLocation self, StepShape_DirectedDimensionalLocation thePtr) -> Handle_StepShape_DirectedDimensionalLocation
        assign(Handle_StepShape_DirectedDimensionalLocation self, Handle_StepShape_DirectedDimensionalLocation theHandle) -> Handle_StepShape_DirectedDimensionalLocation

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepShape.Handle_StepShape_DirectedDimensionalLocation_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepShape_DirectedDimensionalLocation self) -> StepShape_DirectedDimensionalLocation

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepShape.Handle_StepShape_DirectedDimensionalLocation_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepShape_DirectedDimensionalLocation self) -> StepShape_DirectedDimensionalLocation

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepShape.Handle_StepShape_DirectedDimensionalLocation___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepShape_DirectedDimensionalLocation self) -> StepShape_DirectedDimensionalLocation

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepShape.Handle_StepShape_DirectedDimensionalLocation___ref__(self, *args)


    def __hash__(self):
        return _StepShape.Handle_StepShape_DirectedDimensionalLocation___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepShape.Handle_StepShape_DirectedDimensionalLocation___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepShape.new_Handle_StepShape_DirectedDimensionalLocation(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepShape.Handle_StepShape_DirectedDimensionalLocation_DownCast)
    __swig_destroy__ = _StepShape.delete_Handle_StepShape_DirectedDimensionalLocation

    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepShape_DirectedDimensionalLocation self) -> char const *

        :rtype: const char *

        """
        return _StepShape.Handle_StepShape_DirectedDimensionalLocation_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.Handle_StepShape_DirectedDimensionalLocation_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.Handle_StepShape_DirectedDimensionalLocation_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Init(self, *args):
        """
        Init(Handle_StepShape_DirectedDimensionalLocation self, Handle_TCollection_HAsciiString aName, Standard_Boolean const hasDescription, Handle_TCollection_HAsciiString aDescription, Handle_StepRepr_ShapeAspect aRelatingShapeAspect, Handle_StepRepr_ShapeAspect aRelatedShapeAspect)

        Initialize all fields (own and inherited)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type hasDescription: bool
        :type aDescription: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aRelatingShapeAspect: OCC.wrapper.StepRepr.Handle_StepRepr_ShapeAspect
        :type aRelatedShapeAspect: OCC.wrapper.StepRepr.Handle_StepRepr_ShapeAspect

        """
        return _StepShape.Handle_StepShape_DirectedDimensionalLocation_Init(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepShape_DirectedDimensionalLocation self) -> Handle_TCollection_HAsciiString

        Returns field Name

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepShape.Handle_StepShape_DirectedDimensionalLocation_Name(self, *args)


    def SetName(self, *args):
        """
        SetName(Handle_StepShape_DirectedDimensionalLocation self, Handle_TCollection_HAsciiString Name)

        Set field Name

        :type Name: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepShape.Handle_StepShape_DirectedDimensionalLocation_SetName(self, *args)


    def Description(self, *args):
        """
        Description(Handle_StepShape_DirectedDimensionalLocation self) -> Handle_TCollection_HAsciiString

        Returns field Description

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepShape.Handle_StepShape_DirectedDimensionalLocation_Description(self, *args)


    def SetDescription(self, *args):
        """
        SetDescription(Handle_StepShape_DirectedDimensionalLocation self, Handle_TCollection_HAsciiString Description)

        Set field Description

        :type Description: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepShape.Handle_StepShape_DirectedDimensionalLocation_SetDescription(self, *args)


    def HasDescription(self, *args):
        """
        HasDescription(Handle_StepShape_DirectedDimensionalLocation self) -> Standard_Boolean

        Returns True if optional field Description is defined

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.Handle_StepShape_DirectedDimensionalLocation_HasDescription(self, *args)


    def RelatingShapeAspect(self, *args):
        """
        RelatingShapeAspect(Handle_StepShape_DirectedDimensionalLocation self) -> Handle_StepRepr_ShapeAspect

        Returns field RelatingShapeAspect

        :rtype: OCC.wrapper.StepRepr.Handle_StepRepr_ShapeAspect

        """
        return _StepShape.Handle_StepShape_DirectedDimensionalLocation_RelatingShapeAspect(self, *args)


    def SetRelatingShapeAspect(self, *args):
        """
        SetRelatingShapeAspect(Handle_StepShape_DirectedDimensionalLocation self, Handle_StepRepr_ShapeAspect RelatingShapeAspect)

        Set field RelatingShapeAspect

        :type RelatingShapeAspect: OCC.wrapper.StepRepr.Handle_StepRepr_ShapeAspect

        """
        return _StepShape.Handle_StepShape_DirectedDimensionalLocation_SetRelatingShapeAspect(self, *args)


    def RelatedShapeAspect(self, *args):
        """
        RelatedShapeAspect(Handle_StepShape_DirectedDimensionalLocation self) -> Handle_StepRepr_ShapeAspect

        Returns field RelatedShapeAspect

        :rtype: OCC.wrapper.StepRepr.Handle_StepRepr_ShapeAspect

        """
        return _StepShape.Handle_StepShape_DirectedDimensionalLocation_RelatedShapeAspect(self, *args)


    def SetRelatedShapeAspect(self, *args):
        """
        SetRelatedShapeAspect(Handle_StepShape_DirectedDimensionalLocation self, Handle_StepRepr_ShapeAspect RelatedShapeAspect)

        Set field RelatedShapeAspect

        :type RelatedShapeAspect: OCC.wrapper.StepRepr.Handle_StepRepr_ShapeAspect

        """
        return _StepShape.Handle_StepShape_DirectedDimensionalLocation_SetRelatedShapeAspect(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepShape_DirectedDimensionalLocation self)

        Memory deallocator for transient classes


        """
        return _StepShape.Handle_StepShape_DirectedDimensionalLocation_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepShape_DirectedDimensionalLocation self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepShape_DirectedDimensionalLocation self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.Handle_StepShape_DirectedDimensionalLocation_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepShape_DirectedDimensionalLocation self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepShape_DirectedDimensionalLocation self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.Handle_StepShape_DirectedDimensionalLocation_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepShape_DirectedDimensionalLocation self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepShape.Handle_StepShape_DirectedDimensionalLocation_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepShape_DirectedDimensionalLocation self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_DirectedDimensionalLocation_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepShape_DirectedDimensionalLocation self)

        Increments the reference counter of this object


        """
        return _StepShape.Handle_StepShape_DirectedDimensionalLocation_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepShape_DirectedDimensionalLocation self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_DirectedDimensionalLocation_DecrementRefCounter(self, *args)

Handle_StepShape_DirectedDimensionalLocation_swigregister = _StepShape.Handle_StepShape_DirectedDimensionalLocation_swigregister
Handle_StepShape_DirectedDimensionalLocation_swigregister(Handle_StepShape_DirectedDimensionalLocation)

def Handle_StepShape_DirectedDimensionalLocation_DownCast(thing):
    return _StepShape.Handle_StepShape_DirectedDimensionalLocation_DownCast(thing)
Handle_StepShape_DirectedDimensionalLocation_DownCast = _StepShape.Handle_StepShape_DirectedDimensionalLocation_DownCast

class Handle_StepShape_EdgeLoop(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepShape_EdgeLoop self)

        Nullify the handle


        """
        return _StepShape.Handle_StepShape_EdgeLoop_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepShape_EdgeLoop self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepShape.Handle_StepShape_EdgeLoop_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepShape_EdgeLoop self, StepShape_EdgeLoop thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepShape.Handle_StepShape_EdgeLoop_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepShape_EdgeLoop self, Handle_StepShape_EdgeLoop theHandle) -> Handle_StepShape_EdgeLoop
        assign(Handle_StepShape_EdgeLoop self, StepShape_EdgeLoop thePtr) -> Handle_StepShape_EdgeLoop
        assign(Handle_StepShape_EdgeLoop self, Handle_StepShape_EdgeLoop theHandle) -> Handle_StepShape_EdgeLoop

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepShape.Handle_StepShape_EdgeLoop_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepShape_EdgeLoop self) -> StepShape_EdgeLoop

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepShape.Handle_StepShape_EdgeLoop_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepShape_EdgeLoop self) -> StepShape_EdgeLoop

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepShape.Handle_StepShape_EdgeLoop___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepShape_EdgeLoop self) -> StepShape_EdgeLoop

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepShape.Handle_StepShape_EdgeLoop___ref__(self, *args)


    def __hash__(self):
        return _StepShape.Handle_StepShape_EdgeLoop___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepShape.Handle_StepShape_EdgeLoop___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepShape.new_Handle_StepShape_EdgeLoop(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepShape.Handle_StepShape_EdgeLoop_DownCast)
    __swig_destroy__ = _StepShape.delete_Handle_StepShape_EdgeLoop

    def Init(self, *args):
        """
        Init(Handle_StepShape_EdgeLoop self, Handle_TCollection_HAsciiString aName, Handle_StepShape_HArray1OfOrientedEdge aEdgeList)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aEdgeList: OCC.wrapper.StepShape.Handle_StepShape_HArray1OfOrientedEdge

        """
        return _StepShape.Handle_StepShape_EdgeLoop_Init(self, *args)


    def SetEdgeList(self, *args):
        """
        SetEdgeList(Handle_StepShape_EdgeLoop self, Handle_StepShape_HArray1OfOrientedEdge aEdgeList)

        :type aEdgeList: OCC.wrapper.StepShape.Handle_StepShape_HArray1OfOrientedEdge

        """
        return _StepShape.Handle_StepShape_EdgeLoop_SetEdgeList(self, *args)


    def EdgeList(self, *args):
        """
        EdgeList(Handle_StepShape_EdgeLoop self) -> Handle_StepShape_HArray1OfOrientedEdge

        :rtype: OCC.wrapper.StepShape.Handle_StepShape_HArray1OfOrientedEdge

        """
        return _StepShape.Handle_StepShape_EdgeLoop_EdgeList(self, *args)


    def EdgeListValue(self, *args):
        """
        EdgeListValue(Handle_StepShape_EdgeLoop self, Standard_Integer const num) -> Handle_StepShape_OrientedEdge

        :type num: int
        :rtype: OCC.wrapper.StepShape.Handle_StepShape_OrientedEdge

        """
        return _StepShape.Handle_StepShape_EdgeLoop_EdgeListValue(self, *args)


    def NbEdgeList(self, *args):
        """
        NbEdgeList(Handle_StepShape_EdgeLoop self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_EdgeLoop_NbEdgeList(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepShape_EdgeLoop self) -> char const *

        :rtype: const char *

        """
        return _StepShape.Handle_StepShape_EdgeLoop_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.Handle_StepShape_EdgeLoop_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.Handle_StepShape_EdgeLoop_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetName(self, *args):
        """
        SetName(Handle_StepShape_EdgeLoop self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepShape.Handle_StepShape_EdgeLoop_SetName(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepShape_EdgeLoop self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepShape.Handle_StepShape_EdgeLoop_Name(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepShape_EdgeLoop self)

        Memory deallocator for transient classes


        """
        return _StepShape.Handle_StepShape_EdgeLoop_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepShape_EdgeLoop self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepShape_EdgeLoop self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.Handle_StepShape_EdgeLoop_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepShape_EdgeLoop self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepShape_EdgeLoop self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.Handle_StepShape_EdgeLoop_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepShape_EdgeLoop self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepShape.Handle_StepShape_EdgeLoop_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepShape_EdgeLoop self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_EdgeLoop_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepShape_EdgeLoop self)

        Increments the reference counter of this object


        """
        return _StepShape.Handle_StepShape_EdgeLoop_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepShape_EdgeLoop self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_EdgeLoop_DecrementRefCounter(self, *args)

Handle_StepShape_EdgeLoop_swigregister = _StepShape.Handle_StepShape_EdgeLoop_swigregister
Handle_StepShape_EdgeLoop_swigregister(Handle_StepShape_EdgeLoop)

def Handle_StepShape_EdgeLoop_DownCast(thing):
    return _StepShape.Handle_StepShape_EdgeLoop_DownCast(thing)
Handle_StepShape_EdgeLoop_DownCast = _StepShape.Handle_StepShape_EdgeLoop_DownCast

class StepShape_DefinitionalRepresentationAndShapeRepresentation(StepRepr.StepRepr_DefinitionalRepresentation):
    """
    Implements complex type
    (DEFINITIONAL_REPRESENTATION,REPRESENTATION,SHAPE_REPRESENTATION)
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepShape_DefinitionalRepresentationAndShapeRepresentation
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepShape_DefinitionalRepresentationAndShapeRepresentation(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepShape_DefinitionalRepresentationAndShapeRepresentation self) -> StepShape_DefinitionalRepresentationAndShapeRepresentation

        Implements complex type
        (DEFINITIONAL_REPRESENTATION,REPRESENTATION,SHAPE_REPRESENTATION)
        """
        this = _StepShape.new_StepShape_DefinitionalRepresentationAndShapeRepresentation(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepShape.StepShape_DefinitionalRepresentationAndShapeRepresentation_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepShape.StepShape_DefinitionalRepresentationAndShapeRepresentation_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.StepShape_DefinitionalRepresentationAndShapeRepresentation_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepShape.delete_StepShape_DefinitionalRepresentationAndShapeRepresentation
StepShape_DefinitionalRepresentationAndShapeRepresentation_swigregister = _StepShape.StepShape_DefinitionalRepresentationAndShapeRepresentation_swigregister
StepShape_DefinitionalRepresentationAndShapeRepresentation_swigregister(StepShape_DefinitionalRepresentationAndShapeRepresentation)

def StepShape_DefinitionalRepresentationAndShapeRepresentation_get_type_name(*args):
    """
    StepShape_DefinitionalRepresentationAndShapeRepresentation_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepShape.StepShape_DefinitionalRepresentationAndShapeRepresentation_get_type_name(*args)

def StepShape_DefinitionalRepresentationAndShapeRepresentation_get_type_descriptor(*args):
    """
    StepShape_DefinitionalRepresentationAndShapeRepresentation_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepShape.StepShape_DefinitionalRepresentationAndShapeRepresentation_get_type_descriptor(*args)

class Handle_StepShape_OrientedOpenShell(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepShape_OrientedOpenShell self)

        Nullify the handle


        """
        return _StepShape.Handle_StepShape_OrientedOpenShell_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepShape_OrientedOpenShell self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepShape.Handle_StepShape_OrientedOpenShell_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepShape_OrientedOpenShell self, StepShape_OrientedOpenShell thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepShape.Handle_StepShape_OrientedOpenShell_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepShape_OrientedOpenShell self, Handle_StepShape_OrientedOpenShell theHandle) -> Handle_StepShape_OrientedOpenShell
        assign(Handle_StepShape_OrientedOpenShell self, StepShape_OrientedOpenShell thePtr) -> Handle_StepShape_OrientedOpenShell
        assign(Handle_StepShape_OrientedOpenShell self, Handle_StepShape_OrientedOpenShell theHandle) -> Handle_StepShape_OrientedOpenShell

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepShape.Handle_StepShape_OrientedOpenShell_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepShape_OrientedOpenShell self) -> StepShape_OrientedOpenShell

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepShape.Handle_StepShape_OrientedOpenShell_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepShape_OrientedOpenShell self) -> StepShape_OrientedOpenShell

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepShape.Handle_StepShape_OrientedOpenShell___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepShape_OrientedOpenShell self) -> StepShape_OrientedOpenShell

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepShape.Handle_StepShape_OrientedOpenShell___ref__(self, *args)


    def __hash__(self):
        return _StepShape.Handle_StepShape_OrientedOpenShell___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepShape.Handle_StepShape_OrientedOpenShell___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepShape.new_Handle_StepShape_OrientedOpenShell(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepShape.Handle_StepShape_OrientedOpenShell_DownCast)
    __swig_destroy__ = _StepShape.delete_Handle_StepShape_OrientedOpenShell

    def Init(self, *args):
        """
        Init(Handle_StepShape_OrientedOpenShell self, Handle_TCollection_HAsciiString aName, Handle_StepShape_OpenShell aOpenShellElement, Standard_Boolean const aOrientation)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aOpenShellElement: OCC.wrapper.StepShape.Handle_StepShape_OpenShell
        :type aOrientation: bool

        """
        return _StepShape.Handle_StepShape_OrientedOpenShell_Init(self, *args)


    def SetOpenShellElement(self, *args):
        """
        SetOpenShellElement(Handle_StepShape_OrientedOpenShell self, Handle_StepShape_OpenShell aOpenShellElement)

        :type aOpenShellElement: OCC.wrapper.StepShape.Handle_StepShape_OpenShell

        """
        return _StepShape.Handle_StepShape_OrientedOpenShell_SetOpenShellElement(self, *args)


    def OpenShellElement(self, *args):
        """
        OpenShellElement(Handle_StepShape_OrientedOpenShell self) -> Handle_StepShape_OpenShell

        :rtype: OCC.wrapper.StepShape.Handle_StepShape_OpenShell

        """
        return _StepShape.Handle_StepShape_OrientedOpenShell_OpenShellElement(self, *args)


    def SetOrientation(self, *args):
        """
        SetOrientation(Handle_StepShape_OrientedOpenShell self, Standard_Boolean const aOrientation)

        :type aOrientation: bool

        """
        return _StepShape.Handle_StepShape_OrientedOpenShell_SetOrientation(self, *args)


    def Orientation(self, *args):
        """
        Orientation(Handle_StepShape_OrientedOpenShell self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.Handle_StepShape_OrientedOpenShell_Orientation(self, *args)


    def SetCfsFaces(self, *args):
        """
        SetCfsFaces(Handle_StepShape_OrientedOpenShell self, Handle_StepShape_HArray1OfFace aCfsFaces)

        :type aCfsFaces: OCC.wrapper.StepShape.Handle_StepShape_HArray1OfFace

        """
        return _StepShape.Handle_StepShape_OrientedOpenShell_SetCfsFaces(self, *args)


    def CfsFaces(self, *args):
        """
        CfsFaces(Handle_StepShape_OrientedOpenShell self) -> Handle_StepShape_HArray1OfFace

        :rtype: OCC.wrapper.StepShape.Handle_StepShape_HArray1OfFace

        """
        return _StepShape.Handle_StepShape_OrientedOpenShell_CfsFaces(self, *args)


    def CfsFacesValue(self, *args):
        """
        CfsFacesValue(Handle_StepShape_OrientedOpenShell self, Standard_Integer const num) -> Handle_StepShape_Face

        :type num: int
        :rtype: OCC.wrapper.StepShape.Handle_StepShape_Face

        """
        return _StepShape.Handle_StepShape_OrientedOpenShell_CfsFacesValue(self, *args)


    def NbCfsFaces(self, *args):
        """
        NbCfsFaces(Handle_StepShape_OrientedOpenShell self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_OrientedOpenShell_NbCfsFaces(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepShape_OrientedOpenShell self) -> char const *

        :rtype: const char *

        """
        return _StepShape.Handle_StepShape_OrientedOpenShell_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.Handle_StepShape_OrientedOpenShell_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.Handle_StepShape_OrientedOpenShell_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetName(self, *args):
        """
        SetName(Handle_StepShape_OrientedOpenShell self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepShape.Handle_StepShape_OrientedOpenShell_SetName(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepShape_OrientedOpenShell self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepShape.Handle_StepShape_OrientedOpenShell_Name(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepShape_OrientedOpenShell self)

        Memory deallocator for transient classes


        """
        return _StepShape.Handle_StepShape_OrientedOpenShell_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepShape_OrientedOpenShell self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepShape_OrientedOpenShell self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.Handle_StepShape_OrientedOpenShell_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepShape_OrientedOpenShell self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepShape_OrientedOpenShell self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.Handle_StepShape_OrientedOpenShell_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepShape_OrientedOpenShell self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepShape.Handle_StepShape_OrientedOpenShell_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepShape_OrientedOpenShell self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_OrientedOpenShell_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepShape_OrientedOpenShell self)

        Increments the reference counter of this object


        """
        return _StepShape.Handle_StepShape_OrientedOpenShell_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepShape_OrientedOpenShell self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_OrientedOpenShell_DecrementRefCounter(self, *args)

Handle_StepShape_OrientedOpenShell_swigregister = _StepShape.Handle_StepShape_OrientedOpenShell_swigregister
Handle_StepShape_OrientedOpenShell_swigregister(Handle_StepShape_OrientedOpenShell)

def Handle_StepShape_OrientedOpenShell_DownCast(thing):
    return _StepShape.Handle_StepShape_OrientedOpenShell_DownCast(thing)
Handle_StepShape_OrientedOpenShell_DownCast = _StepShape.Handle_StepShape_OrientedOpenShell_DownCast

class Handle_StepShape_ManifoldSolidBrep(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepShape_ManifoldSolidBrep self)

        Nullify the handle


        """
        return _StepShape.Handle_StepShape_ManifoldSolidBrep_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepShape_ManifoldSolidBrep self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepShape.Handle_StepShape_ManifoldSolidBrep_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepShape_ManifoldSolidBrep self, StepShape_ManifoldSolidBrep thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepShape.Handle_StepShape_ManifoldSolidBrep_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepShape_ManifoldSolidBrep self, Handle_StepShape_ManifoldSolidBrep theHandle) -> Handle_StepShape_ManifoldSolidBrep
        assign(Handle_StepShape_ManifoldSolidBrep self, StepShape_ManifoldSolidBrep thePtr) -> Handle_StepShape_ManifoldSolidBrep
        assign(Handle_StepShape_ManifoldSolidBrep self, Handle_StepShape_ManifoldSolidBrep theHandle) -> Handle_StepShape_ManifoldSolidBrep

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepShape.Handle_StepShape_ManifoldSolidBrep_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepShape_ManifoldSolidBrep self) -> StepShape_ManifoldSolidBrep

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepShape.Handle_StepShape_ManifoldSolidBrep_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepShape_ManifoldSolidBrep self) -> StepShape_ManifoldSolidBrep

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepShape.Handle_StepShape_ManifoldSolidBrep___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepShape_ManifoldSolidBrep self) -> StepShape_ManifoldSolidBrep

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepShape.Handle_StepShape_ManifoldSolidBrep___ref__(self, *args)


    def __hash__(self):
        return _StepShape.Handle_StepShape_ManifoldSolidBrep___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepShape.Handle_StepShape_ManifoldSolidBrep___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepShape.new_Handle_StepShape_ManifoldSolidBrep(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepShape.Handle_StepShape_ManifoldSolidBrep_DownCast)
    __swig_destroy__ = _StepShape.delete_Handle_StepShape_ManifoldSolidBrep

    def Init(self, *args):
        """
        Init(Handle_StepShape_ManifoldSolidBrep self, Handle_TCollection_HAsciiString aName, Handle_StepShape_ClosedShell aOuter)
        Init(Handle_StepShape_ManifoldSolidBrep self, Handle_TCollection_HAsciiString aName, Handle_StepShape_ConnectedFaceSet aOuter)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aOuter: OCC.wrapper.StepShape.Handle_StepShape_ConnectedFaceSet

        """
        return _StepShape.Handle_StepShape_ManifoldSolidBrep_Init(self, *args)


    def SetOuter(self, *args):
        """
        SetOuter(Handle_StepShape_ManifoldSolidBrep self, Handle_StepShape_ConnectedFaceSet aOuter)

        :type aOuter: OCC.wrapper.StepShape.Handle_StepShape_ConnectedFaceSet

        """
        return _StepShape.Handle_StepShape_ManifoldSolidBrep_SetOuter(self, *args)


    def Outer(self, *args):
        """
        Outer(Handle_StepShape_ManifoldSolidBrep self) -> Handle_StepShape_ConnectedFaceSet

        :rtype: OCC.wrapper.StepShape.Handle_StepShape_ConnectedFaceSet

        """
        return _StepShape.Handle_StepShape_ManifoldSolidBrep_Outer(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepShape_ManifoldSolidBrep self) -> char const *

        :rtype: const char *

        """
        return _StepShape.Handle_StepShape_ManifoldSolidBrep_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.Handle_StepShape_ManifoldSolidBrep_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.Handle_StepShape_ManifoldSolidBrep_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetName(self, *args):
        """
        SetName(Handle_StepShape_ManifoldSolidBrep self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepShape.Handle_StepShape_ManifoldSolidBrep_SetName(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepShape_ManifoldSolidBrep self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepShape.Handle_StepShape_ManifoldSolidBrep_Name(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepShape_ManifoldSolidBrep self)

        Memory deallocator for transient classes


        """
        return _StepShape.Handle_StepShape_ManifoldSolidBrep_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepShape_ManifoldSolidBrep self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepShape_ManifoldSolidBrep self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.Handle_StepShape_ManifoldSolidBrep_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepShape_ManifoldSolidBrep self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepShape_ManifoldSolidBrep self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.Handle_StepShape_ManifoldSolidBrep_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepShape_ManifoldSolidBrep self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepShape.Handle_StepShape_ManifoldSolidBrep_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepShape_ManifoldSolidBrep self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_ManifoldSolidBrep_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepShape_ManifoldSolidBrep self)

        Increments the reference counter of this object


        """
        return _StepShape.Handle_StepShape_ManifoldSolidBrep_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepShape_ManifoldSolidBrep self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_ManifoldSolidBrep_DecrementRefCounter(self, *args)

Handle_StepShape_ManifoldSolidBrep_swigregister = _StepShape.Handle_StepShape_ManifoldSolidBrep_swigregister
Handle_StepShape_ManifoldSolidBrep_swigregister(Handle_StepShape_ManifoldSolidBrep)

def Handle_StepShape_ManifoldSolidBrep_DownCast(thing):
    return _StepShape.Handle_StepShape_ManifoldSolidBrep_DownCast(thing)
Handle_StepShape_ManifoldSolidBrep_DownCast = _StepShape.Handle_StepShape_ManifoldSolidBrep_DownCast

class Handle_StepShape_ToleranceValue(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepShape_ToleranceValue self)

        Nullify the handle


        """
        return _StepShape.Handle_StepShape_ToleranceValue_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepShape_ToleranceValue self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepShape.Handle_StepShape_ToleranceValue_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepShape_ToleranceValue self, StepShape_ToleranceValue thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepShape.Handle_StepShape_ToleranceValue_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepShape_ToleranceValue self, Handle_StepShape_ToleranceValue theHandle) -> Handle_StepShape_ToleranceValue
        assign(Handle_StepShape_ToleranceValue self, StepShape_ToleranceValue thePtr) -> Handle_StepShape_ToleranceValue
        assign(Handle_StepShape_ToleranceValue self, Handle_StepShape_ToleranceValue theHandle) -> Handle_StepShape_ToleranceValue

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepShape.Handle_StepShape_ToleranceValue_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepShape_ToleranceValue self) -> StepShape_ToleranceValue

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepShape.Handle_StepShape_ToleranceValue_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepShape_ToleranceValue self) -> StepShape_ToleranceValue

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepShape.Handle_StepShape_ToleranceValue___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepShape_ToleranceValue self) -> StepShape_ToleranceValue

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepShape.Handle_StepShape_ToleranceValue___ref__(self, *args)


    def __hash__(self):
        return _StepShape.Handle_StepShape_ToleranceValue___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepShape.Handle_StepShape_ToleranceValue___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepShape.new_Handle_StepShape_ToleranceValue(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepShape.Handle_StepShape_ToleranceValue_DownCast)
    __swig_destroy__ = _StepShape.delete_Handle_StepShape_ToleranceValue

    def Init(self, *args):
        """
        Init(Handle_StepShape_ToleranceValue self, Handle_StepBasic_MeasureWithUnit lower_bound, Handle_StepBasic_MeasureWithUnit upper_bound)

        :type lower_bound: OCC.wrapper.StepBasic.Handle_StepBasic_MeasureWithUnit
        :type upper_bound: OCC.wrapper.StepBasic.Handle_StepBasic_MeasureWithUnit

        """
        return _StepShape.Handle_StepShape_ToleranceValue_Init(self, *args)


    def LowerBound(self, *args):
        """
        LowerBound(Handle_StepShape_ToleranceValue self) -> Handle_StepBasic_MeasureWithUnit

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_MeasureWithUnit

        """
        return _StepShape.Handle_StepShape_ToleranceValue_LowerBound(self, *args)


    def SetLowerBound(self, *args):
        """
        SetLowerBound(Handle_StepShape_ToleranceValue self, Handle_StepBasic_MeasureWithUnit lower_bound)

        :type lower_bound: OCC.wrapper.StepBasic.Handle_StepBasic_MeasureWithUnit

        """
        return _StepShape.Handle_StepShape_ToleranceValue_SetLowerBound(self, *args)


    def UpperBound(self, *args):
        """
        UpperBound(Handle_StepShape_ToleranceValue self) -> Handle_StepBasic_MeasureWithUnit

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_MeasureWithUnit

        """
        return _StepShape.Handle_StepShape_ToleranceValue_UpperBound(self, *args)


    def SetUpperBound(self, *args):
        """
        SetUpperBound(Handle_StepShape_ToleranceValue self, Handle_StepBasic_MeasureWithUnit upper_bound)

        :type upper_bound: OCC.wrapper.StepBasic.Handle_StepBasic_MeasureWithUnit

        """
        return _StepShape.Handle_StepShape_ToleranceValue_SetUpperBound(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepShape_ToleranceValue self) -> char const *

        :rtype: const char *

        """
        return _StepShape.Handle_StepShape_ToleranceValue_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.Handle_StepShape_ToleranceValue_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.Handle_StepShape_ToleranceValue_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_StepShape_ToleranceValue self)

        Memory deallocator for transient classes


        """
        return _StepShape.Handle_StepShape_ToleranceValue_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepShape_ToleranceValue self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepShape_ToleranceValue self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.Handle_StepShape_ToleranceValue_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepShape_ToleranceValue self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepShape_ToleranceValue self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.Handle_StepShape_ToleranceValue_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepShape_ToleranceValue self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepShape.Handle_StepShape_ToleranceValue_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepShape_ToleranceValue self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_ToleranceValue_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepShape_ToleranceValue self)

        Increments the reference counter of this object


        """
        return _StepShape.Handle_StepShape_ToleranceValue_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepShape_ToleranceValue self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_ToleranceValue_DecrementRefCounter(self, *args)

Handle_StepShape_ToleranceValue_swigregister = _StepShape.Handle_StepShape_ToleranceValue_swigregister
Handle_StepShape_ToleranceValue_swigregister(Handle_StepShape_ToleranceValue)

def Handle_StepShape_ToleranceValue_DownCast(thing):
    return _StepShape.Handle_StepShape_ToleranceValue_DownCast(thing)
Handle_StepShape_ToleranceValue_DownCast = _StepShape.Handle_StepShape_ToleranceValue_DownCast

class Handle_StepShape_PlusMinusTolerance(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepShape_PlusMinusTolerance self)

        Nullify the handle


        """
        return _StepShape.Handle_StepShape_PlusMinusTolerance_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepShape_PlusMinusTolerance self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepShape.Handle_StepShape_PlusMinusTolerance_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepShape_PlusMinusTolerance self, StepShape_PlusMinusTolerance thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepShape.Handle_StepShape_PlusMinusTolerance_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepShape_PlusMinusTolerance self, Handle_StepShape_PlusMinusTolerance theHandle) -> Handle_StepShape_PlusMinusTolerance
        assign(Handle_StepShape_PlusMinusTolerance self, StepShape_PlusMinusTolerance thePtr) -> Handle_StepShape_PlusMinusTolerance
        assign(Handle_StepShape_PlusMinusTolerance self, Handle_StepShape_PlusMinusTolerance theHandle) -> Handle_StepShape_PlusMinusTolerance

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepShape.Handle_StepShape_PlusMinusTolerance_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepShape_PlusMinusTolerance self) -> StepShape_PlusMinusTolerance

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepShape.Handle_StepShape_PlusMinusTolerance_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepShape_PlusMinusTolerance self) -> StepShape_PlusMinusTolerance

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepShape.Handle_StepShape_PlusMinusTolerance___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepShape_PlusMinusTolerance self) -> StepShape_PlusMinusTolerance

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepShape.Handle_StepShape_PlusMinusTolerance___ref__(self, *args)


    def __hash__(self):
        return _StepShape.Handle_StepShape_PlusMinusTolerance___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepShape.Handle_StepShape_PlusMinusTolerance___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepShape.new_Handle_StepShape_PlusMinusTolerance(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepShape.Handle_StepShape_PlusMinusTolerance_DownCast)
    __swig_destroy__ = _StepShape.delete_Handle_StepShape_PlusMinusTolerance

    def Init(self, *args):
        """
        Init(Handle_StepShape_PlusMinusTolerance self, StepShape_ToleranceMethodDefinition range, StepShape_DimensionalCharacteristic toleranced_dimension)

        :type range: OCC.wrapper.StepShape.StepShape_ToleranceMethodDefinition
        :type toleranced_dimension: OCC.wrapper.StepShape.StepShape_DimensionalCharacteristic

        """
        return _StepShape.Handle_StepShape_PlusMinusTolerance_Init(self, *args)


    def Range(self, *args):
        """
        Range(Handle_StepShape_PlusMinusTolerance self) -> StepShape_ToleranceMethodDefinition

        :rtype: OCC.wrapper.StepShape.StepShape_ToleranceMethodDefinition

        """
        return _StepShape.Handle_StepShape_PlusMinusTolerance_Range(self, *args)


    def SetRange(self, *args):
        """
        SetRange(Handle_StepShape_PlusMinusTolerance self, StepShape_ToleranceMethodDefinition range)

        :type range: OCC.wrapper.StepShape.StepShape_ToleranceMethodDefinition

        """
        return _StepShape.Handle_StepShape_PlusMinusTolerance_SetRange(self, *args)


    def TolerancedDimension(self, *args):
        """
        TolerancedDimension(Handle_StepShape_PlusMinusTolerance self) -> StepShape_DimensionalCharacteristic

        :rtype: OCC.wrapper.StepShape.StepShape_DimensionalCharacteristic

        """
        return _StepShape.Handle_StepShape_PlusMinusTolerance_TolerancedDimension(self, *args)


    def SetTolerancedDimension(self, *args):
        """
        SetTolerancedDimension(Handle_StepShape_PlusMinusTolerance self, StepShape_DimensionalCharacteristic toleranced_dimension)

        :type toleranced_dimension: OCC.wrapper.StepShape.StepShape_DimensionalCharacteristic

        """
        return _StepShape.Handle_StepShape_PlusMinusTolerance_SetTolerancedDimension(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepShape_PlusMinusTolerance self) -> char const *

        :rtype: const char *

        """
        return _StepShape.Handle_StepShape_PlusMinusTolerance_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.Handle_StepShape_PlusMinusTolerance_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.Handle_StepShape_PlusMinusTolerance_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_StepShape_PlusMinusTolerance self)

        Memory deallocator for transient classes


        """
        return _StepShape.Handle_StepShape_PlusMinusTolerance_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepShape_PlusMinusTolerance self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepShape_PlusMinusTolerance self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.Handle_StepShape_PlusMinusTolerance_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepShape_PlusMinusTolerance self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepShape_PlusMinusTolerance self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.Handle_StepShape_PlusMinusTolerance_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepShape_PlusMinusTolerance self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepShape.Handle_StepShape_PlusMinusTolerance_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepShape_PlusMinusTolerance self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_PlusMinusTolerance_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepShape_PlusMinusTolerance self)

        Increments the reference counter of this object


        """
        return _StepShape.Handle_StepShape_PlusMinusTolerance_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepShape_PlusMinusTolerance self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_PlusMinusTolerance_DecrementRefCounter(self, *args)

Handle_StepShape_PlusMinusTolerance_swigregister = _StepShape.Handle_StepShape_PlusMinusTolerance_swigregister
Handle_StepShape_PlusMinusTolerance_swigregister(Handle_StepShape_PlusMinusTolerance)

def Handle_StepShape_PlusMinusTolerance_DownCast(thing):
    return _StepShape.Handle_StepShape_PlusMinusTolerance_DownCast(thing)
Handle_StepShape_PlusMinusTolerance_DownCast = _StepShape.Handle_StepShape_PlusMinusTolerance_DownCast

class Handle_StepShape_AdvancedFace(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepShape_AdvancedFace self)

        Nullify the handle


        """
        return _StepShape.Handle_StepShape_AdvancedFace_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepShape_AdvancedFace self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepShape.Handle_StepShape_AdvancedFace_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepShape_AdvancedFace self, StepShape_AdvancedFace thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepShape.Handle_StepShape_AdvancedFace_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepShape_AdvancedFace self, Handle_StepShape_AdvancedFace theHandle) -> Handle_StepShape_AdvancedFace
        assign(Handle_StepShape_AdvancedFace self, StepShape_AdvancedFace thePtr) -> Handle_StepShape_AdvancedFace
        assign(Handle_StepShape_AdvancedFace self, Handle_StepShape_AdvancedFace theHandle) -> Handle_StepShape_AdvancedFace

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepShape.Handle_StepShape_AdvancedFace_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepShape_AdvancedFace self) -> StepShape_AdvancedFace

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepShape.Handle_StepShape_AdvancedFace_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepShape_AdvancedFace self) -> StepShape_AdvancedFace

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepShape.Handle_StepShape_AdvancedFace___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepShape_AdvancedFace self) -> StepShape_AdvancedFace

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepShape.Handle_StepShape_AdvancedFace___ref__(self, *args)


    def __hash__(self):
        return _StepShape.Handle_StepShape_AdvancedFace___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepShape.Handle_StepShape_AdvancedFace___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepShape.new_Handle_StepShape_AdvancedFace(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepShape.Handle_StepShape_AdvancedFace_DownCast)
    __swig_destroy__ = _StepShape.delete_Handle_StepShape_AdvancedFace

    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepShape_AdvancedFace self) -> char const *

        :rtype: const char *

        """
        return _StepShape.Handle_StepShape_AdvancedFace_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.Handle_StepShape_AdvancedFace_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.Handle_StepShape_AdvancedFace_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Init(self, *args):
        """
        Init(Handle_StepShape_AdvancedFace self, Handle_TCollection_HAsciiString aName, Handle_StepShape_HArray1OfFaceBound aBounds, Handle_StepGeom_Surface aFaceGeometry, Standard_Boolean const aSameSense)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aBounds: OCC.wrapper.StepShape.Handle_StepShape_HArray1OfFaceBound
        :type aFaceGeometry: OCC.wrapper.StepShape.Handle_StepGeom_Surface
        :type aSameSense: bool

        """
        return _StepShape.Handle_StepShape_AdvancedFace_Init(self, *args)


    def SetFaceGeometry(self, *args):
        """
        SetFaceGeometry(Handle_StepShape_AdvancedFace self, Handle_StepGeom_Surface aFaceGeometry)

        :type aFaceGeometry: OCC.wrapper.StepShape.Handle_StepGeom_Surface

        """
        return _StepShape.Handle_StepShape_AdvancedFace_SetFaceGeometry(self, *args)


    def FaceGeometry(self, *args):
        """
        FaceGeometry(Handle_StepShape_AdvancedFace self) -> Handle_StepGeom_Surface

        :rtype: OCC.wrapper.StepShape.Handle_StepGeom_Surface

        """
        return _StepShape.Handle_StepShape_AdvancedFace_FaceGeometry(self, *args)


    def SetSameSense(self, *args):
        """
        SetSameSense(Handle_StepShape_AdvancedFace self, Standard_Boolean const aSameSense)

        :type aSameSense: bool

        """
        return _StepShape.Handle_StepShape_AdvancedFace_SetSameSense(self, *args)


    def SameSense(self, *args):
        """
        SameSense(Handle_StepShape_AdvancedFace self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.Handle_StepShape_AdvancedFace_SameSense(self, *args)


    def SetBounds(self, *args):
        """
        SetBounds(Handle_StepShape_AdvancedFace self, Handle_StepShape_HArray1OfFaceBound aBounds)

        :type aBounds: OCC.wrapper.StepShape.Handle_StepShape_HArray1OfFaceBound

        """
        return _StepShape.Handle_StepShape_AdvancedFace_SetBounds(self, *args)


    def Bounds(self, *args):
        """
        Bounds(Handle_StepShape_AdvancedFace self) -> Handle_StepShape_HArray1OfFaceBound

        :rtype: OCC.wrapper.StepShape.Handle_StepShape_HArray1OfFaceBound

        """
        return _StepShape.Handle_StepShape_AdvancedFace_Bounds(self, *args)


    def BoundsValue(self, *args):
        """
        BoundsValue(Handle_StepShape_AdvancedFace self, Standard_Integer const num) -> Handle_StepShape_FaceBound

        :type num: int
        :rtype: OCC.wrapper.StepShape.Handle_StepShape_FaceBound

        """
        return _StepShape.Handle_StepShape_AdvancedFace_BoundsValue(self, *args)


    def NbBounds(self, *args):
        """
        NbBounds(Handle_StepShape_AdvancedFace self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_AdvancedFace_NbBounds(self, *args)


    def SetName(self, *args):
        """
        SetName(Handle_StepShape_AdvancedFace self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepShape.Handle_StepShape_AdvancedFace_SetName(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepShape_AdvancedFace self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepShape.Handle_StepShape_AdvancedFace_Name(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepShape_AdvancedFace self)

        Memory deallocator for transient classes


        """
        return _StepShape.Handle_StepShape_AdvancedFace_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepShape_AdvancedFace self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepShape_AdvancedFace self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.Handle_StepShape_AdvancedFace_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepShape_AdvancedFace self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepShape_AdvancedFace self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.Handle_StepShape_AdvancedFace_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepShape_AdvancedFace self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepShape.Handle_StepShape_AdvancedFace_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepShape_AdvancedFace self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_AdvancedFace_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepShape_AdvancedFace self)

        Increments the reference counter of this object


        """
        return _StepShape.Handle_StepShape_AdvancedFace_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepShape_AdvancedFace self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_AdvancedFace_DecrementRefCounter(self, *args)

Handle_StepShape_AdvancedFace_swigregister = _StepShape.Handle_StepShape_AdvancedFace_swigregister
Handle_StepShape_AdvancedFace_swigregister(Handle_StepShape_AdvancedFace)

def Handle_StepShape_AdvancedFace_DownCast(thing):
    return _StepShape.Handle_StepShape_AdvancedFace_DownCast(thing)
Handle_StepShape_AdvancedFace_DownCast = _StepShape.Handle_StepShape_AdvancedFace_DownCast

class NCollection_Array1_Handle_StepShape_ConnectedFaceSet(object):
    """
    Purpose:     The class Array1 represents unidimensional arrays 
    of fixed size known at run time. 
    The range of the index is user defined.
    An array1 can be constructed with a "C array".
    This functionality is useful to call methods expecting
    an Array1. It allows to carry the bounds inside the arrays.

    Examples:    Item tab[100]; //  An example with a C array
    Array1OfItem ttab (tab[0],1,100);

    Array1OfItem tttab (ttab(10),10,20); // a slice of ttab

    If you want to reindex an array from 1 to Length do :

    Array1 tab1(tab(tab.Lower()),1,tab.Length());

    Warning:     Programs client of such a class must be independant
    of the range of the first element. Then, a C++ for
    loop must be written like this

    for (i = A.Lower(); i <= A.Upper(); i++)

    Changes:     In  comparison  to  TCollection  the  flag  isAllocated  was
    renamed into myDeletable (alike in  the Array2).  For naming
    compatibility the method IsAllocated remained in class along
    with IsDeletable.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Array1_Handle_StepShape_ConnectedFaceSet self) -> NCollection_Array1< opencascade::handle< StepShape_ConnectedFaceSet > >::iterator

        Returns an iterator pointing to the first element in the array.

        :rtype: iterator

        """
        return _StepShape.NCollection_Array1_Handle_StepShape_ConnectedFaceSet_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Array1_Handle_StepShape_ConnectedFaceSet self) -> NCollection_Array1< opencascade::handle< StepShape_ConnectedFaceSet > >::iterator

        Returns an iterator referring to the past-the-end element in the array.

        :rtype: iterator

        """
        return _StepShape.NCollection_Array1_Handle_StepShape_ConnectedFaceSet_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Array1_Handle_StepShape_ConnectedFaceSet self) -> NCollection_Array1< opencascade::handle< StepShape_ConnectedFaceSet > >::const_iterator

        Returns a const iterator pointing to the first element in the array.

        :rtype: const_iterator

        """
        return _StepShape.NCollection_Array1_Handle_StepShape_ConnectedFaceSet_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Array1_Handle_StepShape_ConnectedFaceSet self) -> NCollection_Array1< opencascade::handle< StepShape_ConnectedFaceSet > >::const_iterator

        Returns a const iterator referring to the past-the-end element in the array.

        :rtype: const_iterator

        """
        return _StepShape.NCollection_Array1_Handle_StepShape_ConnectedFaceSet_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     The class Array1 represents unidimensional arrays 
        of fixed size known at run time. 
        The range of the index is user defined.
        An array1 can be constructed with a "C array".
        This functionality is useful to call methods expecting
        an Array1. It allows to carry the bounds inside the arrays.

        Examples:    Item tab[100]; //  An example with a C array
        Array1OfItem ttab (tab[0],1,100);

        Array1OfItem tttab (ttab(10),10,20); // a slice of ttab

        If you want to reindex an array from 1 to Length do :

        Array1 tab1(tab(tab.Lower()),1,tab.Length());

        Warning:     Programs client of such a class must be independant
        of the range of the first element. Then, a C++ for
        loop must be written like this

        for (i = A.Lower(); i <= A.Upper(); i++)

        Changes:     In  comparison  to  TCollection  the  flag  isAllocated  was
        renamed into myDeletable (alike in  the Array2).  For naming
        compatibility the method IsAllocated remained in class along
        with IsDeletable.
        """
        this = _StepShape.new_NCollection_Array1_Handle_StepShape_ConnectedFaceSet(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(NCollection_Array1_Handle_StepShape_ConnectedFaceSet self, Handle_StepShape_ConnectedFaceSet theValue)

        Initialise the items with theValue

        :type theValue: const TheItemType &

        """
        return _StepShape.NCollection_Array1_Handle_StepShape_ConnectedFaceSet_Init(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_Array1_Handle_StepShape_ConnectedFaceSet self) -> Standard_Integer

        Size query

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.NCollection_Array1_Handle_StepShape_ConnectedFaceSet_Size(self, *args)


    def Length(self, *args):
        """
        Length(NCollection_Array1_Handle_StepShape_ConnectedFaceSet self) -> Standard_Integer

        Length query (the same)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.NCollection_Array1_Handle_StepShape_ConnectedFaceSet_Length(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Array1_Handle_StepShape_ConnectedFaceSet self) -> Standard_Boolean

        Return TRUE if array has zero length.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.NCollection_Array1_Handle_StepShape_ConnectedFaceSet_IsEmpty(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Array1_Handle_StepShape_ConnectedFaceSet self) -> Standard_Integer

        Lower bound

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.NCollection_Array1_Handle_StepShape_ConnectedFaceSet_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Array1_Handle_StepShape_ConnectedFaceSet self) -> Standard_Integer

        Upper bound

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.NCollection_Array1_Handle_StepShape_ConnectedFaceSet_Upper(self, *args)


    def IsDeletable(self, *args):
        """
        IsDeletable(NCollection_Array1_Handle_StepShape_ConnectedFaceSet self) -> Standard_Boolean

        myDeletable flag

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.NCollection_Array1_Handle_StepShape_ConnectedFaceSet_IsDeletable(self, *args)


    def IsAllocated(self, *args):
        """
        IsAllocated(NCollection_Array1_Handle_StepShape_ConnectedFaceSet self) -> Standard_Boolean

        IsAllocated flag - for naming compatibility

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.NCollection_Array1_Handle_StepShape_ConnectedFaceSet_IsAllocated(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Array1_Handle_StepShape_ConnectedFaceSet self, NCollection_Array1_Handle_StepShape_ConnectedFaceSet theOther) -> NCollection_Array1_Handle_StepShape_ConnectedFaceSet

        Copies data of theOther array to this.
        This array should be pre-allocated and have the same length as theOther;
        otherwise exception Standard_DimensionMismatch is thrown.

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _StepShape.NCollection_Array1_Handle_StepShape_ConnectedFaceSet_Assign(self, *args)


    def Move(self, *args):
        """
        Move(NCollection_Array1_Handle_StepShape_ConnectedFaceSet self, NCollection_Array1_Handle_StepShape_ConnectedFaceSet theOther) -> NCollection_Array1_Handle_StepShape_ConnectedFaceSet

        Move assignment.
        This array will borrow all the data from theOther.
        The moved object will keep pointer to the memory buffer and
        range, but it will not free the buffer on destruction.

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _StepShape.NCollection_Array1_Handle_StepShape_ConnectedFaceSet_Move(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Array1_Handle_StepShape_ConnectedFaceSet self, NCollection_Array1_Handle_StepShape_ConnectedFaceSet theOther) -> NCollection_Array1_Handle_StepShape_ConnectedFaceSet
        assign(NCollection_Array1_Handle_StepShape_ConnectedFaceSet self, NCollection_Array1_Handle_StepShape_ConnectedFaceSet theOther) -> NCollection_Array1_Handle_StepShape_ConnectedFaceSet

        Move assignment operator; @sa Move()

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1<TheItemType> &&
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _StepShape.NCollection_Array1_Handle_StepShape_ConnectedFaceSet_assign(self, *args)


    def First(self, *args):
        """
        @return first element

        :rtype: const TheItemType &

        """
        res = _StepShape.NCollection_Array1_Handle_StepShape_ConnectedFaceSet_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Array1_Handle_StepShape_ConnectedFaceSet self) -> Handle_StepShape_ConnectedFaceSet

        @return first element

        :rtype: TheItemType &

        """
        return _StepShape.NCollection_Array1_Handle_StepShape_ConnectedFaceSet_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        @return last element

        :rtype: const TheItemType &

        """
        res = _StepShape.NCollection_Array1_Handle_StepShape_ConnectedFaceSet_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Array1_Handle_StepShape_ConnectedFaceSet self) -> Handle_StepShape_ConnectedFaceSet

        @return last element

        :rtype: TheItemType &

        """
        return _StepShape.NCollection_Array1_Handle_StepShape_ConnectedFaceSet_ChangeLast(self, *args)


    def Value(self, *args):
        """
        Constant value access

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _StepShape.NCollection_Array1_Handle_StepShape_ConnectedFaceSet_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Array1_Handle_StepShape_ConnectedFaceSet self, Standard_Integer const theIndex) -> Handle_StepShape_ConnectedFaceSet

        Variable value access

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _StepShape.NCollection_Array1_Handle_StepShape_ConnectedFaceSet_ChangeValue(self, *args)


    def __call__(self, *args):
        """
        operator() - alias to Value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _StepShape.NCollection_Array1_Handle_StepShape_ConnectedFaceSet___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __getitem__(self, *args):
        """
        operator[] - alias to Value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _StepShape.NCollection_Array1_Handle_StepShape_ConnectedFaceSet_at(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetValue(self, *args):
        """
        SetValue(NCollection_Array1_Handle_StepShape_ConnectedFaceSet self, Standard_Integer const theIndex, Handle_StepShape_ConnectedFaceSet theItem)

        Set value 

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _StepShape.NCollection_Array1_Handle_StepShape_ConnectedFaceSet_SetValue(self, *args)


    def Resize(self, *args):
        """
        Resize(NCollection_Array1_Handle_StepShape_ConnectedFaceSet self, Standard_Integer const theLower, Standard_Integer const theUpper, Standard_Boolean const theToCopyData)

        Resizes the array to specified bounds.
        No re-allocation will be done if length of array does not change,
        but existing values will not be discarded if theToCopyData set to FALSE.
        @param theLower new lower bound of array
        @param theUpper new upper bound of array
        @param theToCopyData flag to copy existing data into new array

        :type theLower: int
        :type theUpper: int
        :type theToCopyData: bool

        """
        return _StepShape.NCollection_Array1_Handle_StepShape_ConnectedFaceSet_Resize(self, *args)

    __swig_destroy__ = _StepShape.delete_NCollection_Array1_Handle_StepShape_ConnectedFaceSet
NCollection_Array1_Handle_StepShape_ConnectedFaceSet_swigregister = _StepShape.NCollection_Array1_Handle_StepShape_ConnectedFaceSet_swigregister
NCollection_Array1_Handle_StepShape_ConnectedFaceSet_swigregister(NCollection_Array1_Handle_StepShape_ConnectedFaceSet)


try:
	StepShape_Array1OfConnectedFaceSet = NCollection_Array1_Handle_StepShape_ConnectedFaceSet
except NameError:
	pass # does not exist, probably ignored

class Handle_StepShape_SweptAreaSolid(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepShape_SweptAreaSolid self)

        Nullify the handle


        """
        return _StepShape.Handle_StepShape_SweptAreaSolid_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepShape_SweptAreaSolid self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepShape.Handle_StepShape_SweptAreaSolid_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepShape_SweptAreaSolid self, StepShape_SweptAreaSolid thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepShape.Handle_StepShape_SweptAreaSolid_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepShape_SweptAreaSolid self, Handle_StepShape_SweptAreaSolid theHandle) -> Handle_StepShape_SweptAreaSolid
        assign(Handle_StepShape_SweptAreaSolid self, StepShape_SweptAreaSolid thePtr) -> Handle_StepShape_SweptAreaSolid
        assign(Handle_StepShape_SweptAreaSolid self, Handle_StepShape_SweptAreaSolid theHandle) -> Handle_StepShape_SweptAreaSolid

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepShape.Handle_StepShape_SweptAreaSolid_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepShape_SweptAreaSolid self) -> StepShape_SweptAreaSolid

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepShape.Handle_StepShape_SweptAreaSolid_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepShape_SweptAreaSolid self) -> StepShape_SweptAreaSolid

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepShape.Handle_StepShape_SweptAreaSolid___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepShape_SweptAreaSolid self) -> StepShape_SweptAreaSolid

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepShape.Handle_StepShape_SweptAreaSolid___ref__(self, *args)


    def __hash__(self):
        return _StepShape.Handle_StepShape_SweptAreaSolid___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepShape.Handle_StepShape_SweptAreaSolid___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepShape.new_Handle_StepShape_SweptAreaSolid(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepShape.Handle_StepShape_SweptAreaSolid_DownCast)
    __swig_destroy__ = _StepShape.delete_Handle_StepShape_SweptAreaSolid

    def Init(self, *args):
        """
        Init(Handle_StepShape_SweptAreaSolid self, Handle_TCollection_HAsciiString aName, Handle_StepGeom_CurveBoundedSurface aSweptArea)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aSweptArea: OCC.wrapper.StepShape.Handle_StepGeom_CurveBoundedSurface

        """
        return _StepShape.Handle_StepShape_SweptAreaSolid_Init(self, *args)


    def SetSweptArea(self, *args):
        """
        SetSweptArea(Handle_StepShape_SweptAreaSolid self, Handle_StepGeom_CurveBoundedSurface aSweptArea)

        :type aSweptArea: OCC.wrapper.StepShape.Handle_StepGeom_CurveBoundedSurface

        """
        return _StepShape.Handle_StepShape_SweptAreaSolid_SetSweptArea(self, *args)


    def SweptArea(self, *args):
        """
        SweptArea(Handle_StepShape_SweptAreaSolid self) -> Handle_StepGeom_CurveBoundedSurface

        :rtype: OCC.wrapper.StepShape.Handle_StepGeom_CurveBoundedSurface

        """
        return _StepShape.Handle_StepShape_SweptAreaSolid_SweptArea(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepShape_SweptAreaSolid self) -> char const *

        :rtype: const char *

        """
        return _StepShape.Handle_StepShape_SweptAreaSolid_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.Handle_StepShape_SweptAreaSolid_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.Handle_StepShape_SweptAreaSolid_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetName(self, *args):
        """
        SetName(Handle_StepShape_SweptAreaSolid self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepShape.Handle_StepShape_SweptAreaSolid_SetName(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepShape_SweptAreaSolid self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepShape.Handle_StepShape_SweptAreaSolid_Name(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepShape_SweptAreaSolid self)

        Memory deallocator for transient classes


        """
        return _StepShape.Handle_StepShape_SweptAreaSolid_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepShape_SweptAreaSolid self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepShape_SweptAreaSolid self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.Handle_StepShape_SweptAreaSolid_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepShape_SweptAreaSolid self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepShape_SweptAreaSolid self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.Handle_StepShape_SweptAreaSolid_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepShape_SweptAreaSolid self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepShape.Handle_StepShape_SweptAreaSolid_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepShape_SweptAreaSolid self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_SweptAreaSolid_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepShape_SweptAreaSolid self)

        Increments the reference counter of this object


        """
        return _StepShape.Handle_StepShape_SweptAreaSolid_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepShape_SweptAreaSolid self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_SweptAreaSolid_DecrementRefCounter(self, *args)

Handle_StepShape_SweptAreaSolid_swigregister = _StepShape.Handle_StepShape_SweptAreaSolid_swigregister
Handle_StepShape_SweptAreaSolid_swigregister(Handle_StepShape_SweptAreaSolid)

def Handle_StepShape_SweptAreaSolid_DownCast(thing):
    return _StepShape.Handle_StepShape_SweptAreaSolid_DownCast(thing)
Handle_StepShape_SweptAreaSolid_DownCast = _StepShape.Handle_StepShape_SweptAreaSolid_DownCast

class NCollection_Array1_StepShape_ValueQualifier(object):
    """
    Purpose:     The class Array1 represents unidimensional arrays 
    of fixed size known at run time. 
    The range of the index is user defined.
    An array1 can be constructed with a "C array".
    This functionality is useful to call methods expecting
    an Array1. It allows to carry the bounds inside the arrays.

    Examples:    Item tab[100]; //  An example with a C array
    Array1OfItem ttab (tab[0],1,100);

    Array1OfItem tttab (ttab(10),10,20); // a slice of ttab

    If you want to reindex an array from 1 to Length do :

    Array1 tab1(tab(tab.Lower()),1,tab.Length());

    Warning:     Programs client of such a class must be independant
    of the range of the first element. Then, a C++ for
    loop must be written like this

    for (i = A.Lower(); i <= A.Upper(); i++)

    Changes:     In  comparison  to  TCollection  the  flag  isAllocated  was
    renamed into myDeletable (alike in  the Array2).  For naming
    compatibility the method IsAllocated remained in class along
    with IsDeletable.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Array1_StepShape_ValueQualifier self) -> NCollection_Array1< StepShape_ValueQualifier >::iterator

        Returns an iterator pointing to the first element in the array.

        :rtype: iterator

        """
        return _StepShape.NCollection_Array1_StepShape_ValueQualifier_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Array1_StepShape_ValueQualifier self) -> NCollection_Array1< StepShape_ValueQualifier >::iterator

        Returns an iterator referring to the past-the-end element in the array.

        :rtype: iterator

        """
        return _StepShape.NCollection_Array1_StepShape_ValueQualifier_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Array1_StepShape_ValueQualifier self) -> NCollection_Array1< StepShape_ValueQualifier >::const_iterator

        Returns a const iterator pointing to the first element in the array.

        :rtype: const_iterator

        """
        return _StepShape.NCollection_Array1_StepShape_ValueQualifier_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Array1_StepShape_ValueQualifier self) -> NCollection_Array1< StepShape_ValueQualifier >::const_iterator

        Returns a const iterator referring to the past-the-end element in the array.

        :rtype: const_iterator

        """
        return _StepShape.NCollection_Array1_StepShape_ValueQualifier_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     The class Array1 represents unidimensional arrays 
        of fixed size known at run time. 
        The range of the index is user defined.
        An array1 can be constructed with a "C array".
        This functionality is useful to call methods expecting
        an Array1. It allows to carry the bounds inside the arrays.

        Examples:    Item tab[100]; //  An example with a C array
        Array1OfItem ttab (tab[0],1,100);

        Array1OfItem tttab (ttab(10),10,20); // a slice of ttab

        If you want to reindex an array from 1 to Length do :

        Array1 tab1(tab(tab.Lower()),1,tab.Length());

        Warning:     Programs client of such a class must be independant
        of the range of the first element. Then, a C++ for
        loop must be written like this

        for (i = A.Lower(); i <= A.Upper(); i++)

        Changes:     In  comparison  to  TCollection  the  flag  isAllocated  was
        renamed into myDeletable (alike in  the Array2).  For naming
        compatibility the method IsAllocated remained in class along
        with IsDeletable.
        """
        this = _StepShape.new_NCollection_Array1_StepShape_ValueQualifier(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(NCollection_Array1_StepShape_ValueQualifier self, StepShape_ValueQualifier theValue)

        Initialise the items with theValue

        :type theValue: const TheItemType &

        """
        return _StepShape.NCollection_Array1_StepShape_ValueQualifier_Init(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_Array1_StepShape_ValueQualifier self) -> Standard_Integer

        Size query

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.NCollection_Array1_StepShape_ValueQualifier_Size(self, *args)


    def Length(self, *args):
        """
        Length(NCollection_Array1_StepShape_ValueQualifier self) -> Standard_Integer

        Length query (the same)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.NCollection_Array1_StepShape_ValueQualifier_Length(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Array1_StepShape_ValueQualifier self) -> Standard_Boolean

        Return TRUE if array has zero length.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.NCollection_Array1_StepShape_ValueQualifier_IsEmpty(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Array1_StepShape_ValueQualifier self) -> Standard_Integer

        Lower bound

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.NCollection_Array1_StepShape_ValueQualifier_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Array1_StepShape_ValueQualifier self) -> Standard_Integer

        Upper bound

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.NCollection_Array1_StepShape_ValueQualifier_Upper(self, *args)


    def IsDeletable(self, *args):
        """
        IsDeletable(NCollection_Array1_StepShape_ValueQualifier self) -> Standard_Boolean

        myDeletable flag

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.NCollection_Array1_StepShape_ValueQualifier_IsDeletable(self, *args)


    def IsAllocated(self, *args):
        """
        IsAllocated(NCollection_Array1_StepShape_ValueQualifier self) -> Standard_Boolean

        IsAllocated flag - for naming compatibility

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.NCollection_Array1_StepShape_ValueQualifier_IsAllocated(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Array1_StepShape_ValueQualifier self, NCollection_Array1_StepShape_ValueQualifier theOther) -> NCollection_Array1_StepShape_ValueQualifier

        Copies data of theOther array to this.
        This array should be pre-allocated and have the same length as theOther;
        otherwise exception Standard_DimensionMismatch is thrown.

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _StepShape.NCollection_Array1_StepShape_ValueQualifier_Assign(self, *args)


    def Move(self, *args):
        """
        Move(NCollection_Array1_StepShape_ValueQualifier self, NCollection_Array1_StepShape_ValueQualifier theOther) -> NCollection_Array1_StepShape_ValueQualifier

        Move assignment.
        This array will borrow all the data from theOther.
        The moved object will keep pointer to the memory buffer and
        range, but it will not free the buffer on destruction.

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _StepShape.NCollection_Array1_StepShape_ValueQualifier_Move(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Array1_StepShape_ValueQualifier self, NCollection_Array1_StepShape_ValueQualifier theOther) -> NCollection_Array1_StepShape_ValueQualifier
        assign(NCollection_Array1_StepShape_ValueQualifier self, NCollection_Array1_StepShape_ValueQualifier theOther) -> NCollection_Array1_StepShape_ValueQualifier

        Move assignment operator; @sa Move()

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1<TheItemType> &&
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _StepShape.NCollection_Array1_StepShape_ValueQualifier_assign(self, *args)


    def First(self, *args):
        """
        @return first element

        :rtype: const TheItemType &

        """
        res = _StepShape.NCollection_Array1_StepShape_ValueQualifier_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Array1_StepShape_ValueQualifier self) -> StepShape_ValueQualifier

        @return first element

        :rtype: TheItemType &

        """
        return _StepShape.NCollection_Array1_StepShape_ValueQualifier_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        @return last element

        :rtype: const TheItemType &

        """
        res = _StepShape.NCollection_Array1_StepShape_ValueQualifier_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Array1_StepShape_ValueQualifier self) -> StepShape_ValueQualifier

        @return last element

        :rtype: TheItemType &

        """
        return _StepShape.NCollection_Array1_StepShape_ValueQualifier_ChangeLast(self, *args)


    def Value(self, *args):
        """
        Constant value access

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _StepShape.NCollection_Array1_StepShape_ValueQualifier_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Array1_StepShape_ValueQualifier self, Standard_Integer const theIndex) -> StepShape_ValueQualifier

        Variable value access

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _StepShape.NCollection_Array1_StepShape_ValueQualifier_ChangeValue(self, *args)


    def __call__(self, *args):
        """
        operator() - alias to Value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _StepShape.NCollection_Array1_StepShape_ValueQualifier___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __getitem__(self, *args):
        """
        operator[] - alias to Value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _StepShape.NCollection_Array1_StepShape_ValueQualifier_at(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetValue(self, *args):
        """
        SetValue(NCollection_Array1_StepShape_ValueQualifier self, Standard_Integer const theIndex, StepShape_ValueQualifier theItem)

        Set value 

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _StepShape.NCollection_Array1_StepShape_ValueQualifier_SetValue(self, *args)


    def Resize(self, *args):
        """
        Resize(NCollection_Array1_StepShape_ValueQualifier self, Standard_Integer const theLower, Standard_Integer const theUpper, Standard_Boolean const theToCopyData)

        Resizes the array to specified bounds.
        No re-allocation will be done if length of array does not change,
        but existing values will not be discarded if theToCopyData set to FALSE.
        @param theLower new lower bound of array
        @param theUpper new upper bound of array
        @param theToCopyData flag to copy existing data into new array

        :type theLower: int
        :type theUpper: int
        :type theToCopyData: bool

        """
        return _StepShape.NCollection_Array1_StepShape_ValueQualifier_Resize(self, *args)

    __swig_destroy__ = _StepShape.delete_NCollection_Array1_StepShape_ValueQualifier
NCollection_Array1_StepShape_ValueQualifier_swigregister = _StepShape.NCollection_Array1_StepShape_ValueQualifier_swigregister
NCollection_Array1_StepShape_ValueQualifier_swigregister(NCollection_Array1_StepShape_ValueQualifier)


try:
	StepShape_Array1OfValueQualifier = NCollection_Array1_StepShape_ValueQualifier
except NameError:
	pass # does not exist, probably ignored

class Handle_StepShape_FaceBound(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepShape_FaceBound self)

        Nullify the handle


        """
        return _StepShape.Handle_StepShape_FaceBound_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepShape_FaceBound self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepShape.Handle_StepShape_FaceBound_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepShape_FaceBound self, StepShape_FaceBound thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepShape.Handle_StepShape_FaceBound_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepShape_FaceBound self, Handle_StepShape_FaceBound theHandle) -> Handle_StepShape_FaceBound
        assign(Handle_StepShape_FaceBound self, StepShape_FaceBound thePtr) -> Handle_StepShape_FaceBound
        assign(Handle_StepShape_FaceBound self, Handle_StepShape_FaceBound theHandle) -> Handle_StepShape_FaceBound

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepShape.Handle_StepShape_FaceBound_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepShape_FaceBound self) -> StepShape_FaceBound

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepShape.Handle_StepShape_FaceBound_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepShape_FaceBound self) -> StepShape_FaceBound

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepShape.Handle_StepShape_FaceBound___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepShape_FaceBound self) -> StepShape_FaceBound

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepShape.Handle_StepShape_FaceBound___ref__(self, *args)


    def __hash__(self):
        return _StepShape.Handle_StepShape_FaceBound___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepShape.Handle_StepShape_FaceBound___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepShape.new_Handle_StepShape_FaceBound(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepShape.Handle_StepShape_FaceBound_DownCast)
    __swig_destroy__ = _StepShape.delete_Handle_StepShape_FaceBound

    def Init(self, *args):
        """
        Init(Handle_StepShape_FaceBound self, Handle_TCollection_HAsciiString aName, Handle_StepShape_Loop aBound, Standard_Boolean const aOrientation)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aBound: OCC.wrapper.StepShape.Handle_StepShape_Loop
        :type aOrientation: bool

        """
        return _StepShape.Handle_StepShape_FaceBound_Init(self, *args)


    def SetBound(self, *args):
        """
        SetBound(Handle_StepShape_FaceBound self, Handle_StepShape_Loop aBound)

        :type aBound: OCC.wrapper.StepShape.Handle_StepShape_Loop

        """
        return _StepShape.Handle_StepShape_FaceBound_SetBound(self, *args)


    def Bound(self, *args):
        """
        Bound(Handle_StepShape_FaceBound self) -> Handle_StepShape_Loop

        :rtype: OCC.wrapper.StepShape.Handle_StepShape_Loop

        """
        return _StepShape.Handle_StepShape_FaceBound_Bound(self, *args)


    def SetOrientation(self, *args):
        """
        SetOrientation(Handle_StepShape_FaceBound self, Standard_Boolean const aOrientation)

        :type aOrientation: bool

        """
        return _StepShape.Handle_StepShape_FaceBound_SetOrientation(self, *args)


    def Orientation(self, *args):
        """
        Orientation(Handle_StepShape_FaceBound self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.Handle_StepShape_FaceBound_Orientation(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepShape_FaceBound self) -> char const *

        :rtype: const char *

        """
        return _StepShape.Handle_StepShape_FaceBound_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.Handle_StepShape_FaceBound_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.Handle_StepShape_FaceBound_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetName(self, *args):
        """
        SetName(Handle_StepShape_FaceBound self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepShape.Handle_StepShape_FaceBound_SetName(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepShape_FaceBound self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepShape.Handle_StepShape_FaceBound_Name(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepShape_FaceBound self)

        Memory deallocator for transient classes


        """
        return _StepShape.Handle_StepShape_FaceBound_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepShape_FaceBound self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepShape_FaceBound self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.Handle_StepShape_FaceBound_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepShape_FaceBound self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepShape_FaceBound self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.Handle_StepShape_FaceBound_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepShape_FaceBound self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepShape.Handle_StepShape_FaceBound_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepShape_FaceBound self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_FaceBound_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepShape_FaceBound self)

        Increments the reference counter of this object


        """
        return _StepShape.Handle_StepShape_FaceBound_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepShape_FaceBound self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_FaceBound_DecrementRefCounter(self, *args)

Handle_StepShape_FaceBound_swigregister = _StepShape.Handle_StepShape_FaceBound_swigregister
Handle_StepShape_FaceBound_swigregister(Handle_StepShape_FaceBound)

def Handle_StepShape_FaceBound_DownCast(thing):
    return _StepShape.Handle_StepShape_FaceBound_DownCast(thing)
Handle_StepShape_FaceBound_DownCast = _StepShape.Handle_StepShape_FaceBound_DownCast

class Handle_StepShape_ContextDependentShapeRepresentation(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepShape_ContextDependentShapeRepresentation self)

        Nullify the handle


        """
        return _StepShape.Handle_StepShape_ContextDependentShapeRepresentation_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepShape_ContextDependentShapeRepresentation self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepShape.Handle_StepShape_ContextDependentShapeRepresentation_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepShape_ContextDependentShapeRepresentation self, StepShape_ContextDependentShapeRepresentation thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepShape.Handle_StepShape_ContextDependentShapeRepresentation_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepShape_ContextDependentShapeRepresentation self, Handle_StepShape_ContextDependentShapeRepresentation theHandle) -> Handle_StepShape_ContextDependentShapeRepresentation
        assign(Handle_StepShape_ContextDependentShapeRepresentation self, StepShape_ContextDependentShapeRepresentation thePtr) -> Handle_StepShape_ContextDependentShapeRepresentation
        assign(Handle_StepShape_ContextDependentShapeRepresentation self, Handle_StepShape_ContextDependentShapeRepresentation theHandle) -> Handle_StepShape_ContextDependentShapeRepresentation

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepShape.Handle_StepShape_ContextDependentShapeRepresentation_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepShape_ContextDependentShapeRepresentation self) -> StepShape_ContextDependentShapeRepresentation

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepShape.Handle_StepShape_ContextDependentShapeRepresentation_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepShape_ContextDependentShapeRepresentation self) -> StepShape_ContextDependentShapeRepresentation

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepShape.Handle_StepShape_ContextDependentShapeRepresentation___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepShape_ContextDependentShapeRepresentation self) -> StepShape_ContextDependentShapeRepresentation

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepShape.Handle_StepShape_ContextDependentShapeRepresentation___ref__(self, *args)


    def __hash__(self):
        return _StepShape.Handle_StepShape_ContextDependentShapeRepresentation___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepShape.Handle_StepShape_ContextDependentShapeRepresentation___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepShape.new_Handle_StepShape_ContextDependentShapeRepresentation(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepShape.Handle_StepShape_ContextDependentShapeRepresentation_DownCast)
    __swig_destroy__ = _StepShape.delete_Handle_StepShape_ContextDependentShapeRepresentation

    def Init(self, *args):
        """
        Init(Handle_StepShape_ContextDependentShapeRepresentation self, Handle_StepRepr_ShapeRepresentationRelationship aRepRel, Handle_StepRepr_ProductDefinitionShape aProRel)

        :type aRepRel: OCC.wrapper.StepShape.Handle_StepRepr_ShapeRepresentationRelationship
        :type aProRel: OCC.wrapper.StepShape.Handle_StepRepr_ProductDefinitionShape

        """
        return _StepShape.Handle_StepShape_ContextDependentShapeRepresentation_Init(self, *args)


    def RepresentationRelation(self, *args):
        """
        RepresentationRelation(Handle_StepShape_ContextDependentShapeRepresentation self) -> Handle_StepRepr_ShapeRepresentationRelationship

        :rtype: OCC.wrapper.StepShape.Handle_StepRepr_ShapeRepresentationRelationship

        """
        return _StepShape.Handle_StepShape_ContextDependentShapeRepresentation_RepresentationRelation(self, *args)


    def SetRepresentationRelation(self, *args):
        """
        SetRepresentationRelation(Handle_StepShape_ContextDependentShapeRepresentation self, Handle_StepRepr_ShapeRepresentationRelationship aRepRel)

        :type aRepRel: OCC.wrapper.StepShape.Handle_StepRepr_ShapeRepresentationRelationship

        """
        return _StepShape.Handle_StepShape_ContextDependentShapeRepresentation_SetRepresentationRelation(self, *args)


    def RepresentedProductRelation(self, *args):
        """
        RepresentedProductRelation(Handle_StepShape_ContextDependentShapeRepresentation self) -> Handle_StepRepr_ProductDefinitionShape

        :rtype: OCC.wrapper.StepShape.Handle_StepRepr_ProductDefinitionShape

        """
        return _StepShape.Handle_StepShape_ContextDependentShapeRepresentation_RepresentedProductRelation(self, *args)


    def SetRepresentedProductRelation(self, *args):
        """
        SetRepresentedProductRelation(Handle_StepShape_ContextDependentShapeRepresentation self, Handle_StepRepr_ProductDefinitionShape aProRel)

        :type aProRel: OCC.wrapper.StepShape.Handle_StepRepr_ProductDefinitionShape

        """
        return _StepShape.Handle_StepShape_ContextDependentShapeRepresentation_SetRepresentedProductRelation(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepShape_ContextDependentShapeRepresentation self) -> char const *

        :rtype: const char *

        """
        return _StepShape.Handle_StepShape_ContextDependentShapeRepresentation_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.Handle_StepShape_ContextDependentShapeRepresentation_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.Handle_StepShape_ContextDependentShapeRepresentation_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_StepShape_ContextDependentShapeRepresentation self)

        Memory deallocator for transient classes


        """
        return _StepShape.Handle_StepShape_ContextDependentShapeRepresentation_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepShape_ContextDependentShapeRepresentation self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepShape_ContextDependentShapeRepresentation self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.Handle_StepShape_ContextDependentShapeRepresentation_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepShape_ContextDependentShapeRepresentation self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepShape_ContextDependentShapeRepresentation self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.Handle_StepShape_ContextDependentShapeRepresentation_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepShape_ContextDependentShapeRepresentation self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepShape.Handle_StepShape_ContextDependentShapeRepresentation_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepShape_ContextDependentShapeRepresentation self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_ContextDependentShapeRepresentation_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepShape_ContextDependentShapeRepresentation self)

        Increments the reference counter of this object


        """
        return _StepShape.Handle_StepShape_ContextDependentShapeRepresentation_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepShape_ContextDependentShapeRepresentation self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_ContextDependentShapeRepresentation_DecrementRefCounter(self, *args)

Handle_StepShape_ContextDependentShapeRepresentation_swigregister = _StepShape.Handle_StepShape_ContextDependentShapeRepresentation_swigregister
Handle_StepShape_ContextDependentShapeRepresentation_swigregister(Handle_StepShape_ContextDependentShapeRepresentation)

def Handle_StepShape_ContextDependentShapeRepresentation_DownCast(thing):
    return _StepShape.Handle_StepShape_ContextDependentShapeRepresentation_DownCast(thing)
Handle_StepShape_ContextDependentShapeRepresentation_DownCast = _StepShape.Handle_StepShape_ContextDependentShapeRepresentation_DownCast

class Handle_StepShape_Block(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepShape_Block self)

        Nullify the handle


        """
        return _StepShape.Handle_StepShape_Block_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepShape_Block self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepShape.Handle_StepShape_Block_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepShape_Block self, StepShape_Block thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepShape.Handle_StepShape_Block_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepShape_Block self, Handle_StepShape_Block theHandle) -> Handle_StepShape_Block
        assign(Handle_StepShape_Block self, StepShape_Block thePtr) -> Handle_StepShape_Block
        assign(Handle_StepShape_Block self, Handle_StepShape_Block theHandle) -> Handle_StepShape_Block

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepShape.Handle_StepShape_Block_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepShape_Block self) -> StepShape_Block

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepShape.Handle_StepShape_Block_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepShape_Block self) -> StepShape_Block

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepShape.Handle_StepShape_Block___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepShape_Block self) -> StepShape_Block

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepShape.Handle_StepShape_Block___ref__(self, *args)


    def __hash__(self):
        return _StepShape.Handle_StepShape_Block___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepShape.Handle_StepShape_Block___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepShape.new_Handle_StepShape_Block(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepShape.Handle_StepShape_Block_DownCast)
    __swig_destroy__ = _StepShape.delete_Handle_StepShape_Block

    def Init(self, *args):
        """
        Init(Handle_StepShape_Block self, Handle_TCollection_HAsciiString aName, Handle_StepGeom_Axis2Placement3d aPosition, Standard_Real const aX, Standard_Real const aY, Standard_Real const aZ)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aPosition: OCC.wrapper.StepShape.Handle_StepGeom_Axis2Placement3d
        :type aX: float
        :type aY: float
        :type aZ: float

        """
        return _StepShape.Handle_StepShape_Block_Init(self, *args)


    def SetPosition(self, *args):
        """
        SetPosition(Handle_StepShape_Block self, Handle_StepGeom_Axis2Placement3d aPosition)

        :type aPosition: OCC.wrapper.StepShape.Handle_StepGeom_Axis2Placement3d

        """
        return _StepShape.Handle_StepShape_Block_SetPosition(self, *args)


    def Position(self, *args):
        """
        Position(Handle_StepShape_Block self) -> Handle_StepGeom_Axis2Placement3d

        :rtype: OCC.wrapper.StepShape.Handle_StepGeom_Axis2Placement3d

        """
        return _StepShape.Handle_StepShape_Block_Position(self, *args)


    def SetX(self, *args):
        """
        SetX(Handle_StepShape_Block self, Standard_Real const aX)

        :type aX: float

        """
        return _StepShape.Handle_StepShape_Block_SetX(self, *args)


    def X(self, *args):
        """
        X(Handle_StepShape_Block self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _StepShape.Handle_StepShape_Block_X(self, *args)


    def SetY(self, *args):
        """
        SetY(Handle_StepShape_Block self, Standard_Real const aY)

        :type aY: float

        """
        return _StepShape.Handle_StepShape_Block_SetY(self, *args)


    def Y(self, *args):
        """
        Y(Handle_StepShape_Block self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _StepShape.Handle_StepShape_Block_Y(self, *args)


    def SetZ(self, *args):
        """
        SetZ(Handle_StepShape_Block self, Standard_Real const aZ)

        :type aZ: float

        """
        return _StepShape.Handle_StepShape_Block_SetZ(self, *args)


    def Z(self, *args):
        """
        Z(Handle_StepShape_Block self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _StepShape.Handle_StepShape_Block_Z(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepShape_Block self) -> char const *

        :rtype: const char *

        """
        return _StepShape.Handle_StepShape_Block_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.Handle_StepShape_Block_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.Handle_StepShape_Block_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetName(self, *args):
        """
        SetName(Handle_StepShape_Block self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepShape.Handle_StepShape_Block_SetName(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepShape_Block self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepShape.Handle_StepShape_Block_Name(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepShape_Block self)

        Memory deallocator for transient classes


        """
        return _StepShape.Handle_StepShape_Block_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepShape_Block self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepShape_Block self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.Handle_StepShape_Block_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepShape_Block self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepShape_Block self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.Handle_StepShape_Block_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepShape_Block self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepShape.Handle_StepShape_Block_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepShape_Block self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_Block_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepShape_Block self)

        Increments the reference counter of this object


        """
        return _StepShape.Handle_StepShape_Block_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepShape_Block self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_Block_DecrementRefCounter(self, *args)

Handle_StepShape_Block_swigregister = _StepShape.Handle_StepShape_Block_swigregister
Handle_StepShape_Block_swigregister(Handle_StepShape_Block)

def Handle_StepShape_Block_DownCast(thing):
    return _StepShape.Handle_StepShape_Block_DownCast(thing)
Handle_StepShape_Block_DownCast = _StepShape.Handle_StepShape_Block_DownCast

class Handle_StepShape_EdgeBasedWireframeModel(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepShape_EdgeBasedWireframeModel self)

        Nullify the handle


        """
        return _StepShape.Handle_StepShape_EdgeBasedWireframeModel_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepShape_EdgeBasedWireframeModel self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepShape.Handle_StepShape_EdgeBasedWireframeModel_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepShape_EdgeBasedWireframeModel self, StepShape_EdgeBasedWireframeModel thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepShape.Handle_StepShape_EdgeBasedWireframeModel_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepShape_EdgeBasedWireframeModel self, Handle_StepShape_EdgeBasedWireframeModel theHandle) -> Handle_StepShape_EdgeBasedWireframeModel
        assign(Handle_StepShape_EdgeBasedWireframeModel self, StepShape_EdgeBasedWireframeModel thePtr) -> Handle_StepShape_EdgeBasedWireframeModel
        assign(Handle_StepShape_EdgeBasedWireframeModel self, Handle_StepShape_EdgeBasedWireframeModel theHandle) -> Handle_StepShape_EdgeBasedWireframeModel

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepShape.Handle_StepShape_EdgeBasedWireframeModel_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepShape_EdgeBasedWireframeModel self) -> StepShape_EdgeBasedWireframeModel

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepShape.Handle_StepShape_EdgeBasedWireframeModel_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepShape_EdgeBasedWireframeModel self) -> StepShape_EdgeBasedWireframeModel

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepShape.Handle_StepShape_EdgeBasedWireframeModel___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepShape_EdgeBasedWireframeModel self) -> StepShape_EdgeBasedWireframeModel

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepShape.Handle_StepShape_EdgeBasedWireframeModel___ref__(self, *args)


    def __hash__(self):
        return _StepShape.Handle_StepShape_EdgeBasedWireframeModel___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepShape.Handle_StepShape_EdgeBasedWireframeModel___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepShape.new_Handle_StepShape_EdgeBasedWireframeModel(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepShape.Handle_StepShape_EdgeBasedWireframeModel_DownCast)
    __swig_destroy__ = _StepShape.delete_Handle_StepShape_EdgeBasedWireframeModel

    def Init(self, *args):
        """
        Init(Handle_StepShape_EdgeBasedWireframeModel self, Handle_TCollection_HAsciiString aRepresentationItem_Name, Handle_StepShape_HArray1OfConnectedEdgeSet aEbwmBoundary)

        Initialize all fields (own and inherited)

        :type aRepresentationItem_Name: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aEbwmBoundary: OCC.wrapper.StepShape.Handle_StepShape_HArray1OfConnectedEdgeSet

        """
        return _StepShape.Handle_StepShape_EdgeBasedWireframeModel_Init(self, *args)


    def EbwmBoundary(self, *args):
        """
        EbwmBoundary(Handle_StepShape_EdgeBasedWireframeModel self) -> Handle_StepShape_HArray1OfConnectedEdgeSet

        Returns field EbwmBoundary

        :rtype: OCC.wrapper.StepShape.Handle_StepShape_HArray1OfConnectedEdgeSet

        """
        return _StepShape.Handle_StepShape_EdgeBasedWireframeModel_EbwmBoundary(self, *args)


    def SetEbwmBoundary(self, *args):
        """
        SetEbwmBoundary(Handle_StepShape_EdgeBasedWireframeModel self, Handle_StepShape_HArray1OfConnectedEdgeSet EbwmBoundary)

        Set field EbwmBoundary

        :type EbwmBoundary: OCC.wrapper.StepShape.Handle_StepShape_HArray1OfConnectedEdgeSet

        """
        return _StepShape.Handle_StepShape_EdgeBasedWireframeModel_SetEbwmBoundary(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepShape_EdgeBasedWireframeModel self) -> char const *

        :rtype: const char *

        """
        return _StepShape.Handle_StepShape_EdgeBasedWireframeModel_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.Handle_StepShape_EdgeBasedWireframeModel_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.Handle_StepShape_EdgeBasedWireframeModel_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetName(self, *args):
        """
        SetName(Handle_StepShape_EdgeBasedWireframeModel self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepShape.Handle_StepShape_EdgeBasedWireframeModel_SetName(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepShape_EdgeBasedWireframeModel self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepShape.Handle_StepShape_EdgeBasedWireframeModel_Name(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepShape_EdgeBasedWireframeModel self)

        Memory deallocator for transient classes


        """
        return _StepShape.Handle_StepShape_EdgeBasedWireframeModel_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepShape_EdgeBasedWireframeModel self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepShape_EdgeBasedWireframeModel self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.Handle_StepShape_EdgeBasedWireframeModel_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepShape_EdgeBasedWireframeModel self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepShape_EdgeBasedWireframeModel self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.Handle_StepShape_EdgeBasedWireframeModel_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepShape_EdgeBasedWireframeModel self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepShape.Handle_StepShape_EdgeBasedWireframeModel_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepShape_EdgeBasedWireframeModel self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_EdgeBasedWireframeModel_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepShape_EdgeBasedWireframeModel self)

        Increments the reference counter of this object


        """
        return _StepShape.Handle_StepShape_EdgeBasedWireframeModel_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepShape_EdgeBasedWireframeModel self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_EdgeBasedWireframeModel_DecrementRefCounter(self, *args)

Handle_StepShape_EdgeBasedWireframeModel_swigregister = _StepShape.Handle_StepShape_EdgeBasedWireframeModel_swigregister
Handle_StepShape_EdgeBasedWireframeModel_swigregister(Handle_StepShape_EdgeBasedWireframeModel)

def Handle_StepShape_EdgeBasedWireframeModel_DownCast(thing):
    return _StepShape.Handle_StepShape_EdgeBasedWireframeModel_DownCast(thing)
Handle_StepShape_EdgeBasedWireframeModel_DownCast = _StepShape.Handle_StepShape_EdgeBasedWireframeModel_DownCast

class Handle_StepShape_TypeQualifier(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepShape_TypeQualifier self)

        Nullify the handle


        """
        return _StepShape.Handle_StepShape_TypeQualifier_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepShape_TypeQualifier self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepShape.Handle_StepShape_TypeQualifier_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepShape_TypeQualifier self, StepShape_TypeQualifier thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepShape.Handle_StepShape_TypeQualifier_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepShape_TypeQualifier self, Handle_StepShape_TypeQualifier theHandle) -> Handle_StepShape_TypeQualifier
        assign(Handle_StepShape_TypeQualifier self, StepShape_TypeQualifier thePtr) -> Handle_StepShape_TypeQualifier
        assign(Handle_StepShape_TypeQualifier self, Handle_StepShape_TypeQualifier theHandle) -> Handle_StepShape_TypeQualifier

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepShape.Handle_StepShape_TypeQualifier_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepShape_TypeQualifier self) -> StepShape_TypeQualifier

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepShape.Handle_StepShape_TypeQualifier_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepShape_TypeQualifier self) -> StepShape_TypeQualifier

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepShape.Handle_StepShape_TypeQualifier___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepShape_TypeQualifier self) -> StepShape_TypeQualifier

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepShape.Handle_StepShape_TypeQualifier___ref__(self, *args)


    def __hash__(self):
        return _StepShape.Handle_StepShape_TypeQualifier___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepShape.Handle_StepShape_TypeQualifier___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepShape.new_Handle_StepShape_TypeQualifier(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepShape.Handle_StepShape_TypeQualifier_DownCast)
    __swig_destroy__ = _StepShape.delete_Handle_StepShape_TypeQualifier

    def Init(self, *args):
        """
        Init(Handle_StepShape_TypeQualifier self, Handle_TCollection_HAsciiString name)

        :type name: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepShape.Handle_StepShape_TypeQualifier_Init(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepShape_TypeQualifier self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepShape.Handle_StepShape_TypeQualifier_Name(self, *args)


    def SetName(self, *args):
        """
        SetName(Handle_StepShape_TypeQualifier self, Handle_TCollection_HAsciiString name)

        :type name: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepShape.Handle_StepShape_TypeQualifier_SetName(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepShape_TypeQualifier self) -> char const *

        :rtype: const char *

        """
        return _StepShape.Handle_StepShape_TypeQualifier_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.Handle_StepShape_TypeQualifier_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.Handle_StepShape_TypeQualifier_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_StepShape_TypeQualifier self)

        Memory deallocator for transient classes


        """
        return _StepShape.Handle_StepShape_TypeQualifier_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepShape_TypeQualifier self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepShape_TypeQualifier self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.Handle_StepShape_TypeQualifier_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepShape_TypeQualifier self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepShape_TypeQualifier self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.Handle_StepShape_TypeQualifier_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepShape_TypeQualifier self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepShape.Handle_StepShape_TypeQualifier_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepShape_TypeQualifier self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_TypeQualifier_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepShape_TypeQualifier self)

        Increments the reference counter of this object


        """
        return _StepShape.Handle_StepShape_TypeQualifier_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepShape_TypeQualifier self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_TypeQualifier_DecrementRefCounter(self, *args)

Handle_StepShape_TypeQualifier_swigregister = _StepShape.Handle_StepShape_TypeQualifier_swigregister
Handle_StepShape_TypeQualifier_swigregister(Handle_StepShape_TypeQualifier)

def Handle_StepShape_TypeQualifier_DownCast(thing):
    return _StepShape.Handle_StepShape_TypeQualifier_DownCast(thing)
Handle_StepShape_TypeQualifier_DownCast = _StepShape.Handle_StepShape_TypeQualifier_DownCast

class Handle_StepShape_AdvancedBrepShapeRepresentation(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepShape_AdvancedBrepShapeRepresentation self)

        Nullify the handle


        """
        return _StepShape.Handle_StepShape_AdvancedBrepShapeRepresentation_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepShape_AdvancedBrepShapeRepresentation self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepShape.Handle_StepShape_AdvancedBrepShapeRepresentation_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepShape_AdvancedBrepShapeRepresentation self, StepShape_AdvancedBrepShapeRepresentation thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepShape.Handle_StepShape_AdvancedBrepShapeRepresentation_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepShape_AdvancedBrepShapeRepresentation self, Handle_StepShape_AdvancedBrepShapeRepresentation theHandle) -> Handle_StepShape_AdvancedBrepShapeRepresentation
        assign(Handle_StepShape_AdvancedBrepShapeRepresentation self, StepShape_AdvancedBrepShapeRepresentation thePtr) -> Handle_StepShape_AdvancedBrepShapeRepresentation
        assign(Handle_StepShape_AdvancedBrepShapeRepresentation self, Handle_StepShape_AdvancedBrepShapeRepresentation theHandle) -> Handle_StepShape_AdvancedBrepShapeRepresentation

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepShape.Handle_StepShape_AdvancedBrepShapeRepresentation_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepShape_AdvancedBrepShapeRepresentation self) -> StepShape_AdvancedBrepShapeRepresentation

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepShape.Handle_StepShape_AdvancedBrepShapeRepresentation_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepShape_AdvancedBrepShapeRepresentation self) -> StepShape_AdvancedBrepShapeRepresentation

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepShape.Handle_StepShape_AdvancedBrepShapeRepresentation___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepShape_AdvancedBrepShapeRepresentation self) -> StepShape_AdvancedBrepShapeRepresentation

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepShape.Handle_StepShape_AdvancedBrepShapeRepresentation___ref__(self, *args)


    def __hash__(self):
        return _StepShape.Handle_StepShape_AdvancedBrepShapeRepresentation___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepShape.Handle_StepShape_AdvancedBrepShapeRepresentation___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepShape.new_Handle_StepShape_AdvancedBrepShapeRepresentation(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepShape.Handle_StepShape_AdvancedBrepShapeRepresentation_DownCast)
    __swig_destroy__ = _StepShape.delete_Handle_StepShape_AdvancedBrepShapeRepresentation

    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepShape_AdvancedBrepShapeRepresentation self) -> char const *

        :rtype: const char *

        """
        return _StepShape.Handle_StepShape_AdvancedBrepShapeRepresentation_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.Handle_StepShape_AdvancedBrepShapeRepresentation_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.Handle_StepShape_AdvancedBrepShapeRepresentation_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Init(self, *args):
        """
        Init(Handle_StepShape_AdvancedBrepShapeRepresentation self, Handle_TCollection_HAsciiString aName, Handle_StepRepr_HArray1OfRepresentationItem aItems, Handle_StepRepr_RepresentationContext aContextOfItems)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aItems: OCC.wrapper.StepRepr.Handle_StepRepr_HArray1OfRepresentationItem
        :type aContextOfItems: OCC.wrapper.StepRepr.Handle_StepRepr_RepresentationContext

        """
        return _StepShape.Handle_StepShape_AdvancedBrepShapeRepresentation_Init(self, *args)


    def SetName(self, *args):
        """
        SetName(Handle_StepShape_AdvancedBrepShapeRepresentation self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepShape.Handle_StepShape_AdvancedBrepShapeRepresentation_SetName(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepShape_AdvancedBrepShapeRepresentation self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepShape.Handle_StepShape_AdvancedBrepShapeRepresentation_Name(self, *args)


    def SetItems(self, *args):
        """
        SetItems(Handle_StepShape_AdvancedBrepShapeRepresentation self, Handle_StepRepr_HArray1OfRepresentationItem aItems)

        :type aItems: OCC.wrapper.StepRepr.Handle_StepRepr_HArray1OfRepresentationItem

        """
        return _StepShape.Handle_StepShape_AdvancedBrepShapeRepresentation_SetItems(self, *args)


    def Items(self, *args):
        """
        Items(Handle_StepShape_AdvancedBrepShapeRepresentation self) -> Handle_StepRepr_HArray1OfRepresentationItem

        :rtype: OCC.wrapper.StepRepr.Handle_StepRepr_HArray1OfRepresentationItem

        """
        return _StepShape.Handle_StepShape_AdvancedBrepShapeRepresentation_Items(self, *args)


    def ItemsValue(self, *args):
        """
        ItemsValue(Handle_StepShape_AdvancedBrepShapeRepresentation self, Standard_Integer const num) -> Handle_StepRepr_RepresentationItem

        :type num: int
        :rtype: OCC.wrapper.StepRepr.Handle_StepRepr_RepresentationItem

        """
        return _StepShape.Handle_StepShape_AdvancedBrepShapeRepresentation_ItemsValue(self, *args)


    def NbItems(self, *args):
        """
        NbItems(Handle_StepShape_AdvancedBrepShapeRepresentation self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_AdvancedBrepShapeRepresentation_NbItems(self, *args)


    def SetContextOfItems(self, *args):
        """
        SetContextOfItems(Handle_StepShape_AdvancedBrepShapeRepresentation self, Handle_StepRepr_RepresentationContext aContextOfItems)

        :type aContextOfItems: OCC.wrapper.StepRepr.Handle_StepRepr_RepresentationContext

        """
        return _StepShape.Handle_StepShape_AdvancedBrepShapeRepresentation_SetContextOfItems(self, *args)


    def ContextOfItems(self, *args):
        """
        ContextOfItems(Handle_StepShape_AdvancedBrepShapeRepresentation self) -> Handle_StepRepr_RepresentationContext

        :rtype: OCC.wrapper.StepRepr.Handle_StepRepr_RepresentationContext

        """
        return _StepShape.Handle_StepShape_AdvancedBrepShapeRepresentation_ContextOfItems(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepShape_AdvancedBrepShapeRepresentation self)

        Memory deallocator for transient classes


        """
        return _StepShape.Handle_StepShape_AdvancedBrepShapeRepresentation_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepShape_AdvancedBrepShapeRepresentation self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepShape_AdvancedBrepShapeRepresentation self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.Handle_StepShape_AdvancedBrepShapeRepresentation_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepShape_AdvancedBrepShapeRepresentation self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepShape_AdvancedBrepShapeRepresentation self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.Handle_StepShape_AdvancedBrepShapeRepresentation_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepShape_AdvancedBrepShapeRepresentation self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepShape.Handle_StepShape_AdvancedBrepShapeRepresentation_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepShape_AdvancedBrepShapeRepresentation self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_AdvancedBrepShapeRepresentation_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepShape_AdvancedBrepShapeRepresentation self)

        Increments the reference counter of this object


        """
        return _StepShape.Handle_StepShape_AdvancedBrepShapeRepresentation_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepShape_AdvancedBrepShapeRepresentation self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_AdvancedBrepShapeRepresentation_DecrementRefCounter(self, *args)

Handle_StepShape_AdvancedBrepShapeRepresentation_swigregister = _StepShape.Handle_StepShape_AdvancedBrepShapeRepresentation_swigregister
Handle_StepShape_AdvancedBrepShapeRepresentation_swigregister(Handle_StepShape_AdvancedBrepShapeRepresentation)

def Handle_StepShape_AdvancedBrepShapeRepresentation_DownCast(thing):
    return _StepShape.Handle_StepShape_AdvancedBrepShapeRepresentation_DownCast(thing)
Handle_StepShape_AdvancedBrepShapeRepresentation_DownCast = _StepShape.Handle_StepShape_AdvancedBrepShapeRepresentation_DownCast

class StepShape_FaceBasedSurfaceModel(StepGeom.StepGeom_GeometricRepresentationItem):
    """Representation of STEP entity FaceBasedSurfaceModel"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepShape_FaceBasedSurfaceModel
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepShape_FaceBasedSurfaceModel(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepShape_FaceBasedSurfaceModel self) -> StepShape_FaceBasedSurfaceModel

        Empty constructor


        """
        this = _StepShape.new_StepShape_FaceBasedSurfaceModel(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepShape_FaceBasedSurfaceModel self, Handle_TCollection_HAsciiString aRepresentationItem_Name, Handle_StepShape_HArray1OfConnectedFaceSet aFbsmFaces)

        Initialize all fields (own and inherited)

        :type aRepresentationItem_Name: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aFbsmFaces: OCC.wrapper.StepShape.Handle_StepShape_HArray1OfConnectedFaceSet

        """
        return _StepShape.StepShape_FaceBasedSurfaceModel_Init(self, *args)


    def FbsmFaces(self, *args):
        """
        FbsmFaces(StepShape_FaceBasedSurfaceModel self) -> Handle_StepShape_HArray1OfConnectedFaceSet

        Returns field FbsmFaces

        :rtype: OCC.wrapper.StepShape.Handle_StepShape_HArray1OfConnectedFaceSet

        """
        return _StepShape.StepShape_FaceBasedSurfaceModel_FbsmFaces(self, *args)


    def SetFbsmFaces(self, *args):
        """
        SetFbsmFaces(StepShape_FaceBasedSurfaceModel self, Handle_StepShape_HArray1OfConnectedFaceSet FbsmFaces)

        Set field FbsmFaces

        :type FbsmFaces: OCC.wrapper.StepShape.Handle_StepShape_HArray1OfConnectedFaceSet

        """
        return _StepShape.StepShape_FaceBasedSurfaceModel_SetFbsmFaces(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepShape.StepShape_FaceBasedSurfaceModel_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepShape.StepShape_FaceBasedSurfaceModel_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.StepShape_FaceBasedSurfaceModel_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepShape.delete_StepShape_FaceBasedSurfaceModel
StepShape_FaceBasedSurfaceModel_swigregister = _StepShape.StepShape_FaceBasedSurfaceModel_swigregister
StepShape_FaceBasedSurfaceModel_swigregister(StepShape_FaceBasedSurfaceModel)

def StepShape_FaceBasedSurfaceModel_get_type_name(*args):
    """
    StepShape_FaceBasedSurfaceModel_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepShape.StepShape_FaceBasedSurfaceModel_get_type_name(*args)

def StepShape_FaceBasedSurfaceModel_get_type_descriptor(*args):
    """
    StepShape_FaceBasedSurfaceModel_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepShape.StepShape_FaceBasedSurfaceModel_get_type_descriptor(*args)

class Handle_StepShape_OrientedFace(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepShape_OrientedFace self)

        Nullify the handle


        """
        return _StepShape.Handle_StepShape_OrientedFace_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepShape_OrientedFace self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepShape.Handle_StepShape_OrientedFace_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepShape_OrientedFace self, StepShape_OrientedFace thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepShape.Handle_StepShape_OrientedFace_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepShape_OrientedFace self, Handle_StepShape_OrientedFace theHandle) -> Handle_StepShape_OrientedFace
        assign(Handle_StepShape_OrientedFace self, StepShape_OrientedFace thePtr) -> Handle_StepShape_OrientedFace
        assign(Handle_StepShape_OrientedFace self, Handle_StepShape_OrientedFace theHandle) -> Handle_StepShape_OrientedFace

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepShape.Handle_StepShape_OrientedFace_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepShape_OrientedFace self) -> StepShape_OrientedFace

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepShape.Handle_StepShape_OrientedFace_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepShape_OrientedFace self) -> StepShape_OrientedFace

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepShape.Handle_StepShape_OrientedFace___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepShape_OrientedFace self) -> StepShape_OrientedFace

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepShape.Handle_StepShape_OrientedFace___ref__(self, *args)


    def __hash__(self):
        return _StepShape.Handle_StepShape_OrientedFace___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepShape.Handle_StepShape_OrientedFace___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepShape.new_Handle_StepShape_OrientedFace(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepShape.Handle_StepShape_OrientedFace_DownCast)
    __swig_destroy__ = _StepShape.delete_Handle_StepShape_OrientedFace

    def Init(self, *args):
        """
        Init(Handle_StepShape_OrientedFace self, Handle_TCollection_HAsciiString aName, Handle_StepShape_Face aFaceElement, Standard_Boolean const aOrientation)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aFaceElement: OCC.wrapper.StepShape.Handle_StepShape_Face
        :type aOrientation: bool

        """
        return _StepShape.Handle_StepShape_OrientedFace_Init(self, *args)


    def SetFaceElement(self, *args):
        """
        SetFaceElement(Handle_StepShape_OrientedFace self, Handle_StepShape_Face aFaceElement)

        :type aFaceElement: OCC.wrapper.StepShape.Handle_StepShape_Face

        """
        return _StepShape.Handle_StepShape_OrientedFace_SetFaceElement(self, *args)


    def FaceElement(self, *args):
        """
        FaceElement(Handle_StepShape_OrientedFace self) -> Handle_StepShape_Face

        :rtype: OCC.wrapper.StepShape.Handle_StepShape_Face

        """
        return _StepShape.Handle_StepShape_OrientedFace_FaceElement(self, *args)


    def SetOrientation(self, *args):
        """
        SetOrientation(Handle_StepShape_OrientedFace self, Standard_Boolean const aOrientation)

        :type aOrientation: bool

        """
        return _StepShape.Handle_StepShape_OrientedFace_SetOrientation(self, *args)


    def Orientation(self, *args):
        """
        Orientation(Handle_StepShape_OrientedFace self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.Handle_StepShape_OrientedFace_Orientation(self, *args)


    def SetBounds(self, *args):
        """
        SetBounds(Handle_StepShape_OrientedFace self, Handle_StepShape_HArray1OfFaceBound aBounds)

        :type aBounds: OCC.wrapper.StepShape.Handle_StepShape_HArray1OfFaceBound

        """
        return _StepShape.Handle_StepShape_OrientedFace_SetBounds(self, *args)


    def Bounds(self, *args):
        """
        Bounds(Handle_StepShape_OrientedFace self) -> Handle_StepShape_HArray1OfFaceBound

        :rtype: OCC.wrapper.StepShape.Handle_StepShape_HArray1OfFaceBound

        """
        return _StepShape.Handle_StepShape_OrientedFace_Bounds(self, *args)


    def BoundsValue(self, *args):
        """
        BoundsValue(Handle_StepShape_OrientedFace self, Standard_Integer const num) -> Handle_StepShape_FaceBound

        :type num: int
        :rtype: OCC.wrapper.StepShape.Handle_StepShape_FaceBound

        """
        return _StepShape.Handle_StepShape_OrientedFace_BoundsValue(self, *args)


    def NbBounds(self, *args):
        """
        NbBounds(Handle_StepShape_OrientedFace self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_OrientedFace_NbBounds(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepShape_OrientedFace self) -> char const *

        :rtype: const char *

        """
        return _StepShape.Handle_StepShape_OrientedFace_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.Handle_StepShape_OrientedFace_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.Handle_StepShape_OrientedFace_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetName(self, *args):
        """
        SetName(Handle_StepShape_OrientedFace self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepShape.Handle_StepShape_OrientedFace_SetName(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepShape_OrientedFace self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepShape.Handle_StepShape_OrientedFace_Name(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepShape_OrientedFace self)

        Memory deallocator for transient classes


        """
        return _StepShape.Handle_StepShape_OrientedFace_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepShape_OrientedFace self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepShape_OrientedFace self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.Handle_StepShape_OrientedFace_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepShape_OrientedFace self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepShape_OrientedFace self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.Handle_StepShape_OrientedFace_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepShape_OrientedFace self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepShape.Handle_StepShape_OrientedFace_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepShape_OrientedFace self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_OrientedFace_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepShape_OrientedFace self)

        Increments the reference counter of this object


        """
        return _StepShape.Handle_StepShape_OrientedFace_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepShape_OrientedFace self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_OrientedFace_DecrementRefCounter(self, *args)

Handle_StepShape_OrientedFace_swigregister = _StepShape.Handle_StepShape_OrientedFace_swigregister
Handle_StepShape_OrientedFace_swigregister(Handle_StepShape_OrientedFace)

def Handle_StepShape_OrientedFace_DownCast(thing):
    return _StepShape.Handle_StepShape_OrientedFace_DownCast(thing)
Handle_StepShape_OrientedFace_DownCast = _StepShape.Handle_StepShape_OrientedFace_DownCast

class Handle_StepShape_Subface(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepShape_Subface self)

        Nullify the handle


        """
        return _StepShape.Handle_StepShape_Subface_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepShape_Subface self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepShape.Handle_StepShape_Subface_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepShape_Subface self, StepShape_Subface thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepShape.Handle_StepShape_Subface_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepShape_Subface self, Handle_StepShape_Subface theHandle) -> Handle_StepShape_Subface
        assign(Handle_StepShape_Subface self, StepShape_Subface thePtr) -> Handle_StepShape_Subface
        assign(Handle_StepShape_Subface self, Handle_StepShape_Subface theHandle) -> Handle_StepShape_Subface

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepShape.Handle_StepShape_Subface_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepShape_Subface self) -> StepShape_Subface

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepShape.Handle_StepShape_Subface_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepShape_Subface self) -> StepShape_Subface

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepShape.Handle_StepShape_Subface___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepShape_Subface self) -> StepShape_Subface

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepShape.Handle_StepShape_Subface___ref__(self, *args)


    def __hash__(self):
        return _StepShape.Handle_StepShape_Subface___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepShape.Handle_StepShape_Subface___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepShape.new_Handle_StepShape_Subface(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepShape.Handle_StepShape_Subface_DownCast)
    __swig_destroy__ = _StepShape.delete_Handle_StepShape_Subface

    def Init(self, *args):
        """
        Init(Handle_StepShape_Subface self, Handle_TCollection_HAsciiString aRepresentationItem_Name, Handle_StepShape_HArray1OfFaceBound aFace_Bounds, Handle_StepShape_Face aParentFace)

        Initialize all fields (own and inherited)

        :type aRepresentationItem_Name: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aFace_Bounds: OCC.wrapper.StepShape.Handle_StepShape_HArray1OfFaceBound
        :type aParentFace: OCC.wrapper.StepShape.Handle_StepShape_Face

        """
        return _StepShape.Handle_StepShape_Subface_Init(self, *args)


    def ParentFace(self, *args):
        """
        ParentFace(Handle_StepShape_Subface self) -> Handle_StepShape_Face

        Returns field ParentFace

        :rtype: OCC.wrapper.StepShape.Handle_StepShape_Face

        """
        return _StepShape.Handle_StepShape_Subface_ParentFace(self, *args)


    def SetParentFace(self, *args):
        """
        SetParentFace(Handle_StepShape_Subface self, Handle_StepShape_Face ParentFace)

        Set field ParentFace

        :type ParentFace: OCC.wrapper.StepShape.Handle_StepShape_Face

        """
        return _StepShape.Handle_StepShape_Subface_SetParentFace(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepShape_Subface self) -> char const *

        :rtype: const char *

        """
        return _StepShape.Handle_StepShape_Subface_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.Handle_StepShape_Subface_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.Handle_StepShape_Subface_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetBounds(self, *args):
        """
        SetBounds(Handle_StepShape_Subface self, Handle_StepShape_HArray1OfFaceBound aBounds)

        :type aBounds: OCC.wrapper.StepShape.Handle_StepShape_HArray1OfFaceBound

        """
        return _StepShape.Handle_StepShape_Subface_SetBounds(self, *args)


    def Bounds(self, *args):
        """
        Bounds(Handle_StepShape_Subface self) -> Handle_StepShape_HArray1OfFaceBound

        :rtype: OCC.wrapper.StepShape.Handle_StepShape_HArray1OfFaceBound

        """
        return _StepShape.Handle_StepShape_Subface_Bounds(self, *args)


    def BoundsValue(self, *args):
        """
        BoundsValue(Handle_StepShape_Subface self, Standard_Integer const num) -> Handle_StepShape_FaceBound

        :type num: int
        :rtype: OCC.wrapper.StepShape.Handle_StepShape_FaceBound

        """
        return _StepShape.Handle_StepShape_Subface_BoundsValue(self, *args)


    def NbBounds(self, *args):
        """
        NbBounds(Handle_StepShape_Subface self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_Subface_NbBounds(self, *args)


    def SetName(self, *args):
        """
        SetName(Handle_StepShape_Subface self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepShape.Handle_StepShape_Subface_SetName(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepShape_Subface self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepShape.Handle_StepShape_Subface_Name(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepShape_Subface self)

        Memory deallocator for transient classes


        """
        return _StepShape.Handle_StepShape_Subface_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepShape_Subface self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepShape_Subface self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.Handle_StepShape_Subface_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepShape_Subface self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepShape_Subface self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.Handle_StepShape_Subface_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepShape_Subface self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepShape.Handle_StepShape_Subface_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepShape_Subface self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_Subface_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepShape_Subface self)

        Increments the reference counter of this object


        """
        return _StepShape.Handle_StepShape_Subface_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepShape_Subface self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_Subface_DecrementRefCounter(self, *args)

Handle_StepShape_Subface_swigregister = _StepShape.Handle_StepShape_Subface_swigregister
Handle_StepShape_Subface_swigregister(Handle_StepShape_Subface)

def Handle_StepShape_Subface_DownCast(thing):
    return _StepShape.Handle_StepShape_Subface_DownCast(thing)
Handle_StepShape_Subface_DownCast = _StepShape.Handle_StepShape_Subface_DownCast

class StepShape_HArray1OfShell(Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepShape_HArray1OfShell
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepShape_HArray1OfShell(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepShape_HArray1OfShell self, Standard_Integer const theLower, Standard_Integer const theUpper) -> StepShape_HArray1OfShell
        __init__(StepShape_HArray1OfShell self, Standard_Integer const theLower, Standard_Integer const theUpper, StepShape_Shell theValue) -> StepShape_HArray1OfShell
        __init__(StepShape_HArray1OfShell self, NCollection_Array1_StepShape_Shell theOther) -> StepShape_HArray1OfShell

        :type theOther: OCC.wrapper.StepShape.StepShape_Array1OfShell

        """
        this = _StepShape.new_StepShape_HArray1OfShell(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Array1(self, *args):
        """
        :rtype: OCC.wrapper.StepShape.StepShape_Array1OfShell

        """
        res = _StepShape.StepShape_HArray1OfShell_Array1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeArray1(self, *args):
        """
        ChangeArray1(StepShape_HArray1OfShell self) -> NCollection_Array1_StepShape_Shell

        :rtype: OCC.wrapper.StepShape.StepShape_Array1OfShell

        """
        return _StepShape.StepShape_HArray1OfShell_ChangeArray1(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepShape.StepShape_HArray1OfShell_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepShape.StepShape_HArray1OfShell_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.StepShape_HArray1OfShell_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepShape.delete_StepShape_HArray1OfShell
StepShape_HArray1OfShell_swigregister = _StepShape.StepShape_HArray1OfShell_swigregister
StepShape_HArray1OfShell_swigregister(StepShape_HArray1OfShell)

def StepShape_HArray1OfShell_get_type_name(*args):
    """
    StepShape_HArray1OfShell_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepShape.StepShape_HArray1OfShell_get_type_name(*args)

def StepShape_HArray1OfShell_get_type_descriptor(*args):
    """
    StepShape_HArray1OfShell_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepShape.StepShape_HArray1OfShell_get_type_descriptor(*args)

class StepShape_ValueFormatTypeQualifier(Standard.Standard_Transient):
    """Added for Dimensional Tolerances"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepShape_ValueFormatTypeQualifier
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepShape_ValueFormatTypeQualifier(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepShape_ValueFormatTypeQualifier self) -> StepShape_ValueFormatTypeQualifier

        Added for Dimensional Tolerances
        """
        this = _StepShape.new_StepShape_ValueFormatTypeQualifier(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepShape_ValueFormatTypeQualifier self, Handle_TCollection_HAsciiString theFormatType)

        Init all field own and inherited

        :type theFormatType: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepShape.StepShape_ValueFormatTypeQualifier_Init(self, *args)


    def FormatType(self, *args):
        """
        FormatType(StepShape_ValueFormatTypeQualifier self) -> Handle_TCollection_HAsciiString

        Returns field FormatType

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepShape.StepShape_ValueFormatTypeQualifier_FormatType(self, *args)


    def SetFormatType(self, *args):
        """
        SetFormatType(StepShape_ValueFormatTypeQualifier self, Handle_TCollection_HAsciiString theFormatType)

        Set field FormatType

        :type theFormatType: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepShape.StepShape_ValueFormatTypeQualifier_SetFormatType(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepShape.StepShape_ValueFormatTypeQualifier_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepShape.StepShape_ValueFormatTypeQualifier_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.StepShape_ValueFormatTypeQualifier_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepShape.delete_StepShape_ValueFormatTypeQualifier
StepShape_ValueFormatTypeQualifier_swigregister = _StepShape.StepShape_ValueFormatTypeQualifier_swigregister
StepShape_ValueFormatTypeQualifier_swigregister(StepShape_ValueFormatTypeQualifier)

def StepShape_ValueFormatTypeQualifier_get_type_name(*args):
    """
    StepShape_ValueFormatTypeQualifier_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepShape.StepShape_ValueFormatTypeQualifier_get_type_name(*args)

def StepShape_ValueFormatTypeQualifier_get_type_descriptor(*args):
    """
    StepShape_ValueFormatTypeQualifier_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepShape.StepShape_ValueFormatTypeQualifier_get_type_descriptor(*args)

class StepShape_VertexPoint(StepShape_Vertex):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepShape_VertexPoint
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepShape_VertexPoint(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepShape_VertexPoint self) -> StepShape_VertexPoint

        Returns a VertexPoint


        """
        this = _StepShape.new_StepShape_VertexPoint(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepShape_VertexPoint self, Handle_TCollection_HAsciiString aName, Handle_StepGeom_Point aVertexGeometry)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aVertexGeometry: OCC.wrapper.StepShape.Handle_StepGeom_Point

        """
        return _StepShape.StepShape_VertexPoint_Init(self, *args)


    def SetVertexGeometry(self, *args):
        """
        SetVertexGeometry(StepShape_VertexPoint self, Handle_StepGeom_Point aVertexGeometry)

        :type aVertexGeometry: OCC.wrapper.StepShape.Handle_StepGeom_Point

        """
        return _StepShape.StepShape_VertexPoint_SetVertexGeometry(self, *args)


    def VertexGeometry(self, *args):
        """
        VertexGeometry(StepShape_VertexPoint self) -> Handle_StepGeom_Point

        :rtype: OCC.wrapper.StepShape.Handle_StepGeom_Point

        """
        return _StepShape.StepShape_VertexPoint_VertexGeometry(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepShape.StepShape_VertexPoint_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepShape.StepShape_VertexPoint_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.StepShape_VertexPoint_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepShape.delete_StepShape_VertexPoint
StepShape_VertexPoint_swigregister = _StepShape.StepShape_VertexPoint_swigregister
StepShape_VertexPoint_swigregister(StepShape_VertexPoint)

def StepShape_VertexPoint_get_type_name(*args):
    """
    StepShape_VertexPoint_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepShape.StepShape_VertexPoint_get_type_name(*args)

def StepShape_VertexPoint_get_type_descriptor(*args):
    """
    StepShape_VertexPoint_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepShape.StepShape_VertexPoint_get_type_descriptor(*args)

class Handle_StepShape_ManifoldSurfaceShapeRepresentation(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepShape_ManifoldSurfaceShapeRepresentation self)

        Nullify the handle


        """
        return _StepShape.Handle_StepShape_ManifoldSurfaceShapeRepresentation_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepShape_ManifoldSurfaceShapeRepresentation self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepShape.Handle_StepShape_ManifoldSurfaceShapeRepresentation_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepShape_ManifoldSurfaceShapeRepresentation self, StepShape_ManifoldSurfaceShapeRepresentation thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepShape.Handle_StepShape_ManifoldSurfaceShapeRepresentation_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepShape_ManifoldSurfaceShapeRepresentation self, Handle_StepShape_ManifoldSurfaceShapeRepresentation theHandle) -> Handle_StepShape_ManifoldSurfaceShapeRepresentation
        assign(Handle_StepShape_ManifoldSurfaceShapeRepresentation self, StepShape_ManifoldSurfaceShapeRepresentation thePtr) -> Handle_StepShape_ManifoldSurfaceShapeRepresentation
        assign(Handle_StepShape_ManifoldSurfaceShapeRepresentation self, Handle_StepShape_ManifoldSurfaceShapeRepresentation theHandle) -> Handle_StepShape_ManifoldSurfaceShapeRepresentation

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepShape.Handle_StepShape_ManifoldSurfaceShapeRepresentation_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepShape_ManifoldSurfaceShapeRepresentation self) -> StepShape_ManifoldSurfaceShapeRepresentation

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepShape.Handle_StepShape_ManifoldSurfaceShapeRepresentation_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepShape_ManifoldSurfaceShapeRepresentation self) -> StepShape_ManifoldSurfaceShapeRepresentation

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepShape.Handle_StepShape_ManifoldSurfaceShapeRepresentation___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepShape_ManifoldSurfaceShapeRepresentation self) -> StepShape_ManifoldSurfaceShapeRepresentation

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepShape.Handle_StepShape_ManifoldSurfaceShapeRepresentation___ref__(self, *args)


    def __hash__(self):
        return _StepShape.Handle_StepShape_ManifoldSurfaceShapeRepresentation___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepShape.Handle_StepShape_ManifoldSurfaceShapeRepresentation___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepShape.new_Handle_StepShape_ManifoldSurfaceShapeRepresentation(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepShape.Handle_StepShape_ManifoldSurfaceShapeRepresentation_DownCast)
    __swig_destroy__ = _StepShape.delete_Handle_StepShape_ManifoldSurfaceShapeRepresentation

    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepShape_ManifoldSurfaceShapeRepresentation self) -> char const *

        :rtype: const char *

        """
        return _StepShape.Handle_StepShape_ManifoldSurfaceShapeRepresentation_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.Handle_StepShape_ManifoldSurfaceShapeRepresentation_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.Handle_StepShape_ManifoldSurfaceShapeRepresentation_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Init(self, *args):
        """
        Init(Handle_StepShape_ManifoldSurfaceShapeRepresentation self, Handle_TCollection_HAsciiString aName, Handle_StepRepr_HArray1OfRepresentationItem aItems, Handle_StepRepr_RepresentationContext aContextOfItems)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aItems: OCC.wrapper.StepRepr.Handle_StepRepr_HArray1OfRepresentationItem
        :type aContextOfItems: OCC.wrapper.StepRepr.Handle_StepRepr_RepresentationContext

        """
        return _StepShape.Handle_StepShape_ManifoldSurfaceShapeRepresentation_Init(self, *args)


    def SetName(self, *args):
        """
        SetName(Handle_StepShape_ManifoldSurfaceShapeRepresentation self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepShape.Handle_StepShape_ManifoldSurfaceShapeRepresentation_SetName(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepShape_ManifoldSurfaceShapeRepresentation self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepShape.Handle_StepShape_ManifoldSurfaceShapeRepresentation_Name(self, *args)


    def SetItems(self, *args):
        """
        SetItems(Handle_StepShape_ManifoldSurfaceShapeRepresentation self, Handle_StepRepr_HArray1OfRepresentationItem aItems)

        :type aItems: OCC.wrapper.StepRepr.Handle_StepRepr_HArray1OfRepresentationItem

        """
        return _StepShape.Handle_StepShape_ManifoldSurfaceShapeRepresentation_SetItems(self, *args)


    def Items(self, *args):
        """
        Items(Handle_StepShape_ManifoldSurfaceShapeRepresentation self) -> Handle_StepRepr_HArray1OfRepresentationItem

        :rtype: OCC.wrapper.StepRepr.Handle_StepRepr_HArray1OfRepresentationItem

        """
        return _StepShape.Handle_StepShape_ManifoldSurfaceShapeRepresentation_Items(self, *args)


    def ItemsValue(self, *args):
        """
        ItemsValue(Handle_StepShape_ManifoldSurfaceShapeRepresentation self, Standard_Integer const num) -> Handle_StepRepr_RepresentationItem

        :type num: int
        :rtype: OCC.wrapper.StepRepr.Handle_StepRepr_RepresentationItem

        """
        return _StepShape.Handle_StepShape_ManifoldSurfaceShapeRepresentation_ItemsValue(self, *args)


    def NbItems(self, *args):
        """
        NbItems(Handle_StepShape_ManifoldSurfaceShapeRepresentation self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_ManifoldSurfaceShapeRepresentation_NbItems(self, *args)


    def SetContextOfItems(self, *args):
        """
        SetContextOfItems(Handle_StepShape_ManifoldSurfaceShapeRepresentation self, Handle_StepRepr_RepresentationContext aContextOfItems)

        :type aContextOfItems: OCC.wrapper.StepRepr.Handle_StepRepr_RepresentationContext

        """
        return _StepShape.Handle_StepShape_ManifoldSurfaceShapeRepresentation_SetContextOfItems(self, *args)


    def ContextOfItems(self, *args):
        """
        ContextOfItems(Handle_StepShape_ManifoldSurfaceShapeRepresentation self) -> Handle_StepRepr_RepresentationContext

        :rtype: OCC.wrapper.StepRepr.Handle_StepRepr_RepresentationContext

        """
        return _StepShape.Handle_StepShape_ManifoldSurfaceShapeRepresentation_ContextOfItems(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepShape_ManifoldSurfaceShapeRepresentation self)

        Memory deallocator for transient classes


        """
        return _StepShape.Handle_StepShape_ManifoldSurfaceShapeRepresentation_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepShape_ManifoldSurfaceShapeRepresentation self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepShape_ManifoldSurfaceShapeRepresentation self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.Handle_StepShape_ManifoldSurfaceShapeRepresentation_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepShape_ManifoldSurfaceShapeRepresentation self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepShape_ManifoldSurfaceShapeRepresentation self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.Handle_StepShape_ManifoldSurfaceShapeRepresentation_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepShape_ManifoldSurfaceShapeRepresentation self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepShape.Handle_StepShape_ManifoldSurfaceShapeRepresentation_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepShape_ManifoldSurfaceShapeRepresentation self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_ManifoldSurfaceShapeRepresentation_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepShape_ManifoldSurfaceShapeRepresentation self)

        Increments the reference counter of this object


        """
        return _StepShape.Handle_StepShape_ManifoldSurfaceShapeRepresentation_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepShape_ManifoldSurfaceShapeRepresentation self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_ManifoldSurfaceShapeRepresentation_DecrementRefCounter(self, *args)

Handle_StepShape_ManifoldSurfaceShapeRepresentation_swigregister = _StepShape.Handle_StepShape_ManifoldSurfaceShapeRepresentation_swigregister
Handle_StepShape_ManifoldSurfaceShapeRepresentation_swigregister(Handle_StepShape_ManifoldSurfaceShapeRepresentation)

def Handle_StepShape_ManifoldSurfaceShapeRepresentation_DownCast(thing):
    return _StepShape.Handle_StepShape_ManifoldSurfaceShapeRepresentation_DownCast(thing)
Handle_StepShape_ManifoldSurfaceShapeRepresentation_DownCast = _StepShape.Handle_StepShape_ManifoldSurfaceShapeRepresentation_DownCast

class Handle_StepShape_HArray1OfConnectedEdgeSet(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepShape_HArray1OfConnectedEdgeSet self)

        Nullify the handle


        """
        return _StepShape.Handle_StepShape_HArray1OfConnectedEdgeSet_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepShape_HArray1OfConnectedEdgeSet self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepShape.Handle_StepShape_HArray1OfConnectedEdgeSet_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepShape_HArray1OfConnectedEdgeSet self, StepShape_HArray1OfConnectedEdgeSet thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepShape.Handle_StepShape_HArray1OfConnectedEdgeSet_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepShape_HArray1OfConnectedEdgeSet self, Handle_StepShape_HArray1OfConnectedEdgeSet theHandle) -> Handle_StepShape_HArray1OfConnectedEdgeSet
        assign(Handle_StepShape_HArray1OfConnectedEdgeSet self, StepShape_HArray1OfConnectedEdgeSet thePtr) -> Handle_StepShape_HArray1OfConnectedEdgeSet
        assign(Handle_StepShape_HArray1OfConnectedEdgeSet self, Handle_StepShape_HArray1OfConnectedEdgeSet theHandle) -> Handle_StepShape_HArray1OfConnectedEdgeSet

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepShape.Handle_StepShape_HArray1OfConnectedEdgeSet_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepShape_HArray1OfConnectedEdgeSet self) -> StepShape_HArray1OfConnectedEdgeSet

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepShape.Handle_StepShape_HArray1OfConnectedEdgeSet_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepShape_HArray1OfConnectedEdgeSet self) -> StepShape_HArray1OfConnectedEdgeSet

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepShape.Handle_StepShape_HArray1OfConnectedEdgeSet___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepShape_HArray1OfConnectedEdgeSet self) -> StepShape_HArray1OfConnectedEdgeSet

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepShape.Handle_StepShape_HArray1OfConnectedEdgeSet___ref__(self, *args)


    def __hash__(self):
        return _StepShape.Handle_StepShape_HArray1OfConnectedEdgeSet___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepShape.Handle_StepShape_HArray1OfConnectedEdgeSet___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepShape.new_Handle_StepShape_HArray1OfConnectedEdgeSet(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepShape.Handle_StepShape_HArray1OfConnectedEdgeSet_DownCast)
    __swig_destroy__ = _StepShape.delete_Handle_StepShape_HArray1OfConnectedEdgeSet

    def Array1(self, *args):
        """
        :rtype: OCC.wrapper.StepShape.StepShape_Array1OfConnectedEdgeSet

        """
        res = _StepShape.Handle_StepShape_HArray1OfConnectedEdgeSet_Array1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeArray1(self, *args):
        """
        ChangeArray1(Handle_StepShape_HArray1OfConnectedEdgeSet self) -> NCollection_Array1_Handle_StepShape_ConnectedEdgeSet

        :rtype: OCC.wrapper.StepShape.StepShape_Array1OfConnectedEdgeSet

        """
        return _StepShape.Handle_StepShape_HArray1OfConnectedEdgeSet_ChangeArray1(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepShape_HArray1OfConnectedEdgeSet self) -> char const *

        :rtype: const char *

        """
        return _StepShape.Handle_StepShape_HArray1OfConnectedEdgeSet_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.Handle_StepShape_HArray1OfConnectedEdgeSet_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.Handle_StepShape_HArray1OfConnectedEdgeSet_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_StepShape_HArray1OfConnectedEdgeSet self)

        Memory deallocator for transient classes


        """
        return _StepShape.Handle_StepShape_HArray1OfConnectedEdgeSet_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepShape_HArray1OfConnectedEdgeSet self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepShape_HArray1OfConnectedEdgeSet self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.Handle_StepShape_HArray1OfConnectedEdgeSet_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepShape_HArray1OfConnectedEdgeSet self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepShape_HArray1OfConnectedEdgeSet self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.Handle_StepShape_HArray1OfConnectedEdgeSet_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepShape_HArray1OfConnectedEdgeSet self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepShape.Handle_StepShape_HArray1OfConnectedEdgeSet_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepShape_HArray1OfConnectedEdgeSet self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_HArray1OfConnectedEdgeSet_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepShape_HArray1OfConnectedEdgeSet self)

        Increments the reference counter of this object


        """
        return _StepShape.Handle_StepShape_HArray1OfConnectedEdgeSet_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepShape_HArray1OfConnectedEdgeSet self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_HArray1OfConnectedEdgeSet_DecrementRefCounter(self, *args)

Handle_StepShape_HArray1OfConnectedEdgeSet_swigregister = _StepShape.Handle_StepShape_HArray1OfConnectedEdgeSet_swigregister
Handle_StepShape_HArray1OfConnectedEdgeSet_swigregister(Handle_StepShape_HArray1OfConnectedEdgeSet)

def Handle_StepShape_HArray1OfConnectedEdgeSet_DownCast(thing):
    return _StepShape.Handle_StepShape_HArray1OfConnectedEdgeSet_DownCast(thing)
Handle_StepShape_HArray1OfConnectedEdgeSet_DownCast = _StepShape.Handle_StepShape_HArray1OfConnectedEdgeSet_DownCast

class Handle_StepShape_Path(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepShape_Path self)

        Nullify the handle


        """
        return _StepShape.Handle_StepShape_Path_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepShape_Path self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepShape.Handle_StepShape_Path_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepShape_Path self, StepShape_Path thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepShape.Handle_StepShape_Path_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepShape_Path self, Handle_StepShape_Path theHandle) -> Handle_StepShape_Path
        assign(Handle_StepShape_Path self, StepShape_Path thePtr) -> Handle_StepShape_Path
        assign(Handle_StepShape_Path self, Handle_StepShape_Path theHandle) -> Handle_StepShape_Path

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepShape.Handle_StepShape_Path_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepShape_Path self) -> StepShape_Path

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepShape.Handle_StepShape_Path_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepShape_Path self) -> StepShape_Path

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepShape.Handle_StepShape_Path___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepShape_Path self) -> StepShape_Path

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepShape.Handle_StepShape_Path___ref__(self, *args)


    def __hash__(self):
        return _StepShape.Handle_StepShape_Path___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepShape.Handle_StepShape_Path___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepShape.new_Handle_StepShape_Path(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepShape.Handle_StepShape_Path_DownCast)
    __swig_destroy__ = _StepShape.delete_Handle_StepShape_Path

    def Init(self, *args):
        """
        Init(Handle_StepShape_Path self, Handle_TCollection_HAsciiString aName, Handle_StepShape_HArray1OfOrientedEdge aEdgeList)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aEdgeList: OCC.wrapper.StepShape.Handle_StepShape_HArray1OfOrientedEdge

        """
        return _StepShape.Handle_StepShape_Path_Init(self, *args)


    def SetEdgeList(self, *args):
        """
        SetEdgeList(Handle_StepShape_Path self, Handle_StepShape_HArray1OfOrientedEdge aEdgeList)

        :type aEdgeList: OCC.wrapper.StepShape.Handle_StepShape_HArray1OfOrientedEdge

        """
        return _StepShape.Handle_StepShape_Path_SetEdgeList(self, *args)


    def EdgeList(self, *args):
        """
        EdgeList(Handle_StepShape_Path self) -> Handle_StepShape_HArray1OfOrientedEdge

        :rtype: OCC.wrapper.StepShape.Handle_StepShape_HArray1OfOrientedEdge

        """
        return _StepShape.Handle_StepShape_Path_EdgeList(self, *args)


    def EdgeListValue(self, *args):
        """
        EdgeListValue(Handle_StepShape_Path self, Standard_Integer const num) -> Handle_StepShape_OrientedEdge

        :type num: int
        :rtype: OCC.wrapper.StepShape.Handle_StepShape_OrientedEdge

        """
        return _StepShape.Handle_StepShape_Path_EdgeListValue(self, *args)


    def NbEdgeList(self, *args):
        """
        NbEdgeList(Handle_StepShape_Path self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_Path_NbEdgeList(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepShape_Path self) -> char const *

        :rtype: const char *

        """
        return _StepShape.Handle_StepShape_Path_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.Handle_StepShape_Path_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.Handle_StepShape_Path_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetName(self, *args):
        """
        SetName(Handle_StepShape_Path self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepShape.Handle_StepShape_Path_SetName(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepShape_Path self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepShape.Handle_StepShape_Path_Name(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepShape_Path self)

        Memory deallocator for transient classes


        """
        return _StepShape.Handle_StepShape_Path_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepShape_Path self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepShape_Path self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.Handle_StepShape_Path_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepShape_Path self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepShape_Path self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.Handle_StepShape_Path_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepShape_Path self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepShape.Handle_StepShape_Path_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepShape_Path self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_Path_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepShape_Path self)

        Increments the reference counter of this object


        """
        return _StepShape.Handle_StepShape_Path_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepShape_Path self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_Path_DecrementRefCounter(self, *args)

Handle_StepShape_Path_swigregister = _StepShape.Handle_StepShape_Path_swigregister
Handle_StepShape_Path_swigregister(Handle_StepShape_Path)

def Handle_StepShape_Path_DownCast(thing):
    return _StepShape.Handle_StepShape_Path_DownCast(thing)
Handle_StepShape_Path_DownCast = _StepShape.Handle_StepShape_Path_DownCast

class Handle_StepShape_TopologicalRepresentationItem(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepShape_TopologicalRepresentationItem self)

        Nullify the handle


        """
        return _StepShape.Handle_StepShape_TopologicalRepresentationItem_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepShape_TopologicalRepresentationItem self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepShape.Handle_StepShape_TopologicalRepresentationItem_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepShape_TopologicalRepresentationItem self, StepShape_TopologicalRepresentationItem thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepShape.Handle_StepShape_TopologicalRepresentationItem_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepShape_TopologicalRepresentationItem self, Handle_StepShape_TopologicalRepresentationItem theHandle) -> Handle_StepShape_TopologicalRepresentationItem
        assign(Handle_StepShape_TopologicalRepresentationItem self, StepShape_TopologicalRepresentationItem thePtr) -> Handle_StepShape_TopologicalRepresentationItem
        assign(Handle_StepShape_TopologicalRepresentationItem self, Handle_StepShape_TopologicalRepresentationItem theHandle) -> Handle_StepShape_TopologicalRepresentationItem

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepShape.Handle_StepShape_TopologicalRepresentationItem_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepShape_TopologicalRepresentationItem self) -> StepShape_TopologicalRepresentationItem

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepShape.Handle_StepShape_TopologicalRepresentationItem_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepShape_TopologicalRepresentationItem self) -> StepShape_TopologicalRepresentationItem

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepShape.Handle_StepShape_TopologicalRepresentationItem___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepShape_TopologicalRepresentationItem self) -> StepShape_TopologicalRepresentationItem

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepShape.Handle_StepShape_TopologicalRepresentationItem___ref__(self, *args)


    def __hash__(self):
        return _StepShape.Handle_StepShape_TopologicalRepresentationItem___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepShape.Handle_StepShape_TopologicalRepresentationItem___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepShape.new_Handle_StepShape_TopologicalRepresentationItem(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepShape.Handle_StepShape_TopologicalRepresentationItem_DownCast)
    __swig_destroy__ = _StepShape.delete_Handle_StepShape_TopologicalRepresentationItem

    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepShape_TopologicalRepresentationItem self) -> char const *

        :rtype: const char *

        """
        return _StepShape.Handle_StepShape_TopologicalRepresentationItem_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.Handle_StepShape_TopologicalRepresentationItem_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.Handle_StepShape_TopologicalRepresentationItem_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Init(self, *args):
        """
        Init(Handle_StepShape_TopologicalRepresentationItem self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepShape.Handle_StepShape_TopologicalRepresentationItem_Init(self, *args)


    def SetName(self, *args):
        """
        SetName(Handle_StepShape_TopologicalRepresentationItem self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepShape.Handle_StepShape_TopologicalRepresentationItem_SetName(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepShape_TopologicalRepresentationItem self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepShape.Handle_StepShape_TopologicalRepresentationItem_Name(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepShape_TopologicalRepresentationItem self)

        Memory deallocator for transient classes


        """
        return _StepShape.Handle_StepShape_TopologicalRepresentationItem_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepShape_TopologicalRepresentationItem self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepShape_TopologicalRepresentationItem self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.Handle_StepShape_TopologicalRepresentationItem_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepShape_TopologicalRepresentationItem self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepShape_TopologicalRepresentationItem self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.Handle_StepShape_TopologicalRepresentationItem_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepShape_TopologicalRepresentationItem self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepShape.Handle_StepShape_TopologicalRepresentationItem_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepShape_TopologicalRepresentationItem self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_TopologicalRepresentationItem_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepShape_TopologicalRepresentationItem self)

        Increments the reference counter of this object


        """
        return _StepShape.Handle_StepShape_TopologicalRepresentationItem_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepShape_TopologicalRepresentationItem self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_TopologicalRepresentationItem_DecrementRefCounter(self, *args)

Handle_StepShape_TopologicalRepresentationItem_swigregister = _StepShape.Handle_StepShape_TopologicalRepresentationItem_swigregister
Handle_StepShape_TopologicalRepresentationItem_swigregister(Handle_StepShape_TopologicalRepresentationItem)

def Handle_StepShape_TopologicalRepresentationItem_DownCast(thing):
    return _StepShape.Handle_StepShape_TopologicalRepresentationItem_DownCast(thing)
Handle_StepShape_TopologicalRepresentationItem_DownCast = _StepShape.Handle_StepShape_TopologicalRepresentationItem_DownCast

class Handle_StepShape_SeamEdge(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepShape_SeamEdge self)

        Nullify the handle


        """
        return _StepShape.Handle_StepShape_SeamEdge_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepShape_SeamEdge self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepShape.Handle_StepShape_SeamEdge_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepShape_SeamEdge self, StepShape_SeamEdge thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepShape.Handle_StepShape_SeamEdge_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepShape_SeamEdge self, Handle_StepShape_SeamEdge theHandle) -> Handle_StepShape_SeamEdge
        assign(Handle_StepShape_SeamEdge self, StepShape_SeamEdge thePtr) -> Handle_StepShape_SeamEdge
        assign(Handle_StepShape_SeamEdge self, Handle_StepShape_SeamEdge theHandle) -> Handle_StepShape_SeamEdge

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepShape.Handle_StepShape_SeamEdge_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepShape_SeamEdge self) -> StepShape_SeamEdge

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepShape.Handle_StepShape_SeamEdge_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepShape_SeamEdge self) -> StepShape_SeamEdge

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepShape.Handle_StepShape_SeamEdge___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepShape_SeamEdge self) -> StepShape_SeamEdge

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepShape.Handle_StepShape_SeamEdge___ref__(self, *args)


    def __hash__(self):
        return _StepShape.Handle_StepShape_SeamEdge___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepShape.Handle_StepShape_SeamEdge___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepShape.new_Handle_StepShape_SeamEdge(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepShape.Handle_StepShape_SeamEdge_DownCast)
    __swig_destroy__ = _StepShape.delete_Handle_StepShape_SeamEdge

    def Init(self, *args):
        """
        Init(Handle_StepShape_SeamEdge self, Handle_TCollection_HAsciiString aRepresentationItem_Name, Handle_StepShape_Edge aOrientedEdge_EdgeElement, Standard_Boolean const aOrientedEdge_Orientation, Handle_StepGeom_Pcurve aPcurveReference)

        Initialize all fields (own and inherited)

        :type aRepresentationItem_Name: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aOrientedEdge_EdgeElement: OCC.wrapper.StepShape.Handle_StepShape_Edge
        :type aOrientedEdge_Orientation: bool
        :type aPcurveReference: OCC.wrapper.StepShape.Handle_StepGeom_Pcurve

        """
        return _StepShape.Handle_StepShape_SeamEdge_Init(self, *args)


    def PcurveReference(self, *args):
        """
        PcurveReference(Handle_StepShape_SeamEdge self) -> Handle_StepGeom_Pcurve

        Returns field PcurveReference

        :rtype: OCC.wrapper.StepShape.Handle_StepGeom_Pcurve

        """
        return _StepShape.Handle_StepShape_SeamEdge_PcurveReference(self, *args)


    def SetPcurveReference(self, *args):
        """
        SetPcurveReference(Handle_StepShape_SeamEdge self, Handle_StepGeom_Pcurve PcurveReference)

        Set field PcurveReference

        :type PcurveReference: OCC.wrapper.StepShape.Handle_StepGeom_Pcurve

        """
        return _StepShape.Handle_StepShape_SeamEdge_SetPcurveReference(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepShape_SeamEdge self) -> char const *

        :rtype: const char *

        """
        return _StepShape.Handle_StepShape_SeamEdge_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.Handle_StepShape_SeamEdge_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.Handle_StepShape_SeamEdge_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetEdgeElement(self, *args):
        """
        SetEdgeElement(Handle_StepShape_SeamEdge self, Handle_StepShape_Edge aEdgeElement)

        :type aEdgeElement: OCC.wrapper.StepShape.Handle_StepShape_Edge

        """
        return _StepShape.Handle_StepShape_SeamEdge_SetEdgeElement(self, *args)


    def EdgeElement(self, *args):
        """
        EdgeElement(Handle_StepShape_SeamEdge self) -> Handle_StepShape_Edge

        :rtype: OCC.wrapper.StepShape.Handle_StepShape_Edge

        """
        return _StepShape.Handle_StepShape_SeamEdge_EdgeElement(self, *args)


    def SetOrientation(self, *args):
        """
        SetOrientation(Handle_StepShape_SeamEdge self, Standard_Boolean const aOrientation)

        :type aOrientation: bool

        """
        return _StepShape.Handle_StepShape_SeamEdge_SetOrientation(self, *args)


    def Orientation(self, *args):
        """
        Orientation(Handle_StepShape_SeamEdge self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.Handle_StepShape_SeamEdge_Orientation(self, *args)


    def SetEdgeStart(self, *args):
        """
        SetEdgeStart(Handle_StepShape_SeamEdge self, Handle_StepShape_Vertex aEdgeStart)

        :type aEdgeStart: OCC.wrapper.StepShape.Handle_StepShape_Vertex

        """
        return _StepShape.Handle_StepShape_SeamEdge_SetEdgeStart(self, *args)


    def EdgeStart(self, *args):
        """
        EdgeStart(Handle_StepShape_SeamEdge self) -> Handle_StepShape_Vertex

        :rtype: OCC.wrapper.StepShape.Handle_StepShape_Vertex

        """
        return _StepShape.Handle_StepShape_SeamEdge_EdgeStart(self, *args)


    def SetEdgeEnd(self, *args):
        """
        SetEdgeEnd(Handle_StepShape_SeamEdge self, Handle_StepShape_Vertex aEdgeEnd)

        :type aEdgeEnd: OCC.wrapper.StepShape.Handle_StepShape_Vertex

        """
        return _StepShape.Handle_StepShape_SeamEdge_SetEdgeEnd(self, *args)


    def EdgeEnd(self, *args):
        """
        EdgeEnd(Handle_StepShape_SeamEdge self) -> Handle_StepShape_Vertex

        :rtype: OCC.wrapper.StepShape.Handle_StepShape_Vertex

        """
        return _StepShape.Handle_StepShape_SeamEdge_EdgeEnd(self, *args)


    def SetName(self, *args):
        """
        SetName(Handle_StepShape_SeamEdge self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepShape.Handle_StepShape_SeamEdge_SetName(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepShape_SeamEdge self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepShape.Handle_StepShape_SeamEdge_Name(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepShape_SeamEdge self)

        Memory deallocator for transient classes


        """
        return _StepShape.Handle_StepShape_SeamEdge_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepShape_SeamEdge self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepShape_SeamEdge self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.Handle_StepShape_SeamEdge_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepShape_SeamEdge self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepShape_SeamEdge self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.Handle_StepShape_SeamEdge_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepShape_SeamEdge self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepShape.Handle_StepShape_SeamEdge_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepShape_SeamEdge self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_SeamEdge_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepShape_SeamEdge self)

        Increments the reference counter of this object


        """
        return _StepShape.Handle_StepShape_SeamEdge_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepShape_SeamEdge self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_SeamEdge_DecrementRefCounter(self, *args)

Handle_StepShape_SeamEdge_swigregister = _StepShape.Handle_StepShape_SeamEdge_swigregister
Handle_StepShape_SeamEdge_swigregister(Handle_StepShape_SeamEdge)

def Handle_StepShape_SeamEdge_DownCast(thing):
    return _StepShape.Handle_StepShape_SeamEdge_DownCast(thing)
Handle_StepShape_SeamEdge_DownCast = _StepShape.Handle_StepShape_SeamEdge_DownCast

class StepShape_CsgSelect(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(StepShape_CsgSelect self) -> StepShape_CsgSelect

        Returns a CsgSelect SelectType


        """
        this = _StepShape.new_StepShape_CsgSelect(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def SetTypeOfContent(self, *args):
        """
        SetTypeOfContent(StepShape_CsgSelect self, Standard_Integer const aTypeOfContent)

        :type aTypeOfContent: int

        """
        return _StepShape.StepShape_CsgSelect_SetTypeOfContent(self, *args)


    def TypeOfContent(self, *args):
        """
        TypeOfContent(StepShape_CsgSelect self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.StepShape_CsgSelect_TypeOfContent(self, *args)


    def BooleanResult(self, *args):
        """
        BooleanResult(StepShape_CsgSelect self) -> Handle_StepShape_BooleanResult

        returns Value as a BooleanResult (Null if another type)

        :rtype: OCC.wrapper.StepShape.Handle_StepShape_BooleanResult

        """
        return _StepShape.StepShape_CsgSelect_BooleanResult(self, *args)


    def SetBooleanResult(self, *args):
        """
        SetBooleanResult(StepShape_CsgSelect self, Handle_StepShape_BooleanResult aBooleanResult)

        :type aBooleanResult: OCC.wrapper.StepShape.Handle_StepShape_BooleanResult

        """
        return _StepShape.StepShape_CsgSelect_SetBooleanResult(self, *args)


    def CsgPrimitive(self, *args):
        """
        CsgPrimitive(StepShape_CsgSelect self) -> StepShape_CsgPrimitive

        returns Value as a CsgPrimitive (Null if another type)

        :rtype: OCC.wrapper.StepShape.StepShape_CsgPrimitive

        """
        return _StepShape.StepShape_CsgSelect_CsgPrimitive(self, *args)


    def SetCsgPrimitive(self, *args):
        """
        SetCsgPrimitive(StepShape_CsgSelect self, StepShape_CsgPrimitive aCsgPrimitive)

        :type aCsgPrimitive: OCC.wrapper.StepShape.StepShape_CsgPrimitive

        """
        return _StepShape.StepShape_CsgSelect_SetCsgPrimitive(self, *args)

    __swig_destroy__ = _StepShape.delete_StepShape_CsgSelect
StepShape_CsgSelect_swigregister = _StepShape.StepShape_CsgSelect_swigregister
StepShape_CsgSelect_swigregister(StepShape_CsgSelect)

class Handle_StepShape_PolyLoop(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepShape_PolyLoop self)

        Nullify the handle


        """
        return _StepShape.Handle_StepShape_PolyLoop_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepShape_PolyLoop self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepShape.Handle_StepShape_PolyLoop_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepShape_PolyLoop self, StepShape_PolyLoop thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepShape.Handle_StepShape_PolyLoop_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepShape_PolyLoop self, Handle_StepShape_PolyLoop theHandle) -> Handle_StepShape_PolyLoop
        assign(Handle_StepShape_PolyLoop self, StepShape_PolyLoop thePtr) -> Handle_StepShape_PolyLoop
        assign(Handle_StepShape_PolyLoop self, Handle_StepShape_PolyLoop theHandle) -> Handle_StepShape_PolyLoop

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepShape.Handle_StepShape_PolyLoop_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepShape_PolyLoop self) -> StepShape_PolyLoop

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepShape.Handle_StepShape_PolyLoop_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepShape_PolyLoop self) -> StepShape_PolyLoop

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepShape.Handle_StepShape_PolyLoop___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepShape_PolyLoop self) -> StepShape_PolyLoop

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepShape.Handle_StepShape_PolyLoop___ref__(self, *args)


    def __hash__(self):
        return _StepShape.Handle_StepShape_PolyLoop___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepShape.Handle_StepShape_PolyLoop___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepShape.new_Handle_StepShape_PolyLoop(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepShape.Handle_StepShape_PolyLoop_DownCast)
    __swig_destroy__ = _StepShape.delete_Handle_StepShape_PolyLoop

    def Init(self, *args):
        """
        Init(Handle_StepShape_PolyLoop self, Handle_TCollection_HAsciiString aName, Handle_StepGeom_HArray1OfCartesianPoint aPolygon)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aPolygon: OCC.wrapper.StepShape.Handle_StepGeom_HArray1OfCartesianPoint

        """
        return _StepShape.Handle_StepShape_PolyLoop_Init(self, *args)


    def SetPolygon(self, *args):
        """
        SetPolygon(Handle_StepShape_PolyLoop self, Handle_StepGeom_HArray1OfCartesianPoint aPolygon)

        :type aPolygon: OCC.wrapper.StepShape.Handle_StepGeom_HArray1OfCartesianPoint

        """
        return _StepShape.Handle_StepShape_PolyLoop_SetPolygon(self, *args)


    def Polygon(self, *args):
        """
        Polygon(Handle_StepShape_PolyLoop self) -> Handle_StepGeom_HArray1OfCartesianPoint

        :rtype: OCC.wrapper.StepShape.Handle_StepGeom_HArray1OfCartesianPoint

        """
        return _StepShape.Handle_StepShape_PolyLoop_Polygon(self, *args)


    def PolygonValue(self, *args):
        """
        PolygonValue(Handle_StepShape_PolyLoop self, Standard_Integer const num) -> Handle_StepGeom_CartesianPoint

        :type num: int
        :rtype: OCC.wrapper.StepShape.Handle_StepGeom_CartesianPoint

        """
        return _StepShape.Handle_StepShape_PolyLoop_PolygonValue(self, *args)


    def NbPolygon(self, *args):
        """
        NbPolygon(Handle_StepShape_PolyLoop self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_PolyLoop_NbPolygon(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepShape_PolyLoop self) -> char const *

        :rtype: const char *

        """
        return _StepShape.Handle_StepShape_PolyLoop_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.Handle_StepShape_PolyLoop_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.Handle_StepShape_PolyLoop_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetName(self, *args):
        """
        SetName(Handle_StepShape_PolyLoop self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepShape.Handle_StepShape_PolyLoop_SetName(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepShape_PolyLoop self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepShape.Handle_StepShape_PolyLoop_Name(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepShape_PolyLoop self)

        Memory deallocator for transient classes


        """
        return _StepShape.Handle_StepShape_PolyLoop_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepShape_PolyLoop self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepShape_PolyLoop self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.Handle_StepShape_PolyLoop_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepShape_PolyLoop self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepShape_PolyLoop self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.Handle_StepShape_PolyLoop_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepShape_PolyLoop self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepShape.Handle_StepShape_PolyLoop_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepShape_PolyLoop self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_PolyLoop_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepShape_PolyLoop self)

        Increments the reference counter of this object


        """
        return _StepShape.Handle_StepShape_PolyLoop_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepShape_PolyLoop self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_PolyLoop_DecrementRefCounter(self, *args)

Handle_StepShape_PolyLoop_swigregister = _StepShape.Handle_StepShape_PolyLoop_swigregister
Handle_StepShape_PolyLoop_swigregister(Handle_StepShape_PolyLoop)

def Handle_StepShape_PolyLoop_DownCast(thing):
    return _StepShape.Handle_StepShape_PolyLoop_DownCast(thing)
Handle_StepShape_PolyLoop_DownCast = _StepShape.Handle_StepShape_PolyLoop_DownCast

class StepShape_DimensionalCharacteristic(StepData.StepData_SelectType):
    """Representation of STEP SELECT type DimensionalCharacteristic"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(StepShape_DimensionalCharacteristic self) -> StepShape_DimensionalCharacteristic

        Empty constructor


        """
        this = _StepShape.new_StepShape_DimensionalCharacteristic(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def CaseNum(self, *args):
        """
        CaseNum(StepShape_DimensionalCharacteristic self, Handle_Standard_Transient ent) -> Standard_Integer

        Recognizes a kind of DimensionalCharacteristic select type
        1 -> DimensionalLocation from StepShape
        2 -> DimensionalSize from StepShape
        0 else

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.StepShape_DimensionalCharacteristic_CaseNum(self, *args)


    def DimensionalLocation(self, *args):
        """
        DimensionalLocation(StepShape_DimensionalCharacteristic self) -> Handle_StepShape_DimensionalLocation

        Returns Value as DimensionalLocation (or Null if another type)

        :rtype: OCC.wrapper.StepShape.Handle_StepShape_DimensionalLocation

        """
        return _StepShape.StepShape_DimensionalCharacteristic_DimensionalLocation(self, *args)


    def DimensionalSize(self, *args):
        """
        DimensionalSize(StepShape_DimensionalCharacteristic self) -> Handle_StepShape_DimensionalSize

        Returns Value as DimensionalSize (or Null if another type)

        :rtype: OCC.wrapper.StepShape.Handle_StepShape_DimensionalSize

        """
        return _StepShape.StepShape_DimensionalCharacteristic_DimensionalSize(self, *args)

    __swig_destroy__ = _StepShape.delete_StepShape_DimensionalCharacteristic
StepShape_DimensionalCharacteristic_swigregister = _StepShape.StepShape_DimensionalCharacteristic_swigregister
StepShape_DimensionalCharacteristic_swigregister(StepShape_DimensionalCharacteristic)

class Handle_StepShape_GeometricCurveSet(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepShape_GeometricCurveSet self)

        Nullify the handle


        """
        return _StepShape.Handle_StepShape_GeometricCurveSet_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepShape_GeometricCurveSet self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepShape.Handle_StepShape_GeometricCurveSet_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepShape_GeometricCurveSet self, StepShape_GeometricCurveSet thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepShape.Handle_StepShape_GeometricCurveSet_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepShape_GeometricCurveSet self, Handle_StepShape_GeometricCurveSet theHandle) -> Handle_StepShape_GeometricCurveSet
        assign(Handle_StepShape_GeometricCurveSet self, StepShape_GeometricCurveSet thePtr) -> Handle_StepShape_GeometricCurveSet
        assign(Handle_StepShape_GeometricCurveSet self, Handle_StepShape_GeometricCurveSet theHandle) -> Handle_StepShape_GeometricCurveSet

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepShape.Handle_StepShape_GeometricCurveSet_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepShape_GeometricCurveSet self) -> StepShape_GeometricCurveSet

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepShape.Handle_StepShape_GeometricCurveSet_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepShape_GeometricCurveSet self) -> StepShape_GeometricCurveSet

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepShape.Handle_StepShape_GeometricCurveSet___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepShape_GeometricCurveSet self) -> StepShape_GeometricCurveSet

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepShape.Handle_StepShape_GeometricCurveSet___ref__(self, *args)


    def __hash__(self):
        return _StepShape.Handle_StepShape_GeometricCurveSet___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepShape.Handle_StepShape_GeometricCurveSet___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepShape.new_Handle_StepShape_GeometricCurveSet(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepShape.Handle_StepShape_GeometricCurveSet_DownCast)
    __swig_destroy__ = _StepShape.delete_Handle_StepShape_GeometricCurveSet

    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepShape_GeometricCurveSet self) -> char const *

        :rtype: const char *

        """
        return _StepShape.Handle_StepShape_GeometricCurveSet_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.Handle_StepShape_GeometricCurveSet_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.Handle_StepShape_GeometricCurveSet_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Init(self, *args):
        """
        Init(Handle_StepShape_GeometricCurveSet self, Handle_TCollection_HAsciiString aName, Handle_StepShape_HArray1OfGeometricSetSelect aElements)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aElements: OCC.wrapper.StepShape.Handle_StepShape_HArray1OfGeometricSetSelect

        """
        return _StepShape.Handle_StepShape_GeometricCurveSet_Init(self, *args)


    def SetElements(self, *args):
        """
        SetElements(Handle_StepShape_GeometricCurveSet self, Handle_StepShape_HArray1OfGeometricSetSelect aElements)

        :type aElements: OCC.wrapper.StepShape.Handle_StepShape_HArray1OfGeometricSetSelect

        """
        return _StepShape.Handle_StepShape_GeometricCurveSet_SetElements(self, *args)


    def Elements(self, *args):
        """
        Elements(Handle_StepShape_GeometricCurveSet self) -> Handle_StepShape_HArray1OfGeometricSetSelect

        :rtype: OCC.wrapper.StepShape.Handle_StepShape_HArray1OfGeometricSetSelect

        """
        return _StepShape.Handle_StepShape_GeometricCurveSet_Elements(self, *args)


    def ElementsValue(self, *args):
        """
        ElementsValue(Handle_StepShape_GeometricCurveSet self, Standard_Integer const num) -> StepShape_GeometricSetSelect

        :type num: int
        :rtype: OCC.wrapper.StepShape.StepShape_GeometricSetSelect

        """
        return _StepShape.Handle_StepShape_GeometricCurveSet_ElementsValue(self, *args)


    def NbElements(self, *args):
        """
        NbElements(Handle_StepShape_GeometricCurveSet self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_GeometricCurveSet_NbElements(self, *args)


    def SetName(self, *args):
        """
        SetName(Handle_StepShape_GeometricCurveSet self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepShape.Handle_StepShape_GeometricCurveSet_SetName(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepShape_GeometricCurveSet self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepShape.Handle_StepShape_GeometricCurveSet_Name(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepShape_GeometricCurveSet self)

        Memory deallocator for transient classes


        """
        return _StepShape.Handle_StepShape_GeometricCurveSet_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepShape_GeometricCurveSet self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepShape_GeometricCurveSet self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.Handle_StepShape_GeometricCurveSet_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepShape_GeometricCurveSet self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepShape_GeometricCurveSet self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.Handle_StepShape_GeometricCurveSet_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepShape_GeometricCurveSet self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepShape.Handle_StepShape_GeometricCurveSet_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepShape_GeometricCurveSet self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_GeometricCurveSet_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepShape_GeometricCurveSet self)

        Increments the reference counter of this object


        """
        return _StepShape.Handle_StepShape_GeometricCurveSet_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepShape_GeometricCurveSet self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_GeometricCurveSet_DecrementRefCounter(self, *args)

Handle_StepShape_GeometricCurveSet_swigregister = _StepShape.Handle_StepShape_GeometricCurveSet_swigregister
Handle_StepShape_GeometricCurveSet_swigregister(Handle_StepShape_GeometricCurveSet)

def Handle_StepShape_GeometricCurveSet_DownCast(thing):
    return _StepShape.Handle_StepShape_GeometricCurveSet_DownCast(thing)
Handle_StepShape_GeometricCurveSet_DownCast = _StepShape.Handle_StepShape_GeometricCurveSet_DownCast

class Handle_StepShape_RevolvedFaceSolid(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepShape_RevolvedFaceSolid self)

        Nullify the handle


        """
        return _StepShape.Handle_StepShape_RevolvedFaceSolid_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepShape_RevolvedFaceSolid self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepShape.Handle_StepShape_RevolvedFaceSolid_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepShape_RevolvedFaceSolid self, StepShape_RevolvedFaceSolid thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepShape.Handle_StepShape_RevolvedFaceSolid_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepShape_RevolvedFaceSolid self, Handle_StepShape_RevolvedFaceSolid theHandle) -> Handle_StepShape_RevolvedFaceSolid
        assign(Handle_StepShape_RevolvedFaceSolid self, StepShape_RevolvedFaceSolid thePtr) -> Handle_StepShape_RevolvedFaceSolid
        assign(Handle_StepShape_RevolvedFaceSolid self, Handle_StepShape_RevolvedFaceSolid theHandle) -> Handle_StepShape_RevolvedFaceSolid

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepShape.Handle_StepShape_RevolvedFaceSolid_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepShape_RevolvedFaceSolid self) -> StepShape_RevolvedFaceSolid

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepShape.Handle_StepShape_RevolvedFaceSolid_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepShape_RevolvedFaceSolid self) -> StepShape_RevolvedFaceSolid

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepShape.Handle_StepShape_RevolvedFaceSolid___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepShape_RevolvedFaceSolid self) -> StepShape_RevolvedFaceSolid

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepShape.Handle_StepShape_RevolvedFaceSolid___ref__(self, *args)


    def __hash__(self):
        return _StepShape.Handle_StepShape_RevolvedFaceSolid___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepShape.Handle_StepShape_RevolvedFaceSolid___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepShape.new_Handle_StepShape_RevolvedFaceSolid(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepShape.Handle_StepShape_RevolvedFaceSolid_DownCast)
    __swig_destroy__ = _StepShape.delete_Handle_StepShape_RevolvedFaceSolid

    def Init(self, *args):
        """
        Init(Handle_StepShape_RevolvedFaceSolid self, Handle_TCollection_HAsciiString aName, Handle_StepShape_FaceSurface aSweptArea)
        Init(Handle_StepShape_RevolvedFaceSolid self, Handle_TCollection_HAsciiString aName, Handle_StepShape_FaceSurface aSweptArea, Handle_StepGeom_Axis1Placement aAxis, Standard_Real const aAngle)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aSweptArea: OCC.wrapper.StepShape.Handle_StepShape_FaceSurface
        :type aAxis: OCC.wrapper.StepShape.Handle_StepGeom_Axis1Placement
        :type aAngle: float

        """
        return _StepShape.Handle_StepShape_RevolvedFaceSolid_Init(self, *args)


    def SetAxis(self, *args):
        """
        SetAxis(Handle_StepShape_RevolvedFaceSolid self, Handle_StepGeom_Axis1Placement aAxis)

        :type aAxis: OCC.wrapper.StepShape.Handle_StepGeom_Axis1Placement

        """
        return _StepShape.Handle_StepShape_RevolvedFaceSolid_SetAxis(self, *args)


    def Axis(self, *args):
        """
        Axis(Handle_StepShape_RevolvedFaceSolid self) -> Handle_StepGeom_Axis1Placement

        :rtype: OCC.wrapper.StepShape.Handle_StepGeom_Axis1Placement

        """
        return _StepShape.Handle_StepShape_RevolvedFaceSolid_Axis(self, *args)


    def SetAngle(self, *args):
        """
        SetAngle(Handle_StepShape_RevolvedFaceSolid self, Standard_Real const aAngle)

        :type aAngle: float

        """
        return _StepShape.Handle_StepShape_RevolvedFaceSolid_SetAngle(self, *args)


    def Angle(self, *args):
        """
        Angle(Handle_StepShape_RevolvedFaceSolid self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _StepShape.Handle_StepShape_RevolvedFaceSolid_Angle(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepShape_RevolvedFaceSolid self) -> char const *

        :rtype: const char *

        """
        return _StepShape.Handle_StepShape_RevolvedFaceSolid_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.Handle_StepShape_RevolvedFaceSolid_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.Handle_StepShape_RevolvedFaceSolid_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetSweptFace(self, *args):
        """
        SetSweptFace(Handle_StepShape_RevolvedFaceSolid self, Handle_StepShape_FaceSurface aSweptArea)

        :type aSweptArea: OCC.wrapper.StepShape.Handle_StepShape_FaceSurface

        """
        return _StepShape.Handle_StepShape_RevolvedFaceSolid_SetSweptFace(self, *args)


    def SweptFace(self, *args):
        """
        SweptFace(Handle_StepShape_RevolvedFaceSolid self) -> Handle_StepShape_FaceSurface

        :rtype: OCC.wrapper.StepShape.Handle_StepShape_FaceSurface

        """
        return _StepShape.Handle_StepShape_RevolvedFaceSolid_SweptFace(self, *args)


    def SetName(self, *args):
        """
        SetName(Handle_StepShape_RevolvedFaceSolid self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepShape.Handle_StepShape_RevolvedFaceSolid_SetName(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepShape_RevolvedFaceSolid self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepShape.Handle_StepShape_RevolvedFaceSolid_Name(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepShape_RevolvedFaceSolid self)

        Memory deallocator for transient classes


        """
        return _StepShape.Handle_StepShape_RevolvedFaceSolid_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepShape_RevolvedFaceSolid self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepShape_RevolvedFaceSolid self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.Handle_StepShape_RevolvedFaceSolid_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepShape_RevolvedFaceSolid self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepShape_RevolvedFaceSolid self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.Handle_StepShape_RevolvedFaceSolid_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepShape_RevolvedFaceSolid self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepShape.Handle_StepShape_RevolvedFaceSolid_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepShape_RevolvedFaceSolid self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_RevolvedFaceSolid_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepShape_RevolvedFaceSolid self)

        Increments the reference counter of this object


        """
        return _StepShape.Handle_StepShape_RevolvedFaceSolid_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepShape_RevolvedFaceSolid self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_RevolvedFaceSolid_DecrementRefCounter(self, *args)

Handle_StepShape_RevolvedFaceSolid_swigregister = _StepShape.Handle_StepShape_RevolvedFaceSolid_swigregister
Handle_StepShape_RevolvedFaceSolid_swigregister(Handle_StepShape_RevolvedFaceSolid)

def Handle_StepShape_RevolvedFaceSolid_DownCast(thing):
    return _StepShape.Handle_StepShape_RevolvedFaceSolid_DownCast(thing)
Handle_StepShape_RevolvedFaceSolid_DownCast = _StepShape.Handle_StepShape_RevolvedFaceSolid_DownCast

class Handle_StepShape_ClosedShell(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepShape_ClosedShell self)

        Nullify the handle


        """
        return _StepShape.Handle_StepShape_ClosedShell_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepShape_ClosedShell self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepShape.Handle_StepShape_ClosedShell_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepShape_ClosedShell self, StepShape_ClosedShell thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepShape.Handle_StepShape_ClosedShell_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepShape_ClosedShell self, Handle_StepShape_ClosedShell theHandle) -> Handle_StepShape_ClosedShell
        assign(Handle_StepShape_ClosedShell self, StepShape_ClosedShell thePtr) -> Handle_StepShape_ClosedShell
        assign(Handle_StepShape_ClosedShell self, Handle_StepShape_ClosedShell theHandle) -> Handle_StepShape_ClosedShell

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepShape.Handle_StepShape_ClosedShell_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepShape_ClosedShell self) -> StepShape_ClosedShell

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepShape.Handle_StepShape_ClosedShell_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepShape_ClosedShell self) -> StepShape_ClosedShell

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepShape.Handle_StepShape_ClosedShell___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepShape_ClosedShell self) -> StepShape_ClosedShell

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepShape.Handle_StepShape_ClosedShell___ref__(self, *args)


    def __hash__(self):
        return _StepShape.Handle_StepShape_ClosedShell___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepShape.Handle_StepShape_ClosedShell___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepShape.new_Handle_StepShape_ClosedShell(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepShape.Handle_StepShape_ClosedShell_DownCast)
    __swig_destroy__ = _StepShape.delete_Handle_StepShape_ClosedShell

    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepShape_ClosedShell self) -> char const *

        :rtype: const char *

        """
        return _StepShape.Handle_StepShape_ClosedShell_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.Handle_StepShape_ClosedShell_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.Handle_StepShape_ClosedShell_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Init(self, *args):
        """
        Init(Handle_StepShape_ClosedShell self, Handle_TCollection_HAsciiString aName, Handle_StepShape_HArray1OfFace aCfsFaces)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aCfsFaces: OCC.wrapper.StepShape.Handle_StepShape_HArray1OfFace

        """
        return _StepShape.Handle_StepShape_ClosedShell_Init(self, *args)


    def SetCfsFaces(self, *args):
        """
        SetCfsFaces(Handle_StepShape_ClosedShell self, Handle_StepShape_HArray1OfFace aCfsFaces)

        :type aCfsFaces: OCC.wrapper.StepShape.Handle_StepShape_HArray1OfFace

        """
        return _StepShape.Handle_StepShape_ClosedShell_SetCfsFaces(self, *args)


    def CfsFaces(self, *args):
        """
        CfsFaces(Handle_StepShape_ClosedShell self) -> Handle_StepShape_HArray1OfFace

        :rtype: OCC.wrapper.StepShape.Handle_StepShape_HArray1OfFace

        """
        return _StepShape.Handle_StepShape_ClosedShell_CfsFaces(self, *args)


    def CfsFacesValue(self, *args):
        """
        CfsFacesValue(Handle_StepShape_ClosedShell self, Standard_Integer const num) -> Handle_StepShape_Face

        :type num: int
        :rtype: OCC.wrapper.StepShape.Handle_StepShape_Face

        """
        return _StepShape.Handle_StepShape_ClosedShell_CfsFacesValue(self, *args)


    def NbCfsFaces(self, *args):
        """
        NbCfsFaces(Handle_StepShape_ClosedShell self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_ClosedShell_NbCfsFaces(self, *args)


    def SetName(self, *args):
        """
        SetName(Handle_StepShape_ClosedShell self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepShape.Handle_StepShape_ClosedShell_SetName(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepShape_ClosedShell self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepShape.Handle_StepShape_ClosedShell_Name(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepShape_ClosedShell self)

        Memory deallocator for transient classes


        """
        return _StepShape.Handle_StepShape_ClosedShell_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepShape_ClosedShell self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepShape_ClosedShell self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.Handle_StepShape_ClosedShell_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepShape_ClosedShell self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepShape_ClosedShell self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.Handle_StepShape_ClosedShell_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepShape_ClosedShell self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepShape.Handle_StepShape_ClosedShell_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepShape_ClosedShell self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_ClosedShell_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepShape_ClosedShell self)

        Increments the reference counter of this object


        """
        return _StepShape.Handle_StepShape_ClosedShell_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepShape_ClosedShell self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_ClosedShell_DecrementRefCounter(self, *args)

Handle_StepShape_ClosedShell_swigregister = _StepShape.Handle_StepShape_ClosedShell_swigregister
Handle_StepShape_ClosedShell_swigregister(Handle_StepShape_ClosedShell)

def Handle_StepShape_ClosedShell_DownCast(thing):
    return _StepShape.Handle_StepShape_ClosedShell_DownCast(thing)
Handle_StepShape_ClosedShell_DownCast = _StepShape.Handle_StepShape_ClosedShell_DownCast

class Handle_StepShape_DimensionalLocation(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepShape_DimensionalLocation self)

        Nullify the handle


        """
        return _StepShape.Handle_StepShape_DimensionalLocation_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepShape_DimensionalLocation self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepShape.Handle_StepShape_DimensionalLocation_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepShape_DimensionalLocation self, StepShape_DimensionalLocation thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepShape.Handle_StepShape_DimensionalLocation_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepShape_DimensionalLocation self, Handle_StepShape_DimensionalLocation theHandle) -> Handle_StepShape_DimensionalLocation
        assign(Handle_StepShape_DimensionalLocation self, StepShape_DimensionalLocation thePtr) -> Handle_StepShape_DimensionalLocation
        assign(Handle_StepShape_DimensionalLocation self, Handle_StepShape_DimensionalLocation theHandle) -> Handle_StepShape_DimensionalLocation

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepShape.Handle_StepShape_DimensionalLocation_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepShape_DimensionalLocation self) -> StepShape_DimensionalLocation

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepShape.Handle_StepShape_DimensionalLocation_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepShape_DimensionalLocation self) -> StepShape_DimensionalLocation

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepShape.Handle_StepShape_DimensionalLocation___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepShape_DimensionalLocation self) -> StepShape_DimensionalLocation

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepShape.Handle_StepShape_DimensionalLocation___ref__(self, *args)


    def __hash__(self):
        return _StepShape.Handle_StepShape_DimensionalLocation___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepShape.Handle_StepShape_DimensionalLocation___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepShape.new_Handle_StepShape_DimensionalLocation(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepShape.Handle_StepShape_DimensionalLocation_DownCast)
    __swig_destroy__ = _StepShape.delete_Handle_StepShape_DimensionalLocation

    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepShape_DimensionalLocation self) -> char const *

        :rtype: const char *

        """
        return _StepShape.Handle_StepShape_DimensionalLocation_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.Handle_StepShape_DimensionalLocation_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.Handle_StepShape_DimensionalLocation_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Init(self, *args):
        """
        Init(Handle_StepShape_DimensionalLocation self, Handle_TCollection_HAsciiString aName, Standard_Boolean const hasDescription, Handle_TCollection_HAsciiString aDescription, Handle_StepRepr_ShapeAspect aRelatingShapeAspect, Handle_StepRepr_ShapeAspect aRelatedShapeAspect)

        Initialize all fields (own and inherited)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type hasDescription: bool
        :type aDescription: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aRelatingShapeAspect: OCC.wrapper.StepRepr.Handle_StepRepr_ShapeAspect
        :type aRelatedShapeAspect: OCC.wrapper.StepRepr.Handle_StepRepr_ShapeAspect

        """
        return _StepShape.Handle_StepShape_DimensionalLocation_Init(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepShape_DimensionalLocation self) -> Handle_TCollection_HAsciiString

        Returns field Name

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepShape.Handle_StepShape_DimensionalLocation_Name(self, *args)


    def SetName(self, *args):
        """
        SetName(Handle_StepShape_DimensionalLocation self, Handle_TCollection_HAsciiString Name)

        Set field Name

        :type Name: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepShape.Handle_StepShape_DimensionalLocation_SetName(self, *args)


    def Description(self, *args):
        """
        Description(Handle_StepShape_DimensionalLocation self) -> Handle_TCollection_HAsciiString

        Returns field Description

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepShape.Handle_StepShape_DimensionalLocation_Description(self, *args)


    def SetDescription(self, *args):
        """
        SetDescription(Handle_StepShape_DimensionalLocation self, Handle_TCollection_HAsciiString Description)

        Set field Description

        :type Description: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepShape.Handle_StepShape_DimensionalLocation_SetDescription(self, *args)


    def HasDescription(self, *args):
        """
        HasDescription(Handle_StepShape_DimensionalLocation self) -> Standard_Boolean

        Returns True if optional field Description is defined

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.Handle_StepShape_DimensionalLocation_HasDescription(self, *args)


    def RelatingShapeAspect(self, *args):
        """
        RelatingShapeAspect(Handle_StepShape_DimensionalLocation self) -> Handle_StepRepr_ShapeAspect

        Returns field RelatingShapeAspect

        :rtype: OCC.wrapper.StepRepr.Handle_StepRepr_ShapeAspect

        """
        return _StepShape.Handle_StepShape_DimensionalLocation_RelatingShapeAspect(self, *args)


    def SetRelatingShapeAspect(self, *args):
        """
        SetRelatingShapeAspect(Handle_StepShape_DimensionalLocation self, Handle_StepRepr_ShapeAspect RelatingShapeAspect)

        Set field RelatingShapeAspect

        :type RelatingShapeAspect: OCC.wrapper.StepRepr.Handle_StepRepr_ShapeAspect

        """
        return _StepShape.Handle_StepShape_DimensionalLocation_SetRelatingShapeAspect(self, *args)


    def RelatedShapeAspect(self, *args):
        """
        RelatedShapeAspect(Handle_StepShape_DimensionalLocation self) -> Handle_StepRepr_ShapeAspect

        Returns field RelatedShapeAspect

        :rtype: OCC.wrapper.StepRepr.Handle_StepRepr_ShapeAspect

        """
        return _StepShape.Handle_StepShape_DimensionalLocation_RelatedShapeAspect(self, *args)


    def SetRelatedShapeAspect(self, *args):
        """
        SetRelatedShapeAspect(Handle_StepShape_DimensionalLocation self, Handle_StepRepr_ShapeAspect RelatedShapeAspect)

        Set field RelatedShapeAspect

        :type RelatedShapeAspect: OCC.wrapper.StepRepr.Handle_StepRepr_ShapeAspect

        """
        return _StepShape.Handle_StepShape_DimensionalLocation_SetRelatedShapeAspect(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepShape_DimensionalLocation self)

        Memory deallocator for transient classes


        """
        return _StepShape.Handle_StepShape_DimensionalLocation_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepShape_DimensionalLocation self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepShape_DimensionalLocation self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.Handle_StepShape_DimensionalLocation_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepShape_DimensionalLocation self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepShape_DimensionalLocation self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.Handle_StepShape_DimensionalLocation_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepShape_DimensionalLocation self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepShape.Handle_StepShape_DimensionalLocation_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepShape_DimensionalLocation self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_DimensionalLocation_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepShape_DimensionalLocation self)

        Increments the reference counter of this object


        """
        return _StepShape.Handle_StepShape_DimensionalLocation_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepShape_DimensionalLocation self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_DimensionalLocation_DecrementRefCounter(self, *args)

Handle_StepShape_DimensionalLocation_swigregister = _StepShape.Handle_StepShape_DimensionalLocation_swigregister
Handle_StepShape_DimensionalLocation_swigregister(Handle_StepShape_DimensionalLocation)

def Handle_StepShape_DimensionalLocation_DownCast(thing):
    return _StepShape.Handle_StepShape_DimensionalLocation_DownCast(thing)
Handle_StepShape_DimensionalLocation_DownCast = _StepShape.Handle_StepShape_DimensionalLocation_DownCast

class Handle_StepShape_ShapeRepresentation(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepShape_ShapeRepresentation self)

        Nullify the handle


        """
        return _StepShape.Handle_StepShape_ShapeRepresentation_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepShape_ShapeRepresentation self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepShape.Handle_StepShape_ShapeRepresentation_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepShape_ShapeRepresentation self, StepShape_ShapeRepresentation thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepShape.Handle_StepShape_ShapeRepresentation_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepShape_ShapeRepresentation self, Handle_StepShape_ShapeRepresentation theHandle) -> Handle_StepShape_ShapeRepresentation
        assign(Handle_StepShape_ShapeRepresentation self, StepShape_ShapeRepresentation thePtr) -> Handle_StepShape_ShapeRepresentation
        assign(Handle_StepShape_ShapeRepresentation self, Handle_StepShape_ShapeRepresentation theHandle) -> Handle_StepShape_ShapeRepresentation

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepShape.Handle_StepShape_ShapeRepresentation_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepShape_ShapeRepresentation self) -> StepShape_ShapeRepresentation

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepShape.Handle_StepShape_ShapeRepresentation_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepShape_ShapeRepresentation self) -> StepShape_ShapeRepresentation

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepShape.Handle_StepShape_ShapeRepresentation___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepShape_ShapeRepresentation self) -> StepShape_ShapeRepresentation

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepShape.Handle_StepShape_ShapeRepresentation___ref__(self, *args)


    def __hash__(self):
        return _StepShape.Handle_StepShape_ShapeRepresentation___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepShape.Handle_StepShape_ShapeRepresentation___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepShape.new_Handle_StepShape_ShapeRepresentation(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepShape.Handle_StepShape_ShapeRepresentation_DownCast)
    __swig_destroy__ = _StepShape.delete_Handle_StepShape_ShapeRepresentation

    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepShape_ShapeRepresentation self) -> char const *

        :rtype: const char *

        """
        return _StepShape.Handle_StepShape_ShapeRepresentation_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.Handle_StepShape_ShapeRepresentation_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.Handle_StepShape_ShapeRepresentation_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Init(self, *args):
        """
        Init(Handle_StepShape_ShapeRepresentation self, Handle_TCollection_HAsciiString aName, Handle_StepRepr_HArray1OfRepresentationItem aItems, Handle_StepRepr_RepresentationContext aContextOfItems)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aItems: OCC.wrapper.StepRepr.Handle_StepRepr_HArray1OfRepresentationItem
        :type aContextOfItems: OCC.wrapper.StepRepr.Handle_StepRepr_RepresentationContext

        """
        return _StepShape.Handle_StepShape_ShapeRepresentation_Init(self, *args)


    def SetName(self, *args):
        """
        SetName(Handle_StepShape_ShapeRepresentation self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepShape.Handle_StepShape_ShapeRepresentation_SetName(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepShape_ShapeRepresentation self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepShape.Handle_StepShape_ShapeRepresentation_Name(self, *args)


    def SetItems(self, *args):
        """
        SetItems(Handle_StepShape_ShapeRepresentation self, Handle_StepRepr_HArray1OfRepresentationItem aItems)

        :type aItems: OCC.wrapper.StepRepr.Handle_StepRepr_HArray1OfRepresentationItem

        """
        return _StepShape.Handle_StepShape_ShapeRepresentation_SetItems(self, *args)


    def Items(self, *args):
        """
        Items(Handle_StepShape_ShapeRepresentation self) -> Handle_StepRepr_HArray1OfRepresentationItem

        :rtype: OCC.wrapper.StepRepr.Handle_StepRepr_HArray1OfRepresentationItem

        """
        return _StepShape.Handle_StepShape_ShapeRepresentation_Items(self, *args)


    def ItemsValue(self, *args):
        """
        ItemsValue(Handle_StepShape_ShapeRepresentation self, Standard_Integer const num) -> Handle_StepRepr_RepresentationItem

        :type num: int
        :rtype: OCC.wrapper.StepRepr.Handle_StepRepr_RepresentationItem

        """
        return _StepShape.Handle_StepShape_ShapeRepresentation_ItemsValue(self, *args)


    def NbItems(self, *args):
        """
        NbItems(Handle_StepShape_ShapeRepresentation self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_ShapeRepresentation_NbItems(self, *args)


    def SetContextOfItems(self, *args):
        """
        SetContextOfItems(Handle_StepShape_ShapeRepresentation self, Handle_StepRepr_RepresentationContext aContextOfItems)

        :type aContextOfItems: OCC.wrapper.StepRepr.Handle_StepRepr_RepresentationContext

        """
        return _StepShape.Handle_StepShape_ShapeRepresentation_SetContextOfItems(self, *args)


    def ContextOfItems(self, *args):
        """
        ContextOfItems(Handle_StepShape_ShapeRepresentation self) -> Handle_StepRepr_RepresentationContext

        :rtype: OCC.wrapper.StepRepr.Handle_StepRepr_RepresentationContext

        """
        return _StepShape.Handle_StepShape_ShapeRepresentation_ContextOfItems(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepShape_ShapeRepresentation self)

        Memory deallocator for transient classes


        """
        return _StepShape.Handle_StepShape_ShapeRepresentation_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepShape_ShapeRepresentation self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepShape_ShapeRepresentation self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.Handle_StepShape_ShapeRepresentation_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepShape_ShapeRepresentation self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepShape_ShapeRepresentation self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.Handle_StepShape_ShapeRepresentation_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepShape_ShapeRepresentation self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepShape.Handle_StepShape_ShapeRepresentation_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepShape_ShapeRepresentation self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_ShapeRepresentation_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepShape_ShapeRepresentation self)

        Increments the reference counter of this object


        """
        return _StepShape.Handle_StepShape_ShapeRepresentation_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepShape_ShapeRepresentation self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_ShapeRepresentation_DecrementRefCounter(self, *args)

Handle_StepShape_ShapeRepresentation_swigregister = _StepShape.Handle_StepShape_ShapeRepresentation_swigregister
Handle_StepShape_ShapeRepresentation_swigregister(Handle_StepShape_ShapeRepresentation)

def Handle_StepShape_ShapeRepresentation_DownCast(thing):
    return _StepShape.Handle_StepShape_ShapeRepresentation_DownCast(thing)
Handle_StepShape_ShapeRepresentation_DownCast = _StepShape.Handle_StepShape_ShapeRepresentation_DownCast

class NCollection_Array1_StepShape_GeometricSetSelect(object):
    """
    Purpose:     The class Array1 represents unidimensional arrays 
    of fixed size known at run time. 
    The range of the index is user defined.
    An array1 can be constructed with a "C array".
    This functionality is useful to call methods expecting
    an Array1. It allows to carry the bounds inside the arrays.

    Examples:    Item tab[100]; //  An example with a C array
    Array1OfItem ttab (tab[0],1,100);

    Array1OfItem tttab (ttab(10),10,20); // a slice of ttab

    If you want to reindex an array from 1 to Length do :

    Array1 tab1(tab(tab.Lower()),1,tab.Length());

    Warning:     Programs client of such a class must be independant
    of the range of the first element. Then, a C++ for
    loop must be written like this

    for (i = A.Lower(); i <= A.Upper(); i++)

    Changes:     In  comparison  to  TCollection  the  flag  isAllocated  was
    renamed into myDeletable (alike in  the Array2).  For naming
    compatibility the method IsAllocated remained in class along
    with IsDeletable.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Array1_StepShape_GeometricSetSelect self) -> NCollection_Array1< StepShape_GeometricSetSelect >::iterator

        Returns an iterator pointing to the first element in the array.

        :rtype: iterator

        """
        return _StepShape.NCollection_Array1_StepShape_GeometricSetSelect_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Array1_StepShape_GeometricSetSelect self) -> NCollection_Array1< StepShape_GeometricSetSelect >::iterator

        Returns an iterator referring to the past-the-end element in the array.

        :rtype: iterator

        """
        return _StepShape.NCollection_Array1_StepShape_GeometricSetSelect_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Array1_StepShape_GeometricSetSelect self) -> NCollection_Array1< StepShape_GeometricSetSelect >::const_iterator

        Returns a const iterator pointing to the first element in the array.

        :rtype: const_iterator

        """
        return _StepShape.NCollection_Array1_StepShape_GeometricSetSelect_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Array1_StepShape_GeometricSetSelect self) -> NCollection_Array1< StepShape_GeometricSetSelect >::const_iterator

        Returns a const iterator referring to the past-the-end element in the array.

        :rtype: const_iterator

        """
        return _StepShape.NCollection_Array1_StepShape_GeometricSetSelect_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     The class Array1 represents unidimensional arrays 
        of fixed size known at run time. 
        The range of the index is user defined.
        An array1 can be constructed with a "C array".
        This functionality is useful to call methods expecting
        an Array1. It allows to carry the bounds inside the arrays.

        Examples:    Item tab[100]; //  An example with a C array
        Array1OfItem ttab (tab[0],1,100);

        Array1OfItem tttab (ttab(10),10,20); // a slice of ttab

        If you want to reindex an array from 1 to Length do :

        Array1 tab1(tab(tab.Lower()),1,tab.Length());

        Warning:     Programs client of such a class must be independant
        of the range of the first element. Then, a C++ for
        loop must be written like this

        for (i = A.Lower(); i <= A.Upper(); i++)

        Changes:     In  comparison  to  TCollection  the  flag  isAllocated  was
        renamed into myDeletable (alike in  the Array2).  For naming
        compatibility the method IsAllocated remained in class along
        with IsDeletable.
        """
        this = _StepShape.new_NCollection_Array1_StepShape_GeometricSetSelect(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(NCollection_Array1_StepShape_GeometricSetSelect self, StepShape_GeometricSetSelect theValue)

        Initialise the items with theValue

        :type theValue: const TheItemType &

        """
        return _StepShape.NCollection_Array1_StepShape_GeometricSetSelect_Init(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_Array1_StepShape_GeometricSetSelect self) -> Standard_Integer

        Size query

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.NCollection_Array1_StepShape_GeometricSetSelect_Size(self, *args)


    def Length(self, *args):
        """
        Length(NCollection_Array1_StepShape_GeometricSetSelect self) -> Standard_Integer

        Length query (the same)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.NCollection_Array1_StepShape_GeometricSetSelect_Length(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Array1_StepShape_GeometricSetSelect self) -> Standard_Boolean

        Return TRUE if array has zero length.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.NCollection_Array1_StepShape_GeometricSetSelect_IsEmpty(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Array1_StepShape_GeometricSetSelect self) -> Standard_Integer

        Lower bound

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.NCollection_Array1_StepShape_GeometricSetSelect_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Array1_StepShape_GeometricSetSelect self) -> Standard_Integer

        Upper bound

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.NCollection_Array1_StepShape_GeometricSetSelect_Upper(self, *args)


    def IsDeletable(self, *args):
        """
        IsDeletable(NCollection_Array1_StepShape_GeometricSetSelect self) -> Standard_Boolean

        myDeletable flag

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.NCollection_Array1_StepShape_GeometricSetSelect_IsDeletable(self, *args)


    def IsAllocated(self, *args):
        """
        IsAllocated(NCollection_Array1_StepShape_GeometricSetSelect self) -> Standard_Boolean

        IsAllocated flag - for naming compatibility

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.NCollection_Array1_StepShape_GeometricSetSelect_IsAllocated(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Array1_StepShape_GeometricSetSelect self, NCollection_Array1_StepShape_GeometricSetSelect theOther) -> NCollection_Array1_StepShape_GeometricSetSelect

        Copies data of theOther array to this.
        This array should be pre-allocated and have the same length as theOther;
        otherwise exception Standard_DimensionMismatch is thrown.

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _StepShape.NCollection_Array1_StepShape_GeometricSetSelect_Assign(self, *args)


    def Move(self, *args):
        """
        Move(NCollection_Array1_StepShape_GeometricSetSelect self, NCollection_Array1_StepShape_GeometricSetSelect theOther) -> NCollection_Array1_StepShape_GeometricSetSelect

        Move assignment.
        This array will borrow all the data from theOther.
        The moved object will keep pointer to the memory buffer and
        range, but it will not free the buffer on destruction.

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _StepShape.NCollection_Array1_StepShape_GeometricSetSelect_Move(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Array1_StepShape_GeometricSetSelect self, NCollection_Array1_StepShape_GeometricSetSelect theOther) -> NCollection_Array1_StepShape_GeometricSetSelect
        assign(NCollection_Array1_StepShape_GeometricSetSelect self, NCollection_Array1_StepShape_GeometricSetSelect theOther) -> NCollection_Array1_StepShape_GeometricSetSelect

        Move assignment operator; @sa Move()

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1<TheItemType> &&
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _StepShape.NCollection_Array1_StepShape_GeometricSetSelect_assign(self, *args)


    def First(self, *args):
        """
        @return first element

        :rtype: const TheItemType &

        """
        res = _StepShape.NCollection_Array1_StepShape_GeometricSetSelect_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Array1_StepShape_GeometricSetSelect self) -> StepShape_GeometricSetSelect

        @return first element

        :rtype: TheItemType &

        """
        return _StepShape.NCollection_Array1_StepShape_GeometricSetSelect_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        @return last element

        :rtype: const TheItemType &

        """
        res = _StepShape.NCollection_Array1_StepShape_GeometricSetSelect_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Array1_StepShape_GeometricSetSelect self) -> StepShape_GeometricSetSelect

        @return last element

        :rtype: TheItemType &

        """
        return _StepShape.NCollection_Array1_StepShape_GeometricSetSelect_ChangeLast(self, *args)


    def Value(self, *args):
        """
        Constant value access

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _StepShape.NCollection_Array1_StepShape_GeometricSetSelect_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Array1_StepShape_GeometricSetSelect self, Standard_Integer const theIndex) -> StepShape_GeometricSetSelect

        Variable value access

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _StepShape.NCollection_Array1_StepShape_GeometricSetSelect_ChangeValue(self, *args)


    def __call__(self, *args):
        """
        operator() - alias to Value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _StepShape.NCollection_Array1_StepShape_GeometricSetSelect___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __getitem__(self, *args):
        """
        operator[] - alias to Value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _StepShape.NCollection_Array1_StepShape_GeometricSetSelect_at(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetValue(self, *args):
        """
        SetValue(NCollection_Array1_StepShape_GeometricSetSelect self, Standard_Integer const theIndex, StepShape_GeometricSetSelect theItem)

        Set value 

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _StepShape.NCollection_Array1_StepShape_GeometricSetSelect_SetValue(self, *args)


    def Resize(self, *args):
        """
        Resize(NCollection_Array1_StepShape_GeometricSetSelect self, Standard_Integer const theLower, Standard_Integer const theUpper, Standard_Boolean const theToCopyData)

        Resizes the array to specified bounds.
        No re-allocation will be done if length of array does not change,
        but existing values will not be discarded if theToCopyData set to FALSE.
        @param theLower new lower bound of array
        @param theUpper new upper bound of array
        @param theToCopyData flag to copy existing data into new array

        :type theLower: int
        :type theUpper: int
        :type theToCopyData: bool

        """
        return _StepShape.NCollection_Array1_StepShape_GeometricSetSelect_Resize(self, *args)

    __swig_destroy__ = _StepShape.delete_NCollection_Array1_StepShape_GeometricSetSelect
NCollection_Array1_StepShape_GeometricSetSelect_swigregister = _StepShape.NCollection_Array1_StepShape_GeometricSetSelect_swigregister
NCollection_Array1_StepShape_GeometricSetSelect_swigregister(NCollection_Array1_StepShape_GeometricSetSelect)


try:
	StepShape_Array1OfGeometricSetSelect = NCollection_Array1_StepShape_GeometricSetSelect
except NameError:
	pass # does not exist, probably ignored

class Handle_StepShape_GeometricallyBoundedSurfaceShapeRepresentation(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepShape_GeometricallyBoundedSurfaceShapeRepresentation self)

        Nullify the handle


        """
        return _StepShape.Handle_StepShape_GeometricallyBoundedSurfaceShapeRepresentation_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepShape_GeometricallyBoundedSurfaceShapeRepresentation self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepShape.Handle_StepShape_GeometricallyBoundedSurfaceShapeRepresentation_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepShape_GeometricallyBoundedSurfaceShapeRepresentation self, StepShape_GeometricallyBoundedSurfaceShapeRepresentation thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepShape.Handle_StepShape_GeometricallyBoundedSurfaceShapeRepresentation_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepShape_GeometricallyBoundedSurfaceShapeRepresentation self, Handle_StepShape_GeometricallyBoundedSurfaceShapeRepresentation theHandle) -> Handle_StepShape_GeometricallyBoundedSurfaceShapeRepresentation
        assign(Handle_StepShape_GeometricallyBoundedSurfaceShapeRepresentation self, StepShape_GeometricallyBoundedSurfaceShapeRepresentation thePtr) -> Handle_StepShape_GeometricallyBoundedSurfaceShapeRepresentation
        assign(Handle_StepShape_GeometricallyBoundedSurfaceShapeRepresentation self, Handle_StepShape_GeometricallyBoundedSurfaceShapeRepresentation theHandle) -> Handle_StepShape_GeometricallyBoundedSurfaceShapeRepresentation

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepShape.Handle_StepShape_GeometricallyBoundedSurfaceShapeRepresentation_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepShape_GeometricallyBoundedSurfaceShapeRepresentation self) -> StepShape_GeometricallyBoundedSurfaceShapeRepresentation

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepShape.Handle_StepShape_GeometricallyBoundedSurfaceShapeRepresentation_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepShape_GeometricallyBoundedSurfaceShapeRepresentation self) -> StepShape_GeometricallyBoundedSurfaceShapeRepresentation

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepShape.Handle_StepShape_GeometricallyBoundedSurfaceShapeRepresentation___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepShape_GeometricallyBoundedSurfaceShapeRepresentation self) -> StepShape_GeometricallyBoundedSurfaceShapeRepresentation

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepShape.Handle_StepShape_GeometricallyBoundedSurfaceShapeRepresentation___ref__(self, *args)


    def __hash__(self):
        return _StepShape.Handle_StepShape_GeometricallyBoundedSurfaceShapeRepresentation___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepShape.Handle_StepShape_GeometricallyBoundedSurfaceShapeRepresentation___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepShape.new_Handle_StepShape_GeometricallyBoundedSurfaceShapeRepresentation(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepShape.Handle_StepShape_GeometricallyBoundedSurfaceShapeRepresentation_DownCast)
    __swig_destroy__ = _StepShape.delete_Handle_StepShape_GeometricallyBoundedSurfaceShapeRepresentation

    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepShape_GeometricallyBoundedSurfaceShapeRepresentation self) -> char const *

        :rtype: const char *

        """
        return _StepShape.Handle_StepShape_GeometricallyBoundedSurfaceShapeRepresentation_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.Handle_StepShape_GeometricallyBoundedSurfaceShapeRepresentation_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.Handle_StepShape_GeometricallyBoundedSurfaceShapeRepresentation_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Init(self, *args):
        """
        Init(Handle_StepShape_GeometricallyBoundedSurfaceShapeRepresentation self, Handle_TCollection_HAsciiString aName, Handle_StepRepr_HArray1OfRepresentationItem aItems, Handle_StepRepr_RepresentationContext aContextOfItems)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aItems: OCC.wrapper.StepRepr.Handle_StepRepr_HArray1OfRepresentationItem
        :type aContextOfItems: OCC.wrapper.StepRepr.Handle_StepRepr_RepresentationContext

        """
        return _StepShape.Handle_StepShape_GeometricallyBoundedSurfaceShapeRepresentation_Init(self, *args)


    def SetName(self, *args):
        """
        SetName(Handle_StepShape_GeometricallyBoundedSurfaceShapeRepresentation self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepShape.Handle_StepShape_GeometricallyBoundedSurfaceShapeRepresentation_SetName(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepShape_GeometricallyBoundedSurfaceShapeRepresentation self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepShape.Handle_StepShape_GeometricallyBoundedSurfaceShapeRepresentation_Name(self, *args)


    def SetItems(self, *args):
        """
        SetItems(Handle_StepShape_GeometricallyBoundedSurfaceShapeRepresentation self, Handle_StepRepr_HArray1OfRepresentationItem aItems)

        :type aItems: OCC.wrapper.StepRepr.Handle_StepRepr_HArray1OfRepresentationItem

        """
        return _StepShape.Handle_StepShape_GeometricallyBoundedSurfaceShapeRepresentation_SetItems(self, *args)


    def Items(self, *args):
        """
        Items(Handle_StepShape_GeometricallyBoundedSurfaceShapeRepresentation self) -> Handle_StepRepr_HArray1OfRepresentationItem

        :rtype: OCC.wrapper.StepRepr.Handle_StepRepr_HArray1OfRepresentationItem

        """
        return _StepShape.Handle_StepShape_GeometricallyBoundedSurfaceShapeRepresentation_Items(self, *args)


    def ItemsValue(self, *args):
        """
        ItemsValue(Handle_StepShape_GeometricallyBoundedSurfaceShapeRepresentation self, Standard_Integer const num) -> Handle_StepRepr_RepresentationItem

        :type num: int
        :rtype: OCC.wrapper.StepRepr.Handle_StepRepr_RepresentationItem

        """
        return _StepShape.Handle_StepShape_GeometricallyBoundedSurfaceShapeRepresentation_ItemsValue(self, *args)


    def NbItems(self, *args):
        """
        NbItems(Handle_StepShape_GeometricallyBoundedSurfaceShapeRepresentation self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_GeometricallyBoundedSurfaceShapeRepresentation_NbItems(self, *args)


    def SetContextOfItems(self, *args):
        """
        SetContextOfItems(Handle_StepShape_GeometricallyBoundedSurfaceShapeRepresentation self, Handle_StepRepr_RepresentationContext aContextOfItems)

        :type aContextOfItems: OCC.wrapper.StepRepr.Handle_StepRepr_RepresentationContext

        """
        return _StepShape.Handle_StepShape_GeometricallyBoundedSurfaceShapeRepresentation_SetContextOfItems(self, *args)


    def ContextOfItems(self, *args):
        """
        ContextOfItems(Handle_StepShape_GeometricallyBoundedSurfaceShapeRepresentation self) -> Handle_StepRepr_RepresentationContext

        :rtype: OCC.wrapper.StepRepr.Handle_StepRepr_RepresentationContext

        """
        return _StepShape.Handle_StepShape_GeometricallyBoundedSurfaceShapeRepresentation_ContextOfItems(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepShape_GeometricallyBoundedSurfaceShapeRepresentation self)

        Memory deallocator for transient classes


        """
        return _StepShape.Handle_StepShape_GeometricallyBoundedSurfaceShapeRepresentation_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepShape_GeometricallyBoundedSurfaceShapeRepresentation self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepShape_GeometricallyBoundedSurfaceShapeRepresentation self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.Handle_StepShape_GeometricallyBoundedSurfaceShapeRepresentation_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepShape_GeometricallyBoundedSurfaceShapeRepresentation self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepShape_GeometricallyBoundedSurfaceShapeRepresentation self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.Handle_StepShape_GeometricallyBoundedSurfaceShapeRepresentation_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepShape_GeometricallyBoundedSurfaceShapeRepresentation self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepShape.Handle_StepShape_GeometricallyBoundedSurfaceShapeRepresentation_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepShape_GeometricallyBoundedSurfaceShapeRepresentation self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_GeometricallyBoundedSurfaceShapeRepresentation_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepShape_GeometricallyBoundedSurfaceShapeRepresentation self)

        Increments the reference counter of this object


        """
        return _StepShape.Handle_StepShape_GeometricallyBoundedSurfaceShapeRepresentation_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepShape_GeometricallyBoundedSurfaceShapeRepresentation self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_GeometricallyBoundedSurfaceShapeRepresentation_DecrementRefCounter(self, *args)

Handle_StepShape_GeometricallyBoundedSurfaceShapeRepresentation_swigregister = _StepShape.Handle_StepShape_GeometricallyBoundedSurfaceShapeRepresentation_swigregister
Handle_StepShape_GeometricallyBoundedSurfaceShapeRepresentation_swigregister(Handle_StepShape_GeometricallyBoundedSurfaceShapeRepresentation)

def Handle_StepShape_GeometricallyBoundedSurfaceShapeRepresentation_DownCast(thing):
    return _StepShape.Handle_StepShape_GeometricallyBoundedSurfaceShapeRepresentation_DownCast(thing)
Handle_StepShape_GeometricallyBoundedSurfaceShapeRepresentation_DownCast = _StepShape.Handle_StepShape_GeometricallyBoundedSurfaceShapeRepresentation_DownCast

class Handle_StepShape_HArray1OfShell(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepShape_HArray1OfShell self)

        Nullify the handle


        """
        return _StepShape.Handle_StepShape_HArray1OfShell_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepShape_HArray1OfShell self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepShape.Handle_StepShape_HArray1OfShell_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepShape_HArray1OfShell self, StepShape_HArray1OfShell thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepShape.Handle_StepShape_HArray1OfShell_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepShape_HArray1OfShell self, Handle_StepShape_HArray1OfShell theHandle) -> Handle_StepShape_HArray1OfShell
        assign(Handle_StepShape_HArray1OfShell self, StepShape_HArray1OfShell thePtr) -> Handle_StepShape_HArray1OfShell
        assign(Handle_StepShape_HArray1OfShell self, Handle_StepShape_HArray1OfShell theHandle) -> Handle_StepShape_HArray1OfShell

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepShape.Handle_StepShape_HArray1OfShell_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepShape_HArray1OfShell self) -> StepShape_HArray1OfShell

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepShape.Handle_StepShape_HArray1OfShell_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepShape_HArray1OfShell self) -> StepShape_HArray1OfShell

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepShape.Handle_StepShape_HArray1OfShell___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepShape_HArray1OfShell self) -> StepShape_HArray1OfShell

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepShape.Handle_StepShape_HArray1OfShell___ref__(self, *args)


    def __hash__(self):
        return _StepShape.Handle_StepShape_HArray1OfShell___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepShape.Handle_StepShape_HArray1OfShell___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepShape.new_Handle_StepShape_HArray1OfShell(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepShape.Handle_StepShape_HArray1OfShell_DownCast)
    __swig_destroy__ = _StepShape.delete_Handle_StepShape_HArray1OfShell

    def Array1(self, *args):
        """
        :rtype: OCC.wrapper.StepShape.StepShape_Array1OfShell

        """
        res = _StepShape.Handle_StepShape_HArray1OfShell_Array1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeArray1(self, *args):
        """
        ChangeArray1(Handle_StepShape_HArray1OfShell self) -> NCollection_Array1_StepShape_Shell

        :rtype: OCC.wrapper.StepShape.StepShape_Array1OfShell

        """
        return _StepShape.Handle_StepShape_HArray1OfShell_ChangeArray1(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepShape_HArray1OfShell self) -> char const *

        :rtype: const char *

        """
        return _StepShape.Handle_StepShape_HArray1OfShell_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.Handle_StepShape_HArray1OfShell_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.Handle_StepShape_HArray1OfShell_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_StepShape_HArray1OfShell self)

        Memory deallocator for transient classes


        """
        return _StepShape.Handle_StepShape_HArray1OfShell_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepShape_HArray1OfShell self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepShape_HArray1OfShell self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.Handle_StepShape_HArray1OfShell_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepShape_HArray1OfShell self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepShape_HArray1OfShell self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.Handle_StepShape_HArray1OfShell_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepShape_HArray1OfShell self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepShape.Handle_StepShape_HArray1OfShell_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepShape_HArray1OfShell self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_HArray1OfShell_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepShape_HArray1OfShell self)

        Increments the reference counter of this object


        """
        return _StepShape.Handle_StepShape_HArray1OfShell_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepShape_HArray1OfShell self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_HArray1OfShell_DecrementRefCounter(self, *args)

Handle_StepShape_HArray1OfShell_swigregister = _StepShape.Handle_StepShape_HArray1OfShell_swigregister
Handle_StepShape_HArray1OfShell_swigregister(Handle_StepShape_HArray1OfShell)

def Handle_StepShape_HArray1OfShell_DownCast(thing):
    return _StepShape.Handle_StepShape_HArray1OfShell_DownCast(thing)
Handle_StepShape_HArray1OfShell_DownCast = _StepShape.Handle_StepShape_HArray1OfShell_DownCast

class Handle_StepShape_Face(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepShape_Face self)

        Nullify the handle


        """
        return _StepShape.Handle_StepShape_Face_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepShape_Face self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepShape.Handle_StepShape_Face_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepShape_Face self, StepShape_Face thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepShape.Handle_StepShape_Face_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepShape_Face self, Handle_StepShape_Face theHandle) -> Handle_StepShape_Face
        assign(Handle_StepShape_Face self, StepShape_Face thePtr) -> Handle_StepShape_Face
        assign(Handle_StepShape_Face self, Handle_StepShape_Face theHandle) -> Handle_StepShape_Face

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepShape.Handle_StepShape_Face_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepShape_Face self) -> StepShape_Face

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepShape.Handle_StepShape_Face_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepShape_Face self) -> StepShape_Face

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepShape.Handle_StepShape_Face___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepShape_Face self) -> StepShape_Face

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepShape.Handle_StepShape_Face___ref__(self, *args)


    def __hash__(self):
        return _StepShape.Handle_StepShape_Face___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepShape.Handle_StepShape_Face___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepShape.new_Handle_StepShape_Face(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepShape.Handle_StepShape_Face_DownCast)
    __swig_destroy__ = _StepShape.delete_Handle_StepShape_Face

    def Init(self, *args):
        """
        Init(Handle_StepShape_Face self, Handle_TCollection_HAsciiString aName, Handle_StepShape_HArray1OfFaceBound aBounds)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aBounds: OCC.wrapper.StepShape.Handle_StepShape_HArray1OfFaceBound

        """
        return _StepShape.Handle_StepShape_Face_Init(self, *args)


    def SetBounds(self, *args):
        """
        SetBounds(Handle_StepShape_Face self, Handle_StepShape_HArray1OfFaceBound aBounds)

        :type aBounds: OCC.wrapper.StepShape.Handle_StepShape_HArray1OfFaceBound

        """
        return _StepShape.Handle_StepShape_Face_SetBounds(self, *args)


    def Bounds(self, *args):
        """
        Bounds(Handle_StepShape_Face self) -> Handle_StepShape_HArray1OfFaceBound

        :rtype: OCC.wrapper.StepShape.Handle_StepShape_HArray1OfFaceBound

        """
        return _StepShape.Handle_StepShape_Face_Bounds(self, *args)


    def BoundsValue(self, *args):
        """
        BoundsValue(Handle_StepShape_Face self, Standard_Integer const num) -> Handle_StepShape_FaceBound

        :type num: int
        :rtype: OCC.wrapper.StepShape.Handle_StepShape_FaceBound

        """
        return _StepShape.Handle_StepShape_Face_BoundsValue(self, *args)


    def NbBounds(self, *args):
        """
        NbBounds(Handle_StepShape_Face self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_Face_NbBounds(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepShape_Face self) -> char const *

        :rtype: const char *

        """
        return _StepShape.Handle_StepShape_Face_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.Handle_StepShape_Face_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.Handle_StepShape_Face_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetName(self, *args):
        """
        SetName(Handle_StepShape_Face self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepShape.Handle_StepShape_Face_SetName(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepShape_Face self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepShape.Handle_StepShape_Face_Name(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepShape_Face self)

        Memory deallocator for transient classes


        """
        return _StepShape.Handle_StepShape_Face_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepShape_Face self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepShape_Face self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.Handle_StepShape_Face_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepShape_Face self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepShape_Face self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.Handle_StepShape_Face_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepShape_Face self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepShape.Handle_StepShape_Face_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepShape_Face self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_Face_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepShape_Face self)

        Increments the reference counter of this object


        """
        return _StepShape.Handle_StepShape_Face_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepShape_Face self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_Face_DecrementRefCounter(self, *args)

Handle_StepShape_Face_swigregister = _StepShape.Handle_StepShape_Face_swigregister
Handle_StepShape_Face_swigregister(Handle_StepShape_Face)

def Handle_StepShape_Face_DownCast(thing):
    return _StepShape.Handle_StepShape_Face_DownCast(thing)
Handle_StepShape_Face_DownCast = _StepShape.Handle_StepShape_Face_DownCast

class StepShape_CsgPrimitive(StepData.StepData_SelectType):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(StepShape_CsgPrimitive self) -> StepShape_CsgPrimitive

        Returns a CsgPrimitive SelectType


        """
        this = _StepShape.new_StepShape_CsgPrimitive(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def CaseNum(self, *args):
        """
        CaseNum(StepShape_CsgPrimitive self, Handle_Standard_Transient ent) -> Standard_Integer

        Recognizes a CsgPrimitive Kind Entity that is :
        1 -> Sphere
        2 -> Block
        3 -> RightAngularWedge
        4 -> Torus
        5 -> RightCircularCone
        6 -> RightCircularCylinder
        0 else

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.StepShape_CsgPrimitive_CaseNum(self, *args)


    def Sphere(self, *args):
        """
        Sphere(StepShape_CsgPrimitive self) -> Handle_StepShape_Sphere

        returns Value as a Sphere (Null if another type)

        :rtype: OCC.wrapper.StepShape.Handle_StepShape_Sphere

        """
        return _StepShape.StepShape_CsgPrimitive_Sphere(self, *args)


    def Block(self, *args):
        """
        Block(StepShape_CsgPrimitive self) -> Handle_StepShape_Block

        returns Value as a Block (Null if another type)

        :rtype: OCC.wrapper.StepShape.Handle_StepShape_Block

        """
        return _StepShape.StepShape_CsgPrimitive_Block(self, *args)


    def RightAngularWedge(self, *args):
        """
        RightAngularWedge(StepShape_CsgPrimitive self) -> Handle_StepShape_RightAngularWedge

        returns Value as a RightAngularWedge (Null if another type)

        :rtype: OCC.wrapper.StepShape.Handle_StepShape_RightAngularWedge

        """
        return _StepShape.StepShape_CsgPrimitive_RightAngularWedge(self, *args)


    def Torus(self, *args):
        """
        Torus(StepShape_CsgPrimitive self) -> Handle_StepShape_Torus

        returns Value as a Torus (Null if another type)

        :rtype: OCC.wrapper.StepShape.Handle_StepShape_Torus

        """
        return _StepShape.StepShape_CsgPrimitive_Torus(self, *args)


    def RightCircularCone(self, *args):
        """
        RightCircularCone(StepShape_CsgPrimitive self) -> Handle_StepShape_RightCircularCone

        returns Value as a RightCircularCone (Null if another type)

        :rtype: OCC.wrapper.StepShape.Handle_StepShape_RightCircularCone

        """
        return _StepShape.StepShape_CsgPrimitive_RightCircularCone(self, *args)


    def RightCircularCylinder(self, *args):
        """
        RightCircularCylinder(StepShape_CsgPrimitive self) -> Handle_StepShape_RightCircularCylinder

        returns Value as a RightCircularCylinder (Null if another type)

        :rtype: OCC.wrapper.StepShape.Handle_StepShape_RightCircularCylinder

        """
        return _StepShape.StepShape_CsgPrimitive_RightCircularCylinder(self, *args)

    __swig_destroy__ = _StepShape.delete_StepShape_CsgPrimitive
StepShape_CsgPrimitive_swigregister = _StepShape.StepShape_CsgPrimitive_swigregister
StepShape_CsgPrimitive_swigregister(StepShape_CsgPrimitive)

class Handle_StepShape_HArray1OfGeometricSetSelect(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepShape_HArray1OfGeometricSetSelect self)

        Nullify the handle


        """
        return _StepShape.Handle_StepShape_HArray1OfGeometricSetSelect_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepShape_HArray1OfGeometricSetSelect self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepShape.Handle_StepShape_HArray1OfGeometricSetSelect_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepShape_HArray1OfGeometricSetSelect self, StepShape_HArray1OfGeometricSetSelect thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepShape.Handle_StepShape_HArray1OfGeometricSetSelect_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepShape_HArray1OfGeometricSetSelect self, Handle_StepShape_HArray1OfGeometricSetSelect theHandle) -> Handle_StepShape_HArray1OfGeometricSetSelect
        assign(Handle_StepShape_HArray1OfGeometricSetSelect self, StepShape_HArray1OfGeometricSetSelect thePtr) -> Handle_StepShape_HArray1OfGeometricSetSelect
        assign(Handle_StepShape_HArray1OfGeometricSetSelect self, Handle_StepShape_HArray1OfGeometricSetSelect theHandle) -> Handle_StepShape_HArray1OfGeometricSetSelect

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepShape.Handle_StepShape_HArray1OfGeometricSetSelect_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepShape_HArray1OfGeometricSetSelect self) -> StepShape_HArray1OfGeometricSetSelect

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepShape.Handle_StepShape_HArray1OfGeometricSetSelect_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepShape_HArray1OfGeometricSetSelect self) -> StepShape_HArray1OfGeometricSetSelect

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepShape.Handle_StepShape_HArray1OfGeometricSetSelect___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepShape_HArray1OfGeometricSetSelect self) -> StepShape_HArray1OfGeometricSetSelect

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepShape.Handle_StepShape_HArray1OfGeometricSetSelect___ref__(self, *args)


    def __hash__(self):
        return _StepShape.Handle_StepShape_HArray1OfGeometricSetSelect___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepShape.Handle_StepShape_HArray1OfGeometricSetSelect___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepShape.new_Handle_StepShape_HArray1OfGeometricSetSelect(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepShape.Handle_StepShape_HArray1OfGeometricSetSelect_DownCast)
    __swig_destroy__ = _StepShape.delete_Handle_StepShape_HArray1OfGeometricSetSelect

    def Array1(self, *args):
        """
        :rtype: OCC.wrapper.StepShape.StepShape_Array1OfGeometricSetSelect

        """
        res = _StepShape.Handle_StepShape_HArray1OfGeometricSetSelect_Array1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeArray1(self, *args):
        """
        ChangeArray1(Handle_StepShape_HArray1OfGeometricSetSelect self) -> NCollection_Array1_StepShape_GeometricSetSelect

        :rtype: OCC.wrapper.StepShape.StepShape_Array1OfGeometricSetSelect

        """
        return _StepShape.Handle_StepShape_HArray1OfGeometricSetSelect_ChangeArray1(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepShape_HArray1OfGeometricSetSelect self) -> char const *

        :rtype: const char *

        """
        return _StepShape.Handle_StepShape_HArray1OfGeometricSetSelect_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.Handle_StepShape_HArray1OfGeometricSetSelect_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.Handle_StepShape_HArray1OfGeometricSetSelect_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_StepShape_HArray1OfGeometricSetSelect self)

        Memory deallocator for transient classes


        """
        return _StepShape.Handle_StepShape_HArray1OfGeometricSetSelect_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepShape_HArray1OfGeometricSetSelect self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepShape_HArray1OfGeometricSetSelect self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.Handle_StepShape_HArray1OfGeometricSetSelect_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepShape_HArray1OfGeometricSetSelect self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepShape_HArray1OfGeometricSetSelect self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.Handle_StepShape_HArray1OfGeometricSetSelect_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepShape_HArray1OfGeometricSetSelect self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepShape.Handle_StepShape_HArray1OfGeometricSetSelect_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepShape_HArray1OfGeometricSetSelect self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_HArray1OfGeometricSetSelect_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepShape_HArray1OfGeometricSetSelect self)

        Increments the reference counter of this object


        """
        return _StepShape.Handle_StepShape_HArray1OfGeometricSetSelect_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepShape_HArray1OfGeometricSetSelect self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_HArray1OfGeometricSetSelect_DecrementRefCounter(self, *args)

Handle_StepShape_HArray1OfGeometricSetSelect_swigregister = _StepShape.Handle_StepShape_HArray1OfGeometricSetSelect_swigregister
Handle_StepShape_HArray1OfGeometricSetSelect_swigregister(Handle_StepShape_HArray1OfGeometricSetSelect)

def Handle_StepShape_HArray1OfGeometricSetSelect_DownCast(thing):
    return _StepShape.Handle_StepShape_HArray1OfGeometricSetSelect_DownCast(thing)
Handle_StepShape_HArray1OfGeometricSetSelect_DownCast = _StepShape.Handle_StepShape_HArray1OfGeometricSetSelect_DownCast

class Handle_StepShape_GeometricallyBoundedWireframeShapeRepresentation(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepShape_GeometricallyBoundedWireframeShapeRepresentation self)

        Nullify the handle


        """
        return _StepShape.Handle_StepShape_GeometricallyBoundedWireframeShapeRepresentation_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepShape_GeometricallyBoundedWireframeShapeRepresentation self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepShape.Handle_StepShape_GeometricallyBoundedWireframeShapeRepresentation_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepShape_GeometricallyBoundedWireframeShapeRepresentation self, StepShape_GeometricallyBoundedWireframeShapeRepresentation thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepShape.Handle_StepShape_GeometricallyBoundedWireframeShapeRepresentation_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepShape_GeometricallyBoundedWireframeShapeRepresentation self, Handle_StepShape_GeometricallyBoundedWireframeShapeRepresentation theHandle) -> Handle_StepShape_GeometricallyBoundedWireframeShapeRepresentation
        assign(Handle_StepShape_GeometricallyBoundedWireframeShapeRepresentation self, StepShape_GeometricallyBoundedWireframeShapeRepresentation thePtr) -> Handle_StepShape_GeometricallyBoundedWireframeShapeRepresentation
        assign(Handle_StepShape_GeometricallyBoundedWireframeShapeRepresentation self, Handle_StepShape_GeometricallyBoundedWireframeShapeRepresentation theHandle) -> Handle_StepShape_GeometricallyBoundedWireframeShapeRepresentation

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepShape.Handle_StepShape_GeometricallyBoundedWireframeShapeRepresentation_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepShape_GeometricallyBoundedWireframeShapeRepresentation self) -> StepShape_GeometricallyBoundedWireframeShapeRepresentation

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepShape.Handle_StepShape_GeometricallyBoundedWireframeShapeRepresentation_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepShape_GeometricallyBoundedWireframeShapeRepresentation self) -> StepShape_GeometricallyBoundedWireframeShapeRepresentation

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepShape.Handle_StepShape_GeometricallyBoundedWireframeShapeRepresentation___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepShape_GeometricallyBoundedWireframeShapeRepresentation self) -> StepShape_GeometricallyBoundedWireframeShapeRepresentation

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepShape.Handle_StepShape_GeometricallyBoundedWireframeShapeRepresentation___ref__(self, *args)


    def __hash__(self):
        return _StepShape.Handle_StepShape_GeometricallyBoundedWireframeShapeRepresentation___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepShape.Handle_StepShape_GeometricallyBoundedWireframeShapeRepresentation___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepShape.new_Handle_StepShape_GeometricallyBoundedWireframeShapeRepresentation(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepShape.Handle_StepShape_GeometricallyBoundedWireframeShapeRepresentation_DownCast)
    __swig_destroy__ = _StepShape.delete_Handle_StepShape_GeometricallyBoundedWireframeShapeRepresentation

    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepShape_GeometricallyBoundedWireframeShapeRepresentation self) -> char const *

        :rtype: const char *

        """
        return _StepShape.Handle_StepShape_GeometricallyBoundedWireframeShapeRepresentation_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.Handle_StepShape_GeometricallyBoundedWireframeShapeRepresentation_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.Handle_StepShape_GeometricallyBoundedWireframeShapeRepresentation_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Init(self, *args):
        """
        Init(Handle_StepShape_GeometricallyBoundedWireframeShapeRepresentation self, Handle_TCollection_HAsciiString aName, Handle_StepRepr_HArray1OfRepresentationItem aItems, Handle_StepRepr_RepresentationContext aContextOfItems)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aItems: OCC.wrapper.StepRepr.Handle_StepRepr_HArray1OfRepresentationItem
        :type aContextOfItems: OCC.wrapper.StepRepr.Handle_StepRepr_RepresentationContext

        """
        return _StepShape.Handle_StepShape_GeometricallyBoundedWireframeShapeRepresentation_Init(self, *args)


    def SetName(self, *args):
        """
        SetName(Handle_StepShape_GeometricallyBoundedWireframeShapeRepresentation self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepShape.Handle_StepShape_GeometricallyBoundedWireframeShapeRepresentation_SetName(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepShape_GeometricallyBoundedWireframeShapeRepresentation self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepShape.Handle_StepShape_GeometricallyBoundedWireframeShapeRepresentation_Name(self, *args)


    def SetItems(self, *args):
        """
        SetItems(Handle_StepShape_GeometricallyBoundedWireframeShapeRepresentation self, Handle_StepRepr_HArray1OfRepresentationItem aItems)

        :type aItems: OCC.wrapper.StepRepr.Handle_StepRepr_HArray1OfRepresentationItem

        """
        return _StepShape.Handle_StepShape_GeometricallyBoundedWireframeShapeRepresentation_SetItems(self, *args)


    def Items(self, *args):
        """
        Items(Handle_StepShape_GeometricallyBoundedWireframeShapeRepresentation self) -> Handle_StepRepr_HArray1OfRepresentationItem

        :rtype: OCC.wrapper.StepRepr.Handle_StepRepr_HArray1OfRepresentationItem

        """
        return _StepShape.Handle_StepShape_GeometricallyBoundedWireframeShapeRepresentation_Items(self, *args)


    def ItemsValue(self, *args):
        """
        ItemsValue(Handle_StepShape_GeometricallyBoundedWireframeShapeRepresentation self, Standard_Integer const num) -> Handle_StepRepr_RepresentationItem

        :type num: int
        :rtype: OCC.wrapper.StepRepr.Handle_StepRepr_RepresentationItem

        """
        return _StepShape.Handle_StepShape_GeometricallyBoundedWireframeShapeRepresentation_ItemsValue(self, *args)


    def NbItems(self, *args):
        """
        NbItems(Handle_StepShape_GeometricallyBoundedWireframeShapeRepresentation self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_GeometricallyBoundedWireframeShapeRepresentation_NbItems(self, *args)


    def SetContextOfItems(self, *args):
        """
        SetContextOfItems(Handle_StepShape_GeometricallyBoundedWireframeShapeRepresentation self, Handle_StepRepr_RepresentationContext aContextOfItems)

        :type aContextOfItems: OCC.wrapper.StepRepr.Handle_StepRepr_RepresentationContext

        """
        return _StepShape.Handle_StepShape_GeometricallyBoundedWireframeShapeRepresentation_SetContextOfItems(self, *args)


    def ContextOfItems(self, *args):
        """
        ContextOfItems(Handle_StepShape_GeometricallyBoundedWireframeShapeRepresentation self) -> Handle_StepRepr_RepresentationContext

        :rtype: OCC.wrapper.StepRepr.Handle_StepRepr_RepresentationContext

        """
        return _StepShape.Handle_StepShape_GeometricallyBoundedWireframeShapeRepresentation_ContextOfItems(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepShape_GeometricallyBoundedWireframeShapeRepresentation self)

        Memory deallocator for transient classes


        """
        return _StepShape.Handle_StepShape_GeometricallyBoundedWireframeShapeRepresentation_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepShape_GeometricallyBoundedWireframeShapeRepresentation self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepShape_GeometricallyBoundedWireframeShapeRepresentation self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.Handle_StepShape_GeometricallyBoundedWireframeShapeRepresentation_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepShape_GeometricallyBoundedWireframeShapeRepresentation self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepShape_GeometricallyBoundedWireframeShapeRepresentation self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.Handle_StepShape_GeometricallyBoundedWireframeShapeRepresentation_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepShape_GeometricallyBoundedWireframeShapeRepresentation self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepShape.Handle_StepShape_GeometricallyBoundedWireframeShapeRepresentation_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepShape_GeometricallyBoundedWireframeShapeRepresentation self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_GeometricallyBoundedWireframeShapeRepresentation_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepShape_GeometricallyBoundedWireframeShapeRepresentation self)

        Increments the reference counter of this object


        """
        return _StepShape.Handle_StepShape_GeometricallyBoundedWireframeShapeRepresentation_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepShape_GeometricallyBoundedWireframeShapeRepresentation self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_GeometricallyBoundedWireframeShapeRepresentation_DecrementRefCounter(self, *args)

Handle_StepShape_GeometricallyBoundedWireframeShapeRepresentation_swigregister = _StepShape.Handle_StepShape_GeometricallyBoundedWireframeShapeRepresentation_swigregister
Handle_StepShape_GeometricallyBoundedWireframeShapeRepresentation_swigregister(Handle_StepShape_GeometricallyBoundedWireframeShapeRepresentation)

def Handle_StepShape_GeometricallyBoundedWireframeShapeRepresentation_DownCast(thing):
    return _StepShape.Handle_StepShape_GeometricallyBoundedWireframeShapeRepresentation_DownCast(thing)
Handle_StepShape_GeometricallyBoundedWireframeShapeRepresentation_DownCast = _StepShape.Handle_StepShape_GeometricallyBoundedWireframeShapeRepresentation_DownCast

class Handle_StepShape_FacetedBrepAndBrepWithVoids(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepShape_FacetedBrepAndBrepWithVoids self)

        Nullify the handle


        """
        return _StepShape.Handle_StepShape_FacetedBrepAndBrepWithVoids_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepShape_FacetedBrepAndBrepWithVoids self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepShape.Handle_StepShape_FacetedBrepAndBrepWithVoids_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepShape_FacetedBrepAndBrepWithVoids self, StepShape_FacetedBrepAndBrepWithVoids thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepShape.Handle_StepShape_FacetedBrepAndBrepWithVoids_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepShape_FacetedBrepAndBrepWithVoids self, Handle_StepShape_FacetedBrepAndBrepWithVoids theHandle) -> Handle_StepShape_FacetedBrepAndBrepWithVoids
        assign(Handle_StepShape_FacetedBrepAndBrepWithVoids self, StepShape_FacetedBrepAndBrepWithVoids thePtr) -> Handle_StepShape_FacetedBrepAndBrepWithVoids
        assign(Handle_StepShape_FacetedBrepAndBrepWithVoids self, Handle_StepShape_FacetedBrepAndBrepWithVoids theHandle) -> Handle_StepShape_FacetedBrepAndBrepWithVoids

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepShape.Handle_StepShape_FacetedBrepAndBrepWithVoids_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepShape_FacetedBrepAndBrepWithVoids self) -> StepShape_FacetedBrepAndBrepWithVoids

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepShape.Handle_StepShape_FacetedBrepAndBrepWithVoids_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepShape_FacetedBrepAndBrepWithVoids self) -> StepShape_FacetedBrepAndBrepWithVoids

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepShape.Handle_StepShape_FacetedBrepAndBrepWithVoids___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepShape_FacetedBrepAndBrepWithVoids self) -> StepShape_FacetedBrepAndBrepWithVoids

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepShape.Handle_StepShape_FacetedBrepAndBrepWithVoids___ref__(self, *args)


    def __hash__(self):
        return _StepShape.Handle_StepShape_FacetedBrepAndBrepWithVoids___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepShape.Handle_StepShape_FacetedBrepAndBrepWithVoids___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepShape.new_Handle_StepShape_FacetedBrepAndBrepWithVoids(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepShape.Handle_StepShape_FacetedBrepAndBrepWithVoids_DownCast)
    __swig_destroy__ = _StepShape.delete_Handle_StepShape_FacetedBrepAndBrepWithVoids

    def Init(self, *args):
        """
        Init(Handle_StepShape_FacetedBrepAndBrepWithVoids self, Handle_TCollection_HAsciiString aName, Handle_StepShape_ClosedShell aOuter, Handle_StepShape_FacetedBrep aFacetedBrep, Handle_StepShape_BrepWithVoids aBrepWithVoids)
        Init(Handle_StepShape_FacetedBrepAndBrepWithVoids self, Handle_TCollection_HAsciiString aName, Handle_StepShape_ClosedShell aOuter, Handle_StepShape_HArray1OfOrientedClosedShell aVoids)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aOuter: OCC.wrapper.StepShape.Handle_StepShape_ClosedShell
        :type aVoids: OCC.wrapper.StepShape.Handle_StepShape_HArray1OfOrientedClosedShell

        """
        return _StepShape.Handle_StepShape_FacetedBrepAndBrepWithVoids_Init(self, *args)


    def SetFacetedBrep(self, *args):
        """
        SetFacetedBrep(Handle_StepShape_FacetedBrepAndBrepWithVoids self, Handle_StepShape_FacetedBrep aFacetedBrep)

        :type aFacetedBrep: OCC.wrapper.StepShape.Handle_StepShape_FacetedBrep

        """
        return _StepShape.Handle_StepShape_FacetedBrepAndBrepWithVoids_SetFacetedBrep(self, *args)


    def FacetedBrep(self, *args):
        """
        FacetedBrep(Handle_StepShape_FacetedBrepAndBrepWithVoids self) -> Handle_StepShape_FacetedBrep

        :rtype: OCC.wrapper.StepShape.Handle_StepShape_FacetedBrep

        """
        return _StepShape.Handle_StepShape_FacetedBrepAndBrepWithVoids_FacetedBrep(self, *args)


    def SetBrepWithVoids(self, *args):
        """
        SetBrepWithVoids(Handle_StepShape_FacetedBrepAndBrepWithVoids self, Handle_StepShape_BrepWithVoids aBrepWithVoids)

        :type aBrepWithVoids: OCC.wrapper.StepShape.Handle_StepShape_BrepWithVoids

        """
        return _StepShape.Handle_StepShape_FacetedBrepAndBrepWithVoids_SetBrepWithVoids(self, *args)


    def BrepWithVoids(self, *args):
        """
        BrepWithVoids(Handle_StepShape_FacetedBrepAndBrepWithVoids self) -> Handle_StepShape_BrepWithVoids

        :rtype: OCC.wrapper.StepShape.Handle_StepShape_BrepWithVoids

        """
        return _StepShape.Handle_StepShape_FacetedBrepAndBrepWithVoids_BrepWithVoids(self, *args)


    def SetVoids(self, *args):
        """
        SetVoids(Handle_StepShape_FacetedBrepAndBrepWithVoids self, Handle_StepShape_HArray1OfOrientedClosedShell aVoids)

        :type aVoids: OCC.wrapper.StepShape.Handle_StepShape_HArray1OfOrientedClosedShell

        """
        return _StepShape.Handle_StepShape_FacetedBrepAndBrepWithVoids_SetVoids(self, *args)


    def Voids(self, *args):
        """
        Voids(Handle_StepShape_FacetedBrepAndBrepWithVoids self) -> Handle_StepShape_HArray1OfOrientedClosedShell

        :rtype: OCC.wrapper.StepShape.Handle_StepShape_HArray1OfOrientedClosedShell

        """
        return _StepShape.Handle_StepShape_FacetedBrepAndBrepWithVoids_Voids(self, *args)


    def VoidsValue(self, *args):
        """
        VoidsValue(Handle_StepShape_FacetedBrepAndBrepWithVoids self, Standard_Integer const num) -> Handle_StepShape_OrientedClosedShell

        :type num: int
        :rtype: OCC.wrapper.StepShape.Handle_StepShape_OrientedClosedShell

        """
        return _StepShape.Handle_StepShape_FacetedBrepAndBrepWithVoids_VoidsValue(self, *args)


    def NbVoids(self, *args):
        """
        NbVoids(Handle_StepShape_FacetedBrepAndBrepWithVoids self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_FacetedBrepAndBrepWithVoids_NbVoids(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepShape_FacetedBrepAndBrepWithVoids self) -> char const *

        :rtype: const char *

        """
        return _StepShape.Handle_StepShape_FacetedBrepAndBrepWithVoids_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.Handle_StepShape_FacetedBrepAndBrepWithVoids_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.Handle_StepShape_FacetedBrepAndBrepWithVoids_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetOuter(self, *args):
        """
        SetOuter(Handle_StepShape_FacetedBrepAndBrepWithVoids self, Handle_StepShape_ConnectedFaceSet aOuter)

        :type aOuter: OCC.wrapper.StepShape.Handle_StepShape_ConnectedFaceSet

        """
        return _StepShape.Handle_StepShape_FacetedBrepAndBrepWithVoids_SetOuter(self, *args)


    def Outer(self, *args):
        """
        Outer(Handle_StepShape_FacetedBrepAndBrepWithVoids self) -> Handle_StepShape_ConnectedFaceSet

        :rtype: OCC.wrapper.StepShape.Handle_StepShape_ConnectedFaceSet

        """
        return _StepShape.Handle_StepShape_FacetedBrepAndBrepWithVoids_Outer(self, *args)


    def SetName(self, *args):
        """
        SetName(Handle_StepShape_FacetedBrepAndBrepWithVoids self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepShape.Handle_StepShape_FacetedBrepAndBrepWithVoids_SetName(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepShape_FacetedBrepAndBrepWithVoids self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepShape.Handle_StepShape_FacetedBrepAndBrepWithVoids_Name(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepShape_FacetedBrepAndBrepWithVoids self)

        Memory deallocator for transient classes


        """
        return _StepShape.Handle_StepShape_FacetedBrepAndBrepWithVoids_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepShape_FacetedBrepAndBrepWithVoids self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepShape_FacetedBrepAndBrepWithVoids self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.Handle_StepShape_FacetedBrepAndBrepWithVoids_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepShape_FacetedBrepAndBrepWithVoids self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepShape_FacetedBrepAndBrepWithVoids self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.Handle_StepShape_FacetedBrepAndBrepWithVoids_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepShape_FacetedBrepAndBrepWithVoids self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepShape.Handle_StepShape_FacetedBrepAndBrepWithVoids_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepShape_FacetedBrepAndBrepWithVoids self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_FacetedBrepAndBrepWithVoids_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepShape_FacetedBrepAndBrepWithVoids self)

        Increments the reference counter of this object


        """
        return _StepShape.Handle_StepShape_FacetedBrepAndBrepWithVoids_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepShape_FacetedBrepAndBrepWithVoids self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_FacetedBrepAndBrepWithVoids_DecrementRefCounter(self, *args)

Handle_StepShape_FacetedBrepAndBrepWithVoids_swigregister = _StepShape.Handle_StepShape_FacetedBrepAndBrepWithVoids_swigregister
Handle_StepShape_FacetedBrepAndBrepWithVoids_swigregister(Handle_StepShape_FacetedBrepAndBrepWithVoids)

def Handle_StepShape_FacetedBrepAndBrepWithVoids_DownCast(thing):
    return _StepShape.Handle_StepShape_FacetedBrepAndBrepWithVoids_DownCast(thing)
Handle_StepShape_FacetedBrepAndBrepWithVoids_DownCast = _StepShape.Handle_StepShape_FacetedBrepAndBrepWithVoids_DownCast

class Handle_StepShape_DefinitionalRepresentationAndShapeRepresentation(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepShape_DefinitionalRepresentationAndShapeRepresentation self)

        Nullify the handle


        """
        return _StepShape.Handle_StepShape_DefinitionalRepresentationAndShapeRepresentation_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepShape_DefinitionalRepresentationAndShapeRepresentation self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepShape.Handle_StepShape_DefinitionalRepresentationAndShapeRepresentation_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepShape_DefinitionalRepresentationAndShapeRepresentation self, StepShape_DefinitionalRepresentationAndShapeRepresentation thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepShape.Handle_StepShape_DefinitionalRepresentationAndShapeRepresentation_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepShape_DefinitionalRepresentationAndShapeRepresentation self, Handle_StepShape_DefinitionalRepresentationAndShapeRepresentation theHandle) -> Handle_StepShape_DefinitionalRepresentationAndShapeRepresentation
        assign(Handle_StepShape_DefinitionalRepresentationAndShapeRepresentation self, StepShape_DefinitionalRepresentationAndShapeRepresentation thePtr) -> Handle_StepShape_DefinitionalRepresentationAndShapeRepresentation
        assign(Handle_StepShape_DefinitionalRepresentationAndShapeRepresentation self, Handle_StepShape_DefinitionalRepresentationAndShapeRepresentation theHandle) -> Handle_StepShape_DefinitionalRepresentationAndShapeRepresentation

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepShape.Handle_StepShape_DefinitionalRepresentationAndShapeRepresentation_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepShape_DefinitionalRepresentationAndShapeRepresentation self) -> StepShape_DefinitionalRepresentationAndShapeRepresentation

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepShape.Handle_StepShape_DefinitionalRepresentationAndShapeRepresentation_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepShape_DefinitionalRepresentationAndShapeRepresentation self) -> StepShape_DefinitionalRepresentationAndShapeRepresentation

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepShape.Handle_StepShape_DefinitionalRepresentationAndShapeRepresentation___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepShape_DefinitionalRepresentationAndShapeRepresentation self) -> StepShape_DefinitionalRepresentationAndShapeRepresentation

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepShape.Handle_StepShape_DefinitionalRepresentationAndShapeRepresentation___ref__(self, *args)


    def __hash__(self):
        return _StepShape.Handle_StepShape_DefinitionalRepresentationAndShapeRepresentation___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepShape.Handle_StepShape_DefinitionalRepresentationAndShapeRepresentation___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepShape.new_Handle_StepShape_DefinitionalRepresentationAndShapeRepresentation(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepShape.Handle_StepShape_DefinitionalRepresentationAndShapeRepresentation_DownCast)
    __swig_destroy__ = _StepShape.delete_Handle_StepShape_DefinitionalRepresentationAndShapeRepresentation

    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepShape_DefinitionalRepresentationAndShapeRepresentation self) -> char const *

        :rtype: const char *

        """
        return _StepShape.Handle_StepShape_DefinitionalRepresentationAndShapeRepresentation_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.Handle_StepShape_DefinitionalRepresentationAndShapeRepresentation_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.Handle_StepShape_DefinitionalRepresentationAndShapeRepresentation_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Init(self, *args):
        """
        Init(Handle_StepShape_DefinitionalRepresentationAndShapeRepresentation self, Handle_TCollection_HAsciiString aName, Handle_StepRepr_HArray1OfRepresentationItem aItems, Handle_StepRepr_RepresentationContext aContextOfItems)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aItems: OCC.wrapper.StepRepr.Handle_StepRepr_HArray1OfRepresentationItem
        :type aContextOfItems: OCC.wrapper.StepRepr.Handle_StepRepr_RepresentationContext

        """
        return _StepShape.Handle_StepShape_DefinitionalRepresentationAndShapeRepresentation_Init(self, *args)


    def SetName(self, *args):
        """
        SetName(Handle_StepShape_DefinitionalRepresentationAndShapeRepresentation self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepShape.Handle_StepShape_DefinitionalRepresentationAndShapeRepresentation_SetName(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepShape_DefinitionalRepresentationAndShapeRepresentation self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepShape.Handle_StepShape_DefinitionalRepresentationAndShapeRepresentation_Name(self, *args)


    def SetItems(self, *args):
        """
        SetItems(Handle_StepShape_DefinitionalRepresentationAndShapeRepresentation self, Handle_StepRepr_HArray1OfRepresentationItem aItems)

        :type aItems: OCC.wrapper.StepRepr.Handle_StepRepr_HArray1OfRepresentationItem

        """
        return _StepShape.Handle_StepShape_DefinitionalRepresentationAndShapeRepresentation_SetItems(self, *args)


    def Items(self, *args):
        """
        Items(Handle_StepShape_DefinitionalRepresentationAndShapeRepresentation self) -> Handle_StepRepr_HArray1OfRepresentationItem

        :rtype: OCC.wrapper.StepRepr.Handle_StepRepr_HArray1OfRepresentationItem

        """
        return _StepShape.Handle_StepShape_DefinitionalRepresentationAndShapeRepresentation_Items(self, *args)


    def ItemsValue(self, *args):
        """
        ItemsValue(Handle_StepShape_DefinitionalRepresentationAndShapeRepresentation self, Standard_Integer const num) -> Handle_StepRepr_RepresentationItem

        :type num: int
        :rtype: OCC.wrapper.StepRepr.Handle_StepRepr_RepresentationItem

        """
        return _StepShape.Handle_StepShape_DefinitionalRepresentationAndShapeRepresentation_ItemsValue(self, *args)


    def NbItems(self, *args):
        """
        NbItems(Handle_StepShape_DefinitionalRepresentationAndShapeRepresentation self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_DefinitionalRepresentationAndShapeRepresentation_NbItems(self, *args)


    def SetContextOfItems(self, *args):
        """
        SetContextOfItems(Handle_StepShape_DefinitionalRepresentationAndShapeRepresentation self, Handle_StepRepr_RepresentationContext aContextOfItems)

        :type aContextOfItems: OCC.wrapper.StepRepr.Handle_StepRepr_RepresentationContext

        """
        return _StepShape.Handle_StepShape_DefinitionalRepresentationAndShapeRepresentation_SetContextOfItems(self, *args)


    def ContextOfItems(self, *args):
        """
        ContextOfItems(Handle_StepShape_DefinitionalRepresentationAndShapeRepresentation self) -> Handle_StepRepr_RepresentationContext

        :rtype: OCC.wrapper.StepRepr.Handle_StepRepr_RepresentationContext

        """
        return _StepShape.Handle_StepShape_DefinitionalRepresentationAndShapeRepresentation_ContextOfItems(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepShape_DefinitionalRepresentationAndShapeRepresentation self)

        Memory deallocator for transient classes


        """
        return _StepShape.Handle_StepShape_DefinitionalRepresentationAndShapeRepresentation_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepShape_DefinitionalRepresentationAndShapeRepresentation self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepShape_DefinitionalRepresentationAndShapeRepresentation self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.Handle_StepShape_DefinitionalRepresentationAndShapeRepresentation_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepShape_DefinitionalRepresentationAndShapeRepresentation self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepShape_DefinitionalRepresentationAndShapeRepresentation self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.Handle_StepShape_DefinitionalRepresentationAndShapeRepresentation_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepShape_DefinitionalRepresentationAndShapeRepresentation self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepShape.Handle_StepShape_DefinitionalRepresentationAndShapeRepresentation_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepShape_DefinitionalRepresentationAndShapeRepresentation self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_DefinitionalRepresentationAndShapeRepresentation_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepShape_DefinitionalRepresentationAndShapeRepresentation self)

        Increments the reference counter of this object


        """
        return _StepShape.Handle_StepShape_DefinitionalRepresentationAndShapeRepresentation_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepShape_DefinitionalRepresentationAndShapeRepresentation self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_DefinitionalRepresentationAndShapeRepresentation_DecrementRefCounter(self, *args)

Handle_StepShape_DefinitionalRepresentationAndShapeRepresentation_swigregister = _StepShape.Handle_StepShape_DefinitionalRepresentationAndShapeRepresentation_swigregister
Handle_StepShape_DefinitionalRepresentationAndShapeRepresentation_swigregister(Handle_StepShape_DefinitionalRepresentationAndShapeRepresentation)

def Handle_StepShape_DefinitionalRepresentationAndShapeRepresentation_DownCast(thing):
    return _StepShape.Handle_StepShape_DefinitionalRepresentationAndShapeRepresentation_DownCast(thing)
Handle_StepShape_DefinitionalRepresentationAndShapeRepresentation_DownCast = _StepShape.Handle_StepShape_DefinitionalRepresentationAndShapeRepresentation_DownCast

class StepShape_ToleranceMethodDefinition(StepData.StepData_SelectType):
    """Added for Dimensional Tolerances"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(StepShape_ToleranceMethodDefinition self) -> StepShape_ToleranceMethodDefinition

        Added for Dimensional Tolerances
        """
        this = _StepShape.new_StepShape_ToleranceMethodDefinition(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def CaseNum(self, *args):
        """
        CaseNum(StepShape_ToleranceMethodDefinition self, Handle_Standard_Transient ent) -> Standard_Integer

        Recognizes a kind of ValueQualifier Select Type :
        1 -> ToleranceValue from StepShape
        2 -> LimitsAndFits from StepShape

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.StepShape_ToleranceMethodDefinition_CaseNum(self, *args)


    def ToleranceValue(self, *args):
        """
        ToleranceValue(StepShape_ToleranceMethodDefinition self) -> Handle_StepShape_ToleranceValue

        Returns Value as ToleranceValue

        :rtype: OCC.wrapper.StepShape.Handle_StepShape_ToleranceValue

        """
        return _StepShape.StepShape_ToleranceMethodDefinition_ToleranceValue(self, *args)


    def LimitsAndFits(self, *args):
        """
        LimitsAndFits(StepShape_ToleranceMethodDefinition self) -> Handle_StepShape_LimitsAndFits

        Returns Value as LimitsAndFits

        :rtype: OCC.wrapper.StepShape.Handle_StepShape_LimitsAndFits

        """
        return _StepShape.StepShape_ToleranceMethodDefinition_LimitsAndFits(self, *args)

    __swig_destroy__ = _StepShape.delete_StepShape_ToleranceMethodDefinition
StepShape_ToleranceMethodDefinition_swigregister = _StepShape.StepShape_ToleranceMethodDefinition_swigregister
StepShape_ToleranceMethodDefinition_swigregister(StepShape_ToleranceMethodDefinition)

class NCollection_Array1_StepShape_Shell(object):
    """
    Purpose:     The class Array1 represents unidimensional arrays 
    of fixed size known at run time. 
    The range of the index is user defined.
    An array1 can be constructed with a "C array".
    This functionality is useful to call methods expecting
    an Array1. It allows to carry the bounds inside the arrays.

    Examples:    Item tab[100]; //  An example with a C array
    Array1OfItem ttab (tab[0],1,100);

    Array1OfItem tttab (ttab(10),10,20); // a slice of ttab

    If you want to reindex an array from 1 to Length do :

    Array1 tab1(tab(tab.Lower()),1,tab.Length());

    Warning:     Programs client of such a class must be independant
    of the range of the first element. Then, a C++ for
    loop must be written like this

    for (i = A.Lower(); i <= A.Upper(); i++)

    Changes:     In  comparison  to  TCollection  the  flag  isAllocated  was
    renamed into myDeletable (alike in  the Array2).  For naming
    compatibility the method IsAllocated remained in class along
    with IsDeletable.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Array1_StepShape_Shell self) -> NCollection_Array1< StepShape_Shell >::iterator

        Returns an iterator pointing to the first element in the array.

        :rtype: iterator

        """
        return _StepShape.NCollection_Array1_StepShape_Shell_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Array1_StepShape_Shell self) -> NCollection_Array1< StepShape_Shell >::iterator

        Returns an iterator referring to the past-the-end element in the array.

        :rtype: iterator

        """
        return _StepShape.NCollection_Array1_StepShape_Shell_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Array1_StepShape_Shell self) -> NCollection_Array1< StepShape_Shell >::const_iterator

        Returns a const iterator pointing to the first element in the array.

        :rtype: const_iterator

        """
        return _StepShape.NCollection_Array1_StepShape_Shell_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Array1_StepShape_Shell self) -> NCollection_Array1< StepShape_Shell >::const_iterator

        Returns a const iterator referring to the past-the-end element in the array.

        :rtype: const_iterator

        """
        return _StepShape.NCollection_Array1_StepShape_Shell_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     The class Array1 represents unidimensional arrays 
        of fixed size known at run time. 
        The range of the index is user defined.
        An array1 can be constructed with a "C array".
        This functionality is useful to call methods expecting
        an Array1. It allows to carry the bounds inside the arrays.

        Examples:    Item tab[100]; //  An example with a C array
        Array1OfItem ttab (tab[0],1,100);

        Array1OfItem tttab (ttab(10),10,20); // a slice of ttab

        If you want to reindex an array from 1 to Length do :

        Array1 tab1(tab(tab.Lower()),1,tab.Length());

        Warning:     Programs client of such a class must be independant
        of the range of the first element. Then, a C++ for
        loop must be written like this

        for (i = A.Lower(); i <= A.Upper(); i++)

        Changes:     In  comparison  to  TCollection  the  flag  isAllocated  was
        renamed into myDeletable (alike in  the Array2).  For naming
        compatibility the method IsAllocated remained in class along
        with IsDeletable.
        """
        this = _StepShape.new_NCollection_Array1_StepShape_Shell(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(NCollection_Array1_StepShape_Shell self, StepShape_Shell theValue)

        Initialise the items with theValue

        :type theValue: const TheItemType &

        """
        return _StepShape.NCollection_Array1_StepShape_Shell_Init(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_Array1_StepShape_Shell self) -> Standard_Integer

        Size query

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.NCollection_Array1_StepShape_Shell_Size(self, *args)


    def Length(self, *args):
        """
        Length(NCollection_Array1_StepShape_Shell self) -> Standard_Integer

        Length query (the same)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.NCollection_Array1_StepShape_Shell_Length(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Array1_StepShape_Shell self) -> Standard_Boolean

        Return TRUE if array has zero length.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.NCollection_Array1_StepShape_Shell_IsEmpty(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Array1_StepShape_Shell self) -> Standard_Integer

        Lower bound

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.NCollection_Array1_StepShape_Shell_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Array1_StepShape_Shell self) -> Standard_Integer

        Upper bound

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.NCollection_Array1_StepShape_Shell_Upper(self, *args)


    def IsDeletable(self, *args):
        """
        IsDeletable(NCollection_Array1_StepShape_Shell self) -> Standard_Boolean

        myDeletable flag

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.NCollection_Array1_StepShape_Shell_IsDeletable(self, *args)


    def IsAllocated(self, *args):
        """
        IsAllocated(NCollection_Array1_StepShape_Shell self) -> Standard_Boolean

        IsAllocated flag - for naming compatibility

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.NCollection_Array1_StepShape_Shell_IsAllocated(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Array1_StepShape_Shell self, NCollection_Array1_StepShape_Shell theOther) -> NCollection_Array1_StepShape_Shell

        Copies data of theOther array to this.
        This array should be pre-allocated and have the same length as theOther;
        otherwise exception Standard_DimensionMismatch is thrown.

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _StepShape.NCollection_Array1_StepShape_Shell_Assign(self, *args)


    def Move(self, *args):
        """
        Move(NCollection_Array1_StepShape_Shell self, NCollection_Array1_StepShape_Shell theOther) -> NCollection_Array1_StepShape_Shell

        Move assignment.
        This array will borrow all the data from theOther.
        The moved object will keep pointer to the memory buffer and
        range, but it will not free the buffer on destruction.

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _StepShape.NCollection_Array1_StepShape_Shell_Move(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Array1_StepShape_Shell self, NCollection_Array1_StepShape_Shell theOther) -> NCollection_Array1_StepShape_Shell
        assign(NCollection_Array1_StepShape_Shell self, NCollection_Array1_StepShape_Shell theOther) -> NCollection_Array1_StepShape_Shell

        Move assignment operator; @sa Move()

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1<TheItemType> &&
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _StepShape.NCollection_Array1_StepShape_Shell_assign(self, *args)


    def First(self, *args):
        """
        @return first element

        :rtype: const TheItemType &

        """
        res = _StepShape.NCollection_Array1_StepShape_Shell_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Array1_StepShape_Shell self) -> StepShape_Shell

        @return first element

        :rtype: TheItemType &

        """
        return _StepShape.NCollection_Array1_StepShape_Shell_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        @return last element

        :rtype: const TheItemType &

        """
        res = _StepShape.NCollection_Array1_StepShape_Shell_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Array1_StepShape_Shell self) -> StepShape_Shell

        @return last element

        :rtype: TheItemType &

        """
        return _StepShape.NCollection_Array1_StepShape_Shell_ChangeLast(self, *args)


    def Value(self, *args):
        """
        Constant value access

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _StepShape.NCollection_Array1_StepShape_Shell_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Array1_StepShape_Shell self, Standard_Integer const theIndex) -> StepShape_Shell

        Variable value access

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _StepShape.NCollection_Array1_StepShape_Shell_ChangeValue(self, *args)


    def __call__(self, *args):
        """
        operator() - alias to Value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _StepShape.NCollection_Array1_StepShape_Shell___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __getitem__(self, *args):
        """
        operator[] - alias to Value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _StepShape.NCollection_Array1_StepShape_Shell_at(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetValue(self, *args):
        """
        SetValue(NCollection_Array1_StepShape_Shell self, Standard_Integer const theIndex, StepShape_Shell theItem)

        Set value 

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _StepShape.NCollection_Array1_StepShape_Shell_SetValue(self, *args)


    def Resize(self, *args):
        """
        Resize(NCollection_Array1_StepShape_Shell self, Standard_Integer const theLower, Standard_Integer const theUpper, Standard_Boolean const theToCopyData)

        Resizes the array to specified bounds.
        No re-allocation will be done if length of array does not change,
        but existing values will not be discarded if theToCopyData set to FALSE.
        @param theLower new lower bound of array
        @param theUpper new upper bound of array
        @param theToCopyData flag to copy existing data into new array

        :type theLower: int
        :type theUpper: int
        :type theToCopyData: bool

        """
        return _StepShape.NCollection_Array1_StepShape_Shell_Resize(self, *args)

    __swig_destroy__ = _StepShape.delete_NCollection_Array1_StepShape_Shell
NCollection_Array1_StepShape_Shell_swigregister = _StepShape.NCollection_Array1_StepShape_Shell_swigregister
NCollection_Array1_StepShape_Shell_swigregister(NCollection_Array1_StepShape_Shell)


try:
	StepShape_Array1OfShell = NCollection_Array1_StepShape_Shell
except NameError:
	pass # does not exist, probably ignored

class Handle_StepShape_MeasureRepresentationItemAndQualifiedRepresentationItem(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepShape_MeasureRepresentationItemAndQualifiedRepresentationItem self)

        Nullify the handle


        """
        return _StepShape.Handle_StepShape_MeasureRepresentationItemAndQualifiedRepresentationItem_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepShape_MeasureRepresentationItemAndQualifiedRepresentationItem self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepShape.Handle_StepShape_MeasureRepresentationItemAndQualifiedRepresentationItem_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepShape_MeasureRepresentationItemAndQualifiedRepresentationItem self, StepShape_MeasureRepresentationItemAndQualifiedRepresentationItem thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepShape.Handle_StepShape_MeasureRepresentationItemAndQualifiedRepresentationItem_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepShape_MeasureRepresentationItemAndQualifiedRepresentationItem self, Handle_StepShape_MeasureRepresentationItemAndQualifiedRepresentationItem theHandle) -> Handle_StepShape_MeasureRepresentationItemAndQualifiedRepresentationItem
        assign(Handle_StepShape_MeasureRepresentationItemAndQualifiedRepresentationItem self, StepShape_MeasureRepresentationItemAndQualifiedRepresentationItem thePtr) -> Handle_StepShape_MeasureRepresentationItemAndQualifiedRepresentationItem
        assign(Handle_StepShape_MeasureRepresentationItemAndQualifiedRepresentationItem self, Handle_StepShape_MeasureRepresentationItemAndQualifiedRepresentationItem theHandle) -> Handle_StepShape_MeasureRepresentationItemAndQualifiedRepresentationItem

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepShape.Handle_StepShape_MeasureRepresentationItemAndQualifiedRepresentationItem_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepShape_MeasureRepresentationItemAndQualifiedRepresentationItem self) -> StepShape_MeasureRepresentationItemAndQualifiedRepresentationItem

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepShape.Handle_StepShape_MeasureRepresentationItemAndQualifiedRepresentationItem_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepShape_MeasureRepresentationItemAndQualifiedRepresentationItem self) -> StepShape_MeasureRepresentationItemAndQualifiedRepresentationItem

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepShape.Handle_StepShape_MeasureRepresentationItemAndQualifiedRepresentationItem___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepShape_MeasureRepresentationItemAndQualifiedRepresentationItem self) -> StepShape_MeasureRepresentationItemAndQualifiedRepresentationItem

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepShape.Handle_StepShape_MeasureRepresentationItemAndQualifiedRepresentationItem___ref__(self, *args)


    def __hash__(self):
        return _StepShape.Handle_StepShape_MeasureRepresentationItemAndQualifiedRepresentationItem___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepShape.Handle_StepShape_MeasureRepresentationItemAndQualifiedRepresentationItem___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepShape.new_Handle_StepShape_MeasureRepresentationItemAndQualifiedRepresentationItem(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepShape.Handle_StepShape_MeasureRepresentationItemAndQualifiedRepresentationItem_DownCast)
    __swig_destroy__ = _StepShape.delete_Handle_StepShape_MeasureRepresentationItemAndQualifiedRepresentationItem

    def Init(self, *args):
        """
        Init(Handle_StepShape_MeasureRepresentationItemAndQualifiedRepresentationItem self, Handle_TCollection_HAsciiString aName, Handle_StepBasic_MeasureValueMember aValueComponent, StepBasic_Unit aUnitComponent, Handle_StepShape_HArray1OfValueQualifier qualifiers)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aValueComponent: OCC.wrapper.StepBasic.Handle_StepBasic_MeasureValueMember
        :type aUnitComponent: OCC.wrapper.StepBasic.StepBasic_Unit
        :type qualifiers: OCC.wrapper.StepShape.Handle_StepShape_HArray1OfValueQualifier

        """
        return _StepShape.Handle_StepShape_MeasureRepresentationItemAndQualifiedRepresentationItem_Init(self, *args)


    def SetMeasure(self, *args):
        """
        SetMeasure(Handle_StepShape_MeasureRepresentationItemAndQualifiedRepresentationItem self, Handle_StepBasic_MeasureWithUnit Measure)

        :type Measure: OCC.wrapper.StepBasic.Handle_StepBasic_MeasureWithUnit

        """
        return _StepShape.Handle_StepShape_MeasureRepresentationItemAndQualifiedRepresentationItem_SetMeasure(self, *args)


    def Measure(self, *args):
        """
        Measure(Handle_StepShape_MeasureRepresentationItemAndQualifiedRepresentationItem self) -> Handle_StepBasic_MeasureWithUnit

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_MeasureWithUnit

        """
        return _StepShape.Handle_StepShape_MeasureRepresentationItemAndQualifiedRepresentationItem_Measure(self, *args)


    def Qualifiers(self, *args):
        """
        Qualifiers(Handle_StepShape_MeasureRepresentationItemAndQualifiedRepresentationItem self) -> Handle_StepShape_HArray1OfValueQualifier

        :rtype: OCC.wrapper.StepShape.Handle_StepShape_HArray1OfValueQualifier

        """
        return _StepShape.Handle_StepShape_MeasureRepresentationItemAndQualifiedRepresentationItem_Qualifiers(self, *args)


    def NbQualifiers(self, *args):
        """
        NbQualifiers(Handle_StepShape_MeasureRepresentationItemAndQualifiedRepresentationItem self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_MeasureRepresentationItemAndQualifiedRepresentationItem_NbQualifiers(self, *args)


    def SetQualifiers(self, *args):
        """
        SetQualifiers(Handle_StepShape_MeasureRepresentationItemAndQualifiedRepresentationItem self, Handle_StepShape_HArray1OfValueQualifier qualifiers)

        :type qualifiers: OCC.wrapper.StepShape.Handle_StepShape_HArray1OfValueQualifier

        """
        return _StepShape.Handle_StepShape_MeasureRepresentationItemAndQualifiedRepresentationItem_SetQualifiers(self, *args)


    def QualifiersValue(self, *args):
        """
        QualifiersValue(Handle_StepShape_MeasureRepresentationItemAndQualifiedRepresentationItem self, Standard_Integer const num) -> StepShape_ValueQualifier

        :type num: int
        :rtype: OCC.wrapper.StepShape.StepShape_ValueQualifier

        """
        return _StepShape.Handle_StepShape_MeasureRepresentationItemAndQualifiedRepresentationItem_QualifiersValue(self, *args)


    def SetQualifiersValue(self, *args):
        """
        SetQualifiersValue(Handle_StepShape_MeasureRepresentationItemAndQualifiedRepresentationItem self, Standard_Integer const num, StepShape_ValueQualifier aqualifier)

        :type num: int
        :type aqualifier: OCC.wrapper.StepShape.StepShape_ValueQualifier

        """
        return _StepShape.Handle_StepShape_MeasureRepresentationItemAndQualifiedRepresentationItem_SetQualifiersValue(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepShape_MeasureRepresentationItemAndQualifiedRepresentationItem self) -> char const *

        :rtype: const char *

        """
        return _StepShape.Handle_StepShape_MeasureRepresentationItemAndQualifiedRepresentationItem_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.Handle_StepShape_MeasureRepresentationItemAndQualifiedRepresentationItem_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.Handle_StepShape_MeasureRepresentationItemAndQualifiedRepresentationItem_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetName(self, *args):
        """
        SetName(Handle_StepShape_MeasureRepresentationItemAndQualifiedRepresentationItem self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepShape.Handle_StepShape_MeasureRepresentationItemAndQualifiedRepresentationItem_SetName(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepShape_MeasureRepresentationItemAndQualifiedRepresentationItem self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepShape.Handle_StepShape_MeasureRepresentationItemAndQualifiedRepresentationItem_Name(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepShape_MeasureRepresentationItemAndQualifiedRepresentationItem self)

        Memory deallocator for transient classes


        """
        return _StepShape.Handle_StepShape_MeasureRepresentationItemAndQualifiedRepresentationItem_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepShape_MeasureRepresentationItemAndQualifiedRepresentationItem self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepShape_MeasureRepresentationItemAndQualifiedRepresentationItem self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.Handle_StepShape_MeasureRepresentationItemAndQualifiedRepresentationItem_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepShape_MeasureRepresentationItemAndQualifiedRepresentationItem self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepShape_MeasureRepresentationItemAndQualifiedRepresentationItem self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.Handle_StepShape_MeasureRepresentationItemAndQualifiedRepresentationItem_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepShape_MeasureRepresentationItemAndQualifiedRepresentationItem self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepShape.Handle_StepShape_MeasureRepresentationItemAndQualifiedRepresentationItem_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepShape_MeasureRepresentationItemAndQualifiedRepresentationItem self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_MeasureRepresentationItemAndQualifiedRepresentationItem_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepShape_MeasureRepresentationItemAndQualifiedRepresentationItem self)

        Increments the reference counter of this object


        """
        return _StepShape.Handle_StepShape_MeasureRepresentationItemAndQualifiedRepresentationItem_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepShape_MeasureRepresentationItemAndQualifiedRepresentationItem self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_MeasureRepresentationItemAndQualifiedRepresentationItem_DecrementRefCounter(self, *args)

Handle_StepShape_MeasureRepresentationItemAndQualifiedRepresentationItem_swigregister = _StepShape.Handle_StepShape_MeasureRepresentationItemAndQualifiedRepresentationItem_swigregister
Handle_StepShape_MeasureRepresentationItemAndQualifiedRepresentationItem_swigregister(Handle_StepShape_MeasureRepresentationItemAndQualifiedRepresentationItem)

def Handle_StepShape_MeasureRepresentationItemAndQualifiedRepresentationItem_DownCast(thing):
    return _StepShape.Handle_StepShape_MeasureRepresentationItemAndQualifiedRepresentationItem_DownCast(thing)
Handle_StepShape_MeasureRepresentationItemAndQualifiedRepresentationItem_DownCast = _StepShape.Handle_StepShape_MeasureRepresentationItemAndQualifiedRepresentationItem_DownCast

class Handle_StepShape_FaceBasedSurfaceModel(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepShape_FaceBasedSurfaceModel self)

        Nullify the handle


        """
        return _StepShape.Handle_StepShape_FaceBasedSurfaceModel_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepShape_FaceBasedSurfaceModel self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepShape.Handle_StepShape_FaceBasedSurfaceModel_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepShape_FaceBasedSurfaceModel self, StepShape_FaceBasedSurfaceModel thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepShape.Handle_StepShape_FaceBasedSurfaceModel_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepShape_FaceBasedSurfaceModel self, Handle_StepShape_FaceBasedSurfaceModel theHandle) -> Handle_StepShape_FaceBasedSurfaceModel
        assign(Handle_StepShape_FaceBasedSurfaceModel self, StepShape_FaceBasedSurfaceModel thePtr) -> Handle_StepShape_FaceBasedSurfaceModel
        assign(Handle_StepShape_FaceBasedSurfaceModel self, Handle_StepShape_FaceBasedSurfaceModel theHandle) -> Handle_StepShape_FaceBasedSurfaceModel

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepShape.Handle_StepShape_FaceBasedSurfaceModel_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepShape_FaceBasedSurfaceModel self) -> StepShape_FaceBasedSurfaceModel

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepShape.Handle_StepShape_FaceBasedSurfaceModel_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepShape_FaceBasedSurfaceModel self) -> StepShape_FaceBasedSurfaceModel

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepShape.Handle_StepShape_FaceBasedSurfaceModel___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepShape_FaceBasedSurfaceModel self) -> StepShape_FaceBasedSurfaceModel

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepShape.Handle_StepShape_FaceBasedSurfaceModel___ref__(self, *args)


    def __hash__(self):
        return _StepShape.Handle_StepShape_FaceBasedSurfaceModel___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepShape.Handle_StepShape_FaceBasedSurfaceModel___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepShape.new_Handle_StepShape_FaceBasedSurfaceModel(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepShape.Handle_StepShape_FaceBasedSurfaceModel_DownCast)
    __swig_destroy__ = _StepShape.delete_Handle_StepShape_FaceBasedSurfaceModel

    def Init(self, *args):
        """
        Init(Handle_StepShape_FaceBasedSurfaceModel self, Handle_TCollection_HAsciiString aRepresentationItem_Name, Handle_StepShape_HArray1OfConnectedFaceSet aFbsmFaces)

        Initialize all fields (own and inherited)

        :type aRepresentationItem_Name: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aFbsmFaces: OCC.wrapper.StepShape.Handle_StepShape_HArray1OfConnectedFaceSet

        """
        return _StepShape.Handle_StepShape_FaceBasedSurfaceModel_Init(self, *args)


    def FbsmFaces(self, *args):
        """
        FbsmFaces(Handle_StepShape_FaceBasedSurfaceModel self) -> Handle_StepShape_HArray1OfConnectedFaceSet

        Returns field FbsmFaces

        :rtype: OCC.wrapper.StepShape.Handle_StepShape_HArray1OfConnectedFaceSet

        """
        return _StepShape.Handle_StepShape_FaceBasedSurfaceModel_FbsmFaces(self, *args)


    def SetFbsmFaces(self, *args):
        """
        SetFbsmFaces(Handle_StepShape_FaceBasedSurfaceModel self, Handle_StepShape_HArray1OfConnectedFaceSet FbsmFaces)

        Set field FbsmFaces

        :type FbsmFaces: OCC.wrapper.StepShape.Handle_StepShape_HArray1OfConnectedFaceSet

        """
        return _StepShape.Handle_StepShape_FaceBasedSurfaceModel_SetFbsmFaces(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepShape_FaceBasedSurfaceModel self) -> char const *

        :rtype: const char *

        """
        return _StepShape.Handle_StepShape_FaceBasedSurfaceModel_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.Handle_StepShape_FaceBasedSurfaceModel_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.Handle_StepShape_FaceBasedSurfaceModel_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetName(self, *args):
        """
        SetName(Handle_StepShape_FaceBasedSurfaceModel self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepShape.Handle_StepShape_FaceBasedSurfaceModel_SetName(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepShape_FaceBasedSurfaceModel self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepShape.Handle_StepShape_FaceBasedSurfaceModel_Name(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepShape_FaceBasedSurfaceModel self)

        Memory deallocator for transient classes


        """
        return _StepShape.Handle_StepShape_FaceBasedSurfaceModel_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepShape_FaceBasedSurfaceModel self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepShape_FaceBasedSurfaceModel self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.Handle_StepShape_FaceBasedSurfaceModel_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepShape_FaceBasedSurfaceModel self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepShape_FaceBasedSurfaceModel self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.Handle_StepShape_FaceBasedSurfaceModel_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepShape_FaceBasedSurfaceModel self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepShape.Handle_StepShape_FaceBasedSurfaceModel_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepShape_FaceBasedSurfaceModel self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_FaceBasedSurfaceModel_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepShape_FaceBasedSurfaceModel self)

        Increments the reference counter of this object


        """
        return _StepShape.Handle_StepShape_FaceBasedSurfaceModel_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepShape_FaceBasedSurfaceModel self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_FaceBasedSurfaceModel_DecrementRefCounter(self, *args)

Handle_StepShape_FaceBasedSurfaceModel_swigregister = _StepShape.Handle_StepShape_FaceBasedSurfaceModel_swigregister
Handle_StepShape_FaceBasedSurfaceModel_swigregister(Handle_StepShape_FaceBasedSurfaceModel)

def Handle_StepShape_FaceBasedSurfaceModel_DownCast(thing):
    return _StepShape.Handle_StepShape_FaceBasedSurfaceModel_DownCast(thing)
Handle_StepShape_FaceBasedSurfaceModel_DownCast = _StepShape.Handle_StepShape_FaceBasedSurfaceModel_DownCast

class Handle_StepShape_VertexPoint(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepShape_VertexPoint self)

        Nullify the handle


        """
        return _StepShape.Handle_StepShape_VertexPoint_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepShape_VertexPoint self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepShape.Handle_StepShape_VertexPoint_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepShape_VertexPoint self, StepShape_VertexPoint thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepShape.Handle_StepShape_VertexPoint_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepShape_VertexPoint self, Handle_StepShape_VertexPoint theHandle) -> Handle_StepShape_VertexPoint
        assign(Handle_StepShape_VertexPoint self, StepShape_VertexPoint thePtr) -> Handle_StepShape_VertexPoint
        assign(Handle_StepShape_VertexPoint self, Handle_StepShape_VertexPoint theHandle) -> Handle_StepShape_VertexPoint

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepShape.Handle_StepShape_VertexPoint_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepShape_VertexPoint self) -> StepShape_VertexPoint

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepShape.Handle_StepShape_VertexPoint_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepShape_VertexPoint self) -> StepShape_VertexPoint

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepShape.Handle_StepShape_VertexPoint___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepShape_VertexPoint self) -> StepShape_VertexPoint

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepShape.Handle_StepShape_VertexPoint___ref__(self, *args)


    def __hash__(self):
        return _StepShape.Handle_StepShape_VertexPoint___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepShape.Handle_StepShape_VertexPoint___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepShape.new_Handle_StepShape_VertexPoint(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepShape.Handle_StepShape_VertexPoint_DownCast)
    __swig_destroy__ = _StepShape.delete_Handle_StepShape_VertexPoint

    def Init(self, *args):
        """
        Init(Handle_StepShape_VertexPoint self, Handle_TCollection_HAsciiString aName, Handle_StepGeom_Point aVertexGeometry)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aVertexGeometry: OCC.wrapper.StepShape.Handle_StepGeom_Point

        """
        return _StepShape.Handle_StepShape_VertexPoint_Init(self, *args)


    def SetVertexGeometry(self, *args):
        """
        SetVertexGeometry(Handle_StepShape_VertexPoint self, Handle_StepGeom_Point aVertexGeometry)

        :type aVertexGeometry: OCC.wrapper.StepShape.Handle_StepGeom_Point

        """
        return _StepShape.Handle_StepShape_VertexPoint_SetVertexGeometry(self, *args)


    def VertexGeometry(self, *args):
        """
        VertexGeometry(Handle_StepShape_VertexPoint self) -> Handle_StepGeom_Point

        :rtype: OCC.wrapper.StepShape.Handle_StepGeom_Point

        """
        return _StepShape.Handle_StepShape_VertexPoint_VertexGeometry(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepShape_VertexPoint self) -> char const *

        :rtype: const char *

        """
        return _StepShape.Handle_StepShape_VertexPoint_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.Handle_StepShape_VertexPoint_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.Handle_StepShape_VertexPoint_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetName(self, *args):
        """
        SetName(Handle_StepShape_VertexPoint self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepShape.Handle_StepShape_VertexPoint_SetName(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepShape_VertexPoint self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepShape.Handle_StepShape_VertexPoint_Name(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepShape_VertexPoint self)

        Memory deallocator for transient classes


        """
        return _StepShape.Handle_StepShape_VertexPoint_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepShape_VertexPoint self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepShape_VertexPoint self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.Handle_StepShape_VertexPoint_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepShape_VertexPoint self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepShape_VertexPoint self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.Handle_StepShape_VertexPoint_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepShape_VertexPoint self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepShape.Handle_StepShape_VertexPoint_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepShape_VertexPoint self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_VertexPoint_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepShape_VertexPoint self)

        Increments the reference counter of this object


        """
        return _StepShape.Handle_StepShape_VertexPoint_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepShape_VertexPoint self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_VertexPoint_DecrementRefCounter(self, *args)

Handle_StepShape_VertexPoint_swigregister = _StepShape.Handle_StepShape_VertexPoint_swigregister
Handle_StepShape_VertexPoint_swigregister(Handle_StepShape_VertexPoint)

def Handle_StepShape_VertexPoint_DownCast(thing):
    return _StepShape.Handle_StepShape_VertexPoint_DownCast(thing)
Handle_StepShape_VertexPoint_DownCast = _StepShape.Handle_StepShape_VertexPoint_DownCast

class Handle_StepShape_ValueFormatTypeQualifier(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepShape_ValueFormatTypeQualifier self)

        Nullify the handle


        """
        return _StepShape.Handle_StepShape_ValueFormatTypeQualifier_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepShape_ValueFormatTypeQualifier self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepShape.Handle_StepShape_ValueFormatTypeQualifier_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepShape_ValueFormatTypeQualifier self, StepShape_ValueFormatTypeQualifier thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepShape.Handle_StepShape_ValueFormatTypeQualifier_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepShape_ValueFormatTypeQualifier self, Handle_StepShape_ValueFormatTypeQualifier theHandle) -> Handle_StepShape_ValueFormatTypeQualifier
        assign(Handle_StepShape_ValueFormatTypeQualifier self, StepShape_ValueFormatTypeQualifier thePtr) -> Handle_StepShape_ValueFormatTypeQualifier
        assign(Handle_StepShape_ValueFormatTypeQualifier self, Handle_StepShape_ValueFormatTypeQualifier theHandle) -> Handle_StepShape_ValueFormatTypeQualifier

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepShape.Handle_StepShape_ValueFormatTypeQualifier_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepShape_ValueFormatTypeQualifier self) -> StepShape_ValueFormatTypeQualifier

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepShape.Handle_StepShape_ValueFormatTypeQualifier_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepShape_ValueFormatTypeQualifier self) -> StepShape_ValueFormatTypeQualifier

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepShape.Handle_StepShape_ValueFormatTypeQualifier___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepShape_ValueFormatTypeQualifier self) -> StepShape_ValueFormatTypeQualifier

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepShape.Handle_StepShape_ValueFormatTypeQualifier___ref__(self, *args)


    def __hash__(self):
        return _StepShape.Handle_StepShape_ValueFormatTypeQualifier___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepShape.Handle_StepShape_ValueFormatTypeQualifier___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepShape.new_Handle_StepShape_ValueFormatTypeQualifier(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepShape.Handle_StepShape_ValueFormatTypeQualifier_DownCast)
    __swig_destroy__ = _StepShape.delete_Handle_StepShape_ValueFormatTypeQualifier

    def Init(self, *args):
        """
        Init(Handle_StepShape_ValueFormatTypeQualifier self, Handle_TCollection_HAsciiString theFormatType)

        Init all field own and inherited

        :type theFormatType: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepShape.Handle_StepShape_ValueFormatTypeQualifier_Init(self, *args)


    def FormatType(self, *args):
        """
        FormatType(Handle_StepShape_ValueFormatTypeQualifier self) -> Handle_TCollection_HAsciiString

        Returns field FormatType

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepShape.Handle_StepShape_ValueFormatTypeQualifier_FormatType(self, *args)


    def SetFormatType(self, *args):
        """
        SetFormatType(Handle_StepShape_ValueFormatTypeQualifier self, Handle_TCollection_HAsciiString theFormatType)

        Set field FormatType

        :type theFormatType: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepShape.Handle_StepShape_ValueFormatTypeQualifier_SetFormatType(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepShape_ValueFormatTypeQualifier self) -> char const *

        :rtype: const char *

        """
        return _StepShape.Handle_StepShape_ValueFormatTypeQualifier_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.Handle_StepShape_ValueFormatTypeQualifier_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.Handle_StepShape_ValueFormatTypeQualifier_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_StepShape_ValueFormatTypeQualifier self)

        Memory deallocator for transient classes


        """
        return _StepShape.Handle_StepShape_ValueFormatTypeQualifier_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepShape_ValueFormatTypeQualifier self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepShape_ValueFormatTypeQualifier self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.Handle_StepShape_ValueFormatTypeQualifier_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepShape_ValueFormatTypeQualifier self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepShape_ValueFormatTypeQualifier self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.Handle_StepShape_ValueFormatTypeQualifier_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepShape_ValueFormatTypeQualifier self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepShape.Handle_StepShape_ValueFormatTypeQualifier_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepShape_ValueFormatTypeQualifier self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_ValueFormatTypeQualifier_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepShape_ValueFormatTypeQualifier self)

        Increments the reference counter of this object


        """
        return _StepShape.Handle_StepShape_ValueFormatTypeQualifier_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepShape_ValueFormatTypeQualifier self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_ValueFormatTypeQualifier_DecrementRefCounter(self, *args)

Handle_StepShape_ValueFormatTypeQualifier_swigregister = _StepShape.Handle_StepShape_ValueFormatTypeQualifier_swigregister
Handle_StepShape_ValueFormatTypeQualifier_swigregister(Handle_StepShape_ValueFormatTypeQualifier)

def Handle_StepShape_ValueFormatTypeQualifier_DownCast(thing):
    return _StepShape.Handle_StepShape_ValueFormatTypeQualifier_DownCast(thing)
Handle_StepShape_ValueFormatTypeQualifier_DownCast = _StepShape.Handle_StepShape_ValueFormatTypeQualifier_DownCast

class Handle_StepShape_LimitsAndFits(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepShape_LimitsAndFits self)

        Nullify the handle


        """
        return _StepShape.Handle_StepShape_LimitsAndFits_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepShape_LimitsAndFits self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepShape.Handle_StepShape_LimitsAndFits_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepShape_LimitsAndFits self, StepShape_LimitsAndFits thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepShape.Handle_StepShape_LimitsAndFits_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepShape_LimitsAndFits self, Handle_StepShape_LimitsAndFits theHandle) -> Handle_StepShape_LimitsAndFits
        assign(Handle_StepShape_LimitsAndFits self, StepShape_LimitsAndFits thePtr) -> Handle_StepShape_LimitsAndFits
        assign(Handle_StepShape_LimitsAndFits self, Handle_StepShape_LimitsAndFits theHandle) -> Handle_StepShape_LimitsAndFits

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepShape.Handle_StepShape_LimitsAndFits_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepShape_LimitsAndFits self) -> StepShape_LimitsAndFits

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepShape.Handle_StepShape_LimitsAndFits_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepShape_LimitsAndFits self) -> StepShape_LimitsAndFits

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepShape.Handle_StepShape_LimitsAndFits___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepShape_LimitsAndFits self) -> StepShape_LimitsAndFits

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepShape.Handle_StepShape_LimitsAndFits___ref__(self, *args)


    def __hash__(self):
        return _StepShape.Handle_StepShape_LimitsAndFits___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepShape.Handle_StepShape_LimitsAndFits___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepShape.new_Handle_StepShape_LimitsAndFits(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepShape.Handle_StepShape_LimitsAndFits_DownCast)
    __swig_destroy__ = _StepShape.delete_Handle_StepShape_LimitsAndFits

    def Init(self, *args):
        """
        Init(Handle_StepShape_LimitsAndFits self, Handle_TCollection_HAsciiString form_variance, Handle_TCollection_HAsciiString zone_variance, Handle_TCollection_HAsciiString grade, Handle_TCollection_HAsciiString source)

        :type form_variance: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type zone_variance: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type grade: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type source: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepShape.Handle_StepShape_LimitsAndFits_Init(self, *args)


    def FormVariance(self, *args):
        """
        FormVariance(Handle_StepShape_LimitsAndFits self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepShape.Handle_StepShape_LimitsAndFits_FormVariance(self, *args)


    def SetFormVariance(self, *args):
        """
        SetFormVariance(Handle_StepShape_LimitsAndFits self, Handle_TCollection_HAsciiString form_variance)

        :type form_variance: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepShape.Handle_StepShape_LimitsAndFits_SetFormVariance(self, *args)


    def ZoneVariance(self, *args):
        """
        ZoneVariance(Handle_StepShape_LimitsAndFits self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepShape.Handle_StepShape_LimitsAndFits_ZoneVariance(self, *args)


    def SetZoneVariance(self, *args):
        """
        SetZoneVariance(Handle_StepShape_LimitsAndFits self, Handle_TCollection_HAsciiString zone_variance)

        :type zone_variance: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepShape.Handle_StepShape_LimitsAndFits_SetZoneVariance(self, *args)


    def Grade(self, *args):
        """
        Grade(Handle_StepShape_LimitsAndFits self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepShape.Handle_StepShape_LimitsAndFits_Grade(self, *args)


    def SetGrade(self, *args):
        """
        SetGrade(Handle_StepShape_LimitsAndFits self, Handle_TCollection_HAsciiString grade)

        :type grade: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepShape.Handle_StepShape_LimitsAndFits_SetGrade(self, *args)


    def Source(self, *args):
        """
        Source(Handle_StepShape_LimitsAndFits self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepShape.Handle_StepShape_LimitsAndFits_Source(self, *args)


    def SetSource(self, *args):
        """
        SetSource(Handle_StepShape_LimitsAndFits self, Handle_TCollection_HAsciiString source)

        :type source: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepShape.Handle_StepShape_LimitsAndFits_SetSource(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepShape_LimitsAndFits self) -> char const *

        :rtype: const char *

        """
        return _StepShape.Handle_StepShape_LimitsAndFits_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.Handle_StepShape_LimitsAndFits_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepShape.Handle_StepShape_LimitsAndFits_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_StepShape_LimitsAndFits self)

        Memory deallocator for transient classes


        """
        return _StepShape.Handle_StepShape_LimitsAndFits_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepShape_LimitsAndFits self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepShape_LimitsAndFits self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.Handle_StepShape_LimitsAndFits_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepShape_LimitsAndFits self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepShape_LimitsAndFits self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepShape.Handle_StepShape_LimitsAndFits_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepShape_LimitsAndFits self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepShape.Handle_StepShape_LimitsAndFits_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepShape_LimitsAndFits self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_LimitsAndFits_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepShape_LimitsAndFits self)

        Increments the reference counter of this object


        """
        return _StepShape.Handle_StepShape_LimitsAndFits_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepShape_LimitsAndFits self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepShape.Handle_StepShape_LimitsAndFits_DecrementRefCounter(self, *args)

Handle_StepShape_LimitsAndFits_swigregister = _StepShape.Handle_StepShape_LimitsAndFits_swigregister
Handle_StepShape_LimitsAndFits_swigregister(Handle_StepShape_LimitsAndFits)

def Handle_StepShape_LimitsAndFits_DownCast(thing):
    return _StepShape.Handle_StepShape_LimitsAndFits_DownCast(thing)
Handle_StepShape_LimitsAndFits_DownCast = _StepShape.Handle_StepShape_LimitsAndFits_DownCast




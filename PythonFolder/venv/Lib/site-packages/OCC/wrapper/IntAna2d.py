# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_IntAna2d')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_IntAna2d')
    _IntAna2d = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_IntAna2d', [dirname(__file__)])
        except ImportError:
            import _IntAna2d
            return _IntAna2d
        try:
            _mod = imp.load_module('_IntAna2d', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _IntAna2d = swig_import_helper()
    del swig_import_helper
else:
    import _IntAna2d
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


class SwigPyIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _IntAna2d.delete_SwigPyIterator

    def value(self):
        return _IntAna2d.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _IntAna2d.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _IntAna2d.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _IntAna2d.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _IntAna2d.SwigPyIterator_equal(self, x)

    def copy(self):
        return _IntAna2d.SwigPyIterator_copy(self)

    def next(self):
        return _IntAna2d.SwigPyIterator_next(self)

    def __next__(self):
        return _IntAna2d.SwigPyIterator___next__(self)

    def previous(self):
        return _IntAna2d.SwigPyIterator_previous(self)

    def advance(self, n):
        return _IntAna2d.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _IntAna2d.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _IntAna2d.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _IntAna2d.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _IntAna2d.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _IntAna2d.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _IntAna2d.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self
SwigPyIterator_swigregister = _IntAna2d.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

class NCollection_CellFilter_InspectorXYZ(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _IntAna2d.NCollection_CellFilter_InspectorXYZ_Dimension
    Coord = staticmethod(_IntAna2d.NCollection_CellFilter_InspectorXYZ_Coord)

    def Shift(self, thePnt, theTol):
        return _IntAna2d.NCollection_CellFilter_InspectorXYZ_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _IntAna2d.new_NCollection_CellFilter_InspectorXYZ()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _IntAna2d.delete_NCollection_CellFilter_InspectorXYZ
NCollection_CellFilter_InspectorXYZ_swigregister = _IntAna2d.NCollection_CellFilter_InspectorXYZ_swigregister
NCollection_CellFilter_InspectorXYZ_swigregister(NCollection_CellFilter_InspectorXYZ)

def NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt):
    return _IntAna2d.NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt)
NCollection_CellFilter_InspectorXYZ_Coord = _IntAna2d.NCollection_CellFilter_InspectorXYZ_Coord

class NCollection_CellFilter_InspectorXY(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _IntAna2d.NCollection_CellFilter_InspectorXY_Dimension
    Coord = staticmethod(_IntAna2d.NCollection_CellFilter_InspectorXY_Coord)

    def Shift(self, thePnt, theTol):
        return _IntAna2d.NCollection_CellFilter_InspectorXY_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _IntAna2d.new_NCollection_CellFilter_InspectorXY()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _IntAna2d.delete_NCollection_CellFilter_InspectorXY
NCollection_CellFilter_InspectorXY_swigregister = _IntAna2d.NCollection_CellFilter_InspectorXY_swigregister
NCollection_CellFilter_InspectorXY_swigregister(NCollection_CellFilter_InspectorXY)

def NCollection_CellFilter_InspectorXY_Coord(i, thePnt):
    return _IntAna2d.NCollection_CellFilter_InspectorXY_Coord(i, thePnt)
NCollection_CellFilter_InspectorXY_Coord = _IntAna2d.NCollection_CellFilter_InspectorXY_Coord


def ptr_to_number(item):
    return _IntAna2d.ptr_to_number(item)
ptr_to_number = _IntAna2d.ptr_to_number

def HashCode(*args):
    return _IntAna2d.HashCode(*args)
HashCode = _IntAna2d.HashCode

def ptr_equal(a, b):
    return _IntAna2d.ptr_equal(a, b)
ptr_equal = _IntAna2d.ptr_equal
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Standard
else:
    import Standard
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import gp
else:
    import gp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColStd
else:
    import TColStd
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TCollection
else:
    import TCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import NCollection
else:
    import NCollection
del _swig_python_version_info
class IntAna2d_IntPoint(object):
    """Geometrical intersection between two 2d elements."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(IntAna2d_IntPoint self, Standard_Real const X, Standard_Real const Y, Standard_Real const U1, Standard_Real const U2) -> IntAna2d_IntPoint
        __init__(IntAna2d_IntPoint self, Standard_Real const X, Standard_Real const Y, Standard_Real const U1) -> IntAna2d_IntPoint
        __init__(IntAna2d_IntPoint self) -> IntAna2d_IntPoint

        Create an intersection point between a parametric 2d line,
        and a line given by an implicit equation (ImplicitCurve).
        X,Y are the coordinate of the point. U1 is the parameter
        on the parametric element.
        Empty constructor. It's necessary to use one of
        the SetValue method after this one.

        :type X: float
        :type Y: float
        :type U1: float

        """
        this = _IntAna2d.new_IntAna2d_IntPoint(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def SetValue(self, *args):
        """
        SetValue(IntAna2d_IntPoint self, Standard_Real const X, Standard_Real const Y, Standard_Real const U1, Standard_Real const U2)
        SetValue(IntAna2d_IntPoint self, Standard_Real const X, Standard_Real const Y, Standard_Real const U1)

        Set the values for an "implicit" point.

        :type X: float
        :type Y: float
        :type U1: float

        """
        return _IntAna2d.IntAna2d_IntPoint_SetValue(self, *args)


    def Value(self, *args):
        """
        Returns the geometric point.

        :rtype: OCC.wrapper.gp.gp_Pnt2d

        """
        res = _IntAna2d.IntAna2d_IntPoint_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SecondIsImplicit(self, *args):
        """
        SecondIsImplicit(IntAna2d_IntPoint self) -> Standard_Boolean

        Returns True if the second curve is implicit.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntAna2d.IntAna2d_IntPoint_SecondIsImplicit(self, *args)


    def ParamOnFirst(self, *args):
        """
        ParamOnFirst(IntAna2d_IntPoint self) -> Standard_Real

        Returns the parameter on the first element.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _IntAna2d.IntAna2d_IntPoint_ParamOnFirst(self, *args)


    def ParamOnSecond(self, *args):
        """
        ParamOnSecond(IntAna2d_IntPoint self) -> Standard_Real

        Returns the parameter on the second element.
        If the second element is an implicit curve, an exception
        is raised.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _IntAna2d.IntAna2d_IntPoint_ParamOnSecond(self, *args)

    __swig_destroy__ = _IntAna2d.delete_IntAna2d_IntPoint
IntAna2d_IntPoint_swigregister = _IntAna2d.IntAna2d_IntPoint_swigregister
IntAna2d_IntPoint_swigregister(IntAna2d_IntPoint)

class MyDirectPolynomialRoots(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def NbSolutions(self, *args):
        """
        NbSolutions(MyDirectPolynomialRoots self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntAna2d.MyDirectPolynomialRoots_NbSolutions(self, *args)


    def Value(self, *args):
        """
        Value(MyDirectPolynomialRoots self, Standard_Integer const i) -> Standard_Real

        :type i: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _IntAna2d.MyDirectPolynomialRoots_Value(self, *args)


    def IsDone(self, *args):
        """
        IsDone(MyDirectPolynomialRoots self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _IntAna2d.MyDirectPolynomialRoots_IsDone(self, *args)


    def InfiniteRoots(self, *args):
        """
        InfiniteRoots(MyDirectPolynomialRoots self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntAna2d.MyDirectPolynomialRoots_InfiniteRoots(self, *args)

    __swig_destroy__ = _IntAna2d.delete_MyDirectPolynomialRoots
MyDirectPolynomialRoots_swigregister = _IntAna2d.MyDirectPolynomialRoots_swigregister
MyDirectPolynomialRoots_swigregister(MyDirectPolynomialRoots)

class IntAna2d_Conic(object):
    """
    Definition of a conic by its implicit quadaratic equation:
    A.X**2 + B.Y**2 + 2.C.X*Y + 2.D.X + 2.E.Y + F = 0.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(IntAna2d_Conic self, gp_Circ2d C) -> IntAna2d_Conic
        __init__(IntAna2d_Conic self, gp_Lin2d C) -> IntAna2d_Conic
        __init__(IntAna2d_Conic self, gp_Parab2d C) -> IntAna2d_Conic
        __init__(IntAna2d_Conic self, gp_Hypr2d C) -> IntAna2d_Conic
        __init__(IntAna2d_Conic self, gp_Elips2d C) -> IntAna2d_Conic

        :type C: OCC.wrapper.gp.gp_Elips2d

        """
        this = _IntAna2d.new_IntAna2d_Conic(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Value(self, *args):
        """
        Value(IntAna2d_Conic self, Standard_Real const X, Standard_Real const Y) -> Standard_Real

        value of the function F at the point X,Y.

        :type X: float
        :type Y: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _IntAna2d.IntAna2d_Conic_Value(self, *args)


    def Grad(self, *args):
        """
        Grad(IntAna2d_Conic self, Standard_Real const X, Standard_Real const Y) -> gp_XY

        returns the value of the gradient of F at the point X,Y.

        :type X: float
        :type Y: float
        :rtype: OCC.wrapper.gp.gp_XY

        """
        return _IntAna2d.IntAna2d_Conic_Grad(self, *args)


    def ValAndGrad(self, *args):
        """
        ValAndGrad(IntAna2d_Conic self, Standard_Real const X, Standard_Real const Y, gp_XY Grd)

        Returns the value of the function and its gradient at
        the point X,Y.

        :type X: float
        :type Y: float
        :type Val: float
        :type Grd: OCC.wrapper.gp.gp_XY

        """
        return _IntAna2d.IntAna2d_Conic_ValAndGrad(self, *args)


    def Coefficients(self, *args):
        """
        Coefficients(IntAna2d_Conic self)

        returns the coefficients of the polynomial equation
        wich defines the conic:
        A.X**2 + B.Y**2 + 2.C.X*Y + 2.D.X + 2.E.Y + F = 0.

        :type A: float
        :type B: float
        :type C: float
        :type D: float
        :type E: float
        :type F: float

        """
        return _IntAna2d.IntAna2d_Conic_Coefficients(self, *args)


    def NewCoefficients(self, *args):
        """
        NewCoefficients(IntAna2d_Conic self, gp_Ax2d Axis)

        Returns the coefficients of the polynomial equation
        ( written in the natural coordinates system )
        A x x + B y y + 2 C x y + 2 D x + 2 E y + F
        in the local coordinates system defined by Axis

        :type A: float
        :type B: float
        :type C: float
        :type D: float
        :type E: float
        :type F: float
        :type Axis: OCC.wrapper.gp.gp_Ax2d

        """
        return _IntAna2d.IntAna2d_Conic_NewCoefficients(self, *args)

    __swig_destroy__ = _IntAna2d.delete_IntAna2d_Conic
IntAna2d_Conic_swigregister = _IntAna2d.IntAna2d_Conic_swigregister
IntAna2d_Conic_swigregister(IntAna2d_Conic)

class IntAna2d_AnaIntersection(object):
    """
    Implementation of the analytical intersection between:
    - two Lin2d,
    - two Circ2d,
    - a Lin2d and a Circ2d,
    - an element of gp (Lin2d, Circ2d, Elips2d, Parab2d, Hypr2d)
    and another conic.
    No tolerance is given for all the intersections: the tolerance
    will be the "precision machine".
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(IntAna2d_AnaIntersection self) -> IntAna2d_AnaIntersection
        __init__(IntAna2d_AnaIntersection self, gp_Lin2d L1, gp_Lin2d L2) -> IntAna2d_AnaIntersection
        __init__(IntAna2d_AnaIntersection self, gp_Circ2d C1, gp_Circ2d C2) -> IntAna2d_AnaIntersection
        __init__(IntAna2d_AnaIntersection self, gp_Lin2d L, gp_Circ2d C) -> IntAna2d_AnaIntersection
        __init__(IntAna2d_AnaIntersection self, gp_Lin2d L, IntAna2d_Conic C) -> IntAna2d_AnaIntersection
        __init__(IntAna2d_AnaIntersection self, gp_Circ2d C, IntAna2d_Conic Co) -> IntAna2d_AnaIntersection
        __init__(IntAna2d_AnaIntersection self, gp_Elips2d E, IntAna2d_Conic C) -> IntAna2d_AnaIntersection
        __init__(IntAna2d_AnaIntersection self, gp_Parab2d P, IntAna2d_Conic C) -> IntAna2d_AnaIntersection
        __init__(IntAna2d_AnaIntersection self, gp_Hypr2d H, IntAna2d_Conic C) -> IntAna2d_AnaIntersection

        Intersection between an hyperbola and another conic.

        :type H: OCC.wrapper.gp.gp_Hypr2d
        :type C: OCC.wrapper.IntAna2d.IntAna2d_Conic

        """
        this = _IntAna2d.new_IntAna2d_AnaIntersection(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Perform(self, *args):
        """
        Perform(IntAna2d_AnaIntersection self, gp_Lin2d L1, gp_Lin2d L2)
        Perform(IntAna2d_AnaIntersection self, gp_Circ2d C1, gp_Circ2d C2)
        Perform(IntAna2d_AnaIntersection self, gp_Lin2d L, gp_Circ2d C)
        Perform(IntAna2d_AnaIntersection self, gp_Lin2d L, IntAna2d_Conic C)
        Perform(IntAna2d_AnaIntersection self, gp_Circ2d C, IntAna2d_Conic Co)
        Perform(IntAna2d_AnaIntersection self, gp_Elips2d E, IntAna2d_Conic C)
        Perform(IntAna2d_AnaIntersection self, gp_Parab2d P, IntAna2d_Conic C)
        Perform(IntAna2d_AnaIntersection self, gp_Hypr2d H, IntAna2d_Conic C)

        Intersection between an hyperbola and another conic.

        :type H: OCC.wrapper.gp.gp_Hypr2d
        :type C: OCC.wrapper.IntAna2d.IntAna2d_Conic

        """
        return _IntAna2d.IntAna2d_AnaIntersection_Perform(self, *args)


    def IsDone(self, *args):
        """
        IsDone(IntAna2d_AnaIntersection self) -> Standard_Boolean

        Returns TRUE if the computation was succesfull.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntAna2d.IntAna2d_AnaIntersection_IsDone(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(IntAna2d_AnaIntersection self) -> Standard_Boolean

        Returns TRUE when there is no intersection, i-e
        - no intersection point
        - the elements are not identical.
        The element may be parallel in this case.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntAna2d.IntAna2d_AnaIntersection_IsEmpty(self, *args)


    def IdenticalElements(self, *args):
        """
        IdenticalElements(IntAna2d_AnaIntersection self) -> Standard_Boolean

        For the intersection between an element of gp and a conic
        known by an implicit equation, the result will be TRUE
        if the element of gp verifies the implicit equation.
        For the intersection between two Lin2d or two Circ2d, the
        result will be TRUE if the elements are identical.
        The function returns FALSE in all the other cases.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntAna2d.IntAna2d_AnaIntersection_IdenticalElements(self, *args)


    def ParallelElements(self, *args):
        """
        ParallelElements(IntAna2d_AnaIntersection self) -> Standard_Boolean

        For the intersection between two Lin2d or two Circ2d,
        the function returns TRUE if the elements are parallel.
        The function returns FALSE in all the other cases.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntAna2d.IntAna2d_AnaIntersection_ParallelElements(self, *args)


    def NbPoints(self, *args):
        """
        NbPoints(IntAna2d_AnaIntersection self) -> Standard_Integer

        returns the number of IntPoint between the 2 curves.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntAna2d.IntAna2d_AnaIntersection_NbPoints(self, *args)


    def Point(self, *args):
        """
        returns the intersection point of range N;
        If (N<=0) or (N>NbPoints), an exception is raised.

        :type N: int
        :rtype: OCC.wrapper.IntAna2d.IntAna2d_IntPoint

        """
        res = _IntAna2d.IntAna2d_AnaIntersection_Point(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _IntAna2d.delete_IntAna2d_AnaIntersection
IntAna2d_AnaIntersection_swigregister = _IntAna2d.IntAna2d_AnaIntersection_swigregister
IntAna2d_AnaIntersection_swigregister(IntAna2d_AnaIntersection)




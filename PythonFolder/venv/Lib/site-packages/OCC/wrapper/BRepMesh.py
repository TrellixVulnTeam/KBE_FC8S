# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_BRepMesh')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_BRepMesh')
    _BRepMesh = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_BRepMesh', [dirname(__file__)])
        except ImportError:
            import _BRepMesh
            return _BRepMesh
        try:
            _mod = imp.load_module('_BRepMesh', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _BRepMesh = swig_import_helper()
    del swig_import_helper
else:
    import _BRepMesh
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


class SwigPyIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _BRepMesh.delete_SwigPyIterator

    def value(self):
        return _BRepMesh.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _BRepMesh.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _BRepMesh.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _BRepMesh.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _BRepMesh.SwigPyIterator_equal(self, x)

    def copy(self):
        return _BRepMesh.SwigPyIterator_copy(self)

    def next(self):
        return _BRepMesh.SwigPyIterator_next(self)

    def __next__(self):
        return _BRepMesh.SwigPyIterator___next__(self)

    def previous(self):
        return _BRepMesh.SwigPyIterator_previous(self)

    def advance(self, n):
        return _BRepMesh.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _BRepMesh.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _BRepMesh.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _BRepMesh.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _BRepMesh.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _BRepMesh.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _BRepMesh.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self
SwigPyIterator_swigregister = _BRepMesh.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

class NCollection_CellFilter_InspectorXYZ(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _BRepMesh.NCollection_CellFilter_InspectorXYZ_Dimension
    Coord = staticmethod(_BRepMesh.NCollection_CellFilter_InspectorXYZ_Coord)

    def Shift(self, thePnt, theTol):
        return _BRepMesh.NCollection_CellFilter_InspectorXYZ_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _BRepMesh.new_NCollection_CellFilter_InspectorXYZ()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _BRepMesh.delete_NCollection_CellFilter_InspectorXYZ
NCollection_CellFilter_InspectorXYZ_swigregister = _BRepMesh.NCollection_CellFilter_InspectorXYZ_swigregister
NCollection_CellFilter_InspectorXYZ_swigregister(NCollection_CellFilter_InspectorXYZ)

def NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt):
    return _BRepMesh.NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt)
NCollection_CellFilter_InspectorXYZ_Coord = _BRepMesh.NCollection_CellFilter_InspectorXYZ_Coord

class NCollection_CellFilter_InspectorXY(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _BRepMesh.NCollection_CellFilter_InspectorXY_Dimension
    Coord = staticmethod(_BRepMesh.NCollection_CellFilter_InspectorXY_Coord)

    def Shift(self, thePnt, theTol):
        return _BRepMesh.NCollection_CellFilter_InspectorXY_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _BRepMesh.new_NCollection_CellFilter_InspectorXY()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _BRepMesh.delete_NCollection_CellFilter_InspectorXY
NCollection_CellFilter_InspectorXY_swigregister = _BRepMesh.NCollection_CellFilter_InspectorXY_swigregister
NCollection_CellFilter_InspectorXY_swigregister(NCollection_CellFilter_InspectorXY)

def NCollection_CellFilter_InspectorXY_Coord(i, thePnt):
    return _BRepMesh.NCollection_CellFilter_InspectorXY_Coord(i, thePnt)
NCollection_CellFilter_InspectorXY_Coord = _BRepMesh.NCollection_CellFilter_InspectorXY_Coord


def ptr_to_number(item):
    return _BRepMesh.ptr_to_number(item)
ptr_to_number = _BRepMesh.ptr_to_number

def HashCode(*args):
    return _BRepMesh.HashCode(*args)
HashCode = _BRepMesh.HashCode

def ptr_equal(a, b):
    return _BRepMesh.ptr_equal(a, b)
ptr_equal = _BRepMesh.ptr_equal
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopoDS
else:
    import TopoDS
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import NCollection
else:
    import NCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Standard
else:
    import Standard
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopAbs
else:
    import TopAbs
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Message
else:
    import Message
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColStd
else:
    import TColStd
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TCollection
else:
    import TCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopLoc
else:
    import TopLoc
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import gp
else:
    import gp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Geom2dAdaptor
else:
    import Geom2dAdaptor
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Geom2d
else:
    import Geom2d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import GeomAbs
else:
    import GeomAbs
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColgp
else:
    import TColgp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Adaptor2d
else:
    import Adaptor2d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Poly
else:
    import Poly
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TShort
else:
    import TShort
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Adaptor3d
else:
    import Adaptor3d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Geom
else:
    import Geom
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import math
else:
    import math
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import BRepAdaptor
else:
    import BRepAdaptor
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import GeomAdaptor
else:
    import GeomAdaptor
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopTools
else:
    import TopTools
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Bnd
else:
    import Bnd
del _swig_python_version_info
BRepMesh_Free = _BRepMesh.BRepMesh_Free
BRepMesh_InVolume = _BRepMesh.BRepMesh_InVolume
BRepMesh_OnSurface = _BRepMesh.BRepMesh_OnSurface
BRepMesh_OnCurve = _BRepMesh.BRepMesh_OnCurve
BRepMesh_Fixed = _BRepMesh.BRepMesh_Fixed
BRepMesh_Frontier = _BRepMesh.BRepMesh_Frontier
BRepMesh_Deleted = _BRepMesh.BRepMesh_Deleted
BRepMesh_FE_NOERROR = _BRepMesh.BRepMesh_FE_NOERROR
BRepMesh_FE_LIBRARYNOTFOUND = _BRepMesh.BRepMesh_FE_LIBRARYNOTFOUND
BRepMesh_FE_FUNCTIONNOTFOUND = _BRepMesh.BRepMesh_FE_FUNCTIONNOTFOUND
BRepMesh_FE_CANNOTCREATEALGO = _BRepMesh.BRepMesh_FE_CANNOTCREATEALGO
BRepMesh_NoError = _BRepMesh.BRepMesh_NoError
BRepMesh_OpenWire = _BRepMesh.BRepMesh_OpenWire
BRepMesh_SelfIntersectingWire = _BRepMesh.BRepMesh_SelfIntersectingWire
BRepMesh_Failure = _BRepMesh.BRepMesh_Failure
BRepMesh_ReMesh = _BRepMesh.BRepMesh_ReMesh
class BRepMesh_DiscretRoot(Standard.Standard_Transient):
    """
    This is a common interface for meshing algorithms 
    instantiated by Mesh Factory and implemented by plugins.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_BRepMesh_DiscretRoot
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_BRepMesh_DiscretRoot(self) 
            return h


    def SetShape(self, *args):
        """
        SetShape(BRepMesh_DiscretRoot self, TopoDS_Shape theShape)

        Set the shape to triangulate.

        :type theShape: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _BRepMesh.BRepMesh_DiscretRoot_SetShape(self, *args)


    def Shape(self, *args):
        """
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _BRepMesh.BRepMesh_DiscretRoot_Shape(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def IsDone(self, *args):
        """
        IsDone(BRepMesh_DiscretRoot self) -> Standard_Boolean

        Returns true if triangualtion was performed and has success.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepMesh.BRepMesh_DiscretRoot_IsDone(self, *args)


    def Perform(self, *args):
        """
        Perform(BRepMesh_DiscretRoot self)

        Compute triangulation for set shape.


        """
        return _BRepMesh.BRepMesh_DiscretRoot_Perform(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _BRepMesh.BRepMesh_DiscretRoot_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _BRepMesh.BRepMesh_DiscretRoot_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _BRepMesh.BRepMesh_DiscretRoot_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _BRepMesh.delete_BRepMesh_DiscretRoot
BRepMesh_DiscretRoot_swigregister = _BRepMesh.BRepMesh_DiscretRoot_swigregister
BRepMesh_DiscretRoot_swigregister(BRepMesh_DiscretRoot)

def BRepMesh_DiscretRoot_get_type_name(*args):
    """
    BRepMesh_DiscretRoot_get_type_name() -> char const *

    :rtype: const char *

    """
    return _BRepMesh.BRepMesh_DiscretRoot_get_type_name(*args)

def BRepMesh_DiscretRoot_get_type_descriptor(*args):
    """
    BRepMesh_DiscretRoot_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _BRepMesh.BRepMesh_DiscretRoot_get_type_descriptor(*args)

class BRepMesh_DataStructureOfDelaun(Standard.Standard_Transient):
    """
    Describes the data structure necessary for the mesh algorithms in 
    two dimensions plane or on surface by meshing in UV space.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_BRepMesh_DataStructureOfDelaun
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_BRepMesh_DataStructureOfDelaun(self) 
            return h


    def __init__(self, *args):
        """
        __init__(BRepMesh_DataStructureOfDelaun self, Handle_NCollection_IncAllocator theAllocator, Standard_Integer const theReservedNodeSize=100) -> BRepMesh_DataStructureOfDelaun

        Constructor.
        @param theAllocator memory allocator to be used by internal structures.
        @param theReservedNodeSize presumed number of nodes in this mesh.

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_IncAllocator
        :type theReservedNodeSize: int

        """
        this = _BRepMesh.new_BRepMesh_DataStructureOfDelaun(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def NbNodes(self, *args):
        """
        NbNodes(BRepMesh_DataStructureOfDelaun self) -> Standard_Integer

        Returns number of nodes.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepMesh.BRepMesh_DataStructureOfDelaun_NbNodes(self, *args)


    def AddNode(self, *args):
        """
        AddNode(BRepMesh_DataStructureOfDelaun self, BRepMesh_Vertex theNode, Standard_Boolean const isForceAdd) -> Standard_Integer

        Adds node to the mesh if it is not already in the mesh.
        @param theNode node to be added to the mesh.
        @param isForceAdd adds the given node to structure without 
        checking on coincidence with other nodes.
        @return index of the node in the structure.

        :type theNode: OCC.wrapper.BRepMesh.BRepMesh_Vertex
        :type isForceAdd: bool
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepMesh.BRepMesh_DataStructureOfDelaun_AddNode(self, *args)


    def GetNode(self, *args):
        """
        Get node by the index.
        @param theIndex index of a node.
        @return node with the given index.

        :type theIndex: int
        :rtype: OCC.wrapper.BRepMesh.BRepMesh_Vertex

        """
        res = _BRepMesh.BRepMesh_DataStructureOfDelaun_GetNode(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __call__(self, *args):
        """
        Alias for GetNode.

        :type theIndex: int
        :rtype: OCC.wrapper.BRepMesh.BRepMesh_Vertex

        """
        res = _BRepMesh.BRepMesh_DataStructureOfDelaun___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SubstituteNode(self, *args):
        """
        SubstituteNode(BRepMesh_DataStructureOfDelaun self, Standard_Integer const theIndex, BRepMesh_Vertex theNewNode) -> Standard_Boolean

        Substitutes the node with the given index by new one.
        @param theIndex index of node to be substituted.
        @param theNewNode substituting node.
        @return FALSE in case if new node is already in the structure, TRUE elsewhere.

        :type theIndex: int
        :type theNewNode: OCC.wrapper.BRepMesh.BRepMesh_Vertex
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepMesh.BRepMesh_DataStructureOfDelaun_SubstituteNode(self, *args)


    def RemoveNode(self, *args):
        """
        RemoveNode(BRepMesh_DataStructureOfDelaun self, Standard_Integer const theIndex, Standard_Boolean const isForce)

        Removes node from the mesh in case if it has no connected links 
        and its type is Free.
        @param theIndex index of node to be removed.
        @param isForce if TRUE node will be removed even if movability
        is not Free.

        :type theIndex: int
        :type isForce: bool

        """
        return _BRepMesh.BRepMesh_DataStructureOfDelaun_RemoveNode(self, *args)


    def LinksConnectedTo(self, *args):
        """
        Get list of links attached to the node with the given index.
        @param theIndex index of node whose links should be retrieved.
        @return list of links attached to the node.

        :type theIndex: int
        :rtype: ListOfInteger

        """
        res = _BRepMesh.BRepMesh_DataStructureOfDelaun_LinksConnectedTo(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def NbLinks(self, *args):
        """
        NbLinks(BRepMesh_DataStructureOfDelaun self) -> Standard_Integer

        Returns number of links.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepMesh.BRepMesh_DataStructureOfDelaun_NbLinks(self, *args)


    def AddLink(self, *args):
        """
        AddLink(BRepMesh_DataStructureOfDelaun self, BRepMesh_Edge theLink) -> Standard_Integer

        Adds link to the mesh if it is not already in the mesh.
        @param theLink link to be added to the mesh.
        @return index of the link in the structure.

        :type theLink: OCC.wrapper.BRepMesh.BRepMesh_Edge
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepMesh.BRepMesh_DataStructureOfDelaun_AddLink(self, *args)


    def GetLink(self, *args):
        """
        Get link by the index.
        @param theIndex index of a link.
        @return link with the given index.

        :type theIndex: int
        :rtype: OCC.wrapper.BRepMesh.BRepMesh_Edge

        """
        res = _BRepMesh.BRepMesh_DataStructureOfDelaun_GetLink(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def LinksOfDomain(self, *args):
        """
        Returns map of indices of links registered in mesh.

        :rtype: MapOfInteger

        """
        res = _BRepMesh.BRepMesh_DataStructureOfDelaun_LinksOfDomain(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SubstituteLink(self, *args):
        """
        SubstituteLink(BRepMesh_DataStructureOfDelaun self, Standard_Integer const theIndex, BRepMesh_Edge theNewLink) -> Standard_Boolean

        Substitutes the link with the given index by new one.
        @param theIndex index of link to be substituted.
        @param theNewLink substituting link.
        @return FALSE in case if new link is already in the structure, TRUE elsewhere.

        :type theIndex: int
        :type theNewLink: OCC.wrapper.BRepMesh.BRepMesh_Edge
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepMesh.BRepMesh_DataStructureOfDelaun_SubstituteLink(self, *args)


    def RemoveLink(self, *args):
        """
        RemoveLink(BRepMesh_DataStructureOfDelaun self, Standard_Integer const theIndex, Standard_Boolean const isForce)

        Removes link from the mesh in case if it has no connected elements 
        and its type is Free.
        @param theIndex index of link to be removed.
        @param isForce if TRUE link will be removed even if movability
        is not Free.

        :type theIndex: int
        :type isForce: bool

        """
        return _BRepMesh.BRepMesh_DataStructureOfDelaun_RemoveLink(self, *args)


    def ElementsConnectedTo(self, *args):
        """
        Returns indices of elements conected to the link with the given index.
        @param theLinkIndex index of link whose data should be retrieved.
        @return indices of elements conected to the link.

        :type theLinkIndex: int
        :rtype: OCC.wrapper.BRepMesh.BRepMesh_PairOfIndex

        """
        res = _BRepMesh.BRepMesh_DataStructureOfDelaun_ElementsConnectedTo(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def NbElements(self, *args):
        """
        NbElements(BRepMesh_DataStructureOfDelaun self) -> Standard_Integer

        Returns number of links.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepMesh.BRepMesh_DataStructureOfDelaun_NbElements(self, *args)


    def AddElement(self, *args):
        """
        AddElement(BRepMesh_DataStructureOfDelaun self, BRepMesh_Triangle theElement) -> Standard_Integer

        Adds element to the mesh if it is not already in the mesh.
        @param theElement element to be added to the mesh.
        @return index of the element in the structure.

        :type theElement: OCC.wrapper.BRepMesh.BRepMesh_Triangle
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepMesh.BRepMesh_DataStructureOfDelaun_AddElement(self, *args)


    def IndexOf(self, *args):
        """
        IndexOf(BRepMesh_DataStructureOfDelaun self, BRepMesh_Vertex theNode) -> Standard_Integer
        IndexOf(BRepMesh_DataStructureOfDelaun self, BRepMesh_Edge theLink) -> Standard_Integer
        IndexOf(BRepMesh_DataStructureOfDelaun self, BRepMesh_Triangle theElement) -> Standard_Integer

        Finds the index of the given element.
        @param theElement element to find.
        @return index of the given element of zero if element is not in the mesh.

        :type theElement: OCC.wrapper.BRepMesh.BRepMesh_Triangle
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepMesh.BRepMesh_DataStructureOfDelaun_IndexOf(self, *args)


    def GetElement(self, *args):
        """
        Get element by the index.
        @param theIndex index of an element.
        @return element with the given index.

        :type theIndex: int
        :rtype: OCC.wrapper.BRepMesh.BRepMesh_Triangle

        """
        res = _BRepMesh.BRepMesh_DataStructureOfDelaun_GetElement(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ElementsOfDomain(self, *args):
        """
        Returns map of indices of elements registered in mesh.

        :rtype: MapOfInteger

        """
        res = _BRepMesh.BRepMesh_DataStructureOfDelaun_ElementsOfDomain(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SubstituteElement(self, *args):
        """
        SubstituteElement(BRepMesh_DataStructureOfDelaun self, Standard_Integer const theIndex, BRepMesh_Triangle theNewElement) -> Standard_Boolean

        Substitutes the element with the given index by new one.
        @param theIndex index of element to be substituted.
        @param theNewLink substituting element.
        @return FALSE in case if new element is already in the structure, TRUE elsewhere.

        :type theIndex: int
        :type theNewElement: OCC.wrapper.BRepMesh.BRepMesh_Triangle
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepMesh.BRepMesh_DataStructureOfDelaun_SubstituteElement(self, *args)


    def RemoveElement(self, *args):
        """
        RemoveElement(BRepMesh_DataStructureOfDelaun self, Standard_Integer const theIndex)

        Removes element from the mesh.
        @param theIndex index of element to be removed.

        :type theIndex: int

        """
        return _BRepMesh.BRepMesh_DataStructureOfDelaun_RemoveElement(self, *args)


    def ElementNodes(self, *args):
        """
        ElementNodes(BRepMesh_DataStructureOfDelaun self, BRepMesh_Triangle theElement, Standard_Integer (&)[3] theNodes)

        Returns indices of nodes forming the given element.
        @param theElement element which nodes should be retrieved.
        @param[out] theNodes nodes of the given element.

        :type theElement: OCC.wrapper.BRepMesh.BRepMesh_Triangle
        :type theNodes: OCC.wrapper.Standard.Standard_Integer (&)[3]

        """
        return _BRepMesh.BRepMesh_DataStructureOfDelaun_ElementNodes(self, *args)


    def Statistics(self, *args):
        """
        Statistics(BRepMesh_DataStructureOfDelaun self, Standard_OStream & theStream)

        Dumps information about this structure.
        @param theStream stream to be used for dump.

        :type theStream: OCC.wrapper.Standard.Standard_OStream

        """
        return _BRepMesh.BRepMesh_DataStructureOfDelaun_Statistics(self, *args)


    def Allocator(self, *args):
        """
        Returns memory allocator used by the structure.

        :rtype: OCC.wrapper.NCollection.Handle_NCollection_IncAllocator

        """
        res = _BRepMesh.BRepMesh_DataStructureOfDelaun_Allocator(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Data(self, *args):
        """
        Data(BRepMesh_DataStructureOfDelaun self) -> BRepMesh::HVertexTool &

        Gives the data structure for initialization of cell size and tolerance.

        :rtype: HVertexTool

        """
        return _BRepMesh.BRepMesh_DataStructureOfDelaun_Data(self, *args)


    def ClearDomain(self, *args):
        """
        ClearDomain(BRepMesh_DataStructureOfDelaun self)

        Removes all elements.


        """
        return _BRepMesh.BRepMesh_DataStructureOfDelaun_ClearDomain(self, *args)


    def ClearDeleted(self, *args):
        """
        ClearDeleted(BRepMesh_DataStructureOfDelaun self)

        Substitutes deleted items by the last one from corresponding map 
        to have only non-deleted elements, links or nodes in the structure.


        """
        return _BRepMesh.BRepMesh_DataStructureOfDelaun_ClearDeleted(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _BRepMesh.BRepMesh_DataStructureOfDelaun_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _BRepMesh.BRepMesh_DataStructureOfDelaun_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _BRepMesh.BRepMesh_DataStructureOfDelaun_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _BRepMesh.delete_BRepMesh_DataStructureOfDelaun
BRepMesh_DataStructureOfDelaun_swigregister = _BRepMesh.BRepMesh_DataStructureOfDelaun_swigregister
BRepMesh_DataStructureOfDelaun_swigregister(BRepMesh_DataStructureOfDelaun)

def BRepMesh_DataStructureOfDelaun_get_type_name(*args):
    """
    BRepMesh_DataStructureOfDelaun_get_type_name() -> char const *

    :rtype: const char *

    """
    return _BRepMesh.BRepMesh_DataStructureOfDelaun_get_type_name(*args)

def BRepMesh_DataStructureOfDelaun_get_type_descriptor(*args):
    """
    BRepMesh_DataStructureOfDelaun_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _BRepMesh.BRepMesh_DataStructureOfDelaun_get_type_descriptor(*args)

class BRepMesh_IncrementalMesh(BRepMesh_DiscretRoot):
    """
    Builds the mesh of a shape with respect of their 
    correctly triangulated parts 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_BRepMesh_IncrementalMesh
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_BRepMesh_IncrementalMesh(self) 
            return h


    def __init__(self, *args):
        """
        __init__(BRepMesh_IncrementalMesh self) -> BRepMesh_IncrementalMesh
        __init__(BRepMesh_IncrementalMesh self, TopoDS_Shape theShape, Standard_Real const theLinDeflection, Standard_Boolean const isRelative, Standard_Real const theAngDeflection=0.5, Standard_Boolean const isInParallel, Standard_Boolean const adaptiveMin) -> BRepMesh_IncrementalMesh
        __init__(BRepMesh_IncrementalMesh self, TopoDS_Shape theShape, BRepMesh_FastDiscret::Parameters const & theParameters) -> BRepMesh_IncrementalMesh

        Constructor.
        Automatically calls method Perform.
        @param theShape shape to be meshed.
        @param theParameters - parameters of meshing

        :type theShape: OCC.wrapper.TopoDS.TopoDS_Shape
        :type theParameters: Parameters

        """
        this = _BRepMesh.new_BRepMesh_IncrementalMesh(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Perform(self, *args):
        """
        Perform(BRepMesh_IncrementalMesh self)

        Performs meshing ot the shape.


        """
        return _BRepMesh.BRepMesh_IncrementalMesh_Perform(self, *args)


    def Parameters(self, *args):
        """
        Returns meshing parameters

        :rtype: Parameters

        """
        res = _BRepMesh.BRepMesh_IncrementalMesh_Parameters(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeParameters(self, *args):
        """
        ChangeParameters(BRepMesh_IncrementalMesh self) -> BRepMesh_FastDiscret::Parameters &

        Returns modifiable meshing parameters

        :rtype: Parameters

        """
        return _BRepMesh.BRepMesh_IncrementalMesh_ChangeParameters(self, *args)


    def IsModified(self, *args):
        """
        IsModified(BRepMesh_IncrementalMesh self) -> Standard_Boolean

        Returns modified flag.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepMesh.BRepMesh_IncrementalMesh_IsModified(self, *args)


    def GetStatusFlags(self, *args):
        """
        GetStatusFlags(BRepMesh_IncrementalMesh self) -> Standard_Integer

        Returns accumulated status flags faced during meshing.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepMesh.BRepMesh_IncrementalMesh_GetStatusFlags(self, *args)


    def Discret(*args):
        """
        Discret(TopoDS_Shape theShape, Standard_Real const theLinDeflection, Standard_Real const theAngDeflection, BRepMesh_DiscretRoot *& theAlgo) -> Standard_Integer

        Plugin interface for the Mesh Factories.
        Initializes meshing algorithm with the given parameters.
        @param theShape shape to be meshed.
        @param theLinDeflection linear deflection.
        @param theAngDeflection angular deflection.
        @param[out] theAlgo pointer to initialized algorithm.

        :type theShape: OCC.wrapper.TopoDS.TopoDS_Shape
        :type theLinDeflection: float
        :type theAngDeflection: float
        :type theAlgo: OCC.wrapper.BRepMesh.BRepMesh_DiscretRoot
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepMesh.BRepMesh_IncrementalMesh_Discret(*args)

    Discret = staticmethod(Discret)

    def IsParallelDefault(*args):
        """
        IsParallelDefault() -> Standard_Boolean

        Returns multi-threading usage flag set by default in 
        Discret() static method (thus applied only to Mesh Factories).

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepMesh.BRepMesh_IncrementalMesh_IsParallelDefault(*args)

    IsParallelDefault = staticmethod(IsParallelDefault)

    def SetParallelDefault(*args):
        """
        SetParallelDefault(Standard_Boolean const isInParallel)

        Setup multi-threading usage flag set by default in 
        Discret() static method (thus applied only to Mesh Factories).

        :type isInParallel: bool

        """
        return _BRepMesh.BRepMesh_IncrementalMesh_SetParallelDefault(*args)

    SetParallelDefault = staticmethod(SetParallelDefault)

    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _BRepMesh.BRepMesh_IncrementalMesh_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _BRepMesh.BRepMesh_IncrementalMesh_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _BRepMesh.BRepMesh_IncrementalMesh_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _BRepMesh.delete_BRepMesh_IncrementalMesh
BRepMesh_IncrementalMesh_swigregister = _BRepMesh.BRepMesh_IncrementalMesh_swigregister
BRepMesh_IncrementalMesh_swigregister(BRepMesh_IncrementalMesh)

def BRepMesh_IncrementalMesh_Discret(*args):
    """
    BRepMesh_IncrementalMesh_Discret(TopoDS_Shape theShape, Standard_Real const theLinDeflection, Standard_Real const theAngDeflection, BRepMesh_DiscretRoot *& theAlgo) -> Standard_Integer

    Plugin interface for the Mesh Factories.
    Initializes meshing algorithm with the given parameters.
    @param theShape shape to be meshed.
    @param theLinDeflection linear deflection.
    @param theAngDeflection angular deflection.
    @param[out] theAlgo pointer to initialized algorithm.

    :type theShape: OCC.wrapper.TopoDS.TopoDS_Shape
    :type theLinDeflection: float
    :type theAngDeflection: float
    :type theAlgo: OCC.wrapper.BRepMesh.BRepMesh_DiscretRoot
    :rtype: OCC.wrapper.Standard.Standard_Integer

    """
    return _BRepMesh.BRepMesh_IncrementalMesh_Discret(*args)

def BRepMesh_IncrementalMesh_IsParallelDefault(*args):
    """
    BRepMesh_IncrementalMesh_IsParallelDefault() -> Standard_Boolean

    Returns multi-threading usage flag set by default in 
    Discret() static method (thus applied only to Mesh Factories).

    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _BRepMesh.BRepMesh_IncrementalMesh_IsParallelDefault(*args)

def BRepMesh_IncrementalMesh_SetParallelDefault(*args):
    """
    BRepMesh_IncrementalMesh_SetParallelDefault(Standard_Boolean const isInParallel)

    Setup multi-threading usage flag set by default in 
    Discret() static method (thus applied only to Mesh Factories).

    :type isInParallel: bool

    """
    return _BRepMesh.BRepMesh_IncrementalMesh_SetParallelDefault(*args)

def BRepMesh_IncrementalMesh_get_type_name(*args):
    """
    BRepMesh_IncrementalMesh_get_type_name() -> char const *

    :rtype: const char *

    """
    return _BRepMesh.BRepMesh_IncrementalMesh_get_type_name(*args)

def BRepMesh_IncrementalMesh_get_type_descriptor(*args):
    """
    BRepMesh_IncrementalMesh_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _BRepMesh.BRepMesh_IncrementalMesh_get_type_descriptor(*args)

class BRepMesh_FaceAttribute(Standard.Standard_Transient):
    """Auxiliary class for FastDiscret and FastDiscretFace classes."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_BRepMesh_FaceAttribute
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_BRepMesh_FaceAttribute(self) 
            return h


    def __init__(self, *args):
        """
        __init__(BRepMesh_FaceAttribute self, BRepMesh::HDMapOfVertexInteger const & theBoundaryVertices, BRepMesh::HDMapOfIntegerPnt const & theBoundaryPoints) -> BRepMesh_FaceAttribute
        __init__(BRepMesh_FaceAttribute self, TopoDS_Face theFace, BRepMesh::HDMapOfVertexInteger const & theBoundaryVertices, BRepMesh::HDMapOfIntegerPnt const & theBoundaryPoints, Standard_Boolean const theAdaptiveMin) -> BRepMesh_FaceAttribute

        Constructor.
        @param theFace face the attribute is created for. 
        Used for default initialization. Attribute keeps reference 
        to the source face with forward orientation.
        @param theBoundaryVertices shared map of shape vertices.
        @param theBoundaryPoints shared discretization points of shape boundaries.
        @param theAdaptiveMin switches on adaptive computation of minimal parametric
        tolerance (if true).

        :type theFace: OCC.wrapper.TopoDS.TopoDS_Face
        :type theBoundaryVertices: HDMapOfVertexInteger
        :type theBoundaryPoints: HDMapOfIntegerPnt
        :type theAdaptiveMin: bool

        """
        this = _BRepMesh.new_BRepMesh_FaceAttribute(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Surface(self, *args):
        """
        Returns face's surface.

        :rtype: OCC.wrapper.BRepAdaptor.Handle_BRepAdaptor_HSurface

        """
        res = _BRepMesh.BRepMesh_FaceAttribute_Surface(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def IsInitialized(self, *args):
        """
        IsInitialized(BRepMesh_FaceAttribute self) -> Standard_Boolean

        Returns True in case if this attribute has already been intialized.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepMesh.BRepMesh_FaceAttribute_IsInitialized(self, *args)


    def SetFace(self, *args):
        """
        SetFace(BRepMesh_FaceAttribute self, TopoDS_Face theFace, Standard_Boolean const theAdaptiveMin)

        Initializes this attribute by the given face.

        :type theFace: OCC.wrapper.TopoDS.TopoDS_Face
        :type theAdaptiveMin: bool

        """
        return _BRepMesh.BRepMesh_FaceAttribute_SetFace(self, *args)


    def Face(self, *args):
        """
        Returns forward oriented face to be used for calculations.

        :rtype: OCC.wrapper.TopoDS.TopoDS_Face

        """
        res = _BRepMesh.BRepMesh_FaceAttribute_Face(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetBoundaryVertices(self, *args):
        """
        SetBoundaryVertices(BRepMesh_FaceAttribute self, BRepMesh::HDMapOfVertexInteger const & theVertices)

        Sets boundary vertices map.

        :type theVertices: HDMapOfVertexInteger

        """
        return _BRepMesh.BRepMesh_FaceAttribute_SetBoundaryVertices(self, *args)


    def SetBoundaryPoints(self, *args):
        """
        SetBoundaryPoints(BRepMesh_FaceAttribute self, BRepMesh::HDMapOfIntegerPnt const & theBoundaryPoints)

        Sets boundary points map.

        :type theBoundaryPoints: HDMapOfIntegerPnt

        """
        return _BRepMesh.BRepMesh_FaceAttribute_SetBoundaryPoints(self, *args)


    def ToleranceU(self, *args):
        """
        ToleranceU(BRepMesh_FaceAttribute self) -> Standard_Real

        Returns U tolerance of face calculated regarding its parameters.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _BRepMesh.BRepMesh_FaceAttribute_ToleranceU(self, *args)


    def ToleranceV(self, *args):
        """
        ToleranceV(BRepMesh_FaceAttribute self) -> Standard_Real

        Returns V tolerance of face calculated regarding its parameters.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _BRepMesh.BRepMesh_FaceAttribute_ToleranceV(self, *args)


    def GetDefFace(self, *args):
        """
        GetDefFace(BRepMesh_FaceAttribute self) -> Standard_Real

        Gives face deflection parameter.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _BRepMesh.BRepMesh_FaceAttribute_GetDefFace(self, *args)


    def SetDefFace(self, *args):
        """
        SetDefFace(BRepMesh_FaceAttribute self, Standard_Real const theDefFace)

        Sets face deflection.

        :type theDefFace: float

        """
        return _BRepMesh.BRepMesh_FaceAttribute_SetDefFace(self, *args)


    def GetUMin(self, *args):
        """
        GetUMin(BRepMesh_FaceAttribute self) -> Standard_Real

        Gives minimal value in U domain.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _BRepMesh.BRepMesh_FaceAttribute_GetUMin(self, *args)


    def SetUMin(self, *args):
        """
        SetUMin(BRepMesh_FaceAttribute self, Standard_Real const theUMin)

        Sets minimal value in U domain.

        :type theUMin: float

        """
        return _BRepMesh.BRepMesh_FaceAttribute_SetUMin(self, *args)


    def GetVMin(self, *args):
        """
        GetVMin(BRepMesh_FaceAttribute self) -> Standard_Real

        Gives minimal value in V domain.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _BRepMesh.BRepMesh_FaceAttribute_GetVMin(self, *args)


    def SetVMin(self, *args):
        """
        SetVMin(BRepMesh_FaceAttribute self, Standard_Real const theVMin)

        Sets minimal value in V domain.

        :type theVMin: float

        """
        return _BRepMesh.BRepMesh_FaceAttribute_SetVMin(self, *args)


    def GetUMax(self, *args):
        """
        GetUMax(BRepMesh_FaceAttribute self) -> Standard_Real

        Gives maximal value in U domain.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _BRepMesh.BRepMesh_FaceAttribute_GetUMax(self, *args)


    def SetUMax(self, *args):
        """
        SetUMax(BRepMesh_FaceAttribute self, Standard_Real const theUMax)

        Sets maximal value in U domain.

        :type theUMax: float

        """
        return _BRepMesh.BRepMesh_FaceAttribute_SetUMax(self, *args)


    def GetVMax(self, *args):
        """
        GetVMax(BRepMesh_FaceAttribute self) -> Standard_Real

        Gives maximal value in V domain.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _BRepMesh.BRepMesh_FaceAttribute_GetVMax(self, *args)


    def SetVMax(self, *args):
        """
        SetVMax(BRepMesh_FaceAttribute self, Standard_Real const theVMax)

        Sets maximal value in V domain.

        :type theVMax: float

        """
        return _BRepMesh.BRepMesh_FaceAttribute_SetVMax(self, *args)


    def GetDeltaX(self, *args):
        """
        GetDeltaX(BRepMesh_FaceAttribute self) -> Standard_Real

        Gives value of step in U domain.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _BRepMesh.BRepMesh_FaceAttribute_GetDeltaX(self, *args)


    def SetDeltaX(self, *args):
        """
        SetDeltaX(BRepMesh_FaceAttribute self, Standard_Real const theDeltaX)

        Sets value of step in U domain.

        :type theDeltaX: float

        """
        return _BRepMesh.BRepMesh_FaceAttribute_SetDeltaX(self, *args)


    def GetDeltaY(self, *args):
        """
        GetDeltaY(BRepMesh_FaceAttribute self) -> Standard_Real

        Gives value of step in V domain.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _BRepMesh.BRepMesh_FaceAttribute_GetDeltaY(self, *args)


    def SetDeltaY(self, *args):
        """
        SetDeltaY(BRepMesh_FaceAttribute self, Standard_Real const theDeltaY)

        Sets value of step in V domain.

        :type theDeltaY: float

        """
        return _BRepMesh.BRepMesh_FaceAttribute_SetDeltaY(self, *args)


    def GetStatus(self, *args):
        """
        GetStatus(BRepMesh_FaceAttribute self) -> Standard_Integer

        Sets set of status flags for this face.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepMesh.BRepMesh_FaceAttribute_GetStatus(self, *args)


    def SetStatus(self, *args):
        """
        SetStatus(BRepMesh_FaceAttribute self, BRepMesh_Status const theStatus)

        Sets status flag for this face.

        :type theStatus: OCC.wrapper.BRepMesh.BRepMesh_Status

        """
        return _BRepMesh.BRepMesh_FaceAttribute_SetStatus(self, *args)


    def IsValid(self, *args):
        """
        IsValid(BRepMesh_FaceAttribute self) -> Standard_Boolean

        Returns TRUE in case if computed data is valid.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepMesh.BRepMesh_FaceAttribute_IsValid(self, *args)


    def Clear(self, *args):
        """
        Clear(BRepMesh_FaceAttribute self)

        Clear face attribute.


        """
        return _BRepMesh.BRepMesh_FaceAttribute_Clear(self, *args)


    def ChangeInternalEdges(self, *args):
        """
        ChangeInternalEdges(BRepMesh_FaceAttribute self) -> BRepMesh::HDMapOfShapePairOfPolygon &

        Gives reference to map of internal edges of face.

        :rtype: HDMapOfShapePairOfPolygon

        """
        return _BRepMesh.BRepMesh_FaceAttribute_ChangeInternalEdges(self, *args)


    def ChangeLocation2D(self, *args):
        """
        ChangeLocation2D(BRepMesh_FaceAttribute self) -> BRepMesh::HDMapOfIntegerListOfXY &

        Gives reference to map of 2D points of discretization.

        :rtype: HDMapOfIntegerListOfXY

        """
        return _BRepMesh.BRepMesh_FaceAttribute_ChangeLocation2D(self, *args)


    def ChangeSurfacePoints(self, *args):
        """
        ChangeSurfacePoints(BRepMesh_FaceAttribute self) -> BRepMesh::HDMapOfIntegerPnt &

        Gives reference to map of 3D points of discretization.

        :rtype: HDMapOfIntegerPnt

        """
        return _BRepMesh.BRepMesh_FaceAttribute_ChangeSurfacePoints(self, *args)


    def ChangeSurfaceVertices(self, *args):
        """
        ChangeSurfaceVertices(BRepMesh_FaceAttribute self) -> BRepMesh::HDMapOfVertexInteger &

        Gives reference to map of vertices of discretization.

        :rtype: HDMapOfVertexInteger

        """
        return _BRepMesh.BRepMesh_FaceAttribute_ChangeSurfaceVertices(self, *args)


    def ChangeVertexEdgeMap(self, *args):
        """
        ChangeVertexEdgeMap(BRepMesh_FaceAttribute self) -> BRepMesh::HIMapOfInteger &

        Gives reference on map of (vertex, edge) pairs of face.

        :rtype: HIMapOfInteger

        """
        return _BRepMesh.BRepMesh_FaceAttribute_ChangeVertexEdgeMap(self, *args)


    def ChangeStructure(self, *args):
        """
        ChangeStructure(BRepMesh_FaceAttribute self) -> Handle_BRepMesh_DataStructureOfDelaun

        Gives Delaunay data structure.

        :rtype: OCC.wrapper.BRepMesh.Handle_BRepMesh_DataStructureOfDelaun

        """
        return _BRepMesh.BRepMesh_FaceAttribute_ChangeStructure(self, *args)


    def ChangeClassifier(self, *args):
        """
        ChangeClassifier(BRepMesh_FaceAttribute self) -> BRepMesh::HClassifier &

        Returns classifier.

        :rtype: HClassifier

        """
        return _BRepMesh.BRepMesh_FaceAttribute_ChangeClassifier(self, *args)


    def ChangeMeshNodes(self, *args):
        """
        ChangeMeshNodes(BRepMesh_FaceAttribute self) -> BRepMesh::HVectorOfVertex &

        Returns mesh nodes calculated for boundaries.

        :rtype: HVectorOfVertex

        """
        return _BRepMesh.BRepMesh_FaceAttribute_ChangeMeshNodes(self, *args)


    def LastPointId(self, *args):
        """
        LastPointId(BRepMesh_FaceAttribute self) -> Standard_Integer

        Gives the number of different locations in 3D space.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepMesh.BRepMesh_FaceAttribute_LastPointId(self, *args)


    def GetPoint(self, *args):
        """
        Gives the 3D location of the vertex.

        :type theIndex: int
        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        res = _BRepMesh.BRepMesh_FaceAttribute_GetPoint(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def AddNode(self, *args):
        """
        AddNode(BRepMesh_FaceAttribute self, Standard_Integer const theIndex, gp_XY theUV, BRepMesh_DegreeOfFreedom const theMovability)

        Adds node with the given parameters to mesh.
        @param theIndex index of 3D point corresponded to the node.
        @param theUV node position.
        @param theMovability movability of a node.
        @param theNodeIndex index of vertex in mesh structure.
        @param theNodeOnEdgeIndex ordered index of node on the boundary.

        :type theIndex: int
        :type theUV: OCC.wrapper.gp.gp_XY
        :type theMovability: OCC.wrapper.BRepMesh.BRepMesh_DegreeOfFreedom
        :type theNodeIndex: int
        :type theNodeOnEdgeIndex: int

        """
        return _BRepMesh.BRepMesh_FaceAttribute_AddNode(self, *args)


    def Scale(self, *args):
        """
        Scale(BRepMesh_FaceAttribute self, gp_XY thePoint2d, Standard_Boolean const isToFaceBasis) -> gp_XY

        Scales the given point from real parametric space 
        to face basis and otherwise.
        @param thePoint2d point to be scaled.
        @param isToFaceBasis if TRUE converts point to face basis,
        otherwise performs reverse conversion.
        @return scaled point.

        :type thePoint2d: OCC.wrapper.gp.gp_XY
        :type isToFaceBasis: bool
        :rtype: OCC.wrapper.gp.gp_XY

        """
        return _BRepMesh.BRepMesh_FaceAttribute_Scale(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _BRepMesh.BRepMesh_FaceAttribute_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _BRepMesh.BRepMesh_FaceAttribute_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _BRepMesh.BRepMesh_FaceAttribute_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _BRepMesh.delete_BRepMesh_FaceAttribute
BRepMesh_FaceAttribute_swigregister = _BRepMesh.BRepMesh_FaceAttribute_swigregister
BRepMesh_FaceAttribute_swigregister(BRepMesh_FaceAttribute)

def BRepMesh_FaceAttribute_get_type_name(*args):
    """
    BRepMesh_FaceAttribute_get_type_name() -> char const *

    :rtype: const char *

    """
    return _BRepMesh.BRepMesh_FaceAttribute_get_type_name(*args)

def BRepMesh_FaceAttribute_get_type_descriptor(*args):
    """
    BRepMesh_FaceAttribute_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _BRepMesh.BRepMesh_FaceAttribute_get_type_descriptor(*args)

class BRepMesh_IEdgeTool(Standard.Standard_Transient):
    """Interface class providing API for edge tessellation tools."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_BRepMesh_IEdgeTool
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_BRepMesh_IEdgeTool(self) 
            return h


    def NbPoints(self, *args):
        """
        NbPoints(BRepMesh_IEdgeTool self) -> Standard_Integer

        Returns number of tessellation points.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepMesh.BRepMesh_IEdgeTool_NbPoints(self, *args)


    def Value(self, *args):
        """
        Value(BRepMesh_IEdgeTool self, Standard_Integer const theIndex, gp_Pnt thePoint, gp_Pnt2d theUV) -> Standard_Boolean

        Returns parameters of solution with the given index.
        @param theIndex index of tessellation point.
        @param theParameter parameters on PCurve corresponded to the solution.
        @param thePoint tessellation point.
        @param theUV coordinates of tessellation point in parametric space of face.
        @return True in case of valid result, false elewhere.

        :type theIndex: int
        :type theParameter: float
        :type thePoint: OCC.wrapper.gp.gp_Pnt
        :type theUV: OCC.wrapper.gp.gp_Pnt2d
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepMesh.BRepMesh_IEdgeTool_Value(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _BRepMesh.BRepMesh_IEdgeTool_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _BRepMesh.BRepMesh_IEdgeTool_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _BRepMesh.BRepMesh_IEdgeTool_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _BRepMesh.delete_BRepMesh_IEdgeTool
BRepMesh_IEdgeTool_swigregister = _BRepMesh.BRepMesh_IEdgeTool_swigregister
BRepMesh_IEdgeTool_swigregister(BRepMesh_IEdgeTool)

def BRepMesh_IEdgeTool_get_type_name(*args):
    """
    BRepMesh_IEdgeTool_get_type_name() -> char const *

    :rtype: const char *

    """
    return _BRepMesh.BRepMesh_IEdgeTool_get_type_name(*args)

def BRepMesh_IEdgeTool_get_type_descriptor(*args):
    """
    BRepMesh_IEdgeTool_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _BRepMesh.BRepMesh_IEdgeTool_get_type_descriptor(*args)

class BRepMesh_EdgeTessellationExtractor(BRepMesh_IEdgeTool):
    """
    Auxiliary class implements functionality retrieving tessellated
    representation of an edge stored in polygon.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_BRepMesh_EdgeTessellationExtractor
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_BRepMesh_EdgeTessellationExtractor(self) 
            return h


    def NbPoints(self, *args):
        """
        NbPoints(BRepMesh_EdgeTessellationExtractor self) -> Standard_Integer

        Returns number of dicretization points.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepMesh.BRepMesh_EdgeTessellationExtractor_NbPoints(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _BRepMesh.BRepMesh_EdgeTessellationExtractor_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _BRepMesh.BRepMesh_EdgeTessellationExtractor_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _BRepMesh.BRepMesh_EdgeTessellationExtractor_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _BRepMesh.delete_BRepMesh_EdgeTessellationExtractor
BRepMesh_EdgeTessellationExtractor_swigregister = _BRepMesh.BRepMesh_EdgeTessellationExtractor_swigregister
BRepMesh_EdgeTessellationExtractor_swigregister(BRepMesh_EdgeTessellationExtractor)

def BRepMesh_EdgeTessellationExtractor_get_type_name(*args):
    """
    BRepMesh_EdgeTessellationExtractor_get_type_name() -> char const *

    :rtype: const char *

    """
    return _BRepMesh.BRepMesh_EdgeTessellationExtractor_get_type_name(*args)

def BRepMesh_EdgeTessellationExtractor_get_type_descriptor(*args):
    """
    BRepMesh_EdgeTessellationExtractor_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _BRepMesh.BRepMesh_EdgeTessellationExtractor_get_type_descriptor(*args)

class BRepMesh_Delaun(object):
    """Compute the Delaunay's triangulation with the algorithm of Watson."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BRepMesh_Delaun self, BRepMesh::Array1OfVertexOfDelaun & theVertices) -> BRepMesh_Delaun
        __init__(BRepMesh_Delaun self, Handle_BRepMesh_DataStructureOfDelaun theOldMesh, BRepMesh::Array1OfVertexOfDelaun & theVertices) -> BRepMesh_Delaun
        __init__(BRepMesh_Delaun self, Handle_BRepMesh_DataStructureOfDelaun theOldMesh, BRepMesh::Array1OfInteger & theVertexIndices) -> BRepMesh_Delaun
        __init__(BRepMesh_Delaun self, Handle_BRepMesh_DataStructureOfDelaun theOldMesh, BRepMesh::Array1OfInteger & theVertexIndices, Standard_Integer const theCellsCountU, Standard_Integer const theCellsCountV) -> BRepMesh_Delaun

        Creates the triangulation with an existant Mesh data structure.

        :type theOldMesh: OCC.wrapper.BRepMesh.Handle_BRepMesh_DataStructureOfDelaun
        :type theVertexIndices: Array1OfInteger
        :type theCellsCountU: int
        :type theCellsCountV: int

        """
        this = _BRepMesh.new_BRepMesh_Delaun(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(BRepMesh_Delaun self, BRepMesh::Array1OfVertexOfDelaun & theVertices)

        Initializes the triangulation with an array of vertices.

        :type theVertices: Array1OfVertexOfDelaun

        """
        return _BRepMesh.BRepMesh_Delaun_Init(self, *args)


    def RemoveVertex(self, *args):
        """
        RemoveVertex(BRepMesh_Delaun self, BRepMesh_Vertex theVertex)

        Removes a vertex from the triangulation.

        :type theVertex: OCC.wrapper.BRepMesh.BRepMesh_Vertex

        """
        return _BRepMesh.BRepMesh_Delaun_RemoveVertex(self, *args)


    def AddVertices(self, *args):
        """
        AddVertices(BRepMesh_Delaun self, BRepMesh::Array1OfVertexOfDelaun & theVertices)

        Adds some vertices into the triangulation.

        :type theVertices: Array1OfVertexOfDelaun

        """
        return _BRepMesh.BRepMesh_Delaun_AddVertices(self, *args)


    def UseEdge(self, *args):
        """
        UseEdge(BRepMesh_Delaun self, Standard_Integer const theEdge) -> Standard_Boolean

        Modify mesh to use the edge.
        @return True if done

        :type theEdge: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepMesh.BRepMesh_Delaun_UseEdge(self, *args)


    def Result(self, *args):
        """
        Gives the Mesh data structure.

        :rtype: OCC.wrapper.BRepMesh.Handle_BRepMesh_DataStructureOfDelaun

        """
        res = _BRepMesh.BRepMesh_Delaun_Result(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def GetVertex(self, *args):
        """
        Gives vertex with the given index

        :type theIndex: int
        :rtype: OCC.wrapper.BRepMesh.BRepMesh_Vertex

        """
        res = _BRepMesh.BRepMesh_Delaun_GetVertex(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def GetEdge(self, *args):
        """
        Gives edge with the given index

        :type theIndex: int
        :rtype: OCC.wrapper.BRepMesh.BRepMesh_Edge

        """
        res = _BRepMesh.BRepMesh_Delaun_GetEdge(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def GetTriangle(self, *args):
        """
        Gives triangle with the given index

        :type theIndex: int
        :rtype: OCC.wrapper.BRepMesh.BRepMesh_Triangle

        """
        res = _BRepMesh.BRepMesh_Delaun_GetTriangle(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Circles(self, *args):
        """
        Returns tool used to build mesh consistent to Delaunay criteria.

        :rtype: OCC.wrapper.BRepMesh.BRepMesh_CircleTool

        """
        res = _BRepMesh.BRepMesh_Delaun_Circles(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Contains(self, *args):
        """
        Contains(BRepMesh_Delaun self, Standard_Integer const theTriangleId, BRepMesh_Vertex theVertex, Standard_Real const theSqTolerance) -> Standard_Boolean

        Test is the given triangle contains the given vertex.
        @param theSqTolerance square tolerance to check closeness to some edge
        @param theEdgeOn If it is != 0 the vertex lies onto the edge index
        returned through this parameter.

        :type theTriangleId: int
        :type theVertex: OCC.wrapper.BRepMesh.BRepMesh_Vertex
        :type theSqTolerance: float
        :type theEdgeOn: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepMesh.BRepMesh_Delaun_Contains(self, *args)

    __swig_destroy__ = _BRepMesh.delete_BRepMesh_Delaun
BRepMesh_Delaun_swigregister = _BRepMesh.BRepMesh_Delaun_swigregister
BRepMesh_Delaun_swigregister(BRepMesh_Delaun)

class BRepMesh_WireChecker(object):
    """
    Auxilary class intended to check correctness of discretized face.
    In particular, checks boundaries of discretized face for self 
    intersections and gaps.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BRepMesh_WireChecker self, TopoDS_Face theFace, Standard_Real const theTolUV, BRepMesh::HDMapOfShapePairOfPolygon const & theEdges, BRepMesh::HIMapOfInteger const & theVertexMap, Handle_BRepMesh_DataStructureOfDelaun theStructure, Standard_Real const theUmin, Standard_Real const theUmax, Standard_Real const theVmin, Standard_Real const theVmax, Standard_Boolean const isInParallel) -> BRepMesh_WireChecker

        Constructor.
        @param theFace Face to be checked.
        @param theTolUV Tolerance to be used for calculations in parametric space.
        @param theEdges Map of edges with associated polygon on triangulation.
        @param theVertexMap Map of face vertices.
        @param theStructure Discretized representation of face in parametric space.
        @param theUmin Lower U boundary of the face in parametric space.
        @param theUmax Upper U boundary of the face in parametric space.
        @param theVmin Lower V boundary of the face in parametric space.
        @param theVmax Upper V boundary of the face in parametric space.

        :type theFace: OCC.wrapper.TopoDS.TopoDS_Face
        :type theTolUV: float
        :type theEdges: HDMapOfShapePairOfPolygon
        :type theVertexMap: HIMapOfInteger
        :type theStructure: OCC.wrapper.BRepMesh.Handle_BRepMesh_DataStructureOfDelaun
        :type theUmin: float
        :type theUmax: float
        :type theVmin: float
        :type theVmax: float
        :type isInParallel: bool

        """
        this = _BRepMesh.new_BRepMesh_WireChecker(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def ReCompute(self, *args):
        """
        ReCompute(BRepMesh_WireChecker self, BRepMesh::HClassifier & theClassifier)

        Recompute data using parameters passed in constructor.
        @param[out] theClassifier Classifier to be updated using calculated data.

        :type theClassifier: HClassifier

        """
        return _BRepMesh.BRepMesh_WireChecker_ReCompute(self, *args)


    def Status(self, *args):
        """
        Status(BRepMesh_WireChecker self) -> BRepMesh_Status

        Returns status of the check.

        :rtype: OCC.wrapper.BRepMesh.BRepMesh_Status

        """
        return _BRepMesh.BRepMesh_WireChecker_Status(self, *args)

    __swig_destroy__ = _BRepMesh.delete_BRepMesh_WireChecker
BRepMesh_WireChecker_swigregister = _BRepMesh.BRepMesh_WireChecker_swigregister
BRepMesh_WireChecker_swigregister(BRepMesh_WireChecker)

class Handle_BRepMesh_DataStructureOfDelaun(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_BRepMesh_DataStructureOfDelaun self)

        Nullify the handle


        """
        return _BRepMesh.Handle_BRepMesh_DataStructureOfDelaun_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_BRepMesh_DataStructureOfDelaun self) -> bool

        Check for being null

        :rtype: bool

        """
        return _BRepMesh.Handle_BRepMesh_DataStructureOfDelaun_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_BRepMesh_DataStructureOfDelaun self, BRepMesh_DataStructureOfDelaun thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _BRepMesh.Handle_BRepMesh_DataStructureOfDelaun_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_BRepMesh_DataStructureOfDelaun self, Handle_BRepMesh_DataStructureOfDelaun theHandle) -> Handle_BRepMesh_DataStructureOfDelaun
        assign(Handle_BRepMesh_DataStructureOfDelaun self, BRepMesh_DataStructureOfDelaun thePtr) -> Handle_BRepMesh_DataStructureOfDelaun
        assign(Handle_BRepMesh_DataStructureOfDelaun self, Handle_BRepMesh_DataStructureOfDelaun theHandle) -> Handle_BRepMesh_DataStructureOfDelaun

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _BRepMesh.Handle_BRepMesh_DataStructureOfDelaun_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_BRepMesh_DataStructureOfDelaun self) -> BRepMesh_DataStructureOfDelaun

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _BRepMesh.Handle_BRepMesh_DataStructureOfDelaun_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_BRepMesh_DataStructureOfDelaun self) -> BRepMesh_DataStructureOfDelaun

        Member access operator (note non-const)

        :rtype: T *

        """
        return _BRepMesh.Handle_BRepMesh_DataStructureOfDelaun___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_BRepMesh_DataStructureOfDelaun self) -> BRepMesh_DataStructureOfDelaun

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _BRepMesh.Handle_BRepMesh_DataStructureOfDelaun___ref__(self, *args)


    def __hash__(self):
        return _BRepMesh.Handle_BRepMesh_DataStructureOfDelaun___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _BRepMesh.Handle_BRepMesh_DataStructureOfDelaun___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _BRepMesh.new_Handle_BRepMesh_DataStructureOfDelaun(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_BRepMesh.Handle_BRepMesh_DataStructureOfDelaun_DownCast)
    __swig_destroy__ = _BRepMesh.delete_Handle_BRepMesh_DataStructureOfDelaun

    def NbNodes(self, *args):
        """
        NbNodes(Handle_BRepMesh_DataStructureOfDelaun self) -> Standard_Integer

        Returns number of nodes.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepMesh.Handle_BRepMesh_DataStructureOfDelaun_NbNodes(self, *args)


    def AddNode(self, *args):
        """
        AddNode(Handle_BRepMesh_DataStructureOfDelaun self, BRepMesh_Vertex theNode, Standard_Boolean const isForceAdd) -> Standard_Integer

        Adds node to the mesh if it is not already in the mesh.
        @param theNode node to be added to the mesh.
        @param isForceAdd adds the given node to structure without 
        checking on coincidence with other nodes.
        @return index of the node in the structure.

        :type theNode: OCC.wrapper.BRepMesh.BRepMesh_Vertex
        :type isForceAdd: bool
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepMesh.Handle_BRepMesh_DataStructureOfDelaun_AddNode(self, *args)


    def IndexOf(self, *args):
        """
        IndexOf(Handle_BRepMesh_DataStructureOfDelaun self, BRepMesh_Vertex theNode) -> Standard_Integer
        IndexOf(Handle_BRepMesh_DataStructureOfDelaun self, BRepMesh_Edge theLink) -> Standard_Integer
        IndexOf(Handle_BRepMesh_DataStructureOfDelaun self, BRepMesh_Triangle theElement) -> Standard_Integer

        Finds the index of the given element.
        @param theElement element to find.
        @return index of the given element of zero if element is not in the mesh.

        :type theElement: OCC.wrapper.BRepMesh.BRepMesh_Triangle
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepMesh.Handle_BRepMesh_DataStructureOfDelaun_IndexOf(self, *args)


    def GetNode(self, *args):
        """
        Get node by the index.
        @param theIndex index of a node.
        @return node with the given index.

        :type theIndex: int
        :rtype: OCC.wrapper.BRepMesh.BRepMesh_Vertex

        """
        res = _BRepMesh.Handle_BRepMesh_DataStructureOfDelaun_GetNode(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __call__(self, *args):
        """
        Alias for GetNode.

        :type theIndex: int
        :rtype: OCC.wrapper.BRepMesh.BRepMesh_Vertex

        """
        res = _BRepMesh.Handle_BRepMesh_DataStructureOfDelaun___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SubstituteNode(self, *args):
        """
        SubstituteNode(Handle_BRepMesh_DataStructureOfDelaun self, Standard_Integer const theIndex, BRepMesh_Vertex theNewNode) -> Standard_Boolean

        Substitutes the node with the given index by new one.
        @param theIndex index of node to be substituted.
        @param theNewNode substituting node.
        @return FALSE in case if new node is already in the structure, TRUE elsewhere.

        :type theIndex: int
        :type theNewNode: OCC.wrapper.BRepMesh.BRepMesh_Vertex
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepMesh.Handle_BRepMesh_DataStructureOfDelaun_SubstituteNode(self, *args)


    def RemoveNode(self, *args):
        """
        RemoveNode(Handle_BRepMesh_DataStructureOfDelaun self, Standard_Integer const theIndex, Standard_Boolean const isForce)

        Removes node from the mesh in case if it has no connected links 
        and its type is Free.
        @param theIndex index of node to be removed.
        @param isForce if TRUE node will be removed even if movability
        is not Free.

        :type theIndex: int
        :type isForce: bool

        """
        return _BRepMesh.Handle_BRepMesh_DataStructureOfDelaun_RemoveNode(self, *args)


    def LinksConnectedTo(self, *args):
        """
        Get list of links attached to the node with the given index.
        @param theIndex index of node whose links should be retrieved.
        @return list of links attached to the node.

        :type theIndex: int
        :rtype: ListOfInteger

        """
        res = _BRepMesh.Handle_BRepMesh_DataStructureOfDelaun_LinksConnectedTo(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def NbLinks(self, *args):
        """
        NbLinks(Handle_BRepMesh_DataStructureOfDelaun self) -> Standard_Integer

        Returns number of links.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepMesh.Handle_BRepMesh_DataStructureOfDelaun_NbLinks(self, *args)


    def AddLink(self, *args):
        """
        AddLink(Handle_BRepMesh_DataStructureOfDelaun self, BRepMesh_Edge theLink) -> Standard_Integer

        Adds link to the mesh if it is not already in the mesh.
        @param theLink link to be added to the mesh.
        @return index of the link in the structure.

        :type theLink: OCC.wrapper.BRepMesh.BRepMesh_Edge
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepMesh.Handle_BRepMesh_DataStructureOfDelaun_AddLink(self, *args)


    def GetLink(self, *args):
        """
        Get link by the index.
        @param theIndex index of a link.
        @return link with the given index.

        :type theIndex: int
        :rtype: OCC.wrapper.BRepMesh.BRepMesh_Edge

        """
        res = _BRepMesh.Handle_BRepMesh_DataStructureOfDelaun_GetLink(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def LinksOfDomain(self, *args):
        """
        Returns map of indices of links registered in mesh.

        :rtype: MapOfInteger

        """
        res = _BRepMesh.Handle_BRepMesh_DataStructureOfDelaun_LinksOfDomain(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SubstituteLink(self, *args):
        """
        SubstituteLink(Handle_BRepMesh_DataStructureOfDelaun self, Standard_Integer const theIndex, BRepMesh_Edge theNewLink) -> Standard_Boolean

        Substitutes the link with the given index by new one.
        @param theIndex index of link to be substituted.
        @param theNewLink substituting link.
        @return FALSE in case if new link is already in the structure, TRUE elsewhere.

        :type theIndex: int
        :type theNewLink: OCC.wrapper.BRepMesh.BRepMesh_Edge
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepMesh.Handle_BRepMesh_DataStructureOfDelaun_SubstituteLink(self, *args)


    def RemoveLink(self, *args):
        """
        RemoveLink(Handle_BRepMesh_DataStructureOfDelaun self, Standard_Integer const theIndex, Standard_Boolean const isForce)

        Removes link from the mesh in case if it has no connected elements 
        and its type is Free.
        @param theIndex index of link to be removed.
        @param isForce if TRUE link will be removed even if movability
        is not Free.

        :type theIndex: int
        :type isForce: bool

        """
        return _BRepMesh.Handle_BRepMesh_DataStructureOfDelaun_RemoveLink(self, *args)


    def ElementsConnectedTo(self, *args):
        """
        Returns indices of elements conected to the link with the given index.
        @param theLinkIndex index of link whose data should be retrieved.
        @return indices of elements conected to the link.

        :type theLinkIndex: int
        :rtype: OCC.wrapper.BRepMesh.BRepMesh_PairOfIndex

        """
        res = _BRepMesh.Handle_BRepMesh_DataStructureOfDelaun_ElementsConnectedTo(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def NbElements(self, *args):
        """
        NbElements(Handle_BRepMesh_DataStructureOfDelaun self) -> Standard_Integer

        Returns number of links.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepMesh.Handle_BRepMesh_DataStructureOfDelaun_NbElements(self, *args)


    def AddElement(self, *args):
        """
        AddElement(Handle_BRepMesh_DataStructureOfDelaun self, BRepMesh_Triangle theElement) -> Standard_Integer

        Adds element to the mesh if it is not already in the mesh.
        @param theElement element to be added to the mesh.
        @return index of the element in the structure.

        :type theElement: OCC.wrapper.BRepMesh.BRepMesh_Triangle
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepMesh.Handle_BRepMesh_DataStructureOfDelaun_AddElement(self, *args)


    def GetElement(self, *args):
        """
        Get element by the index.
        @param theIndex index of an element.
        @return element with the given index.

        :type theIndex: int
        :rtype: OCC.wrapper.BRepMesh.BRepMesh_Triangle

        """
        res = _BRepMesh.Handle_BRepMesh_DataStructureOfDelaun_GetElement(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ElementsOfDomain(self, *args):
        """
        Returns map of indices of elements registered in mesh.

        :rtype: MapOfInteger

        """
        res = _BRepMesh.Handle_BRepMesh_DataStructureOfDelaun_ElementsOfDomain(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SubstituteElement(self, *args):
        """
        SubstituteElement(Handle_BRepMesh_DataStructureOfDelaun self, Standard_Integer const theIndex, BRepMesh_Triangle theNewElement) -> Standard_Boolean

        Substitutes the element with the given index by new one.
        @param theIndex index of element to be substituted.
        @param theNewLink substituting element.
        @return FALSE in case if new element is already in the structure, TRUE elsewhere.

        :type theIndex: int
        :type theNewElement: OCC.wrapper.BRepMesh.BRepMesh_Triangle
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepMesh.Handle_BRepMesh_DataStructureOfDelaun_SubstituteElement(self, *args)


    def RemoveElement(self, *args):
        """
        RemoveElement(Handle_BRepMesh_DataStructureOfDelaun self, Standard_Integer const theIndex)

        Removes element from the mesh.
        @param theIndex index of element to be removed.

        :type theIndex: int

        """
        return _BRepMesh.Handle_BRepMesh_DataStructureOfDelaun_RemoveElement(self, *args)


    def ElementNodes(self, *args):
        """
        ElementNodes(Handle_BRepMesh_DataStructureOfDelaun self, BRepMesh_Triangle theElement, Standard_Integer (&)[3] theNodes)

        Returns indices of nodes forming the given element.
        @param theElement element which nodes should be retrieved.
        @param[out] theNodes nodes of the given element.

        :type theElement: OCC.wrapper.BRepMesh.BRepMesh_Triangle
        :type theNodes: OCC.wrapper.Standard.Standard_Integer (&)[3]

        """
        return _BRepMesh.Handle_BRepMesh_DataStructureOfDelaun_ElementNodes(self, *args)


    def Statistics(self, *args):
        """
        Statistics(Handle_BRepMesh_DataStructureOfDelaun self, Standard_OStream & theStream)

        Dumps information about this structure.
        @param theStream stream to be used for dump.

        :type theStream: OCC.wrapper.Standard.Standard_OStream

        """
        return _BRepMesh.Handle_BRepMesh_DataStructureOfDelaun_Statistics(self, *args)


    def Allocator(self, *args):
        """
        Returns memory allocator used by the structure.

        :rtype: OCC.wrapper.NCollection.Handle_NCollection_IncAllocator

        """
        res = _BRepMesh.Handle_BRepMesh_DataStructureOfDelaun_Allocator(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Data(self, *args):
        """
        Data(Handle_BRepMesh_DataStructureOfDelaun self) -> BRepMesh::HVertexTool &

        Gives the data structure for initialization of cell size and tolerance.

        :rtype: HVertexTool

        """
        return _BRepMesh.Handle_BRepMesh_DataStructureOfDelaun_Data(self, *args)


    def ClearDomain(self, *args):
        """
        ClearDomain(Handle_BRepMesh_DataStructureOfDelaun self)

        Removes all elements.


        """
        return _BRepMesh.Handle_BRepMesh_DataStructureOfDelaun_ClearDomain(self, *args)


    def ClearDeleted(self, *args):
        """
        ClearDeleted(Handle_BRepMesh_DataStructureOfDelaun self)

        Substitutes deleted items by the last one from corresponding map 
        to have only non-deleted elements, links or nodes in the structure.


        """
        return _BRepMesh.Handle_BRepMesh_DataStructureOfDelaun_ClearDeleted(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_BRepMesh_DataStructureOfDelaun self) -> char const *

        :rtype: const char *

        """
        return _BRepMesh.Handle_BRepMesh_DataStructureOfDelaun_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _BRepMesh.Handle_BRepMesh_DataStructureOfDelaun_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _BRepMesh.Handle_BRepMesh_DataStructureOfDelaun_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_BRepMesh_DataStructureOfDelaun self)

        Memory deallocator for transient classes


        """
        return _BRepMesh.Handle_BRepMesh_DataStructureOfDelaun_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_BRepMesh_DataStructureOfDelaun self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_BRepMesh_DataStructureOfDelaun self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepMesh.Handle_BRepMesh_DataStructureOfDelaun_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_BRepMesh_DataStructureOfDelaun self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_BRepMesh_DataStructureOfDelaun self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepMesh.Handle_BRepMesh_DataStructureOfDelaun_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_BRepMesh_DataStructureOfDelaun self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _BRepMesh.Handle_BRepMesh_DataStructureOfDelaun_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_BRepMesh_DataStructureOfDelaun self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepMesh.Handle_BRepMesh_DataStructureOfDelaun_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_BRepMesh_DataStructureOfDelaun self)

        Increments the reference counter of this object


        """
        return _BRepMesh.Handle_BRepMesh_DataStructureOfDelaun_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_BRepMesh_DataStructureOfDelaun self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepMesh.Handle_BRepMesh_DataStructureOfDelaun_DecrementRefCounter(self, *args)

Handle_BRepMesh_DataStructureOfDelaun_swigregister = _BRepMesh.Handle_BRepMesh_DataStructureOfDelaun_swigregister
Handle_BRepMesh_DataStructureOfDelaun_swigregister(Handle_BRepMesh_DataStructureOfDelaun)

def Handle_BRepMesh_DataStructureOfDelaun_DownCast(thing):
    return _BRepMesh.Handle_BRepMesh_DataStructureOfDelaun_DownCast(thing)
Handle_BRepMesh_DataStructureOfDelaun_DownCast = _BRepMesh.Handle_BRepMesh_DataStructureOfDelaun_DownCast

class BRepMesh_PairOfIndex(object):
    """
    This class represents a pair of integer indices to store 
    element indices connected to link. It is restricted to 
    store more than two indices in it.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BRepMesh_PairOfIndex self) -> BRepMesh_PairOfIndex

        Default constructor


        """
        this = _BRepMesh.new_BRepMesh_PairOfIndex(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Clear(self, *args):
        """
        Clear(BRepMesh_PairOfIndex self)

        Clears indices.


        """
        return _BRepMesh.BRepMesh_PairOfIndex_Clear(self, *args)


    def Append(self, *args):
        """
        Append(BRepMesh_PairOfIndex self, Standard_Integer const theIndex)

        Appends index to the pair.

        :type theIndex: int

        """
        return _BRepMesh.BRepMesh_PairOfIndex_Append(self, *args)


    def Prepend(self, *args):
        """
        Prepend(BRepMesh_PairOfIndex self, Standard_Integer const theIndex)

        Prepends index to the pair.

        :type theIndex: int

        """
        return _BRepMesh.BRepMesh_PairOfIndex_Prepend(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(BRepMesh_PairOfIndex self) -> Standard_Boolean

        Returns is pair is empty.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepMesh.BRepMesh_PairOfIndex_IsEmpty(self, *args)


    def Extent(self, *args):
        """
        Extent(BRepMesh_PairOfIndex self) -> Standard_Integer

        Returns number of initialized indeces.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepMesh.BRepMesh_PairOfIndex_Extent(self, *args)


    def FirstIndex(self, *args):
        """
        FirstIndex(BRepMesh_PairOfIndex self) -> Standard_Integer

        Returns first index of pair.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepMesh.BRepMesh_PairOfIndex_FirstIndex(self, *args)


    def LastIndex(self, *args):
        """
        LastIndex(BRepMesh_PairOfIndex self) -> Standard_Integer

        Returns last index of pair

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepMesh.BRepMesh_PairOfIndex_LastIndex(self, *args)


    def Index(self, *args):
        """
        Index(BRepMesh_PairOfIndex self, Standard_Integer const thePairPos) -> Standard_Integer

        Returns index corresponding to the given position in the pair.
        @param thePairPos position of index in the pair (1 or 2).

        :type thePairPos: int
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepMesh.BRepMesh_PairOfIndex_Index(self, *args)


    def SetIndex(self, *args):
        """
        SetIndex(BRepMesh_PairOfIndex self, Standard_Integer const thePairPos, Standard_Integer const theIndex)

        Sets index corresponding to the given position in the pair.
        @param thePairPos position of index in the pair (1 or 2).
        @param theIndex index to be stored.

        :type thePairPos: int
        :type theIndex: int

        """
        return _BRepMesh.BRepMesh_PairOfIndex_SetIndex(self, *args)


    def RemoveIndex(self, *args):
        """
        RemoveIndex(BRepMesh_PairOfIndex self, Standard_Integer const thePairPos)

        Remove index from the given position.
        @param thePairPos position of index in the pair (1 or 2).

        :type thePairPos: int

        """
        return _BRepMesh.BRepMesh_PairOfIndex_RemoveIndex(self, *args)

    __swig_destroy__ = _BRepMesh.delete_BRepMesh_PairOfIndex
BRepMesh_PairOfIndex_swigregister = _BRepMesh.BRepMesh_PairOfIndex_swigregister
BRepMesh_PairOfIndex_swigregister(BRepMesh_PairOfIndex)

class BRepMesh_CircleInspector(NCollection_CellFilter_InspectorXY):
    """Auxilary class to find circles shot by the given point."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BRepMesh_CircleInspector self, Standard_Real const theTolerance, Standard_Integer const theReservedSize, Handle_NCollection_IncAllocator theAllocator) -> BRepMesh_CircleInspector

        Constructor.
        @param theTolerance tolerance to be used for identification of shot circles.
        @param theReservedSize size to be reserved for vector of circles.
        @param theAllocator memory allocator to be used by internal collections.

        :type theTolerance: float
        :type theReservedSize: int
        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_IncAllocator

        """
        this = _BRepMesh.new_BRepMesh_CircleInspector(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Bind(self, *args):
        """
        Bind(BRepMesh_CircleInspector self, Standard_Integer const theIndex, BRepMesh_Circle theCircle)

        Adds the circle to vector of circles at the given position.
        @param theIndex position of circle in the vector.
        @param theCircle circle to be added.

        :type theIndex: int
        :type theCircle: OCC.wrapper.BRepMesh.BRepMesh_Circle

        """
        return _BRepMesh.BRepMesh_CircleInspector_Bind(self, *args)


    def Circles(self, *args):
        """
        Resutns vector of registered circles.

        :rtype: VectorOfCircle

        """
        res = _BRepMesh.BRepMesh_CircleInspector_Circles(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Circle(self, *args):
        """
        Circle(BRepMesh_CircleInspector self, Standard_Integer const theIndex) -> BRepMesh_Circle

        Returns circle with the given index.
        @param theIndex index of circle.
        @return circle with the given index.

        :type theIndex: int
        :rtype: OCC.wrapper.BRepMesh.BRepMesh_Circle

        """
        return _BRepMesh.BRepMesh_CircleInspector_Circle(self, *args)


    def SetPoint(self, *args):
        """
        SetPoint(BRepMesh_CircleInspector self, gp_XY thePoint)

        Set reference point to be checked.
        @param thePoint bullet point.

        :type thePoint: OCC.wrapper.gp.gp_XY

        """
        return _BRepMesh.BRepMesh_CircleInspector_SetPoint(self, *args)


    def GetShotCircles(self, *args):
        """
        GetShotCircles(BRepMesh_CircleInspector self) -> BRepMesh::ListOfInteger &

        Returns list of circles shot by the reference point.

        :rtype: ListOfInteger

        """
        return _BRepMesh.BRepMesh_CircleInspector_GetShotCircles(self, *args)


    def Inspect(self, *args):
        """
        Inspect(BRepMesh_CircleInspector self, Standard_Integer const theTargetIndex) -> NCollection_CellFilter_Action

        Performs inspection of a circle with the given index.
        @param theTargetIndex index of a circle to be checked.
        @return status of the check.

        :type theTargetIndex: int
        :rtype: OCC.wrapper.NCollection.NCollection_CellFilter_Action

        """
        return _BRepMesh.BRepMesh_CircleInspector_Inspect(self, *args)


    def IsEqual(*args):
        """
        IsEqual(Standard_Integer const theIndex, Standard_Integer const theTargetIndex) -> Standard_Boolean

        Checks indices for equlity.

        :type theIndex: int
        :type theTargetIndex: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepMesh.BRepMesh_CircleInspector_IsEqual(*args)

    IsEqual = staticmethod(IsEqual)
    __swig_destroy__ = _BRepMesh.delete_BRepMesh_CircleInspector
BRepMesh_CircleInspector_swigregister = _BRepMesh.BRepMesh_CircleInspector_swigregister
BRepMesh_CircleInspector_swigregister(BRepMesh_CircleInspector)

def BRepMesh_CircleInspector_IsEqual(*args):
    """
    BRepMesh_CircleInspector_IsEqual(Standard_Integer const theIndex, Standard_Integer const theTargetIndex) -> Standard_Boolean

    Checks indices for equlity.

    :type theIndex: int
    :type theTargetIndex: int
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _BRepMesh.BRepMesh_CircleInspector_IsEqual(*args)

class BRepMesh_Circle(object):
    """
    Describes a 2d circle with a size of only 3 Standard_Real 
    numbers instead of gp who needs 7 Standard_Real numbers.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BRepMesh_Circle self) -> BRepMesh_Circle
        __init__(BRepMesh_Circle self, gp_XY theLocation, Standard_Real const theRadius) -> BRepMesh_Circle

        Constructor.
        @param theLocation location of a circle.
        @param theRadius radius of a circle.

        :type theLocation: OCC.wrapper.gp.gp_XY
        :type theRadius: float

        """
        this = _BRepMesh.new_BRepMesh_Circle(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def SetLocation(self, *args):
        """
        SetLocation(BRepMesh_Circle self, gp_XY theLocation)

        Sets location of a circle.
        @param theLocation location of a circle.

        :type theLocation: OCC.wrapper.gp.gp_XY

        """
        return _BRepMesh.BRepMesh_Circle_SetLocation(self, *args)


    def SetRadius(self, *args):
        """
        SetRadius(BRepMesh_Circle self, Standard_Real const theRadius)

        Sets radius of a circle.
        @param theRadius radius of a circle.

        :type theRadius: float

        """
        return _BRepMesh.BRepMesh_Circle_SetRadius(self, *args)


    def Location(self, *args):
        """
        Returns location of a circle.

        :rtype: OCC.wrapper.gp.gp_XY

        """
        res = _BRepMesh.BRepMesh_Circle_Location(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Radius(self, *args):
        """
        Radius(BRepMesh_Circle self) -> Standard_Real const &

        Returns radius of a circle.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _BRepMesh.BRepMesh_Circle_Radius(self, *args)

    __swig_destroy__ = _BRepMesh.delete_BRepMesh_Circle
BRepMesh_Circle_swigregister = _BRepMesh.BRepMesh_Circle_swigregister
BRepMesh_Circle_swigregister(BRepMesh_Circle)

class BRepMesh_Triangle(object):
    """
    Light weighted structure representing triangle 
    of mesh consisting of oriented links.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BRepMesh_Triangle self) -> BRepMesh_Triangle
        __init__(BRepMesh_Triangle self, Standard_Integer const (&)[3] theEdges, Standard_Boolean const (&)[3] theOrientations, BRepMesh_DegreeOfFreedom const theMovability) -> BRepMesh_Triangle

        Constructor.
        @param theEdges array of edges of triangle.
        @param theOrientations array of edge's orientations.
        @param theMovability movability of triangle.

        :type theEdges: const Standard_Integer (&)[3]
        :type theOrientations: const Standard_Boolean (&)[3]
        :type theMovability: OCC.wrapper.BRepMesh.BRepMesh_DegreeOfFreedom

        """
        this = _BRepMesh.new_BRepMesh_Triangle(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Initialize(self, *args):
        """
        Initialize(BRepMesh_Triangle self, Standard_Integer const (&)[3] theEdges, Standard_Boolean const (&)[3] theOrientations, BRepMesh_DegreeOfFreedom const theMovability)

        Initializes the triangle by the given parameters.
        @param theEdges array of edges of triangle.
        @param theOrientations array of edge's orientations.
        @param theMovability movability of triangle.

        :type theEdges: const Standard_Integer (&)[3]
        :type theOrientations: const Standard_Boolean (&)[3]
        :type theMovability: OCC.wrapper.BRepMesh.BRepMesh_DegreeOfFreedom

        """
        return _BRepMesh.BRepMesh_Triangle_Initialize(self, *args)


    def Edges(self, *args):
        """
        Edges(BRepMesh_Triangle self, Standard_Integer (&)[3] theEdges, Standard_Boolean (&)[3] theOrientations)

        Gets edges with orientations composing the triangle.
        @param[out] theEdges array edges are stored to.
        @param[out] theOrientations array orientations are stored to.

        :type theEdges: OCC.wrapper.Standard.Standard_Integer (&)[3]
        :type theOrientations: OCC.wrapper.Standard.Standard_Boolean (&)[3]

        """
        return _BRepMesh.BRepMesh_Triangle_Edges(self, *args)


    def Movability(self, *args):
        """
        Movability(BRepMesh_Triangle self) -> BRepMesh_DegreeOfFreedom

        Returns movability of the triangle.

        :rtype: OCC.wrapper.BRepMesh.BRepMesh_DegreeOfFreedom

        """
        return _BRepMesh.BRepMesh_Triangle_Movability(self, *args)


    def SetMovability(self, *args):
        """
        SetMovability(BRepMesh_Triangle self, BRepMesh_DegreeOfFreedom const theMovability)

        Sets movability of the triangle.

        :type theMovability: OCC.wrapper.BRepMesh.BRepMesh_DegreeOfFreedom

        """
        return _BRepMesh.BRepMesh_Triangle_SetMovability(self, *args)


    def HashCode(self, *args):
        """
        HashCode(BRepMesh_Triangle self, Standard_Integer const theUpper) -> Standard_Integer

        Returns hash code for this triangle.
        @param theUpper upper index in the container.
        @return hash code.

        :type theUpper: int
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepMesh.BRepMesh_Triangle_HashCode(self, *args)


    def __hash__(self, *args):
        """
        __hash__(BRepMesh_Triangle self) -> Standard_Integer

        Returns the a hashcode based on the HashCode method, suitable for a python __hash__

        :rtype: int
        """
        return _BRepMesh.BRepMesh_Triangle___hash__(self, *args)


    def IsEqual(self, *args):
        """
        IsEqual(BRepMesh_Triangle self, BRepMesh_Triangle theOther) -> Standard_Boolean

        Checks for equality with another triangle.
        @param theOther triangle to be checked against this one.
        @return TRUE if equal, FALSE if not.

        :type theOther: OCC.wrapper.BRepMesh.BRepMesh_Triangle
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepMesh.BRepMesh_Triangle_IsEqual(self, *args)


    def __eq__(self, *args):
        """
        __eq__(BRepMesh_Triangle self, BRepMesh_Triangle theOther) -> Standard_Boolean

        Alias for IsEqual.

        :type theOther: OCC.wrapper.BRepMesh.BRepMesh_Triangle
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepMesh.BRepMesh_Triangle___eq__(self, *args)

    __swig_destroy__ = _BRepMesh.delete_BRepMesh_Triangle
BRepMesh_Triangle_swigregister = _BRepMesh.BRepMesh_Triangle_swigregister
BRepMesh_Triangle_swigregister(BRepMesh_Triangle)

class BRepMesh_PairOfPolygon(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BRepMesh_PairOfPolygon self) -> BRepMesh_PairOfPolygon

        Constructor. Creates empty pair with null fileds.


        """
        this = _BRepMesh.new_BRepMesh_PairOfPolygon(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Clear(self, *args):
        """
        Clear(BRepMesh_PairOfPolygon self)

        Clears pair handles.


        """
        return _BRepMesh.BRepMesh_PairOfPolygon_Clear(self, *args)


    def Prepend(self, *args):
        """
        Prepend(BRepMesh_PairOfPolygon self, Handle_Poly_PolygonOnTriangulation thePolygon)

        Sets the first element of the pair.
        If last element is empty, also assignes the given polygon to it.
        @param thePolygon plygon to be set.

        :type thePolygon: OCC.wrapper.Poly.Handle_Poly_PolygonOnTriangulation

        """
        return _BRepMesh.BRepMesh_PairOfPolygon_Prepend(self, *args)


    def Append(self, *args):
        """
        Append(BRepMesh_PairOfPolygon self, Handle_Poly_PolygonOnTriangulation thePolygon)

        Sets the last element of the pair.
        If first element is empty, also assignes the given polygon to it.
        @param thePolygon plygon to be set.

        :type thePolygon: OCC.wrapper.Poly.Handle_Poly_PolygonOnTriangulation

        """
        return _BRepMesh.BRepMesh_PairOfPolygon_Append(self, *args)


    def First(self, *args):
        """
        Returns first polygon on triangulation.

        :rtype: OCC.wrapper.Poly.Handle_Poly_PolygonOnTriangulation

        """
        res = _BRepMesh.BRepMesh_PairOfPolygon_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Last(self, *args):
        """
        Returns last polygon on triangulation.

        :rtype: OCC.wrapper.Poly.Handle_Poly_PolygonOnTriangulation

        """
        res = _BRepMesh.BRepMesh_PairOfPolygon_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _BRepMesh.delete_BRepMesh_PairOfPolygon
BRepMesh_PairOfPolygon_swigregister = _BRepMesh.BRepMesh_PairOfPolygon_swigregister
BRepMesh_PairOfPolygon_swigregister(BRepMesh_PairOfPolygon)

class BRepMesh_FastDiscret(Standard.Standard_Transient):
    """
    Algorithm to mesh a shape with respect of the <br>
    frontier the deflection and by option the shared <br>
    components. <br>
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_BRepMesh_FastDiscret
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_BRepMesh_FastDiscret(self) 
            return h


    def __init__(self, *args):
        """
        __init__(BRepMesh_FastDiscret self, Bnd_Box B, BRepMesh_FastDiscret::Parameters const & theParams) -> BRepMesh_FastDiscret

        Constructor. 
        Sets the meshing parameters and updates
        relative defletion according to bounding box
        @param B - bounding box encompasing shape
        @param theParams - meshing algo parameters    

        :type B: OCC.wrapper.Bnd.Bnd_Box
        :type theParams: Parameters

        """
        this = _BRepMesh.new_BRepMesh_FastDiscret(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Perform(self, *args):
        """
        Perform(BRepMesh_FastDiscret self, TopoDS_Shape shape)

        Build triangulation on the whole shape.

        :type shape: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _BRepMesh.BRepMesh_FastDiscret_Perform(self, *args)


    def Add(self, *args):
        """
        Add(BRepMesh_FastDiscret self, TopoDS_Face face) -> Standard_Integer

        Record a face for further processing.
        @return status flags collected during discretization 
        of boundaries of the given face.

        :type face: OCC.wrapper.TopoDS.TopoDS_Face
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepMesh.BRepMesh_FastDiscret_Add(self, *args)


    def Process(self, *args):
        """
        Process(BRepMesh_FastDiscret self, TopoDS_Face face)

        Triangulate a face previously recorded for 
        processing by call to Add(). Can be executed in 
        parallel threads.

        :type face: OCC.wrapper.TopoDS.TopoDS_Face

        """
        return _BRepMesh.BRepMesh_FastDiscret_Process(self, *args)


    def __call__(self, *args):
        """
        __call__(BRepMesh_FastDiscret self, TopoDS_Face face)

        :type face: OCC.wrapper.TopoDS.TopoDS_Face

        """
        return _BRepMesh.BRepMesh_FastDiscret___call__(self, *args)


    def MeshParameters(self, *args):
        """
        Returns parameters of meshing

        :rtype: Parameters

        """
        res = _BRepMesh.BRepMesh_FastDiscret_MeshParameters(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeMeshParameters(self, *args):
        """
        ChangeMeshParameters(BRepMesh_FastDiscret self) -> BRepMesh_FastDiscret::Parameters &

        Returns modificable mesh parameters

        :rtype: Parameters

        """
        return _BRepMesh.BRepMesh_FastDiscret_ChangeMeshParameters(self, *args)


    def InitSharedFaces(self, *args):
        """
        InitSharedFaces(BRepMesh_FastDiscret self, TopoDS_Shape theShape)

        :type theShape: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _BRepMesh.BRepMesh_FastDiscret_InitSharedFaces(self, *args)


    def SharedFaces(self, *args):
        """
        :rtype: OCC.wrapper.TopTools.TopTools_IndexedDataMapOfShapeListOfShape

        """
        res = _BRepMesh.BRepMesh_FastDiscret_SharedFaces(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def GetFaceAttribute(self, *args):
        """
        GetFaceAttribute(BRepMesh_FastDiscret self, TopoDS_Face theFace, Handle_BRepMesh_FaceAttribute theAttribute, Standard_Boolean const isForceCreate) -> Standard_Boolean

        Returns attribute descriptor for the given face.
        @param theFace face the attribute should be returned for.
        @param[out] theAttribute attribute found for the specified face.
        @param isForceCreate if True creates new attribute in case if there 
        is no data for the given face.

        :type theFace: OCC.wrapper.TopoDS.TopoDS_Face
        :type theAttribute: OCC.wrapper.BRepMesh.Handle_BRepMesh_FaceAttribute
        :type isForceCreate: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepMesh.BRepMesh_FastDiscret_GetFaceAttribute(self, *args)


    def RemoveFaceAttribute(self, *args):
        """
        RemoveFaceAttribute(BRepMesh_FastDiscret self, TopoDS_Face theFace)

        Remove face attribute as useless to free locate memory.

        :type theFace: OCC.wrapper.TopoDS.TopoDS_Face

        """
        return _BRepMesh.BRepMesh_FastDiscret_RemoveFaceAttribute(self, *args)


    def NbBoundaryPoints(self, *args):
        """
        NbBoundaryPoints(BRepMesh_FastDiscret self) -> Standard_Integer

        Returns number of boundary 3d points.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepMesh.BRepMesh_FastDiscret_NbBoundaryPoints(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _BRepMesh.BRepMesh_FastDiscret_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _BRepMesh.BRepMesh_FastDiscret_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _BRepMesh.BRepMesh_FastDiscret_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _BRepMesh.delete_BRepMesh_FastDiscret
BRepMesh_FastDiscret_swigregister = _BRepMesh.BRepMesh_FastDiscret_swigregister
BRepMesh_FastDiscret_swigregister(BRepMesh_FastDiscret)

def BRepMesh_FastDiscret_get_type_name(*args):
    """
    BRepMesh_FastDiscret_get_type_name() -> char const *

    :rtype: const char *

    """
    return _BRepMesh.BRepMesh_FastDiscret_get_type_name(*args)

def BRepMesh_FastDiscret_get_type_descriptor(*args):
    """
    BRepMesh_FastDiscret_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _BRepMesh.BRepMesh_FastDiscret_get_type_descriptor(*args)

class Handle_BRepMesh_FaceAttribute(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_BRepMesh_FaceAttribute self)

        Nullify the handle


        """
        return _BRepMesh.Handle_BRepMesh_FaceAttribute_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_BRepMesh_FaceAttribute self) -> bool

        Check for being null

        :rtype: bool

        """
        return _BRepMesh.Handle_BRepMesh_FaceAttribute_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_BRepMesh_FaceAttribute self, BRepMesh_FaceAttribute thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _BRepMesh.Handle_BRepMesh_FaceAttribute_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_BRepMesh_FaceAttribute self, Handle_BRepMesh_FaceAttribute theHandle) -> Handle_BRepMesh_FaceAttribute
        assign(Handle_BRepMesh_FaceAttribute self, BRepMesh_FaceAttribute thePtr) -> Handle_BRepMesh_FaceAttribute
        assign(Handle_BRepMesh_FaceAttribute self, Handle_BRepMesh_FaceAttribute theHandle) -> Handle_BRepMesh_FaceAttribute

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _BRepMesh.Handle_BRepMesh_FaceAttribute_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_BRepMesh_FaceAttribute self) -> BRepMesh_FaceAttribute

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _BRepMesh.Handle_BRepMesh_FaceAttribute_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_BRepMesh_FaceAttribute self) -> BRepMesh_FaceAttribute

        Member access operator (note non-const)

        :rtype: T *

        """
        return _BRepMesh.Handle_BRepMesh_FaceAttribute___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_BRepMesh_FaceAttribute self) -> BRepMesh_FaceAttribute

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _BRepMesh.Handle_BRepMesh_FaceAttribute___ref__(self, *args)


    def __hash__(self):
        return _BRepMesh.Handle_BRepMesh_FaceAttribute___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _BRepMesh.Handle_BRepMesh_FaceAttribute___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _BRepMesh.new_Handle_BRepMesh_FaceAttribute(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_BRepMesh.Handle_BRepMesh_FaceAttribute_DownCast)
    __swig_destroy__ = _BRepMesh.delete_Handle_BRepMesh_FaceAttribute

    def Surface(self, *args):
        """
        Returns face's surface.

        :rtype: OCC.wrapper.BRepAdaptor.Handle_BRepAdaptor_HSurface

        """
        res = _BRepMesh.Handle_BRepMesh_FaceAttribute_Surface(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def IsInitialized(self, *args):
        """
        IsInitialized(Handle_BRepMesh_FaceAttribute self) -> Standard_Boolean

        Returns True in case if this attribute has already been intialized.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepMesh.Handle_BRepMesh_FaceAttribute_IsInitialized(self, *args)


    def SetFace(self, *args):
        """
        SetFace(Handle_BRepMesh_FaceAttribute self, TopoDS_Face theFace, Standard_Boolean const theAdaptiveMin)

        Initializes this attribute by the given face.

        :type theFace: OCC.wrapper.TopoDS.TopoDS_Face
        :type theAdaptiveMin: bool

        """
        return _BRepMesh.Handle_BRepMesh_FaceAttribute_SetFace(self, *args)


    def Face(self, *args):
        """
        Returns forward oriented face to be used for calculations.

        :rtype: OCC.wrapper.TopoDS.TopoDS_Face

        """
        res = _BRepMesh.Handle_BRepMesh_FaceAttribute_Face(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetBoundaryVertices(self, *args):
        """
        SetBoundaryVertices(Handle_BRepMesh_FaceAttribute self, BRepMesh::HDMapOfVertexInteger const & theVertices)

        Sets boundary vertices map.

        :type theVertices: HDMapOfVertexInteger

        """
        return _BRepMesh.Handle_BRepMesh_FaceAttribute_SetBoundaryVertices(self, *args)


    def SetBoundaryPoints(self, *args):
        """
        SetBoundaryPoints(Handle_BRepMesh_FaceAttribute self, BRepMesh::HDMapOfIntegerPnt const & theBoundaryPoints)

        Sets boundary points map.

        :type theBoundaryPoints: HDMapOfIntegerPnt

        """
        return _BRepMesh.Handle_BRepMesh_FaceAttribute_SetBoundaryPoints(self, *args)


    def ToleranceU(self, *args):
        """
        ToleranceU(Handle_BRepMesh_FaceAttribute self) -> Standard_Real

        Returns U tolerance of face calculated regarding its parameters.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _BRepMesh.Handle_BRepMesh_FaceAttribute_ToleranceU(self, *args)


    def ToleranceV(self, *args):
        """
        ToleranceV(Handle_BRepMesh_FaceAttribute self) -> Standard_Real

        Returns V tolerance of face calculated regarding its parameters.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _BRepMesh.Handle_BRepMesh_FaceAttribute_ToleranceV(self, *args)


    def GetDefFace(self, *args):
        """
        GetDefFace(Handle_BRepMesh_FaceAttribute self) -> Standard_Real

        Gives face deflection parameter.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _BRepMesh.Handle_BRepMesh_FaceAttribute_GetDefFace(self, *args)


    def SetDefFace(self, *args):
        """
        SetDefFace(Handle_BRepMesh_FaceAttribute self, Standard_Real const theDefFace)

        Sets face deflection.

        :type theDefFace: float

        """
        return _BRepMesh.Handle_BRepMesh_FaceAttribute_SetDefFace(self, *args)


    def GetUMin(self, *args):
        """
        GetUMin(Handle_BRepMesh_FaceAttribute self) -> Standard_Real

        Gives minimal value in U domain.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _BRepMesh.Handle_BRepMesh_FaceAttribute_GetUMin(self, *args)


    def SetUMin(self, *args):
        """
        SetUMin(Handle_BRepMesh_FaceAttribute self, Standard_Real const theUMin)

        Sets minimal value in U domain.

        :type theUMin: float

        """
        return _BRepMesh.Handle_BRepMesh_FaceAttribute_SetUMin(self, *args)


    def GetVMin(self, *args):
        """
        GetVMin(Handle_BRepMesh_FaceAttribute self) -> Standard_Real

        Gives minimal value in V domain.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _BRepMesh.Handle_BRepMesh_FaceAttribute_GetVMin(self, *args)


    def SetVMin(self, *args):
        """
        SetVMin(Handle_BRepMesh_FaceAttribute self, Standard_Real const theVMin)

        Sets minimal value in V domain.

        :type theVMin: float

        """
        return _BRepMesh.Handle_BRepMesh_FaceAttribute_SetVMin(self, *args)


    def GetUMax(self, *args):
        """
        GetUMax(Handle_BRepMesh_FaceAttribute self) -> Standard_Real

        Gives maximal value in U domain.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _BRepMesh.Handle_BRepMesh_FaceAttribute_GetUMax(self, *args)


    def SetUMax(self, *args):
        """
        SetUMax(Handle_BRepMesh_FaceAttribute self, Standard_Real const theUMax)

        Sets maximal value in U domain.

        :type theUMax: float

        """
        return _BRepMesh.Handle_BRepMesh_FaceAttribute_SetUMax(self, *args)


    def GetVMax(self, *args):
        """
        GetVMax(Handle_BRepMesh_FaceAttribute self) -> Standard_Real

        Gives maximal value in V domain.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _BRepMesh.Handle_BRepMesh_FaceAttribute_GetVMax(self, *args)


    def SetVMax(self, *args):
        """
        SetVMax(Handle_BRepMesh_FaceAttribute self, Standard_Real const theVMax)

        Sets maximal value in V domain.

        :type theVMax: float

        """
        return _BRepMesh.Handle_BRepMesh_FaceAttribute_SetVMax(self, *args)


    def GetDeltaX(self, *args):
        """
        GetDeltaX(Handle_BRepMesh_FaceAttribute self) -> Standard_Real

        Gives value of step in U domain.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _BRepMesh.Handle_BRepMesh_FaceAttribute_GetDeltaX(self, *args)


    def SetDeltaX(self, *args):
        """
        SetDeltaX(Handle_BRepMesh_FaceAttribute self, Standard_Real const theDeltaX)

        Sets value of step in U domain.

        :type theDeltaX: float

        """
        return _BRepMesh.Handle_BRepMesh_FaceAttribute_SetDeltaX(self, *args)


    def GetDeltaY(self, *args):
        """
        GetDeltaY(Handle_BRepMesh_FaceAttribute self) -> Standard_Real

        Gives value of step in V domain.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _BRepMesh.Handle_BRepMesh_FaceAttribute_GetDeltaY(self, *args)


    def SetDeltaY(self, *args):
        """
        SetDeltaY(Handle_BRepMesh_FaceAttribute self, Standard_Real const theDeltaY)

        Sets value of step in V domain.

        :type theDeltaY: float

        """
        return _BRepMesh.Handle_BRepMesh_FaceAttribute_SetDeltaY(self, *args)


    def GetStatus(self, *args):
        """
        GetStatus(Handle_BRepMesh_FaceAttribute self) -> Standard_Integer

        Sets set of status flags for this face.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepMesh.Handle_BRepMesh_FaceAttribute_GetStatus(self, *args)


    def SetStatus(self, *args):
        """
        SetStatus(Handle_BRepMesh_FaceAttribute self, BRepMesh_Status const theStatus)

        Sets status flag for this face.

        :type theStatus: OCC.wrapper.BRepMesh.BRepMesh_Status

        """
        return _BRepMesh.Handle_BRepMesh_FaceAttribute_SetStatus(self, *args)


    def IsValid(self, *args):
        """
        IsValid(Handle_BRepMesh_FaceAttribute self) -> Standard_Boolean

        Returns TRUE in case if computed data is valid.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepMesh.Handle_BRepMesh_FaceAttribute_IsValid(self, *args)


    def Clear(self, *args):
        """
        Clear(Handle_BRepMesh_FaceAttribute self)

        Clear face attribute.


        """
        return _BRepMesh.Handle_BRepMesh_FaceAttribute_Clear(self, *args)


    def ChangeInternalEdges(self, *args):
        """
        ChangeInternalEdges(Handle_BRepMesh_FaceAttribute self) -> BRepMesh::HDMapOfShapePairOfPolygon &

        Gives reference to map of internal edges of face.

        :rtype: HDMapOfShapePairOfPolygon

        """
        return _BRepMesh.Handle_BRepMesh_FaceAttribute_ChangeInternalEdges(self, *args)


    def ChangeLocation2D(self, *args):
        """
        ChangeLocation2D(Handle_BRepMesh_FaceAttribute self) -> BRepMesh::HDMapOfIntegerListOfXY &

        Gives reference to map of 2D points of discretization.

        :rtype: HDMapOfIntegerListOfXY

        """
        return _BRepMesh.Handle_BRepMesh_FaceAttribute_ChangeLocation2D(self, *args)


    def ChangeSurfacePoints(self, *args):
        """
        ChangeSurfacePoints(Handle_BRepMesh_FaceAttribute self) -> BRepMesh::HDMapOfIntegerPnt &

        Gives reference to map of 3D points of discretization.

        :rtype: HDMapOfIntegerPnt

        """
        return _BRepMesh.Handle_BRepMesh_FaceAttribute_ChangeSurfacePoints(self, *args)


    def ChangeSurfaceVertices(self, *args):
        """
        ChangeSurfaceVertices(Handle_BRepMesh_FaceAttribute self) -> BRepMesh::HDMapOfVertexInteger &

        Gives reference to map of vertices of discretization.

        :rtype: HDMapOfVertexInteger

        """
        return _BRepMesh.Handle_BRepMesh_FaceAttribute_ChangeSurfaceVertices(self, *args)


    def ChangeVertexEdgeMap(self, *args):
        """
        ChangeVertexEdgeMap(Handle_BRepMesh_FaceAttribute self) -> BRepMesh::HIMapOfInteger &

        Gives reference on map of (vertex, edge) pairs of face.

        :rtype: HIMapOfInteger

        """
        return _BRepMesh.Handle_BRepMesh_FaceAttribute_ChangeVertexEdgeMap(self, *args)


    def ChangeStructure(self, *args):
        """
        ChangeStructure(Handle_BRepMesh_FaceAttribute self) -> Handle_BRepMesh_DataStructureOfDelaun

        Gives Delaunay data structure.

        :rtype: OCC.wrapper.BRepMesh.Handle_BRepMesh_DataStructureOfDelaun

        """
        return _BRepMesh.Handle_BRepMesh_FaceAttribute_ChangeStructure(self, *args)


    def ChangeClassifier(self, *args):
        """
        ChangeClassifier(Handle_BRepMesh_FaceAttribute self) -> BRepMesh::HClassifier &

        Returns classifier.

        :rtype: HClassifier

        """
        return _BRepMesh.Handle_BRepMesh_FaceAttribute_ChangeClassifier(self, *args)


    def ChangeMeshNodes(self, *args):
        """
        ChangeMeshNodes(Handle_BRepMesh_FaceAttribute self) -> BRepMesh::HVectorOfVertex &

        Returns mesh nodes calculated for boundaries.

        :rtype: HVectorOfVertex

        """
        return _BRepMesh.Handle_BRepMesh_FaceAttribute_ChangeMeshNodes(self, *args)


    def LastPointId(self, *args):
        """
        LastPointId(Handle_BRepMesh_FaceAttribute self) -> Standard_Integer

        Gives the number of different locations in 3D space.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepMesh.Handle_BRepMesh_FaceAttribute_LastPointId(self, *args)


    def GetPoint(self, *args):
        """
        Gives the 3D location of the vertex.

        :type theIndex: int
        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        res = _BRepMesh.Handle_BRepMesh_FaceAttribute_GetPoint(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def AddNode(self, *args):
        """
        AddNode(Handle_BRepMesh_FaceAttribute self, Standard_Integer const theIndex, gp_XY theUV, BRepMesh_DegreeOfFreedom const theMovability)

        Adds node with the given parameters to mesh.
        @param theIndex index of 3D point corresponded to the node.
        @param theUV node position.
        @param theMovability movability of a node.
        @param theNodeIndex index of vertex in mesh structure.
        @param theNodeOnEdgeIndex ordered index of node on the boundary.

        :type theIndex: int
        :type theUV: OCC.wrapper.gp.gp_XY
        :type theMovability: OCC.wrapper.BRepMesh.BRepMesh_DegreeOfFreedom
        :type theNodeIndex: int
        :type theNodeOnEdgeIndex: int

        """
        return _BRepMesh.Handle_BRepMesh_FaceAttribute_AddNode(self, *args)


    def Scale(self, *args):
        """
        Scale(Handle_BRepMesh_FaceAttribute self, gp_XY thePoint2d, Standard_Boolean const isToFaceBasis) -> gp_XY

        Scales the given point from real parametric space 
        to face basis and otherwise.
        @param thePoint2d point to be scaled.
        @param isToFaceBasis if TRUE converts point to face basis,
        otherwise performs reverse conversion.
        @return scaled point.

        :type thePoint2d: OCC.wrapper.gp.gp_XY
        :type isToFaceBasis: bool
        :rtype: OCC.wrapper.gp.gp_XY

        """
        return _BRepMesh.Handle_BRepMesh_FaceAttribute_Scale(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_BRepMesh_FaceAttribute self) -> char const *

        :rtype: const char *

        """
        return _BRepMesh.Handle_BRepMesh_FaceAttribute_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _BRepMesh.Handle_BRepMesh_FaceAttribute_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _BRepMesh.Handle_BRepMesh_FaceAttribute_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_BRepMesh_FaceAttribute self)

        Memory deallocator for transient classes


        """
        return _BRepMesh.Handle_BRepMesh_FaceAttribute_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_BRepMesh_FaceAttribute self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_BRepMesh_FaceAttribute self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepMesh.Handle_BRepMesh_FaceAttribute_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_BRepMesh_FaceAttribute self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_BRepMesh_FaceAttribute self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepMesh.Handle_BRepMesh_FaceAttribute_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_BRepMesh_FaceAttribute self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _BRepMesh.Handle_BRepMesh_FaceAttribute_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_BRepMesh_FaceAttribute self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepMesh.Handle_BRepMesh_FaceAttribute_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_BRepMesh_FaceAttribute self)

        Increments the reference counter of this object


        """
        return _BRepMesh.Handle_BRepMesh_FaceAttribute_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_BRepMesh_FaceAttribute self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepMesh.Handle_BRepMesh_FaceAttribute_DecrementRefCounter(self, *args)

Handle_BRepMesh_FaceAttribute_swigregister = _BRepMesh.Handle_BRepMesh_FaceAttribute_swigregister
Handle_BRepMesh_FaceAttribute_swigregister(Handle_BRepMesh_FaceAttribute)

def Handle_BRepMesh_FaceAttribute_DownCast(thing):
    return _BRepMesh.Handle_BRepMesh_FaceAttribute_DownCast(thing)
Handle_BRepMesh_FaceAttribute_DownCast = _BRepMesh.Handle_BRepMesh_FaceAttribute_DownCast

class Handle_BRepMesh_IncrementalMesh(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_BRepMesh_IncrementalMesh self)

        Nullify the handle


        """
        return _BRepMesh.Handle_BRepMesh_IncrementalMesh_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_BRepMesh_IncrementalMesh self) -> bool

        Check for being null

        :rtype: bool

        """
        return _BRepMesh.Handle_BRepMesh_IncrementalMesh_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_BRepMesh_IncrementalMesh self, BRepMesh_IncrementalMesh thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _BRepMesh.Handle_BRepMesh_IncrementalMesh_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_BRepMesh_IncrementalMesh self, Handle_BRepMesh_IncrementalMesh theHandle) -> Handle_BRepMesh_IncrementalMesh
        assign(Handle_BRepMesh_IncrementalMesh self, BRepMesh_IncrementalMesh thePtr) -> Handle_BRepMesh_IncrementalMesh
        assign(Handle_BRepMesh_IncrementalMesh self, Handle_BRepMesh_IncrementalMesh theHandle) -> Handle_BRepMesh_IncrementalMesh

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _BRepMesh.Handle_BRepMesh_IncrementalMesh_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_BRepMesh_IncrementalMesh self) -> BRepMesh_IncrementalMesh

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _BRepMesh.Handle_BRepMesh_IncrementalMesh_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_BRepMesh_IncrementalMesh self) -> BRepMesh_IncrementalMesh

        Member access operator (note non-const)

        :rtype: T *

        """
        return _BRepMesh.Handle_BRepMesh_IncrementalMesh___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_BRepMesh_IncrementalMesh self) -> BRepMesh_IncrementalMesh

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _BRepMesh.Handle_BRepMesh_IncrementalMesh___ref__(self, *args)


    def __hash__(self):
        return _BRepMesh.Handle_BRepMesh_IncrementalMesh___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _BRepMesh.Handle_BRepMesh_IncrementalMesh___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _BRepMesh.new_Handle_BRepMesh_IncrementalMesh(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_BRepMesh.Handle_BRepMesh_IncrementalMesh_DownCast)
    __swig_destroy__ = _BRepMesh.delete_Handle_BRepMesh_IncrementalMesh

    def Perform(self, *args):
        """
        Perform(Handle_BRepMesh_IncrementalMesh self)

        Performs meshing ot the shape.


        """
        return _BRepMesh.Handle_BRepMesh_IncrementalMesh_Perform(self, *args)


    def Parameters(self, *args):
        """
        Returns meshing parameters

        :rtype: Parameters

        """
        res = _BRepMesh.Handle_BRepMesh_IncrementalMesh_Parameters(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeParameters(self, *args):
        """
        ChangeParameters(Handle_BRepMesh_IncrementalMesh self) -> BRepMesh_FastDiscret::Parameters &

        Returns modifiable meshing parameters

        :rtype: Parameters

        """
        return _BRepMesh.Handle_BRepMesh_IncrementalMesh_ChangeParameters(self, *args)


    def IsModified(self, *args):
        """
        IsModified(Handle_BRepMesh_IncrementalMesh self) -> Standard_Boolean

        Returns modified flag.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepMesh.Handle_BRepMesh_IncrementalMesh_IsModified(self, *args)


    def GetStatusFlags(self, *args):
        """
        GetStatusFlags(Handle_BRepMesh_IncrementalMesh self) -> Standard_Integer

        Returns accumulated status flags faced during meshing.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepMesh.Handle_BRepMesh_IncrementalMesh_GetStatusFlags(self, *args)


    def Discret(self, *args):
        """
        Discret(Handle_BRepMesh_IncrementalMesh self, TopoDS_Shape theShape, Standard_Real const theLinDeflection, Standard_Real const theAngDeflection, BRepMesh_DiscretRoot *& theAlgo) -> Standard_Integer

        Plugin interface for the Mesh Factories.
        Initializes meshing algorithm with the given parameters.
        @param theShape shape to be meshed.
        @param theLinDeflection linear deflection.
        @param theAngDeflection angular deflection.
        @param[out] theAlgo pointer to initialized algorithm.

        :type theShape: OCC.wrapper.TopoDS.TopoDS_Shape
        :type theLinDeflection: float
        :type theAngDeflection: float
        :type theAlgo: OCC.wrapper.BRepMesh.BRepMesh_DiscretRoot
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepMesh.Handle_BRepMesh_IncrementalMesh_Discret(self, *args)


    def IsParallelDefault(self, *args):
        """
        IsParallelDefault(Handle_BRepMesh_IncrementalMesh self) -> Standard_Boolean

        Returns multi-threading usage flag set by default in 
        Discret() static method (thus applied only to Mesh Factories).

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepMesh.Handle_BRepMesh_IncrementalMesh_IsParallelDefault(self, *args)


    def SetParallelDefault(self, *args):
        """
        SetParallelDefault(Handle_BRepMesh_IncrementalMesh self, Standard_Boolean const isInParallel)

        Setup multi-threading usage flag set by default in 
        Discret() static method (thus applied only to Mesh Factories).

        :type isInParallel: bool

        """
        return _BRepMesh.Handle_BRepMesh_IncrementalMesh_SetParallelDefault(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_BRepMesh_IncrementalMesh self) -> char const *

        :rtype: const char *

        """
        return _BRepMesh.Handle_BRepMesh_IncrementalMesh_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _BRepMesh.Handle_BRepMesh_IncrementalMesh_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _BRepMesh.Handle_BRepMesh_IncrementalMesh_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetShape(self, *args):
        """
        SetShape(Handle_BRepMesh_IncrementalMesh self, TopoDS_Shape theShape)

        Set the shape to triangulate.

        :type theShape: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _BRepMesh.Handle_BRepMesh_IncrementalMesh_SetShape(self, *args)


    def Shape(self, *args):
        """
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _BRepMesh.Handle_BRepMesh_IncrementalMesh_Shape(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def IsDone(self, *args):
        """
        IsDone(Handle_BRepMesh_IncrementalMesh self) -> Standard_Boolean

        Returns true if triangualtion was performed and has success.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepMesh.Handle_BRepMesh_IncrementalMesh_IsDone(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_BRepMesh_IncrementalMesh self)

        Memory deallocator for transient classes


        """
        return _BRepMesh.Handle_BRepMesh_IncrementalMesh_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_BRepMesh_IncrementalMesh self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_BRepMesh_IncrementalMesh self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepMesh.Handle_BRepMesh_IncrementalMesh_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_BRepMesh_IncrementalMesh self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_BRepMesh_IncrementalMesh self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepMesh.Handle_BRepMesh_IncrementalMesh_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_BRepMesh_IncrementalMesh self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _BRepMesh.Handle_BRepMesh_IncrementalMesh_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_BRepMesh_IncrementalMesh self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepMesh.Handle_BRepMesh_IncrementalMesh_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_BRepMesh_IncrementalMesh self)

        Increments the reference counter of this object


        """
        return _BRepMesh.Handle_BRepMesh_IncrementalMesh_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_BRepMesh_IncrementalMesh self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepMesh.Handle_BRepMesh_IncrementalMesh_DecrementRefCounter(self, *args)

Handle_BRepMesh_IncrementalMesh_swigregister = _BRepMesh.Handle_BRepMesh_IncrementalMesh_swigregister
Handle_BRepMesh_IncrementalMesh_swigregister(Handle_BRepMesh_IncrementalMesh)

def Handle_BRepMesh_IncrementalMesh_DownCast(thing):
    return _BRepMesh.Handle_BRepMesh_IncrementalMesh_DownCast(thing)
Handle_BRepMesh_IncrementalMesh_DownCast = _BRepMesh.Handle_BRepMesh_IncrementalMesh_DownCast

class BRepMesh_FastDiscretFace(Standard.Standard_Transient):
    """
    Algorithm to mesh a face with respect of the frontier 
    the deflection and by option the shared components.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_BRepMesh_FastDiscretFace
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_BRepMesh_FastDiscretFace(self) 
            return h


    def __init__(self, *args):
        """
        __init__(BRepMesh_FastDiscretFace self, Standard_Real const theAngle, Standard_Real const theMinSize, Standard_Boolean const isInternalVerticesMode, Standard_Boolean const isControlSurfaceDeflection) -> BRepMesh_FastDiscretFace

        Constructor.
        @param theAngle deviation angle to be used for surface tessellation.
        @param isInternalVerticesMode flag enabling/disabling internal 
        vertices mode.
        @param isControlSurfaceDeflection enables/disables adaptive 
        reconfiguration of mesh.

        :type theAngle: float
        :type theMinSize: float
        :type isInternalVerticesMode: bool
        :type isControlSurfaceDeflection: bool

        """
        this = _BRepMesh.new_BRepMesh_FastDiscretFace(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Perform(self, *args):
        """
        Perform(BRepMesh_FastDiscretFace self, Handle_BRepMesh_FaceAttribute theAttribute)

        :type theAttribute: OCC.wrapper.BRepMesh.Handle_BRepMesh_FaceAttribute

        """
        return _BRepMesh.BRepMesh_FastDiscretFace_Perform(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _BRepMesh.BRepMesh_FastDiscretFace_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _BRepMesh.BRepMesh_FastDiscretFace_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _BRepMesh.BRepMesh_FastDiscretFace_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _BRepMesh.delete_BRepMesh_FastDiscretFace
BRepMesh_FastDiscretFace_swigregister = _BRepMesh.BRepMesh_FastDiscretFace_swigregister
BRepMesh_FastDiscretFace_swigregister(BRepMesh_FastDiscretFace)

def BRepMesh_FastDiscretFace_get_type_name(*args):
    """
    BRepMesh_FastDiscretFace_get_type_name() -> char const *

    :rtype: const char *

    """
    return _BRepMesh.BRepMesh_FastDiscretFace_get_type_name(*args)

def BRepMesh_FastDiscretFace_get_type_descriptor(*args):
    """
    BRepMesh_FastDiscretFace_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _BRepMesh.BRepMesh_FastDiscretFace_get_type_descriptor(*args)

class Handle_BRepMesh_IEdgeTool(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_BRepMesh_IEdgeTool self)

        Nullify the handle


        """
        return _BRepMesh.Handle_BRepMesh_IEdgeTool_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_BRepMesh_IEdgeTool self) -> bool

        Check for being null

        :rtype: bool

        """
        return _BRepMesh.Handle_BRepMesh_IEdgeTool_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_BRepMesh_IEdgeTool self, BRepMesh_IEdgeTool thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _BRepMesh.Handle_BRepMesh_IEdgeTool_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_BRepMesh_IEdgeTool self, Handle_BRepMesh_IEdgeTool theHandle) -> Handle_BRepMesh_IEdgeTool
        assign(Handle_BRepMesh_IEdgeTool self, BRepMesh_IEdgeTool thePtr) -> Handle_BRepMesh_IEdgeTool
        assign(Handle_BRepMesh_IEdgeTool self, Handle_BRepMesh_IEdgeTool theHandle) -> Handle_BRepMesh_IEdgeTool

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _BRepMesh.Handle_BRepMesh_IEdgeTool_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_BRepMesh_IEdgeTool self) -> BRepMesh_IEdgeTool

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _BRepMesh.Handle_BRepMesh_IEdgeTool_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_BRepMesh_IEdgeTool self) -> BRepMesh_IEdgeTool

        Member access operator (note non-const)

        :rtype: T *

        """
        return _BRepMesh.Handle_BRepMesh_IEdgeTool___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_BRepMesh_IEdgeTool self) -> BRepMesh_IEdgeTool

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _BRepMesh.Handle_BRepMesh_IEdgeTool___ref__(self, *args)


    def __hash__(self):
        return _BRepMesh.Handle_BRepMesh_IEdgeTool___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _BRepMesh.Handle_BRepMesh_IEdgeTool___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _BRepMesh.new_Handle_BRepMesh_IEdgeTool(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_BRepMesh.Handle_BRepMesh_IEdgeTool_DownCast)
    __swig_destroy__ = _BRepMesh.delete_Handle_BRepMesh_IEdgeTool

    def NbPoints(self, *args):
        """
        NbPoints(Handle_BRepMesh_IEdgeTool self) -> Standard_Integer

        Returns number of tessellation points.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepMesh.Handle_BRepMesh_IEdgeTool_NbPoints(self, *args)


    def Value(self, *args):
        """
        Value(Handle_BRepMesh_IEdgeTool self, Standard_Integer const theIndex, gp_Pnt thePoint, gp_Pnt2d theUV) -> Standard_Boolean

        Returns parameters of solution with the given index.
        @param theIndex index of tessellation point.
        @param theParameter parameters on PCurve corresponded to the solution.
        @param thePoint tessellation point.
        @param theUV coordinates of tessellation point in parametric space of face.
        @return True in case of valid result, false elewhere.

        :type theIndex: int
        :type theParameter: float
        :type thePoint: OCC.wrapper.gp.gp_Pnt
        :type theUV: OCC.wrapper.gp.gp_Pnt2d
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepMesh.Handle_BRepMesh_IEdgeTool_Value(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_BRepMesh_IEdgeTool self) -> char const *

        :rtype: const char *

        """
        return _BRepMesh.Handle_BRepMesh_IEdgeTool_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _BRepMesh.Handle_BRepMesh_IEdgeTool_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _BRepMesh.Handle_BRepMesh_IEdgeTool_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_BRepMesh_IEdgeTool self)

        Memory deallocator for transient classes


        """
        return _BRepMesh.Handle_BRepMesh_IEdgeTool_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_BRepMesh_IEdgeTool self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_BRepMesh_IEdgeTool self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepMesh.Handle_BRepMesh_IEdgeTool_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_BRepMesh_IEdgeTool self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_BRepMesh_IEdgeTool self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepMesh.Handle_BRepMesh_IEdgeTool_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_BRepMesh_IEdgeTool self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _BRepMesh.Handle_BRepMesh_IEdgeTool_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_BRepMesh_IEdgeTool self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepMesh.Handle_BRepMesh_IEdgeTool_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_BRepMesh_IEdgeTool self)

        Increments the reference counter of this object


        """
        return _BRepMesh.Handle_BRepMesh_IEdgeTool_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_BRepMesh_IEdgeTool self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepMesh.Handle_BRepMesh_IEdgeTool_DecrementRefCounter(self, *args)

Handle_BRepMesh_IEdgeTool_swigregister = _BRepMesh.Handle_BRepMesh_IEdgeTool_swigregister
Handle_BRepMesh_IEdgeTool_swigregister(Handle_BRepMesh_IEdgeTool)

def Handle_BRepMesh_IEdgeTool_DownCast(thing):
    return _BRepMesh.Handle_BRepMesh_IEdgeTool_DownCast(thing)
Handle_BRepMesh_IEdgeTool_DownCast = _BRepMesh.Handle_BRepMesh_IEdgeTool_DownCast

class BRepMesh_DiscretFactory(object):
    """
    This class intended to setup / retrieve default triangulation algorithm. <br>
    Use BRepMesh_DiscretFactory::Get() static method to retrieve global Factory instance. <br>
    Use BRepMesh_DiscretFactory::Discret() method to retrieve meshing tool. <br>
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def Get(*args):
        """
        Get() -> BRepMesh_DiscretFactory

        Returns the global factory instance.

        :rtype: OCC.wrapper.BRepMesh.BRepMesh_DiscretFactory

        """
        return _BRepMesh.BRepMesh_DiscretFactory_Get(*args)

    Get = staticmethod(Get)

    def Names(self, *args):
        """
        Returns the list of registered meshing algorithms.

        :rtype: OCC.wrapper.TColStd.TColStd_MapOfAsciiString

        """
        res = _BRepMesh.BRepMesh_DiscretFactory_Names(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetDefaultName(self, *args):
        """
        SetDefaultName(BRepMesh_DiscretFactory self, TCollection_AsciiString theName) -> Standard_Boolean

        Setup meshing algorithm by name. <br>
        Returns TRUE if requested tool is available. <br>
        On fail Factory will continue to use previous algo.

        :type theName: OCC.wrapper.TCollection.TCollection_AsciiString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepMesh.BRepMesh_DiscretFactory_SetDefaultName(self, *args)


    def DefaultName(self, *args):
        """
        Returns name for current meshing algorithm.

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        res = _BRepMesh.BRepMesh_DiscretFactory_DefaultName(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetFunctionName(self, *args):
        """
        SetFunctionName(BRepMesh_DiscretFactory self, TCollection_AsciiString theFuncName) -> Standard_Boolean

        Advanced function. Changes function name to retrieve from plugin. <br>
        Returns TRUE if requested tool is available. <br>
        On fail Factory will continue to use previous algo.

        :type theFuncName: OCC.wrapper.TCollection.TCollection_AsciiString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepMesh.BRepMesh_DiscretFactory_SetFunctionName(self, *args)


    def FunctionName(self, *args):
        """
        Returns function name that should be exported by plugin.

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        res = _BRepMesh.BRepMesh_DiscretFactory_FunctionName(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ErrorStatus(self, *args):
        """
        ErrorStatus(BRepMesh_DiscretFactory self) -> BRepMesh_FactoryError

        Returns error status for last meshing algorithm switch.

        :rtype: OCC.wrapper.BRepMesh.BRepMesh_FactoryError

        """
        return _BRepMesh.BRepMesh_DiscretFactory_ErrorStatus(self, *args)


    def SetDefault(self, *args):
        """
        SetDefault(BRepMesh_DiscretFactory self, TCollection_AsciiString theName, TCollection_AsciiString theFuncName) -> Standard_Boolean

        Setup meshing algorithm that should be created by this Factory. <br>
        Returns TRUE if requested tool is available. <br>
        On fail Factory will continue to use previous algo. <br>
        Call ::ErrorStatus() method to retrieve fault reason.

        :type theName: OCC.wrapper.TCollection.TCollection_AsciiString
        :type theFuncName: OCC.wrapper.TCollection.TCollection_AsciiString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepMesh.BRepMesh_DiscretFactory_SetDefault(self, *args)


    def Discret(self, *args):
        """
        Discret(BRepMesh_DiscretFactory self, TopoDS_Shape theShape, Standard_Real const theLinDeflection, Standard_Real const theAngDeflection) -> Handle_BRepMesh_DiscretRoot

        Returns triangulation algorithm instance.
        @param theShape shape to be meshed.
        @param theLinDeflection linear deflection to be used for meshing.
        @param theAngDeflection angular deflection to be used for meshing.

        :type theShape: OCC.wrapper.TopoDS.TopoDS_Shape
        :type theLinDeflection: float
        :type theAngDeflection: float
        :rtype: OCC.wrapper.BRepMesh.Handle_BRepMesh_DiscretRoot

        """
        return _BRepMesh.BRepMesh_DiscretFactory_Discret(self, *args)

BRepMesh_DiscretFactory_swigregister = _BRepMesh.BRepMesh_DiscretFactory_swigregister
BRepMesh_DiscretFactory_swigregister(BRepMesh_DiscretFactory)

def BRepMesh_DiscretFactory_Get(*args):
    """
    BRepMesh_DiscretFactory_Get() -> BRepMesh_DiscretFactory

    Returns the global factory instance.

    :rtype: OCC.wrapper.BRepMesh.BRepMesh_DiscretFactory

    """
    return _BRepMesh.BRepMesh_DiscretFactory_Get(*args)

class Handle_BRepMesh_FastDiscretFace(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_BRepMesh_FastDiscretFace self)

        Nullify the handle


        """
        return _BRepMesh.Handle_BRepMesh_FastDiscretFace_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_BRepMesh_FastDiscretFace self) -> bool

        Check for being null

        :rtype: bool

        """
        return _BRepMesh.Handle_BRepMesh_FastDiscretFace_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_BRepMesh_FastDiscretFace self, BRepMesh_FastDiscretFace thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _BRepMesh.Handle_BRepMesh_FastDiscretFace_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_BRepMesh_FastDiscretFace self, Handle_BRepMesh_FastDiscretFace theHandle) -> Handle_BRepMesh_FastDiscretFace
        assign(Handle_BRepMesh_FastDiscretFace self, BRepMesh_FastDiscretFace thePtr) -> Handle_BRepMesh_FastDiscretFace
        assign(Handle_BRepMesh_FastDiscretFace self, Handle_BRepMesh_FastDiscretFace theHandle) -> Handle_BRepMesh_FastDiscretFace

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _BRepMesh.Handle_BRepMesh_FastDiscretFace_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_BRepMesh_FastDiscretFace self) -> BRepMesh_FastDiscretFace

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _BRepMesh.Handle_BRepMesh_FastDiscretFace_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_BRepMesh_FastDiscretFace self) -> BRepMesh_FastDiscretFace

        Member access operator (note non-const)

        :rtype: T *

        """
        return _BRepMesh.Handle_BRepMesh_FastDiscretFace___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_BRepMesh_FastDiscretFace self) -> BRepMesh_FastDiscretFace

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _BRepMesh.Handle_BRepMesh_FastDiscretFace___ref__(self, *args)


    def __hash__(self):
        return _BRepMesh.Handle_BRepMesh_FastDiscretFace___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _BRepMesh.Handle_BRepMesh_FastDiscretFace___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _BRepMesh.new_Handle_BRepMesh_FastDiscretFace(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_BRepMesh.Handle_BRepMesh_FastDiscretFace_DownCast)
    __swig_destroy__ = _BRepMesh.delete_Handle_BRepMesh_FastDiscretFace

    def Perform(self, *args):
        """
        Perform(Handle_BRepMesh_FastDiscretFace self, Handle_BRepMesh_FaceAttribute theAttribute)

        :type theAttribute: OCC.wrapper.BRepMesh.Handle_BRepMesh_FaceAttribute

        """
        return _BRepMesh.Handle_BRepMesh_FastDiscretFace_Perform(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_BRepMesh_FastDiscretFace self) -> char const *

        :rtype: const char *

        """
        return _BRepMesh.Handle_BRepMesh_FastDiscretFace_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _BRepMesh.Handle_BRepMesh_FastDiscretFace_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _BRepMesh.Handle_BRepMesh_FastDiscretFace_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_BRepMesh_FastDiscretFace self)

        Memory deallocator for transient classes


        """
        return _BRepMesh.Handle_BRepMesh_FastDiscretFace_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_BRepMesh_FastDiscretFace self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_BRepMesh_FastDiscretFace self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepMesh.Handle_BRepMesh_FastDiscretFace_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_BRepMesh_FastDiscretFace self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_BRepMesh_FastDiscretFace self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepMesh.Handle_BRepMesh_FastDiscretFace_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_BRepMesh_FastDiscretFace self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _BRepMesh.Handle_BRepMesh_FastDiscretFace_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_BRepMesh_FastDiscretFace self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepMesh.Handle_BRepMesh_FastDiscretFace_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_BRepMesh_FastDiscretFace self)

        Increments the reference counter of this object


        """
        return _BRepMesh.Handle_BRepMesh_FastDiscretFace_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_BRepMesh_FastDiscretFace self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepMesh.Handle_BRepMesh_FastDiscretFace_DecrementRefCounter(self, *args)

Handle_BRepMesh_FastDiscretFace_swigregister = _BRepMesh.Handle_BRepMesh_FastDiscretFace_swigregister
Handle_BRepMesh_FastDiscretFace_swigregister(Handle_BRepMesh_FastDiscretFace)

def Handle_BRepMesh_FastDiscretFace_DownCast(thing):
    return _BRepMesh.Handle_BRepMesh_FastDiscretFace_DownCast(thing)
Handle_BRepMesh_FastDiscretFace_DownCast = _BRepMesh.Handle_BRepMesh_FastDiscretFace_DownCast

class BRepMesh_CircleTool(object):
    """Create sort and destroy the circles used in triangulation. <br>"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BRepMesh_CircleTool self, Handle_NCollection_IncAllocator theAllocator) -> BRepMesh_CircleTool
        __init__(BRepMesh_CircleTool self, Standard_Integer const theReservedSize, Handle_NCollection_IncAllocator theAllocator) -> BRepMesh_CircleTool

        Constructor.
        @param theReservedSize size to be reserved for vector of circles.
        @param theAllocator memory allocator to be used by internal structures.

        :type theReservedSize: int
        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_IncAllocator

        """
        this = _BRepMesh.new_BRepMesh_CircleTool(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(BRepMesh_CircleTool self, Standard_Integer const arg2)

        Initializes the tool.
        @param theReservedSize size to be reserved for vector of circles.

        :type : int

        """
        return _BRepMesh.BRepMesh_CircleTool_Init(self, *args)


    def SetCellSize(self, *args):
        """
        SetCellSize(BRepMesh_CircleTool self, Standard_Real const theSize)
        SetCellSize(BRepMesh_CircleTool self, Standard_Real const theSizeX, Standard_Real const theSizeY)

        Sets new size for cell filter.
        @param theSizeX cell size to be set for X dimension.
        @param theSizeY cell size to be set for Y dimension.

        :type theSizeX: float
        :type theSizeY: float

        """
        return _BRepMesh.BRepMesh_CircleTool_SetCellSize(self, *args)


    def SetMinMaxSize(self, *args):
        """
        SetMinMaxSize(BRepMesh_CircleTool self, gp_XY theMin, gp_XY theMax)

        Sets limits of inspection area.
        @param theMin bottom left corner of inspection area.
        @param theMax top right corner of inspection area.

        :type theMin: OCC.wrapper.gp.gp_XY
        :type theMax: OCC.wrapper.gp.gp_XY

        """
        return _BRepMesh.BRepMesh_CircleTool_SetMinMaxSize(self, *args)


    def MakeCircle(*args):
        """
        MakeCircle(gp_XY thePoint1, gp_XY thePoint2, gp_XY thePoint3, gp_XY theLocation) -> Standard_Boolean

        Computes circle on three points.
        @param thePoint1 first point.
        @param thePoint2 second point.
        @param thePoint3 third point.
        @param[out] theLocation center of computed circle.
        @param[out] theRadius radius of computed circle.
        @return FALSE in case of impossibility to build a circle 
        on the given points, TRUE elsewhere.

        :type thePoint1: OCC.wrapper.gp.gp_XY
        :type thePoint2: OCC.wrapper.gp.gp_XY
        :type thePoint3: OCC.wrapper.gp.gp_XY
        :type theLocation: OCC.wrapper.gp.gp_XY
        :type theRadius: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepMesh.BRepMesh_CircleTool_MakeCircle(*args)

    MakeCircle = staticmethod(MakeCircle)

    def Bind(self, *args):
        """
        Bind(BRepMesh_CircleTool self, Standard_Integer const theIndex, gp_Circ2d theCircle)
        Bind(BRepMesh_CircleTool self, Standard_Integer const theIndex, gp_XY thePoint1, gp_XY thePoint2, gp_XY thePoint3) -> Standard_Boolean

        Computes circle on three points and bind it to the tool.
        @param theIndex index a circle should be bound with.
        @param thePoint1 first point.
        @param thePoint2 second point.
        @param thePoint3 third point.
        @return FALSE in case of impossibility to build a circle 
        on the given points, TRUE elsewhere.

        :type theIndex: int
        :type thePoint1: OCC.wrapper.gp.gp_XY
        :type thePoint2: OCC.wrapper.gp.gp_XY
        :type thePoint3: OCC.wrapper.gp.gp_XY
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepMesh.BRepMesh_CircleTool_Bind(self, *args)


    def MocBind(self, *args):
        """
        MocBind(BRepMesh_CircleTool self, Standard_Integer const theIndex)

        Binds implicit zero circle.
        @param theIndex index a zero circle should be bound with.

        :type theIndex: int

        """
        return _BRepMesh.BRepMesh_CircleTool_MocBind(self, *args)


    def Delete(self, *args):
        """
        Delete(BRepMesh_CircleTool self, Standard_Integer const theIndex)

        Deletes a circle from the tool.
        @param theIndex index of a circle to be removed.

        :type theIndex: int

        """
        return _BRepMesh.BRepMesh_CircleTool_Delete(self, *args)


    def Select(self, *args):
        """
        Select(BRepMesh_CircleTool self, gp_XY thePoint) -> BRepMesh::ListOfInteger &

        Select the circles shot by the given point.
        @param thePoint bullet point.

        :type thePoint: OCC.wrapper.gp.gp_XY
        :rtype: ListOfInteger

        """
        return _BRepMesh.BRepMesh_CircleTool_Select(self, *args)

    __swig_destroy__ = _BRepMesh.delete_BRepMesh_CircleTool
BRepMesh_CircleTool_swigregister = _BRepMesh.BRepMesh_CircleTool_swigregister
BRepMesh_CircleTool_swigregister(BRepMesh_CircleTool)

def BRepMesh_CircleTool_MakeCircle(*args):
    """
    BRepMesh_CircleTool_MakeCircle(gp_XY thePoint1, gp_XY thePoint2, gp_XY thePoint3, gp_XY theLocation) -> Standard_Boolean

    Computes circle on three points.
    @param thePoint1 first point.
    @param thePoint2 second point.
    @param thePoint3 third point.
    @param[out] theLocation center of computed circle.
    @param[out] theRadius radius of computed circle.
    @return FALSE in case of impossibility to build a circle 
    on the given points, TRUE elsewhere.

    :type thePoint1: OCC.wrapper.gp.gp_XY
    :type thePoint2: OCC.wrapper.gp.gp_XY
    :type thePoint3: OCC.wrapper.gp.gp_XY
    :type theLocation: OCC.wrapper.gp.gp_XY
    :type theRadius: float
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _BRepMesh.BRepMesh_CircleTool_MakeCircle(*args)

class Handle_BRepMesh_EdgeTessellationExtractor(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_BRepMesh_EdgeTessellationExtractor self)

        Nullify the handle


        """
        return _BRepMesh.Handle_BRepMesh_EdgeTessellationExtractor_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_BRepMesh_EdgeTessellationExtractor self) -> bool

        Check for being null

        :rtype: bool

        """
        return _BRepMesh.Handle_BRepMesh_EdgeTessellationExtractor_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_BRepMesh_EdgeTessellationExtractor self, BRepMesh_EdgeTessellationExtractor thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _BRepMesh.Handle_BRepMesh_EdgeTessellationExtractor_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_BRepMesh_EdgeTessellationExtractor self, Handle_BRepMesh_EdgeTessellationExtractor theHandle) -> Handle_BRepMesh_EdgeTessellationExtractor
        assign(Handle_BRepMesh_EdgeTessellationExtractor self, BRepMesh_EdgeTessellationExtractor thePtr) -> Handle_BRepMesh_EdgeTessellationExtractor
        assign(Handle_BRepMesh_EdgeTessellationExtractor self, Handle_BRepMesh_EdgeTessellationExtractor theHandle) -> Handle_BRepMesh_EdgeTessellationExtractor

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _BRepMesh.Handle_BRepMesh_EdgeTessellationExtractor_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_BRepMesh_EdgeTessellationExtractor self) -> BRepMesh_EdgeTessellationExtractor

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _BRepMesh.Handle_BRepMesh_EdgeTessellationExtractor_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_BRepMesh_EdgeTessellationExtractor self) -> BRepMesh_EdgeTessellationExtractor

        Member access operator (note non-const)

        :rtype: T *

        """
        return _BRepMesh.Handle_BRepMesh_EdgeTessellationExtractor___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_BRepMesh_EdgeTessellationExtractor self) -> BRepMesh_EdgeTessellationExtractor

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _BRepMesh.Handle_BRepMesh_EdgeTessellationExtractor___ref__(self, *args)


    def __hash__(self):
        return _BRepMesh.Handle_BRepMesh_EdgeTessellationExtractor___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _BRepMesh.Handle_BRepMesh_EdgeTessellationExtractor___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _BRepMesh.new_Handle_BRepMesh_EdgeTessellationExtractor(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_BRepMesh.Handle_BRepMesh_EdgeTessellationExtractor_DownCast)
    __swig_destroy__ = _BRepMesh.delete_Handle_BRepMesh_EdgeTessellationExtractor

    def NbPoints(self, *args):
        """
        NbPoints(Handle_BRepMesh_EdgeTessellationExtractor self) -> Standard_Integer

        Returns number of dicretization points.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepMesh.Handle_BRepMesh_EdgeTessellationExtractor_NbPoints(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_BRepMesh_EdgeTessellationExtractor self) -> char const *

        :rtype: const char *

        """
        return _BRepMesh.Handle_BRepMesh_EdgeTessellationExtractor_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _BRepMesh.Handle_BRepMesh_EdgeTessellationExtractor_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _BRepMesh.Handle_BRepMesh_EdgeTessellationExtractor_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Value(self, *args):
        """
        Value(Handle_BRepMesh_EdgeTessellationExtractor self, Standard_Integer const theIndex, gp_Pnt thePoint, gp_Pnt2d theUV) -> Standard_Boolean

        Returns parameters of solution with the given index.
        @param theIndex index of tessellation point.
        @param theParameter parameters on PCurve corresponded to the solution.
        @param thePoint tessellation point.
        @param theUV coordinates of tessellation point in parametric space of face.
        @return True in case of valid result, false elewhere.

        :type theIndex: int
        :type theParameter: float
        :type thePoint: OCC.wrapper.gp.gp_Pnt
        :type theUV: OCC.wrapper.gp.gp_Pnt2d
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepMesh.Handle_BRepMesh_EdgeTessellationExtractor_Value(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_BRepMesh_EdgeTessellationExtractor self)

        Memory deallocator for transient classes


        """
        return _BRepMesh.Handle_BRepMesh_EdgeTessellationExtractor_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_BRepMesh_EdgeTessellationExtractor self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_BRepMesh_EdgeTessellationExtractor self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepMesh.Handle_BRepMesh_EdgeTessellationExtractor_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_BRepMesh_EdgeTessellationExtractor self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_BRepMesh_EdgeTessellationExtractor self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepMesh.Handle_BRepMesh_EdgeTessellationExtractor_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_BRepMesh_EdgeTessellationExtractor self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _BRepMesh.Handle_BRepMesh_EdgeTessellationExtractor_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_BRepMesh_EdgeTessellationExtractor self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepMesh.Handle_BRepMesh_EdgeTessellationExtractor_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_BRepMesh_EdgeTessellationExtractor self)

        Increments the reference counter of this object


        """
        return _BRepMesh.Handle_BRepMesh_EdgeTessellationExtractor_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_BRepMesh_EdgeTessellationExtractor self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepMesh.Handle_BRepMesh_EdgeTessellationExtractor_DecrementRefCounter(self, *args)

Handle_BRepMesh_EdgeTessellationExtractor_swigregister = _BRepMesh.Handle_BRepMesh_EdgeTessellationExtractor_swigregister
Handle_BRepMesh_EdgeTessellationExtractor_swigregister(Handle_BRepMesh_EdgeTessellationExtractor)

def Handle_BRepMesh_EdgeTessellationExtractor_DownCast(thing):
    return _BRepMesh.Handle_BRepMesh_EdgeTessellationExtractor_DownCast(thing)
Handle_BRepMesh_EdgeTessellationExtractor_DownCast = _BRepMesh.Handle_BRepMesh_EdgeTessellationExtractor_DownCast

class BRepMesh_ShapeTool(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def MaxFaceTolerance(*args):
        """
        MaxFaceTolerance(TopoDS_Face theFace) -> Standard_Real

        Returns maximum tolerance of the given face.
        Considers tolerances of edges and vertices contained in the given face.

        :type theFace: OCC.wrapper.TopoDS.TopoDS_Face
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _BRepMesh.BRepMesh_ShapeTool_MaxFaceTolerance(*args)

    MaxFaceTolerance = staticmethod(MaxFaceTolerance)

    def BoxMaxDimension(*args):
        """
        BoxMaxDimension(Bnd_Box theBox)

        Gets the maximum dimension of the given bounding box.
        If the given bounding box is void leaves the resulting value unchanged.
        @param theBox bounding box to be processed.
        @param theMaxDimension maximum dimension of the given box.

        :type theBox: OCC.wrapper.Bnd.Bnd_Box
        :type theMaxDimension: float

        """
        return _BRepMesh.BRepMesh_ShapeTool_BoxMaxDimension(*args)

    BoxMaxDimension = staticmethod(BoxMaxDimension)

    def RelativeEdgeDeflection(*args):
        """
        RelativeEdgeDeflection(TopoDS_Edge theEdge, Standard_Real const theDeflection, Standard_Real const theMaxShapeSize) -> Standard_Real

        Returns relative deflection for edge with respect to shape size.
        @param theEdge edge for which relative deflection should be computed.
        @param theDeflection absolute deflection.
        @param theMaxShapeSize maximum size of a shape.
        @param theAdjustmentCoefficient coefficient of adjustment between maximum 
        size of shape and calculated relative deflection.
        @return relative deflection for the edge.

        :type theEdge: OCC.wrapper.TopoDS.TopoDS_Edge
        :type theDeflection: float
        :type theMaxShapeSize: float
        :type theAdjustmentCoefficient: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _BRepMesh.BRepMesh_ShapeTool_RelativeEdgeDeflection(*args)

    RelativeEdgeDeflection = staticmethod(RelativeEdgeDeflection)

    def FindUV(*args):
        """
        FindUV(Standard_Integer const theIndexOfPnt3d, gp_Pnt2d thePnt2d, Standard_Real const theMinDistance, Handle_BRepMesh_FaceAttribute theFaceAttribute) -> gp_XY

        Checks 2d representations of 3d point with the 
        given index for equality to avoid duplications.
        @param theIndexOfPnt3d index of 3d point with which 2d 
        representation should be associated.
        @param thePnt2d 2d representation of the point with the 
        given index.
        @param theMinDistance minimum distance between vertices 
        regarding which they could be treated as distinct ones.
        @param theFaceAttribute attributes contining data calculated
        according to face geomtry and define limits of face in parametric 
        space. If defined, will be used instead of surface parameter.
        @param theLocation2dMap map of 2d representations of 3d points.
        @return given 2d point in case if 3d poind does not alredy have 
        the similar representation, otherwice 2d point corresponding to 
        existing representation will be returned.

        :type theIndexOfPnt3d: int
        :type thePnt2d: OCC.wrapper.gp.gp_Pnt2d
        :type theMinDistance: float
        :type theFaceAttribute: OCC.wrapper.BRepMesh.Handle_BRepMesh_FaceAttribute
        :rtype: OCC.wrapper.gp.gp_XY

        """
        return _BRepMesh.BRepMesh_ShapeTool_FindUV(*args)

    FindUV = staticmethod(FindUV)

    def AddInFace(*args):
        """
        AddInFace(TopoDS_Face theFace, Handle_Poly_Triangulation theTriangulation)

        Stores the given triangulation into the given face.
        @param theFace face to be updated by triangulation.
        @param theTriangulation triangulation to be stored into the face.

        :type theFace: OCC.wrapper.TopoDS.TopoDS_Face
        :type theTriangulation: OCC.wrapper.Poly.Handle_Poly_Triangulation

        """
        return _BRepMesh.BRepMesh_ShapeTool_AddInFace(*args)

    AddInFace = staticmethod(AddInFace)

    def NullifyFace(*args):
        """
        NullifyFace(TopoDS_Face theFace)

        Nullifies triangulation stored in the face.
        @param theFace face to be updated by null triangulation.

        :type theFace: OCC.wrapper.TopoDS.TopoDS_Face

        """
        return _BRepMesh.BRepMesh_ShapeTool_NullifyFace(*args)

    NullifyFace = staticmethod(NullifyFace)

    def NullifyEdge(*args):
        """
        NullifyEdge(TopoDS_Edge theEdge, Handle_Poly_Triangulation theTriangulation, TopLoc_Location theLocation)

        Nullifies polygon on triangulation stored in the edge.
        @param theEdge edge to be updated by null polygon.
        @param theTriangulation triangulation the given edge is associated to.
        @param theLocation face location.

        :type theEdge: OCC.wrapper.TopoDS.TopoDS_Edge
        :type theTriangulation: OCC.wrapper.Poly.Handle_Poly_Triangulation
        :type theLocation: OCC.wrapper.TopLoc.TopLoc_Location

        """
        return _BRepMesh.BRepMesh_ShapeTool_NullifyEdge(*args)

    NullifyEdge = staticmethod(NullifyEdge)

    def UpdateEdge(*args):
        """
        UpdateEdge(TopoDS_Edge theEdge, Handle_Poly_PolygonOnTriangulation thePolygon, Handle_Poly_Triangulation theTriangulation, TopLoc_Location theLocation)
        UpdateEdge(TopoDS_Edge theEdge, Handle_Poly_PolygonOnTriangulation thePolygon1, Handle_Poly_PolygonOnTriangulation thePolygon2, Handle_Poly_Triangulation theTriangulation, TopLoc_Location theLocation)

        Updates the given seam edge by the given tessellated representations.
        @param theEdge edge to be updated.
        @param thePolygon1 tessellated representation corresponding to
        forward direction of the seam edge.
        @param thePolygon2 tessellated representation corresponding to
        reversed direction of the seam edge.
        @param theTriangulation triangulation the given edge is associated to.
        @param theLocation face location.

        :type theEdge: OCC.wrapper.TopoDS.TopoDS_Edge
        :type thePolygon1: OCC.wrapper.Poly.Handle_Poly_PolygonOnTriangulation
        :type thePolygon2: OCC.wrapper.Poly.Handle_Poly_PolygonOnTriangulation
        :type theTriangulation: OCC.wrapper.Poly.Handle_Poly_Triangulation
        :type theLocation: OCC.wrapper.TopLoc.TopLoc_Location

        """
        return _BRepMesh.BRepMesh_ShapeTool_UpdateEdge(*args)

    UpdateEdge = staticmethod(UpdateEdge)

    def UseLocation(*args):
        """
        UseLocation(gp_Pnt thePnt, TopLoc_Location theLoc) -> gp_Pnt

        Applies location to the given point and return result.
        @param thePnt point to be transformed.
        @param theLoc location to be applied.

        :type thePnt: OCC.wrapper.gp.gp_Pnt
        :type theLoc: OCC.wrapper.TopLoc.TopLoc_Location
        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _BRepMesh.BRepMesh_ShapeTool_UseLocation(*args)

    UseLocation = staticmethod(UseLocation)

    def IsDegenerated(*args):
        """
        IsDegenerated(TopoDS_Edge theEdge, TopoDS_Face theFace) -> Standard_Boolean

        Checks is the given edge degenerated.
        Checks geometrical parameters in case if IsDegenerated flag is not set.
        @param theEdge edge to be checked.
        @param theFace face within which parametric space edge will be checked
        for geometrical degenerativity.

        :type theEdge: OCC.wrapper.TopoDS.TopoDS_Edge
        :type theFace: OCC.wrapper.TopoDS.TopoDS_Face
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepMesh.BRepMesh_ShapeTool_IsDegenerated(*args)

    IsDegenerated = staticmethod(IsDegenerated)

    def __init__(self):
        this = _BRepMesh.new_BRepMesh_ShapeTool()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _BRepMesh.delete_BRepMesh_ShapeTool
BRepMesh_ShapeTool_swigregister = _BRepMesh.BRepMesh_ShapeTool_swigregister
BRepMesh_ShapeTool_swigregister(BRepMesh_ShapeTool)

def BRepMesh_ShapeTool_MaxFaceTolerance(*args):
    """
    BRepMesh_ShapeTool_MaxFaceTolerance(TopoDS_Face theFace) -> Standard_Real

    Returns maximum tolerance of the given face.
    Considers tolerances of edges and vertices contained in the given face.

    :type theFace: OCC.wrapper.TopoDS.TopoDS_Face
    :rtype: OCC.wrapper.Standard.Standard_Real

    """
    return _BRepMesh.BRepMesh_ShapeTool_MaxFaceTolerance(*args)

def BRepMesh_ShapeTool_BoxMaxDimension(*args):
    """
    BRepMesh_ShapeTool_BoxMaxDimension(Bnd_Box theBox)

    Gets the maximum dimension of the given bounding box.
    If the given bounding box is void leaves the resulting value unchanged.
    @param theBox bounding box to be processed.
    @param theMaxDimension maximum dimension of the given box.

    :type theBox: OCC.wrapper.Bnd.Bnd_Box
    :type theMaxDimension: float

    """
    return _BRepMesh.BRepMesh_ShapeTool_BoxMaxDimension(*args)

def BRepMesh_ShapeTool_RelativeEdgeDeflection(*args):
    """
    BRepMesh_ShapeTool_RelativeEdgeDeflection(TopoDS_Edge theEdge, Standard_Real const theDeflection, Standard_Real const theMaxShapeSize) -> Standard_Real

    Returns relative deflection for edge with respect to shape size.
    @param theEdge edge for which relative deflection should be computed.
    @param theDeflection absolute deflection.
    @param theMaxShapeSize maximum size of a shape.
    @param theAdjustmentCoefficient coefficient of adjustment between maximum 
    size of shape and calculated relative deflection.
    @return relative deflection for the edge.

    :type theEdge: OCC.wrapper.TopoDS.TopoDS_Edge
    :type theDeflection: float
    :type theMaxShapeSize: float
    :type theAdjustmentCoefficient: float
    :rtype: OCC.wrapper.Standard.Standard_Real

    """
    return _BRepMesh.BRepMesh_ShapeTool_RelativeEdgeDeflection(*args)

def BRepMesh_ShapeTool_FindUV(*args):
    """
    BRepMesh_ShapeTool_FindUV(Standard_Integer const theIndexOfPnt3d, gp_Pnt2d thePnt2d, Standard_Real const theMinDistance, Handle_BRepMesh_FaceAttribute theFaceAttribute) -> gp_XY

    Checks 2d representations of 3d point with the 
    given index for equality to avoid duplications.
    @param theIndexOfPnt3d index of 3d point with which 2d 
    representation should be associated.
    @param thePnt2d 2d representation of the point with the 
    given index.
    @param theMinDistance minimum distance between vertices 
    regarding which they could be treated as distinct ones.
    @param theFaceAttribute attributes contining data calculated
    according to face geomtry and define limits of face in parametric 
    space. If defined, will be used instead of surface parameter.
    @param theLocation2dMap map of 2d representations of 3d points.
    @return given 2d point in case if 3d poind does not alredy have 
    the similar representation, otherwice 2d point corresponding to 
    existing representation will be returned.

    :type theIndexOfPnt3d: int
    :type thePnt2d: OCC.wrapper.gp.gp_Pnt2d
    :type theMinDistance: float
    :type theFaceAttribute: OCC.wrapper.BRepMesh.Handle_BRepMesh_FaceAttribute
    :rtype: OCC.wrapper.gp.gp_XY

    """
    return _BRepMesh.BRepMesh_ShapeTool_FindUV(*args)

def BRepMesh_ShapeTool_AddInFace(*args):
    """
    BRepMesh_ShapeTool_AddInFace(TopoDS_Face theFace, Handle_Poly_Triangulation theTriangulation)

    Stores the given triangulation into the given face.
    @param theFace face to be updated by triangulation.
    @param theTriangulation triangulation to be stored into the face.

    :type theFace: OCC.wrapper.TopoDS.TopoDS_Face
    :type theTriangulation: OCC.wrapper.Poly.Handle_Poly_Triangulation

    """
    return _BRepMesh.BRepMesh_ShapeTool_AddInFace(*args)

def BRepMesh_ShapeTool_NullifyFace(*args):
    """
    BRepMesh_ShapeTool_NullifyFace(TopoDS_Face theFace)

    Nullifies triangulation stored in the face.
    @param theFace face to be updated by null triangulation.

    :type theFace: OCC.wrapper.TopoDS.TopoDS_Face

    """
    return _BRepMesh.BRepMesh_ShapeTool_NullifyFace(*args)

def BRepMesh_ShapeTool_NullifyEdge(*args):
    """
    BRepMesh_ShapeTool_NullifyEdge(TopoDS_Edge theEdge, Handle_Poly_Triangulation theTriangulation, TopLoc_Location theLocation)

    Nullifies polygon on triangulation stored in the edge.
    @param theEdge edge to be updated by null polygon.
    @param theTriangulation triangulation the given edge is associated to.
    @param theLocation face location.

    :type theEdge: OCC.wrapper.TopoDS.TopoDS_Edge
    :type theTriangulation: OCC.wrapper.Poly.Handle_Poly_Triangulation
    :type theLocation: OCC.wrapper.TopLoc.TopLoc_Location

    """
    return _BRepMesh.BRepMesh_ShapeTool_NullifyEdge(*args)

def BRepMesh_ShapeTool_UpdateEdge(*args):
    """
    UpdateEdge(TopoDS_Edge theEdge, Handle_Poly_PolygonOnTriangulation thePolygon, Handle_Poly_Triangulation theTriangulation, TopLoc_Location theLocation)
    BRepMesh_ShapeTool_UpdateEdge(TopoDS_Edge theEdge, Handle_Poly_PolygonOnTriangulation thePolygon1, Handle_Poly_PolygonOnTriangulation thePolygon2, Handle_Poly_Triangulation theTriangulation, TopLoc_Location theLocation)

    Updates the given seam edge by the given tessellated representations.
    @param theEdge edge to be updated.
    @param thePolygon1 tessellated representation corresponding to
    forward direction of the seam edge.
    @param thePolygon2 tessellated representation corresponding to
    reversed direction of the seam edge.
    @param theTriangulation triangulation the given edge is associated to.
    @param theLocation face location.

    :type theEdge: OCC.wrapper.TopoDS.TopoDS_Edge
    :type thePolygon1: OCC.wrapper.Poly.Handle_Poly_PolygonOnTriangulation
    :type thePolygon2: OCC.wrapper.Poly.Handle_Poly_PolygonOnTriangulation
    :type theTriangulation: OCC.wrapper.Poly.Handle_Poly_Triangulation
    :type theLocation: OCC.wrapper.TopLoc.TopLoc_Location

    """
    return _BRepMesh.BRepMesh_ShapeTool_UpdateEdge(*args)

def BRepMesh_ShapeTool_UseLocation(*args):
    """
    BRepMesh_ShapeTool_UseLocation(gp_Pnt thePnt, TopLoc_Location theLoc) -> gp_Pnt

    Applies location to the given point and return result.
    @param thePnt point to be transformed.
    @param theLoc location to be applied.

    :type thePnt: OCC.wrapper.gp.gp_Pnt
    :type theLoc: OCC.wrapper.TopLoc.TopLoc_Location
    :rtype: OCC.wrapper.gp.gp_Pnt

    """
    return _BRepMesh.BRepMesh_ShapeTool_UseLocation(*args)

def BRepMesh_ShapeTool_IsDegenerated(*args):
    """
    BRepMesh_ShapeTool_IsDegenerated(TopoDS_Edge theEdge, TopoDS_Face theFace) -> Standard_Boolean

    Checks is the given edge degenerated.
    Checks geometrical parameters in case if IsDegenerated flag is not set.
    @param theEdge edge to be checked.
    @param theFace face within which parametric space edge will be checked
    for geometrical degenerativity.

    :type theEdge: OCC.wrapper.TopoDS.TopoDS_Edge
    :type theFace: OCC.wrapper.TopoDS.TopoDS_Face
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _BRepMesh.BRepMesh_ShapeTool_IsDegenerated(*args)

class BRepMesh_Vertex(object):
    """
    Light weighted structure representing vertex 
    of the mesh in parametric space. Vertex could be 
    associated with 3d point stored in external map.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BRepMesh_Vertex self) -> BRepMesh_Vertex
        __init__(BRepMesh_Vertex self, gp_XY theUV, Standard_Integer const theLocation3d, BRepMesh_DegreeOfFreedom const theMovability) -> BRepMesh_Vertex
        __init__(BRepMesh_Vertex self, Standard_Real const theU, Standard_Real const theV, BRepMesh_DegreeOfFreedom const theMovability) -> BRepMesh_Vertex

        Creates vertex without association with point in 3d space.
        @param theU U position of vertex in parametric space.
        @param theV V position of vertex in parametric space.
        @param theMovability movability of the vertex.

        :type theU: float
        :type theV: float
        :type theMovability: OCC.wrapper.BRepMesh.BRepMesh_DegreeOfFreedom

        """
        this = _BRepMesh.new_BRepMesh_Vertex(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Initialize(self, *args):
        """
        Initialize(BRepMesh_Vertex self, gp_XY theUV, Standard_Integer const theLocation3d, BRepMesh_DegreeOfFreedom const theMovability)

        Initializes vertex associated with point in 3d space.
        @param theUV position of vertex in parametric space.
        @param theLocation3d index of 3d point to be associated with vertex.
        @param theMovability movability of the vertex.

        :type theUV: OCC.wrapper.gp.gp_XY
        :type theLocation3d: int
        :type theMovability: OCC.wrapper.BRepMesh.BRepMesh_DegreeOfFreedom

        """
        return _BRepMesh.BRepMesh_Vertex_Initialize(self, *args)


    def Coord(self, *args):
        """
        Returns position of the vertex in parametric space.

        :rtype: OCC.wrapper.gp.gp_XY

        """
        res = _BRepMesh.BRepMesh_Vertex_Coord(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeCoord(self, *args):
        """
        ChangeCoord(BRepMesh_Vertex self) -> gp_XY

        Returns position of the vertex in parametric space for modification.

        :rtype: OCC.wrapper.gp.gp_XY

        """
        return _BRepMesh.BRepMesh_Vertex_ChangeCoord(self, *args)


    def Location3d(self, *args):
        """
        Location3d(BRepMesh_Vertex self) -> Standard_Integer

        Returns index of 3d point associated with the vertex.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepMesh.BRepMesh_Vertex_Location3d(self, *args)


    def Movability(self, *args):
        """
        Movability(BRepMesh_Vertex self) -> BRepMesh_DegreeOfFreedom

        Returns movability of the vertex.

        :rtype: OCC.wrapper.BRepMesh.BRepMesh_DegreeOfFreedom

        """
        return _BRepMesh.BRepMesh_Vertex_Movability(self, *args)


    def SetMovability(self, *args):
        """
        SetMovability(BRepMesh_Vertex self, BRepMesh_DegreeOfFreedom const theMovability)

        Sets movability of the vertex.

        :type theMovability: OCC.wrapper.BRepMesh.BRepMesh_DegreeOfFreedom

        """
        return _BRepMesh.BRepMesh_Vertex_SetMovability(self, *args)


    def HashCode(self, *args):
        """
        HashCode(BRepMesh_Vertex self, Standard_Integer const Upper) -> Standard_Integer

        Returns hash code for this vertex.
        @param theUpper upper index in the container.
        @return hash code.

        :type Upper: int
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepMesh.BRepMesh_Vertex_HashCode(self, *args)


    def __hash__(self, *args):
        """
        __hash__(BRepMesh_Vertex self) -> Standard_Integer

        Returns the a hashcode based on the HashCode method, suitable for a python __hash__

        :rtype: int
        """
        return _BRepMesh.BRepMesh_Vertex___hash__(self, *args)


    def IsEqual(self, *args):
        """
        IsEqual(BRepMesh_Vertex self, BRepMesh_Vertex theOther) -> Standard_Boolean

        Checks for equality with another vertex.
        @param theOther vertex to be checked against this one.
        @return TRUE if equal, FALSE if not.

        :type theOther: OCC.wrapper.BRepMesh.BRepMesh_Vertex
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepMesh.BRepMesh_Vertex_IsEqual(self, *args)


    def __eq__(self, *args):
        """
        __eq__(BRepMesh_Vertex self, BRepMesh_Vertex Other) -> Standard_Boolean

        Alias for IsEqual.

        :type Other: OCC.wrapper.BRepMesh.BRepMesh_Vertex
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepMesh.BRepMesh_Vertex___eq__(self, *args)

    __swig_destroy__ = _BRepMesh.delete_BRepMesh_Vertex
BRepMesh_Vertex_swigregister = _BRepMesh.BRepMesh_Vertex_swigregister
BRepMesh_Vertex_swigregister(BRepMesh_Vertex)

class BRepMesh_OrientedEdge(object):
    """Light weighted structure representing simple link."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BRepMesh_OrientedEdge self) -> BRepMesh_OrientedEdge
        __init__(BRepMesh_OrientedEdge self, Standard_Integer const theFirstNode, Standard_Integer const theLastNode) -> BRepMesh_OrientedEdge

        Constructs a link between two vertices.

        :type theFirstNode: int
        :type theLastNode: int

        """
        this = _BRepMesh.new_BRepMesh_OrientedEdge(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def FirstNode(self, *args):
        """
        FirstNode(BRepMesh_OrientedEdge self) -> Standard_Integer

        Returns index of first node of the Link.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepMesh.BRepMesh_OrientedEdge_FirstNode(self, *args)


    def LastNode(self, *args):
        """
        LastNode(BRepMesh_OrientedEdge self) -> Standard_Integer

        Returns index of last node of the Link.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepMesh.BRepMesh_OrientedEdge_LastNode(self, *args)


    def HashCode(self, *args):
        """
        HashCode(BRepMesh_OrientedEdge self, Standard_Integer const theUpper) -> Standard_Integer

        Returns hash code for this edge.
        @param theUpper upper index in the container.
        @return hash code.

        :type theUpper: int
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepMesh.BRepMesh_OrientedEdge_HashCode(self, *args)


    def __hash__(self, *args):
        """
        __hash__(BRepMesh_OrientedEdge self) -> Standard_Integer

        Returns the a hashcode based on the HashCode method, suitable for a python __hash__

        :rtype: int
        """
        return _BRepMesh.BRepMesh_OrientedEdge___hash__(self, *args)


    def IsEqual(self, *args):
        """
        IsEqual(BRepMesh_OrientedEdge self, BRepMesh_OrientedEdge theOther) -> Standard_Boolean

        Checks this and other edge for equality.
        @param theOther edge to be checked against this one.
        @return TRUE if edges have the same orientation, FALSE if not.

        :type theOther: OCC.wrapper.BRepMesh.BRepMesh_OrientedEdge
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepMesh.BRepMesh_OrientedEdge_IsEqual(self, *args)


    def __eq__(self, *args):
        """
        __eq__(BRepMesh_OrientedEdge self, BRepMesh_OrientedEdge Other) -> Standard_Boolean

        Alias for IsEqual.

        :type Other: OCC.wrapper.BRepMesh.BRepMesh_OrientedEdge
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepMesh.BRepMesh_OrientedEdge___eq__(self, *args)

    __swig_destroy__ = _BRepMesh.delete_BRepMesh_OrientedEdge
BRepMesh_OrientedEdge_swigregister = _BRepMesh.BRepMesh_OrientedEdge_swigregister
BRepMesh_OrientedEdge_swigregister(BRepMesh_OrientedEdge)

class BRepMesh_Edge(BRepMesh_OrientedEdge):
    """Light weighted structure representing link of the mesh."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BRepMesh_Edge self) -> BRepMesh_Edge
        __init__(BRepMesh_Edge self, Standard_Integer const theFirstNode, Standard_Integer const theLastNode, BRepMesh_DegreeOfFreedom const theMovability) -> BRepMesh_Edge

        Constructs a link between two vertices.

        :type theFirstNode: int
        :type theLastNode: int
        :type theMovability: OCC.wrapper.BRepMesh.BRepMesh_DegreeOfFreedom

        """
        this = _BRepMesh.new_BRepMesh_Edge(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Movability(self, *args):
        """
        Movability(BRepMesh_Edge self) -> BRepMesh_DegreeOfFreedom

        Returns movability flag of the Link.

        :rtype: OCC.wrapper.BRepMesh.BRepMesh_DegreeOfFreedom

        """
        return _BRepMesh.BRepMesh_Edge_Movability(self, *args)


    def SetMovability(self, *args):
        """
        SetMovability(BRepMesh_Edge self, BRepMesh_DegreeOfFreedom const theMovability)

        Sets movability flag of the Link.
        @param theMovability flag to be set.

        :type theMovability: OCC.wrapper.BRepMesh.BRepMesh_DegreeOfFreedom

        """
        return _BRepMesh.BRepMesh_Edge_SetMovability(self, *args)


    def IsSameOrientation(self, *args):
        """
        IsSameOrientation(BRepMesh_Edge self, BRepMesh_Edge theOther) -> Standard_Boolean

        Checks if the given edge and this one have the same orientation.
        @param theOther edge to be checked against this one.
        @return TRUE if edges have the same orientation, FALSE if not.

        :type theOther: OCC.wrapper.BRepMesh.BRepMesh_Edge
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepMesh.BRepMesh_Edge_IsSameOrientation(self, *args)


    def IsEqual(self, *args):
        """
        IsEqual(BRepMesh_Edge self, BRepMesh_Edge theOther) -> Standard_Boolean

        Checks for equality with another edge.
        @param theOther edge to be checked against this one.
        @return TRUE if equal, FALSE if not.

        :type theOther: OCC.wrapper.BRepMesh.BRepMesh_Edge
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepMesh.BRepMesh_Edge_IsEqual(self, *args)


    def __eq__(self, *args):
        """
        __eq__(BRepMesh_Edge self, BRepMesh_Edge Other) -> Standard_Boolean

        Alias for IsEqual.

        :type Other: OCC.wrapper.BRepMesh.BRepMesh_Edge
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepMesh.BRepMesh_Edge___eq__(self, *args)

    __swig_destroy__ = _BRepMesh.delete_BRepMesh_Edge
BRepMesh_Edge_swigregister = _BRepMesh.BRepMesh_Edge_swigregister
BRepMesh_Edge_swigregister(BRepMesh_Edge)

class Handle_BRepMesh_FastDiscret(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_BRepMesh_FastDiscret self)

        Nullify the handle


        """
        return _BRepMesh.Handle_BRepMesh_FastDiscret_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_BRepMesh_FastDiscret self) -> bool

        Check for being null

        :rtype: bool

        """
        return _BRepMesh.Handle_BRepMesh_FastDiscret_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_BRepMesh_FastDiscret self, BRepMesh_FastDiscret thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _BRepMesh.Handle_BRepMesh_FastDiscret_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_BRepMesh_FastDiscret self, Handle_BRepMesh_FastDiscret theHandle) -> Handle_BRepMesh_FastDiscret
        assign(Handle_BRepMesh_FastDiscret self, BRepMesh_FastDiscret thePtr) -> Handle_BRepMesh_FastDiscret
        assign(Handle_BRepMesh_FastDiscret self, Handle_BRepMesh_FastDiscret theHandle) -> Handle_BRepMesh_FastDiscret

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _BRepMesh.Handle_BRepMesh_FastDiscret_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_BRepMesh_FastDiscret self) -> BRepMesh_FastDiscret

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _BRepMesh.Handle_BRepMesh_FastDiscret_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_BRepMesh_FastDiscret self) -> BRepMesh_FastDiscret

        Member access operator (note non-const)

        :rtype: T *

        """
        return _BRepMesh.Handle_BRepMesh_FastDiscret___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_BRepMesh_FastDiscret self) -> BRepMesh_FastDiscret

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _BRepMesh.Handle_BRepMesh_FastDiscret___ref__(self, *args)


    def __hash__(self):
        return _BRepMesh.Handle_BRepMesh_FastDiscret___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _BRepMesh.Handle_BRepMesh_FastDiscret___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _BRepMesh.new_Handle_BRepMesh_FastDiscret(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_BRepMesh.Handle_BRepMesh_FastDiscret_DownCast)
    __swig_destroy__ = _BRepMesh.delete_Handle_BRepMesh_FastDiscret

    def Perform(self, *args):
        """
        Perform(Handle_BRepMesh_FastDiscret self, TopoDS_Shape shape)

        Build triangulation on the whole shape.

        :type shape: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _BRepMesh.Handle_BRepMesh_FastDiscret_Perform(self, *args)


    def Add(self, *args):
        """
        Add(Handle_BRepMesh_FastDiscret self, TopoDS_Face face) -> Standard_Integer

        Record a face for further processing.
        @return status flags collected during discretization 
        of boundaries of the given face.

        :type face: OCC.wrapper.TopoDS.TopoDS_Face
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepMesh.Handle_BRepMesh_FastDiscret_Add(self, *args)


    def Process(self, *args):
        """
        Process(Handle_BRepMesh_FastDiscret self, TopoDS_Face face)

        Triangulate a face previously recorded for 
        processing by call to Add(). Can be executed in 
        parallel threads.

        :type face: OCC.wrapper.TopoDS.TopoDS_Face

        """
        return _BRepMesh.Handle_BRepMesh_FastDiscret_Process(self, *args)


    def __call__(self, *args):
        """
        __call__(Handle_BRepMesh_FastDiscret self, TopoDS_Face face)

        :type face: OCC.wrapper.TopoDS.TopoDS_Face

        """
        return _BRepMesh.Handle_BRepMesh_FastDiscret___call__(self, *args)


    def MeshParameters(self, *args):
        """
        Returns parameters of meshing

        :rtype: Parameters

        """
        res = _BRepMesh.Handle_BRepMesh_FastDiscret_MeshParameters(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeMeshParameters(self, *args):
        """
        ChangeMeshParameters(Handle_BRepMesh_FastDiscret self) -> BRepMesh_FastDiscret::Parameters &

        Returns modificable mesh parameters

        :rtype: Parameters

        """
        return _BRepMesh.Handle_BRepMesh_FastDiscret_ChangeMeshParameters(self, *args)


    def InitSharedFaces(self, *args):
        """
        InitSharedFaces(Handle_BRepMesh_FastDiscret self, TopoDS_Shape theShape)

        :type theShape: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _BRepMesh.Handle_BRepMesh_FastDiscret_InitSharedFaces(self, *args)


    def SharedFaces(self, *args):
        """
        :rtype: OCC.wrapper.TopTools.TopTools_IndexedDataMapOfShapeListOfShape

        """
        res = _BRepMesh.Handle_BRepMesh_FastDiscret_SharedFaces(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def GetFaceAttribute(self, *args):
        """
        GetFaceAttribute(Handle_BRepMesh_FastDiscret self, TopoDS_Face theFace, Handle_BRepMesh_FaceAttribute theAttribute, Standard_Boolean const isForceCreate) -> Standard_Boolean

        Returns attribute descriptor for the given face.
        @param theFace face the attribute should be returned for.
        @param[out] theAttribute attribute found for the specified face.
        @param isForceCreate if True creates new attribute in case if there 
        is no data for the given face.

        :type theFace: OCC.wrapper.TopoDS.TopoDS_Face
        :type theAttribute: OCC.wrapper.BRepMesh.Handle_BRepMesh_FaceAttribute
        :type isForceCreate: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepMesh.Handle_BRepMesh_FastDiscret_GetFaceAttribute(self, *args)


    def RemoveFaceAttribute(self, *args):
        """
        RemoveFaceAttribute(Handle_BRepMesh_FastDiscret self, TopoDS_Face theFace)

        Remove face attribute as useless to free locate memory.

        :type theFace: OCC.wrapper.TopoDS.TopoDS_Face

        """
        return _BRepMesh.Handle_BRepMesh_FastDiscret_RemoveFaceAttribute(self, *args)


    def NbBoundaryPoints(self, *args):
        """
        NbBoundaryPoints(Handle_BRepMesh_FastDiscret self) -> Standard_Integer

        Returns number of boundary 3d points.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepMesh.Handle_BRepMesh_FastDiscret_NbBoundaryPoints(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_BRepMesh_FastDiscret self) -> char const *

        :rtype: const char *

        """
        return _BRepMesh.Handle_BRepMesh_FastDiscret_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _BRepMesh.Handle_BRepMesh_FastDiscret_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _BRepMesh.Handle_BRepMesh_FastDiscret_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_BRepMesh_FastDiscret self)

        Memory deallocator for transient classes


        """
        return _BRepMesh.Handle_BRepMesh_FastDiscret_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_BRepMesh_FastDiscret self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_BRepMesh_FastDiscret self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepMesh.Handle_BRepMesh_FastDiscret_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_BRepMesh_FastDiscret self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_BRepMesh_FastDiscret self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepMesh.Handle_BRepMesh_FastDiscret_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_BRepMesh_FastDiscret self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _BRepMesh.Handle_BRepMesh_FastDiscret_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_BRepMesh_FastDiscret self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepMesh.Handle_BRepMesh_FastDiscret_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_BRepMesh_FastDiscret self)

        Increments the reference counter of this object


        """
        return _BRepMesh.Handle_BRepMesh_FastDiscret_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_BRepMesh_FastDiscret self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepMesh.Handle_BRepMesh_FastDiscret_DecrementRefCounter(self, *args)

Handle_BRepMesh_FastDiscret_swigregister = _BRepMesh.Handle_BRepMesh_FastDiscret_swigregister
Handle_BRepMesh_FastDiscret_swigregister(Handle_BRepMesh_FastDiscret)

def Handle_BRepMesh_FastDiscret_DownCast(thing):
    return _BRepMesh.Handle_BRepMesh_FastDiscret_DownCast(thing)
Handle_BRepMesh_FastDiscret_DownCast = _BRepMesh.Handle_BRepMesh_FastDiscret_DownCast

class BRepMesh_Classifier(object):
    """
    Auxilary class contains information about correctness of discretized 
    face and used for classification of points regarding face internals.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BRepMesh_Classifier self) -> BRepMesh_Classifier

        Constructor.


        """
        this = _BRepMesh.new_BRepMesh_Classifier(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Destroy(self, *args):
        """
        Destroy(BRepMesh_Classifier self)

        Method is called on destruction.
        Clears internal data structures.


        """
        return _BRepMesh.BRepMesh_Classifier_Destroy(self, *args)


    def Perform(self, *args):
        """
        Perform(BRepMesh_Classifier self, gp_Pnt2d thePoint) -> TopAbs_State

        Performs classification of the given point regarding to face internals.
        @param thePoint Point in parametric space to be classified.
        @return 

        :type thePoint: OCC.wrapper.gp.gp_Pnt2d
        :rtype: OCC.wrapper.TopAbs.TopAbs_State

        """
        return _BRepMesh.BRepMesh_Classifier_Perform(self, *args)


    def RegisterWire(self, *args):
        """
        RegisterWire(BRepMesh_Classifier self, NCollection_Sequence_gp_Pnt2d theWire, Standard_Real const theTolUV, Standard_Real const theUmin, Standard_Real const theUmax, Standard_Real const theVmin, Standard_Real const theVmax)

        Registers wire specified by sequence of points for 
        further classification of points.
        @param theWire Wire to be registered. Specified by sequence of points.
        @param theTolUV Tolerance to be used for calculations in parametric space.
        @param theUmin Lower U boundary of the face in parametric space.
        @param theUmax Upper U boundary of the face in parametric space.
        @param theVmin Lower V boundary of the face in parametric space.
        @param theVmax Upper V boundary of the face in parametric space.

        :type theWire: OCC.wrapper.TColgp.NCollection_Sequence_gp_Pnt2d
        :type theTolUV: float
        :type theUmin: float
        :type theUmax: float
        :type theVmin: float
        :type theVmax: float

        """
        return _BRepMesh.BRepMesh_Classifier_RegisterWire(self, *args)

    __swig_destroy__ = _BRepMesh.delete_BRepMesh_Classifier
BRepMesh_Classifier_swigregister = _BRepMesh.BRepMesh_Classifier_swigregister
BRepMesh_Classifier_swigregister(BRepMesh_Classifier)

class BRepMesh_SelectorOfDataStructureOfDelaun(object):
    """
    Describes a selector and an iterator on a 
    selector of components of a mesh.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BRepMesh_SelectorOfDataStructureOfDelaun self) -> BRepMesh_SelectorOfDataStructureOfDelaun
        __init__(BRepMesh_SelectorOfDataStructureOfDelaun self, Handle_BRepMesh_DataStructureOfDelaun theMesh) -> BRepMesh_SelectorOfDataStructureOfDelaun

        Constructor.
        Initializes selector by the mesh.

        :type theMesh: OCC.wrapper.BRepMesh.Handle_BRepMesh_DataStructureOfDelaun

        """
        this = _BRepMesh.new_BRepMesh_SelectorOfDataStructureOfDelaun(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Initialize(self, *args):
        """
        Initialize(BRepMesh_SelectorOfDataStructureOfDelaun self, Handle_BRepMesh_DataStructureOfDelaun theMesh)

        Initializes selector by the mesh.

        :type theMesh: OCC.wrapper.BRepMesh.Handle_BRepMesh_DataStructureOfDelaun

        """
        return _BRepMesh.BRepMesh_SelectorOfDataStructureOfDelaun_Initialize(self, *args)


    def NeighboursOfNode(self, *args):
        """
        NeighboursOfNode(BRepMesh_SelectorOfDataStructureOfDelaun self, Standard_Integer const theNodeIndex)

        Selects all neighboring elements of node with the given index.

        :type theNodeIndex: int

        """
        return _BRepMesh.BRepMesh_SelectorOfDataStructureOfDelaun_NeighboursOfNode(self, *args)


    def NeighboursOfLink(self, *args):
        """
        NeighboursOfLink(BRepMesh_SelectorOfDataStructureOfDelaun self, Standard_Integer const theLinkIndex)

        Selects all neighboring elements of link with the given index.

        :type theLinkIndex: int

        """
        return _BRepMesh.BRepMesh_SelectorOfDataStructureOfDelaun_NeighboursOfLink(self, *args)


    def NeighboursOfElement(self, *args):
        """
        NeighboursOfElement(BRepMesh_SelectorOfDataStructureOfDelaun self, Standard_Integer const theElementIndex)

        Selects all neighboring elements by nodes of the given element.

        :type theElementIndex: int

        """
        return _BRepMesh.BRepMesh_SelectorOfDataStructureOfDelaun_NeighboursOfElement(self, *args)


    def NeighboursByEdgeOf(self, *args):
        """
        NeighboursByEdgeOf(BRepMesh_SelectorOfDataStructureOfDelaun self, BRepMesh_Triangle theElement)

        Selects all neighboring elements by links of the given element.

        :type theElement: OCC.wrapper.BRepMesh.BRepMesh_Triangle

        """
        return _BRepMesh.BRepMesh_SelectorOfDataStructureOfDelaun_NeighboursByEdgeOf(self, *args)


    def NeighboursOf(self, *args):
        """
        NeighboursOf(BRepMesh_SelectorOfDataStructureOfDelaun self, BRepMesh_Vertex theNode)
        NeighboursOf(BRepMesh_SelectorOfDataStructureOfDelaun self, BRepMesh_Edge theLink)
        NeighboursOf(BRepMesh_SelectorOfDataStructureOfDelaun self, BRepMesh_Triangle theElement)
        NeighboursOf(BRepMesh_SelectorOfDataStructureOfDelaun self, BRepMesh_SelectorOfDataStructureOfDelaun arg2)

        Adds a level of neighbours by edge to the selector.

        :type : OCC.wrapper.BRepMesh.BRepMesh_SelectorOfDataStructureOfDelaun

        """
        return _BRepMesh.BRepMesh_SelectorOfDataStructureOfDelaun_NeighboursOf(self, *args)


    def AddNeighbours(self, *args):
        """
        AddNeighbours(BRepMesh_SelectorOfDataStructureOfDelaun self)

        Adds a level of neighbours by edge the selector.


        """
        return _BRepMesh.BRepMesh_SelectorOfDataStructureOfDelaun_AddNeighbours(self, *args)


    def Nodes(self, *args):
        """
        Returns selected nodes.

        :rtype: MapOfInteger

        """
        res = _BRepMesh.BRepMesh_SelectorOfDataStructureOfDelaun_Nodes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Links(self, *args):
        """
        Returns selected links.

        :rtype: MapOfInteger

        """
        res = _BRepMesh.BRepMesh_SelectorOfDataStructureOfDelaun_Links(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Elements(self, *args):
        """
        Returns selected elements.

        :rtype: MapOfInteger

        """
        res = _BRepMesh.BRepMesh_SelectorOfDataStructureOfDelaun_Elements(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def FrontierLinks(self, *args):
        """
        Gives the list of incices of frontier links.

        :rtype: MapOfInteger

        """
        res = _BRepMesh.BRepMesh_SelectorOfDataStructureOfDelaun_FrontierLinks(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _BRepMesh.delete_BRepMesh_SelectorOfDataStructureOfDelaun
BRepMesh_SelectorOfDataStructureOfDelaun_swigregister = _BRepMesh.BRepMesh_SelectorOfDataStructureOfDelaun_swigregister
BRepMesh_SelectorOfDataStructureOfDelaun_swigregister(BRepMesh_SelectorOfDataStructureOfDelaun)

class BRepMesh_GeomTool(object):
    """
    Tool class accumulating common geometrical functions as well as 
    functionality using shape geometry to produce data necessary for 
    tessellation.
    General aim is to calculate discretization points for the given
    curve or iso curve of surface according to the specified parameters.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    NoIntersection = _BRepMesh.BRepMesh_GeomTool_NoIntersection
    Cross = _BRepMesh.BRepMesh_GeomTool_Cross
    EndPointTouch = _BRepMesh.BRepMesh_GeomTool_EndPointTouch
    PointOnSegment = _BRepMesh.BRepMesh_GeomTool_PointOnSegment
    Glued = _BRepMesh.BRepMesh_GeomTool_Glued
    Same = _BRepMesh.BRepMesh_GeomTool_Same

    def __init__(self, *args):
        """
        __init__(BRepMesh_GeomTool self, BRepAdaptor_Curve theCurve, Standard_Real const theFirstParam, Standard_Real const theLastParam, Standard_Real const theLinDeflection, Standard_Real const theAngDeflection, Standard_Integer const theMinPointsNb=2, Standard_Real const theMinSize) -> BRepMesh_GeomTool
        __init__(BRepMesh_GeomTool self, Handle_BRepAdaptor_HSurface theSurface, GeomAbs_IsoType const theIsoType, Standard_Real const theParamIso, Standard_Real const theFirstParam, Standard_Real const theLastParam, Standard_Real const theLinDeflection, Standard_Real const theAngDeflection, Standard_Integer const theMinPointsNb=2, Standard_Real const theMinSize) -> BRepMesh_GeomTool

        Constructor.
        Initiates discretization of geometric curve corresponding 
        to iso curve of the given surface.
        @param theSurface surface the iso curve to be taken from.
        @param theIsoType type of iso curve to be used, U or V.
        @param theParamIso parameter on the surface specifying the iso curve.
        @param theFirstParam first parameter of the curve.
        @param theLastParam last parameter of the curve.
        @param theLinDeflection linear deflection.
        @param theAngDeflection angular deflection.
        @param theMinPointsNb minimum nuber of points to be produced.

        :type theSurface: OCC.wrapper.BRepAdaptor.Handle_BRepAdaptor_HSurface
        :type theIsoType: OCC.wrapper.GeomAbs.GeomAbs_IsoType
        :type theParamIso: float
        :type theFirstParam: float
        :type theLastParam: float
        :type theLinDeflection: float
        :type theAngDeflection: float
        :type theMinPointsNb: int
        :type theMinSize: float

        """
        this = _BRepMesh.new_BRepMesh_GeomTool(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def AddPoint(self, *args):
        """
        AddPoint(BRepMesh_GeomTool self, gp_Pnt thePoint, Standard_Real const theParam, Standard_Boolean const theIsReplace) -> Standard_Integer

        Adds point to already calculated points (or replaces existing).
        @param thePoint point to be added.
        @param theParam parameter on the curve corresponding to the given point.
        @param theIsReplace if TRUE replaces existing point lying within 
        parameteric tolerance of the given point.
        @return index of new added point or found with parametric tolerance

        :type thePoint: OCC.wrapper.gp.gp_Pnt
        :type theParam: float
        :type theIsReplace: bool
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepMesh.BRepMesh_GeomTool_AddPoint(self, *args)


    def NbPoints(self, *args):
        """
        NbPoints(BRepMesh_GeomTool self) -> Standard_Integer

        Returns number of discretization points.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepMesh.BRepMesh_GeomTool_NbPoints(self, *args)


    def Value(self, *args):
        """
        Value(BRepMesh_GeomTool self, Standard_Integer const theIndex, Standard_Real const theIsoParam, gp_Pnt thePoint, gp_Pnt2d theUV) -> Standard_Boolean
        Value(BRepMesh_GeomTool self, Standard_Integer const theIndex, gp_Pnt thePoint) -> Standard_Boolean

        Gets parameters of discretization point with the given index.
        @param theIndex index of discretization point.
        @param theParam[out] parameter of the point on the curve.
        @param thePoint[out] discretization point.
        @return TRUE on success, FALSE elsewhere.

        :type theIndex: int
        :type theParam: float
        :type thePoint: OCC.wrapper.gp.gp_Pnt
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepMesh.BRepMesh_GeomTool_Value(self, *args)


    def Normal(*args):
        """
        Normal(Handle_BRepAdaptor_HSurface theSurface, Standard_Real const theParamU, Standard_Real const theParamV, gp_Pnt thePoint, gp_Dir theNormal) -> Standard_Boolean

        Computes normal to the given surface at the specified
        position in parametric space.
        @param theSurface surface the normal should be found for.
        @param theParamU U parameter in parametric space of the surface.
        @param theParamV V parameter in parametric space of the surface.
        @param[out] thePoint 3d point corresponding to the given parameters.
        @param[out] theNormal normal vector at the point specified by the parameters.
        @return FALSE if the normal can not be computed, TRUE elsewhere.

        :type theSurface: OCC.wrapper.BRepAdaptor.Handle_BRepAdaptor_HSurface
        :type theParamU: float
        :type theParamV: float
        :type thePoint: OCC.wrapper.gp.gp_Pnt
        :type theNormal: OCC.wrapper.gp.gp_Dir
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepMesh.BRepMesh_GeomTool_Normal(*args)

    Normal = staticmethod(Normal)

    def IntLinLin(*args):
        """
        IntLinLin(gp_XY theStartPnt1, gp_XY theEndPnt1, gp_XY theStartPnt2, gp_XY theEndPnt2, gp_XY theIntPnt, Standard_Real (&)[2] theParamOnSegment) -> BRepMesh_GeomTool::IntFlag

        Checks intersection between two lines defined by two points.
        @param theStartPnt1 start point of first line.
        @param theEndPnt1 end point of first line.
        @param theStartPnt2 start point of second line.
        @param theEndPnt2 end point of second line.
        @param[out] theIntPnt point of intersection.
        @param[out] theParamOnSegment parameters of intersection point 
        corresponding to first and second segment.
        @return status of intersection check.

        :type theStartPnt1: OCC.wrapper.gp.gp_XY
        :type theEndPnt1: OCC.wrapper.gp.gp_XY
        :type theStartPnt2: OCC.wrapper.gp.gp_XY
        :type theEndPnt2: OCC.wrapper.gp.gp_XY
        :type theIntPnt: OCC.wrapper.gp.gp_XY
        :type theParamOnSegment: OCC.wrapper.Standard.Standard_Real (&)[2]
        :rtype: IntFlag

        """
        return _BRepMesh.BRepMesh_GeomTool_IntLinLin(*args)

    IntLinLin = staticmethod(IntLinLin)

    def IntSegSeg(*args):
        """
        IntSegSeg(gp_XY theStartPnt1, gp_XY theEndPnt1, gp_XY theStartPnt2, gp_XY theEndPnt2, Standard_Boolean const isConsiderEndPointTouch, Standard_Boolean const isConsiderPointOnSegment, gp_Pnt2d theIntPnt) -> BRepMesh_GeomTool::IntFlag

        Checks intersection between the two segments. 
        Checks that intersection point lies within ranges of both segments.
        @param theStartPnt1 start point of first segment.
        @param theEndPnt1 end point of first segment.
        @param theStartPnt2 start point of second segment.
        @param theEndPnt2 end point of second segment.
        @param isConsiderEndPointTouch if TRUE EndPointTouch status will be
        returned in case if segments are touching by end points, if FALSE
        returns NoIntersection flag.
        @param isConsiderPointOnSegment if TRUE PointOnSegment status will be
        returned in case if end point of one segment lies onto another one, 
        if FALSE returns NoIntersection flag.
        @param[out] theIntPnt point of intersection.
        @return status of intersection check.

        :type theStartPnt1: OCC.wrapper.gp.gp_XY
        :type theEndPnt1: OCC.wrapper.gp.gp_XY
        :type theStartPnt2: OCC.wrapper.gp.gp_XY
        :type theEndPnt2: OCC.wrapper.gp.gp_XY
        :type isConsiderEndPointTouch: bool
        :type isConsiderPointOnSegment: bool
        :type theIntPnt: OCC.wrapper.gp.gp_Pnt2d
        :rtype: IntFlag

        """
        return _BRepMesh.BRepMesh_GeomTool_IntSegSeg(*args)

    IntSegSeg = staticmethod(IntSegSeg)
    __swig_destroy__ = _BRepMesh.delete_BRepMesh_GeomTool
BRepMesh_GeomTool_swigregister = _BRepMesh.BRepMesh_GeomTool_swigregister
BRepMesh_GeomTool_swigregister(BRepMesh_GeomTool)

def BRepMesh_GeomTool_Normal(*args):
    """
    BRepMesh_GeomTool_Normal(Handle_BRepAdaptor_HSurface theSurface, Standard_Real const theParamU, Standard_Real const theParamV, gp_Pnt thePoint, gp_Dir theNormal) -> Standard_Boolean

    Computes normal to the given surface at the specified
    position in parametric space.
    @param theSurface surface the normal should be found for.
    @param theParamU U parameter in parametric space of the surface.
    @param theParamV V parameter in parametric space of the surface.
    @param[out] thePoint 3d point corresponding to the given parameters.
    @param[out] theNormal normal vector at the point specified by the parameters.
    @return FALSE if the normal can not be computed, TRUE elsewhere.

    :type theSurface: OCC.wrapper.BRepAdaptor.Handle_BRepAdaptor_HSurface
    :type theParamU: float
    :type theParamV: float
    :type thePoint: OCC.wrapper.gp.gp_Pnt
    :type theNormal: OCC.wrapper.gp.gp_Dir
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _BRepMesh.BRepMesh_GeomTool_Normal(*args)

def BRepMesh_GeomTool_IntLinLin(*args):
    """
    BRepMesh_GeomTool_IntLinLin(gp_XY theStartPnt1, gp_XY theEndPnt1, gp_XY theStartPnt2, gp_XY theEndPnt2, gp_XY theIntPnt, Standard_Real (&)[2] theParamOnSegment) -> BRepMesh_GeomTool::IntFlag

    Checks intersection between two lines defined by two points.
    @param theStartPnt1 start point of first line.
    @param theEndPnt1 end point of first line.
    @param theStartPnt2 start point of second line.
    @param theEndPnt2 end point of second line.
    @param[out] theIntPnt point of intersection.
    @param[out] theParamOnSegment parameters of intersection point 
    corresponding to first and second segment.
    @return status of intersection check.

    :type theStartPnt1: OCC.wrapper.gp.gp_XY
    :type theEndPnt1: OCC.wrapper.gp.gp_XY
    :type theStartPnt2: OCC.wrapper.gp.gp_XY
    :type theEndPnt2: OCC.wrapper.gp.gp_XY
    :type theIntPnt: OCC.wrapper.gp.gp_XY
    :type theParamOnSegment: OCC.wrapper.Standard.Standard_Real (&)[2]
    :rtype: IntFlag

    """
    return _BRepMesh.BRepMesh_GeomTool_IntLinLin(*args)

def BRepMesh_GeomTool_IntSegSeg(*args):
    """
    BRepMesh_GeomTool_IntSegSeg(gp_XY theStartPnt1, gp_XY theEndPnt1, gp_XY theStartPnt2, gp_XY theEndPnt2, Standard_Boolean const isConsiderEndPointTouch, Standard_Boolean const isConsiderPointOnSegment, gp_Pnt2d theIntPnt) -> BRepMesh_GeomTool::IntFlag

    Checks intersection between the two segments. 
    Checks that intersection point lies within ranges of both segments.
    @param theStartPnt1 start point of first segment.
    @param theEndPnt1 end point of first segment.
    @param theStartPnt2 start point of second segment.
    @param theEndPnt2 end point of second segment.
    @param isConsiderEndPointTouch if TRUE EndPointTouch status will be
    returned in case if segments are touching by end points, if FALSE
    returns NoIntersection flag.
    @param isConsiderPointOnSegment if TRUE PointOnSegment status will be
    returned in case if end point of one segment lies onto another one, 
    if FALSE returns NoIntersection flag.
    @param[out] theIntPnt point of intersection.
    @return status of intersection check.

    :type theStartPnt1: OCC.wrapper.gp.gp_XY
    :type theEndPnt1: OCC.wrapper.gp.gp_XY
    :type theStartPnt2: OCC.wrapper.gp.gp_XY
    :type theEndPnt2: OCC.wrapper.gp.gp_XY
    :type isConsiderEndPointTouch: bool
    :type isConsiderPointOnSegment: bool
    :type theIntPnt: OCC.wrapper.gp.gp_Pnt2d
    :rtype: IntFlag

    """
    return _BRepMesh.BRepMesh_GeomTool_IntSegSeg(*args)

class Handle_BRepMesh_DiscretRoot(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_BRepMesh_DiscretRoot self)

        Nullify the handle


        """
        return _BRepMesh.Handle_BRepMesh_DiscretRoot_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_BRepMesh_DiscretRoot self) -> bool

        Check for being null

        :rtype: bool

        """
        return _BRepMesh.Handle_BRepMesh_DiscretRoot_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_BRepMesh_DiscretRoot self, BRepMesh_DiscretRoot thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _BRepMesh.Handle_BRepMesh_DiscretRoot_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_BRepMesh_DiscretRoot self, Handle_BRepMesh_DiscretRoot theHandle) -> Handle_BRepMesh_DiscretRoot
        assign(Handle_BRepMesh_DiscretRoot self, BRepMesh_DiscretRoot thePtr) -> Handle_BRepMesh_DiscretRoot
        assign(Handle_BRepMesh_DiscretRoot self, Handle_BRepMesh_DiscretRoot theHandle) -> Handle_BRepMesh_DiscretRoot

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _BRepMesh.Handle_BRepMesh_DiscretRoot_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_BRepMesh_DiscretRoot self) -> BRepMesh_DiscretRoot

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _BRepMesh.Handle_BRepMesh_DiscretRoot_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_BRepMesh_DiscretRoot self) -> BRepMesh_DiscretRoot

        Member access operator (note non-const)

        :rtype: T *

        """
        return _BRepMesh.Handle_BRepMesh_DiscretRoot___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_BRepMesh_DiscretRoot self) -> BRepMesh_DiscretRoot

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _BRepMesh.Handle_BRepMesh_DiscretRoot___ref__(self, *args)


    def __hash__(self):
        return _BRepMesh.Handle_BRepMesh_DiscretRoot___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _BRepMesh.Handle_BRepMesh_DiscretRoot___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _BRepMesh.new_Handle_BRepMesh_DiscretRoot(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_BRepMesh.Handle_BRepMesh_DiscretRoot_DownCast)
    __swig_destroy__ = _BRepMesh.delete_Handle_BRepMesh_DiscretRoot

    def SetShape(self, *args):
        """
        SetShape(Handle_BRepMesh_DiscretRoot self, TopoDS_Shape theShape)

        Set the shape to triangulate.

        :type theShape: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _BRepMesh.Handle_BRepMesh_DiscretRoot_SetShape(self, *args)


    def Shape(self, *args):
        """
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _BRepMesh.Handle_BRepMesh_DiscretRoot_Shape(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def IsDone(self, *args):
        """
        IsDone(Handle_BRepMesh_DiscretRoot self) -> Standard_Boolean

        Returns true if triangualtion was performed and has success.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepMesh.Handle_BRepMesh_DiscretRoot_IsDone(self, *args)


    def Perform(self, *args):
        """
        Perform(Handle_BRepMesh_DiscretRoot self)

        Compute triangulation for set shape.


        """
        return _BRepMesh.Handle_BRepMesh_DiscretRoot_Perform(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_BRepMesh_DiscretRoot self) -> char const *

        :rtype: const char *

        """
        return _BRepMesh.Handle_BRepMesh_DiscretRoot_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _BRepMesh.Handle_BRepMesh_DiscretRoot_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _BRepMesh.Handle_BRepMesh_DiscretRoot_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_BRepMesh_DiscretRoot self)

        Memory deallocator for transient classes


        """
        return _BRepMesh.Handle_BRepMesh_DiscretRoot_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_BRepMesh_DiscretRoot self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_BRepMesh_DiscretRoot self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepMesh.Handle_BRepMesh_DiscretRoot_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_BRepMesh_DiscretRoot self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_BRepMesh_DiscretRoot self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepMesh.Handle_BRepMesh_DiscretRoot_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_BRepMesh_DiscretRoot self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _BRepMesh.Handle_BRepMesh_DiscretRoot_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_BRepMesh_DiscretRoot self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepMesh.Handle_BRepMesh_DiscretRoot_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_BRepMesh_DiscretRoot self)

        Increments the reference counter of this object


        """
        return _BRepMesh.Handle_BRepMesh_DiscretRoot_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_BRepMesh_DiscretRoot self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepMesh.Handle_BRepMesh_DiscretRoot_DecrementRefCounter(self, *args)

Handle_BRepMesh_DiscretRoot_swigregister = _BRepMesh.Handle_BRepMesh_DiscretRoot_swigregister
Handle_BRepMesh_DiscretRoot_swigregister(Handle_BRepMesh_DiscretRoot)

def Handle_BRepMesh_DiscretRoot_DownCast(thing):
    return _BRepMesh.Handle_BRepMesh_DiscretRoot_DownCast(thing)
Handle_BRepMesh_DiscretRoot_DownCast = _BRepMesh.Handle_BRepMesh_DiscretRoot_DownCast

class BRepMesh_EdgeTessellator(BRepMesh_IEdgeTool):
    """
    Auxiliary class implements functionality producing tessellated
    representation of an edge based on edge geometry.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_BRepMesh_EdgeTessellator
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_BRepMesh_EdgeTessellator(self) 
            return h


    def NbPoints(self, *args):
        """
        NbPoints(BRepMesh_EdgeTessellator self) -> Standard_Integer

        Returns number of dicretization points.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepMesh.BRepMesh_EdgeTessellator_NbPoints(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _BRepMesh.BRepMesh_EdgeTessellator_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _BRepMesh.BRepMesh_EdgeTessellator_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _BRepMesh.BRepMesh_EdgeTessellator_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _BRepMesh.delete_BRepMesh_EdgeTessellator
BRepMesh_EdgeTessellator_swigregister = _BRepMesh.BRepMesh_EdgeTessellator_swigregister
BRepMesh_EdgeTessellator_swigregister(BRepMesh_EdgeTessellator)

def BRepMesh_EdgeTessellator_get_type_name(*args):
    """
    BRepMesh_EdgeTessellator_get_type_name() -> char const *

    :rtype: const char *

    """
    return _BRepMesh.BRepMesh_EdgeTessellator_get_type_name(*args)

def BRepMesh_EdgeTessellator_get_type_descriptor(*args):
    """
    BRepMesh_EdgeTessellator_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _BRepMesh.BRepMesh_EdgeTessellator_get_type_descriptor(*args)

class Handle_BRepMesh_EdgeTessellator(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_BRepMesh_EdgeTessellator self)

        Nullify the handle


        """
        return _BRepMesh.Handle_BRepMesh_EdgeTessellator_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_BRepMesh_EdgeTessellator self) -> bool

        Check for being null

        :rtype: bool

        """
        return _BRepMesh.Handle_BRepMesh_EdgeTessellator_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_BRepMesh_EdgeTessellator self, BRepMesh_EdgeTessellator thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _BRepMesh.Handle_BRepMesh_EdgeTessellator_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_BRepMesh_EdgeTessellator self, Handle_BRepMesh_EdgeTessellator theHandle) -> Handle_BRepMesh_EdgeTessellator
        assign(Handle_BRepMesh_EdgeTessellator self, BRepMesh_EdgeTessellator thePtr) -> Handle_BRepMesh_EdgeTessellator
        assign(Handle_BRepMesh_EdgeTessellator self, Handle_BRepMesh_EdgeTessellator theHandle) -> Handle_BRepMesh_EdgeTessellator

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _BRepMesh.Handle_BRepMesh_EdgeTessellator_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_BRepMesh_EdgeTessellator self) -> BRepMesh_EdgeTessellator

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _BRepMesh.Handle_BRepMesh_EdgeTessellator_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_BRepMesh_EdgeTessellator self) -> BRepMesh_EdgeTessellator

        Member access operator (note non-const)

        :rtype: T *

        """
        return _BRepMesh.Handle_BRepMesh_EdgeTessellator___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_BRepMesh_EdgeTessellator self) -> BRepMesh_EdgeTessellator

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _BRepMesh.Handle_BRepMesh_EdgeTessellator___ref__(self, *args)


    def __hash__(self):
        return _BRepMesh.Handle_BRepMesh_EdgeTessellator___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _BRepMesh.Handle_BRepMesh_EdgeTessellator___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _BRepMesh.new_Handle_BRepMesh_EdgeTessellator(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_BRepMesh.Handle_BRepMesh_EdgeTessellator_DownCast)
    __swig_destroy__ = _BRepMesh.delete_Handle_BRepMesh_EdgeTessellator

    def NbPoints(self, *args):
        """
        NbPoints(Handle_BRepMesh_EdgeTessellator self) -> Standard_Integer

        Returns number of dicretization points.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepMesh.Handle_BRepMesh_EdgeTessellator_NbPoints(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_BRepMesh_EdgeTessellator self) -> char const *

        :rtype: const char *

        """
        return _BRepMesh.Handle_BRepMesh_EdgeTessellator_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _BRepMesh.Handle_BRepMesh_EdgeTessellator_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _BRepMesh.Handle_BRepMesh_EdgeTessellator_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Value(self, *args):
        """
        Value(Handle_BRepMesh_EdgeTessellator self, Standard_Integer const theIndex, gp_Pnt thePoint, gp_Pnt2d theUV) -> Standard_Boolean

        Returns parameters of solution with the given index.
        @param theIndex index of tessellation point.
        @param theParameter parameters on PCurve corresponded to the solution.
        @param thePoint tessellation point.
        @param theUV coordinates of tessellation point in parametric space of face.
        @return True in case of valid result, false elewhere.

        :type theIndex: int
        :type theParameter: float
        :type thePoint: OCC.wrapper.gp.gp_Pnt
        :type theUV: OCC.wrapper.gp.gp_Pnt2d
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepMesh.Handle_BRepMesh_EdgeTessellator_Value(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_BRepMesh_EdgeTessellator self)

        Memory deallocator for transient classes


        """
        return _BRepMesh.Handle_BRepMesh_EdgeTessellator_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_BRepMesh_EdgeTessellator self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_BRepMesh_EdgeTessellator self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepMesh.Handle_BRepMesh_EdgeTessellator_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_BRepMesh_EdgeTessellator self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_BRepMesh_EdgeTessellator self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepMesh.Handle_BRepMesh_EdgeTessellator_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_BRepMesh_EdgeTessellator self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _BRepMesh.Handle_BRepMesh_EdgeTessellator_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_BRepMesh_EdgeTessellator self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepMesh.Handle_BRepMesh_EdgeTessellator_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_BRepMesh_EdgeTessellator self)

        Increments the reference counter of this object


        """
        return _BRepMesh.Handle_BRepMesh_EdgeTessellator_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_BRepMesh_EdgeTessellator self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepMesh.Handle_BRepMesh_EdgeTessellator_DecrementRefCounter(self, *args)

Handle_BRepMesh_EdgeTessellator_swigregister = _BRepMesh.Handle_BRepMesh_EdgeTessellator_swigregister
Handle_BRepMesh_EdgeTessellator_swigregister(Handle_BRepMesh_EdgeTessellator)

def Handle_BRepMesh_EdgeTessellator_DownCast(thing):
    return _BRepMesh.Handle_BRepMesh_EdgeTessellator_DownCast(thing)
Handle_BRepMesh_EdgeTessellator_DownCast = _BRepMesh.Handle_BRepMesh_EdgeTessellator_DownCast

class BRepMesh_VertexTool(object):
    """
    Describes data structure intended to keep mesh nodes 
    defined in UV space and implements functionality 
    providing their uniqueness regarding thir position.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BRepMesh_VertexTool self, Handle_NCollection_IncAllocator theAllocator) -> BRepMesh_VertexTool

        Constructor.
        @param theAllocator memory allocator to be used by internal collections.

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_IncAllocator

        """
        this = _BRepMesh.new_BRepMesh_VertexTool(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def SetCellSize(self, *args):
        """
        SetCellSize(BRepMesh_VertexTool self, Standard_Real const theSize)
        SetCellSize(BRepMesh_VertexTool self, Standard_Real const theSizeX, Standard_Real const theSizeY)

        Sets new size of cell for cellfilter.
        @param theSizeX size for X dimension.
        @param theSizeY size for Y dimension.

        :type theSizeX: float
        :type theSizeY: float

        """
        return _BRepMesh.BRepMesh_VertexTool_SetCellSize(self, *args)


    def SetTolerance(self, *args):
        """
        SetTolerance(BRepMesh_VertexTool self, Standard_Real const theTolerance)
        SetTolerance(BRepMesh_VertexTool self, Standard_Real const theToleranceX, Standard_Real const theToleranceY)

        Sets the tolerance to be used for identification of 
        coincident vertices.
        @param theToleranceX tolerance for X dimension.
        @param theToleranceY tolerance for Y dimension.

        :type theToleranceX: float
        :type theToleranceY: float

        """
        return _BRepMesh.BRepMesh_VertexTool_SetTolerance(self, *args)


    def GetTolerance(self, *args):
        """
        GetTolerance(BRepMesh_VertexTool self)

        Gets the tolerance to be used for identification of 
        coincident vertices.
        @param theToleranceX tolerance for X dimension.
        @param theToleranceY tolerance for Y dimension.

        :type theToleranceX: float
        :type theToleranceY: float

        """
        return _BRepMesh.BRepMesh_VertexTool_GetTolerance(self, *args)


    def Add(self, *args):
        """
        Add(BRepMesh_VertexTool self, BRepMesh_Vertex theVertex, Standard_Boolean const isForceAdd) -> Standard_Integer

        Adds vertex with empty data to the tool.
        @param theVertex node to be added to the mesh.
        @param isForceAdd adds the given node to structure without 
        checking on coincidence with other nodes.
        @return index of the node in the structure.

        :type theVertex: OCC.wrapper.BRepMesh.BRepMesh_Vertex
        :type isForceAdd: bool
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepMesh.BRepMesh_VertexTool_Add(self, *args)


    def Delete(self, *args):
        """
        Delete(BRepMesh_VertexTool self, Standard_Integer const theIndex)

        Deletes vertex with the given index from the tool.

        :type theIndex: int

        """
        return _BRepMesh.BRepMesh_VertexTool_Delete(self, *args)


    def Vertices(self, *args):
        """
        Returns set of mesh vertices.

        :rtype: HVectorOfVertex

        """
        res = _BRepMesh.BRepMesh_VertexTool_Vertices(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeVertices(self, *args):
        """
        ChangeVertices(BRepMesh_VertexTool self) -> BRepMesh::HVectorOfVertex &

        Returns set of mesh vertices.

        :rtype: HVectorOfVertex

        """
        return _BRepMesh.BRepMesh_VertexTool_ChangeVertices(self, *args)


    def FindKey(self, *args):
        """
        Returns vertex by the given index.

        :type theIndex: int
        :rtype: OCC.wrapper.BRepMesh.BRepMesh_Vertex

        """
        res = _BRepMesh.BRepMesh_VertexTool_FindKey(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def FindIndex(self, *args):
        """
        FindIndex(BRepMesh_VertexTool self, BRepMesh_Vertex theVertex) -> Standard_Integer

        Returns index of the given vertex.

        :type theVertex: OCC.wrapper.BRepMesh.BRepMesh_Vertex
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepMesh.BRepMesh_VertexTool_FindIndex(self, *args)


    def Extent(self, *args):
        """
        Extent(BRepMesh_VertexTool self) -> Standard_Integer

        Returns a number of vertices.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepMesh.BRepMesh_VertexTool_Extent(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(BRepMesh_VertexTool self) -> Standard_Boolean

        Returns True when the map contains no keys. <br>

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepMesh.BRepMesh_VertexTool_IsEmpty(self, *args)


    def Substitute(self, *args):
        """
        Substitute(BRepMesh_VertexTool self, Standard_Integer const theIndex, BRepMesh_Vertex theVertex)

        Substitutes vertex with the given by the given vertex with attributes.
        @param theIndex index of vertex to be substituted.
        @param theVertex replacement vertex.

        :type theIndex: int
        :type theVertex: OCC.wrapper.BRepMesh.BRepMesh_Vertex

        """
        return _BRepMesh.BRepMesh_VertexTool_Substitute(self, *args)


    def RemoveLast(self, *args):
        """
        RemoveLast(BRepMesh_VertexTool self)

        Remove last node from the structure.


        """
        return _BRepMesh.BRepMesh_VertexTool_RemoveLast(self, *args)


    def GetListOfDelNodes(self, *args):
        """
        Returns the list with indexes of vertices that have movability attribute
        equal to BRepMesh_Deleted and can be replaced with another node.

        :rtype: ListOfInteger

        """
        res = _BRepMesh.BRepMesh_VertexTool_GetListOfDelNodes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Statistics(self, *args):
        """
        Statistics(BRepMesh_VertexTool self, Standard_OStream & theStream)

        Prints statistics.

        :type theStream: OCC.wrapper.Standard.Standard_OStream

        """
        return _BRepMesh.BRepMesh_VertexTool_Statistics(self, *args)

    __swig_destroy__ = _BRepMesh.delete_BRepMesh_VertexTool
BRepMesh_VertexTool_swigregister = _BRepMesh.BRepMesh_VertexTool_swigregister
BRepMesh_VertexTool_swigregister(BRepMesh_VertexTool)

class BRepMesh_VertexInspector(NCollection_CellFilter_InspectorXY):
    """Class intended for fast searching of the coincidence points."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BRepMesh_VertexInspector self, Handle_NCollection_IncAllocator theAllocator) -> BRepMesh_VertexInspector

        Constructor.
        @param theAllocator memory allocator to be used by internal collections.

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_IncAllocator

        """
        this = _BRepMesh.new_BRepMesh_VertexInspector(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Add(self, *args):
        """
        Add(BRepMesh_VertexInspector self, BRepMesh_Vertex theVertex) -> Standard_Integer

        Registers the given vertex.
        @param theVertex vertex to be registered.

        :type theVertex: OCC.wrapper.BRepMesh.BRepMesh_Vertex
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepMesh.BRepMesh_VertexInspector_Add(self, *args)


    def SetTolerance(self, *args):
        """
        SetTolerance(BRepMesh_VertexInspector self, Standard_Real const theTolerance)
        SetTolerance(BRepMesh_VertexInspector self, Standard_Real const theToleranceX, Standard_Real const theToleranceY)

        Sets the tolerance to be used for identification of 
        coincident vertices.
        @param theToleranceX tolerance for X dimension.
        @param theToleranceY tolerance for Y dimension.

        :type theToleranceX: float
        :type theToleranceY: float

        """
        return _BRepMesh.BRepMesh_VertexInspector_SetTolerance(self, *args)


    def Clear(self, *args):
        """
        Clear(BRepMesh_VertexInspector self)

        Clear inspector's internal data structures.


        """
        return _BRepMesh.BRepMesh_VertexInspector_Clear(self, *args)


    def Delete(self, *args):
        """
        Delete(BRepMesh_VertexInspector self, Standard_Integer const theIndex)

        Deletes vertex with the given index.
        @param theIndex index of vertex to be removed.

        :type theIndex: int

        """
        return _BRepMesh.BRepMesh_VertexInspector_Delete(self, *args)


    def NbVertices(self, *args):
        """
        NbVertices(BRepMesh_VertexInspector self) -> Standard_Integer

        Returns number of registered vertices.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepMesh.BRepMesh_VertexInspector_NbVertices(self, *args)


    def GetVertex(self, *args):
        """
        GetVertex(BRepMesh_VertexInspector self, Standard_Integer theIndex) -> BRepMesh_Vertex

        Returns vertex with the given index.

        :type theIndex: int
        :rtype: OCC.wrapper.BRepMesh.BRepMesh_Vertex

        """
        return _BRepMesh.BRepMesh_VertexInspector_GetVertex(self, *args)


    def SetPoint(self, *args):
        """
        SetPoint(BRepMesh_VertexInspector self, gp_XY thePoint)

        Set reference point to be checked.

        :type thePoint: OCC.wrapper.gp.gp_XY

        """
        return _BRepMesh.BRepMesh_VertexInspector_SetPoint(self, *args)


    def GetCoincidentPoint(self, *args):
        """
        GetCoincidentPoint(BRepMesh_VertexInspector self) -> Standard_Integer

        Returns index of point coinciding with regerence one.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepMesh.BRepMesh_VertexInspector_GetCoincidentPoint(self, *args)


    def GetListOfDelPoints(self, *args):
        """
        Returns list with indexes of vertices that have movability attribute 
        equal to BRepMesh_Deleted and can be replaced with another node.

        :rtype: ListOfInteger

        """
        res = _BRepMesh.BRepMesh_VertexInspector_GetListOfDelPoints(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Vertices(self, *args):
        """
        Returns set of mesh vertices.

        :rtype: HVectorOfVertex

        """
        res = _BRepMesh.BRepMesh_VertexInspector_Vertices(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeVertices(self, *args):
        """
        ChangeVertices(BRepMesh_VertexInspector self) -> BRepMesh::HVectorOfVertex &

        Returns set of mesh vertices for modification.

        :rtype: HVectorOfVertex

        """
        return _BRepMesh.BRepMesh_VertexInspector_ChangeVertices(self, *args)


    def Inspect(self, *args):
        """
        Inspect(BRepMesh_VertexInspector self, Standard_Integer const theTargetIndex) -> NCollection_CellFilter_Action

        Performs inspection of a point with the given index.
        @param theTargetIndex index of a circle to be checked.
        @return status of the check.

        :type theTargetIndex: int
        :rtype: OCC.wrapper.NCollection.NCollection_CellFilter_Action

        """
        return _BRepMesh.BRepMesh_VertexInspector_Inspect(self, *args)


    def IsEqual(*args):
        """
        IsEqual(Standard_Integer const theIndex, Standard_Integer const theTargetIndex) -> Standard_Boolean

        Checks indices for equlity.

        :type theIndex: int
        :type theTargetIndex: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepMesh.BRepMesh_VertexInspector_IsEqual(*args)

    IsEqual = staticmethod(IsEqual)
    __swig_destroy__ = _BRepMesh.delete_BRepMesh_VertexInspector
BRepMesh_VertexInspector_swigregister = _BRepMesh.BRepMesh_VertexInspector_swigregister
BRepMesh_VertexInspector_swigregister(BRepMesh_VertexInspector)

def BRepMesh_VertexInspector_IsEqual(*args):
    """
    BRepMesh_VertexInspector_IsEqual(Standard_Integer const theIndex, Standard_Integer const theTargetIndex) -> Standard_Boolean

    Checks indices for equlity.

    :type theIndex: int
    :type theTargetIndex: int
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _BRepMesh.BRepMesh_VertexInspector_IsEqual(*args)




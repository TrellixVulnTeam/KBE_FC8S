# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_CSLib')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_CSLib')
    _CSLib = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_CSLib', [dirname(__file__)])
        except ImportError:
            import _CSLib
            return _CSLib
        try:
            _mod = imp.load_module('_CSLib', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _CSLib = swig_import_helper()
    del swig_import_helper
else:
    import _CSLib
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


class SwigPyIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _CSLib.delete_SwigPyIterator

    def value(self):
        return _CSLib.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _CSLib.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _CSLib.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _CSLib.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _CSLib.SwigPyIterator_equal(self, x)

    def copy(self):
        return _CSLib.SwigPyIterator_copy(self)

    def next(self):
        return _CSLib.SwigPyIterator_next(self)

    def __next__(self):
        return _CSLib.SwigPyIterator___next__(self)

    def previous(self):
        return _CSLib.SwigPyIterator_previous(self)

    def advance(self, n):
        return _CSLib.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _CSLib.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _CSLib.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _CSLib.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _CSLib.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _CSLib.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _CSLib.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self
SwigPyIterator_swigregister = _CSLib.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

class NCollection_CellFilter_InspectorXYZ(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _CSLib.NCollection_CellFilter_InspectorXYZ_Dimension
    Coord = staticmethod(_CSLib.NCollection_CellFilter_InspectorXYZ_Coord)

    def Shift(self, thePnt, theTol):
        return _CSLib.NCollection_CellFilter_InspectorXYZ_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _CSLib.new_NCollection_CellFilter_InspectorXYZ()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _CSLib.delete_NCollection_CellFilter_InspectorXYZ
NCollection_CellFilter_InspectorXYZ_swigregister = _CSLib.NCollection_CellFilter_InspectorXYZ_swigregister
NCollection_CellFilter_InspectorXYZ_swigregister(NCollection_CellFilter_InspectorXYZ)

def NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt):
    return _CSLib.NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt)
NCollection_CellFilter_InspectorXYZ_Coord = _CSLib.NCollection_CellFilter_InspectorXYZ_Coord

class NCollection_CellFilter_InspectorXY(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _CSLib.NCollection_CellFilter_InspectorXY_Dimension
    Coord = staticmethod(_CSLib.NCollection_CellFilter_InspectorXY_Coord)

    def Shift(self, thePnt, theTol):
        return _CSLib.NCollection_CellFilter_InspectorXY_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _CSLib.new_NCollection_CellFilter_InspectorXY()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _CSLib.delete_NCollection_CellFilter_InspectorXY
NCollection_CellFilter_InspectorXY_swigregister = _CSLib.NCollection_CellFilter_InspectorXY_swigregister
NCollection_CellFilter_InspectorXY_swigregister(NCollection_CellFilter_InspectorXY)

def NCollection_CellFilter_InspectorXY_Coord(i, thePnt):
    return _CSLib.NCollection_CellFilter_InspectorXY_Coord(i, thePnt)
NCollection_CellFilter_InspectorXY_Coord = _CSLib.NCollection_CellFilter_InspectorXY_Coord


def ptr_to_number(item):
    return _CSLib.ptr_to_number(item)
ptr_to_number = _CSLib.ptr_to_number

def HashCode(*args):
    return _CSLib.HashCode(*args)
HashCode = _CSLib.HashCode

def ptr_equal(a, b):
    return _CSLib.ptr_equal(a, b)
ptr_equal = _CSLib.ptr_equal
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import gp
else:
    import gp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColStd
else:
    import TColStd
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TCollection
else:
    import TCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Standard
else:
    import Standard
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import NCollection
else:
    import NCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColgp
else:
    import TColgp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import math
else:
    import math
del _swig_python_version_info
CSLib_Done = _CSLib.CSLib_Done
CSLib_D1uIsNull = _CSLib.CSLib_D1uIsNull
CSLib_D1vIsNull = _CSLib.CSLib_D1vIsNull
CSLib_D1IsNull = _CSLib.CSLib_D1IsNull
CSLib_D1uD1vRatioIsNull = _CSLib.CSLib_D1uD1vRatioIsNull
CSLib_D1vD1uRatioIsNull = _CSLib.CSLib_D1vD1uRatioIsNull
CSLib_D1uIsParallelD1v = _CSLib.CSLib_D1uIsParallelD1v
CSLib_Singular = _CSLib.CSLib_Singular
CSLib_Defined = _CSLib.CSLib_Defined
CSLib_InfinityOfSolutions = _CSLib.CSLib_InfinityOfSolutions
CSLib_D1NuIsNull = _CSLib.CSLib_D1NuIsNull
CSLib_D1NvIsNull = _CSLib.CSLib_D1NvIsNull
CSLib_D1NIsNull = _CSLib.CSLib_D1NIsNull
CSLib_D1NuNvRatioIsNull = _CSLib.CSLib_D1NuNvRatioIsNull
CSLib_D1NvNuRatioIsNull = _CSLib.CSLib_D1NvNuRatioIsNull
CSLib_D1NuIsParallelD1Nv = _CSLib.CSLib_D1NuIsParallelD1Nv
class CSLib_Class2d(object):
    """
    *** Class2d    : Low level algorithm for 2d classification
    this class was moved from package BRepTopAdaptor
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(CSLib_Class2d self, NCollection_Array1_gp_Pnt2d thePnts2d, Standard_Real const theTolU, Standard_Real const theTolV, Standard_Real const theUMin, Standard_Real const theVMin, Standard_Real const theUMax, Standard_Real const theVMax) -> CSLib_Class2d
        __init__(CSLib_Class2d self, NCollection_Sequence_gp_Pnt2d thePnts2d, Standard_Real const theTolU, Standard_Real const theTolV, Standard_Real const theUMin, Standard_Real const theVMin, Standard_Real const theUMax, Standard_Real const theVMax) -> CSLib_Class2d

        Constructs the 2D-polygon.
        thePnts2d is the set of the vertices (closed polygon
        will always be created inside of this constructor;
        consequently, there is no point in repeating first and
        last point in thePnts2d).
        theTolu and theTolv are tolerances.
        theUmin, theVmin, theUmax, theVmax are
        UV-bounds of the polygon.

        :type thePnts2d: OCC.wrapper.TColgp.TColgp_SequenceOfPnt2d
        :type theTolU: float
        :type theTolV: float
        :type theUMin: float
        :type theVMin: float
        :type theUMax: float
        :type theVMax: float

        """
        this = _CSLib.new_CSLib_Class2d(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def SiDans(self, *args):
        """
        SiDans(CSLib_Class2d self, gp_Pnt2d P) -> Standard_Integer

        :type P: OCC.wrapper.gp.gp_Pnt2d
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _CSLib.CSLib_Class2d_SiDans(self, *args)


    def SiDans_OnMode(self, *args):
        """
        SiDans_OnMode(CSLib_Class2d self, gp_Pnt2d P, Standard_Real const Tol) -> Standard_Integer

        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type Tol: float
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _CSLib.CSLib_Class2d_SiDans_OnMode(self, *args)


    def InternalSiDans(self, *args):
        """
        InternalSiDans(CSLib_Class2d self, Standard_Real const X, Standard_Real const Y) -> Standard_Integer

        :type X: float
        :type Y: float
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _CSLib.CSLib_Class2d_InternalSiDans(self, *args)


    def InternalSiDansOuOn(self, *args):
        """
        InternalSiDansOuOn(CSLib_Class2d self, Standard_Real const X, Standard_Real const Y) -> Standard_Integer

        :type X: float
        :type Y: float
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _CSLib.CSLib_Class2d_InternalSiDansOuOn(self, *args)

    __swig_destroy__ = _CSLib.delete_CSLib_Class2d
CSLib_Class2d_swigregister = _CSLib.CSLib_Class2d_swigregister
CSLib_Class2d_swigregister(CSLib_Class2d)

class CSLib_(object):
    """
    This package implements functions for basis geometric
    computation on curves and surfaces.
    The tolerance criterions used in this package are
    Resolution from package gp and RealEpsilon from class
    Real of package Standard.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Normal(*args):
        """
        Normal(gp_Vec D1U, gp_Vec D1V, Standard_Real const SinTol, gp_Dir Normal)
        Normal(gp_Vec D1U, gp_Vec D1V, gp_Vec D2U, gp_Vec D2V, gp_Vec D2UV, Standard_Real const SinTol, gp_Dir Normal)
        Normal(gp_Vec D1U, gp_Vec D1V, Standard_Real const MagTol, gp_Dir Normal)
        Normal(Standard_Integer const MaxOrder, NCollection_Array2_gp_Vec DerNUV, Standard_Real const MagTol, Standard_Real const U, Standard_Real const V, Standard_Real const Umin, Standard_Real const Umax, Standard_Real const Vmin, Standard_Real const Vmax, gp_Dir Normal)

        find the first  order k0  of deriviative of NUV
        where: foreach order < k0  all the derivatives of NUV  are
        null all the derivatives of NUV corresponding to the order
        k0 are collinear and have the same sens.
        In this case, normal at U,V is unique.

        :type MaxOrder: int
        :type DerNUV: OCC.wrapper.TColgp.TColgp_Array2OfVec
        :type MagTol: float
        :type U: float
        :type V: float
        :type Umin: float
        :type Umax: float
        :type Vmin: float
        :type Vmax: float
        :type theStatus: OCC.wrapper.CSLib.CSLib_NormalStatus
        :type Normal: OCC.wrapper.gp.gp_Dir
        :type OrderU: int
        :type OrderV: int

        """
        return _CSLib.CSLib__Normal(*args)

    Normal = staticmethod(Normal)

    def DNNUV(*args):
        """
        DNNUV(Standard_Integer const Nu, Standard_Integer const Nv, NCollection_Array2_gp_Vec DerSurf) -> gp_Vec
        DNNUV(Standard_Integer const Nu, Standard_Integer const Nv, NCollection_Array2_gp_Vec DerSurf1, NCollection_Array2_gp_Vec DerSurf2) -> gp_Vec

        Computes the derivatives of order Nu in the direction Nu
        and Nv in the direction Nv of the not normalized vector
        N(u,v) = dS1/du * dS2/dv (cases where we use an osculating surface)
        DerSurf1 are the derivatives of S1

        :type Nu: int
        :type Nv: int
        :type DerSurf1: OCC.wrapper.TColgp.TColgp_Array2OfVec
        :type DerSurf2: OCC.wrapper.TColgp.TColgp_Array2OfVec
        :rtype: OCC.wrapper.gp.gp_Vec

        """
        return _CSLib.CSLib__DNNUV(*args)

    DNNUV = staticmethod(DNNUV)

    def DNNormal(*args):
        """
        DNNormal(Standard_Integer const Nu, Standard_Integer const Nv, NCollection_Array2_gp_Vec DerNUV, Standard_Integer const Iduref=0, Standard_Integer const Idvref=0) -> gp_Vec

        -- Computes the derivative  of order Nu in the --
        direction   U and  Nv in the  direction  V  of the
        normalized normal vector  at the point P(U,V) array
        DerNUV contain the  derivative  (i+Iduref,j+Idvref)
        of D1U ^ D1V for i=0,Nu  ; j=0,Nv Iduref and Idvref
        correspond to a derivative  of D1U ^ D1V  which can
        be used to compute the normalized normal vector.
        In the regular cases , Iduref=Idvref=0.

        :type Nu: int
        :type Nv: int
        :type DerNUV: OCC.wrapper.TColgp.TColgp_Array2OfVec
        :type Iduref: int
        :type Idvref: int
        :rtype: OCC.wrapper.gp.gp_Vec

        """
        return _CSLib.CSLib__DNNormal(*args)

    DNNormal = staticmethod(DNNormal)

    def __init__(self):
        """
        This package implements functions for basis geometric
        computation on curves and surfaces.
        The tolerance criterions used in this package are
        Resolution from package gp and RealEpsilon from class
        Real of package Standard.
        """
        this = _CSLib.new_CSLib_()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _CSLib.delete_CSLib_
CSLib__swigregister = _CSLib.CSLib__swigregister
CSLib__swigregister(CSLib_)

def CSLib__Normal(*args):
    """
    Normal(gp_Vec D1U, gp_Vec D1V, Standard_Real const SinTol, gp_Dir Normal)
    Normal(gp_Vec D1U, gp_Vec D1V, gp_Vec D2U, gp_Vec D2V, gp_Vec D2UV, Standard_Real const SinTol, gp_Dir Normal)
    Normal(gp_Vec D1U, gp_Vec D1V, Standard_Real const MagTol, gp_Dir Normal)
    CSLib__Normal(Standard_Integer const MaxOrder, NCollection_Array2_gp_Vec DerNUV, Standard_Real const MagTol, Standard_Real const U, Standard_Real const V, Standard_Real const Umin, Standard_Real const Umax, Standard_Real const Vmin, Standard_Real const Vmax, gp_Dir Normal)

    find the first  order k0  of deriviative of NUV
    where: foreach order < k0  all the derivatives of NUV  are
    null all the derivatives of NUV corresponding to the order
    k0 are collinear and have the same sens.
    In this case, normal at U,V is unique.

    :type MaxOrder: int
    :type DerNUV: OCC.wrapper.TColgp.TColgp_Array2OfVec
    :type MagTol: float
    :type U: float
    :type V: float
    :type Umin: float
    :type Umax: float
    :type Vmin: float
    :type Vmax: float
    :type theStatus: OCC.wrapper.CSLib.CSLib_NormalStatus
    :type Normal: OCC.wrapper.gp.gp_Dir
    :type OrderU: int
    :type OrderV: int

    """
    return _CSLib.CSLib__Normal(*args)

def CSLib__DNNUV(*args):
    """
    DNNUV(Standard_Integer const Nu, Standard_Integer const Nv, NCollection_Array2_gp_Vec DerSurf) -> gp_Vec
    CSLib__DNNUV(Standard_Integer const Nu, Standard_Integer const Nv, NCollection_Array2_gp_Vec DerSurf1, NCollection_Array2_gp_Vec DerSurf2) -> gp_Vec

    Computes the derivatives of order Nu in the direction Nu
    and Nv in the direction Nv of the not normalized vector
    N(u,v) = dS1/du * dS2/dv (cases where we use an osculating surface)
    DerSurf1 are the derivatives of S1

    :type Nu: int
    :type Nv: int
    :type DerSurf1: OCC.wrapper.TColgp.TColgp_Array2OfVec
    :type DerSurf2: OCC.wrapper.TColgp.TColgp_Array2OfVec
    :rtype: OCC.wrapper.gp.gp_Vec

    """
    return _CSLib.CSLib__DNNUV(*args)

def CSLib__DNNormal(*args):
    """
    CSLib__DNNormal(Standard_Integer const Nu, Standard_Integer const Nv, NCollection_Array2_gp_Vec DerNUV, Standard_Integer const Iduref=0, Standard_Integer const Idvref=0) -> gp_Vec

    -- Computes the derivative  of order Nu in the --
    direction   U and  Nv in the  direction  V  of the
    normalized normal vector  at the point P(U,V) array
    DerNUV contain the  derivative  (i+Iduref,j+Idvref)
    of D1U ^ D1V for i=0,Nu  ; j=0,Nv Iduref and Idvref
    correspond to a derivative  of D1U ^ D1V  which can
    be used to compute the normalized normal vector.
    In the regular cases , Iduref=Idvref=0.

    :type Nu: int
    :type Nv: int
    :type DerNUV: OCC.wrapper.TColgp.TColgp_Array2OfVec
    :type Iduref: int
    :type Idvref: int
    :rtype: OCC.wrapper.gp.gp_Vec

    """
    return _CSLib.CSLib__DNNormal(*args)

class CSLib_NormalPolyDef(math.math_FunctionWithDerivative):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(CSLib_NormalPolyDef self, Standard_Integer const k0, NCollection_Array1_Standard_Real li) -> CSLib_NormalPolyDef

        :type k0: int
        :type li: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        this = _CSLib.new_CSLib_NormalPolyDef(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Value(self, *args):
        """
        Value(CSLib_NormalPolyDef self, Standard_Real const X) -> Standard_Boolean

        computes the value <F>of the function for the variable <X>.
        Returns True if the calculation were successfully done,
        False otherwise.

        :type X: float
        :type F: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _CSLib.CSLib_NormalPolyDef_Value(self, *args)


    def Derivative(self, *args):
        """
        Derivative(CSLib_NormalPolyDef self, Standard_Real const X) -> Standard_Boolean

        computes the derivative <D> of the function
        for the variable <X>.
        Returns True if the calculation were successfully done,
        False otherwise.

        :type X: float
        :type D: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _CSLib.CSLib_NormalPolyDef_Derivative(self, *args)


    def Values(self, *args):
        """
        Values(CSLib_NormalPolyDef self, Standard_Real const X) -> Standard_Boolean

        computes the value <F> and the derivative <D> of the
        function for the variable <X>.
        Returns True if the calculation were successfully done,
        False otherwise.

        :type X: float
        :type F: float
        :type D: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _CSLib.CSLib_NormalPolyDef_Values(self, *args)

    __swig_destroy__ = _CSLib.delete_CSLib_NormalPolyDef
CSLib_NormalPolyDef_swigregister = _CSLib.CSLib_NormalPolyDef_swigregister
CSLib_NormalPolyDef_swigregister(CSLib_NormalPolyDef)




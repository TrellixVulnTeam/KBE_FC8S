# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_IntCurve')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_IntCurve')
    _IntCurve = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_IntCurve', [dirname(__file__)])
        except ImportError:
            import _IntCurve
            return _IntCurve
        try:
            _mod = imp.load_module('_IntCurve', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _IntCurve = swig_import_helper()
    del swig_import_helper
else:
    import _IntCurve
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


class SwigPyIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _IntCurve.delete_SwigPyIterator

    def value(self):
        return _IntCurve.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _IntCurve.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _IntCurve.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _IntCurve.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _IntCurve.SwigPyIterator_equal(self, x)

    def copy(self):
        return _IntCurve.SwigPyIterator_copy(self)

    def next(self):
        return _IntCurve.SwigPyIterator_next(self)

    def __next__(self):
        return _IntCurve.SwigPyIterator___next__(self)

    def previous(self):
        return _IntCurve.SwigPyIterator_previous(self)

    def advance(self, n):
        return _IntCurve.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _IntCurve.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _IntCurve.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _IntCurve.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _IntCurve.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _IntCurve.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _IntCurve.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self
SwigPyIterator_swigregister = _IntCurve.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

class NCollection_CellFilter_InspectorXYZ(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _IntCurve.NCollection_CellFilter_InspectorXYZ_Dimension
    Coord = staticmethod(_IntCurve.NCollection_CellFilter_InspectorXYZ_Coord)

    def Shift(self, thePnt, theTol):
        return _IntCurve.NCollection_CellFilter_InspectorXYZ_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _IntCurve.new_NCollection_CellFilter_InspectorXYZ()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _IntCurve.delete_NCollection_CellFilter_InspectorXYZ
NCollection_CellFilter_InspectorXYZ_swigregister = _IntCurve.NCollection_CellFilter_InspectorXYZ_swigregister
NCollection_CellFilter_InspectorXYZ_swigregister(NCollection_CellFilter_InspectorXYZ)

def NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt):
    return _IntCurve.NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt)
NCollection_CellFilter_InspectorXYZ_Coord = _IntCurve.NCollection_CellFilter_InspectorXYZ_Coord

class NCollection_CellFilter_InspectorXY(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _IntCurve.NCollection_CellFilter_InspectorXY_Dimension
    Coord = staticmethod(_IntCurve.NCollection_CellFilter_InspectorXY_Coord)

    def Shift(self, thePnt, theTol):
        return _IntCurve.NCollection_CellFilter_InspectorXY_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _IntCurve.new_NCollection_CellFilter_InspectorXY()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _IntCurve.delete_NCollection_CellFilter_InspectorXY
NCollection_CellFilter_InspectorXY_swigregister = _IntCurve.NCollection_CellFilter_InspectorXY_swigregister
NCollection_CellFilter_InspectorXY_swigregister(NCollection_CellFilter_InspectorXY)

def NCollection_CellFilter_InspectorXY_Coord(i, thePnt):
    return _IntCurve.NCollection_CellFilter_InspectorXY_Coord(i, thePnt)
NCollection_CellFilter_InspectorXY_Coord = _IntCurve.NCollection_CellFilter_InspectorXY_Coord


def ptr_to_number(item):
    return _IntCurve.ptr_to_number(item)
ptr_to_number = _IntCurve.ptr_to_number

def HashCode(*args):
    return _IntCurve.HashCode(*args)
HashCode = _IntCurve.HashCode

def ptr_equal(a, b):
    return _IntCurve.ptr_equal(a, b)
ptr_equal = _IntCurve.ptr_equal
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import GeomAbs
else:
    import GeomAbs
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColStd
else:
    import TColStd
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TCollection
else:
    import TCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Standard
else:
    import Standard
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import NCollection
else:
    import NCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import gp
else:
    import gp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import IntRes2d
else:
    import IntRes2d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import math
else:
    import math
del _swig_python_version_info
class IntCurve_IntConicConic(IntRes2d.IntRes2d_Intersection):
    """
    Provides methods to intersect two conics.
    The exception ConstructionError is raised  in constructors
    or in Perform methods  when a domain  (Domain from IntRes2d)
    is not correct, i-e when a Circle (Circ2d from  gp) or
    an Ellipse (i-e Elips2d from  gp) do not have a closed
    domain (use the  SetEquivalentParameters method for a domain
    on a circle or an ellipse).
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(IntCurve_IntConicConic self) -> IntCurve_IntConicConic
        __init__(IntCurve_IntConicConic self, gp_Lin2d L1, IntRes2d_Domain D1, gp_Lin2d L2, IntRes2d_Domain D2, Standard_Real const TolConf, Standard_Real const Tol) -> IntCurve_IntConicConic
        __init__(IntCurve_IntConicConic self, gp_Lin2d L, IntRes2d_Domain DL, gp_Circ2d C, IntRes2d_Domain DC, Standard_Real const TolConf, Standard_Real const Tol) -> IntCurve_IntConicConic
        __init__(IntCurve_IntConicConic self, gp_Lin2d L, IntRes2d_Domain DL, gp_Elips2d E, IntRes2d_Domain DE, Standard_Real const TolConf, Standard_Real const Tol) -> IntCurve_IntConicConic
        __init__(IntCurve_IntConicConic self, gp_Lin2d L, IntRes2d_Domain DL, gp_Parab2d P, IntRes2d_Domain DP, Standard_Real const TolConf, Standard_Real const Tol) -> IntCurve_IntConicConic
        __init__(IntCurve_IntConicConic self, gp_Lin2d L, IntRes2d_Domain DL, gp_Hypr2d H, IntRes2d_Domain DH, Standard_Real const TolConf, Standard_Real const Tol) -> IntCurve_IntConicConic
        __init__(IntCurve_IntConicConic self, gp_Circ2d C1, IntRes2d_Domain D1, gp_Circ2d C2, IntRes2d_Domain D2, Standard_Real const TolConf, Standard_Real const Tol) -> IntCurve_IntConicConic
        __init__(IntCurve_IntConicConic self, gp_Circ2d C, IntRes2d_Domain DC, gp_Elips2d E, IntRes2d_Domain DE, Standard_Real const TolConf, Standard_Real const Tol) -> IntCurve_IntConicConic
        __init__(IntCurve_IntConicConic self, gp_Circ2d C, IntRes2d_Domain DC, gp_Parab2d P, IntRes2d_Domain DP, Standard_Real const TolConf, Standard_Real const Tol) -> IntCurve_IntConicConic
        __init__(IntCurve_IntConicConic self, gp_Circ2d C, IntRes2d_Domain DC, gp_Hypr2d H, IntRes2d_Domain DH, Standard_Real const TolConf, Standard_Real const Tol) -> IntCurve_IntConicConic
        __init__(IntCurve_IntConicConic self, gp_Elips2d E1, IntRes2d_Domain D1, gp_Elips2d E2, IntRes2d_Domain D2, Standard_Real const TolConf, Standard_Real const Tol) -> IntCurve_IntConicConic
        __init__(IntCurve_IntConicConic self, gp_Elips2d E, IntRes2d_Domain DE, gp_Parab2d P, IntRes2d_Domain DP, Standard_Real const TolConf, Standard_Real const Tol) -> IntCurve_IntConicConic
        __init__(IntCurve_IntConicConic self, gp_Elips2d E, IntRes2d_Domain DE, gp_Hypr2d H, IntRes2d_Domain DH, Standard_Real const TolConf, Standard_Real const Tol) -> IntCurve_IntConicConic
        __init__(IntCurve_IntConicConic self, gp_Parab2d P1, IntRes2d_Domain D1, gp_Parab2d P2, IntRes2d_Domain D2, Standard_Real const TolConf, Standard_Real const Tol) -> IntCurve_IntConicConic
        __init__(IntCurve_IntConicConic self, gp_Parab2d P, IntRes2d_Domain DP, gp_Hypr2d H, IntRes2d_Domain DH, Standard_Real const TolConf, Standard_Real const Tol) -> IntCurve_IntConicConic
        __init__(IntCurve_IntConicConic self, gp_Hypr2d H1, IntRes2d_Domain D1, gp_Hypr2d H2, IntRes2d_Domain D2, Standard_Real const TolConf, Standard_Real const Tol) -> IntCurve_IntConicConic

        Intersection between 2 hyperbolas.

        :type H1: OCC.wrapper.gp.gp_Hypr2d
        :type D1: OCC.wrapper.IntRes2d.IntRes2d_Domain
        :type H2: OCC.wrapper.gp.gp_Hypr2d
        :type D2: OCC.wrapper.IntRes2d.IntRes2d_Domain
        :type TolConf: float
        :type Tol: float

        """
        this = _IntCurve.new_IntCurve_IntConicConic(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Perform(self, *args):
        """
        Perform(IntCurve_IntConicConic self, gp_Lin2d L1, IntRes2d_Domain D1, gp_Lin2d L2, IntRes2d_Domain D2, Standard_Real const TolConf, Standard_Real const Tol)
        Perform(IntCurve_IntConicConic self, gp_Lin2d L, IntRes2d_Domain DL, gp_Circ2d C, IntRes2d_Domain DC, Standard_Real const TolConf, Standard_Real const Tol)
        Perform(IntCurve_IntConicConic self, gp_Lin2d L, IntRes2d_Domain DL, gp_Elips2d E, IntRes2d_Domain DE, Standard_Real const TolConf, Standard_Real const Tol)
        Perform(IntCurve_IntConicConic self, gp_Lin2d L, IntRes2d_Domain DL, gp_Parab2d P, IntRes2d_Domain DP, Standard_Real const TolConf, Standard_Real const Tol)
        Perform(IntCurve_IntConicConic self, gp_Lin2d L, IntRes2d_Domain DL, gp_Hypr2d H, IntRes2d_Domain DH, Standard_Real const TolConf, Standard_Real const Tol)
        Perform(IntCurve_IntConicConic self, gp_Circ2d C1, IntRes2d_Domain D1, gp_Circ2d C2, IntRes2d_Domain D2, Standard_Real const TolConf, Standard_Real const Tol)
        Perform(IntCurve_IntConicConic self, gp_Circ2d C, IntRes2d_Domain DC, gp_Elips2d E, IntRes2d_Domain DE, Standard_Real const TolConf, Standard_Real const Tol)
        Perform(IntCurve_IntConicConic self, gp_Circ2d C, IntRes2d_Domain DC, gp_Parab2d P, IntRes2d_Domain DP, Standard_Real const TolConf, Standard_Real const Tol)
        Perform(IntCurve_IntConicConic self, gp_Circ2d C, IntRes2d_Domain DC, gp_Hypr2d H, IntRes2d_Domain DH, Standard_Real const TolConf, Standard_Real const Tol)
        Perform(IntCurve_IntConicConic self, gp_Elips2d E1, IntRes2d_Domain D1, gp_Elips2d E2, IntRes2d_Domain D2, Standard_Real const TolConf, Standard_Real const Tol)
        Perform(IntCurve_IntConicConic self, gp_Elips2d E, IntRes2d_Domain DE, gp_Parab2d P, IntRes2d_Domain DP, Standard_Real const TolConf, Standard_Real const Tol)
        Perform(IntCurve_IntConicConic self, gp_Elips2d E, IntRes2d_Domain DE, gp_Hypr2d H, IntRes2d_Domain DH, Standard_Real const TolConf, Standard_Real const Tol)
        Perform(IntCurve_IntConicConic self, gp_Parab2d P1, IntRes2d_Domain D1, gp_Parab2d P2, IntRes2d_Domain D2, Standard_Real const TolConf, Standard_Real const Tol)
        Perform(IntCurve_IntConicConic self, gp_Parab2d P, IntRes2d_Domain DP, gp_Hypr2d H, IntRes2d_Domain DH, Standard_Real const TolConf, Standard_Real const Tol)
        Perform(IntCurve_IntConicConic self, gp_Hypr2d H1, IntRes2d_Domain D1, gp_Hypr2d H2, IntRes2d_Domain D2, Standard_Real const TolConf, Standard_Real const Tol)

        Intersection between 2 hyperbolas.

        :type H1: OCC.wrapper.gp.gp_Hypr2d
        :type D1: OCC.wrapper.IntRes2d.IntRes2d_Domain
        :type H2: OCC.wrapper.gp.gp_Hypr2d
        :type D2: OCC.wrapper.IntRes2d.IntRes2d_Domain
        :type TolConf: float
        :type Tol: float

        """
        return _IntCurve.IntCurve_IntConicConic_Perform(self, *args)

    __swig_destroy__ = _IntCurve.delete_IntCurve_IntConicConic
IntCurve_IntConicConic_swigregister = _IntCurve.IntCurve_IntConicConic_swigregister
IntCurve_IntConicConic_swigregister(IntCurve_IntConicConic)

class IntCurve_PConic(object):
    """
    This class represents a conic from gp as a
    parametric curve ( in order to be used by the
    class PConicTool from IntCurve).
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(IntCurve_PConic self, IntCurve_PConic PC) -> IntCurve_PConic
        __init__(IntCurve_PConic self, gp_Elips2d E) -> IntCurve_PConic
        __init__(IntCurve_PConic self, gp_Circ2d C) -> IntCurve_PConic
        __init__(IntCurve_PConic self, gp_Parab2d P) -> IntCurve_PConic
        __init__(IntCurve_PConic self, gp_Hypr2d H) -> IntCurve_PConic
        __init__(IntCurve_PConic self, gp_Lin2d L) -> IntCurve_PConic

        :type L: OCC.wrapper.gp.gp_Lin2d

        """
        this = _IntCurve.new_IntCurve_PConic(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def SetEpsX(self, *args):
        """
        SetEpsX(IntCurve_PConic self, Standard_Real const EpsDist)

        EpsX is a internal tolerance used in math
        algorithms, usually about 1e-10
        (See FunctionAllRoots for more details)

        :type EpsDist: float

        """
        return _IntCurve.IntCurve_PConic_SetEpsX(self, *args)


    def SetAccuracy(self, *args):
        """
        SetAccuracy(IntCurve_PConic self, Standard_Integer const Nb)

        Accuracy is the number of samples used to
        approximate the parametric curve on its domain.

        :type Nb: int

        """
        return _IntCurve.IntCurve_PConic_SetAccuracy(self, *args)


    def Accuracy(self, *args):
        """
        Accuracy(IntCurve_PConic self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntCurve.IntCurve_PConic_Accuracy(self, *args)


    def EpsX(self, *args):
        """
        EpsX(IntCurve_PConic self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _IntCurve.IntCurve_PConic_EpsX(self, *args)


    def TypeCurve(self, *args):
        """
        TypeCurve(IntCurve_PConic self) -> GeomAbs_CurveType

        The Conics are manipulated as objects which only
        depend on three parameters : Axis and two Real from Standards.
        Type Curve is used to select the correct Conic.

        :rtype: OCC.wrapper.GeomAbs.GeomAbs_CurveType

        """
        return _IntCurve.IntCurve_PConic_TypeCurve(self, *args)


    def Axis2(self, *args):
        """
        :rtype: OCC.wrapper.gp.gp_Ax22d

        """
        res = _IntCurve.IntCurve_PConic_Axis2(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Param1(self, *args):
        """
        Param1(IntCurve_PConic self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _IntCurve.IntCurve_PConic_Param1(self, *args)


    def Param2(self, *args):
        """
        Param2(IntCurve_PConic self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _IntCurve.IntCurve_PConic_Param2(self, *args)

    __swig_destroy__ = _IntCurve.delete_IntCurve_PConic
IntCurve_PConic_swigregister = _IntCurve.IntCurve_PConic_swigregister
IntCurve_PConic_swigregister(IntCurve_PConic)

class PeriodicInterval(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def SetNull(self, *args):
        """SetNull(PeriodicInterval self)"""
        return _IntCurve.PeriodicInterval_SetNull(self, *args)


    def IsNull(self, *args):
        """
        IsNull(PeriodicInterval self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntCurve.PeriodicInterval_IsNull(self, *args)


    def Complement(self, *args):
        """Complement(PeriodicInterval self)"""
        return _IntCurve.PeriodicInterval_Complement(self, *args)


    def Length(self, *args):
        """
        Length(PeriodicInterval self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _IntCurve.PeriodicInterval_Length(self, *args)


    def __init__(self, *args):
        """
        __init__(PeriodicInterval self, IntRes2d_Domain Domain) -> PeriodicInterval
        __init__(PeriodicInterval self) -> PeriodicInterval
        __init__(PeriodicInterval self, Standard_Real const a, Standard_Real const b) -> PeriodicInterval

        :type a: float
        :type b: float

        """
        this = _IntCurve.new_PeriodicInterval(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def SetValues(self, *args):
        """
        SetValues(PeriodicInterval self, Standard_Real const a, Standard_Real const b)

        :type a: float
        :type b: float

        """
        return _IntCurve.PeriodicInterval_SetValues(self, *args)


    def Normalize(self, *args):
        """Normalize(PeriodicInterval self)"""
        return _IntCurve.PeriodicInterval_Normalize(self, *args)

    __swig_destroy__ = _IntCurve.delete_PeriodicInterval
PeriodicInterval_swigregister = _IntCurve.PeriodicInterval_swigregister
PeriodicInterval_swigregister(PeriodicInterval)

class IntCurve_MyImpParToolOfIntImpConicParConic(math.math_FunctionWithDerivative):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(IntCurve_MyImpParToolOfIntImpConicParConic self, IntCurve_IConicTool IT, IntCurve_PConic PC) -> IntCurve_MyImpParToolOfIntImpConicParConic

        Constructor of the class.

        :type IT: OCC.wrapper.IntCurve.IntCurve_IConicTool
        :type PC: OCC.wrapper.IntCurve.IntCurve_PConic

        """
        this = _IntCurve.new_IntCurve_MyImpParToolOfIntImpConicParConic(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Value(self, *args):
        """
        Value(IntCurve_MyImpParToolOfIntImpConicParConic self, Standard_Real const Param) -> Standard_Boolean

        Computes the value of the signed distance between
        the implicit curve and the point at parameter Param
        on the parametrised curve.

        :type Param: float
        :type F: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntCurve.IntCurve_MyImpParToolOfIntImpConicParConic_Value(self, *args)


    def Derivative(self, *args):
        """
        Derivative(IntCurve_MyImpParToolOfIntImpConicParConic self, Standard_Real const Param) -> Standard_Boolean

        Computes the derivative of the previous function at
        parameter Param.

        :type Param: float
        :type D: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntCurve.IntCurve_MyImpParToolOfIntImpConicParConic_Derivative(self, *args)


    def Values(self, *args):
        """
        Values(IntCurve_MyImpParToolOfIntImpConicParConic self, Standard_Real const Param) -> Standard_Boolean

        Computes the value and the derivative of the function.

        :type Param: float
        :type F: float
        :type D: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntCurve.IntCurve_MyImpParToolOfIntImpConicParConic_Values(self, *args)

    __swig_destroy__ = _IntCurve.delete_IntCurve_MyImpParToolOfIntImpConicParConic
IntCurve_MyImpParToolOfIntImpConicParConic_swigregister = _IntCurve.IntCurve_MyImpParToolOfIntImpConicParConic_swigregister
IntCurve_MyImpParToolOfIntImpConicParConic_swigregister(IntCurve_MyImpParToolOfIntImpConicParConic)

class IntCurve_PConicTool(object):
    """
    Implementation of the ParTool from IntImpParGen
    for conics of gp, using the class PConic from IntCurve.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def EpsX(*args):
        """
        EpsX(IntCurve_PConic C) -> Standard_Real

        :type C: OCC.wrapper.IntCurve.IntCurve_PConic
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _IntCurve.IntCurve_PConicTool_EpsX(*args)

    EpsX = staticmethod(EpsX)

    def NbSamples(*args):
        """
        NbSamples(IntCurve_PConic C) -> Standard_Integer
        NbSamples(IntCurve_PConic C, Standard_Real const U0, Standard_Real const U1) -> Standard_Integer

        :type C: OCC.wrapper.IntCurve.IntCurve_PConic
        :type U0: float
        :type U1: float
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntCurve.IntCurve_PConicTool_NbSamples(*args)

    NbSamples = staticmethod(NbSamples)

    def Value(*args):
        """
        Value(IntCurve_PConic C, Standard_Real const X) -> gp_Pnt2d

        :type C: OCC.wrapper.IntCurve.IntCurve_PConic
        :type X: float
        :rtype: OCC.wrapper.gp.gp_Pnt2d

        """
        return _IntCurve.IntCurve_PConicTool_Value(*args)

    Value = staticmethod(Value)

    def D1(*args):
        """
        D1(IntCurve_PConic C, Standard_Real const U, gp_Pnt2d P, gp_Vec2d T)

        :type C: OCC.wrapper.IntCurve.IntCurve_PConic
        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type T: OCC.wrapper.gp.gp_Vec2d

        """
        return _IntCurve.IntCurve_PConicTool_D1(*args)

    D1 = staticmethod(D1)

    def D2(*args):
        """
        D2(IntCurve_PConic C, Standard_Real const U, gp_Pnt2d P, gp_Vec2d T, gp_Vec2d N)

        :type C: OCC.wrapper.IntCurve.IntCurve_PConic
        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type T: OCC.wrapper.gp.gp_Vec2d
        :type N: OCC.wrapper.gp.gp_Vec2d

        """
        return _IntCurve.IntCurve_PConicTool_D2(*args)

    D2 = staticmethod(D2)

    def __init__(self):
        """
        Implementation of the ParTool from IntImpParGen
        for conics of gp, using the class PConic from IntCurve.
        """
        this = _IntCurve.new_IntCurve_PConicTool()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _IntCurve.delete_IntCurve_PConicTool
IntCurve_PConicTool_swigregister = _IntCurve.IntCurve_PConicTool_swigregister
IntCurve_PConicTool_swigregister(IntCurve_PConicTool)

def IntCurve_PConicTool_EpsX(*args):
    """
    IntCurve_PConicTool_EpsX(IntCurve_PConic C) -> Standard_Real

    :type C: OCC.wrapper.IntCurve.IntCurve_PConic
    :rtype: OCC.wrapper.Standard.Standard_Real

    """
    return _IntCurve.IntCurve_PConicTool_EpsX(*args)

def IntCurve_PConicTool_NbSamples(*args):
    """
    NbSamples(IntCurve_PConic C) -> Standard_Integer
    IntCurve_PConicTool_NbSamples(IntCurve_PConic C, Standard_Real const U0, Standard_Real const U1) -> Standard_Integer

    :type C: OCC.wrapper.IntCurve.IntCurve_PConic
    :type U0: float
    :type U1: float
    :rtype: OCC.wrapper.Standard.Standard_Integer

    """
    return _IntCurve.IntCurve_PConicTool_NbSamples(*args)

def IntCurve_PConicTool_Value(*args):
    """
    IntCurve_PConicTool_Value(IntCurve_PConic C, Standard_Real const X) -> gp_Pnt2d

    :type C: OCC.wrapper.IntCurve.IntCurve_PConic
    :type X: float
    :rtype: OCC.wrapper.gp.gp_Pnt2d

    """
    return _IntCurve.IntCurve_PConicTool_Value(*args)

def IntCurve_PConicTool_D1(*args):
    """
    IntCurve_PConicTool_D1(IntCurve_PConic C, Standard_Real const U, gp_Pnt2d P, gp_Vec2d T)

    :type C: OCC.wrapper.IntCurve.IntCurve_PConic
    :type U: float
    :type P: OCC.wrapper.gp.gp_Pnt2d
    :type T: OCC.wrapper.gp.gp_Vec2d

    """
    return _IntCurve.IntCurve_PConicTool_D1(*args)

def IntCurve_PConicTool_D2(*args):
    """
    IntCurve_PConicTool_D2(IntCurve_PConic C, Standard_Real const U, gp_Pnt2d P, gp_Vec2d T, gp_Vec2d N)

    :type C: OCC.wrapper.IntCurve.IntCurve_PConic
    :type U: float
    :type P: OCC.wrapper.gp.gp_Pnt2d
    :type T: OCC.wrapper.gp.gp_Vec2d
    :type N: OCC.wrapper.gp.gp_Vec2d

    """
    return _IntCurve.IntCurve_PConicTool_D2(*args)

class IntCurve_IntImpConicParConic(IntRes2d.IntRes2d_Intersection):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(IntCurve_IntImpConicParConic self) -> IntCurve_IntImpConicParConic
        __init__(IntCurve_IntImpConicParConic self, IntCurve_IConicTool ITool, IntRes2d_Domain Dom1, IntCurve_PConic PCurve, IntRes2d_Domain Dom2, Standard_Real const TolConf, Standard_Real const Tol) -> IntCurve_IntImpConicParConic

        Intersection between an implicit curve and
        a parametrised curve.
        The exception ConstructionError is raised if the domain
        of the parametrised curve does not verify HasFirstPoint
        and HasLastPoint return True.

        :type ITool: OCC.wrapper.IntCurve.IntCurve_IConicTool
        :type Dom1: OCC.wrapper.IntRes2d.IntRes2d_Domain
        :type PCurve: OCC.wrapper.IntCurve.IntCurve_PConic
        :type Dom2: OCC.wrapper.IntRes2d.IntRes2d_Domain
        :type TolConf: float
        :type Tol: float

        """
        this = _IntCurve.new_IntCurve_IntImpConicParConic(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Perform(self, *args):
        """
        Perform(IntCurve_IntImpConicParConic self, IntCurve_IConicTool ITool, IntRes2d_Domain Dom1, IntCurve_PConic PCurve, IntRes2d_Domain Dom2, Standard_Real const TolConf, Standard_Real const Tol)

        Intersection between an implicit curve and
        a parametrised curve.
        The exception ConstructionError is raised if the domain
        of the parametrised curve does not verify HasFirstPoint
        and HasLastPoint return True.

        :type ITool: OCC.wrapper.IntCurve.IntCurve_IConicTool
        :type Dom1: OCC.wrapper.IntRes2d.IntRes2d_Domain
        :type PCurve: OCC.wrapper.IntCurve.IntCurve_PConic
        :type Dom2: OCC.wrapper.IntRes2d.IntRes2d_Domain
        :type TolConf: float
        :type Tol: float

        """
        return _IntCurve.IntCurve_IntImpConicParConic_Perform(self, *args)


    def FindU(self, *args):
        """
        FindU(IntCurve_IntImpConicParConic self, Standard_Real const parameter, gp_Pnt2d point, IntCurve_PConic TheParCurev, IntCurve_IConicTool TheImpTool) -> Standard_Real

        :type parameter: float
        :type point: OCC.wrapper.gp.gp_Pnt2d
        :type TheParCurev: OCC.wrapper.IntCurve.IntCurve_PConic
        :type TheImpTool: OCC.wrapper.IntCurve.IntCurve_IConicTool
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _IntCurve.IntCurve_IntImpConicParConic_FindU(self, *args)


    def FindV(self, *args):
        """
        FindV(IntCurve_IntImpConicParConic self, Standard_Real const parameter, gp_Pnt2d point, IntCurve_IConicTool TheImpTool, IntCurve_PConic ParCurve, IntRes2d_Domain TheParCurveDomain, Standard_Real const V0, Standard_Real const V1, Standard_Real const Tolerance) -> Standard_Real

        :type parameter: float
        :type point: OCC.wrapper.gp.gp_Pnt2d
        :type TheImpTool: OCC.wrapper.IntCurve.IntCurve_IConicTool
        :type ParCurve: OCC.wrapper.IntCurve.IntCurve_PConic
        :type TheParCurveDomain: OCC.wrapper.IntRes2d.IntRes2d_Domain
        :type V0: float
        :type V1: float
        :type Tolerance: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _IntCurve.IntCurve_IntImpConicParConic_FindV(self, *args)


    def And_Domaine_Objet1_Intersections(self, *args):
        """
        And_Domaine_Objet1_Intersections(IntCurve_IntImpConicParConic self, IntCurve_IConicTool TheImpTool, IntCurve_PConic TheParCurve, IntRes2d_Domain TheImpCurveDomain, IntRes2d_Domain TheParCurveDomain, NCollection_Array1_Standard_Real Inter2_And_Domain2, NCollection_Array1_Standard_Real Inter1, NCollection_Array1_Standard_Real Resultat1, NCollection_Array1_Standard_Real Resultat2, Standard_Real const EpsNul)

        :type TheImpTool: OCC.wrapper.IntCurve.IntCurve_IConicTool
        :type TheParCurve: OCC.wrapper.IntCurve.IntCurve_PConic
        :type TheImpCurveDomain: OCC.wrapper.IntRes2d.IntRes2d_Domain
        :type TheParCurveDomain: OCC.wrapper.IntRes2d.IntRes2d_Domain
        :type NbResultats: int
        :type Inter2_And_Domain2: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type Inter1: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type Resultat1: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type Resultat2: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type EpsNul: float

        """
        return _IntCurve.IntCurve_IntImpConicParConic_And_Domaine_Objet1_Intersections(self, *args)

    __swig_destroy__ = _IntCurve.delete_IntCurve_IntImpConicParConic
IntCurve_IntImpConicParConic_swigregister = _IntCurve.IntCurve_IntImpConicParConic_swigregister
IntCurve_IntImpConicParConic_swigregister(IntCurve_IntImpConicParConic)

class IntCurve_ProjectOnPConicTool(object):
    """
    This class provides a tool which computes the parameter
    of a point near a parametric conic.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def FindParameter(*args):
        """
        FindParameter(IntCurve_PConic C, gp_Pnt2d Pnt, Standard_Real const Tol) -> Standard_Real
        FindParameter(IntCurve_PConic C, gp_Pnt2d Pnt, Standard_Real const LowParameter, Standard_Real const HighParameter, Standard_Real const Tol) -> Standard_Real

        Returns the  parameter  V of the   point  on the
        parametric  curve corresponding  to  the   Point Pnt.  The
        Correspondance  between Pnt and  the   point  P(V) on  the
        parametric  curve  must  be  coherent   with the  way   of
        determination of the  signed distance between  a point and
        the implicit curve.  Tol  is the tolerance on the distance
        between a point and the  parametrised curve.  LowParameter
        and HighParameter give the  boundaries of the interval  in
        wich the parameter  certainly  lies.  These parameters are
        given to implement a  more efficient  algoritm. So,  it is
        not necessary to check   that the returned value  verifies
        LowParameter <= Value <= HighParameter.

        :type C: OCC.wrapper.IntCurve.IntCurve_PConic
        :type Pnt: OCC.wrapper.gp.gp_Pnt2d
        :type LowParameter: float
        :type HighParameter: float
        :type Tol: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _IntCurve.IntCurve_ProjectOnPConicTool_FindParameter(*args)

    FindParameter = staticmethod(FindParameter)

    def __init__(self):
        """
        This class provides a tool which computes the parameter
        of a point near a parametric conic.
        """
        this = _IntCurve.new_IntCurve_ProjectOnPConicTool()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _IntCurve.delete_IntCurve_ProjectOnPConicTool
IntCurve_ProjectOnPConicTool_swigregister = _IntCurve.IntCurve_ProjectOnPConicTool_swigregister
IntCurve_ProjectOnPConicTool_swigregister(IntCurve_ProjectOnPConicTool)

def IntCurve_ProjectOnPConicTool_FindParameter(*args):
    """
    FindParameter(IntCurve_PConic C, gp_Pnt2d Pnt, Standard_Real const Tol) -> Standard_Real
    IntCurve_ProjectOnPConicTool_FindParameter(IntCurve_PConic C, gp_Pnt2d Pnt, Standard_Real const LowParameter, Standard_Real const HighParameter, Standard_Real const Tol) -> Standard_Real

    Returns the  parameter  V of the   point  on the
    parametric  curve corresponding  to  the   Point Pnt.  The
    Correspondance  between Pnt and  the   point  P(V) on  the
    parametric  curve  must  be  coherent   with the  way   of
    determination of the  signed distance between  a point and
    the implicit curve.  Tol  is the tolerance on the distance
    between a point and the  parametrised curve.  LowParameter
    and HighParameter give the  boundaries of the interval  in
    wich the parameter  certainly  lies.  These parameters are
    given to implement a  more efficient  algoritm. So,  it is
    not necessary to check   that the returned value  verifies
    LowParameter <= Value <= HighParameter.

    :type C: OCC.wrapper.IntCurve.IntCurve_PConic
    :type Pnt: OCC.wrapper.gp.gp_Pnt2d
    :type LowParameter: float
    :type HighParameter: float
    :type Tol: float
    :rtype: OCC.wrapper.Standard.Standard_Real

    """
    return _IntCurve.IntCurve_ProjectOnPConicTool_FindParameter(*args)

class IntCurve_IConicTool(object):
    """
    Implementation of the ImpTool from IntImpParGen
    for conics of gp.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(IntCurve_IConicTool self) -> IntCurve_IConicTool
        __init__(IntCurve_IConicTool self, IntCurve_IConicTool IT) -> IntCurve_IConicTool
        __init__(IntCurve_IConicTool self, gp_Elips2d E) -> IntCurve_IConicTool
        __init__(IntCurve_IConicTool self, gp_Lin2d L) -> IntCurve_IConicTool
        __init__(IntCurve_IConicTool self, gp_Circ2d C) -> IntCurve_IConicTool
        __init__(IntCurve_IConicTool self, gp_Parab2d P) -> IntCurve_IConicTool
        __init__(IntCurve_IConicTool self, gp_Hypr2d H) -> IntCurve_IConicTool

        :type H: OCC.wrapper.gp.gp_Hypr2d

        """
        this = _IntCurve.new_IntCurve_IConicTool(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Value(self, *args):
        """
        Value(IntCurve_IConicTool self, Standard_Real const X) -> gp_Pnt2d

        :type X: float
        :rtype: OCC.wrapper.gp.gp_Pnt2d

        """
        return _IntCurve.IntCurve_IConicTool_Value(self, *args)


    def D1(self, *args):
        """
        D1(IntCurve_IConicTool self, Standard_Real const U, gp_Pnt2d P, gp_Vec2d T)

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type T: OCC.wrapper.gp.gp_Vec2d

        """
        return _IntCurve.IntCurve_IConicTool_D1(self, *args)


    def D2(self, *args):
        """
        D2(IntCurve_IConicTool self, Standard_Real const U, gp_Pnt2d P, gp_Vec2d T, gp_Vec2d N)

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type T: OCC.wrapper.gp.gp_Vec2d
        :type N: OCC.wrapper.gp.gp_Vec2d

        """
        return _IntCurve.IntCurve_IConicTool_D2(self, *args)


    def Distance(self, *args):
        """
        Distance(IntCurve_IConicTool self, gp_Pnt2d P) -> Standard_Real

        Computes the value of the signed  distance between
        the point P and the implicit curve.

        :type P: OCC.wrapper.gp.gp_Pnt2d
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _IntCurve.IntCurve_IConicTool_Distance(self, *args)


    def GradDistance(self, *args):
        """
        GradDistance(IntCurve_IConicTool self, gp_Pnt2d P) -> gp_Vec2d

        Computes  the   Gradient  of  the  Signed Distance
        between  a  point and  the  implicit curve, at the
        point P.

        :type P: OCC.wrapper.gp.gp_Pnt2d
        :rtype: OCC.wrapper.gp.gp_Vec2d

        """
        return _IntCurve.IntCurve_IConicTool_GradDistance(self, *args)


    def FindParameter(self, *args):
        """
        FindParameter(IntCurve_IConicTool self, gp_Pnt2d P) -> Standard_Real

        Returns the   parameter  U of   the point  on  the
        implicit curve corresponding to  the point P.  The
        correspondance between P and the point P(U) on the
        implicit curve must be coherent  with the  way  of
        determination of the signed distance.

        :type P: OCC.wrapper.gp.gp_Pnt2d
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _IntCurve.IntCurve_IConicTool_FindParameter(self, *args)

    __swig_destroy__ = _IntCurve.delete_IntCurve_IConicTool
IntCurve_IConicTool_swigregister = _IntCurve.IntCurve_IConicTool_swigregister
IntCurve_IConicTool_swigregister(IntCurve_IConicTool)




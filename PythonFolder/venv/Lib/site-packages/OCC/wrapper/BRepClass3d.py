# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_BRepClass3d')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_BRepClass3d')
    _BRepClass3d = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_BRepClass3d', [dirname(__file__)])
        except ImportError:
            import _BRepClass3d
            return _BRepClass3d
        try:
            _mod = imp.load_module('_BRepClass3d', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _BRepClass3d = swig_import_helper()
    del swig_import_helper
else:
    import _BRepClass3d
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


class SwigPyIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _BRepClass3d.delete_SwigPyIterator

    def value(self):
        return _BRepClass3d.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _BRepClass3d.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _BRepClass3d.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _BRepClass3d.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _BRepClass3d.SwigPyIterator_equal(self, x)

    def copy(self):
        return _BRepClass3d.SwigPyIterator_copy(self)

    def next(self):
        return _BRepClass3d.SwigPyIterator_next(self)

    def __next__(self):
        return _BRepClass3d.SwigPyIterator___next__(self)

    def previous(self):
        return _BRepClass3d.SwigPyIterator_previous(self)

    def advance(self, n):
        return _BRepClass3d.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _BRepClass3d.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _BRepClass3d.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _BRepClass3d.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _BRepClass3d.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _BRepClass3d.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _BRepClass3d.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self
SwigPyIterator_swigregister = _BRepClass3d.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

class NCollection_CellFilter_InspectorXYZ(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _BRepClass3d.NCollection_CellFilter_InspectorXYZ_Dimension
    Coord = staticmethod(_BRepClass3d.NCollection_CellFilter_InspectorXYZ_Coord)

    def Shift(self, thePnt, theTol):
        return _BRepClass3d.NCollection_CellFilter_InspectorXYZ_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _BRepClass3d.new_NCollection_CellFilter_InspectorXYZ()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _BRepClass3d.delete_NCollection_CellFilter_InspectorXYZ
NCollection_CellFilter_InspectorXYZ_swigregister = _BRepClass3d.NCollection_CellFilter_InspectorXYZ_swigregister
NCollection_CellFilter_InspectorXYZ_swigregister(NCollection_CellFilter_InspectorXYZ)

def NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt):
    return _BRepClass3d.NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt)
NCollection_CellFilter_InspectorXYZ_Coord = _BRepClass3d.NCollection_CellFilter_InspectorXYZ_Coord

class NCollection_CellFilter_InspectorXY(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _BRepClass3d.NCollection_CellFilter_InspectorXY_Dimension
    Coord = staticmethod(_BRepClass3d.NCollection_CellFilter_InspectorXY_Coord)

    def Shift(self, thePnt, theTol):
        return _BRepClass3d.NCollection_CellFilter_InspectorXY_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _BRepClass3d.new_NCollection_CellFilter_InspectorXY()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _BRepClass3d.delete_NCollection_CellFilter_InspectorXY
NCollection_CellFilter_InspectorXY_swigregister = _BRepClass3d.NCollection_CellFilter_InspectorXY_swigregister
NCollection_CellFilter_InspectorXY_swigregister(NCollection_CellFilter_InspectorXY)

def NCollection_CellFilter_InspectorXY_Coord(i, thePnt):
    return _BRepClass3d.NCollection_CellFilter_InspectorXY_Coord(i, thePnt)
NCollection_CellFilter_InspectorXY_Coord = _BRepClass3d.NCollection_CellFilter_InspectorXY_Coord


def ptr_to_number(item):
    return _BRepClass3d.ptr_to_number(item)
ptr_to_number = _BRepClass3d.ptr_to_number

def HashCode(*args):
    return _BRepClass3d.HashCode(*args)
HashCode = _BRepClass3d.HashCode

def ptr_equal(a, b):
    return _BRepClass3d.ptr_equal(a, b)
ptr_equal = _BRepClass3d.ptr_equal
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopoDS
else:
    import TopoDS
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import NCollection
else:
    import NCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Standard
else:
    import Standard
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopAbs
else:
    import TopAbs
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Message
else:
    import Message
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColStd
else:
    import TColStd
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TCollection
else:
    import TCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopLoc
else:
    import TopLoc
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import gp
else:
    import gp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import IntCurveSurface
else:
    import IntCurveSurface
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Intf
else:
    import Intf
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Bnd
else:
    import Bnd
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColgp
else:
    import TColgp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import GeomAbs
else:
    import GeomAbs
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import IntAna
else:
    import IntAna
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import IntSurf
else:
    import IntSurf
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Adaptor3d
else:
    import Adaptor3d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Adaptor2d
else:
    import Adaptor2d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Geom2d
else:
    import Geom2d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Geom
else:
    import Geom
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import math
else:
    import math
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import IntCurvesFace
else:
    import IntCurvesFace
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import BRepAdaptor
else:
    import BRepAdaptor
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Geom2dAdaptor
else:
    import Geom2dAdaptor
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import GeomAdaptor
else:
    import GeomAdaptor
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopTools
else:
    import TopTools
del _swig_python_version_info
class NCollection_UBTree_Standard_Integer_Bnd_Box(object):
    """
    The algorithm of unbalanced binary tree of overlapped bounding boxes.

    Once the tree of boxes  of geometric objects is constructed, the algorithm
    is capable of fast geometric selection of objects.  The tree can be easily
    updated by adding to it a new object with bounding box.

    The time of adding to the tree  of one object is O(log(N)), where N is the
    total number of  objects, so the time  of building a tree of  N objects is
    O(N(log(N)). The search time of one object is O(log(N)).

    Defining  various classes  inheriting NCollection_UBTree::Selector  we can
    perform various kinds of selection over the same b-tree object

    The object  may be of any  type allowing copying. Among  the best suitable
    solutions there can  be a pointer to an object,  handled object or integer
    index of object inside some  collection.  The bounding object may have any
    dimension  and  geometry. The  minimal  interface  of TheBndType  (besides
    public empty and copy constructor and operator =) used in UBTree algorithm
    is as the following:
    @code
    class MyBndType
    {
    public:
    inline void                   Add (const MyBndType& other);
    // Updates me with other bounding

    inline Standard_Boolean       IsOut (const MyBndType& other) const;
    // Classifies other bounding relatively me

    inline Standard_Real          SquareExtent() const;
    // Computes the squared maximal linear extent of me.
    // (For box it is the squared diagonal of box)
    };
    @endcode
    To select objects you need to define a class derived from UBTree::Selector
    that  should  redefine  the  necessary  virtual methods  to  maintain  the
    selection condition.  The object  of this class  is also used  to retrieve
    selected objects after search.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        The algorithm of unbalanced binary tree of overlapped bounding boxes.

        Once the tree of boxes  of geometric objects is constructed, the algorithm
        is capable of fast geometric selection of objects.  The tree can be easily
        updated by adding to it a new object with bounding box.

        The time of adding to the tree  of one object is O(log(N)), where N is the
        total number of  objects, so the time  of building a tree of  N objects is
        O(N(log(N)). The search time of one object is O(log(N)).

        Defining  various classes  inheriting NCollection_UBTree::Selector  we can
        perform various kinds of selection over the same b-tree object

        The object  may be of any  type allowing copying. Among  the best suitable
        solutions there can  be a pointer to an object,  handled object or integer
        index of object inside some  collection.  The bounding object may have any
        dimension  and  geometry. The  minimal  interface  of TheBndType  (besides
        public empty and copy constructor and operator =) used in UBTree algorithm
        is as the following:
        @code
        class MyBndType
        {
        public:
        inline void                   Add (const MyBndType& other);
        // Updates me with other bounding

        inline Standard_Boolean       IsOut (const MyBndType& other) const;
        // Classifies other bounding relatively me

        inline Standard_Real          SquareExtent() const;
        // Computes the squared maximal linear extent of me.
        // (For box it is the squared diagonal of box)
        };
        @endcode
        To select objects you need to define a class derived from UBTree::Selector
        that  should  redefine  the  necessary  virtual methods  to  maintain  the
        selection condition.  The object  of this class  is also used  to retrieve
        selected objects after search.
        """
        this = _BRepClass3d.new_NCollection_UBTree_Standard_Integer_Bnd_Box(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Add(self, *args):
        """
        Add(NCollection_UBTree_Standard_Integer_Bnd_Box self, int const & theObj, Bnd_Box theBnd) -> Standard_Boolean

        Update the tree with a new object and its bounding box.
        @param theObj
        added object
        @param theBnd
        bounding box of the object.
        @return
        always True

        :type theObj: const TheObjType &
        :type theBnd: const TheBndType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepClass3d.NCollection_UBTree_Standard_Integer_Bnd_Box_Add(self, *args)


    def Select(self, *args):
        """
        Select(NCollection_UBTree_Standard_Integer_Bnd_Box self, NCollection_UBTree< Standard_Integer,Bnd_Box >::Selector & theSelector) -> Standard_Integer

        Searches in the branch all objects conforming to the given selector.
        @return
        the number of objects accepted

        :type theBranch: OCC.wrapper.NCollection.TreeNode
        :type theSelector: OCC.wrapper.NCollection.Selector
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepClass3d.NCollection_UBTree_Standard_Integer_Bnd_Box_Select(self, *args)


    def Clear(self, *args):
        """
        Clear(NCollection_UBTree_Standard_Integer_Bnd_Box self, Handle_NCollection_BaseAllocator aNewAlloc=0)

        Clears the contents of the tree.
        @param aNewAlloc
        Optional:   a new allocator that will be used when the tree is rebuilt
        anew. This makes sense if the memory allocator needs re-initialisation
        (like NCollection_IncAllocator).  By default the previous allocator is
        kept.

        :type aNewAlloc: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _BRepClass3d.NCollection_UBTree_Standard_Integer_Bnd_Box_Clear(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_UBTree_Standard_Integer_Bnd_Box self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepClass3d.NCollection_UBTree_Standard_Integer_Bnd_Box_IsEmpty(self, *args)


    def Root(self, *args):
        """
        @return
        the root node of the tree

        :rtype: OCC.wrapper.NCollection.TreeNode

        """
        res = _BRepClass3d.NCollection_UBTree_Standard_Integer_Bnd_Box_Root(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Allocator(self, *args):
        """
        Recommended to be used only in sub-classes.
        @return
        Allocator object used in this instance of UBTree.

        :rtype: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        res = _BRepClass3d.NCollection_UBTree_Standard_Integer_Bnd_Box_Allocator(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _BRepClass3d.delete_NCollection_UBTree_Standard_Integer_Bnd_Box
NCollection_UBTree_Standard_Integer_Bnd_Box_swigregister = _BRepClass3d.NCollection_UBTree_Standard_Integer_Bnd_Box_swigregister
NCollection_UBTree_Standard_Integer_Bnd_Box_swigregister(NCollection_UBTree_Standard_Integer_Bnd_Box)


try:
	BRepClass3d_BndBoxTree = NCollection_UBTree_Standard_Integer_Bnd_Box
except NameError:
	pass # does not exist, probably ignored

class BRepClass3d_SClassifier(object):
    """Provides an algorithm to classify a point in a solid."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BRepClass3d_SClassifier self) -> BRepClass3d_SClassifier
        __init__(BRepClass3d_SClassifier self, BRepClass3d_SolidExplorer S, gp_Pnt P, Standard_Real const Tol) -> BRepClass3d_SClassifier

        Constructor to classify the point P with the
        tolerance Tol on the solid S.

        :type S: OCC.wrapper.BRepClass3d.BRepClass3d_SolidExplorer
        :type P: OCC.wrapper.gp.gp_Pnt
        :type Tol: float

        """
        this = _BRepClass3d.new_BRepClass3d_SClassifier(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Perform(self, *args):
        """
        Perform(BRepClass3d_SClassifier self, BRepClass3d_SolidExplorer S, gp_Pnt P, Standard_Real const Tol)

        Classify the point P with the
        tolerance Tol on the solid S.

        :type S: OCC.wrapper.BRepClass3d.BRepClass3d_SolidExplorer
        :type P: OCC.wrapper.gp.gp_Pnt
        :type Tol: float

        """
        return _BRepClass3d.BRepClass3d_SClassifier_Perform(self, *args)


    def PerformInfinitePoint(self, *args):
        """
        PerformInfinitePoint(BRepClass3d_SClassifier self, BRepClass3d_SolidExplorer S, Standard_Real const Tol)

        Classify an infinite point with the
        tolerance Tol on the solid S.

        :type S: OCC.wrapper.BRepClass3d.BRepClass3d_SolidExplorer
        :type Tol: float

        """
        return _BRepClass3d.BRepClass3d_SClassifier_PerformInfinitePoint(self, *args)


    def Rejected(self, *args):
        """
        Rejected(BRepClass3d_SClassifier self) -> Standard_Boolean

        Returns True if the classification has been
        computed by rejection.
        The State is then OUT.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepClass3d.BRepClass3d_SClassifier_Rejected(self, *args)


    def State(self, *args):
        """
        State(BRepClass3d_SClassifier self) -> TopAbs_State

        Returns the result of the classification.

        :rtype: OCC.wrapper.TopAbs.TopAbs_State

        """
        return _BRepClass3d.BRepClass3d_SClassifier_State(self, *args)


    def IsOnAFace(self, *args):
        """
        IsOnAFace(BRepClass3d_SClassifier self) -> Standard_Boolean

        Returns True when the point is a point of a face.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepClass3d.BRepClass3d_SClassifier_IsOnAFace(self, *args)


    def Face(self, *args):
        """
        Face(BRepClass3d_SClassifier self) -> TopoDS_Face

        Returns the face used to determine the
        classification. When the state is ON, this is the
        face containing the point.

        When Rejected() returns True, Face() has no signification.

        :rtype: OCC.wrapper.TopoDS.TopoDS_Face

        """
        return _BRepClass3d.BRepClass3d_SClassifier_Face(self, *args)

    __swig_destroy__ = _BRepClass3d.delete_BRepClass3d_SClassifier
BRepClass3d_SClassifier_swigregister = _BRepClass3d.BRepClass3d_SClassifier_swigregister
BRepClass3d_SClassifier_swigregister(BRepClass3d_SClassifier)

class BRepClass3d_Intersector3d(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BRepClass3d_Intersector3d self) -> BRepClass3d_Intersector3d

        Empty constructor.


        """
        this = _BRepClass3d.new_BRepClass3d_Intersector3d(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Perform(self, *args):
        """
        Perform(BRepClass3d_Intersector3d self, gp_Lin L, Standard_Real const Prm, Standard_Real const Tol, TopoDS_Face F)

        Perform the intersection between the
        segment L(0) ... L(Prm) and the Shape <Sh>.

        Only the point with the smallest parameter on the
        line is returned.

        The Tolerance <Tol> is used to determine if the
        first point of the segment is near the face. In
        that case, the parameter of the intersection point
        on the line can be a negative value (greater than -Tol).

        :type L: OCC.wrapper.gp.gp_Lin
        :type Prm: float
        :type Tol: float
        :type F: OCC.wrapper.TopoDS.TopoDS_Face

        """
        return _BRepClass3d.BRepClass3d_Intersector3d_Perform(self, *args)


    def IsDone(self, *args):
        """
        IsDone(BRepClass3d_Intersector3d self) -> Standard_Boolean

        True is returned when the intersection have been computed.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepClass3d.BRepClass3d_Intersector3d_IsDone(self, *args)


    def HasAPoint(self, *args):
        """
        HasAPoint(BRepClass3d_Intersector3d self) -> Standard_Boolean

        True is returned if a point has been found.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepClass3d.BRepClass3d_Intersector3d_HasAPoint(self, *args)


    def UParameter(self, *args):
        """
        UParameter(BRepClass3d_Intersector3d self) -> Standard_Real

        Returns the U parameter of the intersection point
        on the surface.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _BRepClass3d.BRepClass3d_Intersector3d_UParameter(self, *args)


    def VParameter(self, *args):
        """
        VParameter(BRepClass3d_Intersector3d self) -> Standard_Real

        Returns the V parameter of the intersection point
        on the surface.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _BRepClass3d.BRepClass3d_Intersector3d_VParameter(self, *args)


    def WParameter(self, *args):
        """
        WParameter(BRepClass3d_Intersector3d self) -> Standard_Real

        Returns the parameter of the intersection point
        on the line.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _BRepClass3d.BRepClass3d_Intersector3d_WParameter(self, *args)


    def Pnt(self, *args):
        """
        Returns the geometric point of the intersection
        between the line and the surface.

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        res = _BRepClass3d.BRepClass3d_Intersector3d_Pnt(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Transition(self, *args):
        """
        Transition(BRepClass3d_Intersector3d self) -> IntCurveSurface_TransitionOnCurve

        Returns the transition of the line on the surface.

        :rtype: OCC.wrapper.IntCurveSurface.IntCurveSurface_TransitionOnCurve

        """
        return _BRepClass3d.BRepClass3d_Intersector3d_Transition(self, *args)


    def State(self, *args):
        """
        State(BRepClass3d_Intersector3d self) -> TopAbs_State

        Returns the state of the point on the face.
        The values can be either TopAbs_IN
        ( the point is in the face)
        or TopAbs_ON
        ( the point is on a boudary of the face).

        :rtype: OCC.wrapper.TopAbs.TopAbs_State

        """
        return _BRepClass3d.BRepClass3d_Intersector3d_State(self, *args)


    def Face(self, *args):
        """
        Returns the significant face used to determine
        the intersection.

        :rtype: OCC.wrapper.TopoDS.TopoDS_Face

        """
        res = _BRepClass3d.BRepClass3d_Intersector3d_Face(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _BRepClass3d.delete_BRepClass3d_Intersector3d
BRepClass3d_Intersector3d_swigregister = _BRepClass3d.BRepClass3d_Intersector3d_swigregister
BRepClass3d_Intersector3d_swigregister(BRepClass3d_Intersector3d)

class BRepClass3d_SolidExplorer(object):
    """
    Provide an exploration of a BRep Shape for the classification.
    Provide access to the special UB tree to obtain fast search.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BRepClass3d_SolidExplorer self) -> BRepClass3d_SolidExplorer
        __init__(BRepClass3d_SolidExplorer self, TopoDS_Shape S) -> BRepClass3d_SolidExplorer

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        this = _BRepClass3d.new_BRepClass3d_SolidExplorer(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def InitShape(self, *args):
        """
        InitShape(BRepClass3d_SolidExplorer self, TopoDS_Shape S)

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _BRepClass3d.BRepClass3d_SolidExplorer_InitShape(self, *args)


    def Reject(self, *args):
        """
        Reject(BRepClass3d_SolidExplorer self, gp_Pnt P) -> Standard_Boolean

        Should return True if P outside of bounding vol. of the shape

        :type P: OCC.wrapper.gp.gp_Pnt
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepClass3d.BRepClass3d_SolidExplorer_Reject(self, *args)


    def FindAPointInTheFace(*args):
        """
        FindAPointInTheFace(TopoDS_Face F, gp_Pnt P) -> Standard_Boolean
        FindAPointInTheFace(TopoDS_Face F, gp_Pnt P) -> Standard_Boolean
        FindAPointInTheFace(TopoDS_Face F, gp_Pnt P, gp_Vec theVecD1U, gp_Vec theVecD1V) -> Standard_Boolean
        FindAPointInTheFace(TopoDS_Face F, gp_Pnt P) -> Standard_Boolean
        FindAPointInTheFace(TopoDS_Face F, gp_Pnt P) -> Standard_Boolean
        FindAPointInTheFace(TopoDS_Face F) -> Standard_Boolean

        :type F: OCC.wrapper.TopoDS.TopoDS_Face
        :type u: float
        :type v: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepClass3d.BRepClass3d_SolidExplorer_FindAPointInTheFace(*args)

    FindAPointInTheFace = staticmethod(FindAPointInTheFace)

    def PointInTheFace(self, *args):
        """
        PointInTheFace(BRepClass3d_SolidExplorer self, TopoDS_Face F, gp_Pnt P) -> Standard_Boolean
        PointInTheFace(BRepClass3d_SolidExplorer self, TopoDS_Face F, gp_Pnt P, Handle_BRepAdaptor_HSurface surf, Standard_Real const u1, Standard_Real const v1, Standard_Real const u2, Standard_Real const v2) -> Standard_Boolean
        PointInTheFace(BRepClass3d_SolidExplorer self, TopoDS_Face F, gp_Pnt P, Handle_BRepAdaptor_HSurface surf, Standard_Real const u1, Standard_Real const v1, Standard_Real const u2, Standard_Real const v2, gp_Vec theVecD1U, gp_Vec theVecD1V) -> Standard_Boolean

        <Index> gives point index  to  search from and returns
        point index of succeseful search

        :type F: OCC.wrapper.TopoDS.TopoDS_Face
        :type P: OCC.wrapper.gp.gp_Pnt
        :type u: float
        :type v: float
        :type Param: float
        :type Index: int
        :type surf: OCC.wrapper.BRepAdaptor.Handle_BRepAdaptor_HSurface
        :type u1: float
        :type v1: float
        :type u2: float
        :type v2: float
        :type theVecD1U: OCC.wrapper.gp.gp_Vec
        :type theVecD1V: OCC.wrapper.gp.gp_Vec
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepClass3d.BRepClass3d_SolidExplorer_PointInTheFace(self, *args)


    def InitShell(self, *args):
        """
        InitShell(BRepClass3d_SolidExplorer self)

        Starts an exploration of the shells.


        """
        return _BRepClass3d.BRepClass3d_SolidExplorer_InitShell(self, *args)


    def MoreShell(self, *args):
        """
        MoreShell(BRepClass3d_SolidExplorer self) -> Standard_Boolean

        Returns True if there is a current shell.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepClass3d.BRepClass3d_SolidExplorer_MoreShell(self, *args)


    def NextShell(self, *args):
        """
        NextShell(BRepClass3d_SolidExplorer self)

        Sets the explorer to the next shell.


        """
        return _BRepClass3d.BRepClass3d_SolidExplorer_NextShell(self, *args)


    def CurrentShell(self, *args):
        """
        CurrentShell(BRepClass3d_SolidExplorer self) -> TopoDS_Shell

        Returns the current shell.

        :rtype: OCC.wrapper.TopoDS.TopoDS_Shell

        """
        return _BRepClass3d.BRepClass3d_SolidExplorer_CurrentShell(self, *args)


    def RejectShell(self, *args):
        """
        RejectShell(BRepClass3d_SolidExplorer self, gp_Lin L) -> Standard_Boolean

        Returns True if the Shell is rejected.

        :type L: OCC.wrapper.gp.gp_Lin
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepClass3d.BRepClass3d_SolidExplorer_RejectShell(self, *args)


    def InitFace(self, *args):
        """
        InitFace(BRepClass3d_SolidExplorer self)

        Starts an exploration of the faces of the current shell.


        """
        return _BRepClass3d.BRepClass3d_SolidExplorer_InitFace(self, *args)


    def MoreFace(self, *args):
        """
        MoreFace(BRepClass3d_SolidExplorer self) -> Standard_Boolean

        Returns True if current face in current shell.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepClass3d.BRepClass3d_SolidExplorer_MoreFace(self, *args)


    def NextFace(self, *args):
        """
        NextFace(BRepClass3d_SolidExplorer self)

        Sets the explorer to the next Face of the current shell.


        """
        return _BRepClass3d.BRepClass3d_SolidExplorer_NextFace(self, *args)


    def CurrentFace(self, *args):
        """
        CurrentFace(BRepClass3d_SolidExplorer self) -> TopoDS_Face

        Returns the current face.

        :rtype: OCC.wrapper.TopoDS.TopoDS_Face

        """
        return _BRepClass3d.BRepClass3d_SolidExplorer_CurrentFace(self, *args)


    def RejectFace(self, *args):
        """
        RejectFace(BRepClass3d_SolidExplorer self, gp_Lin L) -> Standard_Boolean

        returns True if the face is rejected.

        :type L: OCC.wrapper.gp.gp_Lin
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepClass3d.BRepClass3d_SolidExplorer_RejectFace(self, *args)


    def Segment(self, *args):
        """
        Segment(BRepClass3d_SolidExplorer self, gp_Pnt P, gp_Lin L) -> Standard_Integer

        Returns  in <L>, <Par>  a segment having at least
        one  intersection  with  the  shape  boundary  to
        compute  intersections.

        :type P: OCC.wrapper.gp.gp_Pnt
        :type L: OCC.wrapper.gp.gp_Lin
        :type Par: float
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepClass3d.BRepClass3d_SolidExplorer_Segment(self, *args)


    def OtherSegment(self, *args):
        """
        OtherSegment(BRepClass3d_SolidExplorer self, gp_Pnt P, gp_Lin L) -> Standard_Integer

        Returns  in <L>, <Par>  a segment having at least
        one  intersection  with  the  shape  boundary  to
        compute  intersections.

        The First Call to this method returns a line which
        point to a point of the first face of the shape.
        The Second Call provide a line to the second face
        and so on.

        :type P: OCC.wrapper.gp.gp_Pnt
        :type L: OCC.wrapper.gp.gp_Lin
        :type Par: float
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepClass3d.BRepClass3d_SolidExplorer_OtherSegment(self, *args)


    def GetFaceSegmentIndex(self, *args):
        """
        GetFaceSegmentIndex(BRepClass3d_SolidExplorer self) -> Standard_Integer

        Returns the index of face for which
        last segment is calculated.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepClass3d.BRepClass3d_SolidExplorer_GetFaceSegmentIndex(self, *args)


    def DumpSegment(self, *args):
        """
        DumpSegment(BRepClass3d_SolidExplorer self, gp_Pnt P, gp_Lin L, Standard_Real const Par, TopAbs_State const S)

        :type P: OCC.wrapper.gp.gp_Pnt
        :type L: OCC.wrapper.gp.gp_Lin
        :type Par: float
        :type S: OCC.wrapper.TopAbs.TopAbs_State

        """
        return _BRepClass3d.BRepClass3d_SolidExplorer_DumpSegment(self, *args)


    def Box(self, *args):
        """
        :rtype: OCC.wrapper.Bnd.Bnd_Box

        """
        res = _BRepClass3d.BRepClass3d_SolidExplorer_Box(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def GetShape(self, *args):
        """
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _BRepClass3d.BRepClass3d_SolidExplorer_GetShape(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Intersector(self, *args):
        """
        Intersector(BRepClass3d_SolidExplorer self, TopoDS_Face F) -> IntCurvesFace_Intersector

        :type F: OCC.wrapper.TopoDS.TopoDS_Face
        :rtype: OCC.wrapper.IntCurvesFace.IntCurvesFace_Intersector

        """
        return _BRepClass3d.BRepClass3d_SolidExplorer_Intersector(self, *args)


    def GetTree(self, *args):
        """
        Return UB-tree instance which is used for edge / vertex checks.

        :rtype: OCC.wrapper.BRepClass3d.BRepClass3d_BndBoxTree

        """
        res = _BRepClass3d.BRepClass3d_SolidExplorer_GetTree(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def GetMapEV(self, *args):
        """
        Return edge/vertices map for current shape.

        :rtype: OCC.wrapper.TopTools.TopTools_IndexedMapOfShape

        """
        res = _BRepClass3d.BRepClass3d_SolidExplorer_GetMapEV(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Destroy(self, *args):
        """Destroy(BRepClass3d_SolidExplorer self)"""
        return _BRepClass3d.BRepClass3d_SolidExplorer_Destroy(self, *args)

    __swig_destroy__ = _BRepClass3d.delete_BRepClass3d_SolidExplorer
BRepClass3d_SolidExplorer_swigregister = _BRepClass3d.BRepClass3d_SolidExplorer_swigregister
BRepClass3d_SolidExplorer_swigregister(BRepClass3d_SolidExplorer)

def BRepClass3d_SolidExplorer_FindAPointInTheFace(*args):
    """
    FindAPointInTheFace(TopoDS_Face F, gp_Pnt P) -> Standard_Boolean
    FindAPointInTheFace(TopoDS_Face F, gp_Pnt P) -> Standard_Boolean
    FindAPointInTheFace(TopoDS_Face F, gp_Pnt P, gp_Vec theVecD1U, gp_Vec theVecD1V) -> Standard_Boolean
    FindAPointInTheFace(TopoDS_Face F, gp_Pnt P) -> Standard_Boolean
    FindAPointInTheFace(TopoDS_Face F, gp_Pnt P) -> Standard_Boolean
    BRepClass3d_SolidExplorer_FindAPointInTheFace(TopoDS_Face F) -> Standard_Boolean

    :type F: OCC.wrapper.TopoDS.TopoDS_Face
    :type u: float
    :type v: float
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _BRepClass3d.BRepClass3d_SolidExplorer_FindAPointInTheFace(*args)

class BRepClass3d_(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def OuterShell(*args):
        """
        OuterShell(TopoDS_Solid S) -> TopoDS_Shell

        Returns the outer most shell of <S>. Returns a Null
        shell if <S> has no outer shell.
        If <S> has only one shell, then it will return, without checking orientation.

        :type S: OCC.wrapper.TopoDS.TopoDS_Solid
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shell

        """
        return _BRepClass3d.BRepClass3d__OuterShell(*args)

    OuterShell = staticmethod(OuterShell)

    def __init__(self):
        this = _BRepClass3d.new_BRepClass3d_()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _BRepClass3d.delete_BRepClass3d_
BRepClass3d__swigregister = _BRepClass3d.BRepClass3d__swigregister
BRepClass3d__swigregister(BRepClass3d_)

def BRepClass3d__OuterShell(*args):
    """
    BRepClass3d__OuterShell(TopoDS_Solid S) -> TopoDS_Shell

    Returns the outer most shell of <S>. Returns a Null
    shell if <S> has no outer shell.
    If <S> has only one shell, then it will return, without checking orientation.

    :type S: OCC.wrapper.TopoDS.TopoDS_Solid
    :rtype: OCC.wrapper.TopoDS.TopoDS_Shell

    """
    return _BRepClass3d.BRepClass3d__OuterShell(*args)

class BRepClass3d_SolidPassiveClassifier(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BRepClass3d_SolidPassiveClassifier self) -> BRepClass3d_SolidPassiveClassifier

        Creates an undefined classifier.


        """
        this = _BRepClass3d.new_BRepClass3d_SolidPassiveClassifier(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Reset(self, *args):
        """
        Reset(BRepClass3d_SolidPassiveClassifier self, gp_Lin L, Standard_Real const P, Standard_Real const Tol)

        Starts  a  classification process.   The  point to
        classify is the origin of  the  line <L>.  <P>  is
        the original length of the segment on <L>  used to
        compute  intersections.   <Tol> is the   tolerance
        attached to the intersections.

        :type L: OCC.wrapper.gp.gp_Lin
        :type P: float
        :type Tol: float

        """
        return _BRepClass3d.BRepClass3d_SolidPassiveClassifier_Reset(self, *args)


    def Compare(self, *args):
        """
        Compare(BRepClass3d_SolidPassiveClassifier self, TopoDS_Face F, TopAbs_Orientation const Or)

        Updates  the classification process with  the face
        <F> from the boundary.

        :type F: OCC.wrapper.TopoDS.TopoDS_Face
        :type Or: OCC.wrapper.TopAbs.TopAbs_Orientation

        """
        return _BRepClass3d.BRepClass3d_SolidPassiveClassifier_Compare(self, *args)


    def Parameter(self, *args):
        """
        Parameter(BRepClass3d_SolidPassiveClassifier self) -> Standard_Real

        Returns the current value of the parameter.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _BRepClass3d.BRepClass3d_SolidPassiveClassifier_Parameter(self, *args)


    def HasIntersection(self, *args):
        """
        HasIntersection(BRepClass3d_SolidPassiveClassifier self) -> Standard_Boolean

        Returns True if an intersection is computed.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepClass3d.BRepClass3d_SolidPassiveClassifier_HasIntersection(self, *args)


    def Intersector(self, *args):
        """
        Intersector(BRepClass3d_SolidPassiveClassifier self) -> BRepClass3d_Intersector3d

        Returns the intersecting algorithm.

        :rtype: OCC.wrapper.BRepClass3d.BRepClass3d_Intersector3d

        """
        return _BRepClass3d.BRepClass3d_SolidPassiveClassifier_Intersector(self, *args)


    def State(self, *args):
        """
        State(BRepClass3d_SolidPassiveClassifier self) -> TopAbs_State

        Returns the current state of the point.

        :rtype: OCC.wrapper.TopAbs.TopAbs_State

        """
        return _BRepClass3d.BRepClass3d_SolidPassiveClassifier_State(self, *args)

    __swig_destroy__ = _BRepClass3d.delete_BRepClass3d_SolidPassiveClassifier
BRepClass3d_SolidPassiveClassifier_swigregister = _BRepClass3d.BRepClass3d_SolidPassiveClassifier_swigregister
BRepClass3d_SolidPassiveClassifier_swigregister(BRepClass3d_SolidPassiveClassifier)

class BRepClass3d_SolidClassifier(BRepClass3d_SClassifier):
    """Provides an algorithm to classify a point in a solid."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Load(self, *args):
        """
        Load(BRepClass3d_SolidClassifier self, TopoDS_Shape S)

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _BRepClass3d.BRepClass3d_SolidClassifier_Load(self, *args)


    def __init__(self, *args):
        """
        __init__(BRepClass3d_SolidClassifier self) -> BRepClass3d_SolidClassifier
        __init__(BRepClass3d_SolidClassifier self, TopoDS_Shape S) -> BRepClass3d_SolidClassifier
        __init__(BRepClass3d_SolidClassifier self, TopoDS_Shape S, gp_Pnt P, Standard_Real const Tol) -> BRepClass3d_SolidClassifier

        Constructor to classify the point P with the
        tolerance Tol on the solid S.

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :type P: OCC.wrapper.gp.gp_Pnt
        :type Tol: float

        """
        this = _BRepClass3d.new_BRepClass3d_SolidClassifier(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Perform(self, *args):
        """
        Perform(BRepClass3d_SolidClassifier self, gp_Pnt P, Standard_Real const Tol)

        Classify the point P with the
        tolerance Tol on the solid S.

        :type P: OCC.wrapper.gp.gp_Pnt
        :type Tol: float

        """
        return _BRepClass3d.BRepClass3d_SolidClassifier_Perform(self, *args)


    def PerformInfinitePoint(self, *args):
        """
        PerformInfinitePoint(BRepClass3d_SolidClassifier self, Standard_Real const Tol)

        Classify an infinite point with the
        tolerance Tol on the solid S.
        Useful for compute the orientation of a solid.

        :type Tol: float

        """
        return _BRepClass3d.BRepClass3d_SolidClassifier_PerformInfinitePoint(self, *args)


    def Destroy(self, *args):
        """Destroy(BRepClass3d_SolidClassifier self)"""
        return _BRepClass3d.BRepClass3d_SolidClassifier_Destroy(self, *args)

    __swig_destroy__ = _BRepClass3d.delete_BRepClass3d_SolidClassifier
BRepClass3d_SolidClassifier_swigregister = _BRepClass3d.BRepClass3d_SolidClassifier_swigregister
BRepClass3d_SolidClassifier_swigregister(BRepClass3d_SolidClassifier)

class NCollection_DataMap_TopoDS_Shape_Standard_Address_TopTools_ShapeMapHasher(NCollection.NCollection_BaseMap):
    """
    Purpose:     The DataMap is a Map to store keys with associated
    Items. See Map  from NCollection for  a discussion
    about the number of buckets.

    The DataMap can be seen as an extended array where
    the Keys  are the   indices.  For this reason  the
    operator () is defined on DataMap to fetch an Item
    from a Key. So the following syntax can be used :

    anItem = aMap(aKey);
    aMap(aKey) = anItem;

    This analogy has its  limit.   aMap(aKey) = anItem
    can  be done only  if aKey was previously bound to
    an item in the map.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_DataMap_TopoDS_Shape_Standard_Address_TopTools_ShapeMapHasher self) -> NCollection_DataMap< TopoDS_Shape,void *,TopTools_ShapeMapHasher >::iterator

        Returns an iterator pointing to the first element in the map.

        :rtype: iterator

        """
        return _BRepClass3d.NCollection_DataMap_TopoDS_Shape_Standard_Address_TopTools_ShapeMapHasher_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_DataMap_TopoDS_Shape_Standard_Address_TopTools_ShapeMapHasher self) -> NCollection_DataMap< TopoDS_Shape,void *,TopTools_ShapeMapHasher >::iterator

        Returns an iterator referring to the past-the-end element in the map.

        :rtype: iterator

        """
        return _BRepClass3d.NCollection_DataMap_TopoDS_Shape_Standard_Address_TopTools_ShapeMapHasher_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_DataMap_TopoDS_Shape_Standard_Address_TopTools_ShapeMapHasher self) -> NCollection_DataMap< TopoDS_Shape,void *,TopTools_ShapeMapHasher >::const_iterator

        Returns a const iterator pointing to the first element in the map.

        :rtype: const_iterator

        """
        return _BRepClass3d.NCollection_DataMap_TopoDS_Shape_Standard_Address_TopTools_ShapeMapHasher_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_DataMap_TopoDS_Shape_Standard_Address_TopTools_ShapeMapHasher self) -> NCollection_DataMap< TopoDS_Shape,void *,TopTools_ShapeMapHasher >::const_iterator

        Returns a const iterator referring to the past-the-end element in the map.

        :rtype: const_iterator

        """
        return _BRepClass3d.NCollection_DataMap_TopoDS_Shape_Standard_Address_TopTools_ShapeMapHasher_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     The DataMap is a Map to store keys with associated
        Items. See Map  from NCollection for  a discussion
        about the number of buckets.

        The DataMap can be seen as an extended array where
        the Keys  are the   indices.  For this reason  the
        operator () is defined on DataMap to fetch an Item
        from a Key. So the following syntax can be used :

        anItem = aMap(aKey);
        aMap(aKey) = anItem;

        This analogy has its  limit.   aMap(aKey) = anItem
        can  be done only  if aKey was previously bound to
        an item in the map.
        """
        this = _BRepClass3d.new_NCollection_DataMap_TopoDS_Shape_Standard_Address_TopTools_ShapeMapHasher(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Exchange(self, *args):
        """
        Exchange(NCollection_DataMap_TopoDS_Shape_Standard_Address_TopTools_ShapeMapHasher self, NCollection_DataMap_TopoDS_Shape_Standard_Address_TopTools_ShapeMapHasher theOther)

        Exchange the content of two maps without re-allocations.
        Notice that allocators will be swapped as well!

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _BRepClass3d.NCollection_DataMap_TopoDS_Shape_Standard_Address_TopTools_ShapeMapHasher_Exchange(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_DataMap_TopoDS_Shape_Standard_Address_TopTools_ShapeMapHasher self, NCollection_DataMap_TopoDS_Shape_Standard_Address_TopTools_ShapeMapHasher theOther) -> NCollection_DataMap_TopoDS_Shape_Standard_Address_TopTools_ShapeMapHasher

        Assignment.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _BRepClass3d.NCollection_DataMap_TopoDS_Shape_Standard_Address_TopTools_ShapeMapHasher_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_DataMap_TopoDS_Shape_Standard_Address_TopTools_ShapeMapHasher self, NCollection_DataMap_TopoDS_Shape_Standard_Address_TopTools_ShapeMapHasher theOther) -> NCollection_DataMap_TopoDS_Shape_Standard_Address_TopTools_ShapeMapHasher

        Assignment operator

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _BRepClass3d.NCollection_DataMap_TopoDS_Shape_Standard_Address_TopTools_ShapeMapHasher_assign(self, *args)


    def ReSize(self, *args):
        """
        ReSize(NCollection_DataMap_TopoDS_Shape_Standard_Address_TopTools_ShapeMapHasher self, Standard_Integer const N)

        ReSize

        :type N: int

        """
        return _BRepClass3d.NCollection_DataMap_TopoDS_Shape_Standard_Address_TopTools_ShapeMapHasher_ReSize(self, *args)


    def Bind(self, *args):
        """
        Bind(NCollection_DataMap_TopoDS_Shape_Standard_Address_TopTools_ShapeMapHasher self, TopoDS_Shape theKey, void *const & theItem) -> Standard_Boolean

        Bind binds Item to Key in map.
        @param theKey  key to add/update
        @param theItem new item; overrides value previously bound to the key, if any
        @return Standard_True if Key was not bound already

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepClass3d.NCollection_DataMap_TopoDS_Shape_Standard_Address_TopTools_ShapeMapHasher_Bind(self, *args)


    def Bound(self, *args):
        """
        Bound(NCollection_DataMap_TopoDS_Shape_Standard_Address_TopTools_ShapeMapHasher self, TopoDS_Shape theKey, void *const & theItem) -> void **

        Bound binds Item to Key in map. Returns modifiable Item 

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: TheItemType *

        """
        return _BRepClass3d.NCollection_DataMap_TopoDS_Shape_Standard_Address_TopTools_ShapeMapHasher_Bound(self, *args)


    def IsBound(self, *args):
        """
        IsBound(NCollection_DataMap_TopoDS_Shape_Standard_Address_TopTools_ShapeMapHasher self, TopoDS_Shape theKey) -> Standard_Boolean

        IsBound

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepClass3d.NCollection_DataMap_TopoDS_Shape_Standard_Address_TopTools_ShapeMapHasher_IsBound(self, *args)


    def UnBind(self, *args):
        """
        UnBind(NCollection_DataMap_TopoDS_Shape_Standard_Address_TopTools_ShapeMapHasher self, TopoDS_Shape theKey) -> Standard_Boolean

        UnBind removes Item Key pair from map

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepClass3d.NCollection_DataMap_TopoDS_Shape_Standard_Address_TopTools_ShapeMapHasher_UnBind(self, *args)


    def Seek(self, *args):
        """
        Seek(NCollection_DataMap_TopoDS_Shape_Standard_Address_TopTools_ShapeMapHasher self, TopoDS_Shape theKey) -> void *const *

        Seek returns pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: const TheItemType *

        """
        return _BRepClass3d.NCollection_DataMap_TopoDS_Shape_Standard_Address_TopTools_ShapeMapHasher_Seek(self, *args)


    def Find(self, *args):
        """
        Find returns the Item for Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _BRepClass3d.NCollection_DataMap_TopoDS_Shape_Standard_Address_TopTools_ShapeMapHasher_Find(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeSeek(self, *args):
        """
        ChangeSeek(NCollection_DataMap_TopoDS_Shape_Standard_Address_TopTools_ShapeMapHasher self, TopoDS_Shape theKey) -> void **

        ChangeSeek returns modifiable pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: TheItemType *

        """
        return _BRepClass3d.NCollection_DataMap_TopoDS_Shape_Standard_Address_TopTools_ShapeMapHasher_ChangeSeek(self, *args)


    def ChangeFind(self, *args):
        """
        ChangeFind(NCollection_DataMap_TopoDS_Shape_Standard_Address_TopTools_ShapeMapHasher self, TopoDS_Shape theKey) -> void *&

        ChangeFind returns mofifiable Item by Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: TheItemType &

        """
        return _BRepClass3d.NCollection_DataMap_TopoDS_Shape_Standard_Address_TopTools_ShapeMapHasher_ChangeFind(self, *args)


    def __call__(self, *args):
        """
        operator ()

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _BRepClass3d.NCollection_DataMap_TopoDS_Shape_Standard_Address_TopTools_ShapeMapHasher___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Clear(self, *args):
        """
        Clear(NCollection_DataMap_TopoDS_Shape_Standard_Address_TopTools_ShapeMapHasher self, Standard_Boolean const doReleaseMemory)
        Clear(NCollection_DataMap_TopoDS_Shape_Standard_Address_TopTools_ShapeMapHasher self, Handle_NCollection_BaseAllocator theAllocator)

        Clear data and reset allocator

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _BRepClass3d.NCollection_DataMap_TopoDS_Shape_Standard_Address_TopTools_ShapeMapHasher_Clear(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_DataMap_TopoDS_Shape_Standard_Address_TopTools_ShapeMapHasher self) -> Standard_Integer

        Size

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepClass3d.NCollection_DataMap_TopoDS_Shape_Standard_Address_TopTools_ShapeMapHasher_Size(self, *args)


    def __iter__(self):
        return _BRepClass3d.NCollection_DataMap_TopoDS_Shape_Standard_Address_TopTools_ShapeMapHasher___iter__(self)
    __swig_destroy__ = _BRepClass3d.delete_NCollection_DataMap_TopoDS_Shape_Standard_Address_TopTools_ShapeMapHasher
NCollection_DataMap_TopoDS_Shape_Standard_Address_TopTools_ShapeMapHasher_swigregister = _BRepClass3d.NCollection_DataMap_TopoDS_Shape_Standard_Address_TopTools_ShapeMapHasher_swigregister
NCollection_DataMap_TopoDS_Shape_Standard_Address_TopTools_ShapeMapHasher_swigregister(NCollection_DataMap_TopoDS_Shape_Standard_Address_TopTools_ShapeMapHasher)

class NCollection_DataMap_TopoDS_Shape_Standard_Address_TopTools_ShapeMapHasher_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _BRepClass3d.new_NCollection_DataMap_TopoDS_Shape_Standard_Address_TopTools_ShapeMapHasher_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _BRepClass3d.delete_NCollection_DataMap_TopoDS_Shape_Standard_Address_TopTools_ShapeMapHasher_IteratorHelper

    def __next__(self):
        return _BRepClass3d.NCollection_DataMap_TopoDS_Shape_Standard_Address_TopTools_ShapeMapHasher_IteratorHelper___next__(self)
NCollection_DataMap_TopoDS_Shape_Standard_Address_TopTools_ShapeMapHasher_IteratorHelper_swigregister = _BRepClass3d.NCollection_DataMap_TopoDS_Shape_Standard_Address_TopTools_ShapeMapHasher_IteratorHelper_swigregister
NCollection_DataMap_TopoDS_Shape_Standard_Address_TopTools_ShapeMapHasher_IteratorHelper_swigregister(NCollection_DataMap_TopoDS_Shape_Standard_Address_TopTools_ShapeMapHasher_IteratorHelper)


try:
	BRepClass3d_MapOfInter = NCollection_DataMap_TopoDS_Shape_Standard_Address_TopTools_ShapeMapHasher
except NameError:
	pass # does not exist, probably ignored




# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_VrmlData')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_VrmlData')
    _VrmlData = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_VrmlData', [dirname(__file__)])
        except ImportError:
            import _VrmlData
            return _VrmlData
        try:
            _mod = imp.load_module('_VrmlData', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _VrmlData = swig_import_helper()
    del swig_import_helper
else:
    import _VrmlData
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


class SwigPyIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _VrmlData.delete_SwigPyIterator

    def value(self):
        return _VrmlData.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _VrmlData.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _VrmlData.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _VrmlData.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _VrmlData.SwigPyIterator_equal(self, x)

    def copy(self):
        return _VrmlData.SwigPyIterator_copy(self)

    def next(self):
        return _VrmlData.SwigPyIterator_next(self)

    def __next__(self):
        return _VrmlData.SwigPyIterator___next__(self)

    def previous(self):
        return _VrmlData.SwigPyIterator_previous(self)

    def advance(self, n):
        return _VrmlData.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _VrmlData.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _VrmlData.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _VrmlData.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _VrmlData.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _VrmlData.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _VrmlData.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self
SwigPyIterator_swigregister = _VrmlData.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

class NCollection_CellFilter_InspectorXYZ(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _VrmlData.NCollection_CellFilter_InspectorXYZ_Dimension
    Coord = staticmethod(_VrmlData.NCollection_CellFilter_InspectorXYZ_Coord)

    def Shift(self, thePnt, theTol):
        return _VrmlData.NCollection_CellFilter_InspectorXYZ_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _VrmlData.new_NCollection_CellFilter_InspectorXYZ()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _VrmlData.delete_NCollection_CellFilter_InspectorXYZ
NCollection_CellFilter_InspectorXYZ_swigregister = _VrmlData.NCollection_CellFilter_InspectorXYZ_swigregister
NCollection_CellFilter_InspectorXYZ_swigregister(NCollection_CellFilter_InspectorXYZ)

def NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt):
    return _VrmlData.NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt)
NCollection_CellFilter_InspectorXYZ_Coord = _VrmlData.NCollection_CellFilter_InspectorXYZ_Coord

class NCollection_CellFilter_InspectorXY(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _VrmlData.NCollection_CellFilter_InspectorXY_Dimension
    Coord = staticmethod(_VrmlData.NCollection_CellFilter_InspectorXY_Coord)

    def Shift(self, thePnt, theTol):
        return _VrmlData.NCollection_CellFilter_InspectorXY_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _VrmlData.new_NCollection_CellFilter_InspectorXY()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _VrmlData.delete_NCollection_CellFilter_InspectorXY
NCollection_CellFilter_InspectorXY_swigregister = _VrmlData.NCollection_CellFilter_InspectorXY_swigregister
NCollection_CellFilter_InspectorXY_swigregister(NCollection_CellFilter_InspectorXY)

def NCollection_CellFilter_InspectorXY_Coord(i, thePnt):
    return _VrmlData.NCollection_CellFilter_InspectorXY_Coord(i, thePnt)
NCollection_CellFilter_InspectorXY_Coord = _VrmlData.NCollection_CellFilter_InspectorXY_Coord


def ptr_to_number(item):
    return _VrmlData.ptr_to_number(item)
ptr_to_number = _VrmlData.ptr_to_number

def HashCode(*args):
    return _VrmlData.HashCode(*args)
HashCode = _VrmlData.HashCode

def ptr_equal(a, b):
    return _VrmlData.ptr_equal(a, b)
ptr_equal = _VrmlData.ptr_equal
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import NCollection
else:
    import NCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Standard
else:
    import Standard
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import gp
else:
    import gp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColStd
else:
    import TColStd
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TCollection
else:
    import TCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Bnd
else:
    import Bnd
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColgp
else:
    import TColgp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Poly
else:
    import Poly
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TShort
else:
    import TShort
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopoDS
else:
    import TopoDS
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopAbs
else:
    import TopAbs
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Message
else:
    import Message
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopLoc
else:
    import TopLoc
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Quantity
else:
    import Quantity
del _swig_python_version_info
VrmlData_StatusOK = _VrmlData.VrmlData_StatusOK
VrmlData_EmptyData = _VrmlData.VrmlData_EmptyData
VrmlData_UnrecoverableError = _VrmlData.VrmlData_UnrecoverableError
VrmlData_GeneralError = _VrmlData.VrmlData_GeneralError
VrmlData_EndOfFile = _VrmlData.VrmlData_EndOfFile
VrmlData_NotVrmlFile = _VrmlData.VrmlData_NotVrmlFile
VrmlData_CannotOpenFile = _VrmlData.VrmlData_CannotOpenFile
VrmlData_VrmlFormatError = _VrmlData.VrmlData_VrmlFormatError
VrmlData_NumericInputError = _VrmlData.VrmlData_NumericInputError
VrmlData_IrrelevantNumber = _VrmlData.VrmlData_IrrelevantNumber
VrmlData_BooleanInputError = _VrmlData.VrmlData_BooleanInputError
VrmlData_StringInputError = _VrmlData.VrmlData_StringInputError
VrmlData_NodeNameUnknown = _VrmlData.VrmlData_NodeNameUnknown
VrmlData_NonPositiveSize = _VrmlData.VrmlData_NonPositiveSize
VrmlData_ReadUnknownNode = _VrmlData.VrmlData_ReadUnknownNode
VrmlData_NonSupportedFeature = _VrmlData.VrmlData_NonSupportedFeature
VrmlData_OutputStreamUndefined = _VrmlData.VrmlData_OutputStreamUndefined
VrmlData_NotImplemented = _VrmlData.VrmlData_NotImplemented
class VrmlData_Node(Standard.Standard_Transient):
    """Abstract VRML Node"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_VrmlData_Node
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_VrmlData_Node(self) 
            return h


    def Scene(self, *args):
        """
        Query the Scene that contains this Node

        :rtype: OCC.wrapper.VrmlData.VrmlData_Scene

        """
        res = _VrmlData.VrmlData_Node_Scene(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Name(self, *args):
        """
        Name(VrmlData_Node self) -> char const *

        Query the name

        :rtype: const char *

        """
        return _VrmlData.VrmlData_Node_Name(self, *args)


    def ReadNode(self, *args):
        """
        ReadNode(VrmlData_Node self, VrmlData_InBuffer & theBuffer, Handle_VrmlData_Node theNode, Handle_Standard_Type Type=0) -> VrmlData_ErrorStatus

        Read a complete node definition from VRML stream
        @param theBuffer
        Buffer receiving the input data.
        @param theNode
        <tt>[out]</tt> Node restored from the buffer data
        @param Type
        Node type to be checked. If it is NULL(default) no type checking is done.
        Otherwise the created node is matched and an error is returned if
        no match detected.

        :type theBuffer: OCC.wrapper.VrmlData.VrmlData_InBuffer
        :type theNode: OCC.wrapper.VrmlData.Handle_VrmlData_Node
        :type Type: OCC.wrapper.Standard.Handle_Standard_Type
        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.VrmlData_Node_ReadNode(self, *args)


    def Read(self, *args):
        """
        Read(VrmlData_Node self, VrmlData_InBuffer & theBuffer) -> VrmlData_ErrorStatus

        Read the Node from input stream.

        :type theBuffer: OCC.wrapper.VrmlData.VrmlData_InBuffer
        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.VrmlData_Node_Read(self, *args)


    def Write(self, *args):
        """
        Write(VrmlData_Node self, char const * thePrefix) -> VrmlData_ErrorStatus

        Write the Node to output stream.

        :type thePrefix: const char *
        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.VrmlData_Node_Write(self, *args)


    def IsDefault(self, *args):
        """
        IsDefault(VrmlData_Node self) -> Standard_Boolean

        Returns True if the node is default, then it would not be written.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _VrmlData.VrmlData_Node_IsDefault(self, *args)


    def WriteClosing(self, *args):
        """
        WriteClosing(VrmlData_Node self) -> VrmlData_ErrorStatus

        Write the closing brace in the end of a node output.

        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.VrmlData_Node_WriteClosing(self, *args)


    def Clone(self, *args):
        """
        Clone(VrmlData_Node self, Handle_VrmlData_Node arg2) -> Handle_VrmlData_Node

        Create a copy of this node.
        If the parameter is null, a new copied node is created. Otherwise new node
        is not created, but rather the given one is modified.<p>
        This method nullifies the argument node if its member myScene differs
        from that one of the current instance.

        :type : OCC.wrapper.VrmlData.Handle_VrmlData_Node
        :rtype: OCC.wrapper.VrmlData.Handle_VrmlData_Node

        """
        return _VrmlData.VrmlData_Node_Clone(self, *args)


    def ReadBoolean(*args):
        """
        ReadBoolean(VrmlData_InBuffer & theBuffer) -> VrmlData_ErrorStatus

        Read one boolean value (TRUE or FALSE).

        :type theBuffer: OCC.wrapper.VrmlData.VrmlData_InBuffer
        :type theResult: bool
        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.VrmlData_Node_ReadBoolean(*args)

    ReadBoolean = staticmethod(ReadBoolean)

    def ReadString(*args):
        """
        ReadString(VrmlData_InBuffer & theBuffer, TCollection_AsciiString theRes) -> VrmlData_ErrorStatus

        Read one quoted string, the quotes are removed.

        :type theBuffer: OCC.wrapper.VrmlData.VrmlData_InBuffer
        :type theRes: OCC.wrapper.TCollection.TCollection_AsciiString
        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.VrmlData_Node_ReadString(*args)

    ReadString = staticmethod(ReadString)

    def ReadMultiString(*args):
        """
        ReadMultiString(VrmlData_InBuffer & theBuffer, NCollection_List_TCollection_AsciiString theRes) -> VrmlData_ErrorStatus

        Read one quoted string, the quotes are removed.

        :type theBuffer: OCC.wrapper.VrmlData.VrmlData_InBuffer
        :type theRes: OCC.wrapper.TColStd.NCollection_List_TCollection_AsciiString
        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.VrmlData_Node_ReadMultiString(*args)

    ReadMultiString = staticmethod(ReadMultiString)

    def ReadInteger(*args):
        """
        ReadInteger(VrmlData_InBuffer & theBuffer) -> VrmlData_ErrorStatus

        Read one integer value.

        :type theBuffer: OCC.wrapper.VrmlData.VrmlData_InBuffer
        :type theResult: long &
        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.VrmlData_Node_ReadInteger(*args)

    ReadInteger = staticmethod(ReadInteger)

    def OK(*args):
        """
        OK(VrmlData_ErrorStatus const theStat) -> Standard_Boolean
        OK(VrmlData_ErrorStatus const theStat) -> Standard_Boolean

        :type outStat: OCC.wrapper.VrmlData.VrmlData_ErrorStatus
        :type theStat: OCC.wrapper.VrmlData.VrmlData_ErrorStatus
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _VrmlData.VrmlData_Node_OK(*args)

    OK = staticmethod(OK)

    def GlobalIndent(*args):
        """
        GlobalIndent() -> Standard_Integer

        Define the common Indent in spaces, for writing all nodes.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _VrmlData.VrmlData_Node_GlobalIndent(*args)

    GlobalIndent = staticmethod(GlobalIndent)

    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _VrmlData.VrmlData_Node_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _VrmlData.VrmlData_Node_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _VrmlData.VrmlData_Node_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _VrmlData.delete_VrmlData_Node
VrmlData_Node_swigregister = _VrmlData.VrmlData_Node_swigregister
VrmlData_Node_swigregister(VrmlData_Node)

def VrmlData_Node_ReadBoolean(*args):
    """
    VrmlData_Node_ReadBoolean(VrmlData_InBuffer & theBuffer) -> VrmlData_ErrorStatus

    Read one boolean value (TRUE or FALSE).

    :type theBuffer: OCC.wrapper.VrmlData.VrmlData_InBuffer
    :type theResult: bool
    :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

    """
    return _VrmlData.VrmlData_Node_ReadBoolean(*args)

def VrmlData_Node_ReadString(*args):
    """
    VrmlData_Node_ReadString(VrmlData_InBuffer & theBuffer, TCollection_AsciiString theRes) -> VrmlData_ErrorStatus

    Read one quoted string, the quotes are removed.

    :type theBuffer: OCC.wrapper.VrmlData.VrmlData_InBuffer
    :type theRes: OCC.wrapper.TCollection.TCollection_AsciiString
    :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

    """
    return _VrmlData.VrmlData_Node_ReadString(*args)

def VrmlData_Node_ReadMultiString(*args):
    """
    VrmlData_Node_ReadMultiString(VrmlData_InBuffer & theBuffer, NCollection_List_TCollection_AsciiString theRes) -> VrmlData_ErrorStatus

    Read one quoted string, the quotes are removed.

    :type theBuffer: OCC.wrapper.VrmlData.VrmlData_InBuffer
    :type theRes: OCC.wrapper.TColStd.NCollection_List_TCollection_AsciiString
    :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

    """
    return _VrmlData.VrmlData_Node_ReadMultiString(*args)

def VrmlData_Node_ReadInteger(*args):
    """
    VrmlData_Node_ReadInteger(VrmlData_InBuffer & theBuffer) -> VrmlData_ErrorStatus

    Read one integer value.

    :type theBuffer: OCC.wrapper.VrmlData.VrmlData_InBuffer
    :type theResult: long &
    :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

    """
    return _VrmlData.VrmlData_Node_ReadInteger(*args)

def VrmlData_Node_OK(*args):
    """
    OK(VrmlData_ErrorStatus const theStat) -> Standard_Boolean
    VrmlData_Node_OK(VrmlData_ErrorStatus const theStat) -> Standard_Boolean

    :type outStat: OCC.wrapper.VrmlData.VrmlData_ErrorStatus
    :type theStat: OCC.wrapper.VrmlData.VrmlData_ErrorStatus
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _VrmlData.VrmlData_Node_OK(*args)

def VrmlData_Node_GlobalIndent(*args):
    """
    VrmlData_Node_GlobalIndent() -> Standard_Integer

    Define the common Indent in spaces, for writing all nodes.

    :rtype: OCC.wrapper.Standard.Standard_Integer

    """
    return _VrmlData.VrmlData_Node_GlobalIndent(*args)

def VrmlData_Node_get_type_name(*args):
    """
    VrmlData_Node_get_type_name() -> char const *

    :rtype: const char *

    """
    return _VrmlData.VrmlData_Node_get_type_name(*args)

def VrmlData_Node_get_type_descriptor(*args):
    """
    VrmlData_Node_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _VrmlData.VrmlData_Node_get_type_descriptor(*args)

class VrmlData_Geometry(VrmlData_Node):
    """
    Implementation of the Geometry node.
    Contains the topological representation (TopoDS_Shell) of the VRML geometry
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_VrmlData_Geometry
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_VrmlData_Geometry(self) 
            return h


    def TShape(self, *args):
        """
        Query the shape. This method checks the flag myIsModified; if True it
        should rebuild the shape presentation.

        :rtype: OCC.wrapper.TopoDS.Handle_TopoDS_TShape

        """
        res = _VrmlData.VrmlData_Geometry_TShape(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _VrmlData.VrmlData_Geometry_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _VrmlData.VrmlData_Geometry_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _VrmlData.VrmlData_Geometry_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _VrmlData.delete_VrmlData_Geometry
VrmlData_Geometry_swigregister = _VrmlData.VrmlData_Geometry_swigregister
VrmlData_Geometry_swigregister(VrmlData_Geometry)

def VrmlData_Geometry_get_type_name(*args):
    """
    VrmlData_Geometry_get_type_name() -> char const *

    :rtype: const char *

    """
    return _VrmlData.VrmlData_Geometry_get_type_name(*args)

def VrmlData_Geometry_get_type_descriptor(*args):
    """
    VrmlData_Geometry_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _VrmlData.VrmlData_Geometry_get_type_descriptor(*args)

class VrmlData_ArrayVec3d(VrmlData_Node):
    """
    Implementatioon of basic node for Coordinate, Normal and Color
    (array of triplets).
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_VrmlData_ArrayVec3d
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_VrmlData_ArrayVec3d(self) 
            return h


    def Length(self, *args):
        """
        Length(VrmlData_ArrayVec3d self) -> Standard_Size

        Query the number of vectors

        :rtype: OCC.wrapper.Standard.Standard_Size

        """
        return _VrmlData.VrmlData_ArrayVec3d_Length(self, *args)


    def Values(self, *args):
        """
        Values(VrmlData_ArrayVec3d self) -> gp_XYZ

        Query the array

        :rtype: OCC.wrapper.gp.gp_XYZ

        """
        return _VrmlData.VrmlData_ArrayVec3d_Values(self, *args)


    def AllocateValues(self, *args):
        """
        AllocateValues(VrmlData_ArrayVec3d self, Standard_Size const theLength) -> Standard_Boolean

        Create a data array and assign the field myArray.
        @return
        True if allocation was successful.

        :type theLength: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _VrmlData.VrmlData_ArrayVec3d_AllocateValues(self, *args)


    def SetValues(self, *args):
        """
        SetValues(VrmlData_ArrayVec3d self, Standard_Size const nValues, gp_XYZ arrValues)

        Set the array data

        :type nValues: int
        :type arrValues: OCC.wrapper.gp.gp_XYZ

        """
        return _VrmlData.VrmlData_ArrayVec3d_SetValues(self, *args)


    def ReadArray(self, *args):
        """
        ReadArray(VrmlData_ArrayVec3d self, VrmlData_InBuffer & theBuffer, char const * theName, Standard_Boolean const isScale) -> VrmlData_ErrorStatus

        Read the Node from input stream.

        :type theBuffer: OCC.wrapper.VrmlData.VrmlData_InBuffer
        :type theName: const char *
        :type isScale: bool
        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.VrmlData_ArrayVec3d_ReadArray(self, *args)


    def WriteArray(self, *args):
        """
        WriteArray(VrmlData_ArrayVec3d self, char const * theName, Standard_Boolean const isScale) -> VrmlData_ErrorStatus

        Write the Node to the output stream currently opened in Scene.

        :type theName: const char *
        :type isScale: bool
        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.VrmlData_ArrayVec3d_WriteArray(self, *args)


    def IsDefault(self, *args):
        """
        IsDefault(VrmlData_ArrayVec3d self) -> Standard_Boolean

        Returns True if the node is default, so that it should not be written.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _VrmlData.VrmlData_ArrayVec3d_IsDefault(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _VrmlData.VrmlData_ArrayVec3d_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _VrmlData.VrmlData_ArrayVec3d_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _VrmlData.VrmlData_ArrayVec3d_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _VrmlData.delete_VrmlData_ArrayVec3d
VrmlData_ArrayVec3d_swigregister = _VrmlData.VrmlData_ArrayVec3d_swigregister
VrmlData_ArrayVec3d_swigregister(VrmlData_ArrayVec3d)

def VrmlData_ArrayVec3d_get_type_name(*args):
    """
    VrmlData_ArrayVec3d_get_type_name() -> char const *

    :rtype: const char *

    """
    return _VrmlData.VrmlData_ArrayVec3d_get_type_name(*args)

def VrmlData_ArrayVec3d_get_type_descriptor(*args):
    """
    VrmlData_ArrayVec3d_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _VrmlData.VrmlData_ArrayVec3d_get_type_descriptor(*args)

class VrmlData_Faceted(VrmlData_Geometry):
    """
    Common API of faceted Geometry nodes: IndexedFaceSet, ElevationGrid,
    Extrusion.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_VrmlData_Faceted
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_VrmlData_Faceted(self) 
            return h


    def IsCCW(self, *args):
        """
        IsCCW(VrmlData_Faceted self) -> Standard_Boolean

        Query "Is Counter-Clockwise" attribute

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _VrmlData.VrmlData_Faceted_IsCCW(self, *args)


    def IsSolid(self, *args):
        """
        IsSolid(VrmlData_Faceted self) -> Standard_Boolean

        Query "Is Solid" attribute

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _VrmlData.VrmlData_Faceted_IsSolid(self, *args)


    def IsConvex(self, *args):
        """
        IsConvex(VrmlData_Faceted self) -> Standard_Boolean

        Query "Is Convex" attribute

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _VrmlData.VrmlData_Faceted_IsConvex(self, *args)


    def CreaseAngle(self, *args):
        """
        CreaseAngle(VrmlData_Faceted self) -> Standard_Real

        Query the Crease Angle

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _VrmlData.VrmlData_Faceted_CreaseAngle(self, *args)


    def SetCCW(self, *args):
        """
        SetCCW(VrmlData_Faceted self, Standard_Boolean const theValue)

        Set "Is Counter-Clockwise" attribute

        :type theValue: bool

        """
        return _VrmlData.VrmlData_Faceted_SetCCW(self, *args)


    def SetSolid(self, *args):
        """
        SetSolid(VrmlData_Faceted self, Standard_Boolean const theValue)

        Set "Is Solid" attribute

        :type theValue: bool

        """
        return _VrmlData.VrmlData_Faceted_SetSolid(self, *args)


    def SetConvex(self, *args):
        """
        SetConvex(VrmlData_Faceted self, Standard_Boolean const theValue)

        Set "Is Convex" attribute

        :type theValue: bool

        """
        return _VrmlData.VrmlData_Faceted_SetConvex(self, *args)


    def SetCreaseAngle(self, *args):
        """
        SetCreaseAngle(VrmlData_Faceted self, Standard_Real const theValue)

        Set "Is Convex" attribute

        :type theValue: float

        """
        return _VrmlData.VrmlData_Faceted_SetCreaseAngle(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _VrmlData.VrmlData_Faceted_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _VrmlData.VrmlData_Faceted_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _VrmlData.VrmlData_Faceted_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _VrmlData.delete_VrmlData_Faceted
VrmlData_Faceted_swigregister = _VrmlData.VrmlData_Faceted_swigregister
VrmlData_Faceted_swigregister(VrmlData_Faceted)

def VrmlData_Faceted_get_type_name(*args):
    """
    VrmlData_Faceted_get_type_name() -> char const *

    :rtype: const char *

    """
    return _VrmlData.VrmlData_Faceted_get_type_name(*args)

def VrmlData_Faceted_get_type_descriptor(*args):
    """
    VrmlData_Faceted_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _VrmlData.VrmlData_Faceted_get_type_descriptor(*args)

class VrmlData_Appearance(VrmlData_Node):
    """Implementation of the Appearance node type"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_VrmlData_Appearance
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_VrmlData_Appearance(self) 
            return h


    def __init__(self, *args):
        """
        __init__(VrmlData_Appearance self) -> VrmlData_Appearance
        __init__(VrmlData_Appearance self, VrmlData_Scene theScene, char const * theName) -> VrmlData_Appearance

        Constructor

        :type theScene: OCC.wrapper.VrmlData.VrmlData_Scene
        :type theName: const char *

        """
        this = _VrmlData.new_VrmlData_Appearance(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Material(self, *args):
        """
        Query the Material

        :rtype: OCC.wrapper.VrmlData.Handle_VrmlData_Material

        """
        res = _VrmlData.VrmlData_Appearance_Material(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Texture(self, *args):
        """
        Query the Texture

        :rtype: OCC.wrapper.VrmlData.Handle_VrmlData_Texture

        """
        res = _VrmlData.VrmlData_Appearance_Texture(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def TextureTransform(self, *args):
        """
        Query the TextureTransform

        :rtype: OCC.wrapper.VrmlData.Handle_VrmlData_TextureTransform

        """
        res = _VrmlData.VrmlData_Appearance_TextureTransform(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetMaterial(self, *args):
        """
        SetMaterial(VrmlData_Appearance self, Handle_VrmlData_Material theMat)

        Set the Material

        :type theMat: OCC.wrapper.VrmlData.Handle_VrmlData_Material

        """
        return _VrmlData.VrmlData_Appearance_SetMaterial(self, *args)


    def SetTexture(self, *args):
        """
        SetTexture(VrmlData_Appearance self, Handle_VrmlData_Texture theTexture)

        Set the Texture

        :type theTexture: OCC.wrapper.VrmlData.Handle_VrmlData_Texture

        """
        return _VrmlData.VrmlData_Appearance_SetTexture(self, *args)


    def SetTextureTransform(self, *args):
        """
        SetTextureTransform(VrmlData_Appearance self, Handle_VrmlData_TextureTransform theTT)

        Set the Texture Transform

        :type theTT: OCC.wrapper.VrmlData.Handle_VrmlData_TextureTransform

        """
        return _VrmlData.VrmlData_Appearance_SetTextureTransform(self, *args)


    def Clone(self, *args):
        """
        Clone(VrmlData_Appearance self, Handle_VrmlData_Node arg2) -> Handle_VrmlData_Node

        Create a copy of this node.
        If the parameter is null, a new copied node is created. Otherwise new node
        is not created, but rather the given one is modified.<p>

        :type : OCC.wrapper.VrmlData.Handle_VrmlData_Node
        :rtype: OCC.wrapper.VrmlData.Handle_VrmlData_Node

        """
        return _VrmlData.VrmlData_Appearance_Clone(self, *args)


    def Read(self, *args):
        """
        Read(VrmlData_Appearance self, VrmlData_InBuffer & theBuffer) -> VrmlData_ErrorStatus

        Read the node from input stream.

        :type theBuffer: OCC.wrapper.VrmlData.VrmlData_InBuffer
        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.VrmlData_Appearance_Read(self, *args)


    def Write(self, *args):
        """
        Write(VrmlData_Appearance self, char const * thePrefix) -> VrmlData_ErrorStatus

        Write the Node from input stream.

        :type thePrefix: const char *
        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.VrmlData_Appearance_Write(self, *args)


    def IsDefault(self, *args):
        """
        IsDefault(VrmlData_Appearance self) -> Standard_Boolean

        Returns True if the node is default, so that it should not be written.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _VrmlData.VrmlData_Appearance_IsDefault(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _VrmlData.VrmlData_Appearance_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _VrmlData.VrmlData_Appearance_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _VrmlData.VrmlData_Appearance_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _VrmlData.delete_VrmlData_Appearance
VrmlData_Appearance_swigregister = _VrmlData.VrmlData_Appearance_swigregister
VrmlData_Appearance_swigregister(VrmlData_Appearance)

def VrmlData_Appearance_get_type_name(*args):
    """
    VrmlData_Appearance_get_type_name() -> char const *

    :rtype: const char *

    """
    return _VrmlData.VrmlData_Appearance_get_type_name(*args)

def VrmlData_Appearance_get_type_descriptor(*args):
    """
    VrmlData_Appearance_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _VrmlData.VrmlData_Appearance_get_type_descriptor(*args)

class VrmlData_Texture(VrmlData_Node):
    """Implementation of the Texture node"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_VrmlData_Texture
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_VrmlData_Texture(self) 
            return h


    def RepeatS(self, *args):
        """
        RepeatS(VrmlData_Texture self) -> Standard_Boolean

        Query the RepeatS value

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _VrmlData.VrmlData_Texture_RepeatS(self, *args)


    def RepeatT(self, *args):
        """
        RepeatT(VrmlData_Texture self) -> Standard_Boolean

        Query the RepeatT value

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _VrmlData.VrmlData_Texture_RepeatT(self, *args)


    def SetRepeatS(self, *args):
        """
        SetRepeatS(VrmlData_Texture self, Standard_Boolean const theFlag)

        Set the RepeatS flag

        :type theFlag: bool

        """
        return _VrmlData.VrmlData_Texture_SetRepeatS(self, *args)


    def SetRepeatT(self, *args):
        """
        SetRepeatT(VrmlData_Texture self, Standard_Boolean const theFlag)

        Set the RepeatT flag

        :type theFlag: bool

        """
        return _VrmlData.VrmlData_Texture_SetRepeatT(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _VrmlData.VrmlData_Texture_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _VrmlData.VrmlData_Texture_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _VrmlData.VrmlData_Texture_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _VrmlData.delete_VrmlData_Texture
VrmlData_Texture_swigregister = _VrmlData.VrmlData_Texture_swigregister
VrmlData_Texture_swigregister(VrmlData_Texture)

def VrmlData_Texture_get_type_name(*args):
    """
    VrmlData_Texture_get_type_name() -> char const *

    :rtype: const char *

    """
    return _VrmlData.VrmlData_Texture_get_type_name(*args)

def VrmlData_Texture_get_type_descriptor(*args):
    """
    VrmlData_Texture_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _VrmlData.VrmlData_Texture_get_type_descriptor(*args)

class VrmlData_Normal(VrmlData_ArrayVec3d):
    """Implementation of the node Normal"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_VrmlData_Normal
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_VrmlData_Normal(self) 
            return h


    def __init__(self, *args):
        """
        __init__(VrmlData_Normal self) -> VrmlData_Normal
        __init__(VrmlData_Normal self, VrmlData_Scene theScene, char const * theName, size_t const nVec=0, gp_XYZ arrVec=0) -> VrmlData_Normal

        Constructor

        :type theScene: OCC.wrapper.VrmlData.VrmlData_Scene
        :type theName: const char *
        :type nVec: size_t
        :type arrVec: OCC.wrapper.gp.gp_XYZ

        """
        this = _VrmlData.new_VrmlData_Normal(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Normal(self, *args):
        """
        Query one normal
        @param i
        index in the array of normals [0 .. N-1]
        @return
        the normal value for the index. If index irrelevant, returns (0., 0., 0.)

        :type i: int
        :rtype: OCC.wrapper.gp.gp_XYZ

        """
        res = _VrmlData.VrmlData_Normal_Normal(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Clone(self, *args):
        """
        Clone(VrmlData_Normal self, Handle_VrmlData_Node theOther) -> Handle_VrmlData_Node

        Create a copy of this node.
        If the parameter is null, a new copied node is created. Otherwise new node
        is not created, but rather the given one is modified.

        :type theOther: OCC.wrapper.VrmlData.Handle_VrmlData_Node
        :rtype: OCC.wrapper.VrmlData.Handle_VrmlData_Node

        """
        return _VrmlData.VrmlData_Normal_Clone(self, *args)


    def Read(self, *args):
        """
        Read(VrmlData_Normal self, VrmlData_InBuffer & theBuffer) -> VrmlData_ErrorStatus

        Read the Node from input stream.

        :type theBuffer: OCC.wrapper.VrmlData.VrmlData_InBuffer
        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.VrmlData_Normal_Read(self, *args)


    def Write(self, *args):
        """
        Write(VrmlData_Normal self, char const * thePrefix) -> VrmlData_ErrorStatus

        Write the Node to the Scene output.

        :type thePrefix: const char *
        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.VrmlData_Normal_Write(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _VrmlData.VrmlData_Normal_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _VrmlData.VrmlData_Normal_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _VrmlData.VrmlData_Normal_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _VrmlData.delete_VrmlData_Normal
VrmlData_Normal_swigregister = _VrmlData.VrmlData_Normal_swigregister
VrmlData_Normal_swigregister(VrmlData_Normal)

def VrmlData_Normal_get_type_name(*args):
    """
    VrmlData_Normal_get_type_name() -> char const *

    :rtype: const char *

    """
    return _VrmlData.VrmlData_Normal_get_type_name(*args)

def VrmlData_Normal_get_type_descriptor(*args):
    """
    VrmlData_Normal_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _VrmlData.VrmlData_Normal_get_type_descriptor(*args)

class VrmlData_IndexedFaceSet(VrmlData_Faceted):
    """Implementation of IndexedFaceSet node"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_VrmlData_IndexedFaceSet
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_VrmlData_IndexedFaceSet(self) 
            return h


    def __init__(self, *args):
        """
        __init__(VrmlData_IndexedFaceSet self) -> VrmlData_IndexedFaceSet
        __init__(VrmlData_IndexedFaceSet self, VrmlData_Scene theScene, char const * theName, Standard_Boolean const isCCW, Standard_Boolean const isSolid, Standard_Boolean const isConvex, Standard_Real const theCreaseAngle=0.) -> VrmlData_IndexedFaceSet

        Constructor

        :type theScene: OCC.wrapper.VrmlData.VrmlData_Scene
        :type theName: const char *
        :type isCCW: bool
        :type isSolid: bool
        :type isConvex: bool
        :type theCreaseAngle: float

        """
        this = _VrmlData.new_VrmlData_IndexedFaceSet(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Normals(self, *args):
        """
        Query the Normals.

        :rtype: OCC.wrapper.VrmlData.Handle_VrmlData_Normal

        """
        res = _VrmlData.VrmlData_IndexedFaceSet_Normals(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Colors(self, *args):
        """
        Query the Colors.

        :rtype: OCC.wrapper.VrmlData.Handle_VrmlData_Color

        """
        res = _VrmlData.VrmlData_IndexedFaceSet_Colors(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def TextureCoords(self, *args):
        """
        Query the Texture Coordinates.

        :rtype: OCC.wrapper.VrmlData.Handle_VrmlData_TextureCoordinate

        """
        res = _VrmlData.VrmlData_IndexedFaceSet_TextureCoords(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Coordinates(self, *args):
        """
        Query the Coordinates.

        :rtype: OCC.wrapper.VrmlData.Handle_VrmlData_Coordinate

        """
        res = _VrmlData.VrmlData_IndexedFaceSet_Coordinates(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Polygons(self, *args):
        """
        Polygons(VrmlData_IndexedFaceSet self, Standard_Integer const **& arrPolygons) -> size_t

        Query the array of polygons

        :type arrPolygons: int
        :rtype: size_t

        """
        return _VrmlData.VrmlData_IndexedFaceSet_Polygons(self, *args)


    def Polygon(self, *args):
        """
        Polygon(VrmlData_IndexedFaceSet self, Standard_Integer const iFace, Standard_Integer const *& outIndice) -> Standard_Integer

        Query one polygon.
        @param iFace
        rank of the polygon [0 .. N-1]
        @param outIndice
        <tt>[out]</tt> array of vertex indice
        @return
        number of vertice in the polygon - the dimension of outIndice array

        :type iFace: int
        :type outIndice: int
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _VrmlData.VrmlData_IndexedFaceSet_Polygon(self, *args)


    def SetCoordinates(self, *args):
        """
        SetCoordinates(VrmlData_IndexedFaceSet self, Handle_VrmlData_Coordinate theCoord)

        Set the nodes

        :type theCoord: OCC.wrapper.VrmlData.Handle_VrmlData_Coordinate

        """
        return _VrmlData.VrmlData_IndexedFaceSet_SetCoordinates(self, *args)


    def SetPolygons(self, *args):
        """
        SetPolygons(VrmlData_IndexedFaceSet self, Standard_Size const nPolygons, Standard_Integer const ** thePolygons)

        Set the polygons

        :type nPolygons: int
        :type thePolygons: int

        """
        return _VrmlData.VrmlData_IndexedFaceSet_SetPolygons(self, *args)


    def ArrayNormalInd(self, *args):
        """
        ArrayNormalInd(VrmlData_IndexedFaceSet self, Standard_Integer const **& arrNormalInd) -> size_t

        Query the array of normal indice
        @param arrNormalInd
        <tt>[out]</tt> array of normalIndex as it is described in VRML2.0 spec
        @return
        Number of integers in the array arrNormalInd.

        :type arrNormalInd: int
        :rtype: size_t

        """
        return _VrmlData.VrmlData_IndexedFaceSet_ArrayNormalInd(self, *args)


    def IndiceNormals(self, *args):
        """
        IndiceNormals(VrmlData_IndexedFaceSet self, Standard_Integer const iFace, Standard_Integer const *& outIndice) -> Standard_Integer

        Query normals indice for one face. This method should be called after
        checking myArrNormalInd != NULL, otherwise exception will be thrown.
        @param iFace
        rank of the face [0 .. N-1]
        @param outIndice
        <tt>[out]</tt> array of normals indice
        @return
        number of indice in the array - the dimension of outIndice array

        :type iFace: int
        :type outIndice: int
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _VrmlData.VrmlData_IndexedFaceSet_IndiceNormals(self, *args)


    def SetNormalInd(self, *args):
        """
        SetNormalInd(VrmlData_IndexedFaceSet self, Standard_Size const nIndice, Standard_Integer const ** theIndice)

        Set the normals array of indice

        :type nIndice: int
        :type theIndice: int

        """
        return _VrmlData.VrmlData_IndexedFaceSet_SetNormalInd(self, *args)


    def SetNormals(self, *args):
        """
        SetNormals(VrmlData_IndexedFaceSet self, Handle_VrmlData_Normal theNormals)

        Set the normals node

        :type theNormals: OCC.wrapper.VrmlData.Handle_VrmlData_Normal

        """
        return _VrmlData.VrmlData_IndexedFaceSet_SetNormals(self, *args)


    def SetNormalPerVertex(self, *args):
        """
        SetNormalPerVertex(VrmlData_IndexedFaceSet self, Standard_Boolean const isNormalPerVertex)

        Set the boolean value "normalPerVertex"

        :type isNormalPerVertex: bool

        """
        return _VrmlData.VrmlData_IndexedFaceSet_SetNormalPerVertex(self, *args)


    def ArrayColorInd(self, *args):
        """
        ArrayColorInd(VrmlData_IndexedFaceSet self, Standard_Integer const **& arrColorInd) -> size_t

        Query the array of color indice
        @param arrColorInd
        <tt>[out]</tt> array of colorIndex as it is described in VRML2.0 spec
        @return
        Number of integers in the array arrColorInd.

        :type arrColorInd: int
        :rtype: size_t

        """
        return _VrmlData.VrmlData_IndexedFaceSet_ArrayColorInd(self, *args)


    def GetColor(self, *args):
        """
        GetColor(VrmlData_IndexedFaceSet self, Standard_Integer const iFace, Standard_Integer const iVertex) -> Quantity_Color

        Query a color for one node in the given element. The color is
        interpreted according to fields myColors, myArrColorInd,
        myColorPerVertex, as defined in VRML 2.0.
        @param iFace
        rank of the polygon [0 .. N-1]
        @param iVertex
        rank of the vertex in the polygon [0 .. M-1]. This parameter is ignored
        if (myColorPerVertex == False)
        @return
        Color value (RGB); if the color is indefinite then returns (0., 0., 0.)

        :type iFace: int
        :type iVertex: int
        :rtype: OCC.wrapper.Quantity.Quantity_Color

        """
        return _VrmlData.VrmlData_IndexedFaceSet_GetColor(self, *args)


    def SetColorInd(self, *args):
        """
        SetColorInd(VrmlData_IndexedFaceSet self, Standard_Size const nIndice, Standard_Integer const ** theIndice)

        Set the colors array of indice

        :type nIndice: int
        :type theIndice: int

        """
        return _VrmlData.VrmlData_IndexedFaceSet_SetColorInd(self, *args)


    def SetColors(self, *args):
        """
        SetColors(VrmlData_IndexedFaceSet self, Handle_VrmlData_Color theColors)

        Set the Color node

        :type theColors: OCC.wrapper.VrmlData.Handle_VrmlData_Color

        """
        return _VrmlData.VrmlData_IndexedFaceSet_SetColors(self, *args)


    def SetColorPerVertex(self, *args):
        """
        SetColorPerVertex(VrmlData_IndexedFaceSet self, Standard_Boolean const isColorPerVertex)

        Set the boolean value "colorPerVertex"

        :type isColorPerVertex: bool

        """
        return _VrmlData.VrmlData_IndexedFaceSet_SetColorPerVertex(self, *args)


    def ArrayTextureCoordInd(self, *args):
        """
        ArrayTextureCoordInd(VrmlData_IndexedFaceSet self, Standard_Integer const **& arrTextureCoordInd) -> size_t

        Query the array of texture coordinate indice
        @param arrTextureCoordInd
        <tt>[out]</tt> array of texCoordIndex as it is described in VRML2.0 spec
        @return
        Number of integers in the array texCoordIndex.

        :type arrTextureCoordInd: int
        :rtype: size_t

        """
        return _VrmlData.VrmlData_IndexedFaceSet_ArrayTextureCoordInd(self, *args)


    def SetTextureCoordInd(self, *args):
        """
        SetTextureCoordInd(VrmlData_IndexedFaceSet self, Standard_Size const nIndice, Standard_Integer const ** theIndice)

        Set the TexCoordiante array of indice

        :type nIndice: int
        :type theIndice: int

        """
        return _VrmlData.VrmlData_IndexedFaceSet_SetTextureCoordInd(self, *args)


    def SetTextureCoords(self, *args):
        """
        SetTextureCoords(VrmlData_IndexedFaceSet self, Handle_VrmlData_TextureCoordinate tc)

        Set the Texture Coordinate node

        :type tc: OCC.wrapper.VrmlData.Handle_VrmlData_TextureCoordinate

        """
        return _VrmlData.VrmlData_IndexedFaceSet_SetTextureCoords(self, *args)


    def TShape(self, *args):
        """
        Query the shape. This method checks the flag myIsModified; if True it
        should rebuild the shape presentation.

        :rtype: OCC.wrapper.TopoDS.Handle_TopoDS_TShape

        """
        res = _VrmlData.VrmlData_IndexedFaceSet_TShape(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Clone(self, *args):
        """
        Clone(VrmlData_IndexedFaceSet self, Handle_VrmlData_Node theOther) -> Handle_VrmlData_Node

        Create a copy of this node.
        If the parameter is null, a new copied node is created. Otherwise new node
        is not created, but rather the given one is modified.

        :type theOther: OCC.wrapper.VrmlData.Handle_VrmlData_Node
        :rtype: OCC.wrapper.VrmlData.Handle_VrmlData_Node

        """
        return _VrmlData.VrmlData_IndexedFaceSet_Clone(self, *args)


    def Read(self, *args):
        """
        Read(VrmlData_IndexedFaceSet self, VrmlData_InBuffer & theBuffer) -> VrmlData_ErrorStatus

        Read the Node from input stream.

        :type theBuffer: OCC.wrapper.VrmlData.VrmlData_InBuffer
        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.VrmlData_IndexedFaceSet_Read(self, *args)


    def Write(self, *args):
        """
        Write(VrmlData_IndexedFaceSet self, char const * thePrefix) -> VrmlData_ErrorStatus

        Write the Node to output stream.

        :type thePrefix: const char *
        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.VrmlData_IndexedFaceSet_Write(self, *args)


    def IsDefault(self, *args):
        """
        IsDefault(VrmlData_IndexedFaceSet self) -> Standard_Boolean

        Returns True if the node is default, so that it should not be written.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _VrmlData.VrmlData_IndexedFaceSet_IsDefault(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _VrmlData.VrmlData_IndexedFaceSet_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _VrmlData.VrmlData_IndexedFaceSet_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _VrmlData.VrmlData_IndexedFaceSet_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _VrmlData.delete_VrmlData_IndexedFaceSet
VrmlData_IndexedFaceSet_swigregister = _VrmlData.VrmlData_IndexedFaceSet_swigregister
VrmlData_IndexedFaceSet_swigregister(VrmlData_IndexedFaceSet)

def VrmlData_IndexedFaceSet_get_type_name(*args):
    """
    VrmlData_IndexedFaceSet_get_type_name() -> char const *

    :rtype: const char *

    """
    return _VrmlData.VrmlData_IndexedFaceSet_get_type_name(*args)

def VrmlData_IndexedFaceSet_get_type_descriptor(*args):
    """
    VrmlData_IndexedFaceSet_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _VrmlData.VrmlData_IndexedFaceSet_get_type_descriptor(*args)

class VrmlData_Cone(VrmlData_Geometry):
    """
    Implementation of the Cone node.
    The cone is located with its middle of the height segment in (0., 0., 0.) 
    The height is oriented along OY.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_VrmlData_Cone
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_VrmlData_Cone(self) 
            return h


    def __init__(self, *args):
        """
        __init__(VrmlData_Cone self) -> VrmlData_Cone
        __init__(VrmlData_Cone self, VrmlData_Scene theScene, char const * theName, Standard_Real const theBottomRadius=1., Standard_Real const theHeight=2.) -> VrmlData_Cone

        Constructor

        :type theScene: OCC.wrapper.VrmlData.VrmlData_Scene
        :type theName: const char *
        :type theBottomRadius: float
        :type theHeight: float

        """
        this = _VrmlData.new_VrmlData_Cone(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def BottomRadius(self, *args):
        """
        BottomRadius(VrmlData_Cone self) -> Standard_Real

        Query the Bottom Radius

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _VrmlData.VrmlData_Cone_BottomRadius(self, *args)


    def Height(self, *args):
        """
        Height(VrmlData_Cone self) -> Standard_Real

        Query the Height

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _VrmlData.VrmlData_Cone_Height(self, *args)


    def HasBottom(self, *args):
        """
        HasBottom(VrmlData_Cone self) -> Standard_Boolean

        Query if the bottom circle is included

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _VrmlData.VrmlData_Cone_HasBottom(self, *args)


    def HasSide(self, *args):
        """
        HasSide(VrmlData_Cone self) -> Standard_Boolean

        Query if the side surface is included

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _VrmlData.VrmlData_Cone_HasSide(self, *args)


    def SetBottomRadius(self, *args):
        """
        SetBottomRadius(VrmlData_Cone self, Standard_Real const theRadius)

        Set the Bottom Radius

        :type theRadius: float

        """
        return _VrmlData.VrmlData_Cone_SetBottomRadius(self, *args)


    def SetHeight(self, *args):
        """
        SetHeight(VrmlData_Cone self, Standard_Real const theHeight)

        Set the Height

        :type theHeight: float

        """
        return _VrmlData.VrmlData_Cone_SetHeight(self, *args)


    def SetFaces(self, *args):
        """
        SetFaces(VrmlData_Cone self, Standard_Boolean const hasBottom, Standard_Boolean const hasSide)

        Set which faces are included

        :type hasBottom: bool
        :type hasSide: bool

        """
        return _VrmlData.VrmlData_Cone_SetFaces(self, *args)


    def TShape(self, *args):
        """
        Query the primitive topology. This method returns a Null shape if there
        is an internal error during the primitive creation (zero radius, etc.)

        :rtype: OCC.wrapper.TopoDS.Handle_TopoDS_TShape

        """
        res = _VrmlData.VrmlData_Cone_TShape(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Clone(self, *args):
        """
        Clone(VrmlData_Cone self, Handle_VrmlData_Node theOther) -> Handle_VrmlData_Node

        Create a copy of this node.
        If the parameter is null, a new copied node is created. Otherwise new node
        is not created, but rather the given one is modified.

        :type theOther: OCC.wrapper.VrmlData.Handle_VrmlData_Node
        :rtype: OCC.wrapper.VrmlData.Handle_VrmlData_Node

        """
        return _VrmlData.VrmlData_Cone_Clone(self, *args)


    def Read(self, *args):
        """
        Read(VrmlData_Cone self, VrmlData_InBuffer & theBuffer) -> VrmlData_ErrorStatus

        Fill the Node internal data from the given input stream.

        :type theBuffer: OCC.wrapper.VrmlData.VrmlData_InBuffer
        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.VrmlData_Cone_Read(self, *args)


    def Write(self, *args):
        """
        Write(VrmlData_Cone self, char const * thePrefix) -> VrmlData_ErrorStatus

        Write the Node to output stream.

        :type thePrefix: const char *
        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.VrmlData_Cone_Write(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _VrmlData.VrmlData_Cone_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _VrmlData.VrmlData_Cone_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _VrmlData.VrmlData_Cone_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _VrmlData.delete_VrmlData_Cone
VrmlData_Cone_swigregister = _VrmlData.VrmlData_Cone_swigregister
VrmlData_Cone_swigregister(VrmlData_Cone)

def VrmlData_Cone_get_type_name(*args):
    """
    VrmlData_Cone_get_type_name() -> char const *

    :rtype: const char *

    """
    return _VrmlData.VrmlData_Cone_get_type_name(*args)

def VrmlData_Cone_get_type_descriptor(*args):
    """
    VrmlData_Cone_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _VrmlData.VrmlData_Cone_get_type_descriptor(*args)

class VrmlData_TextureCoordinate(VrmlData_Node):
    """Implementation of the node TextureCoordinate"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_VrmlData_TextureCoordinate
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_VrmlData_TextureCoordinate(self) 
            return h


    def __init__(self, *args):
        """
        __init__(VrmlData_TextureCoordinate self) -> VrmlData_TextureCoordinate
        __init__(VrmlData_TextureCoordinate self, VrmlData_Scene theScene, char const * theName, size_t const nPoints=0, gp_XY arrPoints=0) -> VrmlData_TextureCoordinate

        Constructor

        :type theScene: OCC.wrapper.VrmlData.VrmlData_Scene
        :type theName: const char *
        :type nPoints: size_t
        :type arrPoints: OCC.wrapper.gp.gp_XY

        """
        this = _VrmlData.new_VrmlData_TextureCoordinate(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def AllocateValues(self, *args):
        """
        AllocateValues(VrmlData_TextureCoordinate self, Standard_Size const theLength) -> Standard_Boolean

        Create a data array and assign the field myArray.
        @return
        True if allocation was successful.

        :type theLength: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _VrmlData.VrmlData_TextureCoordinate_AllocateValues(self, *args)


    def Length(self, *args):
        """
        Length(VrmlData_TextureCoordinate self) -> size_t

        Query the number of points

        :rtype: size_t

        """
        return _VrmlData.VrmlData_TextureCoordinate_Length(self, *args)


    def Points(self, *args):
        """
        Points(VrmlData_TextureCoordinate self) -> gp_XY

        Query the points

        :rtype: OCC.wrapper.gp.gp_XY

        """
        return _VrmlData.VrmlData_TextureCoordinate_Points(self, *args)


    def SetPoints(self, *args):
        """
        SetPoints(VrmlData_TextureCoordinate self, size_t const nPoints, gp_XY arrPoints)

        Set the points array

        :type nPoints: size_t
        :type arrPoints: OCC.wrapper.gp.gp_XY

        """
        return _VrmlData.VrmlData_TextureCoordinate_SetPoints(self, *args)


    def Clone(self, *args):
        """
        Clone(VrmlData_TextureCoordinate self, Handle_VrmlData_Node theOther) -> Handle_VrmlData_Node

        Create a copy of this node.
        If the parameter is null, a new copied node is created. Otherwise new node
        is not created, but rather the given one is modified.

        :type theOther: OCC.wrapper.VrmlData.Handle_VrmlData_Node
        :rtype: OCC.wrapper.VrmlData.Handle_VrmlData_Node

        """
        return _VrmlData.VrmlData_TextureCoordinate_Clone(self, *args)


    def Read(self, *args):
        """
        Read(VrmlData_TextureCoordinate self, VrmlData_InBuffer & theBuffer) -> VrmlData_ErrorStatus

        Read the Node from input stream.

        :type theBuffer: OCC.wrapper.VrmlData.VrmlData_InBuffer
        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.VrmlData_TextureCoordinate_Read(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _VrmlData.VrmlData_TextureCoordinate_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _VrmlData.VrmlData_TextureCoordinate_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _VrmlData.VrmlData_TextureCoordinate_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _VrmlData.delete_VrmlData_TextureCoordinate
VrmlData_TextureCoordinate_swigregister = _VrmlData.VrmlData_TextureCoordinate_swigregister
VrmlData_TextureCoordinate_swigregister(VrmlData_TextureCoordinate)

def VrmlData_TextureCoordinate_get_type_name(*args):
    """
    VrmlData_TextureCoordinate_get_type_name() -> char const *

    :rtype: const char *

    """
    return _VrmlData.VrmlData_TextureCoordinate_get_type_name(*args)

def VrmlData_TextureCoordinate_get_type_descriptor(*args):
    """
    VrmlData_TextureCoordinate_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _VrmlData.VrmlData_TextureCoordinate_get_type_descriptor(*args)

class VrmlData_UnknownNode(VrmlData_Node):
    """
    Definition of UnknownNode -- placeholder for node types that
    are not processed now.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_VrmlData_UnknownNode
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_VrmlData_UnknownNode(self) 
            return h


    def __init__(self, *args):
        """
        __init__(VrmlData_UnknownNode self) -> VrmlData_UnknownNode
        __init__(VrmlData_UnknownNode self, VrmlData_Scene theScene, char const * theName=0, char const * theTitle=0) -> VrmlData_UnknownNode

        Constructor.

        :type theScene: OCC.wrapper.VrmlData.VrmlData_Scene
        :type theName: const char *
        :type theTitle: const char *

        """
        this = _VrmlData.new_VrmlData_UnknownNode(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Read(self, *args):
        """
        Read(VrmlData_UnknownNode self, VrmlData_InBuffer & theBuffer) -> VrmlData_ErrorStatus

        Read the unknown node, till the last closing brace of it.

        :type theBuffer: OCC.wrapper.VrmlData.VrmlData_InBuffer
        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.VrmlData_UnknownNode_Read(self, *args)


    def GetTitle(self, *args):
        """
        Query the title of the unknown node.

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        res = _VrmlData.VrmlData_UnknownNode_GetTitle(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def IsDefault(self, *args):
        """
        IsDefault(VrmlData_UnknownNode self) -> Standard_Boolean

        Check if the Node is non-writeable -- always returns true.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _VrmlData.VrmlData_UnknownNode_IsDefault(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _VrmlData.VrmlData_UnknownNode_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _VrmlData.VrmlData_UnknownNode_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _VrmlData.VrmlData_UnknownNode_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _VrmlData.delete_VrmlData_UnknownNode
VrmlData_UnknownNode_swigregister = _VrmlData.VrmlData_UnknownNode_swigregister
VrmlData_UnknownNode_swigregister(VrmlData_UnknownNode)

def VrmlData_UnknownNode_get_type_name(*args):
    """
    VrmlData_UnknownNode_get_type_name() -> char const *

    :rtype: const char *

    """
    return _VrmlData.VrmlData_UnknownNode_get_type_name(*args)

def VrmlData_UnknownNode_get_type_descriptor(*args):
    """
    VrmlData_UnknownNode_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _VrmlData.VrmlData_UnknownNode_get_type_descriptor(*args)

class VrmlData_Material(VrmlData_Node):
    """Implementation of the Material node"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_VrmlData_Material
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_VrmlData_Material(self) 
            return h


    def __init__(self, *args):
        """
        __init__(VrmlData_Material self) -> VrmlData_Material
        __init__(VrmlData_Material self, VrmlData_Scene theScene, char const * theName, Standard_Real const theAmbientIntensity=-1., Standard_Real const theShininess=-1., Standard_Real const theTransparency=-1.) -> VrmlData_Material

        Constructor

        :type theScene: OCC.wrapper.VrmlData.VrmlData_Scene
        :type theName: const char *
        :type theAmbientIntensity: float
        :type theShininess: float
        :type theTransparency: float

        """
        this = _VrmlData.new_VrmlData_Material(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def AmbientIntensity(self, *args):
        """
        AmbientIntensity(VrmlData_Material self) -> Standard_Real

        Query the Ambient Intensity value

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _VrmlData.VrmlData_Material_AmbientIntensity(self, *args)


    def Shininess(self, *args):
        """
        Shininess(VrmlData_Material self) -> Standard_Real

        Query the Shininess value

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _VrmlData.VrmlData_Material_Shininess(self, *args)


    def Transparency(self, *args):
        """
        Transparency(VrmlData_Material self) -> Standard_Real

        Query the Transparency value

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _VrmlData.VrmlData_Material_Transparency(self, *args)


    def DiffuseColor(self, *args):
        """
        Query the Diffuse color

        :rtype: OCC.wrapper.Quantity.Quantity_Color

        """
        res = _VrmlData.VrmlData_Material_DiffuseColor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def EmissiveColor(self, *args):
        """
        Query the Emissive color

        :rtype: OCC.wrapper.Quantity.Quantity_Color

        """
        res = _VrmlData.VrmlData_Material_EmissiveColor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SpecularColor(self, *args):
        """
        Query the Specular color

        :rtype: OCC.wrapper.Quantity.Quantity_Color

        """
        res = _VrmlData.VrmlData_Material_SpecularColor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetAmbientIntensity(self, *args):
        """
        SetAmbientIntensity(VrmlData_Material self, Standard_Real const theAmbientIntensity)

        Set the Ambient Intensity value

        :type theAmbientIntensity: float

        """
        return _VrmlData.VrmlData_Material_SetAmbientIntensity(self, *args)


    def SetShininess(self, *args):
        """
        SetShininess(VrmlData_Material self, Standard_Real const theShininess)

        Set the Shininess value

        :type theShininess: float

        """
        return _VrmlData.VrmlData_Material_SetShininess(self, *args)


    def SetTransparency(self, *args):
        """
        SetTransparency(VrmlData_Material self, Standard_Real const theTransparency)

        Set the Transparency value

        :type theTransparency: float

        """
        return _VrmlData.VrmlData_Material_SetTransparency(self, *args)


    def SetDiffuseColor(self, *args):
        """
        SetDiffuseColor(VrmlData_Material self, Quantity_Color theColor)

        Query the Diffuse color

        :type theColor: OCC.wrapper.Quantity.Quantity_Color

        """
        return _VrmlData.VrmlData_Material_SetDiffuseColor(self, *args)


    def SetEmissiveColor(self, *args):
        """
        SetEmissiveColor(VrmlData_Material self, Quantity_Color theColor)

        Query the Emissive color

        :type theColor: OCC.wrapper.Quantity.Quantity_Color

        """
        return _VrmlData.VrmlData_Material_SetEmissiveColor(self, *args)


    def SetSpecularColor(self, *args):
        """
        SetSpecularColor(VrmlData_Material self, Quantity_Color theColor)

        Query the Specular color

        :type theColor: OCC.wrapper.Quantity.Quantity_Color

        """
        return _VrmlData.VrmlData_Material_SetSpecularColor(self, *args)


    def Clone(self, *args):
        """
        Clone(VrmlData_Material self, Handle_VrmlData_Node theOther) -> Handle_VrmlData_Node

        Create a copy of this node.
        If the parameter is null, a new copied node is created. Otherwise new node
        is not created, but rather the given one is modified.

        :type theOther: OCC.wrapper.VrmlData.Handle_VrmlData_Node
        :rtype: OCC.wrapper.VrmlData.Handle_VrmlData_Node

        """
        return _VrmlData.VrmlData_Material_Clone(self, *args)


    def Read(self, *args):
        """
        Read(VrmlData_Material self, VrmlData_InBuffer & theBuffer) -> VrmlData_ErrorStatus

        Read the Node from input stream.

        :type theBuffer: OCC.wrapper.VrmlData.VrmlData_InBuffer
        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.VrmlData_Material_Read(self, *args)


    def Write(self, *args):
        """
        Write(VrmlData_Material self, char const * thePrefix) -> VrmlData_ErrorStatus

        Write the Node to the Scene output.

        :type thePrefix: const char *
        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.VrmlData_Material_Write(self, *args)


    def IsDefault(self, *args):
        """
        IsDefault(VrmlData_Material self) -> Standard_Boolean

        Returns True if the node is default, so that it should not be written.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _VrmlData.VrmlData_Material_IsDefault(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _VrmlData.VrmlData_Material_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _VrmlData.VrmlData_Material_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _VrmlData.VrmlData_Material_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _VrmlData.delete_VrmlData_Material
VrmlData_Material_swigregister = _VrmlData.VrmlData_Material_swigregister
VrmlData_Material_swigregister(VrmlData_Material)

def VrmlData_Material_get_type_name(*args):
    """
    VrmlData_Material_get_type_name() -> char const *

    :rtype: const char *

    """
    return _VrmlData.VrmlData_Material_get_type_name(*args)

def VrmlData_Material_get_type_descriptor(*args):
    """
    VrmlData_Material_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _VrmlData.VrmlData_Material_get_type_descriptor(*args)

class VrmlData_ImageTexture(VrmlData_Texture):
    """Implementation of the ImageTexture node"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_VrmlData_ImageTexture
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_VrmlData_ImageTexture(self) 
            return h


    def __init__(self, *args):
        """
        __init__(VrmlData_ImageTexture self) -> VrmlData_ImageTexture
        __init__(VrmlData_ImageTexture self, VrmlData_Scene theScene, char const * theName, char const * theURL=0, Standard_Boolean const theRepS, Standard_Boolean const theRepT) -> VrmlData_ImageTexture

        Constructor

        :type theScene: OCC.wrapper.VrmlData.VrmlData_Scene
        :type theName: const char *
        :type theURL: const char *
        :type theRepS: bool
        :type theRepT: bool

        """
        this = _VrmlData.new_VrmlData_ImageTexture(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def URL(self, *args):
        """
        Query the associated URL.

        :rtype: OCC.wrapper.TColStd.NCollection_List_TCollection_AsciiString

        """
        res = _VrmlData.VrmlData_ImageTexture_URL(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Clone(self, *args):
        """
        Clone(VrmlData_ImageTexture self, Handle_VrmlData_Node theOther) -> Handle_VrmlData_Node

        Create a copy of this node.
        If the parameter is null, a new copied node is created. Otherwise new node
        is not created, but rather the given one is modified.

        :type theOther: OCC.wrapper.VrmlData.Handle_VrmlData_Node
        :rtype: OCC.wrapper.VrmlData.Handle_VrmlData_Node

        """
        return _VrmlData.VrmlData_ImageTexture_Clone(self, *args)


    def Read(self, *args):
        """
        Read(VrmlData_ImageTexture self, VrmlData_InBuffer & theBuffer) -> VrmlData_ErrorStatus

        Read the Node from input stream.

        :type theBuffer: OCC.wrapper.VrmlData.VrmlData_InBuffer
        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.VrmlData_ImageTexture_Read(self, *args)


    def Write(self, *args):
        """
        Write(VrmlData_ImageTexture self, char const * thePrefix) -> VrmlData_ErrorStatus

        Write the Node to output stream.

        :type thePrefix: const char *
        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.VrmlData_ImageTexture_Write(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _VrmlData.VrmlData_ImageTexture_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _VrmlData.VrmlData_ImageTexture_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _VrmlData.VrmlData_ImageTexture_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _VrmlData.delete_VrmlData_ImageTexture
VrmlData_ImageTexture_swigregister = _VrmlData.VrmlData_ImageTexture_swigregister
VrmlData_ImageTexture_swigregister(VrmlData_ImageTexture)

def VrmlData_ImageTexture_get_type_name(*args):
    """
    VrmlData_ImageTexture_get_type_name() -> char const *

    :rtype: const char *

    """
    return _VrmlData.VrmlData_ImageTexture_get_type_name(*args)

def VrmlData_ImageTexture_get_type_descriptor(*args):
    """
    VrmlData_ImageTexture_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _VrmlData.VrmlData_ImageTexture_get_type_descriptor(*args)

class VrmlData_Sphere(VrmlData_Geometry):
    """Implementation of the Sphere node."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_VrmlData_Sphere
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_VrmlData_Sphere(self) 
            return h


    def __init__(self, *args):
        """
        __init__(VrmlData_Sphere self) -> VrmlData_Sphere
        __init__(VrmlData_Sphere self, VrmlData_Scene theScene, char const * theName, Standard_Real const theRadius=1.) -> VrmlData_Sphere

        Constructor

        :type theScene: OCC.wrapper.VrmlData.VrmlData_Scene
        :type theName: const char *
        :type theRadius: float

        """
        this = _VrmlData.new_VrmlData_Sphere(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Radius(self, *args):
        """
        Radius(VrmlData_Sphere self) -> Standard_Real

        Query the sphere radius

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _VrmlData.VrmlData_Sphere_Radius(self, *args)


    def SetRadius(self, *args):
        """
        SetRadius(VrmlData_Sphere self, Standard_Real const theRadius)

        Set the spere radius

        :type theRadius: float

        """
        return _VrmlData.VrmlData_Sphere_SetRadius(self, *args)


    def TShape(self, *args):
        """
        Query the primitive topology. This method returns a Null shape if there
        is an internal error during the primitive creation (zero radius, etc.)

        :rtype: OCC.wrapper.TopoDS.Handle_TopoDS_TShape

        """
        res = _VrmlData.VrmlData_Sphere_TShape(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Clone(self, *args):
        """
        Clone(VrmlData_Sphere self, Handle_VrmlData_Node theOther) -> Handle_VrmlData_Node

        Create a copy of this node.
        If the parameter is null, a new copied node is created. Otherwise new node
        is not created, but rather the given one is modified.

        :type theOther: OCC.wrapper.VrmlData.Handle_VrmlData_Node
        :rtype: OCC.wrapper.VrmlData.Handle_VrmlData_Node

        """
        return _VrmlData.VrmlData_Sphere_Clone(self, *args)


    def Read(self, *args):
        """
        Read(VrmlData_Sphere self, VrmlData_InBuffer & theBuffer) -> VrmlData_ErrorStatus

        Fill the Node internal data from the given input stream.

        :type theBuffer: OCC.wrapper.VrmlData.VrmlData_InBuffer
        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.VrmlData_Sphere_Read(self, *args)


    def Write(self, *args):
        """
        Write(VrmlData_Sphere self, char const * thePrefix) -> VrmlData_ErrorStatus

        Write the Node to output stream.

        :type thePrefix: const char *
        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.VrmlData_Sphere_Write(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _VrmlData.VrmlData_Sphere_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _VrmlData.VrmlData_Sphere_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _VrmlData.VrmlData_Sphere_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _VrmlData.delete_VrmlData_Sphere
VrmlData_Sphere_swigregister = _VrmlData.VrmlData_Sphere_swigregister
VrmlData_Sphere_swigregister(VrmlData_Sphere)

def VrmlData_Sphere_get_type_name(*args):
    """
    VrmlData_Sphere_get_type_name() -> char const *

    :rtype: const char *

    """
    return _VrmlData.VrmlData_Sphere_get_type_name(*args)

def VrmlData_Sphere_get_type_descriptor(*args):
    """
    VrmlData_Sphere_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _VrmlData.VrmlData_Sphere_get_type_descriptor(*args)

class VrmlData_TextureTransform(VrmlData_Node):
    """Implementation of the TextureTransform node"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_VrmlData_TextureTransform
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_VrmlData_TextureTransform(self) 
            return h


    def Center(self, *args):
        """
        Query the Center

        :rtype: OCC.wrapper.gp.gp_XY

        """
        res = _VrmlData.VrmlData_TextureTransform_Center(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Rotation(self, *args):
        """
        Rotation(VrmlData_TextureTransform self) -> Standard_Real

        Query the Rotation

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _VrmlData.VrmlData_TextureTransform_Rotation(self, *args)


    def Scale(self, *args):
        """
        Query the Scale

        :rtype: OCC.wrapper.gp.gp_XY

        """
        res = _VrmlData.VrmlData_TextureTransform_Scale(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Translation(self, *args):
        """
        Query the Translation

        :rtype: OCC.wrapper.gp.gp_XY

        """
        res = _VrmlData.VrmlData_TextureTransform_Translation(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetCenter(self, *args):
        """
        SetCenter(VrmlData_TextureTransform self, gp_XY V)

        Set the Center

        :type V: OCC.wrapper.gp.gp_XY

        """
        return _VrmlData.VrmlData_TextureTransform_SetCenter(self, *args)


    def SetRotation(self, *args):
        """
        SetRotation(VrmlData_TextureTransform self, Standard_Real const V)

        Set the Rotation

        :type V: float

        """
        return _VrmlData.VrmlData_TextureTransform_SetRotation(self, *args)


    def SetScale(self, *args):
        """
        SetScale(VrmlData_TextureTransform self, gp_XY V)

        Set the Scale

        :type V: OCC.wrapper.gp.gp_XY

        """
        return _VrmlData.VrmlData_TextureTransform_SetScale(self, *args)


    def SetTranslation(self, *args):
        """
        SetTranslation(VrmlData_TextureTransform self, gp_XY V)

        Set the Translation

        :type V: OCC.wrapper.gp.gp_XY

        """
        return _VrmlData.VrmlData_TextureTransform_SetTranslation(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _VrmlData.VrmlData_TextureTransform_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _VrmlData.VrmlData_TextureTransform_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _VrmlData.VrmlData_TextureTransform_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _VrmlData.delete_VrmlData_TextureTransform
VrmlData_TextureTransform_swigregister = _VrmlData.VrmlData_TextureTransform_swigregister
VrmlData_TextureTransform_swigregister(VrmlData_TextureTransform)

def VrmlData_TextureTransform_get_type_name(*args):
    """
    VrmlData_TextureTransform_get_type_name() -> char const *

    :rtype: const char *

    """
    return _VrmlData.VrmlData_TextureTransform_get_type_name(*args)

def VrmlData_TextureTransform_get_type_descriptor(*args):
    """
    VrmlData_TextureTransform_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _VrmlData.VrmlData_TextureTransform_get_type_descriptor(*args)

class VrmlData_ShapeNode(VrmlData_Node):
    """Implementation of the Shape node type"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_VrmlData_ShapeNode
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_VrmlData_ShapeNode(self) 
            return h


    def __init__(self, *args):
        """
        __init__(VrmlData_ShapeNode self) -> VrmlData_ShapeNode
        __init__(VrmlData_ShapeNode self, VrmlData_Scene theScene, char const * theName) -> VrmlData_ShapeNode

        Constructor

        :type theScene: OCC.wrapper.VrmlData.VrmlData_Scene
        :type theName: const char *

        """
        this = _VrmlData.new_VrmlData_ShapeNode(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Appearance(self, *args):
        """
        Query the Appearance.

        :rtype: OCC.wrapper.VrmlData.Handle_VrmlData_Appearance

        """
        res = _VrmlData.VrmlData_ShapeNode_Appearance(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Geometry(self, *args):
        """
        Query the Geometry.

        :rtype: OCC.wrapper.VrmlData.Handle_VrmlData_Geometry

        """
        res = _VrmlData.VrmlData_ShapeNode_Geometry(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetAppearance(self, *args):
        """
        SetAppearance(VrmlData_ShapeNode self, Handle_VrmlData_Appearance theAppear)

        Set the Appearance

        :type theAppear: OCC.wrapper.VrmlData.Handle_VrmlData_Appearance

        """
        return _VrmlData.VrmlData_ShapeNode_SetAppearance(self, *args)


    def SetGeometry(self, *args):
        """
        SetGeometry(VrmlData_ShapeNode self, Handle_VrmlData_Geometry theGeometry)

        Set the Geometry

        :type theGeometry: OCC.wrapper.VrmlData.Handle_VrmlData_Geometry

        """
        return _VrmlData.VrmlData_ShapeNode_SetGeometry(self, *args)


    def Clone(self, *args):
        """
        Clone(VrmlData_ShapeNode self, Handle_VrmlData_Node theOther) -> Handle_VrmlData_Node

        Create a copy of this node.
        If the parameter is null, a new copied node is created. Otherwise new node
        is not created, but rather the given one is modified.

        :type theOther: OCC.wrapper.VrmlData.Handle_VrmlData_Node
        :rtype: OCC.wrapper.VrmlData.Handle_VrmlData_Node

        """
        return _VrmlData.VrmlData_ShapeNode_Clone(self, *args)


    def Read(self, *args):
        """
        Read(VrmlData_ShapeNode self, VrmlData_InBuffer & theBuffer) -> VrmlData_ErrorStatus

        Fill the Node internal data from the given input stream.

        :type theBuffer: OCC.wrapper.VrmlData.VrmlData_InBuffer
        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.VrmlData_ShapeNode_Read(self, *args)


    def Write(self, *args):
        """
        Write(VrmlData_ShapeNode self, char const * thePrefix) -> VrmlData_ErrorStatus

        Write the Node to output stream.

        :type thePrefix: const char *
        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.VrmlData_ShapeNode_Write(self, *args)


    def IsDefault(self, *args):
        """
        IsDefault(VrmlData_ShapeNode self) -> Standard_Boolean

        Check if the Shape Node is writeable.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _VrmlData.VrmlData_ShapeNode_IsDefault(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _VrmlData.VrmlData_ShapeNode_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _VrmlData.VrmlData_ShapeNode_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _VrmlData.VrmlData_ShapeNode_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _VrmlData.delete_VrmlData_ShapeNode
VrmlData_ShapeNode_swigregister = _VrmlData.VrmlData_ShapeNode_swigregister
VrmlData_ShapeNode_swigregister(VrmlData_ShapeNode)

def VrmlData_ShapeNode_get_type_name(*args):
    """
    VrmlData_ShapeNode_get_type_name() -> char const *

    :rtype: const char *

    """
    return _VrmlData.VrmlData_ShapeNode_get_type_name(*args)

def VrmlData_ShapeNode_get_type_descriptor(*args):
    """
    VrmlData_ShapeNode_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _VrmlData.VrmlData_ShapeNode_get_type_descriptor(*args)

class VrmlData_Cylinder(VrmlData_Geometry):
    """Implementation of the Cylinder node"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_VrmlData_Cylinder
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_VrmlData_Cylinder(self) 
            return h


    def __init__(self, *args):
        """
        __init__(VrmlData_Cylinder self) -> VrmlData_Cylinder
        __init__(VrmlData_Cylinder self, VrmlData_Scene theScene, char const * theName, Standard_Real const theRadius=1., Standard_Real const theHeight=2.) -> VrmlData_Cylinder

        Constructor

        :type theScene: OCC.wrapper.VrmlData.VrmlData_Scene
        :type theName: const char *
        :type theRadius: float
        :type theHeight: float

        """
        this = _VrmlData.new_VrmlData_Cylinder(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Radius(self, *args):
        """
        Radius(VrmlData_Cylinder self) -> Standard_Real

        Query the Radius

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _VrmlData.VrmlData_Cylinder_Radius(self, *args)


    def Height(self, *args):
        """
        Height(VrmlData_Cylinder self) -> Standard_Real

        Query the Height

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _VrmlData.VrmlData_Cylinder_Height(self, *args)


    def HasBottom(self, *args):
        """
        HasBottom(VrmlData_Cylinder self) -> Standard_Boolean

        Query if the bottom circle is included

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _VrmlData.VrmlData_Cylinder_HasBottom(self, *args)


    def HasSide(self, *args):
        """
        HasSide(VrmlData_Cylinder self) -> Standard_Boolean

        Query if the side surface is included

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _VrmlData.VrmlData_Cylinder_HasSide(self, *args)


    def HasTop(self, *args):
        """
        HasTop(VrmlData_Cylinder self) -> Standard_Boolean

        Query if the top surface is included

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _VrmlData.VrmlData_Cylinder_HasTop(self, *args)


    def SetRadius(self, *args):
        """
        SetRadius(VrmlData_Cylinder self, Standard_Real const theRadius)

        Set the Radius

        :type theRadius: float

        """
        return _VrmlData.VrmlData_Cylinder_SetRadius(self, *args)


    def SetHeight(self, *args):
        """
        SetHeight(VrmlData_Cylinder self, Standard_Real const theHeight)

        Set the Height

        :type theHeight: float

        """
        return _VrmlData.VrmlData_Cylinder_SetHeight(self, *args)


    def SetFaces(self, *args):
        """
        SetFaces(VrmlData_Cylinder self, Standard_Boolean const hasBottom, Standard_Boolean const hasSide, Standard_Boolean const hasTop)

        Set which faces are included

        :type hasBottom: bool
        :type hasSide: bool
        :type hasTop: bool

        """
        return _VrmlData.VrmlData_Cylinder_SetFaces(self, *args)


    def TShape(self, *args):
        """
        Query the primitive topology. This method returns a Null shape if there
        is an internal error during the primitive creation (zero radius, etc.)

        :rtype: OCC.wrapper.TopoDS.Handle_TopoDS_TShape

        """
        res = _VrmlData.VrmlData_Cylinder_TShape(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Clone(self, *args):
        """
        Clone(VrmlData_Cylinder self, Handle_VrmlData_Node theOther) -> Handle_VrmlData_Node

        Create a copy of this node.
        If the parameter is null, a new copied node is created. Otherwise new node
        is not created, but rather the given one is modified.

        :type theOther: OCC.wrapper.VrmlData.Handle_VrmlData_Node
        :rtype: OCC.wrapper.VrmlData.Handle_VrmlData_Node

        """
        return _VrmlData.VrmlData_Cylinder_Clone(self, *args)


    def Read(self, *args):
        """
        Read(VrmlData_Cylinder self, VrmlData_InBuffer & theBuffer) -> VrmlData_ErrorStatus

        Fill the Node internal data from the given input stream.

        :type theBuffer: OCC.wrapper.VrmlData.VrmlData_InBuffer
        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.VrmlData_Cylinder_Read(self, *args)


    def Write(self, *args):
        """
        Write(VrmlData_Cylinder self, char const * thePrefix) -> VrmlData_ErrorStatus

        Write the Node to output stream.

        :type thePrefix: const char *
        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.VrmlData_Cylinder_Write(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _VrmlData.VrmlData_Cylinder_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _VrmlData.VrmlData_Cylinder_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _VrmlData.VrmlData_Cylinder_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _VrmlData.delete_VrmlData_Cylinder
VrmlData_Cylinder_swigregister = _VrmlData.VrmlData_Cylinder_swigregister
VrmlData_Cylinder_swigregister(VrmlData_Cylinder)

def VrmlData_Cylinder_get_type_name(*args):
    """
    VrmlData_Cylinder_get_type_name() -> char const *

    :rtype: const char *

    """
    return _VrmlData.VrmlData_Cylinder_get_type_name(*args)

def VrmlData_Cylinder_get_type_descriptor(*args):
    """
    VrmlData_Cylinder_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _VrmlData.VrmlData_Cylinder_get_type_descriptor(*args)

class VrmlData_ShapeConvert(object):
    """Algorithm converting one shape or a set of shapes to VrmlData_Scene."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(VrmlData_ShapeConvert self, VrmlData_Scene theScene, Standard_Real const theScale=1.) -> VrmlData_ShapeConvert

        Constructor.
        @param theScene
        Scene receiving all Vrml data.
        @param theScale
        Scale factor, considering that VRML standard specifies coordinates in
        meters. So if your data are in mm, you should provide theScale=0.001

        :type theScene: OCC.wrapper.VrmlData.VrmlData_Scene
        :type theScale: float

        """
        this = _VrmlData.new_VrmlData_ShapeConvert(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def AddShape(self, *args):
        """
        AddShape(VrmlData_ShapeConvert self, TopoDS_Shape theShape, char const * theName=0)

        Add one shape to the internal list, may be called several times with
        different shapes.

        :type theShape: OCC.wrapper.TopoDS.TopoDS_Shape
        :type theName: const char *

        """
        return _VrmlData.VrmlData_ShapeConvert_AddShape(self, *args)


    def Convert(self, *args):
        """
        Convert(VrmlData_ShapeConvert self, Standard_Boolean const theExtractFaces, Standard_Boolean const theExtractEdges, Standard_Real const theDeflection=0.01, Standard_Real const theDeflAngle=20)

        Convert all accumulated shapes and store them in myScene.
        The internal data structures are cleared in the end of convertion.
        @param theExtractFaces
        If True,  converter extracst faces from the shapes. 
        @param theExtractEdges
        If True,  converter extracts edges from the shapes.
        @param theDeflection 
        Deflection for tessellation of geometrical lines/surfaces. Existing mesh
        is used if its deflection is smaller than the one given by this
        parameter.
        @param theDeflAngle 
        Angular deflection for tessellation of geometrical lines. 

        :type theExtractFaces: bool
        :type theExtractEdges: bool
        :type theDeflection: float
        :type theDeflAngle: float

        """
        return _VrmlData.VrmlData_ShapeConvert_Convert(self, *args)

    __swig_destroy__ = _VrmlData.delete_VrmlData_ShapeConvert
VrmlData_ShapeConvert_swigregister = _VrmlData.VrmlData_ShapeConvert_swigregister
VrmlData_ShapeConvert_swigregister(VrmlData_ShapeConvert)

class Handle_VrmlData_Node(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_VrmlData_Node self)

        Nullify the handle


        """
        return _VrmlData.Handle_VrmlData_Node_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_VrmlData_Node self) -> bool

        Check for being null

        :rtype: bool

        """
        return _VrmlData.Handle_VrmlData_Node_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_VrmlData_Node self, VrmlData_Node thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _VrmlData.Handle_VrmlData_Node_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_VrmlData_Node self, Handle_VrmlData_Node theHandle) -> Handle_VrmlData_Node
        assign(Handle_VrmlData_Node self, VrmlData_Node thePtr) -> Handle_VrmlData_Node
        assign(Handle_VrmlData_Node self, Handle_VrmlData_Node theHandle) -> Handle_VrmlData_Node

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _VrmlData.Handle_VrmlData_Node_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_VrmlData_Node self) -> VrmlData_Node

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _VrmlData.Handle_VrmlData_Node_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_VrmlData_Node self) -> VrmlData_Node

        Member access operator (note non-const)

        :rtype: T *

        """
        return _VrmlData.Handle_VrmlData_Node___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_VrmlData_Node self) -> VrmlData_Node

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _VrmlData.Handle_VrmlData_Node___ref__(self, *args)


    def __hash__(self):
        return _VrmlData.Handle_VrmlData_Node___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _VrmlData.Handle_VrmlData_Node___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _VrmlData.new_Handle_VrmlData_Node(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_VrmlData.Handle_VrmlData_Node_DownCast)
    __swig_destroy__ = _VrmlData.delete_Handle_VrmlData_Node

    def Scene(self, *args):
        """
        Query the Scene that contains this Node

        :rtype: OCC.wrapper.VrmlData.VrmlData_Scene

        """
        res = _VrmlData.Handle_VrmlData_Node_Scene(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Name(self, *args):
        """
        Name(Handle_VrmlData_Node self) -> char const *

        Query the name

        :rtype: const char *

        """
        return _VrmlData.Handle_VrmlData_Node_Name(self, *args)


    def ReadNode(self, *args):
        """
        ReadNode(Handle_VrmlData_Node self, VrmlData_InBuffer & theBuffer, Handle_VrmlData_Node theNode, Handle_Standard_Type Type=0) -> VrmlData_ErrorStatus

        Read a complete node definition from VRML stream
        @param theBuffer
        Buffer receiving the input data.
        @param theNode
        <tt>[out]</tt> Node restored from the buffer data
        @param Type
        Node type to be checked. If it is NULL(default) no type checking is done.
        Otherwise the created node is matched and an error is returned if
        no match detected.

        :type theBuffer: OCC.wrapper.VrmlData.VrmlData_InBuffer
        :type theNode: OCC.wrapper.VrmlData.Handle_VrmlData_Node
        :type Type: OCC.wrapper.Standard.Handle_Standard_Type
        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.Handle_VrmlData_Node_ReadNode(self, *args)


    def Read(self, *args):
        """
        Read(Handle_VrmlData_Node self, VrmlData_InBuffer & theBuffer) -> VrmlData_ErrorStatus

        Read the Node from input stream.

        :type theBuffer: OCC.wrapper.VrmlData.VrmlData_InBuffer
        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.Handle_VrmlData_Node_Read(self, *args)


    def Write(self, *args):
        """
        Write(Handle_VrmlData_Node self, char const * thePrefix) -> VrmlData_ErrorStatus

        Write the Node to output stream.

        :type thePrefix: const char *
        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.Handle_VrmlData_Node_Write(self, *args)


    def IsDefault(self, *args):
        """
        IsDefault(Handle_VrmlData_Node self) -> Standard_Boolean

        Returns True if the node is default, then it would not be written.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _VrmlData.Handle_VrmlData_Node_IsDefault(self, *args)


    def WriteClosing(self, *args):
        """
        WriteClosing(Handle_VrmlData_Node self) -> VrmlData_ErrorStatus

        Write the closing brace in the end of a node output.

        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.Handle_VrmlData_Node_WriteClosing(self, *args)


    def Clone(self, *args):
        """
        Clone(Handle_VrmlData_Node self, Handle_VrmlData_Node arg2) -> Handle_VrmlData_Node

        Create a copy of this node.
        If the parameter is null, a new copied node is created. Otherwise new node
        is not created, but rather the given one is modified.<p>
        This method nullifies the argument node if its member myScene differs
        from that one of the current instance.

        :type : OCC.wrapper.VrmlData.Handle_VrmlData_Node
        :rtype: OCC.wrapper.VrmlData.Handle_VrmlData_Node

        """
        return _VrmlData.Handle_VrmlData_Node_Clone(self, *args)


    def ReadBoolean(self, *args):
        """
        ReadBoolean(Handle_VrmlData_Node self, VrmlData_InBuffer & theBuffer) -> VrmlData_ErrorStatus

        Read one boolean value (TRUE or FALSE).

        :type theBuffer: OCC.wrapper.VrmlData.VrmlData_InBuffer
        :type theResult: bool
        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.Handle_VrmlData_Node_ReadBoolean(self, *args)


    def ReadString(self, *args):
        """
        ReadString(Handle_VrmlData_Node self, VrmlData_InBuffer & theBuffer, TCollection_AsciiString theRes) -> VrmlData_ErrorStatus

        Read one quoted string, the quotes are removed.

        :type theBuffer: OCC.wrapper.VrmlData.VrmlData_InBuffer
        :type theRes: OCC.wrapper.TCollection.TCollection_AsciiString
        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.Handle_VrmlData_Node_ReadString(self, *args)


    def ReadMultiString(self, *args):
        """
        ReadMultiString(Handle_VrmlData_Node self, VrmlData_InBuffer & theBuffer, NCollection_List_TCollection_AsciiString theRes) -> VrmlData_ErrorStatus

        Read one quoted string, the quotes are removed.

        :type theBuffer: OCC.wrapper.VrmlData.VrmlData_InBuffer
        :type theRes: OCC.wrapper.TColStd.NCollection_List_TCollection_AsciiString
        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.Handle_VrmlData_Node_ReadMultiString(self, *args)


    def ReadInteger(self, *args):
        """
        ReadInteger(Handle_VrmlData_Node self, VrmlData_InBuffer & theBuffer) -> VrmlData_ErrorStatus

        Read one integer value.

        :type theBuffer: OCC.wrapper.VrmlData.VrmlData_InBuffer
        :type theResult: long &
        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.Handle_VrmlData_Node_ReadInteger(self, *args)


    def OK(self, *args):
        """
        OK(Handle_VrmlData_Node self, VrmlData_ErrorStatus const theStat) -> Standard_Boolean
        OK(Handle_VrmlData_Node self, VrmlData_ErrorStatus const theStat) -> Standard_Boolean

        :type outStat: OCC.wrapper.VrmlData.VrmlData_ErrorStatus
        :type theStat: OCC.wrapper.VrmlData.VrmlData_ErrorStatus
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _VrmlData.Handle_VrmlData_Node_OK(self, *args)


    def GlobalIndent(self, *args):
        """
        GlobalIndent(Handle_VrmlData_Node self) -> Standard_Integer

        Define the common Indent in spaces, for writing all nodes.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _VrmlData.Handle_VrmlData_Node_GlobalIndent(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_VrmlData_Node self) -> char const *

        :rtype: const char *

        """
        return _VrmlData.Handle_VrmlData_Node_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _VrmlData.Handle_VrmlData_Node_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _VrmlData.Handle_VrmlData_Node_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_VrmlData_Node self)

        Memory deallocator for transient classes


        """
        return _VrmlData.Handle_VrmlData_Node_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_VrmlData_Node self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_VrmlData_Node self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _VrmlData.Handle_VrmlData_Node_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_VrmlData_Node self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_VrmlData_Node self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _VrmlData.Handle_VrmlData_Node_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_VrmlData_Node self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _VrmlData.Handle_VrmlData_Node_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_VrmlData_Node self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _VrmlData.Handle_VrmlData_Node_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_VrmlData_Node self)

        Increments the reference counter of this object


        """
        return _VrmlData.Handle_VrmlData_Node_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_VrmlData_Node self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _VrmlData.Handle_VrmlData_Node_DecrementRefCounter(self, *args)

Handle_VrmlData_Node_swigregister = _VrmlData.Handle_VrmlData_Node_swigregister
Handle_VrmlData_Node_swigregister(Handle_VrmlData_Node)

def Handle_VrmlData_Node_DownCast(thing):
    return _VrmlData.Handle_VrmlData_Node_DownCast(thing)
Handle_VrmlData_Node_DownCast = _VrmlData.Handle_VrmlData_Node_DownCast

class Handle_VrmlData_IndexedFaceSet(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_VrmlData_IndexedFaceSet self)

        Nullify the handle


        """
        return _VrmlData.Handle_VrmlData_IndexedFaceSet_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_VrmlData_IndexedFaceSet self) -> bool

        Check for being null

        :rtype: bool

        """
        return _VrmlData.Handle_VrmlData_IndexedFaceSet_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_VrmlData_IndexedFaceSet self, VrmlData_IndexedFaceSet thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _VrmlData.Handle_VrmlData_IndexedFaceSet_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_VrmlData_IndexedFaceSet self, Handle_VrmlData_IndexedFaceSet theHandle) -> Handle_VrmlData_IndexedFaceSet
        assign(Handle_VrmlData_IndexedFaceSet self, VrmlData_IndexedFaceSet thePtr) -> Handle_VrmlData_IndexedFaceSet
        assign(Handle_VrmlData_IndexedFaceSet self, Handle_VrmlData_IndexedFaceSet theHandle) -> Handle_VrmlData_IndexedFaceSet

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _VrmlData.Handle_VrmlData_IndexedFaceSet_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_VrmlData_IndexedFaceSet self) -> VrmlData_IndexedFaceSet

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _VrmlData.Handle_VrmlData_IndexedFaceSet_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_VrmlData_IndexedFaceSet self) -> VrmlData_IndexedFaceSet

        Member access operator (note non-const)

        :rtype: T *

        """
        return _VrmlData.Handle_VrmlData_IndexedFaceSet___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_VrmlData_IndexedFaceSet self) -> VrmlData_IndexedFaceSet

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _VrmlData.Handle_VrmlData_IndexedFaceSet___ref__(self, *args)


    def __hash__(self):
        return _VrmlData.Handle_VrmlData_IndexedFaceSet___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _VrmlData.Handle_VrmlData_IndexedFaceSet___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _VrmlData.new_Handle_VrmlData_IndexedFaceSet(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_VrmlData.Handle_VrmlData_IndexedFaceSet_DownCast)
    __swig_destroy__ = _VrmlData.delete_Handle_VrmlData_IndexedFaceSet

    def Normals(self, *args):
        """
        Query the Normals.

        :rtype: OCC.wrapper.VrmlData.Handle_VrmlData_Normal

        """
        res = _VrmlData.Handle_VrmlData_IndexedFaceSet_Normals(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Colors(self, *args):
        """
        Query the Colors.

        :rtype: OCC.wrapper.VrmlData.Handle_VrmlData_Color

        """
        res = _VrmlData.Handle_VrmlData_IndexedFaceSet_Colors(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def TextureCoords(self, *args):
        """
        Query the Texture Coordinates.

        :rtype: OCC.wrapper.VrmlData.Handle_VrmlData_TextureCoordinate

        """
        res = _VrmlData.Handle_VrmlData_IndexedFaceSet_TextureCoords(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Coordinates(self, *args):
        """
        Query the Coordinates.

        :rtype: OCC.wrapper.VrmlData.Handle_VrmlData_Coordinate

        """
        res = _VrmlData.Handle_VrmlData_IndexedFaceSet_Coordinates(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Polygons(self, *args):
        """
        Polygons(Handle_VrmlData_IndexedFaceSet self, Standard_Integer const **& arrPolygons) -> size_t

        Query the array of polygons

        :type arrPolygons: int
        :rtype: size_t

        """
        return _VrmlData.Handle_VrmlData_IndexedFaceSet_Polygons(self, *args)


    def Polygon(self, *args):
        """
        Polygon(Handle_VrmlData_IndexedFaceSet self, Standard_Integer const iFace, Standard_Integer const *& outIndice) -> Standard_Integer

        Query one polygon.
        @param iFace
        rank of the polygon [0 .. N-1]
        @param outIndice
        <tt>[out]</tt> array of vertex indice
        @return
        number of vertice in the polygon - the dimension of outIndice array

        :type iFace: int
        :type outIndice: int
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _VrmlData.Handle_VrmlData_IndexedFaceSet_Polygon(self, *args)


    def SetCoordinates(self, *args):
        """
        SetCoordinates(Handle_VrmlData_IndexedFaceSet self, Handle_VrmlData_Coordinate theCoord)

        Set the nodes

        :type theCoord: OCC.wrapper.VrmlData.Handle_VrmlData_Coordinate

        """
        return _VrmlData.Handle_VrmlData_IndexedFaceSet_SetCoordinates(self, *args)


    def SetPolygons(self, *args):
        """
        SetPolygons(Handle_VrmlData_IndexedFaceSet self, Standard_Size const nPolygons, Standard_Integer const ** thePolygons)

        Set the polygons

        :type nPolygons: int
        :type thePolygons: int

        """
        return _VrmlData.Handle_VrmlData_IndexedFaceSet_SetPolygons(self, *args)


    def ArrayNormalInd(self, *args):
        """
        ArrayNormalInd(Handle_VrmlData_IndexedFaceSet self, Standard_Integer const **& arrNormalInd) -> size_t

        Query the array of normal indice
        @param arrNormalInd
        <tt>[out]</tt> array of normalIndex as it is described in VRML2.0 spec
        @return
        Number of integers in the array arrNormalInd.

        :type arrNormalInd: int
        :rtype: size_t

        """
        return _VrmlData.Handle_VrmlData_IndexedFaceSet_ArrayNormalInd(self, *args)


    def IndiceNormals(self, *args):
        """
        IndiceNormals(Handle_VrmlData_IndexedFaceSet self, Standard_Integer const iFace, Standard_Integer const *& outIndice) -> Standard_Integer

        Query normals indice for one face. This method should be called after
        checking myArrNormalInd != NULL, otherwise exception will be thrown.
        @param iFace
        rank of the face [0 .. N-1]
        @param outIndice
        <tt>[out]</tt> array of normals indice
        @return
        number of indice in the array - the dimension of outIndice array

        :type iFace: int
        :type outIndice: int
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _VrmlData.Handle_VrmlData_IndexedFaceSet_IndiceNormals(self, *args)


    def SetNormalInd(self, *args):
        """
        SetNormalInd(Handle_VrmlData_IndexedFaceSet self, Standard_Size const nIndice, Standard_Integer const ** theIndice)

        Set the normals array of indice

        :type nIndice: int
        :type theIndice: int

        """
        return _VrmlData.Handle_VrmlData_IndexedFaceSet_SetNormalInd(self, *args)


    def SetNormals(self, *args):
        """
        SetNormals(Handle_VrmlData_IndexedFaceSet self, Handle_VrmlData_Normal theNormals)

        Set the normals node

        :type theNormals: OCC.wrapper.VrmlData.Handle_VrmlData_Normal

        """
        return _VrmlData.Handle_VrmlData_IndexedFaceSet_SetNormals(self, *args)


    def SetNormalPerVertex(self, *args):
        """
        SetNormalPerVertex(Handle_VrmlData_IndexedFaceSet self, Standard_Boolean const isNormalPerVertex)

        Set the boolean value "normalPerVertex"

        :type isNormalPerVertex: bool

        """
        return _VrmlData.Handle_VrmlData_IndexedFaceSet_SetNormalPerVertex(self, *args)


    def ArrayColorInd(self, *args):
        """
        ArrayColorInd(Handle_VrmlData_IndexedFaceSet self, Standard_Integer const **& arrColorInd) -> size_t

        Query the array of color indice
        @param arrColorInd
        <tt>[out]</tt> array of colorIndex as it is described in VRML2.0 spec
        @return
        Number of integers in the array arrColorInd.

        :type arrColorInd: int
        :rtype: size_t

        """
        return _VrmlData.Handle_VrmlData_IndexedFaceSet_ArrayColorInd(self, *args)


    def GetColor(self, *args):
        """
        GetColor(Handle_VrmlData_IndexedFaceSet self, Standard_Integer const iFace, Standard_Integer const iVertex) -> Quantity_Color

        Query a color for one node in the given element. The color is
        interpreted according to fields myColors, myArrColorInd,
        myColorPerVertex, as defined in VRML 2.0.
        @param iFace
        rank of the polygon [0 .. N-1]
        @param iVertex
        rank of the vertex in the polygon [0 .. M-1]. This parameter is ignored
        if (myColorPerVertex == False)
        @return
        Color value (RGB); if the color is indefinite then returns (0., 0., 0.)

        :type iFace: int
        :type iVertex: int
        :rtype: OCC.wrapper.Quantity.Quantity_Color

        """
        return _VrmlData.Handle_VrmlData_IndexedFaceSet_GetColor(self, *args)


    def SetColorInd(self, *args):
        """
        SetColorInd(Handle_VrmlData_IndexedFaceSet self, Standard_Size const nIndice, Standard_Integer const ** theIndice)

        Set the colors array of indice

        :type nIndice: int
        :type theIndice: int

        """
        return _VrmlData.Handle_VrmlData_IndexedFaceSet_SetColorInd(self, *args)


    def SetColors(self, *args):
        """
        SetColors(Handle_VrmlData_IndexedFaceSet self, Handle_VrmlData_Color theColors)

        Set the Color node

        :type theColors: OCC.wrapper.VrmlData.Handle_VrmlData_Color

        """
        return _VrmlData.Handle_VrmlData_IndexedFaceSet_SetColors(self, *args)


    def SetColorPerVertex(self, *args):
        """
        SetColorPerVertex(Handle_VrmlData_IndexedFaceSet self, Standard_Boolean const isColorPerVertex)

        Set the boolean value "colorPerVertex"

        :type isColorPerVertex: bool

        """
        return _VrmlData.Handle_VrmlData_IndexedFaceSet_SetColorPerVertex(self, *args)


    def ArrayTextureCoordInd(self, *args):
        """
        ArrayTextureCoordInd(Handle_VrmlData_IndexedFaceSet self, Standard_Integer const **& arrTextureCoordInd) -> size_t

        Query the array of texture coordinate indice
        @param arrTextureCoordInd
        <tt>[out]</tt> array of texCoordIndex as it is described in VRML2.0 spec
        @return
        Number of integers in the array texCoordIndex.

        :type arrTextureCoordInd: int
        :rtype: size_t

        """
        return _VrmlData.Handle_VrmlData_IndexedFaceSet_ArrayTextureCoordInd(self, *args)


    def SetTextureCoordInd(self, *args):
        """
        SetTextureCoordInd(Handle_VrmlData_IndexedFaceSet self, Standard_Size const nIndice, Standard_Integer const ** theIndice)

        Set the TexCoordiante array of indice

        :type nIndice: int
        :type theIndice: int

        """
        return _VrmlData.Handle_VrmlData_IndexedFaceSet_SetTextureCoordInd(self, *args)


    def SetTextureCoords(self, *args):
        """
        SetTextureCoords(Handle_VrmlData_IndexedFaceSet self, Handle_VrmlData_TextureCoordinate tc)

        Set the Texture Coordinate node

        :type tc: OCC.wrapper.VrmlData.Handle_VrmlData_TextureCoordinate

        """
        return _VrmlData.Handle_VrmlData_IndexedFaceSet_SetTextureCoords(self, *args)


    def TShape(self, *args):
        """
        Query the shape. This method checks the flag myIsModified; if True it
        should rebuild the shape presentation.

        :rtype: OCC.wrapper.TopoDS.Handle_TopoDS_TShape

        """
        res = _VrmlData.Handle_VrmlData_IndexedFaceSet_TShape(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Clone(self, *args):
        """
        Clone(Handle_VrmlData_IndexedFaceSet self, Handle_VrmlData_Node theOther) -> Handle_VrmlData_Node

        Create a copy of this node.
        If the parameter is null, a new copied node is created. Otherwise new node
        is not created, but rather the given one is modified.

        :type theOther: OCC.wrapper.VrmlData.Handle_VrmlData_Node
        :rtype: OCC.wrapper.VrmlData.Handle_VrmlData_Node

        """
        return _VrmlData.Handle_VrmlData_IndexedFaceSet_Clone(self, *args)


    def Read(self, *args):
        """
        Read(Handle_VrmlData_IndexedFaceSet self, VrmlData_InBuffer & theBuffer) -> VrmlData_ErrorStatus

        Read the Node from input stream.

        :type theBuffer: OCC.wrapper.VrmlData.VrmlData_InBuffer
        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.Handle_VrmlData_IndexedFaceSet_Read(self, *args)


    def Write(self, *args):
        """
        Write(Handle_VrmlData_IndexedFaceSet self, char const * thePrefix) -> VrmlData_ErrorStatus

        Write the Node to output stream.

        :type thePrefix: const char *
        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.Handle_VrmlData_IndexedFaceSet_Write(self, *args)


    def IsDefault(self, *args):
        """
        IsDefault(Handle_VrmlData_IndexedFaceSet self) -> Standard_Boolean

        Returns True if the node is default, so that it should not be written.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _VrmlData.Handle_VrmlData_IndexedFaceSet_IsDefault(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_VrmlData_IndexedFaceSet self) -> char const *

        :rtype: const char *

        """
        return _VrmlData.Handle_VrmlData_IndexedFaceSet_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _VrmlData.Handle_VrmlData_IndexedFaceSet_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _VrmlData.Handle_VrmlData_IndexedFaceSet_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def IsCCW(self, *args):
        """
        IsCCW(Handle_VrmlData_IndexedFaceSet self) -> Standard_Boolean

        Query "Is Counter-Clockwise" attribute

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _VrmlData.Handle_VrmlData_IndexedFaceSet_IsCCW(self, *args)


    def IsSolid(self, *args):
        """
        IsSolid(Handle_VrmlData_IndexedFaceSet self) -> Standard_Boolean

        Query "Is Solid" attribute

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _VrmlData.Handle_VrmlData_IndexedFaceSet_IsSolid(self, *args)


    def IsConvex(self, *args):
        """
        IsConvex(Handle_VrmlData_IndexedFaceSet self) -> Standard_Boolean

        Query "Is Convex" attribute

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _VrmlData.Handle_VrmlData_IndexedFaceSet_IsConvex(self, *args)


    def CreaseAngle(self, *args):
        """
        CreaseAngle(Handle_VrmlData_IndexedFaceSet self) -> Standard_Real

        Query the Crease Angle

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _VrmlData.Handle_VrmlData_IndexedFaceSet_CreaseAngle(self, *args)


    def SetCCW(self, *args):
        """
        SetCCW(Handle_VrmlData_IndexedFaceSet self, Standard_Boolean const theValue)

        Set "Is Counter-Clockwise" attribute

        :type theValue: bool

        """
        return _VrmlData.Handle_VrmlData_IndexedFaceSet_SetCCW(self, *args)


    def SetSolid(self, *args):
        """
        SetSolid(Handle_VrmlData_IndexedFaceSet self, Standard_Boolean const theValue)

        Set "Is Solid" attribute

        :type theValue: bool

        """
        return _VrmlData.Handle_VrmlData_IndexedFaceSet_SetSolid(self, *args)


    def SetConvex(self, *args):
        """
        SetConvex(Handle_VrmlData_IndexedFaceSet self, Standard_Boolean const theValue)

        Set "Is Convex" attribute

        :type theValue: bool

        """
        return _VrmlData.Handle_VrmlData_IndexedFaceSet_SetConvex(self, *args)


    def SetCreaseAngle(self, *args):
        """
        SetCreaseAngle(Handle_VrmlData_IndexedFaceSet self, Standard_Real const theValue)

        Set "Is Convex" attribute

        :type theValue: float

        """
        return _VrmlData.Handle_VrmlData_IndexedFaceSet_SetCreaseAngle(self, *args)


    def Scene(self, *args):
        """
        Query the Scene that contains this Node

        :rtype: OCC.wrapper.VrmlData.VrmlData_Scene

        """
        res = _VrmlData.Handle_VrmlData_IndexedFaceSet_Scene(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Name(self, *args):
        """
        Name(Handle_VrmlData_IndexedFaceSet self) -> char const *

        Query the name

        :rtype: const char *

        """
        return _VrmlData.Handle_VrmlData_IndexedFaceSet_Name(self, *args)


    def ReadNode(self, *args):
        """
        ReadNode(Handle_VrmlData_IndexedFaceSet self, VrmlData_InBuffer & theBuffer, Handle_VrmlData_Node theNode, Handle_Standard_Type Type=0) -> VrmlData_ErrorStatus

        Read a complete node definition from VRML stream
        @param theBuffer
        Buffer receiving the input data.
        @param theNode
        <tt>[out]</tt> Node restored from the buffer data
        @param Type
        Node type to be checked. If it is NULL(default) no type checking is done.
        Otherwise the created node is matched and an error is returned if
        no match detected.

        :type theBuffer: OCC.wrapper.VrmlData.VrmlData_InBuffer
        :type theNode: OCC.wrapper.VrmlData.Handle_VrmlData_Node
        :type Type: OCC.wrapper.Standard.Handle_Standard_Type
        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.Handle_VrmlData_IndexedFaceSet_ReadNode(self, *args)


    def WriteClosing(self, *args):
        """
        WriteClosing(Handle_VrmlData_IndexedFaceSet self) -> VrmlData_ErrorStatus

        Write the closing brace in the end of a node output.

        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.Handle_VrmlData_IndexedFaceSet_WriteClosing(self, *args)


    def ReadBoolean(self, *args):
        """
        ReadBoolean(Handle_VrmlData_IndexedFaceSet self, VrmlData_InBuffer & theBuffer) -> VrmlData_ErrorStatus

        Read one boolean value (TRUE or FALSE).

        :type theBuffer: OCC.wrapper.VrmlData.VrmlData_InBuffer
        :type theResult: bool
        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.Handle_VrmlData_IndexedFaceSet_ReadBoolean(self, *args)


    def ReadString(self, *args):
        """
        ReadString(Handle_VrmlData_IndexedFaceSet self, VrmlData_InBuffer & theBuffer, TCollection_AsciiString theRes) -> VrmlData_ErrorStatus

        Read one quoted string, the quotes are removed.

        :type theBuffer: OCC.wrapper.VrmlData.VrmlData_InBuffer
        :type theRes: OCC.wrapper.TCollection.TCollection_AsciiString
        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.Handle_VrmlData_IndexedFaceSet_ReadString(self, *args)


    def ReadMultiString(self, *args):
        """
        ReadMultiString(Handle_VrmlData_IndexedFaceSet self, VrmlData_InBuffer & theBuffer, NCollection_List_TCollection_AsciiString theRes) -> VrmlData_ErrorStatus

        Read one quoted string, the quotes are removed.

        :type theBuffer: OCC.wrapper.VrmlData.VrmlData_InBuffer
        :type theRes: OCC.wrapper.TColStd.NCollection_List_TCollection_AsciiString
        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.Handle_VrmlData_IndexedFaceSet_ReadMultiString(self, *args)


    def ReadInteger(self, *args):
        """
        ReadInteger(Handle_VrmlData_IndexedFaceSet self, VrmlData_InBuffer & theBuffer) -> VrmlData_ErrorStatus

        Read one integer value.

        :type theBuffer: OCC.wrapper.VrmlData.VrmlData_InBuffer
        :type theResult: long &
        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.Handle_VrmlData_IndexedFaceSet_ReadInteger(self, *args)


    def OK(self, *args):
        """
        OK(Handle_VrmlData_IndexedFaceSet self, VrmlData_ErrorStatus const theStat) -> Standard_Boolean
        OK(Handle_VrmlData_IndexedFaceSet self, VrmlData_ErrorStatus const theStat) -> Standard_Boolean

        :type outStat: OCC.wrapper.VrmlData.VrmlData_ErrorStatus
        :type theStat: OCC.wrapper.VrmlData.VrmlData_ErrorStatus
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _VrmlData.Handle_VrmlData_IndexedFaceSet_OK(self, *args)


    def GlobalIndent(self, *args):
        """
        GlobalIndent(Handle_VrmlData_IndexedFaceSet self) -> Standard_Integer

        Define the common Indent in spaces, for writing all nodes.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _VrmlData.Handle_VrmlData_IndexedFaceSet_GlobalIndent(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_VrmlData_IndexedFaceSet self)

        Memory deallocator for transient classes


        """
        return _VrmlData.Handle_VrmlData_IndexedFaceSet_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_VrmlData_IndexedFaceSet self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_VrmlData_IndexedFaceSet self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _VrmlData.Handle_VrmlData_IndexedFaceSet_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_VrmlData_IndexedFaceSet self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_VrmlData_IndexedFaceSet self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _VrmlData.Handle_VrmlData_IndexedFaceSet_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_VrmlData_IndexedFaceSet self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _VrmlData.Handle_VrmlData_IndexedFaceSet_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_VrmlData_IndexedFaceSet self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _VrmlData.Handle_VrmlData_IndexedFaceSet_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_VrmlData_IndexedFaceSet self)

        Increments the reference counter of this object


        """
        return _VrmlData.Handle_VrmlData_IndexedFaceSet_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_VrmlData_IndexedFaceSet self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _VrmlData.Handle_VrmlData_IndexedFaceSet_DecrementRefCounter(self, *args)

Handle_VrmlData_IndexedFaceSet_swigregister = _VrmlData.Handle_VrmlData_IndexedFaceSet_swigregister
Handle_VrmlData_IndexedFaceSet_swigregister(Handle_VrmlData_IndexedFaceSet)

def Handle_VrmlData_IndexedFaceSet_DownCast(thing):
    return _VrmlData.Handle_VrmlData_IndexedFaceSet_DownCast(thing)
Handle_VrmlData_IndexedFaceSet_DownCast = _VrmlData.Handle_VrmlData_IndexedFaceSet_DownCast

class NCollection_List_TCollection_ExtendedString(NCollection.NCollection_BaseList):
    """
    Purpose:      Simple list to link  items together keeping the first 
    and the last one.
    Inherits BaseList, adding the data item to each node.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_List_TCollection_ExtendedString self) -> NCollection_List< TCollection_ExtendedString >::iterator

        Returns an iterator pointing to the first element in the list.

        :rtype: iterator

        """
        return _VrmlData.NCollection_List_TCollection_ExtendedString_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_List_TCollection_ExtendedString self) -> NCollection_List< TCollection_ExtendedString >::iterator

        Returns an iterator referring to the past-the-end element in the list.

        :rtype: iterator

        """
        return _VrmlData.NCollection_List_TCollection_ExtendedString_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_List_TCollection_ExtendedString self) -> NCollection_List< TCollection_ExtendedString >::const_iterator

        Returns a const iterator pointing to the first element in the list.

        :rtype: const_iterator

        """
        return _VrmlData.NCollection_List_TCollection_ExtendedString_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_List_TCollection_ExtendedString self) -> NCollection_List< TCollection_ExtendedString >::const_iterator

        Returns a const iterator referring to the past-the-end element in the list.

        :rtype: const_iterator

        """
        return _VrmlData.NCollection_List_TCollection_ExtendedString_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:      Simple list to link  items together keeping the first 
        and the last one.
        Inherits BaseList, adding the data item to each node.
        """
        this = _VrmlData.new_NCollection_List_TCollection_ExtendedString(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Size(self, *args):
        """
        Size(NCollection_List_TCollection_ExtendedString self) -> Standard_Integer

        Size - Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _VrmlData.NCollection_List_TCollection_ExtendedString_Size(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_List_TCollection_ExtendedString self, NCollection_List_TCollection_ExtendedString theOther) -> NCollection_List_TCollection_ExtendedString

        Replace this list by the items of another list (theOther parameter).
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_List
        :rtype: OCC.wrapper.NCollection.NCollection_List

        """
        return _VrmlData.NCollection_List_TCollection_ExtendedString_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_List_TCollection_ExtendedString self, NCollection_List_TCollection_ExtendedString theOther) -> NCollection_List_TCollection_ExtendedString

        Replacement operator

        :type theOther: OCC.wrapper.NCollection.NCollection_List
        :rtype: OCC.wrapper.NCollection.NCollection_List

        """
        return _VrmlData.NCollection_List_TCollection_ExtendedString_assign(self, *args)


    def Clear(self, *args):
        """
        Clear(NCollection_List_TCollection_ExtendedString self, Handle_NCollection_BaseAllocator theAllocator=0)

        Clear this list

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _VrmlData.NCollection_List_TCollection_ExtendedString_Clear(self, *args)


    def First(self, *args):
        """
        First item

        :rtype: const TheItemType &

        """
        res = _VrmlData.NCollection_List_TCollection_ExtendedString_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Last(self, *args):
        """
        Last item

        :rtype: const TheItemType &

        """
        res = _VrmlData.NCollection_List_TCollection_ExtendedString_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Append(self, *args):
        """
        Append(NCollection_List_TCollection_ExtendedString self, TCollection_ExtendedString theItem) -> TCollection_ExtendedString
        Append(NCollection_List_TCollection_ExtendedString self, TCollection_ExtendedString theItem, NCollection_List< TCollection_ExtendedString >::Iterator & theIter)
        Append(NCollection_List_TCollection_ExtendedString self, NCollection_List_TCollection_ExtendedString theOther)

        Append another list at the end

        :type theOther: OCC.wrapper.NCollection.NCollection_List

        """
        return _VrmlData.NCollection_List_TCollection_ExtendedString_Append(self, *args)


    def Prepend(self, *args):
        """
        Prepend(NCollection_List_TCollection_ExtendedString self, TCollection_ExtendedString theItem) -> TCollection_ExtendedString
        Prepend(NCollection_List_TCollection_ExtendedString self, NCollection_List_TCollection_ExtendedString theOther)

        Prepend another list at the beginning

        :type theOther: OCC.wrapper.NCollection.NCollection_List

        """
        return _VrmlData.NCollection_List_TCollection_ExtendedString_Prepend(self, *args)


    def RemoveFirst(self, *args):
        """
        RemoveFirst(NCollection_List_TCollection_ExtendedString self)

        RemoveFirst item


        """
        return _VrmlData.NCollection_List_TCollection_ExtendedString_RemoveFirst(self, *args)


    def Remove(self, *args):
        """
        Remove(NCollection_List_TCollection_ExtendedString self, NCollection_List< TCollection_ExtendedString >::Iterator & theIter)

        Remove item pointed by iterator theIter; 
        theIter is then set to the next item

        :type theIter: Iterator

        """
        return _VrmlData.NCollection_List_TCollection_ExtendedString_Remove(self, *args)


    def InsertBefore(self, *args):
        """
        InsertBefore(NCollection_List_TCollection_ExtendedString self, TCollection_ExtendedString theItem, NCollection_List< TCollection_ExtendedString >::Iterator & theIter) -> TCollection_ExtendedString
        InsertBefore(NCollection_List_TCollection_ExtendedString self, NCollection_List_TCollection_ExtendedString theOther, NCollection_List< TCollection_ExtendedString >::Iterator & theIter)

        InsertBefore

        :type theOther: OCC.wrapper.NCollection.NCollection_List
        :type theIter: Iterator

        """
        return _VrmlData.NCollection_List_TCollection_ExtendedString_InsertBefore(self, *args)


    def InsertAfter(self, *args):
        """
        InsertAfter(NCollection_List_TCollection_ExtendedString self, TCollection_ExtendedString theItem, NCollection_List< TCollection_ExtendedString >::Iterator & theIter) -> TCollection_ExtendedString
        InsertAfter(NCollection_List_TCollection_ExtendedString self, NCollection_List_TCollection_ExtendedString theOther, NCollection_List< TCollection_ExtendedString >::Iterator & theIter)

        InsertAfter

        :type theOther: OCC.wrapper.NCollection.NCollection_List
        :type theIter: Iterator

        """
        return _VrmlData.NCollection_List_TCollection_ExtendedString_InsertAfter(self, *args)


    def Reverse(self, *args):
        """
        Reverse(NCollection_List_TCollection_ExtendedString self)

        Reverse the list


        """
        return _VrmlData.NCollection_List_TCollection_ExtendedString_Reverse(self, *args)


    def __iter__(self):
        return _VrmlData.NCollection_List_TCollection_ExtendedString___iter__(self)
    __swig_destroy__ = _VrmlData.delete_NCollection_List_TCollection_ExtendedString
NCollection_List_TCollection_ExtendedString_swigregister = _VrmlData.NCollection_List_TCollection_ExtendedString_swigregister
NCollection_List_TCollection_ExtendedString_swigregister(NCollection_List_TCollection_ExtendedString)

class NCollection_List_TCollection_ExtendedString_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _VrmlData.new_NCollection_List_TCollection_ExtendedString_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _VrmlData.delete_NCollection_List_TCollection_ExtendedString_IteratorHelper

    def __next__(self):
        return _VrmlData.NCollection_List_TCollection_ExtendedString_IteratorHelper___next__(self)
NCollection_List_TCollection_ExtendedString_IteratorHelper_swigregister = _VrmlData.NCollection_List_TCollection_ExtendedString_IteratorHelper_swigregister
NCollection_List_TCollection_ExtendedString_IteratorHelper_swigregister(NCollection_List_TCollection_ExtendedString_IteratorHelper)

class Handle_VrmlData_Normal(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_VrmlData_Normal self)

        Nullify the handle


        """
        return _VrmlData.Handle_VrmlData_Normal_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_VrmlData_Normal self) -> bool

        Check for being null

        :rtype: bool

        """
        return _VrmlData.Handle_VrmlData_Normal_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_VrmlData_Normal self, VrmlData_Normal thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _VrmlData.Handle_VrmlData_Normal_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_VrmlData_Normal self, Handle_VrmlData_Normal theHandle) -> Handle_VrmlData_Normal
        assign(Handle_VrmlData_Normal self, VrmlData_Normal thePtr) -> Handle_VrmlData_Normal
        assign(Handle_VrmlData_Normal self, Handle_VrmlData_Normal theHandle) -> Handle_VrmlData_Normal

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _VrmlData.Handle_VrmlData_Normal_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_VrmlData_Normal self) -> VrmlData_Normal

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _VrmlData.Handle_VrmlData_Normal_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_VrmlData_Normal self) -> VrmlData_Normal

        Member access operator (note non-const)

        :rtype: T *

        """
        return _VrmlData.Handle_VrmlData_Normal___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_VrmlData_Normal self) -> VrmlData_Normal

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _VrmlData.Handle_VrmlData_Normal___ref__(self, *args)


    def __hash__(self):
        return _VrmlData.Handle_VrmlData_Normal___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _VrmlData.Handle_VrmlData_Normal___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _VrmlData.new_Handle_VrmlData_Normal(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_VrmlData.Handle_VrmlData_Normal_DownCast)
    __swig_destroy__ = _VrmlData.delete_Handle_VrmlData_Normal

    def Normal(self, *args):
        """
        Query one normal
        @param i
        index in the array of normals [0 .. N-1]
        @return
        the normal value for the index. If index irrelevant, returns (0., 0., 0.)

        :type i: int
        :rtype: OCC.wrapper.gp.gp_XYZ

        """
        res = _VrmlData.Handle_VrmlData_Normal_Normal(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Clone(self, *args):
        """
        Clone(Handle_VrmlData_Normal self, Handle_VrmlData_Node theOther) -> Handle_VrmlData_Node

        Create a copy of this node.
        If the parameter is null, a new copied node is created. Otherwise new node
        is not created, but rather the given one is modified.

        :type theOther: OCC.wrapper.VrmlData.Handle_VrmlData_Node
        :rtype: OCC.wrapper.VrmlData.Handle_VrmlData_Node

        """
        return _VrmlData.Handle_VrmlData_Normal_Clone(self, *args)


    def Read(self, *args):
        """
        Read(Handle_VrmlData_Normal self, VrmlData_InBuffer & theBuffer) -> VrmlData_ErrorStatus

        Read the Node from input stream.

        :type theBuffer: OCC.wrapper.VrmlData.VrmlData_InBuffer
        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.Handle_VrmlData_Normal_Read(self, *args)


    def Write(self, *args):
        """
        Write(Handle_VrmlData_Normal self, char const * thePrefix) -> VrmlData_ErrorStatus

        Write the Node to the Scene output.

        :type thePrefix: const char *
        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.Handle_VrmlData_Normal_Write(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_VrmlData_Normal self) -> char const *

        :rtype: const char *

        """
        return _VrmlData.Handle_VrmlData_Normal_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _VrmlData.Handle_VrmlData_Normal_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _VrmlData.Handle_VrmlData_Normal_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Length(self, *args):
        """
        Length(Handle_VrmlData_Normal self) -> Standard_Size

        Query the number of vectors

        :rtype: OCC.wrapper.Standard.Standard_Size

        """
        return _VrmlData.Handle_VrmlData_Normal_Length(self, *args)


    def Values(self, *args):
        """
        Values(Handle_VrmlData_Normal self) -> gp_XYZ

        Query the array

        :rtype: OCC.wrapper.gp.gp_XYZ

        """
        return _VrmlData.Handle_VrmlData_Normal_Values(self, *args)


    def AllocateValues(self, *args):
        """
        AllocateValues(Handle_VrmlData_Normal self, Standard_Size const theLength) -> Standard_Boolean

        Create a data array and assign the field myArray.
        @return
        True if allocation was successful.

        :type theLength: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _VrmlData.Handle_VrmlData_Normal_AllocateValues(self, *args)


    def SetValues(self, *args):
        """
        SetValues(Handle_VrmlData_Normal self, Standard_Size const nValues, gp_XYZ arrValues)

        Set the array data

        :type nValues: int
        :type arrValues: OCC.wrapper.gp.gp_XYZ

        """
        return _VrmlData.Handle_VrmlData_Normal_SetValues(self, *args)


    def ReadArray(self, *args):
        """
        ReadArray(Handle_VrmlData_Normal self, VrmlData_InBuffer & theBuffer, char const * theName, Standard_Boolean const isScale) -> VrmlData_ErrorStatus

        Read the Node from input stream.

        :type theBuffer: OCC.wrapper.VrmlData.VrmlData_InBuffer
        :type theName: const char *
        :type isScale: bool
        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.Handle_VrmlData_Normal_ReadArray(self, *args)


    def WriteArray(self, *args):
        """
        WriteArray(Handle_VrmlData_Normal self, char const * theName, Standard_Boolean const isScale) -> VrmlData_ErrorStatus

        Write the Node to the output stream currently opened in Scene.

        :type theName: const char *
        :type isScale: bool
        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.Handle_VrmlData_Normal_WriteArray(self, *args)


    def IsDefault(self, *args):
        """
        IsDefault(Handle_VrmlData_Normal self) -> Standard_Boolean

        Returns True if the node is default, so that it should not be written.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _VrmlData.Handle_VrmlData_Normal_IsDefault(self, *args)


    def Scene(self, *args):
        """
        Query the Scene that contains this Node

        :rtype: OCC.wrapper.VrmlData.VrmlData_Scene

        """
        res = _VrmlData.Handle_VrmlData_Normal_Scene(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Name(self, *args):
        """
        Name(Handle_VrmlData_Normal self) -> char const *

        Query the name

        :rtype: const char *

        """
        return _VrmlData.Handle_VrmlData_Normal_Name(self, *args)


    def ReadNode(self, *args):
        """
        ReadNode(Handle_VrmlData_Normal self, VrmlData_InBuffer & theBuffer, Handle_VrmlData_Node theNode, Handle_Standard_Type Type=0) -> VrmlData_ErrorStatus

        Read a complete node definition from VRML stream
        @param theBuffer
        Buffer receiving the input data.
        @param theNode
        <tt>[out]</tt> Node restored from the buffer data
        @param Type
        Node type to be checked. If it is NULL(default) no type checking is done.
        Otherwise the created node is matched and an error is returned if
        no match detected.

        :type theBuffer: OCC.wrapper.VrmlData.VrmlData_InBuffer
        :type theNode: OCC.wrapper.VrmlData.Handle_VrmlData_Node
        :type Type: OCC.wrapper.Standard.Handle_Standard_Type
        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.Handle_VrmlData_Normal_ReadNode(self, *args)


    def WriteClosing(self, *args):
        """
        WriteClosing(Handle_VrmlData_Normal self) -> VrmlData_ErrorStatus

        Write the closing brace in the end of a node output.

        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.Handle_VrmlData_Normal_WriteClosing(self, *args)


    def ReadBoolean(self, *args):
        """
        ReadBoolean(Handle_VrmlData_Normal self, VrmlData_InBuffer & theBuffer) -> VrmlData_ErrorStatus

        Read one boolean value (TRUE or FALSE).

        :type theBuffer: OCC.wrapper.VrmlData.VrmlData_InBuffer
        :type theResult: bool
        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.Handle_VrmlData_Normal_ReadBoolean(self, *args)


    def ReadString(self, *args):
        """
        ReadString(Handle_VrmlData_Normal self, VrmlData_InBuffer & theBuffer, TCollection_AsciiString theRes) -> VrmlData_ErrorStatus

        Read one quoted string, the quotes are removed.

        :type theBuffer: OCC.wrapper.VrmlData.VrmlData_InBuffer
        :type theRes: OCC.wrapper.TCollection.TCollection_AsciiString
        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.Handle_VrmlData_Normal_ReadString(self, *args)


    def ReadMultiString(self, *args):
        """
        ReadMultiString(Handle_VrmlData_Normal self, VrmlData_InBuffer & theBuffer, NCollection_List_TCollection_AsciiString theRes) -> VrmlData_ErrorStatus

        Read one quoted string, the quotes are removed.

        :type theBuffer: OCC.wrapper.VrmlData.VrmlData_InBuffer
        :type theRes: OCC.wrapper.TColStd.NCollection_List_TCollection_AsciiString
        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.Handle_VrmlData_Normal_ReadMultiString(self, *args)


    def ReadInteger(self, *args):
        """
        ReadInteger(Handle_VrmlData_Normal self, VrmlData_InBuffer & theBuffer) -> VrmlData_ErrorStatus

        Read one integer value.

        :type theBuffer: OCC.wrapper.VrmlData.VrmlData_InBuffer
        :type theResult: long &
        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.Handle_VrmlData_Normal_ReadInteger(self, *args)


    def OK(self, *args):
        """
        OK(Handle_VrmlData_Normal self, VrmlData_ErrorStatus const theStat) -> Standard_Boolean
        OK(Handle_VrmlData_Normal self, VrmlData_ErrorStatus const theStat) -> Standard_Boolean

        :type outStat: OCC.wrapper.VrmlData.VrmlData_ErrorStatus
        :type theStat: OCC.wrapper.VrmlData.VrmlData_ErrorStatus
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _VrmlData.Handle_VrmlData_Normal_OK(self, *args)


    def GlobalIndent(self, *args):
        """
        GlobalIndent(Handle_VrmlData_Normal self) -> Standard_Integer

        Define the common Indent in spaces, for writing all nodes.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _VrmlData.Handle_VrmlData_Normal_GlobalIndent(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_VrmlData_Normal self)

        Memory deallocator for transient classes


        """
        return _VrmlData.Handle_VrmlData_Normal_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_VrmlData_Normal self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_VrmlData_Normal self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _VrmlData.Handle_VrmlData_Normal_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_VrmlData_Normal self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_VrmlData_Normal self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _VrmlData.Handle_VrmlData_Normal_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_VrmlData_Normal self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _VrmlData.Handle_VrmlData_Normal_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_VrmlData_Normal self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _VrmlData.Handle_VrmlData_Normal_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_VrmlData_Normal self)

        Increments the reference counter of this object


        """
        return _VrmlData.Handle_VrmlData_Normal_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_VrmlData_Normal self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _VrmlData.Handle_VrmlData_Normal_DecrementRefCounter(self, *args)

Handle_VrmlData_Normal_swigregister = _VrmlData.Handle_VrmlData_Normal_swigregister
Handle_VrmlData_Normal_swigregister(Handle_VrmlData_Normal)

def Handle_VrmlData_Normal_DownCast(thing):
    return _VrmlData.Handle_VrmlData_Normal_DownCast(thing)
Handle_VrmlData_Normal_DownCast = _VrmlData.Handle_VrmlData_Normal_DownCast

class NCollection_List_Handle_VrmlData_Node(NCollection.NCollection_BaseList):
    """
    Purpose:      Simple list to link  items together keeping the first 
    and the last one.
    Inherits BaseList, adding the data item to each node.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_List_Handle_VrmlData_Node self) -> NCollection_List< opencascade::handle< VrmlData_Node > >::iterator

        Returns an iterator pointing to the first element in the list.

        :rtype: iterator

        """
        return _VrmlData.NCollection_List_Handle_VrmlData_Node_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_List_Handle_VrmlData_Node self) -> NCollection_List< opencascade::handle< VrmlData_Node > >::iterator

        Returns an iterator referring to the past-the-end element in the list.

        :rtype: iterator

        """
        return _VrmlData.NCollection_List_Handle_VrmlData_Node_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_List_Handle_VrmlData_Node self) -> NCollection_List< opencascade::handle< VrmlData_Node > >::const_iterator

        Returns a const iterator pointing to the first element in the list.

        :rtype: const_iterator

        """
        return _VrmlData.NCollection_List_Handle_VrmlData_Node_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_List_Handle_VrmlData_Node self) -> NCollection_List< opencascade::handle< VrmlData_Node > >::const_iterator

        Returns a const iterator referring to the past-the-end element in the list.

        :rtype: const_iterator

        """
        return _VrmlData.NCollection_List_Handle_VrmlData_Node_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:      Simple list to link  items together keeping the first 
        and the last one.
        Inherits BaseList, adding the data item to each node.
        """
        this = _VrmlData.new_NCollection_List_Handle_VrmlData_Node(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Size(self, *args):
        """
        Size(NCollection_List_Handle_VrmlData_Node self) -> Standard_Integer

        Size - Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _VrmlData.NCollection_List_Handle_VrmlData_Node_Size(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_List_Handle_VrmlData_Node self, NCollection_List_Handle_VrmlData_Node theOther) -> NCollection_List_Handle_VrmlData_Node

        Replace this list by the items of another list (theOther parameter).
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_List
        :rtype: OCC.wrapper.NCollection.NCollection_List

        """
        return _VrmlData.NCollection_List_Handle_VrmlData_Node_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_List_Handle_VrmlData_Node self, NCollection_List_Handle_VrmlData_Node theOther) -> NCollection_List_Handle_VrmlData_Node

        Replacement operator

        :type theOther: OCC.wrapper.NCollection.NCollection_List
        :rtype: OCC.wrapper.NCollection.NCollection_List

        """
        return _VrmlData.NCollection_List_Handle_VrmlData_Node_assign(self, *args)


    def Clear(self, *args):
        """
        Clear(NCollection_List_Handle_VrmlData_Node self, Handle_NCollection_BaseAllocator theAllocator=0)

        Clear this list

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _VrmlData.NCollection_List_Handle_VrmlData_Node_Clear(self, *args)


    def First(self, *args):
        """
        First item

        :rtype: const TheItemType &

        """
        res = _VrmlData.NCollection_List_Handle_VrmlData_Node_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Last(self, *args):
        """
        Last item

        :rtype: const TheItemType &

        """
        res = _VrmlData.NCollection_List_Handle_VrmlData_Node_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Append(self, *args):
        """
        Append(NCollection_List_Handle_VrmlData_Node self, Handle_VrmlData_Node theItem) -> Handle_VrmlData_Node
        Append(NCollection_List_Handle_VrmlData_Node self, Handle_VrmlData_Node theItem, NCollection_List< opencascade::handle< VrmlData_Node > >::Iterator & theIter)
        Append(NCollection_List_Handle_VrmlData_Node self, NCollection_List_Handle_VrmlData_Node theOther)

        Append another list at the end

        :type theOther: OCC.wrapper.NCollection.NCollection_List

        """
        return _VrmlData.NCollection_List_Handle_VrmlData_Node_Append(self, *args)


    def Prepend(self, *args):
        """
        Prepend(NCollection_List_Handle_VrmlData_Node self, Handle_VrmlData_Node theItem) -> Handle_VrmlData_Node
        Prepend(NCollection_List_Handle_VrmlData_Node self, NCollection_List_Handle_VrmlData_Node theOther)

        Prepend another list at the beginning

        :type theOther: OCC.wrapper.NCollection.NCollection_List

        """
        return _VrmlData.NCollection_List_Handle_VrmlData_Node_Prepend(self, *args)


    def RemoveFirst(self, *args):
        """
        RemoveFirst(NCollection_List_Handle_VrmlData_Node self)

        RemoveFirst item


        """
        return _VrmlData.NCollection_List_Handle_VrmlData_Node_RemoveFirst(self, *args)


    def Remove(self, *args):
        """
        Remove(NCollection_List_Handle_VrmlData_Node self, NCollection_List< opencascade::handle< VrmlData_Node > >::Iterator & theIter)

        Remove item pointed by iterator theIter; 
        theIter is then set to the next item

        :type theIter: Iterator

        """
        return _VrmlData.NCollection_List_Handle_VrmlData_Node_Remove(self, *args)


    def InsertBefore(self, *args):
        """
        InsertBefore(NCollection_List_Handle_VrmlData_Node self, Handle_VrmlData_Node theItem, NCollection_List< opencascade::handle< VrmlData_Node > >::Iterator & theIter) -> Handle_VrmlData_Node
        InsertBefore(NCollection_List_Handle_VrmlData_Node self, NCollection_List_Handle_VrmlData_Node theOther, NCollection_List< opencascade::handle< VrmlData_Node > >::Iterator & theIter)

        InsertBefore

        :type theOther: OCC.wrapper.NCollection.NCollection_List
        :type theIter: Iterator

        """
        return _VrmlData.NCollection_List_Handle_VrmlData_Node_InsertBefore(self, *args)


    def InsertAfter(self, *args):
        """
        InsertAfter(NCollection_List_Handle_VrmlData_Node self, Handle_VrmlData_Node theItem, NCollection_List< opencascade::handle< VrmlData_Node > >::Iterator & theIter) -> Handle_VrmlData_Node
        InsertAfter(NCollection_List_Handle_VrmlData_Node self, NCollection_List_Handle_VrmlData_Node theOther, NCollection_List< opencascade::handle< VrmlData_Node > >::Iterator & theIter)

        InsertAfter

        :type theOther: OCC.wrapper.NCollection.NCollection_List
        :type theIter: Iterator

        """
        return _VrmlData.NCollection_List_Handle_VrmlData_Node_InsertAfter(self, *args)


    def Reverse(self, *args):
        """
        Reverse(NCollection_List_Handle_VrmlData_Node self)

        Reverse the list


        """
        return _VrmlData.NCollection_List_Handle_VrmlData_Node_Reverse(self, *args)


    def __iter__(self):
        return _VrmlData.NCollection_List_Handle_VrmlData_Node___iter__(self)
    __swig_destroy__ = _VrmlData.delete_NCollection_List_Handle_VrmlData_Node
NCollection_List_Handle_VrmlData_Node_swigregister = _VrmlData.NCollection_List_Handle_VrmlData_Node_swigregister
NCollection_List_Handle_VrmlData_Node_swigregister(NCollection_List_Handle_VrmlData_Node)

class NCollection_List_Handle_VrmlData_Node_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _VrmlData.new_NCollection_List_Handle_VrmlData_Node_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _VrmlData.delete_NCollection_List_Handle_VrmlData_Node_IteratorHelper

    def __next__(self):
        return _VrmlData.NCollection_List_Handle_VrmlData_Node_IteratorHelper___next__(self)
NCollection_List_Handle_VrmlData_Node_IteratorHelper_swigregister = _VrmlData.NCollection_List_Handle_VrmlData_Node_IteratorHelper_swigregister
NCollection_List_Handle_VrmlData_Node_IteratorHelper_swigregister(NCollection_List_Handle_VrmlData_Node_IteratorHelper)


try:
	VrmlData_ListOfNode = NCollection_List_Handle_VrmlData_Node
except NameError:
	pass # does not exist, probably ignored

class Handle_VrmlData_ImageTexture(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_VrmlData_ImageTexture self)

        Nullify the handle


        """
        return _VrmlData.Handle_VrmlData_ImageTexture_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_VrmlData_ImageTexture self) -> bool

        Check for being null

        :rtype: bool

        """
        return _VrmlData.Handle_VrmlData_ImageTexture_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_VrmlData_ImageTexture self, VrmlData_ImageTexture thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _VrmlData.Handle_VrmlData_ImageTexture_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_VrmlData_ImageTexture self, Handle_VrmlData_ImageTexture theHandle) -> Handle_VrmlData_ImageTexture
        assign(Handle_VrmlData_ImageTexture self, VrmlData_ImageTexture thePtr) -> Handle_VrmlData_ImageTexture
        assign(Handle_VrmlData_ImageTexture self, Handle_VrmlData_ImageTexture theHandle) -> Handle_VrmlData_ImageTexture

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _VrmlData.Handle_VrmlData_ImageTexture_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_VrmlData_ImageTexture self) -> VrmlData_ImageTexture

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _VrmlData.Handle_VrmlData_ImageTexture_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_VrmlData_ImageTexture self) -> VrmlData_ImageTexture

        Member access operator (note non-const)

        :rtype: T *

        """
        return _VrmlData.Handle_VrmlData_ImageTexture___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_VrmlData_ImageTexture self) -> VrmlData_ImageTexture

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _VrmlData.Handle_VrmlData_ImageTexture___ref__(self, *args)


    def __hash__(self):
        return _VrmlData.Handle_VrmlData_ImageTexture___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _VrmlData.Handle_VrmlData_ImageTexture___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _VrmlData.new_Handle_VrmlData_ImageTexture(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_VrmlData.Handle_VrmlData_ImageTexture_DownCast)
    __swig_destroy__ = _VrmlData.delete_Handle_VrmlData_ImageTexture

    def URL(self, *args):
        """
        Query the associated URL.

        :rtype: OCC.wrapper.TColStd.NCollection_List_TCollection_AsciiString

        """
        res = _VrmlData.Handle_VrmlData_ImageTexture_URL(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Clone(self, *args):
        """
        Clone(Handle_VrmlData_ImageTexture self, Handle_VrmlData_Node theOther) -> Handle_VrmlData_Node

        Create a copy of this node.
        If the parameter is null, a new copied node is created. Otherwise new node
        is not created, but rather the given one is modified.

        :type theOther: OCC.wrapper.VrmlData.Handle_VrmlData_Node
        :rtype: OCC.wrapper.VrmlData.Handle_VrmlData_Node

        """
        return _VrmlData.Handle_VrmlData_ImageTexture_Clone(self, *args)


    def Read(self, *args):
        """
        Read(Handle_VrmlData_ImageTexture self, VrmlData_InBuffer & theBuffer) -> VrmlData_ErrorStatus

        Read the Node from input stream.

        :type theBuffer: OCC.wrapper.VrmlData.VrmlData_InBuffer
        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.Handle_VrmlData_ImageTexture_Read(self, *args)


    def Write(self, *args):
        """
        Write(Handle_VrmlData_ImageTexture self, char const * thePrefix) -> VrmlData_ErrorStatus

        Write the Node to output stream.

        :type thePrefix: const char *
        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.Handle_VrmlData_ImageTexture_Write(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_VrmlData_ImageTexture self) -> char const *

        :rtype: const char *

        """
        return _VrmlData.Handle_VrmlData_ImageTexture_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _VrmlData.Handle_VrmlData_ImageTexture_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _VrmlData.Handle_VrmlData_ImageTexture_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def RepeatS(self, *args):
        """
        RepeatS(Handle_VrmlData_ImageTexture self) -> Standard_Boolean

        Query the RepeatS value

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _VrmlData.Handle_VrmlData_ImageTexture_RepeatS(self, *args)


    def RepeatT(self, *args):
        """
        RepeatT(Handle_VrmlData_ImageTexture self) -> Standard_Boolean

        Query the RepeatT value

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _VrmlData.Handle_VrmlData_ImageTexture_RepeatT(self, *args)


    def SetRepeatS(self, *args):
        """
        SetRepeatS(Handle_VrmlData_ImageTexture self, Standard_Boolean const theFlag)

        Set the RepeatS flag

        :type theFlag: bool

        """
        return _VrmlData.Handle_VrmlData_ImageTexture_SetRepeatS(self, *args)


    def SetRepeatT(self, *args):
        """
        SetRepeatT(Handle_VrmlData_ImageTexture self, Standard_Boolean const theFlag)

        Set the RepeatT flag

        :type theFlag: bool

        """
        return _VrmlData.Handle_VrmlData_ImageTexture_SetRepeatT(self, *args)


    def Scene(self, *args):
        """
        Query the Scene that contains this Node

        :rtype: OCC.wrapper.VrmlData.VrmlData_Scene

        """
        res = _VrmlData.Handle_VrmlData_ImageTexture_Scene(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Name(self, *args):
        """
        Name(Handle_VrmlData_ImageTexture self) -> char const *

        Query the name

        :rtype: const char *

        """
        return _VrmlData.Handle_VrmlData_ImageTexture_Name(self, *args)


    def ReadNode(self, *args):
        """
        ReadNode(Handle_VrmlData_ImageTexture self, VrmlData_InBuffer & theBuffer, Handle_VrmlData_Node theNode, Handle_Standard_Type Type=0) -> VrmlData_ErrorStatus

        Read a complete node definition from VRML stream
        @param theBuffer
        Buffer receiving the input data.
        @param theNode
        <tt>[out]</tt> Node restored from the buffer data
        @param Type
        Node type to be checked. If it is NULL(default) no type checking is done.
        Otherwise the created node is matched and an error is returned if
        no match detected.

        :type theBuffer: OCC.wrapper.VrmlData.VrmlData_InBuffer
        :type theNode: OCC.wrapper.VrmlData.Handle_VrmlData_Node
        :type Type: OCC.wrapper.Standard.Handle_Standard_Type
        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.Handle_VrmlData_ImageTexture_ReadNode(self, *args)


    def IsDefault(self, *args):
        """
        IsDefault(Handle_VrmlData_ImageTexture self) -> Standard_Boolean

        Returns True if the node is default, then it would not be written.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _VrmlData.Handle_VrmlData_ImageTexture_IsDefault(self, *args)


    def WriteClosing(self, *args):
        """
        WriteClosing(Handle_VrmlData_ImageTexture self) -> VrmlData_ErrorStatus

        Write the closing brace in the end of a node output.

        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.Handle_VrmlData_ImageTexture_WriteClosing(self, *args)


    def ReadBoolean(self, *args):
        """
        ReadBoolean(Handle_VrmlData_ImageTexture self, VrmlData_InBuffer & theBuffer) -> VrmlData_ErrorStatus

        Read one boolean value (TRUE or FALSE).

        :type theBuffer: OCC.wrapper.VrmlData.VrmlData_InBuffer
        :type theResult: bool
        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.Handle_VrmlData_ImageTexture_ReadBoolean(self, *args)


    def ReadString(self, *args):
        """
        ReadString(Handle_VrmlData_ImageTexture self, VrmlData_InBuffer & theBuffer, TCollection_AsciiString theRes) -> VrmlData_ErrorStatus

        Read one quoted string, the quotes are removed.

        :type theBuffer: OCC.wrapper.VrmlData.VrmlData_InBuffer
        :type theRes: OCC.wrapper.TCollection.TCollection_AsciiString
        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.Handle_VrmlData_ImageTexture_ReadString(self, *args)


    def ReadMultiString(self, *args):
        """
        ReadMultiString(Handle_VrmlData_ImageTexture self, VrmlData_InBuffer & theBuffer, NCollection_List_TCollection_AsciiString theRes) -> VrmlData_ErrorStatus

        Read one quoted string, the quotes are removed.

        :type theBuffer: OCC.wrapper.VrmlData.VrmlData_InBuffer
        :type theRes: OCC.wrapper.TColStd.NCollection_List_TCollection_AsciiString
        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.Handle_VrmlData_ImageTexture_ReadMultiString(self, *args)


    def ReadInteger(self, *args):
        """
        ReadInteger(Handle_VrmlData_ImageTexture self, VrmlData_InBuffer & theBuffer) -> VrmlData_ErrorStatus

        Read one integer value.

        :type theBuffer: OCC.wrapper.VrmlData.VrmlData_InBuffer
        :type theResult: long &
        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.Handle_VrmlData_ImageTexture_ReadInteger(self, *args)


    def OK(self, *args):
        """
        OK(Handle_VrmlData_ImageTexture self, VrmlData_ErrorStatus const theStat) -> Standard_Boolean
        OK(Handle_VrmlData_ImageTexture self, VrmlData_ErrorStatus const theStat) -> Standard_Boolean

        :type outStat: OCC.wrapper.VrmlData.VrmlData_ErrorStatus
        :type theStat: OCC.wrapper.VrmlData.VrmlData_ErrorStatus
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _VrmlData.Handle_VrmlData_ImageTexture_OK(self, *args)


    def GlobalIndent(self, *args):
        """
        GlobalIndent(Handle_VrmlData_ImageTexture self) -> Standard_Integer

        Define the common Indent in spaces, for writing all nodes.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _VrmlData.Handle_VrmlData_ImageTexture_GlobalIndent(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_VrmlData_ImageTexture self)

        Memory deallocator for transient classes


        """
        return _VrmlData.Handle_VrmlData_ImageTexture_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_VrmlData_ImageTexture self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_VrmlData_ImageTexture self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _VrmlData.Handle_VrmlData_ImageTexture_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_VrmlData_ImageTexture self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_VrmlData_ImageTexture self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _VrmlData.Handle_VrmlData_ImageTexture_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_VrmlData_ImageTexture self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _VrmlData.Handle_VrmlData_ImageTexture_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_VrmlData_ImageTexture self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _VrmlData.Handle_VrmlData_ImageTexture_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_VrmlData_ImageTexture self)

        Increments the reference counter of this object


        """
        return _VrmlData.Handle_VrmlData_ImageTexture_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_VrmlData_ImageTexture self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _VrmlData.Handle_VrmlData_ImageTexture_DecrementRefCounter(self, *args)

Handle_VrmlData_ImageTexture_swigregister = _VrmlData.Handle_VrmlData_ImageTexture_swigregister
Handle_VrmlData_ImageTexture_swigregister(Handle_VrmlData_ImageTexture)

def Handle_VrmlData_ImageTexture_DownCast(thing):
    return _VrmlData.Handle_VrmlData_ImageTexture_DownCast(thing)
Handle_VrmlData_ImageTexture_DownCast = _VrmlData.Handle_VrmlData_ImageTexture_DownCast

class VrmlData_Scene(object):
    """Block of comments describing class VrmlData_Scene"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(VrmlData_Scene self, Handle_NCollection_IncAllocator arg2=0) -> VrmlData_Scene

        Constructor.

        :type : OCC.wrapper.NCollection.Handle_NCollection_IncAllocator

        """
        this = _VrmlData.new_VrmlData_Scene(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Status(self, *args):
        """
        Status(VrmlData_Scene self) -> VrmlData_ErrorStatus

        Query the status of the previous operation.
        Normally it should be equal to VrmlData_StatusOK (no error).

        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.VrmlData_Scene_Status(self, *args)


    def SetVrmlDir(self, *args):
        """
        SetVrmlDir(VrmlData_Scene self, TCollection_ExtendedString arg2)

        Add the given directory path to the list of VRML file search directories.
        This method forms the list of directories ordered according to the
        sequence of this method calls. When an Inline node is found, the URLs
        in that node are matched with these directories.
        The last (implicit) search directory is the current process directory
        ("."). It takes effect if the list is empty or if there is no match with
        exisiting directories.

        :type : OCC.wrapper.TCollection.TCollection_ExtendedString

        """
        return _VrmlData.VrmlData_Scene_SetVrmlDir(self, *args)


    def SetLinearScale(self, *args):
        """
        SetLinearScale(VrmlData_Scene self, Standard_Real const theScale)

        Set the scale factor that would be further used in methods
        ReadReal, ReadXYZ and ReadXY. All coordinates, distances and sized are
        multiplied by this factor during reading the data.

        :type theScale: float

        """
        return _VrmlData.VrmlData_Scene_SetLinearScale(self, *args)


    def Allocator(self, *args):
        """
        Allocator used by all nodes contained in the Scene.

        :rtype: OCC.wrapper.NCollection.Handle_NCollection_IncAllocator

        """
        res = _VrmlData.VrmlData_Scene_Allocator(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def AddNode(self, *args):
        """
        Add a Node. If theN belongs to another Scene, it is cloned.
        <p>VrmlData_WorldInfo cannot be added, in this case the method
        returns a NULL handle.

        :type theN: OCC.wrapper.VrmlData.Handle_VrmlData_Node
        :type isTopLevel: bool
        :rtype: OCC.wrapper.VrmlData.Handle_VrmlData_Node

        """
        res = _VrmlData.VrmlData_Scene_AddNode(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def FindNode(self, *args):
        """
        FindNode(VrmlData_Scene self, char const * theName, Handle_Standard_Type theType=0) -> Handle_VrmlData_Node
        FindNode(VrmlData_Scene self, char const * theName, gp_Trsf theLocation) -> Handle_VrmlData_Node

        Find a node by its name.
        @param theName
        Name of the node to search for.
        @param theLocation
        Location of the found node with respect to the whole VRML shape.

        :type theName: const char *
        :type theLocation: OCC.wrapper.gp.gp_Trsf
        :rtype: OCC.wrapper.VrmlData.Handle_VrmlData_Node

        """
        return _VrmlData.VrmlData_Scene_FindNode(self, *args)


    def __lshift__(self, *args):
        """
        __lshift__(VrmlData_Scene self, Standard_IStream & theInput) -> VrmlData_Scene

        Import from text stream (file or else).
        This method is protected by Mutex, it is not allowed to read/write
        two VRML streams concurrently.

        :type theInput: OCC.wrapper.Standard.Standard_IStream
        :rtype: OCC.wrapper.VrmlData.VrmlData_Scene

        """
        return _VrmlData.VrmlData_Scene___lshift__(self, *args)


    def GetShape(self, *args):
        """
        GetShape(VrmlData_Scene self, VrmlData_DataMapOfShapeAppearance & M) -> TopoDS_Shape

        Convert the scene to a Shape, with the information on materials defined
        for each sub-shape. This method should be used instead of TopoDS_Shape
        explicit conversion operator when you need to retrieve the material
        aspect for each face or edge in the returned topological object.
        @param M
        Data Map that binds an Appearance instance to each created TFace or
        TEdge if the Appearance node is defined in VRML scene for that geometry.
        @return
        TopoDS_Shape (Compound) holding all the scene, similar to the result of
        explicit TopoDS_Shape conversion operator.

        :type M: OCC.wrapper.VrmlData.VrmlData_DataMapOfShapeAppearance
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _VrmlData.VrmlData_Scene_GetShape(self, *args)


    def WorldInfo(self, *args):
        """
        Query the WorldInfo member.

        :rtype: OCC.wrapper.VrmlData.Handle_VrmlData_WorldInfo

        """
        res = _VrmlData.VrmlData_Scene_WorldInfo(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ReadLine(*args):
        """
        ReadLine(VrmlData_InBuffer & theBuffer) -> VrmlData_ErrorStatus

        Read a VRML line. Empty lines and comments are skipped.
        The processing starts here from theBuffer.LinePtr; if there is at least
        one non-empty character (neither space nor comment), this line is used
        without reading the next one.
        @param theLine
        Buffer receiving the input line
        @param theInput
        Input stream
        @param theLen
        Length of the input buffer (maximal line length)

        :type theBuffer: OCC.wrapper.VrmlData.VrmlData_InBuffer
        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.VrmlData_Scene_ReadLine(*args)

    ReadLine = staticmethod(ReadLine)

    def ReadWord(*args):
        """
        ReadWord(VrmlData_InBuffer & theBuffer, TCollection_AsciiString theStr) -> VrmlData_ErrorStatus

        Read a singel word from the input stream, delimited by whitespace.

        :type theBuffer: OCC.wrapper.VrmlData.VrmlData_InBuffer
        :type theStr: OCC.wrapper.TCollection.TCollection_AsciiString
        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.VrmlData_Scene_ReadWord(*args)

    ReadWord = staticmethod(ReadWord)

    def Dump(self, *args):
        """
        Dump(VrmlData_Scene self, Standard_OStream & theStream)

        Diagnostic dump of the contents

        :type theStream: OCC.wrapper.Standard.Standard_OStream

        """
        return _VrmlData.VrmlData_Scene_Dump(self, *args)


    def ReadReal(self, *args):
        """
        ReadReal(VrmlData_Scene self, VrmlData_InBuffer & theBuffer, Standard_Boolean isApplyScale, Standard_Boolean isOnlyPositive) -> VrmlData_ErrorStatus

        Read one real value.

        :type theBuffer: OCC.wrapper.VrmlData.VrmlData_InBuffer
        :type theResult: float
        :type isApplyScale: bool
        :type isOnlyPositive: bool
        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.VrmlData_Scene_ReadReal(self, *args)


    def ReadXYZ(self, *args):
        """
        ReadXYZ(VrmlData_Scene self, VrmlData_InBuffer & theBuffer, gp_XYZ theXYZ, Standard_Boolean isApplyScale, Standard_Boolean isOnlyPositive) -> VrmlData_ErrorStatus

        Read one triplet of real values.

        :type theBuffer: OCC.wrapper.VrmlData.VrmlData_InBuffer
        :type theXYZ: OCC.wrapper.gp.gp_XYZ
        :type isApplyScale: bool
        :type isOnlyPositive: bool
        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.VrmlData_Scene_ReadXYZ(self, *args)


    def ReadXY(self, *args):
        """
        ReadXY(VrmlData_Scene self, VrmlData_InBuffer & theBuffer, gp_XY theXYZ, Standard_Boolean isApplyScale, Standard_Boolean isOnlyPositive) -> VrmlData_ErrorStatus

        Read one doublet of real values.

        :type theBuffer: OCC.wrapper.VrmlData.VrmlData_InBuffer
        :type theXYZ: OCC.wrapper.gp.gp_XY
        :type isApplyScale: bool
        :type isOnlyPositive: bool
        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.VrmlData_Scene_ReadXY(self, *args)


    def ReadArrIndex(self, *args):
        """
        ReadArrIndex(VrmlData_Scene self, VrmlData_InBuffer & theBuffer, Standard_Integer const **& theArr) -> VrmlData_ErrorStatus

        Read an array of integer indices, for IndexedfaceSet and IndexedLineSet.

        :type theBuffer: OCC.wrapper.VrmlData.VrmlData_InBuffer
        :type theArr: int
        :type theNBl: int
        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.VrmlData_Scene_ReadArrIndex(self, *args)


    def GetLineError(self, *args):
        """
        GetLineError(VrmlData_Scene self) -> Standard_Integer

        Query the line where the error occurred (if the status is not OK)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _VrmlData.VrmlData_Scene_GetLineError(self, *args)


    def SetIndent(self, *args):
        """
        SetIndent(VrmlData_Scene self, Standard_Integer const nSpc)

        Store the indentation for VRML output.
        @param nSpc
        number of spaces to insert at every indentation level

        :type nSpc: int

        """
        return _VrmlData.VrmlData_Scene_SetIndent(self, *args)


    def WriteXYZ(self, *args):
        """
        WriteXYZ(VrmlData_Scene self, gp_XYZ theXYZ, Standard_Boolean const isScale, char const * thePostfix=0) -> VrmlData_ErrorStatus

        Write a triplet of real values on a separate line.
        @param theXYZ
        The value to be output.
        @param isScale
        If True, then each component is divided by myLinearScale.
        @param thePostfix
        Optional string that is added before the end of the line.

        :type theXYZ: OCC.wrapper.gp.gp_XYZ
        :type isScale: bool
        :type thePostfix: const char *
        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.VrmlData_Scene_WriteXYZ(self, *args)


    def WriteArrIndex(self, *args):
        """
        WriteArrIndex(VrmlData_Scene self, char const * thePrefix, Standard_Integer const ** theArr, Standard_Size const theNbBl) -> VrmlData_ErrorStatus

        Write an array of integer indices, for IndexedFaceSet and IndexedLineSet.

        :type thePrefix: const char *
        :type theArr: int
        :type theNbBl: int
        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.VrmlData_Scene_WriteArrIndex(self, *args)


    def WriteLine(self, *args):
        """
        WriteLine(VrmlData_Scene self, char const * theLine0, char const * theLine1=0, Standard_Integer const theIndent=0) -> VrmlData_ErrorStatus

        Write a string to the output stream respecting the indentation. The string
        can be defined as two substrings that will be separated by a space.
        Each of the substrings can be NULL, then it is ignored. If both
        are NULL, then a single newline is output (without indent).
        @param theLine0
        The first part of string to output
        @param theLine1
        The second part of string to output
        @param theIndent
        - 0 value ignored.
        - negative decreases the current indent and then outputs.
        - positive outputs and then increases the current indent. 
        @return
        Error status of the stream, or a special error if myOutput == NULL.

        :type theLine0: const char *
        :type theLine1: const char *
        :type theIndent: int
        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.VrmlData_Scene_WriteLine(self, *args)


    def WriteNode(self, *args):
        """
        WriteNode(VrmlData_Scene self, char const * thePrefix, Handle_VrmlData_Node arg3) -> VrmlData_ErrorStatus

        Write the given node to output stream 'myOutput'.

        :type thePrefix: const char *
        :type : OCC.wrapper.VrmlData.Handle_VrmlData_Node
        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.VrmlData_Scene_WriteNode(self, *args)


    def IsDummyWrite(self, *args):
        """
        IsDummyWrite(VrmlData_Scene self) -> Standard_Boolean

        Query if the current write operation is dummy, i.e., for the purpose of
        collecting information before the real write is commenced.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _VrmlData.VrmlData_Scene_IsDummyWrite(self, *args)


    def vrmlDirIterator(self):
        return _VrmlData.VrmlData_Scene_vrmlDirIterator(self)

    def namedNodesIterator(self):
        return _VrmlData.VrmlData_Scene_namedNodesIterator(self)

    def getIterator(self):
        return _VrmlData.VrmlData_Scene_getIterator(self)
    __swig_destroy__ = _VrmlData.delete_VrmlData_Scene
VrmlData_Scene_swigregister = _VrmlData.VrmlData_Scene_swigregister
VrmlData_Scene_swigregister(VrmlData_Scene)

def VrmlData_Scene_ReadLine(*args):
    """
    VrmlData_Scene_ReadLine(VrmlData_InBuffer & theBuffer) -> VrmlData_ErrorStatus

    Read a VRML line. Empty lines and comments are skipped.
    The processing starts here from theBuffer.LinePtr; if there is at least
    one non-empty character (neither space nor comment), this line is used
    without reading the next one.
    @param theLine
    Buffer receiving the input line
    @param theInput
    Input stream
    @param theLen
    Length of the input buffer (maximal line length)

    :type theBuffer: OCC.wrapper.VrmlData.VrmlData_InBuffer
    :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

    """
    return _VrmlData.VrmlData_Scene_ReadLine(*args)

def VrmlData_Scene_ReadWord(*args):
    """
    VrmlData_Scene_ReadWord(VrmlData_InBuffer & theBuffer, TCollection_AsciiString theStr) -> VrmlData_ErrorStatus

    Read a singel word from the input stream, delimited by whitespace.

    :type theBuffer: OCC.wrapper.VrmlData.VrmlData_InBuffer
    :type theStr: OCC.wrapper.TCollection.TCollection_AsciiString
    :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

    """
    return _VrmlData.VrmlData_Scene_ReadWord(*args)

class VrmlData_Group(VrmlData_Node):
    """Implementation of node "Group" """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_VrmlData_Group
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_VrmlData_Group(self) 
            return h


    def __init__(self, *args):
        """
        __init__(VrmlData_Group self, Standard_Boolean const isTransform) -> VrmlData_Group
        __init__(VrmlData_Group self, VrmlData_Scene theScene, char const * theName, Standard_Boolean const isTransform) -> VrmlData_Group

        Constructor.
        @param theName
        Name of the Group node
        @param isTransform
        True if the group of type Transform is defined
        @param theAlloc
        Allocator used for the list of children

        :type theScene: OCC.wrapper.VrmlData.VrmlData_Scene
        :type theName: const char *
        :type isTransform: bool

        """
        this = _VrmlData.new_VrmlData_Group(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def AddNode(self, *args):
        """
        AddNode(VrmlData_Group self, Handle_VrmlData_Node theNode) -> Handle_VrmlData_Node

        Add one node to the Group.

        :type theNode: OCC.wrapper.VrmlData.Handle_VrmlData_Node
        :rtype: OCC.wrapper.VrmlData.Handle_VrmlData_Node

        """
        return _VrmlData.VrmlData_Group_AddNode(self, *args)


    def RemoveNode(self, *args):
        """
        RemoveNode(VrmlData_Group self, Handle_VrmlData_Node theNode) -> Standard_Boolean

        Remove one node from the Group.
        @return
        True if the node was located and removed, False if none removed.

        :type theNode: OCC.wrapper.VrmlData.Handle_VrmlData_Node
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _VrmlData.VrmlData_Group_RemoveNode(self, *args)


    def Box(self, *args):
        """
        Query the bounding box.

        :rtype: OCC.wrapper.Bnd.Bnd_B3f

        """
        res = _VrmlData.VrmlData_Group_Box(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetBox(self, *args):
        """
        SetBox(VrmlData_Group self, Bnd_B3f theBox)

        Set the bounding box.

        :type theBox: OCC.wrapper.Bnd.Bnd_B3f

        """
        return _VrmlData.VrmlData_Group_SetBox(self, *args)


    def SetTransform(self, *args):
        """
        SetTransform(VrmlData_Group self, gp_Trsf theTrsf) -> Standard_Boolean

        Set the transformation. Returns True if the group is Transform type,
        otherwise do nothing and return False.

        :type theTrsf: OCC.wrapper.gp.gp_Trsf
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _VrmlData.VrmlData_Group_SetTransform(self, *args)


    def GetTransform(self, *args):
        """
        Query the transform value.
        For group without transformation this always returns Identity

        :rtype: OCC.wrapper.gp.gp_Trsf

        """
        res = _VrmlData.VrmlData_Group_GetTransform(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def IsTransform(self, *args):
        """
        IsTransform(VrmlData_Group self) -> Standard_Boolean

        Query if the node is Transform type.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _VrmlData.VrmlData_Group_IsTransform(self, *args)


    def Clone(self, *args):
        """
        Clone(VrmlData_Group self, Handle_VrmlData_Node theOther) -> Handle_VrmlData_Node

        Create a copy of this node.
        If the parameter is null, a new copied node is created. Otherwise new node
        is not created, but rather the given one is modified.

        :type theOther: OCC.wrapper.VrmlData.Handle_VrmlData_Node
        :rtype: OCC.wrapper.VrmlData.Handle_VrmlData_Node

        """
        return _VrmlData.VrmlData_Group_Clone(self, *args)


    def Read(self, *args):
        """
        Read(VrmlData_Group self, VrmlData_InBuffer & theBuffer) -> VrmlData_ErrorStatus

        Fill the Node internal data from the given input stream.

        :type theBuffer: OCC.wrapper.VrmlData.VrmlData_InBuffer
        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.VrmlData_Group_Read(self, *args)


    def Write(self, *args):
        """
        Write(VrmlData_Group self, char const * thePrefix) -> VrmlData_ErrorStatus

        Write the Node to output stream.

        :type thePrefix: const char *
        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.VrmlData_Group_Write(self, *args)


    def FindNode(self, *args):
        """
        FindNode(VrmlData_Group self, char const * theName, gp_Trsf theLocation) -> Handle_VrmlData_Node

        Find a node by its name, inside this Group
        @param theName
        Name of the node to search for.
        @param theLocation
        Location of the found node with respect to this Group.

        :type theName: const char *
        :type theLocation: OCC.wrapper.gp.gp_Trsf
        :rtype: OCC.wrapper.VrmlData.Handle_VrmlData_Node

        """
        return _VrmlData.VrmlData_Group_FindNode(self, *args)


    def Shape(self, *args):
        """
        Shape(VrmlData_Group self, TopoDS_Shape theShape, VrmlData_DataMapOfShapeAppearance * pMapApp)

        Get the shape representing the group geometry.

        :type theShape: OCC.wrapper.TopoDS.TopoDS_Shape
        :type pMapApp: OCC.wrapper.VrmlData.VrmlData_DataMapOfShapeAppearance

        """
        return _VrmlData.VrmlData_Group_Shape(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _VrmlData.VrmlData_Group_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _VrmlData.VrmlData_Group_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _VrmlData.VrmlData_Group_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def nodeIterator(self):
        return _VrmlData.VrmlData_Group_nodeIterator(self)
    __swig_destroy__ = _VrmlData.delete_VrmlData_Group
VrmlData_Group_swigregister = _VrmlData.VrmlData_Group_swigregister
VrmlData_Group_swigregister(VrmlData_Group)

def VrmlData_Group_get_type_name(*args):
    """
    VrmlData_Group_get_type_name() -> char const *

    :rtype: const char *

    """
    return _VrmlData.VrmlData_Group_get_type_name(*args)

def VrmlData_Group_get_type_descriptor(*args):
    """
    VrmlData_Group_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _VrmlData.VrmlData_Group_get_type_descriptor(*args)

class Handle_VrmlData_Material(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_VrmlData_Material self)

        Nullify the handle


        """
        return _VrmlData.Handle_VrmlData_Material_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_VrmlData_Material self) -> bool

        Check for being null

        :rtype: bool

        """
        return _VrmlData.Handle_VrmlData_Material_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_VrmlData_Material self, VrmlData_Material thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _VrmlData.Handle_VrmlData_Material_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_VrmlData_Material self, Handle_VrmlData_Material theHandle) -> Handle_VrmlData_Material
        assign(Handle_VrmlData_Material self, VrmlData_Material thePtr) -> Handle_VrmlData_Material
        assign(Handle_VrmlData_Material self, Handle_VrmlData_Material theHandle) -> Handle_VrmlData_Material

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _VrmlData.Handle_VrmlData_Material_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_VrmlData_Material self) -> VrmlData_Material

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _VrmlData.Handle_VrmlData_Material_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_VrmlData_Material self) -> VrmlData_Material

        Member access operator (note non-const)

        :rtype: T *

        """
        return _VrmlData.Handle_VrmlData_Material___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_VrmlData_Material self) -> VrmlData_Material

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _VrmlData.Handle_VrmlData_Material___ref__(self, *args)


    def __hash__(self):
        return _VrmlData.Handle_VrmlData_Material___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _VrmlData.Handle_VrmlData_Material___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _VrmlData.new_Handle_VrmlData_Material(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_VrmlData.Handle_VrmlData_Material_DownCast)
    __swig_destroy__ = _VrmlData.delete_Handle_VrmlData_Material

    def AmbientIntensity(self, *args):
        """
        AmbientIntensity(Handle_VrmlData_Material self) -> Standard_Real

        Query the Ambient Intensity value

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _VrmlData.Handle_VrmlData_Material_AmbientIntensity(self, *args)


    def Shininess(self, *args):
        """
        Shininess(Handle_VrmlData_Material self) -> Standard_Real

        Query the Shininess value

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _VrmlData.Handle_VrmlData_Material_Shininess(self, *args)


    def Transparency(self, *args):
        """
        Transparency(Handle_VrmlData_Material self) -> Standard_Real

        Query the Transparency value

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _VrmlData.Handle_VrmlData_Material_Transparency(self, *args)


    def DiffuseColor(self, *args):
        """
        Query the Diffuse color

        :rtype: OCC.wrapper.Quantity.Quantity_Color

        """
        res = _VrmlData.Handle_VrmlData_Material_DiffuseColor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def EmissiveColor(self, *args):
        """
        Query the Emissive color

        :rtype: OCC.wrapper.Quantity.Quantity_Color

        """
        res = _VrmlData.Handle_VrmlData_Material_EmissiveColor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SpecularColor(self, *args):
        """
        Query the Specular color

        :rtype: OCC.wrapper.Quantity.Quantity_Color

        """
        res = _VrmlData.Handle_VrmlData_Material_SpecularColor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetAmbientIntensity(self, *args):
        """
        SetAmbientIntensity(Handle_VrmlData_Material self, Standard_Real const theAmbientIntensity)

        Set the Ambient Intensity value

        :type theAmbientIntensity: float

        """
        return _VrmlData.Handle_VrmlData_Material_SetAmbientIntensity(self, *args)


    def SetShininess(self, *args):
        """
        SetShininess(Handle_VrmlData_Material self, Standard_Real const theShininess)

        Set the Shininess value

        :type theShininess: float

        """
        return _VrmlData.Handle_VrmlData_Material_SetShininess(self, *args)


    def SetTransparency(self, *args):
        """
        SetTransparency(Handle_VrmlData_Material self, Standard_Real const theTransparency)

        Set the Transparency value

        :type theTransparency: float

        """
        return _VrmlData.Handle_VrmlData_Material_SetTransparency(self, *args)


    def SetDiffuseColor(self, *args):
        """
        SetDiffuseColor(Handle_VrmlData_Material self, Quantity_Color theColor)

        Query the Diffuse color

        :type theColor: OCC.wrapper.Quantity.Quantity_Color

        """
        return _VrmlData.Handle_VrmlData_Material_SetDiffuseColor(self, *args)


    def SetEmissiveColor(self, *args):
        """
        SetEmissiveColor(Handle_VrmlData_Material self, Quantity_Color theColor)

        Query the Emissive color

        :type theColor: OCC.wrapper.Quantity.Quantity_Color

        """
        return _VrmlData.Handle_VrmlData_Material_SetEmissiveColor(self, *args)


    def SetSpecularColor(self, *args):
        """
        SetSpecularColor(Handle_VrmlData_Material self, Quantity_Color theColor)

        Query the Specular color

        :type theColor: OCC.wrapper.Quantity.Quantity_Color

        """
        return _VrmlData.Handle_VrmlData_Material_SetSpecularColor(self, *args)


    def Clone(self, *args):
        """
        Clone(Handle_VrmlData_Material self, Handle_VrmlData_Node theOther) -> Handle_VrmlData_Node

        Create a copy of this node.
        If the parameter is null, a new copied node is created. Otherwise new node
        is not created, but rather the given one is modified.

        :type theOther: OCC.wrapper.VrmlData.Handle_VrmlData_Node
        :rtype: OCC.wrapper.VrmlData.Handle_VrmlData_Node

        """
        return _VrmlData.Handle_VrmlData_Material_Clone(self, *args)


    def Read(self, *args):
        """
        Read(Handle_VrmlData_Material self, VrmlData_InBuffer & theBuffer) -> VrmlData_ErrorStatus

        Read the Node from input stream.

        :type theBuffer: OCC.wrapper.VrmlData.VrmlData_InBuffer
        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.Handle_VrmlData_Material_Read(self, *args)


    def Write(self, *args):
        """
        Write(Handle_VrmlData_Material self, char const * thePrefix) -> VrmlData_ErrorStatus

        Write the Node to the Scene output.

        :type thePrefix: const char *
        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.Handle_VrmlData_Material_Write(self, *args)


    def IsDefault(self, *args):
        """
        IsDefault(Handle_VrmlData_Material self) -> Standard_Boolean

        Returns True if the node is default, so that it should not be written.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _VrmlData.Handle_VrmlData_Material_IsDefault(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_VrmlData_Material self) -> char const *

        :rtype: const char *

        """
        return _VrmlData.Handle_VrmlData_Material_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _VrmlData.Handle_VrmlData_Material_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _VrmlData.Handle_VrmlData_Material_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Scene(self, *args):
        """
        Query the Scene that contains this Node

        :rtype: OCC.wrapper.VrmlData.VrmlData_Scene

        """
        res = _VrmlData.Handle_VrmlData_Material_Scene(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Name(self, *args):
        """
        Name(Handle_VrmlData_Material self) -> char const *

        Query the name

        :rtype: const char *

        """
        return _VrmlData.Handle_VrmlData_Material_Name(self, *args)


    def ReadNode(self, *args):
        """
        ReadNode(Handle_VrmlData_Material self, VrmlData_InBuffer & theBuffer, Handle_VrmlData_Node theNode, Handle_Standard_Type Type=0) -> VrmlData_ErrorStatus

        Read a complete node definition from VRML stream
        @param theBuffer
        Buffer receiving the input data.
        @param theNode
        <tt>[out]</tt> Node restored from the buffer data
        @param Type
        Node type to be checked. If it is NULL(default) no type checking is done.
        Otherwise the created node is matched and an error is returned if
        no match detected.

        :type theBuffer: OCC.wrapper.VrmlData.VrmlData_InBuffer
        :type theNode: OCC.wrapper.VrmlData.Handle_VrmlData_Node
        :type Type: OCC.wrapper.Standard.Handle_Standard_Type
        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.Handle_VrmlData_Material_ReadNode(self, *args)


    def WriteClosing(self, *args):
        """
        WriteClosing(Handle_VrmlData_Material self) -> VrmlData_ErrorStatus

        Write the closing brace in the end of a node output.

        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.Handle_VrmlData_Material_WriteClosing(self, *args)


    def ReadBoolean(self, *args):
        """
        ReadBoolean(Handle_VrmlData_Material self, VrmlData_InBuffer & theBuffer) -> VrmlData_ErrorStatus

        Read one boolean value (TRUE or FALSE).

        :type theBuffer: OCC.wrapper.VrmlData.VrmlData_InBuffer
        :type theResult: bool
        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.Handle_VrmlData_Material_ReadBoolean(self, *args)


    def ReadString(self, *args):
        """
        ReadString(Handle_VrmlData_Material self, VrmlData_InBuffer & theBuffer, TCollection_AsciiString theRes) -> VrmlData_ErrorStatus

        Read one quoted string, the quotes are removed.

        :type theBuffer: OCC.wrapper.VrmlData.VrmlData_InBuffer
        :type theRes: OCC.wrapper.TCollection.TCollection_AsciiString
        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.Handle_VrmlData_Material_ReadString(self, *args)


    def ReadMultiString(self, *args):
        """
        ReadMultiString(Handle_VrmlData_Material self, VrmlData_InBuffer & theBuffer, NCollection_List_TCollection_AsciiString theRes) -> VrmlData_ErrorStatus

        Read one quoted string, the quotes are removed.

        :type theBuffer: OCC.wrapper.VrmlData.VrmlData_InBuffer
        :type theRes: OCC.wrapper.TColStd.NCollection_List_TCollection_AsciiString
        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.Handle_VrmlData_Material_ReadMultiString(self, *args)


    def ReadInteger(self, *args):
        """
        ReadInteger(Handle_VrmlData_Material self, VrmlData_InBuffer & theBuffer) -> VrmlData_ErrorStatus

        Read one integer value.

        :type theBuffer: OCC.wrapper.VrmlData.VrmlData_InBuffer
        :type theResult: long &
        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.Handle_VrmlData_Material_ReadInteger(self, *args)


    def OK(self, *args):
        """
        OK(Handle_VrmlData_Material self, VrmlData_ErrorStatus const theStat) -> Standard_Boolean
        OK(Handle_VrmlData_Material self, VrmlData_ErrorStatus const theStat) -> Standard_Boolean

        :type outStat: OCC.wrapper.VrmlData.VrmlData_ErrorStatus
        :type theStat: OCC.wrapper.VrmlData.VrmlData_ErrorStatus
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _VrmlData.Handle_VrmlData_Material_OK(self, *args)


    def GlobalIndent(self, *args):
        """
        GlobalIndent(Handle_VrmlData_Material self) -> Standard_Integer

        Define the common Indent in spaces, for writing all nodes.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _VrmlData.Handle_VrmlData_Material_GlobalIndent(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_VrmlData_Material self)

        Memory deallocator for transient classes


        """
        return _VrmlData.Handle_VrmlData_Material_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_VrmlData_Material self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_VrmlData_Material self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _VrmlData.Handle_VrmlData_Material_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_VrmlData_Material self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_VrmlData_Material self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _VrmlData.Handle_VrmlData_Material_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_VrmlData_Material self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _VrmlData.Handle_VrmlData_Material_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_VrmlData_Material self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _VrmlData.Handle_VrmlData_Material_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_VrmlData_Material self)

        Increments the reference counter of this object


        """
        return _VrmlData.Handle_VrmlData_Material_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_VrmlData_Material self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _VrmlData.Handle_VrmlData_Material_DecrementRefCounter(self, *args)

Handle_VrmlData_Material_swigregister = _VrmlData.Handle_VrmlData_Material_swigregister
Handle_VrmlData_Material_swigregister(Handle_VrmlData_Material)

def Handle_VrmlData_Material_DownCast(thing):
    return _VrmlData.Handle_VrmlData_Material_DownCast(thing)
Handle_VrmlData_Material_DownCast = _VrmlData.Handle_VrmlData_Material_DownCast

class VrmlData_Coordinate(VrmlData_ArrayVec3d):
    """Implementation of the node Coordinate"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_VrmlData_Coordinate
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_VrmlData_Coordinate(self) 
            return h


    def __init__(self, *args):
        """
        __init__(VrmlData_Coordinate self) -> VrmlData_Coordinate
        __init__(VrmlData_Coordinate self, VrmlData_Scene theScene, char const * theName, size_t const nPoints=0, gp_XYZ arrPoints=0) -> VrmlData_Coordinate

        Constructor

        :type theScene: OCC.wrapper.VrmlData.VrmlData_Scene
        :type theName: const char *
        :type nPoints: size_t
        :type arrPoints: OCC.wrapper.gp.gp_XYZ

        """
        this = _VrmlData.new_VrmlData_Coordinate(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Coordinate(self, *args):
        """
        Query one point
        @param i
        index in the array of points [0 .. N-1]
        @return
        the coordinate for the index. If index irrelevant, returns (0., 0., 0.)

        :type i: int
        :rtype: OCC.wrapper.gp.gp_XYZ

        """
        res = _VrmlData.VrmlData_Coordinate_Coordinate(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Clone(self, *args):
        """
        Clone(VrmlData_Coordinate self, Handle_VrmlData_Node theOther) -> Handle_VrmlData_Node

        Create a copy of this node.
        If the parameter is null, a new copied node is created. Otherwise new node
        is not created, but rather the given one is modified.

        :type theOther: OCC.wrapper.VrmlData.Handle_VrmlData_Node
        :rtype: OCC.wrapper.VrmlData.Handle_VrmlData_Node

        """
        return _VrmlData.VrmlData_Coordinate_Clone(self, *args)


    def Read(self, *args):
        """
        Read(VrmlData_Coordinate self, VrmlData_InBuffer & theBuffer) -> VrmlData_ErrorStatus

        Read the Node from input stream.

        :type theBuffer: OCC.wrapper.VrmlData.VrmlData_InBuffer
        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.VrmlData_Coordinate_Read(self, *args)


    def Write(self, *args):
        """
        Write(VrmlData_Coordinate self, char const * thePrefix) -> VrmlData_ErrorStatus

        Write the Node to the Scene output.

        :type thePrefix: const char *
        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.VrmlData_Coordinate_Write(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _VrmlData.VrmlData_Coordinate_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _VrmlData.VrmlData_Coordinate_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _VrmlData.VrmlData_Coordinate_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _VrmlData.delete_VrmlData_Coordinate
VrmlData_Coordinate_swigregister = _VrmlData.VrmlData_Coordinate_swigregister
VrmlData_Coordinate_swigregister(VrmlData_Coordinate)

def VrmlData_Coordinate_get_type_name(*args):
    """
    VrmlData_Coordinate_get_type_name() -> char const *

    :rtype: const char *

    """
    return _VrmlData.VrmlData_Coordinate_get_type_name(*args)

def VrmlData_Coordinate_get_type_descriptor(*args):
    """
    VrmlData_Coordinate_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _VrmlData.VrmlData_Coordinate_get_type_descriptor(*args)

class VrmlData_Color(VrmlData_ArrayVec3d):
    """Implementation of the node Color"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_VrmlData_Color
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_VrmlData_Color(self) 
            return h


    def __init__(self, *args):
        """
        __init__(VrmlData_Color self) -> VrmlData_Color
        __init__(VrmlData_Color self, VrmlData_Scene theScene, char const * theName, size_t const nColors=0, gp_XYZ arrColors=0) -> VrmlData_Color

        Constructor.

        :type theScene: OCC.wrapper.VrmlData.VrmlData_Scene
        :type theName: const char *
        :type nColors: size_t
        :type arrColors: OCC.wrapper.gp.gp_XYZ

        """
        this = _VrmlData.new_VrmlData_Color(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Color(self, *args):
        """
        Color(VrmlData_Color self, Standard_Integer const i) -> Quantity_Color

        Query one color
        @param i
        index in the array of colors [0 .. N-1]
        @return
        the color value for the index. If index irrelevant, returns (0., 0., 0.)

        :type i: int
        :rtype: OCC.wrapper.Quantity.Quantity_Color

        """
        return _VrmlData.VrmlData_Color_Color(self, *args)


    def SetColors(self, *args):
        """
        SetColors(VrmlData_Color self, size_t const nColors, gp_XYZ arrColors)

        Set the array data

        :type nColors: size_t
        :type arrColors: OCC.wrapper.gp.gp_XYZ

        """
        return _VrmlData.VrmlData_Color_SetColors(self, *args)


    def Clone(self, *args):
        """
        Clone(VrmlData_Color self, Handle_VrmlData_Node theOther) -> Handle_VrmlData_Node

        Create a copy of this node.
        If the parameter is null, a new copied node is created. Otherwise new node
        is not created, but rather the given one is modified.<p>

        :type theOther: OCC.wrapper.VrmlData.Handle_VrmlData_Node
        :rtype: OCC.wrapper.VrmlData.Handle_VrmlData_Node

        """
        return _VrmlData.VrmlData_Color_Clone(self, *args)


    def Read(self, *args):
        """
        Read(VrmlData_Color self, VrmlData_InBuffer & theBuffer) -> VrmlData_ErrorStatus

        Read the Node from input stream.

        :type theBuffer: OCC.wrapper.VrmlData.VrmlData_InBuffer
        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.VrmlData_Color_Read(self, *args)


    def Write(self, *args):
        """
        Write(VrmlData_Color self, char const * thePrefix) -> VrmlData_ErrorStatus

        Write the Node to the Scene output.

        :type thePrefix: const char *
        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.VrmlData_Color_Write(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _VrmlData.VrmlData_Color_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _VrmlData.VrmlData_Color_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _VrmlData.VrmlData_Color_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _VrmlData.delete_VrmlData_Color
VrmlData_Color_swigregister = _VrmlData.VrmlData_Color_swigregister
VrmlData_Color_swigregister(VrmlData_Color)

def VrmlData_Color_get_type_name(*args):
    """
    VrmlData_Color_get_type_name() -> char const *

    :rtype: const char *

    """
    return _VrmlData.VrmlData_Color_get_type_name(*args)

def VrmlData_Color_get_type_descriptor(*args):
    """
    VrmlData_Color_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _VrmlData.VrmlData_Color_get_type_descriptor(*args)

class Handle_VrmlData_TextureCoordinate(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_VrmlData_TextureCoordinate self)

        Nullify the handle


        """
        return _VrmlData.Handle_VrmlData_TextureCoordinate_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_VrmlData_TextureCoordinate self) -> bool

        Check for being null

        :rtype: bool

        """
        return _VrmlData.Handle_VrmlData_TextureCoordinate_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_VrmlData_TextureCoordinate self, VrmlData_TextureCoordinate thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _VrmlData.Handle_VrmlData_TextureCoordinate_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_VrmlData_TextureCoordinate self, Handle_VrmlData_TextureCoordinate theHandle) -> Handle_VrmlData_TextureCoordinate
        assign(Handle_VrmlData_TextureCoordinate self, VrmlData_TextureCoordinate thePtr) -> Handle_VrmlData_TextureCoordinate
        assign(Handle_VrmlData_TextureCoordinate self, Handle_VrmlData_TextureCoordinate theHandle) -> Handle_VrmlData_TextureCoordinate

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _VrmlData.Handle_VrmlData_TextureCoordinate_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_VrmlData_TextureCoordinate self) -> VrmlData_TextureCoordinate

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _VrmlData.Handle_VrmlData_TextureCoordinate_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_VrmlData_TextureCoordinate self) -> VrmlData_TextureCoordinate

        Member access operator (note non-const)

        :rtype: T *

        """
        return _VrmlData.Handle_VrmlData_TextureCoordinate___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_VrmlData_TextureCoordinate self) -> VrmlData_TextureCoordinate

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _VrmlData.Handle_VrmlData_TextureCoordinate___ref__(self, *args)


    def __hash__(self):
        return _VrmlData.Handle_VrmlData_TextureCoordinate___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _VrmlData.Handle_VrmlData_TextureCoordinate___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _VrmlData.new_Handle_VrmlData_TextureCoordinate(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_VrmlData.Handle_VrmlData_TextureCoordinate_DownCast)
    __swig_destroy__ = _VrmlData.delete_Handle_VrmlData_TextureCoordinate

    def AllocateValues(self, *args):
        """
        AllocateValues(Handle_VrmlData_TextureCoordinate self, Standard_Size const theLength) -> Standard_Boolean

        Create a data array and assign the field myArray.
        @return
        True if allocation was successful.

        :type theLength: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _VrmlData.Handle_VrmlData_TextureCoordinate_AllocateValues(self, *args)


    def Length(self, *args):
        """
        Length(Handle_VrmlData_TextureCoordinate self) -> size_t

        Query the number of points

        :rtype: size_t

        """
        return _VrmlData.Handle_VrmlData_TextureCoordinate_Length(self, *args)


    def Points(self, *args):
        """
        Points(Handle_VrmlData_TextureCoordinate self) -> gp_XY

        Query the points

        :rtype: OCC.wrapper.gp.gp_XY

        """
        return _VrmlData.Handle_VrmlData_TextureCoordinate_Points(self, *args)


    def SetPoints(self, *args):
        """
        SetPoints(Handle_VrmlData_TextureCoordinate self, size_t const nPoints, gp_XY arrPoints)

        Set the points array

        :type nPoints: size_t
        :type arrPoints: OCC.wrapper.gp.gp_XY

        """
        return _VrmlData.Handle_VrmlData_TextureCoordinate_SetPoints(self, *args)


    def Clone(self, *args):
        """
        Clone(Handle_VrmlData_TextureCoordinate self, Handle_VrmlData_Node theOther) -> Handle_VrmlData_Node

        Create a copy of this node.
        If the parameter is null, a new copied node is created. Otherwise new node
        is not created, but rather the given one is modified.

        :type theOther: OCC.wrapper.VrmlData.Handle_VrmlData_Node
        :rtype: OCC.wrapper.VrmlData.Handle_VrmlData_Node

        """
        return _VrmlData.Handle_VrmlData_TextureCoordinate_Clone(self, *args)


    def Read(self, *args):
        """
        Read(Handle_VrmlData_TextureCoordinate self, VrmlData_InBuffer & theBuffer) -> VrmlData_ErrorStatus

        Read the Node from input stream.

        :type theBuffer: OCC.wrapper.VrmlData.VrmlData_InBuffer
        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.Handle_VrmlData_TextureCoordinate_Read(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_VrmlData_TextureCoordinate self) -> char const *

        :rtype: const char *

        """
        return _VrmlData.Handle_VrmlData_TextureCoordinate_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _VrmlData.Handle_VrmlData_TextureCoordinate_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _VrmlData.Handle_VrmlData_TextureCoordinate_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Scene(self, *args):
        """
        Query the Scene that contains this Node

        :rtype: OCC.wrapper.VrmlData.VrmlData_Scene

        """
        res = _VrmlData.Handle_VrmlData_TextureCoordinate_Scene(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Name(self, *args):
        """
        Name(Handle_VrmlData_TextureCoordinate self) -> char const *

        Query the name

        :rtype: const char *

        """
        return _VrmlData.Handle_VrmlData_TextureCoordinate_Name(self, *args)


    def ReadNode(self, *args):
        """
        ReadNode(Handle_VrmlData_TextureCoordinate self, VrmlData_InBuffer & theBuffer, Handle_VrmlData_Node theNode, Handle_Standard_Type Type=0) -> VrmlData_ErrorStatus

        Read a complete node definition from VRML stream
        @param theBuffer
        Buffer receiving the input data.
        @param theNode
        <tt>[out]</tt> Node restored from the buffer data
        @param Type
        Node type to be checked. If it is NULL(default) no type checking is done.
        Otherwise the created node is matched and an error is returned if
        no match detected.

        :type theBuffer: OCC.wrapper.VrmlData.VrmlData_InBuffer
        :type theNode: OCC.wrapper.VrmlData.Handle_VrmlData_Node
        :type Type: OCC.wrapper.Standard.Handle_Standard_Type
        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.Handle_VrmlData_TextureCoordinate_ReadNode(self, *args)


    def Write(self, *args):
        """
        Write(Handle_VrmlData_TextureCoordinate self, char const * thePrefix) -> VrmlData_ErrorStatus

        Write the Node to output stream.

        :type thePrefix: const char *
        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.Handle_VrmlData_TextureCoordinate_Write(self, *args)


    def IsDefault(self, *args):
        """
        IsDefault(Handle_VrmlData_TextureCoordinate self) -> Standard_Boolean

        Returns True if the node is default, then it would not be written.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _VrmlData.Handle_VrmlData_TextureCoordinate_IsDefault(self, *args)


    def WriteClosing(self, *args):
        """
        WriteClosing(Handle_VrmlData_TextureCoordinate self) -> VrmlData_ErrorStatus

        Write the closing brace in the end of a node output.

        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.Handle_VrmlData_TextureCoordinate_WriteClosing(self, *args)


    def ReadBoolean(self, *args):
        """
        ReadBoolean(Handle_VrmlData_TextureCoordinate self, VrmlData_InBuffer & theBuffer) -> VrmlData_ErrorStatus

        Read one boolean value (TRUE or FALSE).

        :type theBuffer: OCC.wrapper.VrmlData.VrmlData_InBuffer
        :type theResult: bool
        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.Handle_VrmlData_TextureCoordinate_ReadBoolean(self, *args)


    def ReadString(self, *args):
        """
        ReadString(Handle_VrmlData_TextureCoordinate self, VrmlData_InBuffer & theBuffer, TCollection_AsciiString theRes) -> VrmlData_ErrorStatus

        Read one quoted string, the quotes are removed.

        :type theBuffer: OCC.wrapper.VrmlData.VrmlData_InBuffer
        :type theRes: OCC.wrapper.TCollection.TCollection_AsciiString
        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.Handle_VrmlData_TextureCoordinate_ReadString(self, *args)


    def ReadMultiString(self, *args):
        """
        ReadMultiString(Handle_VrmlData_TextureCoordinate self, VrmlData_InBuffer & theBuffer, NCollection_List_TCollection_AsciiString theRes) -> VrmlData_ErrorStatus

        Read one quoted string, the quotes are removed.

        :type theBuffer: OCC.wrapper.VrmlData.VrmlData_InBuffer
        :type theRes: OCC.wrapper.TColStd.NCollection_List_TCollection_AsciiString
        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.Handle_VrmlData_TextureCoordinate_ReadMultiString(self, *args)


    def ReadInteger(self, *args):
        """
        ReadInteger(Handle_VrmlData_TextureCoordinate self, VrmlData_InBuffer & theBuffer) -> VrmlData_ErrorStatus

        Read one integer value.

        :type theBuffer: OCC.wrapper.VrmlData.VrmlData_InBuffer
        :type theResult: long &
        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.Handle_VrmlData_TextureCoordinate_ReadInteger(self, *args)


    def OK(self, *args):
        """
        OK(Handle_VrmlData_TextureCoordinate self, VrmlData_ErrorStatus const theStat) -> Standard_Boolean
        OK(Handle_VrmlData_TextureCoordinate self, VrmlData_ErrorStatus const theStat) -> Standard_Boolean

        :type outStat: OCC.wrapper.VrmlData.VrmlData_ErrorStatus
        :type theStat: OCC.wrapper.VrmlData.VrmlData_ErrorStatus
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _VrmlData.Handle_VrmlData_TextureCoordinate_OK(self, *args)


    def GlobalIndent(self, *args):
        """
        GlobalIndent(Handle_VrmlData_TextureCoordinate self) -> Standard_Integer

        Define the common Indent in spaces, for writing all nodes.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _VrmlData.Handle_VrmlData_TextureCoordinate_GlobalIndent(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_VrmlData_TextureCoordinate self)

        Memory deallocator for transient classes


        """
        return _VrmlData.Handle_VrmlData_TextureCoordinate_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_VrmlData_TextureCoordinate self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_VrmlData_TextureCoordinate self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _VrmlData.Handle_VrmlData_TextureCoordinate_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_VrmlData_TextureCoordinate self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_VrmlData_TextureCoordinate self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _VrmlData.Handle_VrmlData_TextureCoordinate_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_VrmlData_TextureCoordinate self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _VrmlData.Handle_VrmlData_TextureCoordinate_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_VrmlData_TextureCoordinate self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _VrmlData.Handle_VrmlData_TextureCoordinate_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_VrmlData_TextureCoordinate self)

        Increments the reference counter of this object


        """
        return _VrmlData.Handle_VrmlData_TextureCoordinate_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_VrmlData_TextureCoordinate self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _VrmlData.Handle_VrmlData_TextureCoordinate_DecrementRefCounter(self, *args)

Handle_VrmlData_TextureCoordinate_swigregister = _VrmlData.Handle_VrmlData_TextureCoordinate_swigregister
Handle_VrmlData_TextureCoordinate_swigregister(Handle_VrmlData_TextureCoordinate)

def Handle_VrmlData_TextureCoordinate_DownCast(thing):
    return _VrmlData.Handle_VrmlData_TextureCoordinate_DownCast(thing)
Handle_VrmlData_TextureCoordinate_DownCast = _VrmlData.Handle_VrmlData_TextureCoordinate_DownCast

class Handle_VrmlData_Color(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_VrmlData_Color self)

        Nullify the handle


        """
        return _VrmlData.Handle_VrmlData_Color_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_VrmlData_Color self) -> bool

        Check for being null

        :rtype: bool

        """
        return _VrmlData.Handle_VrmlData_Color_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_VrmlData_Color self, VrmlData_Color thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _VrmlData.Handle_VrmlData_Color_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_VrmlData_Color self, Handle_VrmlData_Color theHandle) -> Handle_VrmlData_Color
        assign(Handle_VrmlData_Color self, VrmlData_Color thePtr) -> Handle_VrmlData_Color
        assign(Handle_VrmlData_Color self, Handle_VrmlData_Color theHandle) -> Handle_VrmlData_Color

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _VrmlData.Handle_VrmlData_Color_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_VrmlData_Color self) -> VrmlData_Color

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _VrmlData.Handle_VrmlData_Color_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_VrmlData_Color self) -> VrmlData_Color

        Member access operator (note non-const)

        :rtype: T *

        """
        return _VrmlData.Handle_VrmlData_Color___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_VrmlData_Color self) -> VrmlData_Color

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _VrmlData.Handle_VrmlData_Color___ref__(self, *args)


    def __hash__(self):
        return _VrmlData.Handle_VrmlData_Color___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _VrmlData.Handle_VrmlData_Color___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _VrmlData.new_Handle_VrmlData_Color(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_VrmlData.Handle_VrmlData_Color_DownCast)
    __swig_destroy__ = _VrmlData.delete_Handle_VrmlData_Color

    def Color(self, *args):
        """
        Color(Handle_VrmlData_Color self, Standard_Integer const i) -> Quantity_Color

        Query one color
        @param i
        index in the array of colors [0 .. N-1]
        @return
        the color value for the index. If index irrelevant, returns (0., 0., 0.)

        :type i: int
        :rtype: OCC.wrapper.Quantity.Quantity_Color

        """
        return _VrmlData.Handle_VrmlData_Color_Color(self, *args)


    def SetColors(self, *args):
        """
        SetColors(Handle_VrmlData_Color self, size_t const nColors, gp_XYZ arrColors)

        Set the array data

        :type nColors: size_t
        :type arrColors: OCC.wrapper.gp.gp_XYZ

        """
        return _VrmlData.Handle_VrmlData_Color_SetColors(self, *args)


    def Clone(self, *args):
        """
        Clone(Handle_VrmlData_Color self, Handle_VrmlData_Node theOther) -> Handle_VrmlData_Node

        Create a copy of this node.
        If the parameter is null, a new copied node is created. Otherwise new node
        is not created, but rather the given one is modified.<p>

        :type theOther: OCC.wrapper.VrmlData.Handle_VrmlData_Node
        :rtype: OCC.wrapper.VrmlData.Handle_VrmlData_Node

        """
        return _VrmlData.Handle_VrmlData_Color_Clone(self, *args)


    def Read(self, *args):
        """
        Read(Handle_VrmlData_Color self, VrmlData_InBuffer & theBuffer) -> VrmlData_ErrorStatus

        Read the Node from input stream.

        :type theBuffer: OCC.wrapper.VrmlData.VrmlData_InBuffer
        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.Handle_VrmlData_Color_Read(self, *args)


    def Write(self, *args):
        """
        Write(Handle_VrmlData_Color self, char const * thePrefix) -> VrmlData_ErrorStatus

        Write the Node to the Scene output.

        :type thePrefix: const char *
        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.Handle_VrmlData_Color_Write(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_VrmlData_Color self) -> char const *

        :rtype: const char *

        """
        return _VrmlData.Handle_VrmlData_Color_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _VrmlData.Handle_VrmlData_Color_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _VrmlData.Handle_VrmlData_Color_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Length(self, *args):
        """
        Length(Handle_VrmlData_Color self) -> Standard_Size

        Query the number of vectors

        :rtype: OCC.wrapper.Standard.Standard_Size

        """
        return _VrmlData.Handle_VrmlData_Color_Length(self, *args)


    def Values(self, *args):
        """
        Values(Handle_VrmlData_Color self) -> gp_XYZ

        Query the array

        :rtype: OCC.wrapper.gp.gp_XYZ

        """
        return _VrmlData.Handle_VrmlData_Color_Values(self, *args)


    def AllocateValues(self, *args):
        """
        AllocateValues(Handle_VrmlData_Color self, Standard_Size const theLength) -> Standard_Boolean

        Create a data array and assign the field myArray.
        @return
        True if allocation was successful.

        :type theLength: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _VrmlData.Handle_VrmlData_Color_AllocateValues(self, *args)


    def SetValues(self, *args):
        """
        SetValues(Handle_VrmlData_Color self, Standard_Size const nValues, gp_XYZ arrValues)

        Set the array data

        :type nValues: int
        :type arrValues: OCC.wrapper.gp.gp_XYZ

        """
        return _VrmlData.Handle_VrmlData_Color_SetValues(self, *args)


    def ReadArray(self, *args):
        """
        ReadArray(Handle_VrmlData_Color self, VrmlData_InBuffer & theBuffer, char const * theName, Standard_Boolean const isScale) -> VrmlData_ErrorStatus

        Read the Node from input stream.

        :type theBuffer: OCC.wrapper.VrmlData.VrmlData_InBuffer
        :type theName: const char *
        :type isScale: bool
        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.Handle_VrmlData_Color_ReadArray(self, *args)


    def WriteArray(self, *args):
        """
        WriteArray(Handle_VrmlData_Color self, char const * theName, Standard_Boolean const isScale) -> VrmlData_ErrorStatus

        Write the Node to the output stream currently opened in Scene.

        :type theName: const char *
        :type isScale: bool
        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.Handle_VrmlData_Color_WriteArray(self, *args)


    def IsDefault(self, *args):
        """
        IsDefault(Handle_VrmlData_Color self) -> Standard_Boolean

        Returns True if the node is default, so that it should not be written.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _VrmlData.Handle_VrmlData_Color_IsDefault(self, *args)


    def Scene(self, *args):
        """
        Query the Scene that contains this Node

        :rtype: OCC.wrapper.VrmlData.VrmlData_Scene

        """
        res = _VrmlData.Handle_VrmlData_Color_Scene(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Name(self, *args):
        """
        Name(Handle_VrmlData_Color self) -> char const *

        Query the name

        :rtype: const char *

        """
        return _VrmlData.Handle_VrmlData_Color_Name(self, *args)


    def ReadNode(self, *args):
        """
        ReadNode(Handle_VrmlData_Color self, VrmlData_InBuffer & theBuffer, Handle_VrmlData_Node theNode, Handle_Standard_Type Type=0) -> VrmlData_ErrorStatus

        Read a complete node definition from VRML stream
        @param theBuffer
        Buffer receiving the input data.
        @param theNode
        <tt>[out]</tt> Node restored from the buffer data
        @param Type
        Node type to be checked. If it is NULL(default) no type checking is done.
        Otherwise the created node is matched and an error is returned if
        no match detected.

        :type theBuffer: OCC.wrapper.VrmlData.VrmlData_InBuffer
        :type theNode: OCC.wrapper.VrmlData.Handle_VrmlData_Node
        :type Type: OCC.wrapper.Standard.Handle_Standard_Type
        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.Handle_VrmlData_Color_ReadNode(self, *args)


    def WriteClosing(self, *args):
        """
        WriteClosing(Handle_VrmlData_Color self) -> VrmlData_ErrorStatus

        Write the closing brace in the end of a node output.

        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.Handle_VrmlData_Color_WriteClosing(self, *args)


    def ReadBoolean(self, *args):
        """
        ReadBoolean(Handle_VrmlData_Color self, VrmlData_InBuffer & theBuffer) -> VrmlData_ErrorStatus

        Read one boolean value (TRUE or FALSE).

        :type theBuffer: OCC.wrapper.VrmlData.VrmlData_InBuffer
        :type theResult: bool
        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.Handle_VrmlData_Color_ReadBoolean(self, *args)


    def ReadString(self, *args):
        """
        ReadString(Handle_VrmlData_Color self, VrmlData_InBuffer & theBuffer, TCollection_AsciiString theRes) -> VrmlData_ErrorStatus

        Read one quoted string, the quotes are removed.

        :type theBuffer: OCC.wrapper.VrmlData.VrmlData_InBuffer
        :type theRes: OCC.wrapper.TCollection.TCollection_AsciiString
        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.Handle_VrmlData_Color_ReadString(self, *args)


    def ReadMultiString(self, *args):
        """
        ReadMultiString(Handle_VrmlData_Color self, VrmlData_InBuffer & theBuffer, NCollection_List_TCollection_AsciiString theRes) -> VrmlData_ErrorStatus

        Read one quoted string, the quotes are removed.

        :type theBuffer: OCC.wrapper.VrmlData.VrmlData_InBuffer
        :type theRes: OCC.wrapper.TColStd.NCollection_List_TCollection_AsciiString
        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.Handle_VrmlData_Color_ReadMultiString(self, *args)


    def ReadInteger(self, *args):
        """
        ReadInteger(Handle_VrmlData_Color self, VrmlData_InBuffer & theBuffer) -> VrmlData_ErrorStatus

        Read one integer value.

        :type theBuffer: OCC.wrapper.VrmlData.VrmlData_InBuffer
        :type theResult: long &
        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.Handle_VrmlData_Color_ReadInteger(self, *args)


    def OK(self, *args):
        """
        OK(Handle_VrmlData_Color self, VrmlData_ErrorStatus const theStat) -> Standard_Boolean
        OK(Handle_VrmlData_Color self, VrmlData_ErrorStatus const theStat) -> Standard_Boolean

        :type outStat: OCC.wrapper.VrmlData.VrmlData_ErrorStatus
        :type theStat: OCC.wrapper.VrmlData.VrmlData_ErrorStatus
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _VrmlData.Handle_VrmlData_Color_OK(self, *args)


    def GlobalIndent(self, *args):
        """
        GlobalIndent(Handle_VrmlData_Color self) -> Standard_Integer

        Define the common Indent in spaces, for writing all nodes.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _VrmlData.Handle_VrmlData_Color_GlobalIndent(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_VrmlData_Color self)

        Memory deallocator for transient classes


        """
        return _VrmlData.Handle_VrmlData_Color_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_VrmlData_Color self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_VrmlData_Color self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _VrmlData.Handle_VrmlData_Color_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_VrmlData_Color self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_VrmlData_Color self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _VrmlData.Handle_VrmlData_Color_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_VrmlData_Color self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _VrmlData.Handle_VrmlData_Color_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_VrmlData_Color self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _VrmlData.Handle_VrmlData_Color_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_VrmlData_Color self)

        Increments the reference counter of this object


        """
        return _VrmlData.Handle_VrmlData_Color_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_VrmlData_Color self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _VrmlData.Handle_VrmlData_Color_DecrementRefCounter(self, *args)

Handle_VrmlData_Color_swigregister = _VrmlData.Handle_VrmlData_Color_swigregister
Handle_VrmlData_Color_swigregister(Handle_VrmlData_Color)

def Handle_VrmlData_Color_DownCast(thing):
    return _VrmlData.Handle_VrmlData_Color_DownCast(thing)
Handle_VrmlData_Color_DownCast = _VrmlData.Handle_VrmlData_Color_DownCast

class VrmlData_WorldInfo(VrmlData_Node):
    """Data type for WorldInfo node"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_VrmlData_WorldInfo
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_VrmlData_WorldInfo(self) 
            return h


    def __init__(self, *args):
        """
        __init__(VrmlData_WorldInfo self) -> VrmlData_WorldInfo
        __init__(VrmlData_WorldInfo self, VrmlData_Scene theScene, char const * theName=0, char const * theTitle=0) -> VrmlData_WorldInfo

        Constructor.

        :type theScene: OCC.wrapper.VrmlData.VrmlData_Scene
        :type theName: const char *
        :type theTitle: const char *

        """
        this = _VrmlData.new_VrmlData_WorldInfo(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def SetTitle(self, *args):
        """
        SetTitle(VrmlData_WorldInfo self, char const * theString)

        Set or modify the title.

        :type theString: const char *

        """
        return _VrmlData.VrmlData_WorldInfo_SetTitle(self, *args)


    def AddInfo(self, *args):
        """
        AddInfo(VrmlData_WorldInfo self, char const * theString)

        Add a string to the list of info strings.

        :type theString: const char *

        """
        return _VrmlData.VrmlData_WorldInfo_AddInfo(self, *args)


    def Title(self, *args):
        """
        Title(VrmlData_WorldInfo self) -> char const *

        Query the title string.

        :rtype: const char *

        """
        return _VrmlData.VrmlData_WorldInfo_Title(self, *args)


    def Clone(self, *args):
        """
        Clone(VrmlData_WorldInfo self, Handle_VrmlData_Node theOther) -> Handle_VrmlData_Node

        Create a copy of this node.
        If the parameter is null, a new copied node is created. Otherwise new node
        is not created, but rather the given one is modified.

        :type theOther: OCC.wrapper.VrmlData.Handle_VrmlData_Node
        :rtype: OCC.wrapper.VrmlData.Handle_VrmlData_Node

        """
        return _VrmlData.VrmlData_WorldInfo_Clone(self, *args)


    def Read(self, *args):
        """
        Read(VrmlData_WorldInfo self, VrmlData_InBuffer & theBuffer) -> VrmlData_ErrorStatus

        Read the Node from input stream.

        :type theBuffer: OCC.wrapper.VrmlData.VrmlData_InBuffer
        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.VrmlData_WorldInfo_Read(self, *args)


    def Write(self, *args):
        """
        Write(VrmlData_WorldInfo self, char const * thePrefix) -> VrmlData_ErrorStatus

        Write the Node to the Scene output.

        :type thePrefix: const char *
        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.VrmlData_WorldInfo_Write(self, *args)


    def IsDefault(self, *args):
        """
        IsDefault(VrmlData_WorldInfo self) -> Standard_Boolean

        Returns True if the node is default, then it would not be written.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _VrmlData.VrmlData_WorldInfo_IsDefault(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _VrmlData.VrmlData_WorldInfo_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _VrmlData.VrmlData_WorldInfo_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _VrmlData.VrmlData_WorldInfo_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def infoIterator(self):
        return _VrmlData.VrmlData_WorldInfo_infoIterator(self)
    __swig_destroy__ = _VrmlData.delete_VrmlData_WorldInfo
VrmlData_WorldInfo_swigregister = _VrmlData.VrmlData_WorldInfo_swigregister
VrmlData_WorldInfo_swigregister(VrmlData_WorldInfo)

def VrmlData_WorldInfo_get_type_name(*args):
    """
    VrmlData_WorldInfo_get_type_name() -> char const *

    :rtype: const char *

    """
    return _VrmlData.VrmlData_WorldInfo_get_type_name(*args)

def VrmlData_WorldInfo_get_type_descriptor(*args):
    """
    VrmlData_WorldInfo_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _VrmlData.VrmlData_WorldInfo_get_type_descriptor(*args)

class Handle_VrmlData_ShapeNode(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_VrmlData_ShapeNode self)

        Nullify the handle


        """
        return _VrmlData.Handle_VrmlData_ShapeNode_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_VrmlData_ShapeNode self) -> bool

        Check for being null

        :rtype: bool

        """
        return _VrmlData.Handle_VrmlData_ShapeNode_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_VrmlData_ShapeNode self, VrmlData_ShapeNode thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _VrmlData.Handle_VrmlData_ShapeNode_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_VrmlData_ShapeNode self, Handle_VrmlData_ShapeNode theHandle) -> Handle_VrmlData_ShapeNode
        assign(Handle_VrmlData_ShapeNode self, VrmlData_ShapeNode thePtr) -> Handle_VrmlData_ShapeNode
        assign(Handle_VrmlData_ShapeNode self, Handle_VrmlData_ShapeNode theHandle) -> Handle_VrmlData_ShapeNode

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _VrmlData.Handle_VrmlData_ShapeNode_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_VrmlData_ShapeNode self) -> VrmlData_ShapeNode

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _VrmlData.Handle_VrmlData_ShapeNode_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_VrmlData_ShapeNode self) -> VrmlData_ShapeNode

        Member access operator (note non-const)

        :rtype: T *

        """
        return _VrmlData.Handle_VrmlData_ShapeNode___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_VrmlData_ShapeNode self) -> VrmlData_ShapeNode

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _VrmlData.Handle_VrmlData_ShapeNode___ref__(self, *args)


    def __hash__(self):
        return _VrmlData.Handle_VrmlData_ShapeNode___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _VrmlData.Handle_VrmlData_ShapeNode___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _VrmlData.new_Handle_VrmlData_ShapeNode(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_VrmlData.Handle_VrmlData_ShapeNode_DownCast)
    __swig_destroy__ = _VrmlData.delete_Handle_VrmlData_ShapeNode

    def Appearance(self, *args):
        """
        Query the Appearance.

        :rtype: OCC.wrapper.VrmlData.Handle_VrmlData_Appearance

        """
        res = _VrmlData.Handle_VrmlData_ShapeNode_Appearance(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Geometry(self, *args):
        """
        Query the Geometry.

        :rtype: OCC.wrapper.VrmlData.Handle_VrmlData_Geometry

        """
        res = _VrmlData.Handle_VrmlData_ShapeNode_Geometry(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetAppearance(self, *args):
        """
        SetAppearance(Handle_VrmlData_ShapeNode self, Handle_VrmlData_Appearance theAppear)

        Set the Appearance

        :type theAppear: OCC.wrapper.VrmlData.Handle_VrmlData_Appearance

        """
        return _VrmlData.Handle_VrmlData_ShapeNode_SetAppearance(self, *args)


    def SetGeometry(self, *args):
        """
        SetGeometry(Handle_VrmlData_ShapeNode self, Handle_VrmlData_Geometry theGeometry)

        Set the Geometry

        :type theGeometry: OCC.wrapper.VrmlData.Handle_VrmlData_Geometry

        """
        return _VrmlData.Handle_VrmlData_ShapeNode_SetGeometry(self, *args)


    def Clone(self, *args):
        """
        Clone(Handle_VrmlData_ShapeNode self, Handle_VrmlData_Node theOther) -> Handle_VrmlData_Node

        Create a copy of this node.
        If the parameter is null, a new copied node is created. Otherwise new node
        is not created, but rather the given one is modified.

        :type theOther: OCC.wrapper.VrmlData.Handle_VrmlData_Node
        :rtype: OCC.wrapper.VrmlData.Handle_VrmlData_Node

        """
        return _VrmlData.Handle_VrmlData_ShapeNode_Clone(self, *args)


    def Read(self, *args):
        """
        Read(Handle_VrmlData_ShapeNode self, VrmlData_InBuffer & theBuffer) -> VrmlData_ErrorStatus

        Fill the Node internal data from the given input stream.

        :type theBuffer: OCC.wrapper.VrmlData.VrmlData_InBuffer
        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.Handle_VrmlData_ShapeNode_Read(self, *args)


    def Write(self, *args):
        """
        Write(Handle_VrmlData_ShapeNode self, char const * thePrefix) -> VrmlData_ErrorStatus

        Write the Node to output stream.

        :type thePrefix: const char *
        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.Handle_VrmlData_ShapeNode_Write(self, *args)


    def IsDefault(self, *args):
        """
        IsDefault(Handle_VrmlData_ShapeNode self) -> Standard_Boolean

        Check if the Shape Node is writeable.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _VrmlData.Handle_VrmlData_ShapeNode_IsDefault(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_VrmlData_ShapeNode self) -> char const *

        :rtype: const char *

        """
        return _VrmlData.Handle_VrmlData_ShapeNode_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _VrmlData.Handle_VrmlData_ShapeNode_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _VrmlData.Handle_VrmlData_ShapeNode_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Scene(self, *args):
        """
        Query the Scene that contains this Node

        :rtype: OCC.wrapper.VrmlData.VrmlData_Scene

        """
        res = _VrmlData.Handle_VrmlData_ShapeNode_Scene(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Name(self, *args):
        """
        Name(Handle_VrmlData_ShapeNode self) -> char const *

        Query the name

        :rtype: const char *

        """
        return _VrmlData.Handle_VrmlData_ShapeNode_Name(self, *args)


    def ReadNode(self, *args):
        """
        ReadNode(Handle_VrmlData_ShapeNode self, VrmlData_InBuffer & theBuffer, Handle_VrmlData_Node theNode, Handle_Standard_Type Type=0) -> VrmlData_ErrorStatus

        Read a complete node definition from VRML stream
        @param theBuffer
        Buffer receiving the input data.
        @param theNode
        <tt>[out]</tt> Node restored from the buffer data
        @param Type
        Node type to be checked. If it is NULL(default) no type checking is done.
        Otherwise the created node is matched and an error is returned if
        no match detected.

        :type theBuffer: OCC.wrapper.VrmlData.VrmlData_InBuffer
        :type theNode: OCC.wrapper.VrmlData.Handle_VrmlData_Node
        :type Type: OCC.wrapper.Standard.Handle_Standard_Type
        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.Handle_VrmlData_ShapeNode_ReadNode(self, *args)


    def WriteClosing(self, *args):
        """
        WriteClosing(Handle_VrmlData_ShapeNode self) -> VrmlData_ErrorStatus

        Write the closing brace in the end of a node output.

        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.Handle_VrmlData_ShapeNode_WriteClosing(self, *args)


    def ReadBoolean(self, *args):
        """
        ReadBoolean(Handle_VrmlData_ShapeNode self, VrmlData_InBuffer & theBuffer) -> VrmlData_ErrorStatus

        Read one boolean value (TRUE or FALSE).

        :type theBuffer: OCC.wrapper.VrmlData.VrmlData_InBuffer
        :type theResult: bool
        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.Handle_VrmlData_ShapeNode_ReadBoolean(self, *args)


    def ReadString(self, *args):
        """
        ReadString(Handle_VrmlData_ShapeNode self, VrmlData_InBuffer & theBuffer, TCollection_AsciiString theRes) -> VrmlData_ErrorStatus

        Read one quoted string, the quotes are removed.

        :type theBuffer: OCC.wrapper.VrmlData.VrmlData_InBuffer
        :type theRes: OCC.wrapper.TCollection.TCollection_AsciiString
        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.Handle_VrmlData_ShapeNode_ReadString(self, *args)


    def ReadMultiString(self, *args):
        """
        ReadMultiString(Handle_VrmlData_ShapeNode self, VrmlData_InBuffer & theBuffer, NCollection_List_TCollection_AsciiString theRes) -> VrmlData_ErrorStatus

        Read one quoted string, the quotes are removed.

        :type theBuffer: OCC.wrapper.VrmlData.VrmlData_InBuffer
        :type theRes: OCC.wrapper.TColStd.NCollection_List_TCollection_AsciiString
        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.Handle_VrmlData_ShapeNode_ReadMultiString(self, *args)


    def ReadInteger(self, *args):
        """
        ReadInteger(Handle_VrmlData_ShapeNode self, VrmlData_InBuffer & theBuffer) -> VrmlData_ErrorStatus

        Read one integer value.

        :type theBuffer: OCC.wrapper.VrmlData.VrmlData_InBuffer
        :type theResult: long &
        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.Handle_VrmlData_ShapeNode_ReadInteger(self, *args)


    def OK(self, *args):
        """
        OK(Handle_VrmlData_ShapeNode self, VrmlData_ErrorStatus const theStat) -> Standard_Boolean
        OK(Handle_VrmlData_ShapeNode self, VrmlData_ErrorStatus const theStat) -> Standard_Boolean

        :type outStat: OCC.wrapper.VrmlData.VrmlData_ErrorStatus
        :type theStat: OCC.wrapper.VrmlData.VrmlData_ErrorStatus
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _VrmlData.Handle_VrmlData_ShapeNode_OK(self, *args)


    def GlobalIndent(self, *args):
        """
        GlobalIndent(Handle_VrmlData_ShapeNode self) -> Standard_Integer

        Define the common Indent in spaces, for writing all nodes.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _VrmlData.Handle_VrmlData_ShapeNode_GlobalIndent(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_VrmlData_ShapeNode self)

        Memory deallocator for transient classes


        """
        return _VrmlData.Handle_VrmlData_ShapeNode_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_VrmlData_ShapeNode self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_VrmlData_ShapeNode self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _VrmlData.Handle_VrmlData_ShapeNode_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_VrmlData_ShapeNode self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_VrmlData_ShapeNode self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _VrmlData.Handle_VrmlData_ShapeNode_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_VrmlData_ShapeNode self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _VrmlData.Handle_VrmlData_ShapeNode_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_VrmlData_ShapeNode self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _VrmlData.Handle_VrmlData_ShapeNode_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_VrmlData_ShapeNode self)

        Increments the reference counter of this object


        """
        return _VrmlData.Handle_VrmlData_ShapeNode_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_VrmlData_ShapeNode self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _VrmlData.Handle_VrmlData_ShapeNode_DecrementRefCounter(self, *args)

Handle_VrmlData_ShapeNode_swigregister = _VrmlData.Handle_VrmlData_ShapeNode_swigregister
Handle_VrmlData_ShapeNode_swigregister(Handle_VrmlData_ShapeNode)

def Handle_VrmlData_ShapeNode_DownCast(thing):
    return _VrmlData.Handle_VrmlData_ShapeNode_DownCast(thing)
Handle_VrmlData_ShapeNode_DownCast = _VrmlData.Handle_VrmlData_ShapeNode_DownCast

class Handle_VrmlData_Geometry(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_VrmlData_Geometry self)

        Nullify the handle


        """
        return _VrmlData.Handle_VrmlData_Geometry_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_VrmlData_Geometry self) -> bool

        Check for being null

        :rtype: bool

        """
        return _VrmlData.Handle_VrmlData_Geometry_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_VrmlData_Geometry self, VrmlData_Geometry thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _VrmlData.Handle_VrmlData_Geometry_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_VrmlData_Geometry self, Handle_VrmlData_Geometry theHandle) -> Handle_VrmlData_Geometry
        assign(Handle_VrmlData_Geometry self, VrmlData_Geometry thePtr) -> Handle_VrmlData_Geometry
        assign(Handle_VrmlData_Geometry self, Handle_VrmlData_Geometry theHandle) -> Handle_VrmlData_Geometry

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _VrmlData.Handle_VrmlData_Geometry_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_VrmlData_Geometry self) -> VrmlData_Geometry

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _VrmlData.Handle_VrmlData_Geometry_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_VrmlData_Geometry self) -> VrmlData_Geometry

        Member access operator (note non-const)

        :rtype: T *

        """
        return _VrmlData.Handle_VrmlData_Geometry___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_VrmlData_Geometry self) -> VrmlData_Geometry

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _VrmlData.Handle_VrmlData_Geometry___ref__(self, *args)


    def __hash__(self):
        return _VrmlData.Handle_VrmlData_Geometry___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _VrmlData.Handle_VrmlData_Geometry___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _VrmlData.new_Handle_VrmlData_Geometry(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_VrmlData.Handle_VrmlData_Geometry_DownCast)
    __swig_destroy__ = _VrmlData.delete_Handle_VrmlData_Geometry

    def TShape(self, *args):
        """
        Query the shape. This method checks the flag myIsModified; if True it
        should rebuild the shape presentation.

        :rtype: OCC.wrapper.TopoDS.Handle_TopoDS_TShape

        """
        res = _VrmlData.Handle_VrmlData_Geometry_TShape(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def get_type_name(self, *args):
        """
        get_type_name(Handle_VrmlData_Geometry self) -> char const *

        :rtype: const char *

        """
        return _VrmlData.Handle_VrmlData_Geometry_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _VrmlData.Handle_VrmlData_Geometry_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _VrmlData.Handle_VrmlData_Geometry_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Scene(self, *args):
        """
        Query the Scene that contains this Node

        :rtype: OCC.wrapper.VrmlData.VrmlData_Scene

        """
        res = _VrmlData.Handle_VrmlData_Geometry_Scene(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Name(self, *args):
        """
        Name(Handle_VrmlData_Geometry self) -> char const *

        Query the name

        :rtype: const char *

        """
        return _VrmlData.Handle_VrmlData_Geometry_Name(self, *args)


    def ReadNode(self, *args):
        """
        ReadNode(Handle_VrmlData_Geometry self, VrmlData_InBuffer & theBuffer, Handle_VrmlData_Node theNode, Handle_Standard_Type Type=0) -> VrmlData_ErrorStatus

        Read a complete node definition from VRML stream
        @param theBuffer
        Buffer receiving the input data.
        @param theNode
        <tt>[out]</tt> Node restored from the buffer data
        @param Type
        Node type to be checked. If it is NULL(default) no type checking is done.
        Otherwise the created node is matched and an error is returned if
        no match detected.

        :type theBuffer: OCC.wrapper.VrmlData.VrmlData_InBuffer
        :type theNode: OCC.wrapper.VrmlData.Handle_VrmlData_Node
        :type Type: OCC.wrapper.Standard.Handle_Standard_Type
        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.Handle_VrmlData_Geometry_ReadNode(self, *args)


    def Read(self, *args):
        """
        Read(Handle_VrmlData_Geometry self, VrmlData_InBuffer & theBuffer) -> VrmlData_ErrorStatus

        Read the Node from input stream.

        :type theBuffer: OCC.wrapper.VrmlData.VrmlData_InBuffer
        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.Handle_VrmlData_Geometry_Read(self, *args)


    def Write(self, *args):
        """
        Write(Handle_VrmlData_Geometry self, char const * thePrefix) -> VrmlData_ErrorStatus

        Write the Node to output stream.

        :type thePrefix: const char *
        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.Handle_VrmlData_Geometry_Write(self, *args)


    def IsDefault(self, *args):
        """
        IsDefault(Handle_VrmlData_Geometry self) -> Standard_Boolean

        Returns True if the node is default, then it would not be written.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _VrmlData.Handle_VrmlData_Geometry_IsDefault(self, *args)


    def WriteClosing(self, *args):
        """
        WriteClosing(Handle_VrmlData_Geometry self) -> VrmlData_ErrorStatus

        Write the closing brace in the end of a node output.

        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.Handle_VrmlData_Geometry_WriteClosing(self, *args)


    def Clone(self, *args):
        """
        Clone(Handle_VrmlData_Geometry self, Handle_VrmlData_Node arg2) -> Handle_VrmlData_Node

        Create a copy of this node.
        If the parameter is null, a new copied node is created. Otherwise new node
        is not created, but rather the given one is modified.<p>
        This method nullifies the argument node if its member myScene differs
        from that one of the current instance.

        :type : OCC.wrapper.VrmlData.Handle_VrmlData_Node
        :rtype: OCC.wrapper.VrmlData.Handle_VrmlData_Node

        """
        return _VrmlData.Handle_VrmlData_Geometry_Clone(self, *args)


    def ReadBoolean(self, *args):
        """
        ReadBoolean(Handle_VrmlData_Geometry self, VrmlData_InBuffer & theBuffer) -> VrmlData_ErrorStatus

        Read one boolean value (TRUE or FALSE).

        :type theBuffer: OCC.wrapper.VrmlData.VrmlData_InBuffer
        :type theResult: bool
        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.Handle_VrmlData_Geometry_ReadBoolean(self, *args)


    def ReadString(self, *args):
        """
        ReadString(Handle_VrmlData_Geometry self, VrmlData_InBuffer & theBuffer, TCollection_AsciiString theRes) -> VrmlData_ErrorStatus

        Read one quoted string, the quotes are removed.

        :type theBuffer: OCC.wrapper.VrmlData.VrmlData_InBuffer
        :type theRes: OCC.wrapper.TCollection.TCollection_AsciiString
        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.Handle_VrmlData_Geometry_ReadString(self, *args)


    def ReadMultiString(self, *args):
        """
        ReadMultiString(Handle_VrmlData_Geometry self, VrmlData_InBuffer & theBuffer, NCollection_List_TCollection_AsciiString theRes) -> VrmlData_ErrorStatus

        Read one quoted string, the quotes are removed.

        :type theBuffer: OCC.wrapper.VrmlData.VrmlData_InBuffer
        :type theRes: OCC.wrapper.TColStd.NCollection_List_TCollection_AsciiString
        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.Handle_VrmlData_Geometry_ReadMultiString(self, *args)


    def ReadInteger(self, *args):
        """
        ReadInteger(Handle_VrmlData_Geometry self, VrmlData_InBuffer & theBuffer) -> VrmlData_ErrorStatus

        Read one integer value.

        :type theBuffer: OCC.wrapper.VrmlData.VrmlData_InBuffer
        :type theResult: long &
        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.Handle_VrmlData_Geometry_ReadInteger(self, *args)


    def OK(self, *args):
        """
        OK(Handle_VrmlData_Geometry self, VrmlData_ErrorStatus const theStat) -> Standard_Boolean
        OK(Handle_VrmlData_Geometry self, VrmlData_ErrorStatus const theStat) -> Standard_Boolean

        :type outStat: OCC.wrapper.VrmlData.VrmlData_ErrorStatus
        :type theStat: OCC.wrapper.VrmlData.VrmlData_ErrorStatus
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _VrmlData.Handle_VrmlData_Geometry_OK(self, *args)


    def GlobalIndent(self, *args):
        """
        GlobalIndent(Handle_VrmlData_Geometry self) -> Standard_Integer

        Define the common Indent in spaces, for writing all nodes.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _VrmlData.Handle_VrmlData_Geometry_GlobalIndent(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_VrmlData_Geometry self)

        Memory deallocator for transient classes


        """
        return _VrmlData.Handle_VrmlData_Geometry_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_VrmlData_Geometry self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_VrmlData_Geometry self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _VrmlData.Handle_VrmlData_Geometry_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_VrmlData_Geometry self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_VrmlData_Geometry self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _VrmlData.Handle_VrmlData_Geometry_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_VrmlData_Geometry self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _VrmlData.Handle_VrmlData_Geometry_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_VrmlData_Geometry self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _VrmlData.Handle_VrmlData_Geometry_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_VrmlData_Geometry self)

        Increments the reference counter of this object


        """
        return _VrmlData.Handle_VrmlData_Geometry_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_VrmlData_Geometry self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _VrmlData.Handle_VrmlData_Geometry_DecrementRefCounter(self, *args)

Handle_VrmlData_Geometry_swigregister = _VrmlData.Handle_VrmlData_Geometry_swigregister
Handle_VrmlData_Geometry_swigregister(Handle_VrmlData_Geometry)

def Handle_VrmlData_Geometry_DownCast(thing):
    return _VrmlData.Handle_VrmlData_Geometry_DownCast(thing)
Handle_VrmlData_Geometry_DownCast = _VrmlData.Handle_VrmlData_Geometry_DownCast

class VrmlData_Box(VrmlData_Geometry):
    """
    Inplementation of the Box node.
    This node is defined by Size vector, assumong that the box center is located
    in (0., 0., 0.) and that each corner is 0.5*|Size| distance from the center.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_VrmlData_Box
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_VrmlData_Box(self) 
            return h


    def __init__(self, *args):
        """
        __init__(VrmlData_Box self) -> VrmlData_Box
        __init__(VrmlData_Box self, VrmlData_Scene theScene, char const * theName, Standard_Real const sizeX=2., Standard_Real const sizeY=2., Standard_Real const sizeZ=2.) -> VrmlData_Box

        Constructor

        :type theScene: OCC.wrapper.VrmlData.VrmlData_Scene
        :type theName: const char *
        :type sizeX: float
        :type sizeY: float
        :type sizeZ: float

        """
        this = _VrmlData.new_VrmlData_Box(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Size(self, *args):
        """
        Query the Box size

        :rtype: OCC.wrapper.gp.gp_XYZ

        """
        res = _VrmlData.VrmlData_Box_Size(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetSize(self, *args):
        """
        SetSize(VrmlData_Box self, gp_XYZ theSize)

        Set the Box Size

        :type theSize: OCC.wrapper.gp.gp_XYZ

        """
        return _VrmlData.VrmlData_Box_SetSize(self, *args)


    def TShape(self, *args):
        """
        Query the primitive topology. This method returns a Null shape if there
        is an internal error during the primitive creation (zero radius, etc.)

        :rtype: OCC.wrapper.TopoDS.Handle_TopoDS_TShape

        """
        res = _VrmlData.VrmlData_Box_TShape(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Clone(self, *args):
        """
        Clone(VrmlData_Box self, Handle_VrmlData_Node theOther) -> Handle_VrmlData_Node

        Create a copy of this node.
        If the parameter is null, a new copied node is created. Otherwise new node
        is not created, but rather the given one is modified.

        :type theOther: OCC.wrapper.VrmlData.Handle_VrmlData_Node
        :rtype: OCC.wrapper.VrmlData.Handle_VrmlData_Node

        """
        return _VrmlData.VrmlData_Box_Clone(self, *args)


    def Read(self, *args):
        """
        Read(VrmlData_Box self, VrmlData_InBuffer & theBuffer) -> VrmlData_ErrorStatus

        Fill the Node internal data from the given input stream.

        :type theBuffer: OCC.wrapper.VrmlData.VrmlData_InBuffer
        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.VrmlData_Box_Read(self, *args)


    def Write(self, *args):
        """
        Write(VrmlData_Box self, char const * thePrefix) -> VrmlData_ErrorStatus

        Write the Node to output stream.

        :type thePrefix: const char *
        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.VrmlData_Box_Write(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _VrmlData.VrmlData_Box_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _VrmlData.VrmlData_Box_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _VrmlData.VrmlData_Box_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _VrmlData.delete_VrmlData_Box
VrmlData_Box_swigregister = _VrmlData.VrmlData_Box_swigregister
VrmlData_Box_swigregister(VrmlData_Box)

def VrmlData_Box_get_type_name(*args):
    """
    VrmlData_Box_get_type_name() -> char const *

    :rtype: const char *

    """
    return _VrmlData.VrmlData_Box_get_type_name(*args)

def VrmlData_Box_get_type_descriptor(*args):
    """
    VrmlData_Box_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _VrmlData.VrmlData_Box_get_type_descriptor(*args)

class Handle_VrmlData_TextureTransform(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_VrmlData_TextureTransform self)

        Nullify the handle


        """
        return _VrmlData.Handle_VrmlData_TextureTransform_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_VrmlData_TextureTransform self) -> bool

        Check for being null

        :rtype: bool

        """
        return _VrmlData.Handle_VrmlData_TextureTransform_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_VrmlData_TextureTransform self, VrmlData_TextureTransform thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _VrmlData.Handle_VrmlData_TextureTransform_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_VrmlData_TextureTransform self, Handle_VrmlData_TextureTransform theHandle) -> Handle_VrmlData_TextureTransform
        assign(Handle_VrmlData_TextureTransform self, VrmlData_TextureTransform thePtr) -> Handle_VrmlData_TextureTransform
        assign(Handle_VrmlData_TextureTransform self, Handle_VrmlData_TextureTransform theHandle) -> Handle_VrmlData_TextureTransform

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _VrmlData.Handle_VrmlData_TextureTransform_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_VrmlData_TextureTransform self) -> VrmlData_TextureTransform

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _VrmlData.Handle_VrmlData_TextureTransform_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_VrmlData_TextureTransform self) -> VrmlData_TextureTransform

        Member access operator (note non-const)

        :rtype: T *

        """
        return _VrmlData.Handle_VrmlData_TextureTransform___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_VrmlData_TextureTransform self) -> VrmlData_TextureTransform

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _VrmlData.Handle_VrmlData_TextureTransform___ref__(self, *args)


    def __hash__(self):
        return _VrmlData.Handle_VrmlData_TextureTransform___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _VrmlData.Handle_VrmlData_TextureTransform___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _VrmlData.new_Handle_VrmlData_TextureTransform(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_VrmlData.Handle_VrmlData_TextureTransform_DownCast)
    __swig_destroy__ = _VrmlData.delete_Handle_VrmlData_TextureTransform

    def Center(self, *args):
        """
        Query the Center

        :rtype: OCC.wrapper.gp.gp_XY

        """
        res = _VrmlData.Handle_VrmlData_TextureTransform_Center(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Rotation(self, *args):
        """
        Rotation(Handle_VrmlData_TextureTransform self) -> Standard_Real

        Query the Rotation

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _VrmlData.Handle_VrmlData_TextureTransform_Rotation(self, *args)


    def Scale(self, *args):
        """
        Query the Scale

        :rtype: OCC.wrapper.gp.gp_XY

        """
        res = _VrmlData.Handle_VrmlData_TextureTransform_Scale(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Translation(self, *args):
        """
        Query the Translation

        :rtype: OCC.wrapper.gp.gp_XY

        """
        res = _VrmlData.Handle_VrmlData_TextureTransform_Translation(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetCenter(self, *args):
        """
        SetCenter(Handle_VrmlData_TextureTransform self, gp_XY V)

        Set the Center

        :type V: OCC.wrapper.gp.gp_XY

        """
        return _VrmlData.Handle_VrmlData_TextureTransform_SetCenter(self, *args)


    def SetRotation(self, *args):
        """
        SetRotation(Handle_VrmlData_TextureTransform self, Standard_Real const V)

        Set the Rotation

        :type V: float

        """
        return _VrmlData.Handle_VrmlData_TextureTransform_SetRotation(self, *args)


    def SetScale(self, *args):
        """
        SetScale(Handle_VrmlData_TextureTransform self, gp_XY V)

        Set the Scale

        :type V: OCC.wrapper.gp.gp_XY

        """
        return _VrmlData.Handle_VrmlData_TextureTransform_SetScale(self, *args)


    def SetTranslation(self, *args):
        """
        SetTranslation(Handle_VrmlData_TextureTransform self, gp_XY V)

        Set the Translation

        :type V: OCC.wrapper.gp.gp_XY

        """
        return _VrmlData.Handle_VrmlData_TextureTransform_SetTranslation(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_VrmlData_TextureTransform self) -> char const *

        :rtype: const char *

        """
        return _VrmlData.Handle_VrmlData_TextureTransform_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _VrmlData.Handle_VrmlData_TextureTransform_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _VrmlData.Handle_VrmlData_TextureTransform_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Scene(self, *args):
        """
        Query the Scene that contains this Node

        :rtype: OCC.wrapper.VrmlData.VrmlData_Scene

        """
        res = _VrmlData.Handle_VrmlData_TextureTransform_Scene(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Name(self, *args):
        """
        Name(Handle_VrmlData_TextureTransform self) -> char const *

        Query the name

        :rtype: const char *

        """
        return _VrmlData.Handle_VrmlData_TextureTransform_Name(self, *args)


    def ReadNode(self, *args):
        """
        ReadNode(Handle_VrmlData_TextureTransform self, VrmlData_InBuffer & theBuffer, Handle_VrmlData_Node theNode, Handle_Standard_Type Type=0) -> VrmlData_ErrorStatus

        Read a complete node definition from VRML stream
        @param theBuffer
        Buffer receiving the input data.
        @param theNode
        <tt>[out]</tt> Node restored from the buffer data
        @param Type
        Node type to be checked. If it is NULL(default) no type checking is done.
        Otherwise the created node is matched and an error is returned if
        no match detected.

        :type theBuffer: OCC.wrapper.VrmlData.VrmlData_InBuffer
        :type theNode: OCC.wrapper.VrmlData.Handle_VrmlData_Node
        :type Type: OCC.wrapper.Standard.Handle_Standard_Type
        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.Handle_VrmlData_TextureTransform_ReadNode(self, *args)


    def Read(self, *args):
        """
        Read(Handle_VrmlData_TextureTransform self, VrmlData_InBuffer & theBuffer) -> VrmlData_ErrorStatus

        Read the Node from input stream.

        :type theBuffer: OCC.wrapper.VrmlData.VrmlData_InBuffer
        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.Handle_VrmlData_TextureTransform_Read(self, *args)


    def Write(self, *args):
        """
        Write(Handle_VrmlData_TextureTransform self, char const * thePrefix) -> VrmlData_ErrorStatus

        Write the Node to output stream.

        :type thePrefix: const char *
        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.Handle_VrmlData_TextureTransform_Write(self, *args)


    def IsDefault(self, *args):
        """
        IsDefault(Handle_VrmlData_TextureTransform self) -> Standard_Boolean

        Returns True if the node is default, then it would not be written.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _VrmlData.Handle_VrmlData_TextureTransform_IsDefault(self, *args)


    def WriteClosing(self, *args):
        """
        WriteClosing(Handle_VrmlData_TextureTransform self) -> VrmlData_ErrorStatus

        Write the closing brace in the end of a node output.

        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.Handle_VrmlData_TextureTransform_WriteClosing(self, *args)


    def Clone(self, *args):
        """
        Clone(Handle_VrmlData_TextureTransform self, Handle_VrmlData_Node arg2) -> Handle_VrmlData_Node

        Create a copy of this node.
        If the parameter is null, a new copied node is created. Otherwise new node
        is not created, but rather the given one is modified.<p>
        This method nullifies the argument node if its member myScene differs
        from that one of the current instance.

        :type : OCC.wrapper.VrmlData.Handle_VrmlData_Node
        :rtype: OCC.wrapper.VrmlData.Handle_VrmlData_Node

        """
        return _VrmlData.Handle_VrmlData_TextureTransform_Clone(self, *args)


    def ReadBoolean(self, *args):
        """
        ReadBoolean(Handle_VrmlData_TextureTransform self, VrmlData_InBuffer & theBuffer) -> VrmlData_ErrorStatus

        Read one boolean value (TRUE or FALSE).

        :type theBuffer: OCC.wrapper.VrmlData.VrmlData_InBuffer
        :type theResult: bool
        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.Handle_VrmlData_TextureTransform_ReadBoolean(self, *args)


    def ReadString(self, *args):
        """
        ReadString(Handle_VrmlData_TextureTransform self, VrmlData_InBuffer & theBuffer, TCollection_AsciiString theRes) -> VrmlData_ErrorStatus

        Read one quoted string, the quotes are removed.

        :type theBuffer: OCC.wrapper.VrmlData.VrmlData_InBuffer
        :type theRes: OCC.wrapper.TCollection.TCollection_AsciiString
        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.Handle_VrmlData_TextureTransform_ReadString(self, *args)


    def ReadMultiString(self, *args):
        """
        ReadMultiString(Handle_VrmlData_TextureTransform self, VrmlData_InBuffer & theBuffer, NCollection_List_TCollection_AsciiString theRes) -> VrmlData_ErrorStatus

        Read one quoted string, the quotes are removed.

        :type theBuffer: OCC.wrapper.VrmlData.VrmlData_InBuffer
        :type theRes: OCC.wrapper.TColStd.NCollection_List_TCollection_AsciiString
        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.Handle_VrmlData_TextureTransform_ReadMultiString(self, *args)


    def ReadInteger(self, *args):
        """
        ReadInteger(Handle_VrmlData_TextureTransform self, VrmlData_InBuffer & theBuffer) -> VrmlData_ErrorStatus

        Read one integer value.

        :type theBuffer: OCC.wrapper.VrmlData.VrmlData_InBuffer
        :type theResult: long &
        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.Handle_VrmlData_TextureTransform_ReadInteger(self, *args)


    def OK(self, *args):
        """
        OK(Handle_VrmlData_TextureTransform self, VrmlData_ErrorStatus const theStat) -> Standard_Boolean
        OK(Handle_VrmlData_TextureTransform self, VrmlData_ErrorStatus const theStat) -> Standard_Boolean

        :type outStat: OCC.wrapper.VrmlData.VrmlData_ErrorStatus
        :type theStat: OCC.wrapper.VrmlData.VrmlData_ErrorStatus
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _VrmlData.Handle_VrmlData_TextureTransform_OK(self, *args)


    def GlobalIndent(self, *args):
        """
        GlobalIndent(Handle_VrmlData_TextureTransform self) -> Standard_Integer

        Define the common Indent in spaces, for writing all nodes.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _VrmlData.Handle_VrmlData_TextureTransform_GlobalIndent(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_VrmlData_TextureTransform self)

        Memory deallocator for transient classes


        """
        return _VrmlData.Handle_VrmlData_TextureTransform_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_VrmlData_TextureTransform self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_VrmlData_TextureTransform self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _VrmlData.Handle_VrmlData_TextureTransform_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_VrmlData_TextureTransform self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_VrmlData_TextureTransform self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _VrmlData.Handle_VrmlData_TextureTransform_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_VrmlData_TextureTransform self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _VrmlData.Handle_VrmlData_TextureTransform_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_VrmlData_TextureTransform self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _VrmlData.Handle_VrmlData_TextureTransform_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_VrmlData_TextureTransform self)

        Increments the reference counter of this object


        """
        return _VrmlData.Handle_VrmlData_TextureTransform_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_VrmlData_TextureTransform self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _VrmlData.Handle_VrmlData_TextureTransform_DecrementRefCounter(self, *args)

Handle_VrmlData_TextureTransform_swigregister = _VrmlData.Handle_VrmlData_TextureTransform_swigregister
Handle_VrmlData_TextureTransform_swigregister(Handle_VrmlData_TextureTransform)

def Handle_VrmlData_TextureTransform_DownCast(thing):
    return _VrmlData.Handle_VrmlData_TextureTransform_DownCast(thing)
Handle_VrmlData_TextureTransform_DownCast = _VrmlData.Handle_VrmlData_TextureTransform_DownCast

class Handle_VrmlData_Sphere(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_VrmlData_Sphere self)

        Nullify the handle


        """
        return _VrmlData.Handle_VrmlData_Sphere_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_VrmlData_Sphere self) -> bool

        Check for being null

        :rtype: bool

        """
        return _VrmlData.Handle_VrmlData_Sphere_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_VrmlData_Sphere self, VrmlData_Sphere thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _VrmlData.Handle_VrmlData_Sphere_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_VrmlData_Sphere self, Handle_VrmlData_Sphere theHandle) -> Handle_VrmlData_Sphere
        assign(Handle_VrmlData_Sphere self, VrmlData_Sphere thePtr) -> Handle_VrmlData_Sphere
        assign(Handle_VrmlData_Sphere self, Handle_VrmlData_Sphere theHandle) -> Handle_VrmlData_Sphere

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _VrmlData.Handle_VrmlData_Sphere_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_VrmlData_Sphere self) -> VrmlData_Sphere

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _VrmlData.Handle_VrmlData_Sphere_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_VrmlData_Sphere self) -> VrmlData_Sphere

        Member access operator (note non-const)

        :rtype: T *

        """
        return _VrmlData.Handle_VrmlData_Sphere___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_VrmlData_Sphere self) -> VrmlData_Sphere

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _VrmlData.Handle_VrmlData_Sphere___ref__(self, *args)


    def __hash__(self):
        return _VrmlData.Handle_VrmlData_Sphere___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _VrmlData.Handle_VrmlData_Sphere___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _VrmlData.new_Handle_VrmlData_Sphere(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_VrmlData.Handle_VrmlData_Sphere_DownCast)
    __swig_destroy__ = _VrmlData.delete_Handle_VrmlData_Sphere

    def Radius(self, *args):
        """
        Radius(Handle_VrmlData_Sphere self) -> Standard_Real

        Query the sphere radius

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _VrmlData.Handle_VrmlData_Sphere_Radius(self, *args)


    def SetRadius(self, *args):
        """
        SetRadius(Handle_VrmlData_Sphere self, Standard_Real const theRadius)

        Set the spere radius

        :type theRadius: float

        """
        return _VrmlData.Handle_VrmlData_Sphere_SetRadius(self, *args)


    def TShape(self, *args):
        """
        Query the primitive topology. This method returns a Null shape if there
        is an internal error during the primitive creation (zero radius, etc.)

        :rtype: OCC.wrapper.TopoDS.Handle_TopoDS_TShape

        """
        res = _VrmlData.Handle_VrmlData_Sphere_TShape(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Clone(self, *args):
        """
        Clone(Handle_VrmlData_Sphere self, Handle_VrmlData_Node theOther) -> Handle_VrmlData_Node

        Create a copy of this node.
        If the parameter is null, a new copied node is created. Otherwise new node
        is not created, but rather the given one is modified.

        :type theOther: OCC.wrapper.VrmlData.Handle_VrmlData_Node
        :rtype: OCC.wrapper.VrmlData.Handle_VrmlData_Node

        """
        return _VrmlData.Handle_VrmlData_Sphere_Clone(self, *args)


    def Read(self, *args):
        """
        Read(Handle_VrmlData_Sphere self, VrmlData_InBuffer & theBuffer) -> VrmlData_ErrorStatus

        Fill the Node internal data from the given input stream.

        :type theBuffer: OCC.wrapper.VrmlData.VrmlData_InBuffer
        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.Handle_VrmlData_Sphere_Read(self, *args)


    def Write(self, *args):
        """
        Write(Handle_VrmlData_Sphere self, char const * thePrefix) -> VrmlData_ErrorStatus

        Write the Node to output stream.

        :type thePrefix: const char *
        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.Handle_VrmlData_Sphere_Write(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_VrmlData_Sphere self) -> char const *

        :rtype: const char *

        """
        return _VrmlData.Handle_VrmlData_Sphere_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _VrmlData.Handle_VrmlData_Sphere_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _VrmlData.Handle_VrmlData_Sphere_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Scene(self, *args):
        """
        Query the Scene that contains this Node

        :rtype: OCC.wrapper.VrmlData.VrmlData_Scene

        """
        res = _VrmlData.Handle_VrmlData_Sphere_Scene(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Name(self, *args):
        """
        Name(Handle_VrmlData_Sphere self) -> char const *

        Query the name

        :rtype: const char *

        """
        return _VrmlData.Handle_VrmlData_Sphere_Name(self, *args)


    def ReadNode(self, *args):
        """
        ReadNode(Handle_VrmlData_Sphere self, VrmlData_InBuffer & theBuffer, Handle_VrmlData_Node theNode, Handle_Standard_Type Type=0) -> VrmlData_ErrorStatus

        Read a complete node definition from VRML stream
        @param theBuffer
        Buffer receiving the input data.
        @param theNode
        <tt>[out]</tt> Node restored from the buffer data
        @param Type
        Node type to be checked. If it is NULL(default) no type checking is done.
        Otherwise the created node is matched and an error is returned if
        no match detected.

        :type theBuffer: OCC.wrapper.VrmlData.VrmlData_InBuffer
        :type theNode: OCC.wrapper.VrmlData.Handle_VrmlData_Node
        :type Type: OCC.wrapper.Standard.Handle_Standard_Type
        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.Handle_VrmlData_Sphere_ReadNode(self, *args)


    def IsDefault(self, *args):
        """
        IsDefault(Handle_VrmlData_Sphere self) -> Standard_Boolean

        Returns True if the node is default, then it would not be written.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _VrmlData.Handle_VrmlData_Sphere_IsDefault(self, *args)


    def WriteClosing(self, *args):
        """
        WriteClosing(Handle_VrmlData_Sphere self) -> VrmlData_ErrorStatus

        Write the closing brace in the end of a node output.

        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.Handle_VrmlData_Sphere_WriteClosing(self, *args)


    def ReadBoolean(self, *args):
        """
        ReadBoolean(Handle_VrmlData_Sphere self, VrmlData_InBuffer & theBuffer) -> VrmlData_ErrorStatus

        Read one boolean value (TRUE or FALSE).

        :type theBuffer: OCC.wrapper.VrmlData.VrmlData_InBuffer
        :type theResult: bool
        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.Handle_VrmlData_Sphere_ReadBoolean(self, *args)


    def ReadString(self, *args):
        """
        ReadString(Handle_VrmlData_Sphere self, VrmlData_InBuffer & theBuffer, TCollection_AsciiString theRes) -> VrmlData_ErrorStatus

        Read one quoted string, the quotes are removed.

        :type theBuffer: OCC.wrapper.VrmlData.VrmlData_InBuffer
        :type theRes: OCC.wrapper.TCollection.TCollection_AsciiString
        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.Handle_VrmlData_Sphere_ReadString(self, *args)


    def ReadMultiString(self, *args):
        """
        ReadMultiString(Handle_VrmlData_Sphere self, VrmlData_InBuffer & theBuffer, NCollection_List_TCollection_AsciiString theRes) -> VrmlData_ErrorStatus

        Read one quoted string, the quotes are removed.

        :type theBuffer: OCC.wrapper.VrmlData.VrmlData_InBuffer
        :type theRes: OCC.wrapper.TColStd.NCollection_List_TCollection_AsciiString
        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.Handle_VrmlData_Sphere_ReadMultiString(self, *args)


    def ReadInteger(self, *args):
        """
        ReadInteger(Handle_VrmlData_Sphere self, VrmlData_InBuffer & theBuffer) -> VrmlData_ErrorStatus

        Read one integer value.

        :type theBuffer: OCC.wrapper.VrmlData.VrmlData_InBuffer
        :type theResult: long &
        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.Handle_VrmlData_Sphere_ReadInteger(self, *args)


    def OK(self, *args):
        """
        OK(Handle_VrmlData_Sphere self, VrmlData_ErrorStatus const theStat) -> Standard_Boolean
        OK(Handle_VrmlData_Sphere self, VrmlData_ErrorStatus const theStat) -> Standard_Boolean

        :type outStat: OCC.wrapper.VrmlData.VrmlData_ErrorStatus
        :type theStat: OCC.wrapper.VrmlData.VrmlData_ErrorStatus
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _VrmlData.Handle_VrmlData_Sphere_OK(self, *args)


    def GlobalIndent(self, *args):
        """
        GlobalIndent(Handle_VrmlData_Sphere self) -> Standard_Integer

        Define the common Indent in spaces, for writing all nodes.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _VrmlData.Handle_VrmlData_Sphere_GlobalIndent(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_VrmlData_Sphere self)

        Memory deallocator for transient classes


        """
        return _VrmlData.Handle_VrmlData_Sphere_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_VrmlData_Sphere self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_VrmlData_Sphere self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _VrmlData.Handle_VrmlData_Sphere_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_VrmlData_Sphere self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_VrmlData_Sphere self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _VrmlData.Handle_VrmlData_Sphere_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_VrmlData_Sphere self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _VrmlData.Handle_VrmlData_Sphere_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_VrmlData_Sphere self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _VrmlData.Handle_VrmlData_Sphere_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_VrmlData_Sphere self)

        Increments the reference counter of this object


        """
        return _VrmlData.Handle_VrmlData_Sphere_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_VrmlData_Sphere self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _VrmlData.Handle_VrmlData_Sphere_DecrementRefCounter(self, *args)

Handle_VrmlData_Sphere_swigregister = _VrmlData.Handle_VrmlData_Sphere_swigregister
Handle_VrmlData_Sphere_swigregister(Handle_VrmlData_Sphere)

def Handle_VrmlData_Sphere_DownCast(thing):
    return _VrmlData.Handle_VrmlData_Sphere_DownCast(thing)
Handle_VrmlData_Sphere_DownCast = _VrmlData.Handle_VrmlData_Sphere_DownCast

class Handle_VrmlData_Group(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_VrmlData_Group self)

        Nullify the handle


        """
        return _VrmlData.Handle_VrmlData_Group_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_VrmlData_Group self) -> bool

        Check for being null

        :rtype: bool

        """
        return _VrmlData.Handle_VrmlData_Group_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_VrmlData_Group self, VrmlData_Group thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _VrmlData.Handle_VrmlData_Group_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_VrmlData_Group self, Handle_VrmlData_Group theHandle) -> Handle_VrmlData_Group
        assign(Handle_VrmlData_Group self, VrmlData_Group thePtr) -> Handle_VrmlData_Group
        assign(Handle_VrmlData_Group self, Handle_VrmlData_Group theHandle) -> Handle_VrmlData_Group

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _VrmlData.Handle_VrmlData_Group_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_VrmlData_Group self) -> VrmlData_Group

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _VrmlData.Handle_VrmlData_Group_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_VrmlData_Group self) -> VrmlData_Group

        Member access operator (note non-const)

        :rtype: T *

        """
        return _VrmlData.Handle_VrmlData_Group___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_VrmlData_Group self) -> VrmlData_Group

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _VrmlData.Handle_VrmlData_Group___ref__(self, *args)


    def __hash__(self):
        return _VrmlData.Handle_VrmlData_Group___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _VrmlData.Handle_VrmlData_Group___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _VrmlData.new_Handle_VrmlData_Group(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_VrmlData.Handle_VrmlData_Group_DownCast)
    __swig_destroy__ = _VrmlData.delete_Handle_VrmlData_Group

    def AddNode(self, *args):
        """
        AddNode(Handle_VrmlData_Group self, Handle_VrmlData_Node theNode) -> Handle_VrmlData_Node

        Add one node to the Group.

        :type theNode: OCC.wrapper.VrmlData.Handle_VrmlData_Node
        :rtype: OCC.wrapper.VrmlData.Handle_VrmlData_Node

        """
        return _VrmlData.Handle_VrmlData_Group_AddNode(self, *args)


    def RemoveNode(self, *args):
        """
        RemoveNode(Handle_VrmlData_Group self, Handle_VrmlData_Node theNode) -> Standard_Boolean

        Remove one node from the Group.
        @return
        True if the node was located and removed, False if none removed.

        :type theNode: OCC.wrapper.VrmlData.Handle_VrmlData_Node
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _VrmlData.Handle_VrmlData_Group_RemoveNode(self, *args)


    def Box(self, *args):
        """
        Query the bounding box.

        :rtype: OCC.wrapper.Bnd.Bnd_B3f

        """
        res = _VrmlData.Handle_VrmlData_Group_Box(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetBox(self, *args):
        """
        SetBox(Handle_VrmlData_Group self, Bnd_B3f theBox)

        Set the bounding box.

        :type theBox: OCC.wrapper.Bnd.Bnd_B3f

        """
        return _VrmlData.Handle_VrmlData_Group_SetBox(self, *args)


    def SetTransform(self, *args):
        """
        SetTransform(Handle_VrmlData_Group self, gp_Trsf theTrsf) -> Standard_Boolean

        Set the transformation. Returns True if the group is Transform type,
        otherwise do nothing and return False.

        :type theTrsf: OCC.wrapper.gp.gp_Trsf
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _VrmlData.Handle_VrmlData_Group_SetTransform(self, *args)


    def GetTransform(self, *args):
        """
        Query the transform value.
        For group without transformation this always returns Identity

        :rtype: OCC.wrapper.gp.gp_Trsf

        """
        res = _VrmlData.Handle_VrmlData_Group_GetTransform(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def IsTransform(self, *args):
        """
        IsTransform(Handle_VrmlData_Group self) -> Standard_Boolean

        Query if the node is Transform type.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _VrmlData.Handle_VrmlData_Group_IsTransform(self, *args)


    def Clone(self, *args):
        """
        Clone(Handle_VrmlData_Group self, Handle_VrmlData_Node theOther) -> Handle_VrmlData_Node

        Create a copy of this node.
        If the parameter is null, a new copied node is created. Otherwise new node
        is not created, but rather the given one is modified.

        :type theOther: OCC.wrapper.VrmlData.Handle_VrmlData_Node
        :rtype: OCC.wrapper.VrmlData.Handle_VrmlData_Node

        """
        return _VrmlData.Handle_VrmlData_Group_Clone(self, *args)


    def Read(self, *args):
        """
        Read(Handle_VrmlData_Group self, VrmlData_InBuffer & theBuffer) -> VrmlData_ErrorStatus

        Fill the Node internal data from the given input stream.

        :type theBuffer: OCC.wrapper.VrmlData.VrmlData_InBuffer
        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.Handle_VrmlData_Group_Read(self, *args)


    def Write(self, *args):
        """
        Write(Handle_VrmlData_Group self, char const * thePrefix) -> VrmlData_ErrorStatus

        Write the Node to output stream.

        :type thePrefix: const char *
        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.Handle_VrmlData_Group_Write(self, *args)


    def FindNode(self, *args):
        """
        FindNode(Handle_VrmlData_Group self, char const * theName, gp_Trsf theLocation) -> Handle_VrmlData_Node

        Find a node by its name, inside this Group
        @param theName
        Name of the node to search for.
        @param theLocation
        Location of the found node with respect to this Group.

        :type theName: const char *
        :type theLocation: OCC.wrapper.gp.gp_Trsf
        :rtype: OCC.wrapper.VrmlData.Handle_VrmlData_Node

        """
        return _VrmlData.Handle_VrmlData_Group_FindNode(self, *args)


    def Shape(self, *args):
        """
        Shape(Handle_VrmlData_Group self, TopoDS_Shape theShape, VrmlData_DataMapOfShapeAppearance * pMapApp)

        Get the shape representing the group geometry.

        :type theShape: OCC.wrapper.TopoDS.TopoDS_Shape
        :type pMapApp: OCC.wrapper.VrmlData.VrmlData_DataMapOfShapeAppearance

        """
        return _VrmlData.Handle_VrmlData_Group_Shape(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_VrmlData_Group self) -> char const *

        :rtype: const char *

        """
        return _VrmlData.Handle_VrmlData_Group_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _VrmlData.Handle_VrmlData_Group_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _VrmlData.Handle_VrmlData_Group_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def nodeIterator(self):
        return _VrmlData.Handle_VrmlData_Group_nodeIterator(self)

    def Scene(self, *args):
        """
        Query the Scene that contains this Node

        :rtype: OCC.wrapper.VrmlData.VrmlData_Scene

        """
        res = _VrmlData.Handle_VrmlData_Group_Scene(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Name(self, *args):
        """
        Name(Handle_VrmlData_Group self) -> char const *

        Query the name

        :rtype: const char *

        """
        return _VrmlData.Handle_VrmlData_Group_Name(self, *args)


    def ReadNode(self, *args):
        """
        ReadNode(Handle_VrmlData_Group self, VrmlData_InBuffer & theBuffer, Handle_VrmlData_Node theNode, Handle_Standard_Type Type=0) -> VrmlData_ErrorStatus

        Read a complete node definition from VRML stream
        @param theBuffer
        Buffer receiving the input data.
        @param theNode
        <tt>[out]</tt> Node restored from the buffer data
        @param Type
        Node type to be checked. If it is NULL(default) no type checking is done.
        Otherwise the created node is matched and an error is returned if
        no match detected.

        :type theBuffer: OCC.wrapper.VrmlData.VrmlData_InBuffer
        :type theNode: OCC.wrapper.VrmlData.Handle_VrmlData_Node
        :type Type: OCC.wrapper.Standard.Handle_Standard_Type
        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.Handle_VrmlData_Group_ReadNode(self, *args)


    def IsDefault(self, *args):
        """
        IsDefault(Handle_VrmlData_Group self) -> Standard_Boolean

        Returns True if the node is default, then it would not be written.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _VrmlData.Handle_VrmlData_Group_IsDefault(self, *args)


    def WriteClosing(self, *args):
        """
        WriteClosing(Handle_VrmlData_Group self) -> VrmlData_ErrorStatus

        Write the closing brace in the end of a node output.

        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.Handle_VrmlData_Group_WriteClosing(self, *args)


    def ReadBoolean(self, *args):
        """
        ReadBoolean(Handle_VrmlData_Group self, VrmlData_InBuffer & theBuffer) -> VrmlData_ErrorStatus

        Read one boolean value (TRUE or FALSE).

        :type theBuffer: OCC.wrapper.VrmlData.VrmlData_InBuffer
        :type theResult: bool
        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.Handle_VrmlData_Group_ReadBoolean(self, *args)


    def ReadString(self, *args):
        """
        ReadString(Handle_VrmlData_Group self, VrmlData_InBuffer & theBuffer, TCollection_AsciiString theRes) -> VrmlData_ErrorStatus

        Read one quoted string, the quotes are removed.

        :type theBuffer: OCC.wrapper.VrmlData.VrmlData_InBuffer
        :type theRes: OCC.wrapper.TCollection.TCollection_AsciiString
        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.Handle_VrmlData_Group_ReadString(self, *args)


    def ReadMultiString(self, *args):
        """
        ReadMultiString(Handle_VrmlData_Group self, VrmlData_InBuffer & theBuffer, NCollection_List_TCollection_AsciiString theRes) -> VrmlData_ErrorStatus

        Read one quoted string, the quotes are removed.

        :type theBuffer: OCC.wrapper.VrmlData.VrmlData_InBuffer
        :type theRes: OCC.wrapper.TColStd.NCollection_List_TCollection_AsciiString
        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.Handle_VrmlData_Group_ReadMultiString(self, *args)


    def ReadInteger(self, *args):
        """
        ReadInteger(Handle_VrmlData_Group self, VrmlData_InBuffer & theBuffer) -> VrmlData_ErrorStatus

        Read one integer value.

        :type theBuffer: OCC.wrapper.VrmlData.VrmlData_InBuffer
        :type theResult: long &
        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.Handle_VrmlData_Group_ReadInteger(self, *args)


    def OK(self, *args):
        """
        OK(Handle_VrmlData_Group self, VrmlData_ErrorStatus const theStat) -> Standard_Boolean
        OK(Handle_VrmlData_Group self, VrmlData_ErrorStatus const theStat) -> Standard_Boolean

        :type outStat: OCC.wrapper.VrmlData.VrmlData_ErrorStatus
        :type theStat: OCC.wrapper.VrmlData.VrmlData_ErrorStatus
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _VrmlData.Handle_VrmlData_Group_OK(self, *args)


    def GlobalIndent(self, *args):
        """
        GlobalIndent(Handle_VrmlData_Group self) -> Standard_Integer

        Define the common Indent in spaces, for writing all nodes.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _VrmlData.Handle_VrmlData_Group_GlobalIndent(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_VrmlData_Group self)

        Memory deallocator for transient classes


        """
        return _VrmlData.Handle_VrmlData_Group_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_VrmlData_Group self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_VrmlData_Group self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _VrmlData.Handle_VrmlData_Group_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_VrmlData_Group self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_VrmlData_Group self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _VrmlData.Handle_VrmlData_Group_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_VrmlData_Group self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _VrmlData.Handle_VrmlData_Group_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_VrmlData_Group self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _VrmlData.Handle_VrmlData_Group_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_VrmlData_Group self)

        Increments the reference counter of this object


        """
        return _VrmlData.Handle_VrmlData_Group_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_VrmlData_Group self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _VrmlData.Handle_VrmlData_Group_DecrementRefCounter(self, *args)

Handle_VrmlData_Group_swigregister = _VrmlData.Handle_VrmlData_Group_swigregister
Handle_VrmlData_Group_swigregister(Handle_VrmlData_Group)

def Handle_VrmlData_Group_DownCast(thing):
    return _VrmlData.Handle_VrmlData_Group_DownCast(thing)
Handle_VrmlData_Group_DownCast = _VrmlData.Handle_VrmlData_Group_DownCast

class Handle_VrmlData_Cylinder(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_VrmlData_Cylinder self)

        Nullify the handle


        """
        return _VrmlData.Handle_VrmlData_Cylinder_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_VrmlData_Cylinder self) -> bool

        Check for being null

        :rtype: bool

        """
        return _VrmlData.Handle_VrmlData_Cylinder_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_VrmlData_Cylinder self, VrmlData_Cylinder thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _VrmlData.Handle_VrmlData_Cylinder_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_VrmlData_Cylinder self, Handle_VrmlData_Cylinder theHandle) -> Handle_VrmlData_Cylinder
        assign(Handle_VrmlData_Cylinder self, VrmlData_Cylinder thePtr) -> Handle_VrmlData_Cylinder
        assign(Handle_VrmlData_Cylinder self, Handle_VrmlData_Cylinder theHandle) -> Handle_VrmlData_Cylinder

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _VrmlData.Handle_VrmlData_Cylinder_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_VrmlData_Cylinder self) -> VrmlData_Cylinder

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _VrmlData.Handle_VrmlData_Cylinder_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_VrmlData_Cylinder self) -> VrmlData_Cylinder

        Member access operator (note non-const)

        :rtype: T *

        """
        return _VrmlData.Handle_VrmlData_Cylinder___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_VrmlData_Cylinder self) -> VrmlData_Cylinder

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _VrmlData.Handle_VrmlData_Cylinder___ref__(self, *args)


    def __hash__(self):
        return _VrmlData.Handle_VrmlData_Cylinder___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _VrmlData.Handle_VrmlData_Cylinder___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _VrmlData.new_Handle_VrmlData_Cylinder(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_VrmlData.Handle_VrmlData_Cylinder_DownCast)
    __swig_destroy__ = _VrmlData.delete_Handle_VrmlData_Cylinder

    def Radius(self, *args):
        """
        Radius(Handle_VrmlData_Cylinder self) -> Standard_Real

        Query the Radius

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _VrmlData.Handle_VrmlData_Cylinder_Radius(self, *args)


    def Height(self, *args):
        """
        Height(Handle_VrmlData_Cylinder self) -> Standard_Real

        Query the Height

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _VrmlData.Handle_VrmlData_Cylinder_Height(self, *args)


    def HasBottom(self, *args):
        """
        HasBottom(Handle_VrmlData_Cylinder self) -> Standard_Boolean

        Query if the bottom circle is included

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _VrmlData.Handle_VrmlData_Cylinder_HasBottom(self, *args)


    def HasSide(self, *args):
        """
        HasSide(Handle_VrmlData_Cylinder self) -> Standard_Boolean

        Query if the side surface is included

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _VrmlData.Handle_VrmlData_Cylinder_HasSide(self, *args)


    def HasTop(self, *args):
        """
        HasTop(Handle_VrmlData_Cylinder self) -> Standard_Boolean

        Query if the top surface is included

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _VrmlData.Handle_VrmlData_Cylinder_HasTop(self, *args)


    def SetRadius(self, *args):
        """
        SetRadius(Handle_VrmlData_Cylinder self, Standard_Real const theRadius)

        Set the Radius

        :type theRadius: float

        """
        return _VrmlData.Handle_VrmlData_Cylinder_SetRadius(self, *args)


    def SetHeight(self, *args):
        """
        SetHeight(Handle_VrmlData_Cylinder self, Standard_Real const theHeight)

        Set the Height

        :type theHeight: float

        """
        return _VrmlData.Handle_VrmlData_Cylinder_SetHeight(self, *args)


    def SetFaces(self, *args):
        """
        SetFaces(Handle_VrmlData_Cylinder self, Standard_Boolean const hasBottom, Standard_Boolean const hasSide, Standard_Boolean const hasTop)

        Set which faces are included

        :type hasBottom: bool
        :type hasSide: bool
        :type hasTop: bool

        """
        return _VrmlData.Handle_VrmlData_Cylinder_SetFaces(self, *args)


    def TShape(self, *args):
        """
        Query the primitive topology. This method returns a Null shape if there
        is an internal error during the primitive creation (zero radius, etc.)

        :rtype: OCC.wrapper.TopoDS.Handle_TopoDS_TShape

        """
        res = _VrmlData.Handle_VrmlData_Cylinder_TShape(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Clone(self, *args):
        """
        Clone(Handle_VrmlData_Cylinder self, Handle_VrmlData_Node theOther) -> Handle_VrmlData_Node

        Create a copy of this node.
        If the parameter is null, a new copied node is created. Otherwise new node
        is not created, but rather the given one is modified.

        :type theOther: OCC.wrapper.VrmlData.Handle_VrmlData_Node
        :rtype: OCC.wrapper.VrmlData.Handle_VrmlData_Node

        """
        return _VrmlData.Handle_VrmlData_Cylinder_Clone(self, *args)


    def Read(self, *args):
        """
        Read(Handle_VrmlData_Cylinder self, VrmlData_InBuffer & theBuffer) -> VrmlData_ErrorStatus

        Fill the Node internal data from the given input stream.

        :type theBuffer: OCC.wrapper.VrmlData.VrmlData_InBuffer
        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.Handle_VrmlData_Cylinder_Read(self, *args)


    def Write(self, *args):
        """
        Write(Handle_VrmlData_Cylinder self, char const * thePrefix) -> VrmlData_ErrorStatus

        Write the Node to output stream.

        :type thePrefix: const char *
        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.Handle_VrmlData_Cylinder_Write(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_VrmlData_Cylinder self) -> char const *

        :rtype: const char *

        """
        return _VrmlData.Handle_VrmlData_Cylinder_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _VrmlData.Handle_VrmlData_Cylinder_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _VrmlData.Handle_VrmlData_Cylinder_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Scene(self, *args):
        """
        Query the Scene that contains this Node

        :rtype: OCC.wrapper.VrmlData.VrmlData_Scene

        """
        res = _VrmlData.Handle_VrmlData_Cylinder_Scene(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Name(self, *args):
        """
        Name(Handle_VrmlData_Cylinder self) -> char const *

        Query the name

        :rtype: const char *

        """
        return _VrmlData.Handle_VrmlData_Cylinder_Name(self, *args)


    def ReadNode(self, *args):
        """
        ReadNode(Handle_VrmlData_Cylinder self, VrmlData_InBuffer & theBuffer, Handle_VrmlData_Node theNode, Handle_Standard_Type Type=0) -> VrmlData_ErrorStatus

        Read a complete node definition from VRML stream
        @param theBuffer
        Buffer receiving the input data.
        @param theNode
        <tt>[out]</tt> Node restored from the buffer data
        @param Type
        Node type to be checked. If it is NULL(default) no type checking is done.
        Otherwise the created node is matched and an error is returned if
        no match detected.

        :type theBuffer: OCC.wrapper.VrmlData.VrmlData_InBuffer
        :type theNode: OCC.wrapper.VrmlData.Handle_VrmlData_Node
        :type Type: OCC.wrapper.Standard.Handle_Standard_Type
        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.Handle_VrmlData_Cylinder_ReadNode(self, *args)


    def IsDefault(self, *args):
        """
        IsDefault(Handle_VrmlData_Cylinder self) -> Standard_Boolean

        Returns True if the node is default, then it would not be written.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _VrmlData.Handle_VrmlData_Cylinder_IsDefault(self, *args)


    def WriteClosing(self, *args):
        """
        WriteClosing(Handle_VrmlData_Cylinder self) -> VrmlData_ErrorStatus

        Write the closing brace in the end of a node output.

        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.Handle_VrmlData_Cylinder_WriteClosing(self, *args)


    def ReadBoolean(self, *args):
        """
        ReadBoolean(Handle_VrmlData_Cylinder self, VrmlData_InBuffer & theBuffer) -> VrmlData_ErrorStatus

        Read one boolean value (TRUE or FALSE).

        :type theBuffer: OCC.wrapper.VrmlData.VrmlData_InBuffer
        :type theResult: bool
        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.Handle_VrmlData_Cylinder_ReadBoolean(self, *args)


    def ReadString(self, *args):
        """
        ReadString(Handle_VrmlData_Cylinder self, VrmlData_InBuffer & theBuffer, TCollection_AsciiString theRes) -> VrmlData_ErrorStatus

        Read one quoted string, the quotes are removed.

        :type theBuffer: OCC.wrapper.VrmlData.VrmlData_InBuffer
        :type theRes: OCC.wrapper.TCollection.TCollection_AsciiString
        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.Handle_VrmlData_Cylinder_ReadString(self, *args)


    def ReadMultiString(self, *args):
        """
        ReadMultiString(Handle_VrmlData_Cylinder self, VrmlData_InBuffer & theBuffer, NCollection_List_TCollection_AsciiString theRes) -> VrmlData_ErrorStatus

        Read one quoted string, the quotes are removed.

        :type theBuffer: OCC.wrapper.VrmlData.VrmlData_InBuffer
        :type theRes: OCC.wrapper.TColStd.NCollection_List_TCollection_AsciiString
        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.Handle_VrmlData_Cylinder_ReadMultiString(self, *args)


    def ReadInteger(self, *args):
        """
        ReadInteger(Handle_VrmlData_Cylinder self, VrmlData_InBuffer & theBuffer) -> VrmlData_ErrorStatus

        Read one integer value.

        :type theBuffer: OCC.wrapper.VrmlData.VrmlData_InBuffer
        :type theResult: long &
        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.Handle_VrmlData_Cylinder_ReadInteger(self, *args)


    def OK(self, *args):
        """
        OK(Handle_VrmlData_Cylinder self, VrmlData_ErrorStatus const theStat) -> Standard_Boolean
        OK(Handle_VrmlData_Cylinder self, VrmlData_ErrorStatus const theStat) -> Standard_Boolean

        :type outStat: OCC.wrapper.VrmlData.VrmlData_ErrorStatus
        :type theStat: OCC.wrapper.VrmlData.VrmlData_ErrorStatus
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _VrmlData.Handle_VrmlData_Cylinder_OK(self, *args)


    def GlobalIndent(self, *args):
        """
        GlobalIndent(Handle_VrmlData_Cylinder self) -> Standard_Integer

        Define the common Indent in spaces, for writing all nodes.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _VrmlData.Handle_VrmlData_Cylinder_GlobalIndent(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_VrmlData_Cylinder self)

        Memory deallocator for transient classes


        """
        return _VrmlData.Handle_VrmlData_Cylinder_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_VrmlData_Cylinder self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_VrmlData_Cylinder self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _VrmlData.Handle_VrmlData_Cylinder_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_VrmlData_Cylinder self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_VrmlData_Cylinder self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _VrmlData.Handle_VrmlData_Cylinder_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_VrmlData_Cylinder self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _VrmlData.Handle_VrmlData_Cylinder_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_VrmlData_Cylinder self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _VrmlData.Handle_VrmlData_Cylinder_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_VrmlData_Cylinder self)

        Increments the reference counter of this object


        """
        return _VrmlData.Handle_VrmlData_Cylinder_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_VrmlData_Cylinder self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _VrmlData.Handle_VrmlData_Cylinder_DecrementRefCounter(self, *args)

Handle_VrmlData_Cylinder_swigregister = _VrmlData.Handle_VrmlData_Cylinder_swigregister
Handle_VrmlData_Cylinder_swigregister(Handle_VrmlData_Cylinder)

def Handle_VrmlData_Cylinder_DownCast(thing):
    return _VrmlData.Handle_VrmlData_Cylinder_DownCast(thing)
Handle_VrmlData_Cylinder_DownCast = _VrmlData.Handle_VrmlData_Cylinder_DownCast

class Handle_VrmlData_Texture(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_VrmlData_Texture self)

        Nullify the handle


        """
        return _VrmlData.Handle_VrmlData_Texture_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_VrmlData_Texture self) -> bool

        Check for being null

        :rtype: bool

        """
        return _VrmlData.Handle_VrmlData_Texture_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_VrmlData_Texture self, VrmlData_Texture thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _VrmlData.Handle_VrmlData_Texture_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_VrmlData_Texture self, Handle_VrmlData_Texture theHandle) -> Handle_VrmlData_Texture
        assign(Handle_VrmlData_Texture self, VrmlData_Texture thePtr) -> Handle_VrmlData_Texture
        assign(Handle_VrmlData_Texture self, Handle_VrmlData_Texture theHandle) -> Handle_VrmlData_Texture

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _VrmlData.Handle_VrmlData_Texture_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_VrmlData_Texture self) -> VrmlData_Texture

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _VrmlData.Handle_VrmlData_Texture_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_VrmlData_Texture self) -> VrmlData_Texture

        Member access operator (note non-const)

        :rtype: T *

        """
        return _VrmlData.Handle_VrmlData_Texture___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_VrmlData_Texture self) -> VrmlData_Texture

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _VrmlData.Handle_VrmlData_Texture___ref__(self, *args)


    def __hash__(self):
        return _VrmlData.Handle_VrmlData_Texture___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _VrmlData.Handle_VrmlData_Texture___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _VrmlData.new_Handle_VrmlData_Texture(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_VrmlData.Handle_VrmlData_Texture_DownCast)
    __swig_destroy__ = _VrmlData.delete_Handle_VrmlData_Texture

    def RepeatS(self, *args):
        """
        RepeatS(Handle_VrmlData_Texture self) -> Standard_Boolean

        Query the RepeatS value

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _VrmlData.Handle_VrmlData_Texture_RepeatS(self, *args)


    def RepeatT(self, *args):
        """
        RepeatT(Handle_VrmlData_Texture self) -> Standard_Boolean

        Query the RepeatT value

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _VrmlData.Handle_VrmlData_Texture_RepeatT(self, *args)


    def SetRepeatS(self, *args):
        """
        SetRepeatS(Handle_VrmlData_Texture self, Standard_Boolean const theFlag)

        Set the RepeatS flag

        :type theFlag: bool

        """
        return _VrmlData.Handle_VrmlData_Texture_SetRepeatS(self, *args)


    def SetRepeatT(self, *args):
        """
        SetRepeatT(Handle_VrmlData_Texture self, Standard_Boolean const theFlag)

        Set the RepeatT flag

        :type theFlag: bool

        """
        return _VrmlData.Handle_VrmlData_Texture_SetRepeatT(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_VrmlData_Texture self) -> char const *

        :rtype: const char *

        """
        return _VrmlData.Handle_VrmlData_Texture_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _VrmlData.Handle_VrmlData_Texture_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _VrmlData.Handle_VrmlData_Texture_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Scene(self, *args):
        """
        Query the Scene that contains this Node

        :rtype: OCC.wrapper.VrmlData.VrmlData_Scene

        """
        res = _VrmlData.Handle_VrmlData_Texture_Scene(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Name(self, *args):
        """
        Name(Handle_VrmlData_Texture self) -> char const *

        Query the name

        :rtype: const char *

        """
        return _VrmlData.Handle_VrmlData_Texture_Name(self, *args)


    def ReadNode(self, *args):
        """
        ReadNode(Handle_VrmlData_Texture self, VrmlData_InBuffer & theBuffer, Handle_VrmlData_Node theNode, Handle_Standard_Type Type=0) -> VrmlData_ErrorStatus

        Read a complete node definition from VRML stream
        @param theBuffer
        Buffer receiving the input data.
        @param theNode
        <tt>[out]</tt> Node restored from the buffer data
        @param Type
        Node type to be checked. If it is NULL(default) no type checking is done.
        Otherwise the created node is matched and an error is returned if
        no match detected.

        :type theBuffer: OCC.wrapper.VrmlData.VrmlData_InBuffer
        :type theNode: OCC.wrapper.VrmlData.Handle_VrmlData_Node
        :type Type: OCC.wrapper.Standard.Handle_Standard_Type
        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.Handle_VrmlData_Texture_ReadNode(self, *args)


    def Read(self, *args):
        """
        Read(Handle_VrmlData_Texture self, VrmlData_InBuffer & theBuffer) -> VrmlData_ErrorStatus

        Read the Node from input stream.

        :type theBuffer: OCC.wrapper.VrmlData.VrmlData_InBuffer
        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.Handle_VrmlData_Texture_Read(self, *args)


    def Write(self, *args):
        """
        Write(Handle_VrmlData_Texture self, char const * thePrefix) -> VrmlData_ErrorStatus

        Write the Node to output stream.

        :type thePrefix: const char *
        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.Handle_VrmlData_Texture_Write(self, *args)


    def IsDefault(self, *args):
        """
        IsDefault(Handle_VrmlData_Texture self) -> Standard_Boolean

        Returns True if the node is default, then it would not be written.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _VrmlData.Handle_VrmlData_Texture_IsDefault(self, *args)


    def WriteClosing(self, *args):
        """
        WriteClosing(Handle_VrmlData_Texture self) -> VrmlData_ErrorStatus

        Write the closing brace in the end of a node output.

        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.Handle_VrmlData_Texture_WriteClosing(self, *args)


    def Clone(self, *args):
        """
        Clone(Handle_VrmlData_Texture self, Handle_VrmlData_Node arg2) -> Handle_VrmlData_Node

        Create a copy of this node.
        If the parameter is null, a new copied node is created. Otherwise new node
        is not created, but rather the given one is modified.<p>
        This method nullifies the argument node if its member myScene differs
        from that one of the current instance.

        :type : OCC.wrapper.VrmlData.Handle_VrmlData_Node
        :rtype: OCC.wrapper.VrmlData.Handle_VrmlData_Node

        """
        return _VrmlData.Handle_VrmlData_Texture_Clone(self, *args)


    def ReadBoolean(self, *args):
        """
        ReadBoolean(Handle_VrmlData_Texture self, VrmlData_InBuffer & theBuffer) -> VrmlData_ErrorStatus

        Read one boolean value (TRUE or FALSE).

        :type theBuffer: OCC.wrapper.VrmlData.VrmlData_InBuffer
        :type theResult: bool
        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.Handle_VrmlData_Texture_ReadBoolean(self, *args)


    def ReadString(self, *args):
        """
        ReadString(Handle_VrmlData_Texture self, VrmlData_InBuffer & theBuffer, TCollection_AsciiString theRes) -> VrmlData_ErrorStatus

        Read one quoted string, the quotes are removed.

        :type theBuffer: OCC.wrapper.VrmlData.VrmlData_InBuffer
        :type theRes: OCC.wrapper.TCollection.TCollection_AsciiString
        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.Handle_VrmlData_Texture_ReadString(self, *args)


    def ReadMultiString(self, *args):
        """
        ReadMultiString(Handle_VrmlData_Texture self, VrmlData_InBuffer & theBuffer, NCollection_List_TCollection_AsciiString theRes) -> VrmlData_ErrorStatus

        Read one quoted string, the quotes are removed.

        :type theBuffer: OCC.wrapper.VrmlData.VrmlData_InBuffer
        :type theRes: OCC.wrapper.TColStd.NCollection_List_TCollection_AsciiString
        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.Handle_VrmlData_Texture_ReadMultiString(self, *args)


    def ReadInteger(self, *args):
        """
        ReadInteger(Handle_VrmlData_Texture self, VrmlData_InBuffer & theBuffer) -> VrmlData_ErrorStatus

        Read one integer value.

        :type theBuffer: OCC.wrapper.VrmlData.VrmlData_InBuffer
        :type theResult: long &
        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.Handle_VrmlData_Texture_ReadInteger(self, *args)


    def OK(self, *args):
        """
        OK(Handle_VrmlData_Texture self, VrmlData_ErrorStatus const theStat) -> Standard_Boolean
        OK(Handle_VrmlData_Texture self, VrmlData_ErrorStatus const theStat) -> Standard_Boolean

        :type outStat: OCC.wrapper.VrmlData.VrmlData_ErrorStatus
        :type theStat: OCC.wrapper.VrmlData.VrmlData_ErrorStatus
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _VrmlData.Handle_VrmlData_Texture_OK(self, *args)


    def GlobalIndent(self, *args):
        """
        GlobalIndent(Handle_VrmlData_Texture self) -> Standard_Integer

        Define the common Indent in spaces, for writing all nodes.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _VrmlData.Handle_VrmlData_Texture_GlobalIndent(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_VrmlData_Texture self)

        Memory deallocator for transient classes


        """
        return _VrmlData.Handle_VrmlData_Texture_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_VrmlData_Texture self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_VrmlData_Texture self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _VrmlData.Handle_VrmlData_Texture_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_VrmlData_Texture self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_VrmlData_Texture self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _VrmlData.Handle_VrmlData_Texture_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_VrmlData_Texture self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _VrmlData.Handle_VrmlData_Texture_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_VrmlData_Texture self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _VrmlData.Handle_VrmlData_Texture_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_VrmlData_Texture self)

        Increments the reference counter of this object


        """
        return _VrmlData.Handle_VrmlData_Texture_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_VrmlData_Texture self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _VrmlData.Handle_VrmlData_Texture_DecrementRefCounter(self, *args)

Handle_VrmlData_Texture_swigregister = _VrmlData.Handle_VrmlData_Texture_swigregister
Handle_VrmlData_Texture_swigregister(Handle_VrmlData_Texture)

def Handle_VrmlData_Texture_DownCast(thing):
    return _VrmlData.Handle_VrmlData_Texture_DownCast(thing)
Handle_VrmlData_Texture_DownCast = _VrmlData.Handle_VrmlData_Texture_DownCast

class Handle_VrmlData_Faceted(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_VrmlData_Faceted self)

        Nullify the handle


        """
        return _VrmlData.Handle_VrmlData_Faceted_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_VrmlData_Faceted self) -> bool

        Check for being null

        :rtype: bool

        """
        return _VrmlData.Handle_VrmlData_Faceted_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_VrmlData_Faceted self, VrmlData_Faceted thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _VrmlData.Handle_VrmlData_Faceted_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_VrmlData_Faceted self, Handle_VrmlData_Faceted theHandle) -> Handle_VrmlData_Faceted
        assign(Handle_VrmlData_Faceted self, VrmlData_Faceted thePtr) -> Handle_VrmlData_Faceted
        assign(Handle_VrmlData_Faceted self, Handle_VrmlData_Faceted theHandle) -> Handle_VrmlData_Faceted

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _VrmlData.Handle_VrmlData_Faceted_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_VrmlData_Faceted self) -> VrmlData_Faceted

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _VrmlData.Handle_VrmlData_Faceted_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_VrmlData_Faceted self) -> VrmlData_Faceted

        Member access operator (note non-const)

        :rtype: T *

        """
        return _VrmlData.Handle_VrmlData_Faceted___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_VrmlData_Faceted self) -> VrmlData_Faceted

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _VrmlData.Handle_VrmlData_Faceted___ref__(self, *args)


    def __hash__(self):
        return _VrmlData.Handle_VrmlData_Faceted___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _VrmlData.Handle_VrmlData_Faceted___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _VrmlData.new_Handle_VrmlData_Faceted(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_VrmlData.Handle_VrmlData_Faceted_DownCast)
    __swig_destroy__ = _VrmlData.delete_Handle_VrmlData_Faceted

    def IsCCW(self, *args):
        """
        IsCCW(Handle_VrmlData_Faceted self) -> Standard_Boolean

        Query "Is Counter-Clockwise" attribute

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _VrmlData.Handle_VrmlData_Faceted_IsCCW(self, *args)


    def IsSolid(self, *args):
        """
        IsSolid(Handle_VrmlData_Faceted self) -> Standard_Boolean

        Query "Is Solid" attribute

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _VrmlData.Handle_VrmlData_Faceted_IsSolid(self, *args)


    def IsConvex(self, *args):
        """
        IsConvex(Handle_VrmlData_Faceted self) -> Standard_Boolean

        Query "Is Convex" attribute

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _VrmlData.Handle_VrmlData_Faceted_IsConvex(self, *args)


    def CreaseAngle(self, *args):
        """
        CreaseAngle(Handle_VrmlData_Faceted self) -> Standard_Real

        Query the Crease Angle

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _VrmlData.Handle_VrmlData_Faceted_CreaseAngle(self, *args)


    def SetCCW(self, *args):
        """
        SetCCW(Handle_VrmlData_Faceted self, Standard_Boolean const theValue)

        Set "Is Counter-Clockwise" attribute

        :type theValue: bool

        """
        return _VrmlData.Handle_VrmlData_Faceted_SetCCW(self, *args)


    def SetSolid(self, *args):
        """
        SetSolid(Handle_VrmlData_Faceted self, Standard_Boolean const theValue)

        Set "Is Solid" attribute

        :type theValue: bool

        """
        return _VrmlData.Handle_VrmlData_Faceted_SetSolid(self, *args)


    def SetConvex(self, *args):
        """
        SetConvex(Handle_VrmlData_Faceted self, Standard_Boolean const theValue)

        Set "Is Convex" attribute

        :type theValue: bool

        """
        return _VrmlData.Handle_VrmlData_Faceted_SetConvex(self, *args)


    def SetCreaseAngle(self, *args):
        """
        SetCreaseAngle(Handle_VrmlData_Faceted self, Standard_Real const theValue)

        Set "Is Convex" attribute

        :type theValue: float

        """
        return _VrmlData.Handle_VrmlData_Faceted_SetCreaseAngle(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_VrmlData_Faceted self) -> char const *

        :rtype: const char *

        """
        return _VrmlData.Handle_VrmlData_Faceted_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _VrmlData.Handle_VrmlData_Faceted_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _VrmlData.Handle_VrmlData_Faceted_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def TShape(self, *args):
        """
        Query the shape. This method checks the flag myIsModified; if True it
        should rebuild the shape presentation.

        :rtype: OCC.wrapper.TopoDS.Handle_TopoDS_TShape

        """
        res = _VrmlData.Handle_VrmlData_Faceted_TShape(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Scene(self, *args):
        """
        Query the Scene that contains this Node

        :rtype: OCC.wrapper.VrmlData.VrmlData_Scene

        """
        res = _VrmlData.Handle_VrmlData_Faceted_Scene(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Name(self, *args):
        """
        Name(Handle_VrmlData_Faceted self) -> char const *

        Query the name

        :rtype: const char *

        """
        return _VrmlData.Handle_VrmlData_Faceted_Name(self, *args)


    def ReadNode(self, *args):
        """
        ReadNode(Handle_VrmlData_Faceted self, VrmlData_InBuffer & theBuffer, Handle_VrmlData_Node theNode, Handle_Standard_Type Type=0) -> VrmlData_ErrorStatus

        Read a complete node definition from VRML stream
        @param theBuffer
        Buffer receiving the input data.
        @param theNode
        <tt>[out]</tt> Node restored from the buffer data
        @param Type
        Node type to be checked. If it is NULL(default) no type checking is done.
        Otherwise the created node is matched and an error is returned if
        no match detected.

        :type theBuffer: OCC.wrapper.VrmlData.VrmlData_InBuffer
        :type theNode: OCC.wrapper.VrmlData.Handle_VrmlData_Node
        :type Type: OCC.wrapper.Standard.Handle_Standard_Type
        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.Handle_VrmlData_Faceted_ReadNode(self, *args)


    def Read(self, *args):
        """
        Read(Handle_VrmlData_Faceted self, VrmlData_InBuffer & theBuffer) -> VrmlData_ErrorStatus

        Read the Node from input stream.

        :type theBuffer: OCC.wrapper.VrmlData.VrmlData_InBuffer
        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.Handle_VrmlData_Faceted_Read(self, *args)


    def Write(self, *args):
        """
        Write(Handle_VrmlData_Faceted self, char const * thePrefix) -> VrmlData_ErrorStatus

        Write the Node to output stream.

        :type thePrefix: const char *
        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.Handle_VrmlData_Faceted_Write(self, *args)


    def IsDefault(self, *args):
        """
        IsDefault(Handle_VrmlData_Faceted self) -> Standard_Boolean

        Returns True if the node is default, then it would not be written.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _VrmlData.Handle_VrmlData_Faceted_IsDefault(self, *args)


    def WriteClosing(self, *args):
        """
        WriteClosing(Handle_VrmlData_Faceted self) -> VrmlData_ErrorStatus

        Write the closing brace in the end of a node output.

        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.Handle_VrmlData_Faceted_WriteClosing(self, *args)


    def Clone(self, *args):
        """
        Clone(Handle_VrmlData_Faceted self, Handle_VrmlData_Node arg2) -> Handle_VrmlData_Node

        Create a copy of this node.
        If the parameter is null, a new copied node is created. Otherwise new node
        is not created, but rather the given one is modified.<p>
        This method nullifies the argument node if its member myScene differs
        from that one of the current instance.

        :type : OCC.wrapper.VrmlData.Handle_VrmlData_Node
        :rtype: OCC.wrapper.VrmlData.Handle_VrmlData_Node

        """
        return _VrmlData.Handle_VrmlData_Faceted_Clone(self, *args)


    def ReadBoolean(self, *args):
        """
        ReadBoolean(Handle_VrmlData_Faceted self, VrmlData_InBuffer & theBuffer) -> VrmlData_ErrorStatus

        Read one boolean value (TRUE or FALSE).

        :type theBuffer: OCC.wrapper.VrmlData.VrmlData_InBuffer
        :type theResult: bool
        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.Handle_VrmlData_Faceted_ReadBoolean(self, *args)


    def ReadString(self, *args):
        """
        ReadString(Handle_VrmlData_Faceted self, VrmlData_InBuffer & theBuffer, TCollection_AsciiString theRes) -> VrmlData_ErrorStatus

        Read one quoted string, the quotes are removed.

        :type theBuffer: OCC.wrapper.VrmlData.VrmlData_InBuffer
        :type theRes: OCC.wrapper.TCollection.TCollection_AsciiString
        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.Handle_VrmlData_Faceted_ReadString(self, *args)


    def ReadMultiString(self, *args):
        """
        ReadMultiString(Handle_VrmlData_Faceted self, VrmlData_InBuffer & theBuffer, NCollection_List_TCollection_AsciiString theRes) -> VrmlData_ErrorStatus

        Read one quoted string, the quotes are removed.

        :type theBuffer: OCC.wrapper.VrmlData.VrmlData_InBuffer
        :type theRes: OCC.wrapper.TColStd.NCollection_List_TCollection_AsciiString
        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.Handle_VrmlData_Faceted_ReadMultiString(self, *args)


    def ReadInteger(self, *args):
        """
        ReadInteger(Handle_VrmlData_Faceted self, VrmlData_InBuffer & theBuffer) -> VrmlData_ErrorStatus

        Read one integer value.

        :type theBuffer: OCC.wrapper.VrmlData.VrmlData_InBuffer
        :type theResult: long &
        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.Handle_VrmlData_Faceted_ReadInteger(self, *args)


    def OK(self, *args):
        """
        OK(Handle_VrmlData_Faceted self, VrmlData_ErrorStatus const theStat) -> Standard_Boolean
        OK(Handle_VrmlData_Faceted self, VrmlData_ErrorStatus const theStat) -> Standard_Boolean

        :type outStat: OCC.wrapper.VrmlData.VrmlData_ErrorStatus
        :type theStat: OCC.wrapper.VrmlData.VrmlData_ErrorStatus
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _VrmlData.Handle_VrmlData_Faceted_OK(self, *args)


    def GlobalIndent(self, *args):
        """
        GlobalIndent(Handle_VrmlData_Faceted self) -> Standard_Integer

        Define the common Indent in spaces, for writing all nodes.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _VrmlData.Handle_VrmlData_Faceted_GlobalIndent(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_VrmlData_Faceted self)

        Memory deallocator for transient classes


        """
        return _VrmlData.Handle_VrmlData_Faceted_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_VrmlData_Faceted self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_VrmlData_Faceted self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _VrmlData.Handle_VrmlData_Faceted_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_VrmlData_Faceted self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_VrmlData_Faceted self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _VrmlData.Handle_VrmlData_Faceted_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_VrmlData_Faceted self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _VrmlData.Handle_VrmlData_Faceted_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_VrmlData_Faceted self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _VrmlData.Handle_VrmlData_Faceted_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_VrmlData_Faceted self)

        Increments the reference counter of this object


        """
        return _VrmlData.Handle_VrmlData_Faceted_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_VrmlData_Faceted self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _VrmlData.Handle_VrmlData_Faceted_DecrementRefCounter(self, *args)

Handle_VrmlData_Faceted_swigregister = _VrmlData.Handle_VrmlData_Faceted_swigregister
Handle_VrmlData_Faceted_swigregister(Handle_VrmlData_Faceted)

def Handle_VrmlData_Faceted_DownCast(thing):
    return _VrmlData.Handle_VrmlData_Faceted_DownCast(thing)
Handle_VrmlData_Faceted_DownCast = _VrmlData.Handle_VrmlData_Faceted_DownCast

class Handle_VrmlData_Cone(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_VrmlData_Cone self)

        Nullify the handle


        """
        return _VrmlData.Handle_VrmlData_Cone_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_VrmlData_Cone self) -> bool

        Check for being null

        :rtype: bool

        """
        return _VrmlData.Handle_VrmlData_Cone_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_VrmlData_Cone self, VrmlData_Cone thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _VrmlData.Handle_VrmlData_Cone_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_VrmlData_Cone self, Handle_VrmlData_Cone theHandle) -> Handle_VrmlData_Cone
        assign(Handle_VrmlData_Cone self, VrmlData_Cone thePtr) -> Handle_VrmlData_Cone
        assign(Handle_VrmlData_Cone self, Handle_VrmlData_Cone theHandle) -> Handle_VrmlData_Cone

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _VrmlData.Handle_VrmlData_Cone_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_VrmlData_Cone self) -> VrmlData_Cone

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _VrmlData.Handle_VrmlData_Cone_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_VrmlData_Cone self) -> VrmlData_Cone

        Member access operator (note non-const)

        :rtype: T *

        """
        return _VrmlData.Handle_VrmlData_Cone___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_VrmlData_Cone self) -> VrmlData_Cone

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _VrmlData.Handle_VrmlData_Cone___ref__(self, *args)


    def __hash__(self):
        return _VrmlData.Handle_VrmlData_Cone___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _VrmlData.Handle_VrmlData_Cone___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _VrmlData.new_Handle_VrmlData_Cone(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_VrmlData.Handle_VrmlData_Cone_DownCast)
    __swig_destroy__ = _VrmlData.delete_Handle_VrmlData_Cone

    def BottomRadius(self, *args):
        """
        BottomRadius(Handle_VrmlData_Cone self) -> Standard_Real

        Query the Bottom Radius

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _VrmlData.Handle_VrmlData_Cone_BottomRadius(self, *args)


    def Height(self, *args):
        """
        Height(Handle_VrmlData_Cone self) -> Standard_Real

        Query the Height

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _VrmlData.Handle_VrmlData_Cone_Height(self, *args)


    def HasBottom(self, *args):
        """
        HasBottom(Handle_VrmlData_Cone self) -> Standard_Boolean

        Query if the bottom circle is included

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _VrmlData.Handle_VrmlData_Cone_HasBottom(self, *args)


    def HasSide(self, *args):
        """
        HasSide(Handle_VrmlData_Cone self) -> Standard_Boolean

        Query if the side surface is included

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _VrmlData.Handle_VrmlData_Cone_HasSide(self, *args)


    def SetBottomRadius(self, *args):
        """
        SetBottomRadius(Handle_VrmlData_Cone self, Standard_Real const theRadius)

        Set the Bottom Radius

        :type theRadius: float

        """
        return _VrmlData.Handle_VrmlData_Cone_SetBottomRadius(self, *args)


    def SetHeight(self, *args):
        """
        SetHeight(Handle_VrmlData_Cone self, Standard_Real const theHeight)

        Set the Height

        :type theHeight: float

        """
        return _VrmlData.Handle_VrmlData_Cone_SetHeight(self, *args)


    def SetFaces(self, *args):
        """
        SetFaces(Handle_VrmlData_Cone self, Standard_Boolean const hasBottom, Standard_Boolean const hasSide)

        Set which faces are included

        :type hasBottom: bool
        :type hasSide: bool

        """
        return _VrmlData.Handle_VrmlData_Cone_SetFaces(self, *args)


    def TShape(self, *args):
        """
        Query the primitive topology. This method returns a Null shape if there
        is an internal error during the primitive creation (zero radius, etc.)

        :rtype: OCC.wrapper.TopoDS.Handle_TopoDS_TShape

        """
        res = _VrmlData.Handle_VrmlData_Cone_TShape(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Clone(self, *args):
        """
        Clone(Handle_VrmlData_Cone self, Handle_VrmlData_Node theOther) -> Handle_VrmlData_Node

        Create a copy of this node.
        If the parameter is null, a new copied node is created. Otherwise new node
        is not created, but rather the given one is modified.

        :type theOther: OCC.wrapper.VrmlData.Handle_VrmlData_Node
        :rtype: OCC.wrapper.VrmlData.Handle_VrmlData_Node

        """
        return _VrmlData.Handle_VrmlData_Cone_Clone(self, *args)


    def Read(self, *args):
        """
        Read(Handle_VrmlData_Cone self, VrmlData_InBuffer & theBuffer) -> VrmlData_ErrorStatus

        Fill the Node internal data from the given input stream.

        :type theBuffer: OCC.wrapper.VrmlData.VrmlData_InBuffer
        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.Handle_VrmlData_Cone_Read(self, *args)


    def Write(self, *args):
        """
        Write(Handle_VrmlData_Cone self, char const * thePrefix) -> VrmlData_ErrorStatus

        Write the Node to output stream.

        :type thePrefix: const char *
        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.Handle_VrmlData_Cone_Write(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_VrmlData_Cone self) -> char const *

        :rtype: const char *

        """
        return _VrmlData.Handle_VrmlData_Cone_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _VrmlData.Handle_VrmlData_Cone_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _VrmlData.Handle_VrmlData_Cone_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Scene(self, *args):
        """
        Query the Scene that contains this Node

        :rtype: OCC.wrapper.VrmlData.VrmlData_Scene

        """
        res = _VrmlData.Handle_VrmlData_Cone_Scene(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Name(self, *args):
        """
        Name(Handle_VrmlData_Cone self) -> char const *

        Query the name

        :rtype: const char *

        """
        return _VrmlData.Handle_VrmlData_Cone_Name(self, *args)


    def ReadNode(self, *args):
        """
        ReadNode(Handle_VrmlData_Cone self, VrmlData_InBuffer & theBuffer, Handle_VrmlData_Node theNode, Handle_Standard_Type Type=0) -> VrmlData_ErrorStatus

        Read a complete node definition from VRML stream
        @param theBuffer
        Buffer receiving the input data.
        @param theNode
        <tt>[out]</tt> Node restored from the buffer data
        @param Type
        Node type to be checked. If it is NULL(default) no type checking is done.
        Otherwise the created node is matched and an error is returned if
        no match detected.

        :type theBuffer: OCC.wrapper.VrmlData.VrmlData_InBuffer
        :type theNode: OCC.wrapper.VrmlData.Handle_VrmlData_Node
        :type Type: OCC.wrapper.Standard.Handle_Standard_Type
        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.Handle_VrmlData_Cone_ReadNode(self, *args)


    def IsDefault(self, *args):
        """
        IsDefault(Handle_VrmlData_Cone self) -> Standard_Boolean

        Returns True if the node is default, then it would not be written.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _VrmlData.Handle_VrmlData_Cone_IsDefault(self, *args)


    def WriteClosing(self, *args):
        """
        WriteClosing(Handle_VrmlData_Cone self) -> VrmlData_ErrorStatus

        Write the closing brace in the end of a node output.

        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.Handle_VrmlData_Cone_WriteClosing(self, *args)


    def ReadBoolean(self, *args):
        """
        ReadBoolean(Handle_VrmlData_Cone self, VrmlData_InBuffer & theBuffer) -> VrmlData_ErrorStatus

        Read one boolean value (TRUE or FALSE).

        :type theBuffer: OCC.wrapper.VrmlData.VrmlData_InBuffer
        :type theResult: bool
        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.Handle_VrmlData_Cone_ReadBoolean(self, *args)


    def ReadString(self, *args):
        """
        ReadString(Handle_VrmlData_Cone self, VrmlData_InBuffer & theBuffer, TCollection_AsciiString theRes) -> VrmlData_ErrorStatus

        Read one quoted string, the quotes are removed.

        :type theBuffer: OCC.wrapper.VrmlData.VrmlData_InBuffer
        :type theRes: OCC.wrapper.TCollection.TCollection_AsciiString
        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.Handle_VrmlData_Cone_ReadString(self, *args)


    def ReadMultiString(self, *args):
        """
        ReadMultiString(Handle_VrmlData_Cone self, VrmlData_InBuffer & theBuffer, NCollection_List_TCollection_AsciiString theRes) -> VrmlData_ErrorStatus

        Read one quoted string, the quotes are removed.

        :type theBuffer: OCC.wrapper.VrmlData.VrmlData_InBuffer
        :type theRes: OCC.wrapper.TColStd.NCollection_List_TCollection_AsciiString
        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.Handle_VrmlData_Cone_ReadMultiString(self, *args)


    def ReadInteger(self, *args):
        """
        ReadInteger(Handle_VrmlData_Cone self, VrmlData_InBuffer & theBuffer) -> VrmlData_ErrorStatus

        Read one integer value.

        :type theBuffer: OCC.wrapper.VrmlData.VrmlData_InBuffer
        :type theResult: long &
        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.Handle_VrmlData_Cone_ReadInteger(self, *args)


    def OK(self, *args):
        """
        OK(Handle_VrmlData_Cone self, VrmlData_ErrorStatus const theStat) -> Standard_Boolean
        OK(Handle_VrmlData_Cone self, VrmlData_ErrorStatus const theStat) -> Standard_Boolean

        :type outStat: OCC.wrapper.VrmlData.VrmlData_ErrorStatus
        :type theStat: OCC.wrapper.VrmlData.VrmlData_ErrorStatus
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _VrmlData.Handle_VrmlData_Cone_OK(self, *args)


    def GlobalIndent(self, *args):
        """
        GlobalIndent(Handle_VrmlData_Cone self) -> Standard_Integer

        Define the common Indent in spaces, for writing all nodes.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _VrmlData.Handle_VrmlData_Cone_GlobalIndent(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_VrmlData_Cone self)

        Memory deallocator for transient classes


        """
        return _VrmlData.Handle_VrmlData_Cone_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_VrmlData_Cone self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_VrmlData_Cone self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _VrmlData.Handle_VrmlData_Cone_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_VrmlData_Cone self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_VrmlData_Cone self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _VrmlData.Handle_VrmlData_Cone_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_VrmlData_Cone self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _VrmlData.Handle_VrmlData_Cone_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_VrmlData_Cone self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _VrmlData.Handle_VrmlData_Cone_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_VrmlData_Cone self)

        Increments the reference counter of this object


        """
        return _VrmlData.Handle_VrmlData_Cone_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_VrmlData_Cone self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _VrmlData.Handle_VrmlData_Cone_DecrementRefCounter(self, *args)

Handle_VrmlData_Cone_swigregister = _VrmlData.Handle_VrmlData_Cone_swigregister
Handle_VrmlData_Cone_swigregister(Handle_VrmlData_Cone)

def Handle_VrmlData_Cone_DownCast(thing):
    return _VrmlData.Handle_VrmlData_Cone_DownCast(thing)
Handle_VrmlData_Cone_DownCast = _VrmlData.Handle_VrmlData_Cone_DownCast

class Handle_VrmlData_UnknownNode(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_VrmlData_UnknownNode self)

        Nullify the handle


        """
        return _VrmlData.Handle_VrmlData_UnknownNode_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_VrmlData_UnknownNode self) -> bool

        Check for being null

        :rtype: bool

        """
        return _VrmlData.Handle_VrmlData_UnknownNode_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_VrmlData_UnknownNode self, VrmlData_UnknownNode thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _VrmlData.Handle_VrmlData_UnknownNode_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_VrmlData_UnknownNode self, Handle_VrmlData_UnknownNode theHandle) -> Handle_VrmlData_UnknownNode
        assign(Handle_VrmlData_UnknownNode self, VrmlData_UnknownNode thePtr) -> Handle_VrmlData_UnknownNode
        assign(Handle_VrmlData_UnknownNode self, Handle_VrmlData_UnknownNode theHandle) -> Handle_VrmlData_UnknownNode

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _VrmlData.Handle_VrmlData_UnknownNode_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_VrmlData_UnknownNode self) -> VrmlData_UnknownNode

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _VrmlData.Handle_VrmlData_UnknownNode_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_VrmlData_UnknownNode self) -> VrmlData_UnknownNode

        Member access operator (note non-const)

        :rtype: T *

        """
        return _VrmlData.Handle_VrmlData_UnknownNode___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_VrmlData_UnknownNode self) -> VrmlData_UnknownNode

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _VrmlData.Handle_VrmlData_UnknownNode___ref__(self, *args)


    def __hash__(self):
        return _VrmlData.Handle_VrmlData_UnknownNode___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _VrmlData.Handle_VrmlData_UnknownNode___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _VrmlData.new_Handle_VrmlData_UnknownNode(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_VrmlData.Handle_VrmlData_UnknownNode_DownCast)
    __swig_destroy__ = _VrmlData.delete_Handle_VrmlData_UnknownNode

    def Read(self, *args):
        """
        Read(Handle_VrmlData_UnknownNode self, VrmlData_InBuffer & theBuffer) -> VrmlData_ErrorStatus

        Read the unknown node, till the last closing brace of it.

        :type theBuffer: OCC.wrapper.VrmlData.VrmlData_InBuffer
        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.Handle_VrmlData_UnknownNode_Read(self, *args)


    def GetTitle(self, *args):
        """
        Query the title of the unknown node.

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        res = _VrmlData.Handle_VrmlData_UnknownNode_GetTitle(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def IsDefault(self, *args):
        """
        IsDefault(Handle_VrmlData_UnknownNode self) -> Standard_Boolean

        Check if the Node is non-writeable -- always returns true.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _VrmlData.Handle_VrmlData_UnknownNode_IsDefault(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_VrmlData_UnknownNode self) -> char const *

        :rtype: const char *

        """
        return _VrmlData.Handle_VrmlData_UnknownNode_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _VrmlData.Handle_VrmlData_UnknownNode_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _VrmlData.Handle_VrmlData_UnknownNode_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Scene(self, *args):
        """
        Query the Scene that contains this Node

        :rtype: OCC.wrapper.VrmlData.VrmlData_Scene

        """
        res = _VrmlData.Handle_VrmlData_UnknownNode_Scene(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Name(self, *args):
        """
        Name(Handle_VrmlData_UnknownNode self) -> char const *

        Query the name

        :rtype: const char *

        """
        return _VrmlData.Handle_VrmlData_UnknownNode_Name(self, *args)


    def ReadNode(self, *args):
        """
        ReadNode(Handle_VrmlData_UnknownNode self, VrmlData_InBuffer & theBuffer, Handle_VrmlData_Node theNode, Handle_Standard_Type Type=0) -> VrmlData_ErrorStatus

        Read a complete node definition from VRML stream
        @param theBuffer
        Buffer receiving the input data.
        @param theNode
        <tt>[out]</tt> Node restored from the buffer data
        @param Type
        Node type to be checked. If it is NULL(default) no type checking is done.
        Otherwise the created node is matched and an error is returned if
        no match detected.

        :type theBuffer: OCC.wrapper.VrmlData.VrmlData_InBuffer
        :type theNode: OCC.wrapper.VrmlData.Handle_VrmlData_Node
        :type Type: OCC.wrapper.Standard.Handle_Standard_Type
        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.Handle_VrmlData_UnknownNode_ReadNode(self, *args)


    def Write(self, *args):
        """
        Write(Handle_VrmlData_UnknownNode self, char const * thePrefix) -> VrmlData_ErrorStatus

        Write the Node to output stream.

        :type thePrefix: const char *
        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.Handle_VrmlData_UnknownNode_Write(self, *args)


    def WriteClosing(self, *args):
        """
        WriteClosing(Handle_VrmlData_UnknownNode self) -> VrmlData_ErrorStatus

        Write the closing brace in the end of a node output.

        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.Handle_VrmlData_UnknownNode_WriteClosing(self, *args)


    def Clone(self, *args):
        """
        Clone(Handle_VrmlData_UnknownNode self, Handle_VrmlData_Node arg2) -> Handle_VrmlData_Node

        Create a copy of this node.
        If the parameter is null, a new copied node is created. Otherwise new node
        is not created, but rather the given one is modified.<p>
        This method nullifies the argument node if its member myScene differs
        from that one of the current instance.

        :type : OCC.wrapper.VrmlData.Handle_VrmlData_Node
        :rtype: OCC.wrapper.VrmlData.Handle_VrmlData_Node

        """
        return _VrmlData.Handle_VrmlData_UnknownNode_Clone(self, *args)


    def ReadBoolean(self, *args):
        """
        ReadBoolean(Handle_VrmlData_UnknownNode self, VrmlData_InBuffer & theBuffer) -> VrmlData_ErrorStatus

        Read one boolean value (TRUE or FALSE).

        :type theBuffer: OCC.wrapper.VrmlData.VrmlData_InBuffer
        :type theResult: bool
        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.Handle_VrmlData_UnknownNode_ReadBoolean(self, *args)


    def ReadString(self, *args):
        """
        ReadString(Handle_VrmlData_UnknownNode self, VrmlData_InBuffer & theBuffer, TCollection_AsciiString theRes) -> VrmlData_ErrorStatus

        Read one quoted string, the quotes are removed.

        :type theBuffer: OCC.wrapper.VrmlData.VrmlData_InBuffer
        :type theRes: OCC.wrapper.TCollection.TCollection_AsciiString
        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.Handle_VrmlData_UnknownNode_ReadString(self, *args)


    def ReadMultiString(self, *args):
        """
        ReadMultiString(Handle_VrmlData_UnknownNode self, VrmlData_InBuffer & theBuffer, NCollection_List_TCollection_AsciiString theRes) -> VrmlData_ErrorStatus

        Read one quoted string, the quotes are removed.

        :type theBuffer: OCC.wrapper.VrmlData.VrmlData_InBuffer
        :type theRes: OCC.wrapper.TColStd.NCollection_List_TCollection_AsciiString
        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.Handle_VrmlData_UnknownNode_ReadMultiString(self, *args)


    def ReadInteger(self, *args):
        """
        ReadInteger(Handle_VrmlData_UnknownNode self, VrmlData_InBuffer & theBuffer) -> VrmlData_ErrorStatus

        Read one integer value.

        :type theBuffer: OCC.wrapper.VrmlData.VrmlData_InBuffer
        :type theResult: long &
        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.Handle_VrmlData_UnknownNode_ReadInteger(self, *args)


    def OK(self, *args):
        """
        OK(Handle_VrmlData_UnknownNode self, VrmlData_ErrorStatus const theStat) -> Standard_Boolean
        OK(Handle_VrmlData_UnknownNode self, VrmlData_ErrorStatus const theStat) -> Standard_Boolean

        :type outStat: OCC.wrapper.VrmlData.VrmlData_ErrorStatus
        :type theStat: OCC.wrapper.VrmlData.VrmlData_ErrorStatus
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _VrmlData.Handle_VrmlData_UnknownNode_OK(self, *args)


    def GlobalIndent(self, *args):
        """
        GlobalIndent(Handle_VrmlData_UnknownNode self) -> Standard_Integer

        Define the common Indent in spaces, for writing all nodes.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _VrmlData.Handle_VrmlData_UnknownNode_GlobalIndent(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_VrmlData_UnknownNode self)

        Memory deallocator for transient classes


        """
        return _VrmlData.Handle_VrmlData_UnknownNode_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_VrmlData_UnknownNode self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_VrmlData_UnknownNode self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _VrmlData.Handle_VrmlData_UnknownNode_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_VrmlData_UnknownNode self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_VrmlData_UnknownNode self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _VrmlData.Handle_VrmlData_UnknownNode_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_VrmlData_UnknownNode self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _VrmlData.Handle_VrmlData_UnknownNode_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_VrmlData_UnknownNode self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _VrmlData.Handle_VrmlData_UnknownNode_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_VrmlData_UnknownNode self)

        Increments the reference counter of this object


        """
        return _VrmlData.Handle_VrmlData_UnknownNode_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_VrmlData_UnknownNode self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _VrmlData.Handle_VrmlData_UnknownNode_DecrementRefCounter(self, *args)

Handle_VrmlData_UnknownNode_swigregister = _VrmlData.Handle_VrmlData_UnknownNode_swigregister
Handle_VrmlData_UnknownNode_swigregister(Handle_VrmlData_UnknownNode)

def Handle_VrmlData_UnknownNode_DownCast(thing):
    return _VrmlData.Handle_VrmlData_UnknownNode_DownCast(thing)
Handle_VrmlData_UnknownNode_DownCast = _VrmlData.Handle_VrmlData_UnknownNode_DownCast

class Handle_VrmlData_WorldInfo(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_VrmlData_WorldInfo self)

        Nullify the handle


        """
        return _VrmlData.Handle_VrmlData_WorldInfo_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_VrmlData_WorldInfo self) -> bool

        Check for being null

        :rtype: bool

        """
        return _VrmlData.Handle_VrmlData_WorldInfo_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_VrmlData_WorldInfo self, VrmlData_WorldInfo thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _VrmlData.Handle_VrmlData_WorldInfo_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_VrmlData_WorldInfo self, Handle_VrmlData_WorldInfo theHandle) -> Handle_VrmlData_WorldInfo
        assign(Handle_VrmlData_WorldInfo self, VrmlData_WorldInfo thePtr) -> Handle_VrmlData_WorldInfo
        assign(Handle_VrmlData_WorldInfo self, Handle_VrmlData_WorldInfo theHandle) -> Handle_VrmlData_WorldInfo

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _VrmlData.Handle_VrmlData_WorldInfo_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_VrmlData_WorldInfo self) -> VrmlData_WorldInfo

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _VrmlData.Handle_VrmlData_WorldInfo_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_VrmlData_WorldInfo self) -> VrmlData_WorldInfo

        Member access operator (note non-const)

        :rtype: T *

        """
        return _VrmlData.Handle_VrmlData_WorldInfo___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_VrmlData_WorldInfo self) -> VrmlData_WorldInfo

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _VrmlData.Handle_VrmlData_WorldInfo___ref__(self, *args)


    def __hash__(self):
        return _VrmlData.Handle_VrmlData_WorldInfo___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _VrmlData.Handle_VrmlData_WorldInfo___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _VrmlData.new_Handle_VrmlData_WorldInfo(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_VrmlData.Handle_VrmlData_WorldInfo_DownCast)
    __swig_destroy__ = _VrmlData.delete_Handle_VrmlData_WorldInfo

    def SetTitle(self, *args):
        """
        SetTitle(Handle_VrmlData_WorldInfo self, char const * theString)

        Set or modify the title.

        :type theString: const char *

        """
        return _VrmlData.Handle_VrmlData_WorldInfo_SetTitle(self, *args)


    def AddInfo(self, *args):
        """
        AddInfo(Handle_VrmlData_WorldInfo self, char const * theString)

        Add a string to the list of info strings.

        :type theString: const char *

        """
        return _VrmlData.Handle_VrmlData_WorldInfo_AddInfo(self, *args)


    def Title(self, *args):
        """
        Title(Handle_VrmlData_WorldInfo self) -> char const *

        Query the title string.

        :rtype: const char *

        """
        return _VrmlData.Handle_VrmlData_WorldInfo_Title(self, *args)


    def Clone(self, *args):
        """
        Clone(Handle_VrmlData_WorldInfo self, Handle_VrmlData_Node theOther) -> Handle_VrmlData_Node

        Create a copy of this node.
        If the parameter is null, a new copied node is created. Otherwise new node
        is not created, but rather the given one is modified.

        :type theOther: OCC.wrapper.VrmlData.Handle_VrmlData_Node
        :rtype: OCC.wrapper.VrmlData.Handle_VrmlData_Node

        """
        return _VrmlData.Handle_VrmlData_WorldInfo_Clone(self, *args)


    def Read(self, *args):
        """
        Read(Handle_VrmlData_WorldInfo self, VrmlData_InBuffer & theBuffer) -> VrmlData_ErrorStatus

        Read the Node from input stream.

        :type theBuffer: OCC.wrapper.VrmlData.VrmlData_InBuffer
        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.Handle_VrmlData_WorldInfo_Read(self, *args)


    def Write(self, *args):
        """
        Write(Handle_VrmlData_WorldInfo self, char const * thePrefix) -> VrmlData_ErrorStatus

        Write the Node to the Scene output.

        :type thePrefix: const char *
        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.Handle_VrmlData_WorldInfo_Write(self, *args)


    def IsDefault(self, *args):
        """
        IsDefault(Handle_VrmlData_WorldInfo self) -> Standard_Boolean

        Returns True if the node is default, then it would not be written.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _VrmlData.Handle_VrmlData_WorldInfo_IsDefault(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_VrmlData_WorldInfo self) -> char const *

        :rtype: const char *

        """
        return _VrmlData.Handle_VrmlData_WorldInfo_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _VrmlData.Handle_VrmlData_WorldInfo_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _VrmlData.Handle_VrmlData_WorldInfo_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def infoIterator(self):
        return _VrmlData.Handle_VrmlData_WorldInfo_infoIterator(self)

    def Scene(self, *args):
        """
        Query the Scene that contains this Node

        :rtype: OCC.wrapper.VrmlData.VrmlData_Scene

        """
        res = _VrmlData.Handle_VrmlData_WorldInfo_Scene(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Name(self, *args):
        """
        Name(Handle_VrmlData_WorldInfo self) -> char const *

        Query the name

        :rtype: const char *

        """
        return _VrmlData.Handle_VrmlData_WorldInfo_Name(self, *args)


    def ReadNode(self, *args):
        """
        ReadNode(Handle_VrmlData_WorldInfo self, VrmlData_InBuffer & theBuffer, Handle_VrmlData_Node theNode, Handle_Standard_Type Type=0) -> VrmlData_ErrorStatus

        Read a complete node definition from VRML stream
        @param theBuffer
        Buffer receiving the input data.
        @param theNode
        <tt>[out]</tt> Node restored from the buffer data
        @param Type
        Node type to be checked. If it is NULL(default) no type checking is done.
        Otherwise the created node is matched and an error is returned if
        no match detected.

        :type theBuffer: OCC.wrapper.VrmlData.VrmlData_InBuffer
        :type theNode: OCC.wrapper.VrmlData.Handle_VrmlData_Node
        :type Type: OCC.wrapper.Standard.Handle_Standard_Type
        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.Handle_VrmlData_WorldInfo_ReadNode(self, *args)


    def WriteClosing(self, *args):
        """
        WriteClosing(Handle_VrmlData_WorldInfo self) -> VrmlData_ErrorStatus

        Write the closing brace in the end of a node output.

        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.Handle_VrmlData_WorldInfo_WriteClosing(self, *args)


    def ReadBoolean(self, *args):
        """
        ReadBoolean(Handle_VrmlData_WorldInfo self, VrmlData_InBuffer & theBuffer) -> VrmlData_ErrorStatus

        Read one boolean value (TRUE or FALSE).

        :type theBuffer: OCC.wrapper.VrmlData.VrmlData_InBuffer
        :type theResult: bool
        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.Handle_VrmlData_WorldInfo_ReadBoolean(self, *args)


    def ReadString(self, *args):
        """
        ReadString(Handle_VrmlData_WorldInfo self, VrmlData_InBuffer & theBuffer, TCollection_AsciiString theRes) -> VrmlData_ErrorStatus

        Read one quoted string, the quotes are removed.

        :type theBuffer: OCC.wrapper.VrmlData.VrmlData_InBuffer
        :type theRes: OCC.wrapper.TCollection.TCollection_AsciiString
        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.Handle_VrmlData_WorldInfo_ReadString(self, *args)


    def ReadMultiString(self, *args):
        """
        ReadMultiString(Handle_VrmlData_WorldInfo self, VrmlData_InBuffer & theBuffer, NCollection_List_TCollection_AsciiString theRes) -> VrmlData_ErrorStatus

        Read one quoted string, the quotes are removed.

        :type theBuffer: OCC.wrapper.VrmlData.VrmlData_InBuffer
        :type theRes: OCC.wrapper.TColStd.NCollection_List_TCollection_AsciiString
        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.Handle_VrmlData_WorldInfo_ReadMultiString(self, *args)


    def ReadInteger(self, *args):
        """
        ReadInteger(Handle_VrmlData_WorldInfo self, VrmlData_InBuffer & theBuffer) -> VrmlData_ErrorStatus

        Read one integer value.

        :type theBuffer: OCC.wrapper.VrmlData.VrmlData_InBuffer
        :type theResult: long &
        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.Handle_VrmlData_WorldInfo_ReadInteger(self, *args)


    def OK(self, *args):
        """
        OK(Handle_VrmlData_WorldInfo self, VrmlData_ErrorStatus const theStat) -> Standard_Boolean
        OK(Handle_VrmlData_WorldInfo self, VrmlData_ErrorStatus const theStat) -> Standard_Boolean

        :type outStat: OCC.wrapper.VrmlData.VrmlData_ErrorStatus
        :type theStat: OCC.wrapper.VrmlData.VrmlData_ErrorStatus
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _VrmlData.Handle_VrmlData_WorldInfo_OK(self, *args)


    def GlobalIndent(self, *args):
        """
        GlobalIndent(Handle_VrmlData_WorldInfo self) -> Standard_Integer

        Define the common Indent in spaces, for writing all nodes.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _VrmlData.Handle_VrmlData_WorldInfo_GlobalIndent(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_VrmlData_WorldInfo self)

        Memory deallocator for transient classes


        """
        return _VrmlData.Handle_VrmlData_WorldInfo_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_VrmlData_WorldInfo self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_VrmlData_WorldInfo self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _VrmlData.Handle_VrmlData_WorldInfo_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_VrmlData_WorldInfo self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_VrmlData_WorldInfo self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _VrmlData.Handle_VrmlData_WorldInfo_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_VrmlData_WorldInfo self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _VrmlData.Handle_VrmlData_WorldInfo_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_VrmlData_WorldInfo self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _VrmlData.Handle_VrmlData_WorldInfo_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_VrmlData_WorldInfo self)

        Increments the reference counter of this object


        """
        return _VrmlData.Handle_VrmlData_WorldInfo_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_VrmlData_WorldInfo self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _VrmlData.Handle_VrmlData_WorldInfo_DecrementRefCounter(self, *args)

Handle_VrmlData_WorldInfo_swigregister = _VrmlData.Handle_VrmlData_WorldInfo_swigregister
Handle_VrmlData_WorldInfo_swigregister(Handle_VrmlData_WorldInfo)

def Handle_VrmlData_WorldInfo_DownCast(thing):
    return _VrmlData.Handle_VrmlData_WorldInfo_DownCast(thing)
Handle_VrmlData_WorldInfo_DownCast = _VrmlData.Handle_VrmlData_WorldInfo_DownCast

class Handle_VrmlData_Box(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_VrmlData_Box self)

        Nullify the handle


        """
        return _VrmlData.Handle_VrmlData_Box_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_VrmlData_Box self) -> bool

        Check for being null

        :rtype: bool

        """
        return _VrmlData.Handle_VrmlData_Box_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_VrmlData_Box self, VrmlData_Box thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _VrmlData.Handle_VrmlData_Box_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_VrmlData_Box self, Handle_VrmlData_Box theHandle) -> Handle_VrmlData_Box
        assign(Handle_VrmlData_Box self, VrmlData_Box thePtr) -> Handle_VrmlData_Box
        assign(Handle_VrmlData_Box self, Handle_VrmlData_Box theHandle) -> Handle_VrmlData_Box

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _VrmlData.Handle_VrmlData_Box_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_VrmlData_Box self) -> VrmlData_Box

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _VrmlData.Handle_VrmlData_Box_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_VrmlData_Box self) -> VrmlData_Box

        Member access operator (note non-const)

        :rtype: T *

        """
        return _VrmlData.Handle_VrmlData_Box___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_VrmlData_Box self) -> VrmlData_Box

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _VrmlData.Handle_VrmlData_Box___ref__(self, *args)


    def __hash__(self):
        return _VrmlData.Handle_VrmlData_Box___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _VrmlData.Handle_VrmlData_Box___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _VrmlData.new_Handle_VrmlData_Box(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_VrmlData.Handle_VrmlData_Box_DownCast)
    __swig_destroy__ = _VrmlData.delete_Handle_VrmlData_Box

    def Size(self, *args):
        """
        Query the Box size

        :rtype: OCC.wrapper.gp.gp_XYZ

        """
        res = _VrmlData.Handle_VrmlData_Box_Size(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetSize(self, *args):
        """
        SetSize(Handle_VrmlData_Box self, gp_XYZ theSize)

        Set the Box Size

        :type theSize: OCC.wrapper.gp.gp_XYZ

        """
        return _VrmlData.Handle_VrmlData_Box_SetSize(self, *args)


    def TShape(self, *args):
        """
        Query the primitive topology. This method returns a Null shape if there
        is an internal error during the primitive creation (zero radius, etc.)

        :rtype: OCC.wrapper.TopoDS.Handle_TopoDS_TShape

        """
        res = _VrmlData.Handle_VrmlData_Box_TShape(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Clone(self, *args):
        """
        Clone(Handle_VrmlData_Box self, Handle_VrmlData_Node theOther) -> Handle_VrmlData_Node

        Create a copy of this node.
        If the parameter is null, a new copied node is created. Otherwise new node
        is not created, but rather the given one is modified.

        :type theOther: OCC.wrapper.VrmlData.Handle_VrmlData_Node
        :rtype: OCC.wrapper.VrmlData.Handle_VrmlData_Node

        """
        return _VrmlData.Handle_VrmlData_Box_Clone(self, *args)


    def Read(self, *args):
        """
        Read(Handle_VrmlData_Box self, VrmlData_InBuffer & theBuffer) -> VrmlData_ErrorStatus

        Fill the Node internal data from the given input stream.

        :type theBuffer: OCC.wrapper.VrmlData.VrmlData_InBuffer
        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.Handle_VrmlData_Box_Read(self, *args)


    def Write(self, *args):
        """
        Write(Handle_VrmlData_Box self, char const * thePrefix) -> VrmlData_ErrorStatus

        Write the Node to output stream.

        :type thePrefix: const char *
        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.Handle_VrmlData_Box_Write(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_VrmlData_Box self) -> char const *

        :rtype: const char *

        """
        return _VrmlData.Handle_VrmlData_Box_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _VrmlData.Handle_VrmlData_Box_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _VrmlData.Handle_VrmlData_Box_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Scene(self, *args):
        """
        Query the Scene that contains this Node

        :rtype: OCC.wrapper.VrmlData.VrmlData_Scene

        """
        res = _VrmlData.Handle_VrmlData_Box_Scene(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Name(self, *args):
        """
        Name(Handle_VrmlData_Box self) -> char const *

        Query the name

        :rtype: const char *

        """
        return _VrmlData.Handle_VrmlData_Box_Name(self, *args)


    def ReadNode(self, *args):
        """
        ReadNode(Handle_VrmlData_Box self, VrmlData_InBuffer & theBuffer, Handle_VrmlData_Node theNode, Handle_Standard_Type Type=0) -> VrmlData_ErrorStatus

        Read a complete node definition from VRML stream
        @param theBuffer
        Buffer receiving the input data.
        @param theNode
        <tt>[out]</tt> Node restored from the buffer data
        @param Type
        Node type to be checked. If it is NULL(default) no type checking is done.
        Otherwise the created node is matched and an error is returned if
        no match detected.

        :type theBuffer: OCC.wrapper.VrmlData.VrmlData_InBuffer
        :type theNode: OCC.wrapper.VrmlData.Handle_VrmlData_Node
        :type Type: OCC.wrapper.Standard.Handle_Standard_Type
        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.Handle_VrmlData_Box_ReadNode(self, *args)


    def IsDefault(self, *args):
        """
        IsDefault(Handle_VrmlData_Box self) -> Standard_Boolean

        Returns True if the node is default, then it would not be written.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _VrmlData.Handle_VrmlData_Box_IsDefault(self, *args)


    def WriteClosing(self, *args):
        """
        WriteClosing(Handle_VrmlData_Box self) -> VrmlData_ErrorStatus

        Write the closing brace in the end of a node output.

        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.Handle_VrmlData_Box_WriteClosing(self, *args)


    def ReadBoolean(self, *args):
        """
        ReadBoolean(Handle_VrmlData_Box self, VrmlData_InBuffer & theBuffer) -> VrmlData_ErrorStatus

        Read one boolean value (TRUE or FALSE).

        :type theBuffer: OCC.wrapper.VrmlData.VrmlData_InBuffer
        :type theResult: bool
        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.Handle_VrmlData_Box_ReadBoolean(self, *args)


    def ReadString(self, *args):
        """
        ReadString(Handle_VrmlData_Box self, VrmlData_InBuffer & theBuffer, TCollection_AsciiString theRes) -> VrmlData_ErrorStatus

        Read one quoted string, the quotes are removed.

        :type theBuffer: OCC.wrapper.VrmlData.VrmlData_InBuffer
        :type theRes: OCC.wrapper.TCollection.TCollection_AsciiString
        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.Handle_VrmlData_Box_ReadString(self, *args)


    def ReadMultiString(self, *args):
        """
        ReadMultiString(Handle_VrmlData_Box self, VrmlData_InBuffer & theBuffer, NCollection_List_TCollection_AsciiString theRes) -> VrmlData_ErrorStatus

        Read one quoted string, the quotes are removed.

        :type theBuffer: OCC.wrapper.VrmlData.VrmlData_InBuffer
        :type theRes: OCC.wrapper.TColStd.NCollection_List_TCollection_AsciiString
        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.Handle_VrmlData_Box_ReadMultiString(self, *args)


    def ReadInteger(self, *args):
        """
        ReadInteger(Handle_VrmlData_Box self, VrmlData_InBuffer & theBuffer) -> VrmlData_ErrorStatus

        Read one integer value.

        :type theBuffer: OCC.wrapper.VrmlData.VrmlData_InBuffer
        :type theResult: long &
        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.Handle_VrmlData_Box_ReadInteger(self, *args)


    def OK(self, *args):
        """
        OK(Handle_VrmlData_Box self, VrmlData_ErrorStatus const theStat) -> Standard_Boolean
        OK(Handle_VrmlData_Box self, VrmlData_ErrorStatus const theStat) -> Standard_Boolean

        :type outStat: OCC.wrapper.VrmlData.VrmlData_ErrorStatus
        :type theStat: OCC.wrapper.VrmlData.VrmlData_ErrorStatus
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _VrmlData.Handle_VrmlData_Box_OK(self, *args)


    def GlobalIndent(self, *args):
        """
        GlobalIndent(Handle_VrmlData_Box self) -> Standard_Integer

        Define the common Indent in spaces, for writing all nodes.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _VrmlData.Handle_VrmlData_Box_GlobalIndent(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_VrmlData_Box self)

        Memory deallocator for transient classes


        """
        return _VrmlData.Handle_VrmlData_Box_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_VrmlData_Box self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_VrmlData_Box self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _VrmlData.Handle_VrmlData_Box_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_VrmlData_Box self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_VrmlData_Box self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _VrmlData.Handle_VrmlData_Box_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_VrmlData_Box self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _VrmlData.Handle_VrmlData_Box_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_VrmlData_Box self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _VrmlData.Handle_VrmlData_Box_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_VrmlData_Box self)

        Increments the reference counter of this object


        """
        return _VrmlData.Handle_VrmlData_Box_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_VrmlData_Box self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _VrmlData.Handle_VrmlData_Box_DecrementRefCounter(self, *args)

Handle_VrmlData_Box_swigregister = _VrmlData.Handle_VrmlData_Box_swigregister
Handle_VrmlData_Box_swigregister(Handle_VrmlData_Box)

def Handle_VrmlData_Box_DownCast(thing):
    return _VrmlData.Handle_VrmlData_Box_DownCast(thing)
Handle_VrmlData_Box_DownCast = _VrmlData.Handle_VrmlData_Box_DownCast

class Handle_VrmlData_ArrayVec3d(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_VrmlData_ArrayVec3d self)

        Nullify the handle


        """
        return _VrmlData.Handle_VrmlData_ArrayVec3d_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_VrmlData_ArrayVec3d self) -> bool

        Check for being null

        :rtype: bool

        """
        return _VrmlData.Handle_VrmlData_ArrayVec3d_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_VrmlData_ArrayVec3d self, VrmlData_ArrayVec3d thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _VrmlData.Handle_VrmlData_ArrayVec3d_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_VrmlData_ArrayVec3d self, Handle_VrmlData_ArrayVec3d theHandle) -> Handle_VrmlData_ArrayVec3d
        assign(Handle_VrmlData_ArrayVec3d self, VrmlData_ArrayVec3d thePtr) -> Handle_VrmlData_ArrayVec3d
        assign(Handle_VrmlData_ArrayVec3d self, Handle_VrmlData_ArrayVec3d theHandle) -> Handle_VrmlData_ArrayVec3d

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _VrmlData.Handle_VrmlData_ArrayVec3d_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_VrmlData_ArrayVec3d self) -> VrmlData_ArrayVec3d

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _VrmlData.Handle_VrmlData_ArrayVec3d_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_VrmlData_ArrayVec3d self) -> VrmlData_ArrayVec3d

        Member access operator (note non-const)

        :rtype: T *

        """
        return _VrmlData.Handle_VrmlData_ArrayVec3d___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_VrmlData_ArrayVec3d self) -> VrmlData_ArrayVec3d

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _VrmlData.Handle_VrmlData_ArrayVec3d___ref__(self, *args)


    def __hash__(self):
        return _VrmlData.Handle_VrmlData_ArrayVec3d___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _VrmlData.Handle_VrmlData_ArrayVec3d___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _VrmlData.new_Handle_VrmlData_ArrayVec3d(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_VrmlData.Handle_VrmlData_ArrayVec3d_DownCast)
    __swig_destroy__ = _VrmlData.delete_Handle_VrmlData_ArrayVec3d

    def Length(self, *args):
        """
        Length(Handle_VrmlData_ArrayVec3d self) -> Standard_Size

        Query the number of vectors

        :rtype: OCC.wrapper.Standard.Standard_Size

        """
        return _VrmlData.Handle_VrmlData_ArrayVec3d_Length(self, *args)


    def Values(self, *args):
        """
        Values(Handle_VrmlData_ArrayVec3d self) -> gp_XYZ

        Query the array

        :rtype: OCC.wrapper.gp.gp_XYZ

        """
        return _VrmlData.Handle_VrmlData_ArrayVec3d_Values(self, *args)


    def AllocateValues(self, *args):
        """
        AllocateValues(Handle_VrmlData_ArrayVec3d self, Standard_Size const theLength) -> Standard_Boolean

        Create a data array and assign the field myArray.
        @return
        True if allocation was successful.

        :type theLength: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _VrmlData.Handle_VrmlData_ArrayVec3d_AllocateValues(self, *args)


    def SetValues(self, *args):
        """
        SetValues(Handle_VrmlData_ArrayVec3d self, Standard_Size const nValues, gp_XYZ arrValues)

        Set the array data

        :type nValues: int
        :type arrValues: OCC.wrapper.gp.gp_XYZ

        """
        return _VrmlData.Handle_VrmlData_ArrayVec3d_SetValues(self, *args)


    def ReadArray(self, *args):
        """
        ReadArray(Handle_VrmlData_ArrayVec3d self, VrmlData_InBuffer & theBuffer, char const * theName, Standard_Boolean const isScale) -> VrmlData_ErrorStatus

        Read the Node from input stream.

        :type theBuffer: OCC.wrapper.VrmlData.VrmlData_InBuffer
        :type theName: const char *
        :type isScale: bool
        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.Handle_VrmlData_ArrayVec3d_ReadArray(self, *args)


    def WriteArray(self, *args):
        """
        WriteArray(Handle_VrmlData_ArrayVec3d self, char const * theName, Standard_Boolean const isScale) -> VrmlData_ErrorStatus

        Write the Node to the output stream currently opened in Scene.

        :type theName: const char *
        :type isScale: bool
        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.Handle_VrmlData_ArrayVec3d_WriteArray(self, *args)


    def IsDefault(self, *args):
        """
        IsDefault(Handle_VrmlData_ArrayVec3d self) -> Standard_Boolean

        Returns True if the node is default, so that it should not be written.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _VrmlData.Handle_VrmlData_ArrayVec3d_IsDefault(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_VrmlData_ArrayVec3d self) -> char const *

        :rtype: const char *

        """
        return _VrmlData.Handle_VrmlData_ArrayVec3d_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _VrmlData.Handle_VrmlData_ArrayVec3d_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _VrmlData.Handle_VrmlData_ArrayVec3d_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Scene(self, *args):
        """
        Query the Scene that contains this Node

        :rtype: OCC.wrapper.VrmlData.VrmlData_Scene

        """
        res = _VrmlData.Handle_VrmlData_ArrayVec3d_Scene(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Name(self, *args):
        """
        Name(Handle_VrmlData_ArrayVec3d self) -> char const *

        Query the name

        :rtype: const char *

        """
        return _VrmlData.Handle_VrmlData_ArrayVec3d_Name(self, *args)


    def ReadNode(self, *args):
        """
        ReadNode(Handle_VrmlData_ArrayVec3d self, VrmlData_InBuffer & theBuffer, Handle_VrmlData_Node theNode, Handle_Standard_Type Type=0) -> VrmlData_ErrorStatus

        Read a complete node definition from VRML stream
        @param theBuffer
        Buffer receiving the input data.
        @param theNode
        <tt>[out]</tt> Node restored from the buffer data
        @param Type
        Node type to be checked. If it is NULL(default) no type checking is done.
        Otherwise the created node is matched and an error is returned if
        no match detected.

        :type theBuffer: OCC.wrapper.VrmlData.VrmlData_InBuffer
        :type theNode: OCC.wrapper.VrmlData.Handle_VrmlData_Node
        :type Type: OCC.wrapper.Standard.Handle_Standard_Type
        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.Handle_VrmlData_ArrayVec3d_ReadNode(self, *args)


    def Read(self, *args):
        """
        Read(Handle_VrmlData_ArrayVec3d self, VrmlData_InBuffer & theBuffer) -> VrmlData_ErrorStatus

        Read the Node from input stream.

        :type theBuffer: OCC.wrapper.VrmlData.VrmlData_InBuffer
        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.Handle_VrmlData_ArrayVec3d_Read(self, *args)


    def Write(self, *args):
        """
        Write(Handle_VrmlData_ArrayVec3d self, char const * thePrefix) -> VrmlData_ErrorStatus

        Write the Node to output stream.

        :type thePrefix: const char *
        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.Handle_VrmlData_ArrayVec3d_Write(self, *args)


    def WriteClosing(self, *args):
        """
        WriteClosing(Handle_VrmlData_ArrayVec3d self) -> VrmlData_ErrorStatus

        Write the closing brace in the end of a node output.

        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.Handle_VrmlData_ArrayVec3d_WriteClosing(self, *args)


    def Clone(self, *args):
        """
        Clone(Handle_VrmlData_ArrayVec3d self, Handle_VrmlData_Node arg2) -> Handle_VrmlData_Node

        Create a copy of this node.
        If the parameter is null, a new copied node is created. Otherwise new node
        is not created, but rather the given one is modified.<p>
        This method nullifies the argument node if its member myScene differs
        from that one of the current instance.

        :type : OCC.wrapper.VrmlData.Handle_VrmlData_Node
        :rtype: OCC.wrapper.VrmlData.Handle_VrmlData_Node

        """
        return _VrmlData.Handle_VrmlData_ArrayVec3d_Clone(self, *args)


    def ReadBoolean(self, *args):
        """
        ReadBoolean(Handle_VrmlData_ArrayVec3d self, VrmlData_InBuffer & theBuffer) -> VrmlData_ErrorStatus

        Read one boolean value (TRUE or FALSE).

        :type theBuffer: OCC.wrapper.VrmlData.VrmlData_InBuffer
        :type theResult: bool
        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.Handle_VrmlData_ArrayVec3d_ReadBoolean(self, *args)


    def ReadString(self, *args):
        """
        ReadString(Handle_VrmlData_ArrayVec3d self, VrmlData_InBuffer & theBuffer, TCollection_AsciiString theRes) -> VrmlData_ErrorStatus

        Read one quoted string, the quotes are removed.

        :type theBuffer: OCC.wrapper.VrmlData.VrmlData_InBuffer
        :type theRes: OCC.wrapper.TCollection.TCollection_AsciiString
        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.Handle_VrmlData_ArrayVec3d_ReadString(self, *args)


    def ReadMultiString(self, *args):
        """
        ReadMultiString(Handle_VrmlData_ArrayVec3d self, VrmlData_InBuffer & theBuffer, NCollection_List_TCollection_AsciiString theRes) -> VrmlData_ErrorStatus

        Read one quoted string, the quotes are removed.

        :type theBuffer: OCC.wrapper.VrmlData.VrmlData_InBuffer
        :type theRes: OCC.wrapper.TColStd.NCollection_List_TCollection_AsciiString
        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.Handle_VrmlData_ArrayVec3d_ReadMultiString(self, *args)


    def ReadInteger(self, *args):
        """
        ReadInteger(Handle_VrmlData_ArrayVec3d self, VrmlData_InBuffer & theBuffer) -> VrmlData_ErrorStatus

        Read one integer value.

        :type theBuffer: OCC.wrapper.VrmlData.VrmlData_InBuffer
        :type theResult: long &
        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.Handle_VrmlData_ArrayVec3d_ReadInteger(self, *args)


    def OK(self, *args):
        """
        OK(Handle_VrmlData_ArrayVec3d self, VrmlData_ErrorStatus const theStat) -> Standard_Boolean
        OK(Handle_VrmlData_ArrayVec3d self, VrmlData_ErrorStatus const theStat) -> Standard_Boolean

        :type outStat: OCC.wrapper.VrmlData.VrmlData_ErrorStatus
        :type theStat: OCC.wrapper.VrmlData.VrmlData_ErrorStatus
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _VrmlData.Handle_VrmlData_ArrayVec3d_OK(self, *args)


    def GlobalIndent(self, *args):
        """
        GlobalIndent(Handle_VrmlData_ArrayVec3d self) -> Standard_Integer

        Define the common Indent in spaces, for writing all nodes.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _VrmlData.Handle_VrmlData_ArrayVec3d_GlobalIndent(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_VrmlData_ArrayVec3d self)

        Memory deallocator for transient classes


        """
        return _VrmlData.Handle_VrmlData_ArrayVec3d_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_VrmlData_ArrayVec3d self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_VrmlData_ArrayVec3d self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _VrmlData.Handle_VrmlData_ArrayVec3d_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_VrmlData_ArrayVec3d self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_VrmlData_ArrayVec3d self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _VrmlData.Handle_VrmlData_ArrayVec3d_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_VrmlData_ArrayVec3d self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _VrmlData.Handle_VrmlData_ArrayVec3d_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_VrmlData_ArrayVec3d self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _VrmlData.Handle_VrmlData_ArrayVec3d_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_VrmlData_ArrayVec3d self)

        Increments the reference counter of this object


        """
        return _VrmlData.Handle_VrmlData_ArrayVec3d_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_VrmlData_ArrayVec3d self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _VrmlData.Handle_VrmlData_ArrayVec3d_DecrementRefCounter(self, *args)

Handle_VrmlData_ArrayVec3d_swigregister = _VrmlData.Handle_VrmlData_ArrayVec3d_swigregister
Handle_VrmlData_ArrayVec3d_swigregister(Handle_VrmlData_ArrayVec3d)

def Handle_VrmlData_ArrayVec3d_DownCast(thing):
    return _VrmlData.Handle_VrmlData_ArrayVec3d_DownCast(thing)
Handle_VrmlData_ArrayVec3d_DownCast = _VrmlData.Handle_VrmlData_ArrayVec3d_DownCast

class Handle_VrmlData_Coordinate(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_VrmlData_Coordinate self)

        Nullify the handle


        """
        return _VrmlData.Handle_VrmlData_Coordinate_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_VrmlData_Coordinate self) -> bool

        Check for being null

        :rtype: bool

        """
        return _VrmlData.Handle_VrmlData_Coordinate_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_VrmlData_Coordinate self, VrmlData_Coordinate thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _VrmlData.Handle_VrmlData_Coordinate_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_VrmlData_Coordinate self, Handle_VrmlData_Coordinate theHandle) -> Handle_VrmlData_Coordinate
        assign(Handle_VrmlData_Coordinate self, VrmlData_Coordinate thePtr) -> Handle_VrmlData_Coordinate
        assign(Handle_VrmlData_Coordinate self, Handle_VrmlData_Coordinate theHandle) -> Handle_VrmlData_Coordinate

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _VrmlData.Handle_VrmlData_Coordinate_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_VrmlData_Coordinate self) -> VrmlData_Coordinate

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _VrmlData.Handle_VrmlData_Coordinate_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_VrmlData_Coordinate self) -> VrmlData_Coordinate

        Member access operator (note non-const)

        :rtype: T *

        """
        return _VrmlData.Handle_VrmlData_Coordinate___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_VrmlData_Coordinate self) -> VrmlData_Coordinate

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _VrmlData.Handle_VrmlData_Coordinate___ref__(self, *args)


    def __hash__(self):
        return _VrmlData.Handle_VrmlData_Coordinate___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _VrmlData.Handle_VrmlData_Coordinate___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _VrmlData.new_Handle_VrmlData_Coordinate(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_VrmlData.Handle_VrmlData_Coordinate_DownCast)
    __swig_destroy__ = _VrmlData.delete_Handle_VrmlData_Coordinate

    def Coordinate(self, *args):
        """
        Query one point
        @param i
        index in the array of points [0 .. N-1]
        @return
        the coordinate for the index. If index irrelevant, returns (0., 0., 0.)

        :type i: int
        :rtype: OCC.wrapper.gp.gp_XYZ

        """
        res = _VrmlData.Handle_VrmlData_Coordinate_Coordinate(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Clone(self, *args):
        """
        Clone(Handle_VrmlData_Coordinate self, Handle_VrmlData_Node theOther) -> Handle_VrmlData_Node

        Create a copy of this node.
        If the parameter is null, a new copied node is created. Otherwise new node
        is not created, but rather the given one is modified.

        :type theOther: OCC.wrapper.VrmlData.Handle_VrmlData_Node
        :rtype: OCC.wrapper.VrmlData.Handle_VrmlData_Node

        """
        return _VrmlData.Handle_VrmlData_Coordinate_Clone(self, *args)


    def Read(self, *args):
        """
        Read(Handle_VrmlData_Coordinate self, VrmlData_InBuffer & theBuffer) -> VrmlData_ErrorStatus

        Read the Node from input stream.

        :type theBuffer: OCC.wrapper.VrmlData.VrmlData_InBuffer
        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.Handle_VrmlData_Coordinate_Read(self, *args)


    def Write(self, *args):
        """
        Write(Handle_VrmlData_Coordinate self, char const * thePrefix) -> VrmlData_ErrorStatus

        Write the Node to the Scene output.

        :type thePrefix: const char *
        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.Handle_VrmlData_Coordinate_Write(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_VrmlData_Coordinate self) -> char const *

        :rtype: const char *

        """
        return _VrmlData.Handle_VrmlData_Coordinate_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _VrmlData.Handle_VrmlData_Coordinate_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _VrmlData.Handle_VrmlData_Coordinate_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Length(self, *args):
        """
        Length(Handle_VrmlData_Coordinate self) -> Standard_Size

        Query the number of vectors

        :rtype: OCC.wrapper.Standard.Standard_Size

        """
        return _VrmlData.Handle_VrmlData_Coordinate_Length(self, *args)


    def Values(self, *args):
        """
        Values(Handle_VrmlData_Coordinate self) -> gp_XYZ

        Query the array

        :rtype: OCC.wrapper.gp.gp_XYZ

        """
        return _VrmlData.Handle_VrmlData_Coordinate_Values(self, *args)


    def AllocateValues(self, *args):
        """
        AllocateValues(Handle_VrmlData_Coordinate self, Standard_Size const theLength) -> Standard_Boolean

        Create a data array and assign the field myArray.
        @return
        True if allocation was successful.

        :type theLength: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _VrmlData.Handle_VrmlData_Coordinate_AllocateValues(self, *args)


    def SetValues(self, *args):
        """
        SetValues(Handle_VrmlData_Coordinate self, Standard_Size const nValues, gp_XYZ arrValues)

        Set the array data

        :type nValues: int
        :type arrValues: OCC.wrapper.gp.gp_XYZ

        """
        return _VrmlData.Handle_VrmlData_Coordinate_SetValues(self, *args)


    def ReadArray(self, *args):
        """
        ReadArray(Handle_VrmlData_Coordinate self, VrmlData_InBuffer & theBuffer, char const * theName, Standard_Boolean const isScale) -> VrmlData_ErrorStatus

        Read the Node from input stream.

        :type theBuffer: OCC.wrapper.VrmlData.VrmlData_InBuffer
        :type theName: const char *
        :type isScale: bool
        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.Handle_VrmlData_Coordinate_ReadArray(self, *args)


    def WriteArray(self, *args):
        """
        WriteArray(Handle_VrmlData_Coordinate self, char const * theName, Standard_Boolean const isScale) -> VrmlData_ErrorStatus

        Write the Node to the output stream currently opened in Scene.

        :type theName: const char *
        :type isScale: bool
        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.Handle_VrmlData_Coordinate_WriteArray(self, *args)


    def IsDefault(self, *args):
        """
        IsDefault(Handle_VrmlData_Coordinate self) -> Standard_Boolean

        Returns True if the node is default, so that it should not be written.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _VrmlData.Handle_VrmlData_Coordinate_IsDefault(self, *args)


    def Scene(self, *args):
        """
        Query the Scene that contains this Node

        :rtype: OCC.wrapper.VrmlData.VrmlData_Scene

        """
        res = _VrmlData.Handle_VrmlData_Coordinate_Scene(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Name(self, *args):
        """
        Name(Handle_VrmlData_Coordinate self) -> char const *

        Query the name

        :rtype: const char *

        """
        return _VrmlData.Handle_VrmlData_Coordinate_Name(self, *args)


    def ReadNode(self, *args):
        """
        ReadNode(Handle_VrmlData_Coordinate self, VrmlData_InBuffer & theBuffer, Handle_VrmlData_Node theNode, Handle_Standard_Type Type=0) -> VrmlData_ErrorStatus

        Read a complete node definition from VRML stream
        @param theBuffer
        Buffer receiving the input data.
        @param theNode
        <tt>[out]</tt> Node restored from the buffer data
        @param Type
        Node type to be checked. If it is NULL(default) no type checking is done.
        Otherwise the created node is matched and an error is returned if
        no match detected.

        :type theBuffer: OCC.wrapper.VrmlData.VrmlData_InBuffer
        :type theNode: OCC.wrapper.VrmlData.Handle_VrmlData_Node
        :type Type: OCC.wrapper.Standard.Handle_Standard_Type
        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.Handle_VrmlData_Coordinate_ReadNode(self, *args)


    def WriteClosing(self, *args):
        """
        WriteClosing(Handle_VrmlData_Coordinate self) -> VrmlData_ErrorStatus

        Write the closing brace in the end of a node output.

        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.Handle_VrmlData_Coordinate_WriteClosing(self, *args)


    def ReadBoolean(self, *args):
        """
        ReadBoolean(Handle_VrmlData_Coordinate self, VrmlData_InBuffer & theBuffer) -> VrmlData_ErrorStatus

        Read one boolean value (TRUE or FALSE).

        :type theBuffer: OCC.wrapper.VrmlData.VrmlData_InBuffer
        :type theResult: bool
        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.Handle_VrmlData_Coordinate_ReadBoolean(self, *args)


    def ReadString(self, *args):
        """
        ReadString(Handle_VrmlData_Coordinate self, VrmlData_InBuffer & theBuffer, TCollection_AsciiString theRes) -> VrmlData_ErrorStatus

        Read one quoted string, the quotes are removed.

        :type theBuffer: OCC.wrapper.VrmlData.VrmlData_InBuffer
        :type theRes: OCC.wrapper.TCollection.TCollection_AsciiString
        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.Handle_VrmlData_Coordinate_ReadString(self, *args)


    def ReadMultiString(self, *args):
        """
        ReadMultiString(Handle_VrmlData_Coordinate self, VrmlData_InBuffer & theBuffer, NCollection_List_TCollection_AsciiString theRes) -> VrmlData_ErrorStatus

        Read one quoted string, the quotes are removed.

        :type theBuffer: OCC.wrapper.VrmlData.VrmlData_InBuffer
        :type theRes: OCC.wrapper.TColStd.NCollection_List_TCollection_AsciiString
        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.Handle_VrmlData_Coordinate_ReadMultiString(self, *args)


    def ReadInteger(self, *args):
        """
        ReadInteger(Handle_VrmlData_Coordinate self, VrmlData_InBuffer & theBuffer) -> VrmlData_ErrorStatus

        Read one integer value.

        :type theBuffer: OCC.wrapper.VrmlData.VrmlData_InBuffer
        :type theResult: long &
        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.Handle_VrmlData_Coordinate_ReadInteger(self, *args)


    def OK(self, *args):
        """
        OK(Handle_VrmlData_Coordinate self, VrmlData_ErrorStatus const theStat) -> Standard_Boolean
        OK(Handle_VrmlData_Coordinate self, VrmlData_ErrorStatus const theStat) -> Standard_Boolean

        :type outStat: OCC.wrapper.VrmlData.VrmlData_ErrorStatus
        :type theStat: OCC.wrapper.VrmlData.VrmlData_ErrorStatus
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _VrmlData.Handle_VrmlData_Coordinate_OK(self, *args)


    def GlobalIndent(self, *args):
        """
        GlobalIndent(Handle_VrmlData_Coordinate self) -> Standard_Integer

        Define the common Indent in spaces, for writing all nodes.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _VrmlData.Handle_VrmlData_Coordinate_GlobalIndent(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_VrmlData_Coordinate self)

        Memory deallocator for transient classes


        """
        return _VrmlData.Handle_VrmlData_Coordinate_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_VrmlData_Coordinate self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_VrmlData_Coordinate self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _VrmlData.Handle_VrmlData_Coordinate_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_VrmlData_Coordinate self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_VrmlData_Coordinate self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _VrmlData.Handle_VrmlData_Coordinate_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_VrmlData_Coordinate self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _VrmlData.Handle_VrmlData_Coordinate_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_VrmlData_Coordinate self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _VrmlData.Handle_VrmlData_Coordinate_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_VrmlData_Coordinate self)

        Increments the reference counter of this object


        """
        return _VrmlData.Handle_VrmlData_Coordinate_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_VrmlData_Coordinate self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _VrmlData.Handle_VrmlData_Coordinate_DecrementRefCounter(self, *args)

Handle_VrmlData_Coordinate_swigregister = _VrmlData.Handle_VrmlData_Coordinate_swigregister
Handle_VrmlData_Coordinate_swigregister(Handle_VrmlData_Coordinate)

def Handle_VrmlData_Coordinate_DownCast(thing):
    return _VrmlData.Handle_VrmlData_Coordinate_DownCast(thing)
Handle_VrmlData_Coordinate_DownCast = _VrmlData.Handle_VrmlData_Coordinate_DownCast

class VrmlData_IndexedLineSet(VrmlData_Geometry):
    """Data type to store a set of polygons."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_VrmlData_IndexedLineSet
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_VrmlData_IndexedLineSet(self) 
            return h


    def __init__(self, *args):
        """
        __init__(VrmlData_IndexedLineSet self) -> VrmlData_IndexedLineSet
        __init__(VrmlData_IndexedLineSet self, VrmlData_Scene theScene, char const * theName, Standard_Boolean const isColorPerVertex) -> VrmlData_IndexedLineSet

        Constructor.

        :type theScene: OCC.wrapper.VrmlData.VrmlData_Scene
        :type theName: const char *
        :type isColorPerVertex: bool

        """
        this = _VrmlData.new_VrmlData_IndexedLineSet(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Coordinates(self, *args):
        """
        Query the Coordinates.

        :rtype: OCC.wrapper.VrmlData.Handle_VrmlData_Coordinate

        """
        res = _VrmlData.VrmlData_IndexedLineSet_Coordinates(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetCoordinates(self, *args):
        """
        SetCoordinates(VrmlData_IndexedLineSet self, Handle_VrmlData_Coordinate theCoord)

        Set the nodes

        :type theCoord: OCC.wrapper.VrmlData.Handle_VrmlData_Coordinate

        """
        return _VrmlData.VrmlData_IndexedLineSet_SetCoordinates(self, *args)


    def Colors(self, *args):
        """
        Query the Colors.

        :rtype: OCC.wrapper.VrmlData.Handle_VrmlData_Color

        """
        res = _VrmlData.VrmlData_IndexedLineSet_Colors(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetColors(self, *args):
        """
        SetColors(VrmlData_IndexedLineSet self, Handle_VrmlData_Color theColors)

        Set the Color node

        :type theColors: OCC.wrapper.VrmlData.Handle_VrmlData_Color

        """
        return _VrmlData.VrmlData_IndexedLineSet_SetColors(self, *args)


    def Polygons(self, *args):
        """
        Polygons(VrmlData_IndexedLineSet self, Standard_Integer const **& arrPolygons) -> size_t

        Query the array of polygons

        :type arrPolygons: int
        :rtype: size_t

        """
        return _VrmlData.VrmlData_IndexedLineSet_Polygons(self, *args)


    def Polygon(self, *args):
        """
        Polygon(VrmlData_IndexedLineSet self, Standard_Integer const iPolygon, Standard_Integer const *& outIndice) -> Standard_Integer

        Query one polygon.
        @param iPolygon
        rank of the polygon [0 .. N-1]
        @param outIndice
        <tt>[out]</tt> array of vertex indice
        @return
        number of vertice in the polygon - the dimension of outIndice array

        :type iPolygon: int
        :type outIndice: int
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _VrmlData.VrmlData_IndexedLineSet_Polygon(self, *args)


    def SetPolygons(self, *args):
        """
        SetPolygons(VrmlData_IndexedLineSet self, Standard_Size const nPolygons, Standard_Integer const ** thePolygons)

        Set the polygons

        :type nPolygons: int
        :type thePolygons: int

        """
        return _VrmlData.VrmlData_IndexedLineSet_SetPolygons(self, *args)


    def ArrayColorInd(self, *args):
        """
        ArrayColorInd(VrmlData_IndexedLineSet self, Standard_Integer const **& arrColorInd) -> size_t

        Query the array of color indice
        @param arrColorInd
        <tt>[out]</tt> array of colorIndex as it is described in VRML2.0 spec
        @return
        Number of integers in the array arrColorInd.

        :type arrColorInd: int
        :rtype: size_t

        """
        return _VrmlData.VrmlData_IndexedLineSet_ArrayColorInd(self, *args)


    def GetColor(self, *args):
        """
        GetColor(VrmlData_IndexedLineSet self, Standard_Integer const iFace, Standard_Integer const iVertex) -> Quantity_Color

        Query a color for one node in the given element. The color is
        interpreted according to fields myColors, myArrColorInd,
        myColorPerVertex, as defined in VRML 2.0.
        @param iFace
        rank of the polygon [0 .. N-1]
        @param iVertex
        rank of the vertex in the polygon [0 .. M-1]. This parameter is ignored
        if (myColorPerVertex == False)
        @return
        Color value (RGB); if the color is indefinite then returns (0., 0., 0.)

        :type iFace: int
        :type iVertex: int
        :rtype: OCC.wrapper.Quantity.Quantity_Color

        """
        return _VrmlData.VrmlData_IndexedLineSet_GetColor(self, *args)


    def SetColorInd(self, *args):
        """
        SetColorInd(VrmlData_IndexedLineSet self, Standard_Size const nIndice, Standard_Integer const ** theIndice)

        Set the colors array of indice

        :type nIndice: int
        :type theIndice: int

        """
        return _VrmlData.VrmlData_IndexedLineSet_SetColorInd(self, *args)


    def SetColorPerVertex(self, *args):
        """
        SetColorPerVertex(VrmlData_IndexedLineSet self, Standard_Boolean const isColorPerVertex)

        Set the boolean value "colorPerVertex"

        :type isColorPerVertex: bool

        """
        return _VrmlData.VrmlData_IndexedLineSet_SetColorPerVertex(self, *args)


    def TShape(self, *args):
        """
        Query the shape. This method checks the flag myIsModified; if True it
        should rebuild the shape presentation.

        :rtype: OCC.wrapper.TopoDS.Handle_TopoDS_TShape

        """
        res = _VrmlData.VrmlData_IndexedLineSet_TShape(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Clone(self, *args):
        """
        Clone(VrmlData_IndexedLineSet self, Handle_VrmlData_Node theOther) -> Handle_VrmlData_Node

        Create a copy of this node.
        If the parameter is null, a new copied node is created. Otherwise new node
        is not created, but rather the given one is modified.

        :type theOther: OCC.wrapper.VrmlData.Handle_VrmlData_Node
        :rtype: OCC.wrapper.VrmlData.Handle_VrmlData_Node

        """
        return _VrmlData.VrmlData_IndexedLineSet_Clone(self, *args)


    def Read(self, *args):
        """
        Read(VrmlData_IndexedLineSet self, VrmlData_InBuffer & theBuffer) -> VrmlData_ErrorStatus

        Read the Node from input stream.

        :type theBuffer: OCC.wrapper.VrmlData.VrmlData_InBuffer
        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.VrmlData_IndexedLineSet_Read(self, *args)


    def Write(self, *args):
        """
        Write(VrmlData_IndexedLineSet self, char const * thePrefix) -> VrmlData_ErrorStatus

        Write the Node to output stream.

        :type thePrefix: const char *
        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.VrmlData_IndexedLineSet_Write(self, *args)


    def IsDefault(self, *args):
        """
        IsDefault(VrmlData_IndexedLineSet self) -> Standard_Boolean

        Returns True if the node is default, so that it should not be written.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _VrmlData.VrmlData_IndexedLineSet_IsDefault(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _VrmlData.VrmlData_IndexedLineSet_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _VrmlData.VrmlData_IndexedLineSet_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _VrmlData.VrmlData_IndexedLineSet_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _VrmlData.delete_VrmlData_IndexedLineSet
VrmlData_IndexedLineSet_swigregister = _VrmlData.VrmlData_IndexedLineSet_swigregister
VrmlData_IndexedLineSet_swigregister(VrmlData_IndexedLineSet)

def VrmlData_IndexedLineSet_get_type_name(*args):
    """
    VrmlData_IndexedLineSet_get_type_name() -> char const *

    :rtype: const char *

    """
    return _VrmlData.VrmlData_IndexedLineSet_get_type_name(*args)

def VrmlData_IndexedLineSet_get_type_descriptor(*args):
    """
    VrmlData_IndexedLineSet_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _VrmlData.VrmlData_IndexedLineSet_get_type_descriptor(*args)

class Handle_VrmlData_Appearance(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_VrmlData_Appearance self)

        Nullify the handle


        """
        return _VrmlData.Handle_VrmlData_Appearance_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_VrmlData_Appearance self) -> bool

        Check for being null

        :rtype: bool

        """
        return _VrmlData.Handle_VrmlData_Appearance_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_VrmlData_Appearance self, VrmlData_Appearance thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _VrmlData.Handle_VrmlData_Appearance_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_VrmlData_Appearance self, Handle_VrmlData_Appearance theHandle) -> Handle_VrmlData_Appearance
        assign(Handle_VrmlData_Appearance self, VrmlData_Appearance thePtr) -> Handle_VrmlData_Appearance
        assign(Handle_VrmlData_Appearance self, Handle_VrmlData_Appearance theHandle) -> Handle_VrmlData_Appearance

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _VrmlData.Handle_VrmlData_Appearance_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_VrmlData_Appearance self) -> VrmlData_Appearance

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _VrmlData.Handle_VrmlData_Appearance_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_VrmlData_Appearance self) -> VrmlData_Appearance

        Member access operator (note non-const)

        :rtype: T *

        """
        return _VrmlData.Handle_VrmlData_Appearance___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_VrmlData_Appearance self) -> VrmlData_Appearance

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _VrmlData.Handle_VrmlData_Appearance___ref__(self, *args)


    def __hash__(self):
        return _VrmlData.Handle_VrmlData_Appearance___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _VrmlData.Handle_VrmlData_Appearance___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _VrmlData.new_Handle_VrmlData_Appearance(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_VrmlData.Handle_VrmlData_Appearance_DownCast)
    __swig_destroy__ = _VrmlData.delete_Handle_VrmlData_Appearance

    def Material(self, *args):
        """
        Query the Material

        :rtype: OCC.wrapper.VrmlData.Handle_VrmlData_Material

        """
        res = _VrmlData.Handle_VrmlData_Appearance_Material(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Texture(self, *args):
        """
        Query the Texture

        :rtype: OCC.wrapper.VrmlData.Handle_VrmlData_Texture

        """
        res = _VrmlData.Handle_VrmlData_Appearance_Texture(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def TextureTransform(self, *args):
        """
        Query the TextureTransform

        :rtype: OCC.wrapper.VrmlData.Handle_VrmlData_TextureTransform

        """
        res = _VrmlData.Handle_VrmlData_Appearance_TextureTransform(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetMaterial(self, *args):
        """
        SetMaterial(Handle_VrmlData_Appearance self, Handle_VrmlData_Material theMat)

        Set the Material

        :type theMat: OCC.wrapper.VrmlData.Handle_VrmlData_Material

        """
        return _VrmlData.Handle_VrmlData_Appearance_SetMaterial(self, *args)


    def SetTexture(self, *args):
        """
        SetTexture(Handle_VrmlData_Appearance self, Handle_VrmlData_Texture theTexture)

        Set the Texture

        :type theTexture: OCC.wrapper.VrmlData.Handle_VrmlData_Texture

        """
        return _VrmlData.Handle_VrmlData_Appearance_SetTexture(self, *args)


    def SetTextureTransform(self, *args):
        """
        SetTextureTransform(Handle_VrmlData_Appearance self, Handle_VrmlData_TextureTransform theTT)

        Set the Texture Transform

        :type theTT: OCC.wrapper.VrmlData.Handle_VrmlData_TextureTransform

        """
        return _VrmlData.Handle_VrmlData_Appearance_SetTextureTransform(self, *args)


    def Clone(self, *args):
        """
        Clone(Handle_VrmlData_Appearance self, Handle_VrmlData_Node arg2) -> Handle_VrmlData_Node

        Create a copy of this node.
        If the parameter is null, a new copied node is created. Otherwise new node
        is not created, but rather the given one is modified.<p>

        :type : OCC.wrapper.VrmlData.Handle_VrmlData_Node
        :rtype: OCC.wrapper.VrmlData.Handle_VrmlData_Node

        """
        return _VrmlData.Handle_VrmlData_Appearance_Clone(self, *args)


    def Read(self, *args):
        """
        Read(Handle_VrmlData_Appearance self, VrmlData_InBuffer & theBuffer) -> VrmlData_ErrorStatus

        Read the node from input stream.

        :type theBuffer: OCC.wrapper.VrmlData.VrmlData_InBuffer
        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.Handle_VrmlData_Appearance_Read(self, *args)


    def Write(self, *args):
        """
        Write(Handle_VrmlData_Appearance self, char const * thePrefix) -> VrmlData_ErrorStatus

        Write the Node from input stream.

        :type thePrefix: const char *
        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.Handle_VrmlData_Appearance_Write(self, *args)


    def IsDefault(self, *args):
        """
        IsDefault(Handle_VrmlData_Appearance self) -> Standard_Boolean

        Returns True if the node is default, so that it should not be written.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _VrmlData.Handle_VrmlData_Appearance_IsDefault(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_VrmlData_Appearance self) -> char const *

        :rtype: const char *

        """
        return _VrmlData.Handle_VrmlData_Appearance_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _VrmlData.Handle_VrmlData_Appearance_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _VrmlData.Handle_VrmlData_Appearance_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Scene(self, *args):
        """
        Query the Scene that contains this Node

        :rtype: OCC.wrapper.VrmlData.VrmlData_Scene

        """
        res = _VrmlData.Handle_VrmlData_Appearance_Scene(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Name(self, *args):
        """
        Name(Handle_VrmlData_Appearance self) -> char const *

        Query the name

        :rtype: const char *

        """
        return _VrmlData.Handle_VrmlData_Appearance_Name(self, *args)


    def ReadNode(self, *args):
        """
        ReadNode(Handle_VrmlData_Appearance self, VrmlData_InBuffer & theBuffer, Handle_VrmlData_Node theNode, Handle_Standard_Type Type=0) -> VrmlData_ErrorStatus

        Read a complete node definition from VRML stream
        @param theBuffer
        Buffer receiving the input data.
        @param theNode
        <tt>[out]</tt> Node restored from the buffer data
        @param Type
        Node type to be checked. If it is NULL(default) no type checking is done.
        Otherwise the created node is matched and an error is returned if
        no match detected.

        :type theBuffer: OCC.wrapper.VrmlData.VrmlData_InBuffer
        :type theNode: OCC.wrapper.VrmlData.Handle_VrmlData_Node
        :type Type: OCC.wrapper.Standard.Handle_Standard_Type
        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.Handle_VrmlData_Appearance_ReadNode(self, *args)


    def WriteClosing(self, *args):
        """
        WriteClosing(Handle_VrmlData_Appearance self) -> VrmlData_ErrorStatus

        Write the closing brace in the end of a node output.

        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.Handle_VrmlData_Appearance_WriteClosing(self, *args)


    def ReadBoolean(self, *args):
        """
        ReadBoolean(Handle_VrmlData_Appearance self, VrmlData_InBuffer & theBuffer) -> VrmlData_ErrorStatus

        Read one boolean value (TRUE or FALSE).

        :type theBuffer: OCC.wrapper.VrmlData.VrmlData_InBuffer
        :type theResult: bool
        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.Handle_VrmlData_Appearance_ReadBoolean(self, *args)


    def ReadString(self, *args):
        """
        ReadString(Handle_VrmlData_Appearance self, VrmlData_InBuffer & theBuffer, TCollection_AsciiString theRes) -> VrmlData_ErrorStatus

        Read one quoted string, the quotes are removed.

        :type theBuffer: OCC.wrapper.VrmlData.VrmlData_InBuffer
        :type theRes: OCC.wrapper.TCollection.TCollection_AsciiString
        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.Handle_VrmlData_Appearance_ReadString(self, *args)


    def ReadMultiString(self, *args):
        """
        ReadMultiString(Handle_VrmlData_Appearance self, VrmlData_InBuffer & theBuffer, NCollection_List_TCollection_AsciiString theRes) -> VrmlData_ErrorStatus

        Read one quoted string, the quotes are removed.

        :type theBuffer: OCC.wrapper.VrmlData.VrmlData_InBuffer
        :type theRes: OCC.wrapper.TColStd.NCollection_List_TCollection_AsciiString
        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.Handle_VrmlData_Appearance_ReadMultiString(self, *args)


    def ReadInteger(self, *args):
        """
        ReadInteger(Handle_VrmlData_Appearance self, VrmlData_InBuffer & theBuffer) -> VrmlData_ErrorStatus

        Read one integer value.

        :type theBuffer: OCC.wrapper.VrmlData.VrmlData_InBuffer
        :type theResult: long &
        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.Handle_VrmlData_Appearance_ReadInteger(self, *args)


    def OK(self, *args):
        """
        OK(Handle_VrmlData_Appearance self, VrmlData_ErrorStatus const theStat) -> Standard_Boolean
        OK(Handle_VrmlData_Appearance self, VrmlData_ErrorStatus const theStat) -> Standard_Boolean

        :type outStat: OCC.wrapper.VrmlData.VrmlData_ErrorStatus
        :type theStat: OCC.wrapper.VrmlData.VrmlData_ErrorStatus
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _VrmlData.Handle_VrmlData_Appearance_OK(self, *args)


    def GlobalIndent(self, *args):
        """
        GlobalIndent(Handle_VrmlData_Appearance self) -> Standard_Integer

        Define the common Indent in spaces, for writing all nodes.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _VrmlData.Handle_VrmlData_Appearance_GlobalIndent(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_VrmlData_Appearance self)

        Memory deallocator for transient classes


        """
        return _VrmlData.Handle_VrmlData_Appearance_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_VrmlData_Appearance self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_VrmlData_Appearance self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _VrmlData.Handle_VrmlData_Appearance_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_VrmlData_Appearance self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_VrmlData_Appearance self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _VrmlData.Handle_VrmlData_Appearance_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_VrmlData_Appearance self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _VrmlData.Handle_VrmlData_Appearance_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_VrmlData_Appearance self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _VrmlData.Handle_VrmlData_Appearance_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_VrmlData_Appearance self)

        Increments the reference counter of this object


        """
        return _VrmlData.Handle_VrmlData_Appearance_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_VrmlData_Appearance self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _VrmlData.Handle_VrmlData_Appearance_DecrementRefCounter(self, *args)

Handle_VrmlData_Appearance_swigregister = _VrmlData.Handle_VrmlData_Appearance_swigregister
Handle_VrmlData_Appearance_swigregister(Handle_VrmlData_Appearance)

def Handle_VrmlData_Appearance_DownCast(thing):
    return _VrmlData.Handle_VrmlData_Appearance_DownCast(thing)
Handle_VrmlData_Appearance_DownCast = _VrmlData.Handle_VrmlData_Appearance_DownCast

class Handle_VrmlData_IndexedLineSet(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_VrmlData_IndexedLineSet self)

        Nullify the handle


        """
        return _VrmlData.Handle_VrmlData_IndexedLineSet_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_VrmlData_IndexedLineSet self) -> bool

        Check for being null

        :rtype: bool

        """
        return _VrmlData.Handle_VrmlData_IndexedLineSet_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_VrmlData_IndexedLineSet self, VrmlData_IndexedLineSet thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _VrmlData.Handle_VrmlData_IndexedLineSet_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_VrmlData_IndexedLineSet self, Handle_VrmlData_IndexedLineSet theHandle) -> Handle_VrmlData_IndexedLineSet
        assign(Handle_VrmlData_IndexedLineSet self, VrmlData_IndexedLineSet thePtr) -> Handle_VrmlData_IndexedLineSet
        assign(Handle_VrmlData_IndexedLineSet self, Handle_VrmlData_IndexedLineSet theHandle) -> Handle_VrmlData_IndexedLineSet

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _VrmlData.Handle_VrmlData_IndexedLineSet_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_VrmlData_IndexedLineSet self) -> VrmlData_IndexedLineSet

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _VrmlData.Handle_VrmlData_IndexedLineSet_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_VrmlData_IndexedLineSet self) -> VrmlData_IndexedLineSet

        Member access operator (note non-const)

        :rtype: T *

        """
        return _VrmlData.Handle_VrmlData_IndexedLineSet___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_VrmlData_IndexedLineSet self) -> VrmlData_IndexedLineSet

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _VrmlData.Handle_VrmlData_IndexedLineSet___ref__(self, *args)


    def __hash__(self):
        return _VrmlData.Handle_VrmlData_IndexedLineSet___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _VrmlData.Handle_VrmlData_IndexedLineSet___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _VrmlData.new_Handle_VrmlData_IndexedLineSet(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_VrmlData.Handle_VrmlData_IndexedLineSet_DownCast)
    __swig_destroy__ = _VrmlData.delete_Handle_VrmlData_IndexedLineSet

    def Coordinates(self, *args):
        """
        Query the Coordinates.

        :rtype: OCC.wrapper.VrmlData.Handle_VrmlData_Coordinate

        """
        res = _VrmlData.Handle_VrmlData_IndexedLineSet_Coordinates(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetCoordinates(self, *args):
        """
        SetCoordinates(Handle_VrmlData_IndexedLineSet self, Handle_VrmlData_Coordinate theCoord)

        Set the nodes

        :type theCoord: OCC.wrapper.VrmlData.Handle_VrmlData_Coordinate

        """
        return _VrmlData.Handle_VrmlData_IndexedLineSet_SetCoordinates(self, *args)


    def Colors(self, *args):
        """
        Query the Colors.

        :rtype: OCC.wrapper.VrmlData.Handle_VrmlData_Color

        """
        res = _VrmlData.Handle_VrmlData_IndexedLineSet_Colors(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetColors(self, *args):
        """
        SetColors(Handle_VrmlData_IndexedLineSet self, Handle_VrmlData_Color theColors)

        Set the Color node

        :type theColors: OCC.wrapper.VrmlData.Handle_VrmlData_Color

        """
        return _VrmlData.Handle_VrmlData_IndexedLineSet_SetColors(self, *args)


    def Polygons(self, *args):
        """
        Polygons(Handle_VrmlData_IndexedLineSet self, Standard_Integer const **& arrPolygons) -> size_t

        Query the array of polygons

        :type arrPolygons: int
        :rtype: size_t

        """
        return _VrmlData.Handle_VrmlData_IndexedLineSet_Polygons(self, *args)


    def Polygon(self, *args):
        """
        Polygon(Handle_VrmlData_IndexedLineSet self, Standard_Integer const iPolygon, Standard_Integer const *& outIndice) -> Standard_Integer

        Query one polygon.
        @param iPolygon
        rank of the polygon [0 .. N-1]
        @param outIndice
        <tt>[out]</tt> array of vertex indice
        @return
        number of vertice in the polygon - the dimension of outIndice array

        :type iPolygon: int
        :type outIndice: int
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _VrmlData.Handle_VrmlData_IndexedLineSet_Polygon(self, *args)


    def SetPolygons(self, *args):
        """
        SetPolygons(Handle_VrmlData_IndexedLineSet self, Standard_Size const nPolygons, Standard_Integer const ** thePolygons)

        Set the polygons

        :type nPolygons: int
        :type thePolygons: int

        """
        return _VrmlData.Handle_VrmlData_IndexedLineSet_SetPolygons(self, *args)


    def ArrayColorInd(self, *args):
        """
        ArrayColorInd(Handle_VrmlData_IndexedLineSet self, Standard_Integer const **& arrColorInd) -> size_t

        Query the array of color indice
        @param arrColorInd
        <tt>[out]</tt> array of colorIndex as it is described in VRML2.0 spec
        @return
        Number of integers in the array arrColorInd.

        :type arrColorInd: int
        :rtype: size_t

        """
        return _VrmlData.Handle_VrmlData_IndexedLineSet_ArrayColorInd(self, *args)


    def GetColor(self, *args):
        """
        GetColor(Handle_VrmlData_IndexedLineSet self, Standard_Integer const iFace, Standard_Integer const iVertex) -> Quantity_Color

        Query a color for one node in the given element. The color is
        interpreted according to fields myColors, myArrColorInd,
        myColorPerVertex, as defined in VRML 2.0.
        @param iFace
        rank of the polygon [0 .. N-1]
        @param iVertex
        rank of the vertex in the polygon [0 .. M-1]. This parameter is ignored
        if (myColorPerVertex == False)
        @return
        Color value (RGB); if the color is indefinite then returns (0., 0., 0.)

        :type iFace: int
        :type iVertex: int
        :rtype: OCC.wrapper.Quantity.Quantity_Color

        """
        return _VrmlData.Handle_VrmlData_IndexedLineSet_GetColor(self, *args)


    def SetColorInd(self, *args):
        """
        SetColorInd(Handle_VrmlData_IndexedLineSet self, Standard_Size const nIndice, Standard_Integer const ** theIndice)

        Set the colors array of indice

        :type nIndice: int
        :type theIndice: int

        """
        return _VrmlData.Handle_VrmlData_IndexedLineSet_SetColorInd(self, *args)


    def SetColorPerVertex(self, *args):
        """
        SetColorPerVertex(Handle_VrmlData_IndexedLineSet self, Standard_Boolean const isColorPerVertex)

        Set the boolean value "colorPerVertex"

        :type isColorPerVertex: bool

        """
        return _VrmlData.Handle_VrmlData_IndexedLineSet_SetColorPerVertex(self, *args)


    def TShape(self, *args):
        """
        Query the shape. This method checks the flag myIsModified; if True it
        should rebuild the shape presentation.

        :rtype: OCC.wrapper.TopoDS.Handle_TopoDS_TShape

        """
        res = _VrmlData.Handle_VrmlData_IndexedLineSet_TShape(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Clone(self, *args):
        """
        Clone(Handle_VrmlData_IndexedLineSet self, Handle_VrmlData_Node theOther) -> Handle_VrmlData_Node

        Create a copy of this node.
        If the parameter is null, a new copied node is created. Otherwise new node
        is not created, but rather the given one is modified.

        :type theOther: OCC.wrapper.VrmlData.Handle_VrmlData_Node
        :rtype: OCC.wrapper.VrmlData.Handle_VrmlData_Node

        """
        return _VrmlData.Handle_VrmlData_IndexedLineSet_Clone(self, *args)


    def Read(self, *args):
        """
        Read(Handle_VrmlData_IndexedLineSet self, VrmlData_InBuffer & theBuffer) -> VrmlData_ErrorStatus

        Read the Node from input stream.

        :type theBuffer: OCC.wrapper.VrmlData.VrmlData_InBuffer
        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.Handle_VrmlData_IndexedLineSet_Read(self, *args)


    def Write(self, *args):
        """
        Write(Handle_VrmlData_IndexedLineSet self, char const * thePrefix) -> VrmlData_ErrorStatus

        Write the Node to output stream.

        :type thePrefix: const char *
        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.Handle_VrmlData_IndexedLineSet_Write(self, *args)


    def IsDefault(self, *args):
        """
        IsDefault(Handle_VrmlData_IndexedLineSet self) -> Standard_Boolean

        Returns True if the node is default, so that it should not be written.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _VrmlData.Handle_VrmlData_IndexedLineSet_IsDefault(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_VrmlData_IndexedLineSet self) -> char const *

        :rtype: const char *

        """
        return _VrmlData.Handle_VrmlData_IndexedLineSet_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _VrmlData.Handle_VrmlData_IndexedLineSet_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _VrmlData.Handle_VrmlData_IndexedLineSet_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Scene(self, *args):
        """
        Query the Scene that contains this Node

        :rtype: OCC.wrapper.VrmlData.VrmlData_Scene

        """
        res = _VrmlData.Handle_VrmlData_IndexedLineSet_Scene(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Name(self, *args):
        """
        Name(Handle_VrmlData_IndexedLineSet self) -> char const *

        Query the name

        :rtype: const char *

        """
        return _VrmlData.Handle_VrmlData_IndexedLineSet_Name(self, *args)


    def ReadNode(self, *args):
        """
        ReadNode(Handle_VrmlData_IndexedLineSet self, VrmlData_InBuffer & theBuffer, Handle_VrmlData_Node theNode, Handle_Standard_Type Type=0) -> VrmlData_ErrorStatus

        Read a complete node definition from VRML stream
        @param theBuffer
        Buffer receiving the input data.
        @param theNode
        <tt>[out]</tt> Node restored from the buffer data
        @param Type
        Node type to be checked. If it is NULL(default) no type checking is done.
        Otherwise the created node is matched and an error is returned if
        no match detected.

        :type theBuffer: OCC.wrapper.VrmlData.VrmlData_InBuffer
        :type theNode: OCC.wrapper.VrmlData.Handle_VrmlData_Node
        :type Type: OCC.wrapper.Standard.Handle_Standard_Type
        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.Handle_VrmlData_IndexedLineSet_ReadNode(self, *args)


    def WriteClosing(self, *args):
        """
        WriteClosing(Handle_VrmlData_IndexedLineSet self) -> VrmlData_ErrorStatus

        Write the closing brace in the end of a node output.

        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.Handle_VrmlData_IndexedLineSet_WriteClosing(self, *args)


    def ReadBoolean(self, *args):
        """
        ReadBoolean(Handle_VrmlData_IndexedLineSet self, VrmlData_InBuffer & theBuffer) -> VrmlData_ErrorStatus

        Read one boolean value (TRUE or FALSE).

        :type theBuffer: OCC.wrapper.VrmlData.VrmlData_InBuffer
        :type theResult: bool
        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.Handle_VrmlData_IndexedLineSet_ReadBoolean(self, *args)


    def ReadString(self, *args):
        """
        ReadString(Handle_VrmlData_IndexedLineSet self, VrmlData_InBuffer & theBuffer, TCollection_AsciiString theRes) -> VrmlData_ErrorStatus

        Read one quoted string, the quotes are removed.

        :type theBuffer: OCC.wrapper.VrmlData.VrmlData_InBuffer
        :type theRes: OCC.wrapper.TCollection.TCollection_AsciiString
        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.Handle_VrmlData_IndexedLineSet_ReadString(self, *args)


    def ReadMultiString(self, *args):
        """
        ReadMultiString(Handle_VrmlData_IndexedLineSet self, VrmlData_InBuffer & theBuffer, NCollection_List_TCollection_AsciiString theRes) -> VrmlData_ErrorStatus

        Read one quoted string, the quotes are removed.

        :type theBuffer: OCC.wrapper.VrmlData.VrmlData_InBuffer
        :type theRes: OCC.wrapper.TColStd.NCollection_List_TCollection_AsciiString
        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.Handle_VrmlData_IndexedLineSet_ReadMultiString(self, *args)


    def ReadInteger(self, *args):
        """
        ReadInteger(Handle_VrmlData_IndexedLineSet self, VrmlData_InBuffer & theBuffer) -> VrmlData_ErrorStatus

        Read one integer value.

        :type theBuffer: OCC.wrapper.VrmlData.VrmlData_InBuffer
        :type theResult: long &
        :rtype: OCC.wrapper.VrmlData.VrmlData_ErrorStatus

        """
        return _VrmlData.Handle_VrmlData_IndexedLineSet_ReadInteger(self, *args)


    def OK(self, *args):
        """
        OK(Handle_VrmlData_IndexedLineSet self, VrmlData_ErrorStatus const theStat) -> Standard_Boolean
        OK(Handle_VrmlData_IndexedLineSet self, VrmlData_ErrorStatus const theStat) -> Standard_Boolean

        :type outStat: OCC.wrapper.VrmlData.VrmlData_ErrorStatus
        :type theStat: OCC.wrapper.VrmlData.VrmlData_ErrorStatus
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _VrmlData.Handle_VrmlData_IndexedLineSet_OK(self, *args)


    def GlobalIndent(self, *args):
        """
        GlobalIndent(Handle_VrmlData_IndexedLineSet self) -> Standard_Integer

        Define the common Indent in spaces, for writing all nodes.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _VrmlData.Handle_VrmlData_IndexedLineSet_GlobalIndent(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_VrmlData_IndexedLineSet self)

        Memory deallocator for transient classes


        """
        return _VrmlData.Handle_VrmlData_IndexedLineSet_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_VrmlData_IndexedLineSet self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_VrmlData_IndexedLineSet self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _VrmlData.Handle_VrmlData_IndexedLineSet_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_VrmlData_IndexedLineSet self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_VrmlData_IndexedLineSet self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _VrmlData.Handle_VrmlData_IndexedLineSet_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_VrmlData_IndexedLineSet self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _VrmlData.Handle_VrmlData_IndexedLineSet_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_VrmlData_IndexedLineSet self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _VrmlData.Handle_VrmlData_IndexedLineSet_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_VrmlData_IndexedLineSet self)

        Increments the reference counter of this object


        """
        return _VrmlData.Handle_VrmlData_IndexedLineSet_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_VrmlData_IndexedLineSet self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _VrmlData.Handle_VrmlData_IndexedLineSet_DecrementRefCounter(self, *args)

Handle_VrmlData_IndexedLineSet_swigregister = _VrmlData.Handle_VrmlData_IndexedLineSet_swigregister
Handle_VrmlData_IndexedLineSet_swigregister(Handle_VrmlData_IndexedLineSet)

def Handle_VrmlData_IndexedLineSet_DownCast(thing):
    return _VrmlData.Handle_VrmlData_IndexedLineSet_DownCast(thing)
Handle_VrmlData_IndexedLineSet_DownCast = _VrmlData.Handle_VrmlData_IndexedLineSet_DownCast




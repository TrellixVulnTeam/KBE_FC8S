# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_TNaming')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_TNaming')
    _TNaming = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_TNaming', [dirname(__file__)])
        except ImportError:
            import _TNaming
            return _TNaming
        try:
            _mod = imp.load_module('_TNaming', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _TNaming = swig_import_helper()
    del swig_import_helper
else:
    import _TNaming
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


class SwigPyIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _TNaming.delete_SwigPyIterator

    def value(self):
        return _TNaming.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _TNaming.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _TNaming.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _TNaming.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _TNaming.SwigPyIterator_equal(self, x)

    def copy(self):
        return _TNaming.SwigPyIterator_copy(self)

    def next(self):
        return _TNaming.SwigPyIterator_next(self)

    def __next__(self):
        return _TNaming.SwigPyIterator___next__(self)

    def previous(self):
        return _TNaming.SwigPyIterator_previous(self)

    def advance(self, n):
        return _TNaming.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _TNaming.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _TNaming.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _TNaming.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _TNaming.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _TNaming.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _TNaming.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self
SwigPyIterator_swigregister = _TNaming.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

class NCollection_CellFilter_InspectorXYZ(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _TNaming.NCollection_CellFilter_InspectorXYZ_Dimension
    Coord = staticmethod(_TNaming.NCollection_CellFilter_InspectorXYZ_Coord)

    def Shift(self, thePnt, theTol):
        return _TNaming.NCollection_CellFilter_InspectorXYZ_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _TNaming.new_NCollection_CellFilter_InspectorXYZ()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _TNaming.delete_NCollection_CellFilter_InspectorXYZ
NCollection_CellFilter_InspectorXYZ_swigregister = _TNaming.NCollection_CellFilter_InspectorXYZ_swigregister
NCollection_CellFilter_InspectorXYZ_swigregister(NCollection_CellFilter_InspectorXYZ)

def NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt):
    return _TNaming.NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt)
NCollection_CellFilter_InspectorXYZ_Coord = _TNaming.NCollection_CellFilter_InspectorXYZ_Coord

class NCollection_CellFilter_InspectorXY(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _TNaming.NCollection_CellFilter_InspectorXY_Dimension
    Coord = staticmethod(_TNaming.NCollection_CellFilter_InspectorXY_Coord)

    def Shift(self, thePnt, theTol):
        return _TNaming.NCollection_CellFilter_InspectorXY_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _TNaming.new_NCollection_CellFilter_InspectorXY()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _TNaming.delete_NCollection_CellFilter_InspectorXY
NCollection_CellFilter_InspectorXY_swigregister = _TNaming.NCollection_CellFilter_InspectorXY_swigregister
NCollection_CellFilter_InspectorXY_swigregister(NCollection_CellFilter_InspectorXY)

def NCollection_CellFilter_InspectorXY_Coord(i, thePnt):
    return _TNaming.NCollection_CellFilter_InspectorXY_Coord(i, thePnt)
NCollection_CellFilter_InspectorXY_Coord = _TNaming.NCollection_CellFilter_InspectorXY_Coord


def ptr_to_number(item):
    return _TNaming.ptr_to_number(item)
ptr_to_number = _TNaming.ptr_to_number

def HashCode(*args):
    return _TNaming.HashCode(*args)
HashCode = _TNaming.HashCode

def ptr_equal(a, b):
    return _TNaming.ptr_equal(a, b)
ptr_equal = _TNaming.ptr_equal
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import NCollection
else:
    import NCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Standard
else:
    import Standard
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import gp
else:
    import gp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColStd
else:
    import TColStd
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TCollection
else:
    import TCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TDF
else:
    import TDF
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopAbs
else:
    import TopAbs
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopLoc
else:
    import TopLoc
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopoDS
else:
    import TopoDS
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Message
else:
    import Message
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopTools
else:
    import TopTools
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Bnd
else:
    import Bnd
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColgp
else:
    import TColgp
del _swig_python_version_info
TNaming_PRIMITIVE = _TNaming.TNaming_PRIMITIVE
TNaming_GENERATED = _TNaming.TNaming_GENERATED
TNaming_MODIFY = _TNaming.TNaming_MODIFY
TNaming_DELETE = _TNaming.TNaming_DELETE
TNaming_REPLACE = _TNaming.TNaming_REPLACE
TNaming_SELECTED = _TNaming.TNaming_SELECTED
TNaming_UNKNOWN = _TNaming.TNaming_UNKNOWN
TNaming_IDENTITY = _TNaming.TNaming_IDENTITY
TNaming_MODIFUNTIL = _TNaming.TNaming_MODIFUNTIL
TNaming_GENERATION = _TNaming.TNaming_GENERATION
TNaming_INTERSECTION = _TNaming.TNaming_INTERSECTION
TNaming_UNION = _TNaming.TNaming_UNION
TNaming_SUBSTRACTION = _TNaming.TNaming_SUBSTRACTION
TNaming_CONSTSHAPE = _TNaming.TNaming_CONSTSHAPE
TNaming_FILTERBYNEIGHBOURGS = _TNaming.TNaming_FILTERBYNEIGHBOURGS
TNaming_ORIENTATION = _TNaming.TNaming_ORIENTATION
TNaming_WIREIN = _TNaming.TNaming_WIREIN
TNaming_SHELLIN = _TNaming.TNaming_SHELLIN
class TNaming_NamedShape(TDF.TDF_Attribute):
    """
    The basis to define an attribute for the storage of
    topology and naming data.
    This attribute contains two parts:
    -   The type of evolution, a term of the
    enumeration TNaming_Evolution
    -   A list of pairs of shapes called the "old"
    shape and the "new" shape. The meaning
    depends on the type of evolution.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_TNaming_NamedShape
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_TNaming_NamedShape(self) 
            return h


    def GetID(*args):
        """
        GetID() -> Standard_GUID

        class method
        ============
        Returns the GUID for named shapes.

        :rtype: OCC.wrapper.Standard.Standard_GUID

        """
        return _TNaming.TNaming_NamedShape_GetID(*args)

    GetID = staticmethod(GetID)

    def __init__(self, *args):
        """
        __init__(TNaming_NamedShape self) -> TNaming_NamedShape

        The basis to define an attribute for the storage of
        topology and naming data.
        This attribute contains two parts:
        -   The type of evolution, a term of the
        enumeration TNaming_Evolution
        -   A list of pairs of shapes called the "old"
        shape and the "new" shape. The meaning
        depends on the type of evolution.
        """
        this = _TNaming.new_TNaming_NamedShape(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def IsEmpty(self, *args):
        """
        IsEmpty(TNaming_NamedShape self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TNaming.TNaming_NamedShape_IsEmpty(self, *args)


    def Get(self, *args):
        """
        Get(TNaming_NamedShape self) -> TopoDS_Shape

        Returns the shapes contained in <NS>. Returns a null
        shape if IsEmpty.

        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _TNaming.TNaming_NamedShape_Get(self, *args)


    def Evolution(self, *args):
        """
        Evolution(TNaming_NamedShape self) -> TNaming_Evolution

        Returns the Evolution of the attribute.

        :rtype: OCC.wrapper.TNaming.TNaming_Evolution

        """
        return _TNaming.TNaming_NamedShape_Evolution(self, *args)


    def Version(self, *args):
        """
        Version(TNaming_NamedShape self) -> Standard_Integer

        Returns the Version of the attribute.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TNaming.TNaming_NamedShape_Version(self, *args)


    def SetVersion(self, *args):
        """
        SetVersion(TNaming_NamedShape self, Standard_Integer const version)

        Set the Version of the attribute.

        :type version: int

        """
        return _TNaming.TNaming_NamedShape_SetVersion(self, *args)


    def Clear(self, *args):
        """Clear(TNaming_NamedShape self)"""
        return _TNaming.TNaming_NamedShape_Clear(self, *args)


    def ID(self, *args):
        """
        Returns the ID of the attribute.

        :rtype: OCC.wrapper.Standard.Standard_GUID

        """
        res = _TNaming.TNaming_NamedShape_ID(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def BackupCopy(self, *args):
        """
        BackupCopy(TNaming_NamedShape self) -> Handle_TDF_Attribute

        Copies  the attribute  contents into  a  new other
        attribute. It is used by Backup().

        :rtype: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TNaming.TNaming_NamedShape_BackupCopy(self, *args)


    def Restore(self, *args):
        """
        Restore(TNaming_NamedShape self, Handle_TDF_Attribute anAttribute)

        Restores the contents from <anAttribute> into this
        one. It is used when aborting a transaction.

        :type anAttribute: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TNaming.TNaming_NamedShape_Restore(self, *args)


    def DeltaOnRemoval(self, *args):
        """
        DeltaOnRemoval(TNaming_NamedShape self) -> Handle_TDF_DeltaOnRemoval

        Makes a DeltaOnRemoval on <me> because <me> has
        disappeared from the DS.

        :rtype: OCC.wrapper.TDF.Handle_TDF_DeltaOnRemoval

        """
        return _TNaming.TNaming_NamedShape_DeltaOnRemoval(self, *args)


    def NewEmpty(self, *args):
        """
        NewEmpty(TNaming_NamedShape self) -> Handle_TDF_Attribute

        Returns an new empty attribute from the good end
        type. It is used by the copy algorithm.

        :rtype: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TNaming.TNaming_NamedShape_NewEmpty(self, *args)


    def Paste(self, *args):
        """
        Paste(TNaming_NamedShape self, Handle_TDF_Attribute intoAttribute, Handle_TDF_RelocationTable aRelocTationable)

        This method is different from the "Copy" one,
        because it is used when copying an attribute from
        a source structure into a target structure. This
        method pastes the current attribute to the label
        corresponding to the insertor. The pasted
        attribute may be a brand new one or a new version
        of the previous one.

        :type intoAttribute: OCC.wrapper.TDF.Handle_TDF_Attribute
        :type aRelocTationable: OCC.wrapper.TDF.Handle_TDF_RelocationTable

        """
        return _TNaming.TNaming_NamedShape_Paste(self, *args)


    def References(self, *args):
        """
        References(TNaming_NamedShape self, Handle_TDF_DataSet aDataSet)

        Adds the directly referenced attributes and labels
        to <aDataSet>. "Directly" means we have only to
        look at the first level of references.

        :type aDataSet: OCC.wrapper.TDF.Handle_TDF_DataSet

        """
        return _TNaming.TNaming_NamedShape_References(self, *args)


    def BeforeRemoval(self, *args):
        """
        BeforeRemoval(TNaming_NamedShape self)

        Something to do before removing an Attribute from
        a label.


        """
        return _TNaming.TNaming_NamedShape_BeforeRemoval(self, *args)


    def BeforeUndo(self, *args):
        """
        BeforeUndo(TNaming_NamedShape self, Handle_TDF_AttributeDelta anAttDelta, Standard_Boolean const forceIt) -> Standard_Boolean

        Something to do before applying <anAttDelta>

        :type anAttDelta: OCC.wrapper.TDF.Handle_TDF_AttributeDelta
        :type forceIt: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TNaming.TNaming_NamedShape_BeforeUndo(self, *args)


    def AfterUndo(self, *args):
        """
        AfterUndo(TNaming_NamedShape self, Handle_TDF_AttributeDelta anAttDelta, Standard_Boolean const forceIt) -> Standard_Boolean

        Something to do after applying <anAttDelta>.

        :type anAttDelta: OCC.wrapper.TDF.Handle_TDF_AttributeDelta
        :type forceIt: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TNaming.TNaming_NamedShape_AfterUndo(self, *args)


    def Dump(self, *args):
        """
        Dump(TNaming_NamedShape self, Standard_OStream & anOS) -> Standard_OStream &

        Dumps the attribute on <aStream>.

        :type anOS: OCC.wrapper.Standard.Standard_OStream
        :rtype: OCC.wrapper.Standard.Standard_OStream

        """
        return _TNaming.TNaming_NamedShape_Dump(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _TNaming.TNaming_NamedShape_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _TNaming.TNaming_NamedShape_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TNaming.TNaming_NamedShape_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _TNaming.delete_TNaming_NamedShape
TNaming_NamedShape_swigregister = _TNaming.TNaming_NamedShape_swigregister
TNaming_NamedShape_swigregister(TNaming_NamedShape)

def TNaming_NamedShape_GetID(*args):
    """
    TNaming_NamedShape_GetID() -> Standard_GUID

    class method
    ============
    Returns the GUID for named shapes.

    :rtype: OCC.wrapper.Standard.Standard_GUID

    """
    return _TNaming.TNaming_NamedShape_GetID(*args)

def TNaming_NamedShape_get_type_name(*args):
    """
    TNaming_NamedShape_get_type_name() -> char const *

    :rtype: const char *

    """
    return _TNaming.TNaming_NamedShape_get_type_name(*args)

def TNaming_NamedShape_get_type_descriptor(*args):
    """
    TNaming_NamedShape_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _TNaming.TNaming_NamedShape_get_type_descriptor(*args)

class TNaming_UsedShapes(TDF.TDF_Attribute):
    """
    Global attribute located under root label to store all
    the shapes handled by the framework
    Set of Shapes Used in a Data from TDF
    Only one instance by Data, it always
    Stored as Attribute of The Root.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_TNaming_UsedShapes
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_TNaming_UsedShapes(self) 
            return h


    def Destroy(self, *args):
        """Destroy(TNaming_UsedShapes self)"""
        return _TNaming.TNaming_UsedShapes_Destroy(self, *args)


    def Map(self, *args):
        """
        Map(TNaming_UsedShapes self) -> NCollection_DataMap_TopoDS_Shape_TNaming_PtrRefShape_TopTools_ShapeMapHasher

        :rtype: OCC.wrapper.TNaming.TNaming_DataMapOfShapePtrRefShape

        """
        return _TNaming.TNaming_UsedShapes_Map(self, *args)


    def ID(self, *args):
        """
        Returns the ID of the attribute.

        :rtype: OCC.wrapper.Standard.Standard_GUID

        """
        res = _TNaming.TNaming_UsedShapes_ID(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def GetID(*args):
        """
        GetID() -> Standard_GUID

        Returns the ID: 2a96b614-ec8b-11d0-bee7-080009dc3333.

        :rtype: OCC.wrapper.Standard.Standard_GUID

        """
        return _TNaming.TNaming_UsedShapes_GetID(*args)

    GetID = staticmethod(GetID)

    def BackupCopy(self, *args):
        """
        BackupCopy(TNaming_UsedShapes self) -> Handle_TDF_Attribute

        Copies  the attribute  contents into  a  new other
        attribute. It is used by Backup().

        :rtype: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TNaming.TNaming_UsedShapes_BackupCopy(self, *args)


    def Restore(self, *args):
        """
        Restore(TNaming_UsedShapes self, Handle_TDF_Attribute anAttribute)

        Restores the contents from <anAttribute> into this
        one. It is used when aborting a transaction.

        :type anAttribute: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TNaming.TNaming_UsedShapes_Restore(self, *args)


    def BeforeRemoval(self, *args):
        """
        BeforeRemoval(TNaming_UsedShapes self)

        Clears the table.


        """
        return _TNaming.TNaming_UsedShapes_BeforeRemoval(self, *args)


    def AfterUndo(self, *args):
        """
        AfterUndo(TNaming_UsedShapes self, Handle_TDF_AttributeDelta anAttDelta, Standard_Boolean const forceIt) -> Standard_Boolean

        Something to do after applying <anAttDelta>.

        :type anAttDelta: OCC.wrapper.TDF.Handle_TDF_AttributeDelta
        :type forceIt: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TNaming.TNaming_UsedShapes_AfterUndo(self, *args)


    def DeltaOnAddition(self, *args):
        """
        DeltaOnAddition(TNaming_UsedShapes self) -> Handle_TDF_DeltaOnAddition

        this method returns a null handle (no delta).

        :rtype: OCC.wrapper.TDF.Handle_TDF_DeltaOnAddition

        """
        return _TNaming.TNaming_UsedShapes_DeltaOnAddition(self, *args)


    def DeltaOnRemoval(self, *args):
        """
        DeltaOnRemoval(TNaming_UsedShapes self) -> Handle_TDF_DeltaOnRemoval

        this method returns a null handle (no delta).

        :rtype: OCC.wrapper.TDF.Handle_TDF_DeltaOnRemoval

        """
        return _TNaming.TNaming_UsedShapes_DeltaOnRemoval(self, *args)


    def NewEmpty(self, *args):
        """
        NewEmpty(TNaming_UsedShapes self) -> Handle_TDF_Attribute

        Returns an new empty attribute from the good end
        type. It is used by the copy algorithm.

        :rtype: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TNaming.TNaming_UsedShapes_NewEmpty(self, *args)


    def Paste(self, *args):
        """
        Paste(TNaming_UsedShapes self, Handle_TDF_Attribute intoAttribute, Handle_TDF_RelocationTable aRelocTationable)

        This method is different from the "Copy" one,
        because it is used when copying an attribute from
        a source structure into a target structure. This
        method pastes the current attribute to the label
        corresponding to the insertor. The pasted
        attribute may be a brand new one or a new version
        of the previous one.

        :type intoAttribute: OCC.wrapper.TDF.Handle_TDF_Attribute
        :type aRelocTationable: OCC.wrapper.TDF.Handle_TDF_RelocationTable

        """
        return _TNaming.TNaming_UsedShapes_Paste(self, *args)


    def References(self, *args):
        """
        References(TNaming_UsedShapes self, Handle_TDF_DataSet aDataSet)

        Adds the directly referenced attributes and labels
        to <aDataSet>. "Directly" means we have only to
        look at the first level of references.

        For this, use only the AddLabel() & AddAttribute()
        from DataSet and do not try to modify information
        previously stored in <aDataSet>.

        :type aDataSet: OCC.wrapper.TDF.Handle_TDF_DataSet

        """
        return _TNaming.TNaming_UsedShapes_References(self, *args)


    def Dump(self, *args):
        """
        Dump(TNaming_UsedShapes self, Standard_OStream & anOS) -> Standard_OStream &

        Dumps the attribute on <aStream>.

        :type anOS: OCC.wrapper.Standard.Standard_OStream
        :rtype: OCC.wrapper.Standard.Standard_OStream

        """
        return _TNaming.TNaming_UsedShapes_Dump(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _TNaming.TNaming_UsedShapes_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _TNaming.TNaming_UsedShapes_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TNaming.TNaming_UsedShapes_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _TNaming.delete_TNaming_UsedShapes
TNaming_UsedShapes_swigregister = _TNaming.TNaming_UsedShapes_swigregister
TNaming_UsedShapes_swigregister(TNaming_UsedShapes)

def TNaming_UsedShapes_GetID(*args):
    """
    TNaming_UsedShapes_GetID() -> Standard_GUID

    Returns the ID: 2a96b614-ec8b-11d0-bee7-080009dc3333.

    :rtype: OCC.wrapper.Standard.Standard_GUID

    """
    return _TNaming.TNaming_UsedShapes_GetID(*args)

def TNaming_UsedShapes_get_type_name(*args):
    """
    TNaming_UsedShapes_get_type_name() -> char const *

    :rtype: const char *

    """
    return _TNaming.TNaming_UsedShapes_get_type_name(*args)

def TNaming_UsedShapes_get_type_descriptor(*args):
    """
    TNaming_UsedShapes_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _TNaming.TNaming_UsedShapes_get_type_descriptor(*args)

class TNaming_Naming(TDF.TDF_Attribute):
    """
    This attribute  store the  topological  naming of any
    selected   shape,  when this  shape  is  not  already
    attached to a specific label. This class is also used
    to solve  it when  the argumentsof the  toipological
    naming are modified.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_TNaming_Naming
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_TNaming_Naming(self) 
            return h


    def GetID(*args):
        """
        GetID() -> Standard_GUID

        following code from TDesignStd
        ==============================

        :rtype: OCC.wrapper.Standard.Standard_GUID

        """
        return _TNaming.TNaming_Naming_GetID(*args)

    GetID = staticmethod(GetID)

    def Insert(*args):
        """
        Insert(TDF_Label under) -> Handle_TNaming_Naming

        :type under: OCC.wrapper.TDF.TDF_Label
        :rtype: OCC.wrapper.TNaming.Handle_TNaming_Naming

        """
        return _TNaming.TNaming_Naming_Insert(*args)

    Insert = staticmethod(Insert)

    def Name(*args):
        """
        Name(TDF_Label where, TopoDS_Shape Selection, TopoDS_Shape Context, Standard_Boolean const Geometry, Standard_Boolean const KeepOrientation, Standard_Boolean const BNproblem) -> Handle_TNaming_NamedShape

        Creates  a   Namimg  attribute  at  label <where>   to
        identify  the   shape   <Selection>.    Geometry is
        Standard_True  if   we  are  only  interested  by  the
        underlying   geometry     (e.g.     setting   a
        constraint). <Context> is  used to find neighbours  of
        <S> when required by the naming.
        If KeepOrientation is True the Selection orientation is taken
        into  account. BNproblem == True points out that Context sub-shapes
        in  DF have orientation differences with Context shape itself.
        instance method
        ===============

        :type where: OCC.wrapper.TDF.TDF_Label
        :type Selection: OCC.wrapper.TopoDS.TopoDS_Shape
        :type Context: OCC.wrapper.TopoDS.TopoDS_Shape
        :type Geometry: bool
        :type KeepOrientation: bool
        :type BNproblem: bool
        :rtype: OCC.wrapper.TNaming.Handle_TNaming_NamedShape

        """
        return _TNaming.TNaming_Naming_Name(*args)

    Name = staticmethod(Name)

    def __init__(self, *args):
        """
        __init__(TNaming_Naming self) -> TNaming_Naming

        This attribute  store the  topological  naming of any
        selected   shape,  when this  shape  is  not  already
        attached to a specific label. This class is also used
        to solve  it when  the argumentsof the  toipological
        naming are modified.
        """
        this = _TNaming.new_TNaming_Naming(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def IsDefined(self, *args):
        """
        IsDefined(TNaming_Naming self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TNaming.TNaming_Naming_IsDefined(self, *args)


    def GetName(self, *args):
        """
        :rtype: OCC.wrapper.TNaming.TNaming_Name

        """
        res = _TNaming.TNaming_Naming_GetName(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeName(self, *args):
        """
        ChangeName(TNaming_Naming self) -> TNaming_Name

        :rtype: OCC.wrapper.TNaming.TNaming_Name

        """
        return _TNaming.TNaming_Naming_ChangeName(self, *args)


    def Regenerate(self, *args):
        """
        Regenerate(TNaming_Naming self, NCollection_Map_TDF_Label_TDF_LabelMapHasher scope) -> Standard_Boolean

        regenerate only the Name associated to me

        :type scope: OCC.wrapper.TDF.TDF_LabelMap
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TNaming.TNaming_Naming_Regenerate(self, *args)


    def Solve(self, *args):
        """
        Solve(TNaming_Naming self, NCollection_Map_TDF_Label_TDF_LabelMapHasher scope) -> Standard_Boolean

        Regenerate recursively the  whole name with scope.  If
        scope  is empty it  means that  all the labels  of the
        framework are valid.

        :type scope: OCC.wrapper.TDF.TDF_LabelMap
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TNaming.TNaming_Naming_Solve(self, *args)


    def ID(self, *args):
        """
        Deferred methods from TDF_Attribute
        ===================================

        :rtype: OCC.wrapper.Standard.Standard_GUID

        """
        res = _TNaming.TNaming_Naming_ID(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def NewEmpty(self, *args):
        """
        NewEmpty(TNaming_Naming self) -> Handle_TDF_Attribute

        :rtype: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TNaming.TNaming_Naming_NewEmpty(self, *args)


    def Restore(self, *args):
        """
        Restore(TNaming_Naming self, Handle_TDF_Attribute With)

        :type With: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TNaming.TNaming_Naming_Restore(self, *args)


    def Paste(self, *args):
        """
        Paste(TNaming_Naming self, Handle_TDF_Attribute Into, Handle_TDF_RelocationTable RT)

        :type Into: OCC.wrapper.TDF.Handle_TDF_Attribute
        :type RT: OCC.wrapper.TDF.Handle_TDF_RelocationTable

        """
        return _TNaming.TNaming_Naming_Paste(self, *args)


    def References(self, *args):
        """
        References(TNaming_Naming self, Handle_TDF_DataSet aDataSet)

        :type aDataSet: OCC.wrapper.TDF.Handle_TDF_DataSet

        """
        return _TNaming.TNaming_Naming_References(self, *args)


    def Dump(self, *args):
        """
        Dump(TNaming_Naming self, Standard_OStream & anOS) -> Standard_OStream &

        :type anOS: OCC.wrapper.Standard.Standard_OStream
        :rtype: OCC.wrapper.Standard.Standard_OStream

        """
        return _TNaming.TNaming_Naming_Dump(self, *args)


    def ExtendedDump(self, *args):
        """
        ExtendedDump(TNaming_Naming self, Standard_OStream & anOS, TDF_IDFilter aFilter, NCollection_IndexedMap_Handle_TDF_Attribute_TColStd_MapTransientHasher aMap)

        :type anOS: OCC.wrapper.Standard.Standard_OStream
        :type aFilter: OCC.wrapper.TDF.TDF_IDFilter
        :type aMap: OCC.wrapper.TDF.TDF_AttributeIndexedMap

        """
        return _TNaming.TNaming_Naming_ExtendedDump(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _TNaming.TNaming_Naming_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _TNaming.TNaming_Naming_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TNaming.TNaming_Naming_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _TNaming.delete_TNaming_Naming
TNaming_Naming_swigregister = _TNaming.TNaming_Naming_swigregister
TNaming_Naming_swigregister(TNaming_Naming)

def TNaming_Naming_GetID(*args):
    """
    TNaming_Naming_GetID() -> Standard_GUID

    following code from TDesignStd
    ==============================

    :rtype: OCC.wrapper.Standard.Standard_GUID

    """
    return _TNaming.TNaming_Naming_GetID(*args)

def TNaming_Naming_Insert(*args):
    """
    TNaming_Naming_Insert(TDF_Label under) -> Handle_TNaming_Naming

    :type under: OCC.wrapper.TDF.TDF_Label
    :rtype: OCC.wrapper.TNaming.Handle_TNaming_Naming

    """
    return _TNaming.TNaming_Naming_Insert(*args)

def TNaming_Naming_Name(*args):
    """
    TNaming_Naming_Name(TDF_Label where, TopoDS_Shape Selection, TopoDS_Shape Context, Standard_Boolean const Geometry, Standard_Boolean const KeepOrientation, Standard_Boolean const BNproblem) -> Handle_TNaming_NamedShape

    Creates  a   Namimg  attribute  at  label <where>   to
    identify  the   shape   <Selection>.    Geometry is
    Standard_True  if   we  are  only  interested  by  the
    underlying   geometry     (e.g.     setting   a
    constraint). <Context> is  used to find neighbours  of
    <S> when required by the naming.
    If KeepOrientation is True the Selection orientation is taken
    into  account. BNproblem == True points out that Context sub-shapes
    in  DF have orientation differences with Context shape itself.
    instance method
    ===============

    :type where: OCC.wrapper.TDF.TDF_Label
    :type Selection: OCC.wrapper.TopoDS.TopoDS_Shape
    :type Context: OCC.wrapper.TopoDS.TopoDS_Shape
    :type Geometry: bool
    :type KeepOrientation: bool
    :type BNproblem: bool
    :rtype: OCC.wrapper.TNaming.Handle_TNaming_NamedShape

    """
    return _TNaming.TNaming_Naming_Name(*args)

def TNaming_Naming_get_type_name(*args):
    """
    TNaming_Naming_get_type_name() -> char const *

    :rtype: const char *

    """
    return _TNaming.TNaming_Naming_get_type_name(*args)

def TNaming_Naming_get_type_descriptor(*args):
    """
    TNaming_Naming_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _TNaming.TNaming_Naming_get_type_descriptor(*args)

class TNaming_DeltaOnRemoval(TDF.TDF_DeltaOnRemoval):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_TNaming_DeltaOnRemoval
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_TNaming_DeltaOnRemoval(self) 
            return h


    def __init__(self, *args):
        """
        __init__(TNaming_DeltaOnRemoval self, Handle_TNaming_NamedShape NS) -> TNaming_DeltaOnRemoval

        Initializes a TDF_DeltaOnModification.

        :type NS: OCC.wrapper.TNaming.Handle_TNaming_NamedShape

        """
        this = _TNaming.new_TNaming_DeltaOnRemoval(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Apply(self, *args):
        """
        Apply(TNaming_DeltaOnRemoval self)

        Applies the delta to the attribute.


        """
        return _TNaming.TNaming_DeltaOnRemoval_Apply(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _TNaming.TNaming_DeltaOnRemoval_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _TNaming.TNaming_DeltaOnRemoval_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TNaming.TNaming_DeltaOnRemoval_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _TNaming.delete_TNaming_DeltaOnRemoval
TNaming_DeltaOnRemoval_swigregister = _TNaming.TNaming_DeltaOnRemoval_swigregister
TNaming_DeltaOnRemoval_swigregister(TNaming_DeltaOnRemoval)

def TNaming_DeltaOnRemoval_get_type_name(*args):
    """
    TNaming_DeltaOnRemoval_get_type_name() -> char const *

    :rtype: const char *

    """
    return _TNaming.TNaming_DeltaOnRemoval_get_type_name(*args)

def TNaming_DeltaOnRemoval_get_type_descriptor(*args):
    """
    TNaming_DeltaOnRemoval_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _TNaming.TNaming_DeltaOnRemoval_get_type_descriptor(*args)

class TNaming_RefShape(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(TNaming_RefShape self) -> TNaming_RefShape
        __init__(TNaming_RefShape self, TopoDS_Shape S) -> TNaming_RefShape

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        this = _TNaming.new_TNaming_RefShape(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def FirstUse(self, *args):
        """
        FirstUse(TNaming_RefShape self, TNaming_PtrNode const & aPtr)
        FirstUse(TNaming_RefShape self) -> TNaming_PtrNode

        :rtype: OCC.wrapper.TNaming.TNaming_PtrNode

        """
        return _TNaming.TNaming_RefShape_FirstUse(self, *args)


    def Shape(self, *args):
        """
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _TNaming.TNaming_RefShape_Shape(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Label(self, *args):
        """
        Label(TNaming_RefShape self) -> TDF_Label

        :rtype: OCC.wrapper.TDF.TDF_Label

        """
        return _TNaming.TNaming_RefShape_Label(self, *args)


    def NamedShape(self, *args):
        """
        NamedShape(TNaming_RefShape self) -> Handle_TNaming_NamedShape

        :rtype: OCC.wrapper.TNaming.Handle_TNaming_NamedShape

        """
        return _TNaming.TNaming_RefShape_NamedShape(self, *args)

    __swig_destroy__ = _TNaming.delete_TNaming_RefShape
TNaming_RefShape_swigregister = _TNaming.TNaming_RefShape_swigregister
TNaming_RefShape_swigregister(TNaming_RefShape)

class NCollection_List_Handle_TNaming_NamedShape(NCollection.NCollection_BaseList):
    """
    Purpose:      Simple list to link  items together keeping the first 
    and the last one.
    Inherits BaseList, adding the data item to each node.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_List_Handle_TNaming_NamedShape self) -> NCollection_List< opencascade::handle< TNaming_NamedShape > >::iterator

        Returns an iterator pointing to the first element in the list.

        :rtype: iterator

        """
        return _TNaming.NCollection_List_Handle_TNaming_NamedShape_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_List_Handle_TNaming_NamedShape self) -> NCollection_List< opencascade::handle< TNaming_NamedShape > >::iterator

        Returns an iterator referring to the past-the-end element in the list.

        :rtype: iterator

        """
        return _TNaming.NCollection_List_Handle_TNaming_NamedShape_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_List_Handle_TNaming_NamedShape self) -> NCollection_List< opencascade::handle< TNaming_NamedShape > >::const_iterator

        Returns a const iterator pointing to the first element in the list.

        :rtype: const_iterator

        """
        return _TNaming.NCollection_List_Handle_TNaming_NamedShape_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_List_Handle_TNaming_NamedShape self) -> NCollection_List< opencascade::handle< TNaming_NamedShape > >::const_iterator

        Returns a const iterator referring to the past-the-end element in the list.

        :rtype: const_iterator

        """
        return _TNaming.NCollection_List_Handle_TNaming_NamedShape_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:      Simple list to link  items together keeping the first 
        and the last one.
        Inherits BaseList, adding the data item to each node.
        """
        this = _TNaming.new_NCollection_List_Handle_TNaming_NamedShape(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Size(self, *args):
        """
        Size(NCollection_List_Handle_TNaming_NamedShape self) -> Standard_Integer

        Size - Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TNaming.NCollection_List_Handle_TNaming_NamedShape_Size(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_List_Handle_TNaming_NamedShape self, NCollection_List_Handle_TNaming_NamedShape theOther) -> NCollection_List_Handle_TNaming_NamedShape

        Replace this list by the items of another list (theOther parameter).
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_List
        :rtype: OCC.wrapper.NCollection.NCollection_List

        """
        return _TNaming.NCollection_List_Handle_TNaming_NamedShape_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_List_Handle_TNaming_NamedShape self, NCollection_List_Handle_TNaming_NamedShape theOther) -> NCollection_List_Handle_TNaming_NamedShape

        Replacement operator

        :type theOther: OCC.wrapper.NCollection.NCollection_List
        :rtype: OCC.wrapper.NCollection.NCollection_List

        """
        return _TNaming.NCollection_List_Handle_TNaming_NamedShape_assign(self, *args)


    def Clear(self, *args):
        """
        Clear(NCollection_List_Handle_TNaming_NamedShape self, Handle_NCollection_BaseAllocator theAllocator=0)

        Clear this list

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _TNaming.NCollection_List_Handle_TNaming_NamedShape_Clear(self, *args)


    def First(self, *args):
        """
        First item

        :rtype: const TheItemType &

        """
        res = _TNaming.NCollection_List_Handle_TNaming_NamedShape_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Last(self, *args):
        """
        Last item

        :rtype: const TheItemType &

        """
        res = _TNaming.NCollection_List_Handle_TNaming_NamedShape_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Append(self, *args):
        """
        Append(NCollection_List_Handle_TNaming_NamedShape self, Handle_TNaming_NamedShape theItem) -> Handle_TNaming_NamedShape
        Append(NCollection_List_Handle_TNaming_NamedShape self, Handle_TNaming_NamedShape theItem, NCollection_List< opencascade::handle< TNaming_NamedShape > >::Iterator & theIter)
        Append(NCollection_List_Handle_TNaming_NamedShape self, NCollection_List_Handle_TNaming_NamedShape theOther)

        Append another list at the end

        :type theOther: OCC.wrapper.NCollection.NCollection_List

        """
        return _TNaming.NCollection_List_Handle_TNaming_NamedShape_Append(self, *args)


    def Prepend(self, *args):
        """
        Prepend(NCollection_List_Handle_TNaming_NamedShape self, Handle_TNaming_NamedShape theItem) -> Handle_TNaming_NamedShape
        Prepend(NCollection_List_Handle_TNaming_NamedShape self, NCollection_List_Handle_TNaming_NamedShape theOther)

        Prepend another list at the beginning

        :type theOther: OCC.wrapper.NCollection.NCollection_List

        """
        return _TNaming.NCollection_List_Handle_TNaming_NamedShape_Prepend(self, *args)


    def RemoveFirst(self, *args):
        """
        RemoveFirst(NCollection_List_Handle_TNaming_NamedShape self)

        RemoveFirst item


        """
        return _TNaming.NCollection_List_Handle_TNaming_NamedShape_RemoveFirst(self, *args)


    def Remove(self, *args):
        """
        Remove(NCollection_List_Handle_TNaming_NamedShape self, NCollection_List< opencascade::handle< TNaming_NamedShape > >::Iterator & theIter)

        Remove item pointed by iterator theIter; 
        theIter is then set to the next item

        :type theIter: Iterator

        """
        return _TNaming.NCollection_List_Handle_TNaming_NamedShape_Remove(self, *args)


    def InsertBefore(self, *args):
        """
        InsertBefore(NCollection_List_Handle_TNaming_NamedShape self, Handle_TNaming_NamedShape theItem, NCollection_List< opencascade::handle< TNaming_NamedShape > >::Iterator & theIter) -> Handle_TNaming_NamedShape
        InsertBefore(NCollection_List_Handle_TNaming_NamedShape self, NCollection_List_Handle_TNaming_NamedShape theOther, NCollection_List< opencascade::handle< TNaming_NamedShape > >::Iterator & theIter)

        InsertBefore

        :type theOther: OCC.wrapper.NCollection.NCollection_List
        :type theIter: Iterator

        """
        return _TNaming.NCollection_List_Handle_TNaming_NamedShape_InsertBefore(self, *args)


    def InsertAfter(self, *args):
        """
        InsertAfter(NCollection_List_Handle_TNaming_NamedShape self, Handle_TNaming_NamedShape theItem, NCollection_List< opencascade::handle< TNaming_NamedShape > >::Iterator & theIter) -> Handle_TNaming_NamedShape
        InsertAfter(NCollection_List_Handle_TNaming_NamedShape self, NCollection_List_Handle_TNaming_NamedShape theOther, NCollection_List< opencascade::handle< TNaming_NamedShape > >::Iterator & theIter)

        InsertAfter

        :type theOther: OCC.wrapper.NCollection.NCollection_List
        :type theIter: Iterator

        """
        return _TNaming.NCollection_List_Handle_TNaming_NamedShape_InsertAfter(self, *args)


    def Reverse(self, *args):
        """
        Reverse(NCollection_List_Handle_TNaming_NamedShape self)

        Reverse the list


        """
        return _TNaming.NCollection_List_Handle_TNaming_NamedShape_Reverse(self, *args)


    def __iter__(self):
        return _TNaming.NCollection_List_Handle_TNaming_NamedShape___iter__(self)
    __swig_destroy__ = _TNaming.delete_NCollection_List_Handle_TNaming_NamedShape
NCollection_List_Handle_TNaming_NamedShape_swigregister = _TNaming.NCollection_List_Handle_TNaming_NamedShape_swigregister
NCollection_List_Handle_TNaming_NamedShape_swigregister(NCollection_List_Handle_TNaming_NamedShape)

class NCollection_List_Handle_TNaming_NamedShape_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _TNaming.new_NCollection_List_Handle_TNaming_NamedShape_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _TNaming.delete_NCollection_List_Handle_TNaming_NamedShape_IteratorHelper

    def __next__(self):
        return _TNaming.NCollection_List_Handle_TNaming_NamedShape_IteratorHelper___next__(self)
NCollection_List_Handle_TNaming_NamedShape_IteratorHelper_swigregister = _TNaming.NCollection_List_Handle_TNaming_NamedShape_IteratorHelper_swigregister
NCollection_List_Handle_TNaming_NamedShape_IteratorHelper_swigregister(NCollection_List_Handle_TNaming_NamedShape_IteratorHelper)


try:
	TNaming_ListOfNamedShape = NCollection_List_Handle_TNaming_NamedShape
except NameError:
	pass # does not exist, probably ignored

class NCollection_List_TopTools_MapOfShape_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _TNaming.new_NCollection_List_TopTools_MapOfShape_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _TNaming.delete_NCollection_List_TopTools_MapOfShape_IteratorHelper

    def __next__(self):
        return _TNaming.NCollection_List_TopTools_MapOfShape_IteratorHelper___next__(self)
NCollection_List_TopTools_MapOfShape_IteratorHelper_swigregister = _TNaming.NCollection_List_TopTools_MapOfShape_IteratorHelper_swigregister
NCollection_List_TopTools_MapOfShape_IteratorHelper_swigregister(NCollection_List_TopTools_MapOfShape_IteratorHelper)


try:
	TNaming_ListOfMapOfShape = NCollection_List_TopTools_MapOfShape
except NameError:
	pass # does not exist, probably ignored

class TNaming_Iterator(object):
    """
    A tool to visit the contents of a named shape attribute.
    Pairs of shapes in the attribute are iterated, one
    being the pre-modification or the old shape, and
    the other the post-modification or the new shape.
    This allows you to have a full access to all
    contents of an attribute. If, on the other hand, you
    are only interested in topological entities stored
    in the attribute, you can use the functions
    GetShape and CurrentShape in TNaming_Tool.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(TNaming_Iterator self, Handle_TNaming_NamedShape anAtt) -> TNaming_Iterator
        __init__(TNaming_Iterator self, TDF_Label aLabel) -> TNaming_Iterator
        __init__(TNaming_Iterator self, TDF_Label aLabel, Standard_Integer const aTrans) -> TNaming_Iterator

        Iterates on all  the history records in
        the transaction <aTrans>

        :type aLabel: OCC.wrapper.TDF.TDF_Label
        :type aTrans: int

        """
        this = _TNaming.new_TNaming_Iterator(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def More(self, *args):
        """
        More(TNaming_Iterator self) -> Standard_Boolean

        Returns True if there is a current Item in
        the iteration.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TNaming.TNaming_Iterator_More(self, *args)


    def Next(self, *args):
        """
        Next(TNaming_Iterator self)

        Moves the iteration to the next Item


        """
        return _TNaming.TNaming_Iterator_Next(self, *args)


    def OldShape(self, *args):
        """
        Returns the old shape in this iterator object.
        This shape can be a null one.

        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _TNaming.TNaming_Iterator_OldShape(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def NewShape(self, *args):
        """
        Returns the new shape in this iterator object.

        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _TNaming.TNaming_Iterator_NewShape(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def IsModification(self, *args):
        """
        IsModification(TNaming_Iterator self) -> Standard_Boolean

        Returns true if the  new  shape is a modification  (split,
        fuse,etc...) of the old shape.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TNaming.TNaming_Iterator_IsModification(self, *args)


    def Evolution(self, *args):
        """
        Evolution(TNaming_Iterator self) -> TNaming_Evolution

        :rtype: OCC.wrapper.TNaming.TNaming_Evolution

        """
        return _TNaming.TNaming_Iterator_Evolution(self, *args)

    __swig_destroy__ = _TNaming.delete_TNaming_Iterator
TNaming_Iterator_swigregister = _TNaming.TNaming_Iterator_swigregister
TNaming_Iterator_swigregister(TNaming_Iterator)

class TNaming_DeltaOnModification(TDF.TDF_DeltaOnModification):
    """
    This class provides default services for an
    AttributeDelta on a MODIFICATION action.

    Applying this AttributeDelta means GOING BACK to
    the attribute previously registered state.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_TNaming_DeltaOnModification
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_TNaming_DeltaOnModification(self) 
            return h


    def __init__(self, *args):
        """
        __init__(TNaming_DeltaOnModification self, Handle_TNaming_NamedShape NS) -> TNaming_DeltaOnModification

        Initializes a TDF_DeltaOnModification.

        :type NS: OCC.wrapper.TNaming.Handle_TNaming_NamedShape

        """
        this = _TNaming.new_TNaming_DeltaOnModification(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Apply(self, *args):
        """
        Apply(TNaming_DeltaOnModification self)

        Applies the delta to the attribute.


        """
        return _TNaming.TNaming_DeltaOnModification_Apply(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _TNaming.TNaming_DeltaOnModification_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _TNaming.TNaming_DeltaOnModification_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TNaming.TNaming_DeltaOnModification_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _TNaming.delete_TNaming_DeltaOnModification
TNaming_DeltaOnModification_swigregister = _TNaming.TNaming_DeltaOnModification_swigregister
TNaming_DeltaOnModification_swigregister(TNaming_DeltaOnModification)

def TNaming_DeltaOnModification_get_type_name(*args):
    """
    TNaming_DeltaOnModification_get_type_name() -> char const *

    :rtype: const char *

    """
    return _TNaming.TNaming_DeltaOnModification_get_type_name(*args)

def TNaming_DeltaOnModification_get_type_descriptor(*args):
    """
    TNaming_DeltaOnModification_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _TNaming.TNaming_DeltaOnModification_get_type_descriptor(*args)

class TNaming_ShapesSet(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(TNaming_ShapesSet self) -> TNaming_ShapesSet
        __init__(TNaming_ShapesSet self, TopoDS_Shape S, TopAbs_ShapeEnum const Type=TopAbs_SHAPE) -> TNaming_ShapesSet

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :type Type: OCC.wrapper.TopAbs.TopAbs_ShapeEnum

        """
        this = _TNaming.new_TNaming_ShapesSet(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Clear(self, *args):
        """
        Clear(TNaming_ShapesSet self)

        Removes all Shapes


        """
        return _TNaming.TNaming_ShapesSet_Clear(self, *args)


    def Contains(self, *args):
        """
        Contains(TNaming_ShapesSet self, TopoDS_Shape S) -> Standard_Boolean

        Returns True  if <S> is in <me>

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TNaming.TNaming_ShapesSet_Contains(self, *args)


    def Add(self, *args):
        """
        Add(TNaming_ShapesSet self, TopoDS_Shape S) -> Standard_Boolean
        Add(TNaming_ShapesSet self, TNaming_ShapesSet Shapes)

        Adds the shapes contained in <Shapes>.

        :type Shapes: OCC.wrapper.TNaming.TNaming_ShapesSet

        """
        return _TNaming.TNaming_ShapesSet_Add(self, *args)


    def Filter(self, *args):
        """
        Filter(TNaming_ShapesSet self, TNaming_ShapesSet Shapes)

        Erases in <me> the shapes not
        contained in <Shapes>

        :type Shapes: OCC.wrapper.TNaming.TNaming_ShapesSet

        """
        return _TNaming.TNaming_ShapesSet_Filter(self, *args)


    def Remove(self, *args):
        """
        Remove(TNaming_ShapesSet self, TopoDS_Shape S) -> Standard_Boolean
        Remove(TNaming_ShapesSet self, TNaming_ShapesSet Shapes)

        Removes in <me> the shapes contained in <Shapes>

        :type Shapes: OCC.wrapper.TNaming.TNaming_ShapesSet

        """
        return _TNaming.TNaming_ShapesSet_Remove(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(TNaming_ShapesSet self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TNaming.TNaming_ShapesSet_IsEmpty(self, *args)


    def NbShapes(self, *args):
        """
        NbShapes(TNaming_ShapesSet self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TNaming.TNaming_ShapesSet_NbShapes(self, *args)


    def ChangeMap(self, *args):
        """
        ChangeMap(TNaming_ShapesSet self) -> NCollection_Map_TopoDS_Shape_TopTools_ShapeMapHasher

        :rtype: OCC.wrapper.TopTools.TopTools_MapOfShape

        """
        return _TNaming.TNaming_ShapesSet_ChangeMap(self, *args)


    def Map(self, *args):
        """
        :rtype: OCC.wrapper.TopTools.TopTools_MapOfShape

        """
        res = _TNaming.TNaming_ShapesSet_Map(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _TNaming.delete_TNaming_ShapesSet
TNaming_ShapesSet_swigregister = _TNaming.TNaming_ShapesSet_swigregister
TNaming_ShapesSet_swigregister(TNaming_ShapesSet)

class NCollection_DefaultHasher_Handle_TNaming_NamedShape(object):
    """
    Purpose:     The  DefaultHasher  is a  Hasher  that is used by
    default in NCollection maps. 
    To compute the  hash code of the key  is used the
    global function HashCode.
    To compare two keys is used  the  global function 
    IsEqual.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def HashCode(*args):
        """
        HashCode(Handle_TNaming_NamedShape theKey, Standard_Integer const Upper) -> Standard_Integer

        :type theKey: const TheKeyType &
        :type Upper: int
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TNaming.NCollection_DefaultHasher_Handle_TNaming_NamedShape_HashCode(*args)

    HashCode = staticmethod(HashCode)

    def IsEqual(*args):
        """
        IsEqual(Handle_TNaming_NamedShape theKey1, Handle_TNaming_NamedShape theKey2) -> Standard_Boolean

        :type theKey1: const TheKeyType &
        :type theKey2: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TNaming.NCollection_DefaultHasher_Handle_TNaming_NamedShape_IsEqual(*args)

    IsEqual = staticmethod(IsEqual)

    def __init__(self):
        """
        Purpose:     The  DefaultHasher  is a  Hasher  that is used by
        default in NCollection maps. 
        To compute the  hash code of the key  is used the
        global function HashCode.
        To compare two keys is used  the  global function 
        IsEqual.
        """
        this = _TNaming.new_NCollection_DefaultHasher_Handle_TNaming_NamedShape()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _TNaming.delete_NCollection_DefaultHasher_Handle_TNaming_NamedShape
NCollection_DefaultHasher_Handle_TNaming_NamedShape_swigregister = _TNaming.NCollection_DefaultHasher_Handle_TNaming_NamedShape_swigregister
NCollection_DefaultHasher_Handle_TNaming_NamedShape_swigregister(NCollection_DefaultHasher_Handle_TNaming_NamedShape)

def NCollection_DefaultHasher_Handle_TNaming_NamedShape_HashCode(*args):
    """
    NCollection_DefaultHasher_Handle_TNaming_NamedShape_HashCode(Handle_TNaming_NamedShape theKey, Standard_Integer const Upper) -> Standard_Integer

    :type theKey: const TheKeyType &
    :type Upper: int
    :rtype: OCC.wrapper.Standard.Standard_Integer

    """
    return _TNaming.NCollection_DefaultHasher_Handle_TNaming_NamedShape_HashCode(*args)

def NCollection_DefaultHasher_Handle_TNaming_NamedShape_IsEqual(*args):
    """
    NCollection_DefaultHasher_Handle_TNaming_NamedShape_IsEqual(Handle_TNaming_NamedShape theKey1, Handle_TNaming_NamedShape theKey2) -> Standard_Boolean

    :type theKey1: const TheKeyType &
    :type theKey2: const TheKeyType &
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _TNaming.NCollection_DefaultHasher_Handle_TNaming_NamedShape_IsEqual(*args)


try:
	TNaming_NamedShapeHasher = NCollection_DefaultHasher_Handle_TNaming_NamedShape
except NameError:
	pass # does not exist, probably ignored

class TNaming_NamingTool(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def CurrentShape(*args):
        """
        CurrentShape(NCollection_Map_TDF_Label_TDF_LabelMapHasher Valid, NCollection_Map_TDF_Label_TDF_LabelMapHasher Forbiden, Handle_TNaming_NamedShape NS, NCollection_IndexedMap_TopoDS_Shape_TopTools_ShapeMapHasher MS)

        :type Valid: OCC.wrapper.TDF.TDF_LabelMap
        :type Forbiden: OCC.wrapper.TDF.TDF_LabelMap
        :type NS: OCC.wrapper.TNaming.Handle_TNaming_NamedShape
        :type MS: OCC.wrapper.TopTools.TopTools_IndexedMapOfShape

        """
        return _TNaming.TNaming_NamingTool_CurrentShape(*args)

    CurrentShape = staticmethod(CurrentShape)

    def CurrentShapeFromShape(*args):
        """
        CurrentShapeFromShape(NCollection_Map_TDF_Label_TDF_LabelMapHasher Valid, NCollection_Map_TDF_Label_TDF_LabelMapHasher Forbiden, TDF_Label Acces, TopoDS_Shape S, NCollection_IndexedMap_TopoDS_Shape_TopTools_ShapeMapHasher MS)

        :type Valid: OCC.wrapper.TDF.TDF_LabelMap
        :type Forbiden: OCC.wrapper.TDF.TDF_LabelMap
        :type Acces: OCC.wrapper.TDF.TDF_Label
        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :type MS: OCC.wrapper.TopTools.TopTools_IndexedMapOfShape

        """
        return _TNaming.TNaming_NamingTool_CurrentShapeFromShape(*args)

    CurrentShapeFromShape = staticmethod(CurrentShapeFromShape)

    def BuildDescendants(*args):
        """
        BuildDescendants(Handle_TNaming_NamedShape NS, NCollection_Map_TDF_Label_TDF_LabelMapHasher Labels)

        :type NS: OCC.wrapper.TNaming.Handle_TNaming_NamedShape
        :type Labels: OCC.wrapper.TDF.TDF_LabelMap

        """
        return _TNaming.TNaming_NamingTool_BuildDescendants(*args)

    BuildDescendants = staticmethod(BuildDescendants)

    def __init__(self):
        this = _TNaming.new_TNaming_NamingTool()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _TNaming.delete_TNaming_NamingTool
TNaming_NamingTool_swigregister = _TNaming.TNaming_NamingTool_swigregister
TNaming_NamingTool_swigregister(TNaming_NamingTool)

def TNaming_NamingTool_CurrentShape(*args):
    """
    TNaming_NamingTool_CurrentShape(NCollection_Map_TDF_Label_TDF_LabelMapHasher Valid, NCollection_Map_TDF_Label_TDF_LabelMapHasher Forbiden, Handle_TNaming_NamedShape NS, NCollection_IndexedMap_TopoDS_Shape_TopTools_ShapeMapHasher MS)

    :type Valid: OCC.wrapper.TDF.TDF_LabelMap
    :type Forbiden: OCC.wrapper.TDF.TDF_LabelMap
    :type NS: OCC.wrapper.TNaming.Handle_TNaming_NamedShape
    :type MS: OCC.wrapper.TopTools.TopTools_IndexedMapOfShape

    """
    return _TNaming.TNaming_NamingTool_CurrentShape(*args)

def TNaming_NamingTool_CurrentShapeFromShape(*args):
    """
    TNaming_NamingTool_CurrentShapeFromShape(NCollection_Map_TDF_Label_TDF_LabelMapHasher Valid, NCollection_Map_TDF_Label_TDF_LabelMapHasher Forbiden, TDF_Label Acces, TopoDS_Shape S, NCollection_IndexedMap_TopoDS_Shape_TopTools_ShapeMapHasher MS)

    :type Valid: OCC.wrapper.TDF.TDF_LabelMap
    :type Forbiden: OCC.wrapper.TDF.TDF_LabelMap
    :type Acces: OCC.wrapper.TDF.TDF_Label
    :type S: OCC.wrapper.TopoDS.TopoDS_Shape
    :type MS: OCC.wrapper.TopTools.TopTools_IndexedMapOfShape

    """
    return _TNaming.TNaming_NamingTool_CurrentShapeFromShape(*args)

def TNaming_NamingTool_BuildDescendants(*args):
    """
    TNaming_NamingTool_BuildDescendants(Handle_TNaming_NamedShape NS, NCollection_Map_TDF_Label_TDF_LabelMapHasher Labels)

    :type NS: OCC.wrapper.TNaming.Handle_TNaming_NamedShape
    :type Labels: OCC.wrapper.TDF.TDF_LabelMap

    """
    return _TNaming.TNaming_NamingTool_BuildDescendants(*args)

class NCollection_List_TopTools_IndexedDataMapOfShapeListOfShape_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _TNaming.new_NCollection_List_TopTools_IndexedDataMapOfShapeListOfShape_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _TNaming.delete_NCollection_List_TopTools_IndexedDataMapOfShapeListOfShape_IteratorHelper

    def __next__(self):
        return _TNaming.NCollection_List_TopTools_IndexedDataMapOfShapeListOfShape_IteratorHelper___next__(self)
NCollection_List_TopTools_IndexedDataMapOfShapeListOfShape_IteratorHelper_swigregister = _TNaming.NCollection_List_TopTools_IndexedDataMapOfShapeListOfShape_IteratorHelper_swigregister
NCollection_List_TopTools_IndexedDataMapOfShapeListOfShape_IteratorHelper_swigregister(NCollection_List_TopTools_IndexedDataMapOfShapeListOfShape_IteratorHelper)


try:
	TNaming_ListOfIndexedDataMapOfShapeListOfShape = NCollection_List_TopTools_IndexedDataMapOfShapeListOfShape
except NameError:
	pass # does not exist, probably ignored

class TNaming_NewShapeIterator(object):
    """Iterates on all the descendants of a shape"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(TNaming_NewShapeIterator self, TopoDS_Shape aShape, Standard_Integer const Transaction, TDF_Label access) -> TNaming_NewShapeIterator
        __init__(TNaming_NewShapeIterator self, TopoDS_Shape aShape, TDF_Label access) -> TNaming_NewShapeIterator
        __init__(TNaming_NewShapeIterator self, TNaming_NewShapeIterator anIterator) -> TNaming_NewShapeIterator
        __init__(TNaming_NewShapeIterator self, TNaming_Iterator anIterator) -> TNaming_NewShapeIterator

        Iterates from the current Shape in <anIterator>

        :type anIterator: OCC.wrapper.TNaming.TNaming_Iterator

        """
        this = _TNaming.new_TNaming_NewShapeIterator(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def More(self, *args):
        """
        More(TNaming_NewShapeIterator self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TNaming.TNaming_NewShapeIterator_More(self, *args)


    def Next(self, *args):
        """Next(TNaming_NewShapeIterator self)"""
        return _TNaming.TNaming_NewShapeIterator_Next(self, *args)


    def Label(self, *args):
        """
        Label(TNaming_NewShapeIterator self) -> TDF_Label

        :rtype: OCC.wrapper.TDF.TDF_Label

        """
        return _TNaming.TNaming_NewShapeIterator_Label(self, *args)


    def NamedShape(self, *args):
        """
        NamedShape(TNaming_NewShapeIterator self) -> Handle_TNaming_NamedShape

        :rtype: OCC.wrapper.TNaming.Handle_TNaming_NamedShape

        """
        return _TNaming.TNaming_NewShapeIterator_NamedShape(self, *args)


    def Shape(self, *args):
        """
        Warning! Can be a Null Shape if a descendant is deleted.

        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _TNaming.TNaming_NewShapeIterator_Shape(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def IsModification(self, *args):
        """
        IsModification(TNaming_NewShapeIterator self) -> Standard_Boolean

        True if the new  shape is a modification  (split,
        fuse,etc...) of the old shape.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TNaming.TNaming_NewShapeIterator_IsModification(self, *args)

    __swig_destroy__ = _TNaming.delete_TNaming_NewShapeIterator
TNaming_NewShapeIterator_swigregister = _TNaming.TNaming_NewShapeIterator_swigregister
TNaming_NewShapeIterator_swigregister(TNaming_NewShapeIterator)

class Handle_TNaming_UsedShapes(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_TNaming_UsedShapes self)

        Nullify the handle


        """
        return _TNaming.Handle_TNaming_UsedShapes_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_TNaming_UsedShapes self) -> bool

        Check for being null

        :rtype: bool

        """
        return _TNaming.Handle_TNaming_UsedShapes_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_TNaming_UsedShapes self, TNaming_UsedShapes thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _TNaming.Handle_TNaming_UsedShapes_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_TNaming_UsedShapes self, Handle_TNaming_UsedShapes theHandle) -> Handle_TNaming_UsedShapes
        assign(Handle_TNaming_UsedShapes self, TNaming_UsedShapes thePtr) -> Handle_TNaming_UsedShapes
        assign(Handle_TNaming_UsedShapes self, Handle_TNaming_UsedShapes theHandle) -> Handle_TNaming_UsedShapes

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _TNaming.Handle_TNaming_UsedShapes_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_TNaming_UsedShapes self) -> TNaming_UsedShapes

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _TNaming.Handle_TNaming_UsedShapes_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_TNaming_UsedShapes self) -> TNaming_UsedShapes

        Member access operator (note non-const)

        :rtype: T *

        """
        return _TNaming.Handle_TNaming_UsedShapes___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_TNaming_UsedShapes self) -> TNaming_UsedShapes

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _TNaming.Handle_TNaming_UsedShapes___ref__(self, *args)


    def __hash__(self):
        return _TNaming.Handle_TNaming_UsedShapes___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _TNaming.Handle_TNaming_UsedShapes___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _TNaming.new_Handle_TNaming_UsedShapes(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_TNaming.Handle_TNaming_UsedShapes_DownCast)
    __swig_destroy__ = _TNaming.delete_Handle_TNaming_UsedShapes

    def Destroy(self, *args):
        """Destroy(Handle_TNaming_UsedShapes self)"""
        return _TNaming.Handle_TNaming_UsedShapes_Destroy(self, *args)


    def Map(self, *args):
        """
        Map(Handle_TNaming_UsedShapes self) -> NCollection_DataMap_TopoDS_Shape_TNaming_PtrRefShape_TopTools_ShapeMapHasher

        :rtype: OCC.wrapper.TNaming.TNaming_DataMapOfShapePtrRefShape

        """
        return _TNaming.Handle_TNaming_UsedShapes_Map(self, *args)


    def ID(self, *args):
        """
        Returns the ID of the attribute.

        :rtype: OCC.wrapper.Standard.Standard_GUID

        """
        res = _TNaming.Handle_TNaming_UsedShapes_ID(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def GetID(self, *args):
        """
        Returns the ID: 2a96b614-ec8b-11d0-bee7-080009dc3333.

        :rtype: OCC.wrapper.Standard.Standard_GUID

        """
        res = _TNaming.Handle_TNaming_UsedShapes_GetID(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def BackupCopy(self, *args):
        """
        BackupCopy(Handle_TNaming_UsedShapes self) -> Handle_TDF_Attribute

        Copies  the attribute  contents into  a  new other
        attribute. It is used by Backup().

        :rtype: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TNaming.Handle_TNaming_UsedShapes_BackupCopy(self, *args)


    def Restore(self, *args):
        """
        Restore(Handle_TNaming_UsedShapes self, Handle_TDF_Attribute anAttribute)

        Restores the contents from <anAttribute> into this
        one. It is used when aborting a transaction.

        :type anAttribute: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TNaming.Handle_TNaming_UsedShapes_Restore(self, *args)


    def BeforeRemoval(self, *args):
        """
        BeforeRemoval(Handle_TNaming_UsedShapes self)

        Clears the table.


        """
        return _TNaming.Handle_TNaming_UsedShapes_BeforeRemoval(self, *args)


    def AfterUndo(self, *args):
        """
        AfterUndo(Handle_TNaming_UsedShapes self, Handle_TDF_AttributeDelta anAttDelta, Standard_Boolean const forceIt) -> Standard_Boolean

        Something to do after applying <anAttDelta>.

        :type anAttDelta: OCC.wrapper.TDF.Handle_TDF_AttributeDelta
        :type forceIt: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TNaming.Handle_TNaming_UsedShapes_AfterUndo(self, *args)


    def DeltaOnAddition(self, *args):
        """
        DeltaOnAddition(Handle_TNaming_UsedShapes self) -> Handle_TDF_DeltaOnAddition

        this method returns a null handle (no delta).

        :rtype: OCC.wrapper.TDF.Handle_TDF_DeltaOnAddition

        """
        return _TNaming.Handle_TNaming_UsedShapes_DeltaOnAddition(self, *args)


    def DeltaOnRemoval(self, *args):
        """
        DeltaOnRemoval(Handle_TNaming_UsedShapes self) -> Handle_TDF_DeltaOnRemoval

        this method returns a null handle (no delta).

        :rtype: OCC.wrapper.TDF.Handle_TDF_DeltaOnRemoval

        """
        return _TNaming.Handle_TNaming_UsedShapes_DeltaOnRemoval(self, *args)


    def NewEmpty(self, *args):
        """
        NewEmpty(Handle_TNaming_UsedShapes self) -> Handle_TDF_Attribute

        Returns an new empty attribute from the good end
        type. It is used by the copy algorithm.

        :rtype: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TNaming.Handle_TNaming_UsedShapes_NewEmpty(self, *args)


    def Paste(self, *args):
        """
        Paste(Handle_TNaming_UsedShapes self, Handle_TDF_Attribute intoAttribute, Handle_TDF_RelocationTable aRelocTationable)

        This method is different from the "Copy" one,
        because it is used when copying an attribute from
        a source structure into a target structure. This
        method pastes the current attribute to the label
        corresponding to the insertor. The pasted
        attribute may be a brand new one or a new version
        of the previous one.

        :type intoAttribute: OCC.wrapper.TDF.Handle_TDF_Attribute
        :type aRelocTationable: OCC.wrapper.TDF.Handle_TDF_RelocationTable

        """
        return _TNaming.Handle_TNaming_UsedShapes_Paste(self, *args)


    def References(self, *args):
        """
        References(Handle_TNaming_UsedShapes self, Handle_TDF_DataSet aDataSet)

        Adds the directly referenced attributes and labels
        to <aDataSet>. "Directly" means we have only to
        look at the first level of references.

        For this, use only the AddLabel() & AddAttribute()
        from DataSet and do not try to modify information
        previously stored in <aDataSet>.

        :type aDataSet: OCC.wrapper.TDF.Handle_TDF_DataSet

        """
        return _TNaming.Handle_TNaming_UsedShapes_References(self, *args)


    def Dump(self, *args):
        """
        Dump(Handle_TNaming_UsedShapes self, Standard_OStream & anOS) -> Standard_OStream &

        Dumps the attribute on <aStream>.

        :type anOS: OCC.wrapper.Standard.Standard_OStream
        :rtype: OCC.wrapper.Standard.Standard_OStream

        """
        return _TNaming.Handle_TNaming_UsedShapes_Dump(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_TNaming_UsedShapes self) -> char const *

        :rtype: const char *

        """
        return _TNaming.Handle_TNaming_UsedShapes_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TNaming.Handle_TNaming_UsedShapes_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TNaming.Handle_TNaming_UsedShapes_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetID(self, *args):
        """
        SetID(Handle_TNaming_UsedShapes self, Standard_GUID arg2)
        SetID(Handle_TNaming_UsedShapes self)

        Sets default ID defined in nested class (to be used for attributes having User ID feature).


        """
        return _TNaming.Handle_TNaming_UsedShapes_SetID(self, *args)


    def Label(self, *args):
        """
        Label(Handle_TNaming_UsedShapes self) -> TDF_Label

        Returns   the   label to which  the   attribute is
        attached. If the  label is not  included in a  DF,
        the label is null. See Label.
        Warning
        If the label is not included in a data
        framework, it is null.
        This function should not be redefined inline.

        :rtype: OCC.wrapper.TDF.TDF_Label

        """
        return _TNaming.Handle_TNaming_UsedShapes_Label(self, *args)


    def Transaction(self, *args):
        """
        Transaction(Handle_TNaming_UsedShapes self) -> Standard_Integer

        Returns the transaction index in which the
        attribute has been created or modified.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TNaming.Handle_TNaming_UsedShapes_Transaction(self, *args)


    def UntilTransaction(self, *args):
        """
        UntilTransaction(Handle_TNaming_UsedShapes self) -> Standard_Integer

        Returns the upper transaction index until which
        the attribute is/was valid. This number may
        vary. A removed attribute validity range is
        reduced to its transaction index.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TNaming.Handle_TNaming_UsedShapes_UntilTransaction(self, *args)


    def IsValid(self, *args):
        """
        IsValid(Handle_TNaming_UsedShapes self) -> Standard_Boolean

        Returns true if the attribute is valid; i.e. not a
        backuped or removed one.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TNaming.Handle_TNaming_UsedShapes_IsValid(self, *args)


    def IsNew(self, *args):
        """
        IsNew(Handle_TNaming_UsedShapes self) -> Standard_Boolean

        Returns true if the attribute has no backup

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TNaming.Handle_TNaming_UsedShapes_IsNew(self, *args)


    def IsForgotten(self, *args):
        """
        IsForgotten(Handle_TNaming_UsedShapes self) -> Standard_Boolean

        Returns true if the attribute forgotten status is
        set.

        ShortCut Methods concerning associated attributes
        =================================================

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TNaming.Handle_TNaming_UsedShapes_IsForgotten(self, *args)


    def IsAttribute(self, *args):
        """
        IsAttribute(Handle_TNaming_UsedShapes self, Standard_GUID anID) -> Standard_Boolean

        Returns true if it  exists an associated attribute
        of <me> with <anID> as ID.

        :type anID: OCC.wrapper.Standard.Standard_GUID
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TNaming.Handle_TNaming_UsedShapes_IsAttribute(self, *args)


    def FindAttribute(self, *args):
        """
        FindAttribute(Handle_TNaming_UsedShapes self, Standard_GUID anID, Handle_TDF_Attribute anAttribute) -> Standard_Boolean

        Finds an associated  attribute of  <me>, according
        to <anID>.  the returned <anAttribute> is a  valid
        one. The  method  returns  True if   found,  False
        otherwise.   A removed attribute  cannot be found using
        this  method.

        :type anID: OCC.wrapper.Standard.Standard_GUID
        :type anAttribute: OCC.wrapper.TDF.Handle_TDF_Attribute
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TNaming.Handle_TNaming_UsedShapes_FindAttribute(self, *args)


    def AddAttribute(self, *args):
        """
        AddAttribute(Handle_TNaming_UsedShapes self, Handle_TDF_Attribute other)

        Adds   an   Attribute <other>  to  the   label  of
        <me>.Raises if there is  already  one of the same
        GUID fhan <other>.

        :type other: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TNaming.Handle_TNaming_UsedShapes_AddAttribute(self, *args)


    def ForgetAttribute(self, *args):
        """
        ForgetAttribute(Handle_TNaming_UsedShapes self, Standard_GUID aguid) -> Standard_Boolean

        Forgets  the Attribute of  GUID <aguid> associated
        to the label of <me>. Be  carefull that if <me> is
        the attribute of <guid>, <me> will have a null label
        after this call.  If  the attribute doesn't  exist
        returns False. Otherwise returns True.

        :type aguid: OCC.wrapper.Standard.Standard_GUID
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TNaming.Handle_TNaming_UsedShapes_ForgetAttribute(self, *args)


    def ForgetAllAttributes(self, *args):
        """
        ForgetAllAttributes(Handle_TNaming_UsedShapes self, Standard_Boolean const clearChildren)

        Forgets all the  attributes attached to  the label
        of <me>.    Does   it   on  the  sub-labels   if
        <clearChildren> is set  to true.  Of  course, this
        method  is  compatible with Transaction  &  Delta
        mecanisms. Be carefull  that  if <me> will have a
        null label after this call

        :type clearChildren: bool

        """
        return _TNaming.Handle_TNaming_UsedShapes_ForgetAllAttributes(self, *args)


    def AfterAddition(self, *args):
        """
        AfterAddition(Handle_TNaming_UsedShapes self)

        Something to do after adding an Attribute to a label.


        """
        return _TNaming.Handle_TNaming_UsedShapes_AfterAddition(self, *args)


    def BeforeForget(self, *args):
        """
        BeforeForget(Handle_TNaming_UsedShapes self)

        Something to do before forgetting an Attribute to a
        label.


        """
        return _TNaming.Handle_TNaming_UsedShapes_BeforeForget(self, *args)


    def AfterResume(self, *args):
        """
        AfterResume(Handle_TNaming_UsedShapes self)

        Something to do after resuming an Attribute from
        a label.


        """
        return _TNaming.Handle_TNaming_UsedShapes_AfterResume(self, *args)


    def AfterRetrieval(self, *args):
        """
        AfterRetrieval(Handle_TNaming_UsedShapes self, Standard_Boolean const forceIt) -> Standard_Boolean

        Something to do AFTER creation of an attribute by
        persistent-transient translation. The returned
        status says if AfterUndo has been performed (true)
        or if this callback must be called once again
        further (false). If <forceIt> is set to true, the
        method MUST perform and return true. Does nothing
        by default and returns true.

        :type forceIt: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TNaming.Handle_TNaming_UsedShapes_AfterRetrieval(self, *args)


    def BeforeUndo(self, *args):
        """
        BeforeUndo(Handle_TNaming_UsedShapes self, Handle_TDF_AttributeDelta anAttDelta, Standard_Boolean const forceIt) -> Standard_Boolean

        Something to do before applying <anAttDelta>. The
        returned status says if AfterUndo has been
        performed (true) or if this callback must be
        called once again further (false). If <forceIt> is
        set to true, the method MUST perform and return
        true. Does nothing by default and returns true.

        :type anAttDelta: OCC.wrapper.TDF.Handle_TDF_AttributeDelta
        :type forceIt: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TNaming.Handle_TNaming_UsedShapes_BeforeUndo(self, *args)


    def BeforeCommitTransaction(self, *args):
        """
        BeforeCommitTransaction(Handle_TNaming_UsedShapes self)

        A callback.
        By default does nothing.
        It is called by TDF_Data::CommitTransaction() method.


        """
        return _TNaming.Handle_TNaming_UsedShapes_BeforeCommitTransaction(self, *args)


    def Backup(self, *args):
        """
        Backup(Handle_TNaming_UsedShapes self)

        Backups the attribute. The backuped attribute is
        flagged "Backuped" and not "Valid".

        The method does nothing:

        1) If the attribute transaction number is equal to
        the current transaction number (the attribute has
        already been backuped).

        2) If the attribute is not attached to a label.


        """
        return _TNaming.Handle_TNaming_UsedShapes_Backup(self, *args)


    def IsBackuped(self, *args):
        """
        IsBackuped(Handle_TNaming_UsedShapes self) -> Standard_Boolean

        Returns true if the attribute backup status is
        set. This status is set/unset by the
        Backup() method.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TNaming.Handle_TNaming_UsedShapes_IsBackuped(self, *args)


    def DeltaOnForget(self, *args):
        """
        DeltaOnForget(Handle_TNaming_UsedShapes self) -> Handle_TDF_DeltaOnForget

        Makes an AttributeDelta because <me> has been
        forgotten.

        :rtype: OCC.wrapper.TDF.Handle_TDF_DeltaOnForget

        """
        return _TNaming.Handle_TNaming_UsedShapes_DeltaOnForget(self, *args)


    def DeltaOnResume(self, *args):
        """
        DeltaOnResume(Handle_TNaming_UsedShapes self) -> Handle_TDF_DeltaOnResume

        Makes an AttributeDelta because <me> has been
        resumed.

        :rtype: OCC.wrapper.TDF.Handle_TDF_DeltaOnResume

        """
        return _TNaming.Handle_TNaming_UsedShapes_DeltaOnResume(self, *args)


    def __lshift__(self, *args):
        """
        __lshift__(Handle_TNaming_UsedShapes self, Standard_OStream & anOS) -> Standard_OStream &

        :type anOS: OCC.wrapper.Standard.Standard_OStream
        :rtype: OCC.wrapper.Standard.Standard_OStream

        """
        return _TNaming.Handle_TNaming_UsedShapes___lshift__(self, *args)


    def ExtendedDump(self, *args):
        """
        ExtendedDump(Handle_TNaming_UsedShapes self, Standard_OStream & anOS, TDF_IDFilter aFilter, NCollection_IndexedMap_Handle_TDF_Attribute_TColStd_MapTransientHasher aMap)

        Dumps the attribute content on <aStream>, using
        <aMap> like this: if an attribute is not in the
        map, first put add it to the map and then dump it.
        Use the map rank instead of dumping each attribute
        field.

        :type anOS: OCC.wrapper.Standard.Standard_OStream
        :type aFilter: OCC.wrapper.TDF.TDF_IDFilter
        :type aMap: OCC.wrapper.TDF.TDF_AttributeIndexedMap

        """
        return _TNaming.Handle_TNaming_UsedShapes_ExtendedDump(self, *args)


    def Forget(self, *args):
        """
        Forget(Handle_TNaming_UsedShapes self, Standard_Integer const aTransaction)

        Forgets the attribute. <aTransaction> is the
        current transaction in which the forget is done. A
        forgotten attribute is also flagged not "Valid".

        A forgotten attribute is invisible. Set also the
        "Valid" status to False. Obvioulsy, DF cannot
        empty an attribute (this has a semantic
        signification), but can remove it from the
        structure. So, a forgotten attribute is NOT an empty
        one, but a soon DEAD one.

        Should be private.

        :type aTransaction: int

        """
        return _TNaming.Handle_TNaming_UsedShapes_Forget(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_TNaming_UsedShapes self)

        Memory deallocator for transient classes


        """
        return _TNaming.Handle_TNaming_UsedShapes_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_TNaming_UsedShapes self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_TNaming_UsedShapes self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TNaming.Handle_TNaming_UsedShapes_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_TNaming_UsedShapes self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_TNaming_UsedShapes self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TNaming.Handle_TNaming_UsedShapes_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_TNaming_UsedShapes self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _TNaming.Handle_TNaming_UsedShapes_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_TNaming_UsedShapes self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TNaming.Handle_TNaming_UsedShapes_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_TNaming_UsedShapes self)

        Increments the reference counter of this object


        """
        return _TNaming.Handle_TNaming_UsedShapes_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_TNaming_UsedShapes self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TNaming.Handle_TNaming_UsedShapes_DecrementRefCounter(self, *args)

Handle_TNaming_UsedShapes_swigregister = _TNaming.Handle_TNaming_UsedShapes_swigregister
Handle_TNaming_UsedShapes_swigregister(Handle_TNaming_UsedShapes)

def Handle_TNaming_UsedShapes_DownCast(thing):
    return _TNaming.Handle_TNaming_UsedShapes_DownCast(thing)
Handle_TNaming_UsedShapes_DownCast = _TNaming.Handle_TNaming_UsedShapes_DownCast

class TNaming_OldShapeIterator(object):
    """Iterates on all the ascendants of a shape"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(TNaming_OldShapeIterator self, TopoDS_Shape aShape, Standard_Integer const Transaction, TDF_Label access) -> TNaming_OldShapeIterator
        __init__(TNaming_OldShapeIterator self, TopoDS_Shape aShape, TDF_Label access) -> TNaming_OldShapeIterator
        __init__(TNaming_OldShapeIterator self, TNaming_OldShapeIterator anIterator) -> TNaming_OldShapeIterator
        __init__(TNaming_OldShapeIterator self, TNaming_Iterator anIterator) -> TNaming_OldShapeIterator

        Iterates from the current Shape in <anIterator>

        :type anIterator: OCC.wrapper.TNaming.TNaming_Iterator

        """
        this = _TNaming.new_TNaming_OldShapeIterator(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def More(self, *args):
        """
        More(TNaming_OldShapeIterator self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TNaming.TNaming_OldShapeIterator_More(self, *args)


    def Next(self, *args):
        """Next(TNaming_OldShapeIterator self)"""
        return _TNaming.TNaming_OldShapeIterator_Next(self, *args)


    def Label(self, *args):
        """
        Label(TNaming_OldShapeIterator self) -> TDF_Label

        :rtype: OCC.wrapper.TDF.TDF_Label

        """
        return _TNaming.TNaming_OldShapeIterator_Label(self, *args)


    def NamedShape(self, *args):
        """
        NamedShape(TNaming_OldShapeIterator self) -> Handle_TNaming_NamedShape

        :rtype: OCC.wrapper.TNaming.Handle_TNaming_NamedShape

        """
        return _TNaming.TNaming_OldShapeIterator_NamedShape(self, *args)


    def Shape(self, *args):
        """
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _TNaming.TNaming_OldShapeIterator_Shape(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def IsModification(self, *args):
        """
        IsModification(TNaming_OldShapeIterator self) -> Standard_Boolean

        True if the  new  shape is a modification  (split,
        fuse,etc...) of the old shape.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TNaming.TNaming_OldShapeIterator_IsModification(self, *args)

    __swig_destroy__ = _TNaming.delete_TNaming_OldShapeIterator
TNaming_OldShapeIterator_swigregister = _TNaming.TNaming_OldShapeIterator_swigregister
TNaming_OldShapeIterator_swigregister(TNaming_OldShapeIterator)

class TNaming_CopyShape(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def CopyTool(*args):
        """
        CopyTool(TopoDS_Shape aShape, NCollection_IndexedDataMap_Handle_Standard_Transient_Handle_Standard_Transient_TColStd_MapTransientHasher aMap, TopoDS_Shape aResult)

        Makes  copy  a  set  of  shape(s),  using the  aMap

        :type aShape: OCC.wrapper.TopoDS.TopoDS_Shape
        :type aMap: OCC.wrapper.TColStd.TColStd_IndexedDataMapOfTransientTransient
        :type aResult: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _TNaming.TNaming_CopyShape_CopyTool(*args)

    CopyTool = staticmethod(CopyTool)

    def Translate(*args):
        """
        Translate(TopoDS_Shape aShape, NCollection_IndexedDataMap_Handle_Standard_Transient_Handle_Standard_Transient_TColStd_MapTransientHasher aMap, TopoDS_Shape aResult, Handle_TNaming_TranslateTool TrTool)
        Translate(TopLoc_Location L, NCollection_IndexedDataMap_Handle_Standard_Transient_Handle_Standard_Transient_TColStd_MapTransientHasher aMap) -> TopLoc_Location

        Translates a Topological  Location  to an  other  Top.
        Location

        :type L: OCC.wrapper.TopLoc.TopLoc_Location
        :type aMap: OCC.wrapper.TColStd.TColStd_IndexedDataMapOfTransientTransient
        :rtype: OCC.wrapper.TopLoc.TopLoc_Location

        """
        return _TNaming.TNaming_CopyShape_Translate(*args)

    Translate = staticmethod(Translate)

    def __init__(self):
        this = _TNaming.new_TNaming_CopyShape()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _TNaming.delete_TNaming_CopyShape
TNaming_CopyShape_swigregister = _TNaming.TNaming_CopyShape_swigregister
TNaming_CopyShape_swigregister(TNaming_CopyShape)

def TNaming_CopyShape_CopyTool(*args):
    """
    TNaming_CopyShape_CopyTool(TopoDS_Shape aShape, NCollection_IndexedDataMap_Handle_Standard_Transient_Handle_Standard_Transient_TColStd_MapTransientHasher aMap, TopoDS_Shape aResult)

    Makes  copy  a  set  of  shape(s),  using the  aMap

    :type aShape: OCC.wrapper.TopoDS.TopoDS_Shape
    :type aMap: OCC.wrapper.TColStd.TColStd_IndexedDataMapOfTransientTransient
    :type aResult: OCC.wrapper.TopoDS.TopoDS_Shape

    """
    return _TNaming.TNaming_CopyShape_CopyTool(*args)

def TNaming_CopyShape_Translate(*args):
    """
    Translate(TopoDS_Shape aShape, NCollection_IndexedDataMap_Handle_Standard_Transient_Handle_Standard_Transient_TColStd_MapTransientHasher aMap, TopoDS_Shape aResult, Handle_TNaming_TranslateTool TrTool)
    TNaming_CopyShape_Translate(TopLoc_Location L, NCollection_IndexedDataMap_Handle_Standard_Transient_Handle_Standard_Transient_TColStd_MapTransientHasher aMap) -> TopLoc_Location

    Translates a Topological  Location  to an  other  Top.
    Location

    :type L: OCC.wrapper.TopLoc.TopLoc_Location
    :type aMap: OCC.wrapper.TColStd.TColStd_IndexedDataMapOfTransientTransient
    :rtype: OCC.wrapper.TopLoc.TopLoc_Location

    """
    return _TNaming.TNaming_CopyShape_Translate(*args)

class TNaming_Localizer(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """__init__(TNaming_Localizer self) -> TNaming_Localizer"""
        this = _TNaming.new_TNaming_Localizer(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(TNaming_Localizer self, Handle_TNaming_UsedShapes US, Standard_Integer const CurTrans)

        :type US: OCC.wrapper.TNaming.Handle_TNaming_UsedShapes
        :type CurTrans: int

        """
        return _TNaming.TNaming_Localizer_Init(self, *args)


    def SubShapes(self, *args):
        """
        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :type Type: OCC.wrapper.TopAbs.TopAbs_ShapeEnum
        :rtype: OCC.wrapper.TopTools.TopTools_MapOfShape

        """
        res = _TNaming.TNaming_Localizer_SubShapes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Ancestors(self, *args):
        """
        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :type Type: OCC.wrapper.TopAbs.TopAbs_ShapeEnum
        :rtype: OCC.wrapper.TopTools.TopTools_IndexedDataMapOfShapeListOfShape

        """
        res = _TNaming.TNaming_Localizer_Ancestors(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def FindFeaturesInAncestors(self, *args):
        """
        FindFeaturesInAncestors(TNaming_Localizer self, TopoDS_Shape S, TopoDS_Shape In, NCollection_Map_TopoDS_Shape_TopTools_ShapeMapHasher AncInFeatures)

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :type In: OCC.wrapper.TopoDS.TopoDS_Shape
        :type AncInFeatures: OCC.wrapper.TopTools.TopTools_MapOfShape

        """
        return _TNaming.TNaming_Localizer_FindFeaturesInAncestors(self, *args)


    def GoBack(self, *args):
        """
        GoBack(TNaming_Localizer self, TopoDS_Shape S, TDF_Label Lab, TNaming_Evolution const Evol, NCollection_List_TopoDS_Shape OldS, NCollection_List_Handle_TNaming_NamedShape OldLab)

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :type Lab: OCC.wrapper.TDF.TDF_Label
        :type Evol: OCC.wrapper.TNaming.TNaming_Evolution
        :type OldS: OCC.wrapper.TopTools.TopTools_ListOfShape
        :type OldLab: OCC.wrapper.TNaming.TNaming_ListOfNamedShape

        """
        return _TNaming.TNaming_Localizer_GoBack(self, *args)


    def Backward(self, *args):
        """
        Backward(TNaming_Localizer self, Handle_TNaming_NamedShape NS, TopoDS_Shape S, NCollection_Map_Handle_TNaming_NamedShape_TNaming_NamedShapeHasher Primitives, NCollection_Map_TopoDS_Shape_TopTools_ShapeMapHasher ValidShapes)

        :type NS: OCC.wrapper.TNaming.Handle_TNaming_NamedShape
        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :type Primitives: OCC.wrapper.TNaming.TNaming_MapOfNamedShape
        :type ValidShapes: OCC.wrapper.TopTools.TopTools_MapOfShape

        """
        return _TNaming.TNaming_Localizer_Backward(self, *args)


    def FindNeighbourg(self, *args):
        """
        FindNeighbourg(TNaming_Localizer self, TopoDS_Shape Cont, TopoDS_Shape S, NCollection_Map_TopoDS_Shape_TopTools_ShapeMapHasher Neighbourg)

        :type Cont: OCC.wrapper.TopoDS.TopoDS_Shape
        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :type Neighbourg: OCC.wrapper.TopTools.TopTools_MapOfShape

        """
        return _TNaming.TNaming_Localizer_FindNeighbourg(self, *args)


    def IsNew(*args):
        """
        IsNew(TopoDS_Shape S, Handle_TNaming_NamedShape NS) -> Standard_Boolean

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :type NS: OCC.wrapper.TNaming.Handle_TNaming_NamedShape
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TNaming.TNaming_Localizer_IsNew(*args)

    IsNew = staticmethod(IsNew)

    def FindGenerator(*args):
        """
        FindGenerator(Handle_TNaming_NamedShape NS, TopoDS_Shape S, NCollection_List_TopoDS_Shape theListOfGenerators)

        :type NS: OCC.wrapper.TNaming.Handle_TNaming_NamedShape
        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :type theListOfGenerators: OCC.wrapper.TopTools.TopTools_ListOfShape

        """
        return _TNaming.TNaming_Localizer_FindGenerator(*args)

    FindGenerator = staticmethod(FindGenerator)

    def FindShapeContext(*args):
        """
        FindShapeContext(Handle_TNaming_NamedShape NS, TopoDS_Shape theS, TopoDS_Shape theSC)

        Finds context of the shape <S>.

        :type NS: OCC.wrapper.TNaming.Handle_TNaming_NamedShape
        :type theS: OCC.wrapper.TopoDS.TopoDS_Shape
        :type theSC: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _TNaming.TNaming_Localizer_FindShapeContext(*args)

    FindShapeContext = staticmethod(FindShapeContext)
    __swig_destroy__ = _TNaming.delete_TNaming_Localizer
TNaming_Localizer_swigregister = _TNaming.TNaming_Localizer_swigregister
TNaming_Localizer_swigregister(TNaming_Localizer)

def TNaming_Localizer_IsNew(*args):
    """
    TNaming_Localizer_IsNew(TopoDS_Shape S, Handle_TNaming_NamedShape NS) -> Standard_Boolean

    :type S: OCC.wrapper.TopoDS.TopoDS_Shape
    :type NS: OCC.wrapper.TNaming.Handle_TNaming_NamedShape
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _TNaming.TNaming_Localizer_IsNew(*args)

def TNaming_Localizer_FindGenerator(*args):
    """
    TNaming_Localizer_FindGenerator(Handle_TNaming_NamedShape NS, TopoDS_Shape S, NCollection_List_TopoDS_Shape theListOfGenerators)

    :type NS: OCC.wrapper.TNaming.Handle_TNaming_NamedShape
    :type S: OCC.wrapper.TopoDS.TopoDS_Shape
    :type theListOfGenerators: OCC.wrapper.TopTools.TopTools_ListOfShape

    """
    return _TNaming.TNaming_Localizer_FindGenerator(*args)

def TNaming_Localizer_FindShapeContext(*args):
    """
    TNaming_Localizer_FindShapeContext(Handle_TNaming_NamedShape NS, TopoDS_Shape theS, TopoDS_Shape theSC)

    Finds context of the shape <S>.

    :type NS: OCC.wrapper.TNaming.Handle_TNaming_NamedShape
    :type theS: OCC.wrapper.TopoDS.TopoDS_Shape
    :type theSC: OCC.wrapper.TopoDS.TopoDS_Shape

    """
    return _TNaming.TNaming_Localizer_FindShapeContext(*args)

class NCollection_DataMap_TopoDS_Shape_TNaming_ShapesSet_TopTools_ShapeMapHasher(NCollection.NCollection_BaseMap):
    """
    Purpose:     The DataMap is a Map to store keys with associated
    Items. See Map  from NCollection for  a discussion
    about the number of buckets.

    The DataMap can be seen as an extended array where
    the Keys  are the   indices.  For this reason  the
    operator () is defined on DataMap to fetch an Item
    from a Key. So the following syntax can be used :

    anItem = aMap(aKey);
    aMap(aKey) = anItem;

    This analogy has its  limit.   aMap(aKey) = anItem
    can  be done only  if aKey was previously bound to
    an item in the map.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_DataMap_TopoDS_Shape_TNaming_ShapesSet_TopTools_ShapeMapHasher self) -> NCollection_DataMap< TopoDS_Shape,TNaming_ShapesSet,TopTools_ShapeMapHasher >::iterator

        Returns an iterator pointing to the first element in the map.

        :rtype: iterator

        """
        return _TNaming.NCollection_DataMap_TopoDS_Shape_TNaming_ShapesSet_TopTools_ShapeMapHasher_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_DataMap_TopoDS_Shape_TNaming_ShapesSet_TopTools_ShapeMapHasher self) -> NCollection_DataMap< TopoDS_Shape,TNaming_ShapesSet,TopTools_ShapeMapHasher >::iterator

        Returns an iterator referring to the past-the-end element in the map.

        :rtype: iterator

        """
        return _TNaming.NCollection_DataMap_TopoDS_Shape_TNaming_ShapesSet_TopTools_ShapeMapHasher_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_DataMap_TopoDS_Shape_TNaming_ShapesSet_TopTools_ShapeMapHasher self) -> NCollection_DataMap< TopoDS_Shape,TNaming_ShapesSet,TopTools_ShapeMapHasher >::const_iterator

        Returns a const iterator pointing to the first element in the map.

        :rtype: const_iterator

        """
        return _TNaming.NCollection_DataMap_TopoDS_Shape_TNaming_ShapesSet_TopTools_ShapeMapHasher_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_DataMap_TopoDS_Shape_TNaming_ShapesSet_TopTools_ShapeMapHasher self) -> NCollection_DataMap< TopoDS_Shape,TNaming_ShapesSet,TopTools_ShapeMapHasher >::const_iterator

        Returns a const iterator referring to the past-the-end element in the map.

        :rtype: const_iterator

        """
        return _TNaming.NCollection_DataMap_TopoDS_Shape_TNaming_ShapesSet_TopTools_ShapeMapHasher_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     The DataMap is a Map to store keys with associated
        Items. See Map  from NCollection for  a discussion
        about the number of buckets.

        The DataMap can be seen as an extended array where
        the Keys  are the   indices.  For this reason  the
        operator () is defined on DataMap to fetch an Item
        from a Key. So the following syntax can be used :

        anItem = aMap(aKey);
        aMap(aKey) = anItem;

        This analogy has its  limit.   aMap(aKey) = anItem
        can  be done only  if aKey was previously bound to
        an item in the map.
        """
        this = _TNaming.new_NCollection_DataMap_TopoDS_Shape_TNaming_ShapesSet_TopTools_ShapeMapHasher(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Exchange(self, *args):
        """
        Exchange(NCollection_DataMap_TopoDS_Shape_TNaming_ShapesSet_TopTools_ShapeMapHasher self, NCollection_DataMap_TopoDS_Shape_TNaming_ShapesSet_TopTools_ShapeMapHasher theOther)

        Exchange the content of two maps without re-allocations.
        Notice that allocators will be swapped as well!

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _TNaming.NCollection_DataMap_TopoDS_Shape_TNaming_ShapesSet_TopTools_ShapeMapHasher_Exchange(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_DataMap_TopoDS_Shape_TNaming_ShapesSet_TopTools_ShapeMapHasher self, NCollection_DataMap_TopoDS_Shape_TNaming_ShapesSet_TopTools_ShapeMapHasher theOther) -> NCollection_DataMap_TopoDS_Shape_TNaming_ShapesSet_TopTools_ShapeMapHasher

        Assignment.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _TNaming.NCollection_DataMap_TopoDS_Shape_TNaming_ShapesSet_TopTools_ShapeMapHasher_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_DataMap_TopoDS_Shape_TNaming_ShapesSet_TopTools_ShapeMapHasher self, NCollection_DataMap_TopoDS_Shape_TNaming_ShapesSet_TopTools_ShapeMapHasher theOther) -> NCollection_DataMap_TopoDS_Shape_TNaming_ShapesSet_TopTools_ShapeMapHasher

        Assignment operator

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _TNaming.NCollection_DataMap_TopoDS_Shape_TNaming_ShapesSet_TopTools_ShapeMapHasher_assign(self, *args)


    def ReSize(self, *args):
        """
        ReSize(NCollection_DataMap_TopoDS_Shape_TNaming_ShapesSet_TopTools_ShapeMapHasher self, Standard_Integer const N)

        ReSize

        :type N: int

        """
        return _TNaming.NCollection_DataMap_TopoDS_Shape_TNaming_ShapesSet_TopTools_ShapeMapHasher_ReSize(self, *args)


    def Bind(self, *args):
        """
        Bind(NCollection_DataMap_TopoDS_Shape_TNaming_ShapesSet_TopTools_ShapeMapHasher self, TopoDS_Shape theKey, TNaming_ShapesSet theItem) -> Standard_Boolean

        Bind binds Item to Key in map.
        @param theKey  key to add/update
        @param theItem new item; overrides value previously bound to the key, if any
        @return Standard_True if Key was not bound already

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TNaming.NCollection_DataMap_TopoDS_Shape_TNaming_ShapesSet_TopTools_ShapeMapHasher_Bind(self, *args)


    def Bound(self, *args):
        """
        Bound(NCollection_DataMap_TopoDS_Shape_TNaming_ShapesSet_TopTools_ShapeMapHasher self, TopoDS_Shape theKey, TNaming_ShapesSet theItem) -> TNaming_ShapesSet

        Bound binds Item to Key in map. Returns modifiable Item 

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: TheItemType *

        """
        return _TNaming.NCollection_DataMap_TopoDS_Shape_TNaming_ShapesSet_TopTools_ShapeMapHasher_Bound(self, *args)


    def IsBound(self, *args):
        """
        IsBound(NCollection_DataMap_TopoDS_Shape_TNaming_ShapesSet_TopTools_ShapeMapHasher self, TopoDS_Shape theKey) -> Standard_Boolean

        IsBound

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TNaming.NCollection_DataMap_TopoDS_Shape_TNaming_ShapesSet_TopTools_ShapeMapHasher_IsBound(self, *args)


    def UnBind(self, *args):
        """
        UnBind(NCollection_DataMap_TopoDS_Shape_TNaming_ShapesSet_TopTools_ShapeMapHasher self, TopoDS_Shape theKey) -> Standard_Boolean

        UnBind removes Item Key pair from map

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TNaming.NCollection_DataMap_TopoDS_Shape_TNaming_ShapesSet_TopTools_ShapeMapHasher_UnBind(self, *args)


    def Seek(self, *args):
        """
        Seek(NCollection_DataMap_TopoDS_Shape_TNaming_ShapesSet_TopTools_ShapeMapHasher self, TopoDS_Shape theKey) -> TNaming_ShapesSet

        Seek returns pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: const TheItemType *

        """
        return _TNaming.NCollection_DataMap_TopoDS_Shape_TNaming_ShapesSet_TopTools_ShapeMapHasher_Seek(self, *args)


    def Find(self, *args):
        """
        Find returns the Item for Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _TNaming.NCollection_DataMap_TopoDS_Shape_TNaming_ShapesSet_TopTools_ShapeMapHasher_Find(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeSeek(self, *args):
        """
        ChangeSeek(NCollection_DataMap_TopoDS_Shape_TNaming_ShapesSet_TopTools_ShapeMapHasher self, TopoDS_Shape theKey) -> TNaming_ShapesSet

        ChangeSeek returns modifiable pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: TheItemType *

        """
        return _TNaming.NCollection_DataMap_TopoDS_Shape_TNaming_ShapesSet_TopTools_ShapeMapHasher_ChangeSeek(self, *args)


    def ChangeFind(self, *args):
        """
        ChangeFind(NCollection_DataMap_TopoDS_Shape_TNaming_ShapesSet_TopTools_ShapeMapHasher self, TopoDS_Shape theKey) -> TNaming_ShapesSet

        ChangeFind returns mofifiable Item by Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: TheItemType &

        """
        return _TNaming.NCollection_DataMap_TopoDS_Shape_TNaming_ShapesSet_TopTools_ShapeMapHasher_ChangeFind(self, *args)


    def __call__(self, *args):
        """
        operator ()

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _TNaming.NCollection_DataMap_TopoDS_Shape_TNaming_ShapesSet_TopTools_ShapeMapHasher___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Clear(self, *args):
        """
        Clear(NCollection_DataMap_TopoDS_Shape_TNaming_ShapesSet_TopTools_ShapeMapHasher self, Standard_Boolean const doReleaseMemory)
        Clear(NCollection_DataMap_TopoDS_Shape_TNaming_ShapesSet_TopTools_ShapeMapHasher self, Handle_NCollection_BaseAllocator theAllocator)

        Clear data and reset allocator

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _TNaming.NCollection_DataMap_TopoDS_Shape_TNaming_ShapesSet_TopTools_ShapeMapHasher_Clear(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_DataMap_TopoDS_Shape_TNaming_ShapesSet_TopTools_ShapeMapHasher self) -> Standard_Integer

        Size

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TNaming.NCollection_DataMap_TopoDS_Shape_TNaming_ShapesSet_TopTools_ShapeMapHasher_Size(self, *args)


    def __iter__(self):
        return _TNaming.NCollection_DataMap_TopoDS_Shape_TNaming_ShapesSet_TopTools_ShapeMapHasher___iter__(self)
    __swig_destroy__ = _TNaming.delete_NCollection_DataMap_TopoDS_Shape_TNaming_ShapesSet_TopTools_ShapeMapHasher
NCollection_DataMap_TopoDS_Shape_TNaming_ShapesSet_TopTools_ShapeMapHasher_swigregister = _TNaming.NCollection_DataMap_TopoDS_Shape_TNaming_ShapesSet_TopTools_ShapeMapHasher_swigregister
NCollection_DataMap_TopoDS_Shape_TNaming_ShapesSet_TopTools_ShapeMapHasher_swigregister(NCollection_DataMap_TopoDS_Shape_TNaming_ShapesSet_TopTools_ShapeMapHasher)

class NCollection_DataMap_TopoDS_Shape_TNaming_ShapesSet_TopTools_ShapeMapHasher_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _TNaming.new_NCollection_DataMap_TopoDS_Shape_TNaming_ShapesSet_TopTools_ShapeMapHasher_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _TNaming.delete_NCollection_DataMap_TopoDS_Shape_TNaming_ShapesSet_TopTools_ShapeMapHasher_IteratorHelper

    def __next__(self):
        return _TNaming.NCollection_DataMap_TopoDS_Shape_TNaming_ShapesSet_TopTools_ShapeMapHasher_IteratorHelper___next__(self)
NCollection_DataMap_TopoDS_Shape_TNaming_ShapesSet_TopTools_ShapeMapHasher_IteratorHelper_swigregister = _TNaming.NCollection_DataMap_TopoDS_Shape_TNaming_ShapesSet_TopTools_ShapeMapHasher_IteratorHelper_swigregister
NCollection_DataMap_TopoDS_Shape_TNaming_ShapesSet_TopTools_ShapeMapHasher_IteratorHelper_swigregister(NCollection_DataMap_TopoDS_Shape_TNaming_ShapesSet_TopTools_ShapeMapHasher_IteratorHelper)


try:
	TNaming_DataMapOfShapeShapesSet = NCollection_DataMap_TopoDS_Shape_TNaming_ShapesSet_TopTools_ShapeMapHasher
except NameError:
	pass # does not exist, probably ignored

class TNaming_(object):
    """
    A topological attribute can be seen as a hook
    into the topological structure. To this hook,
    data can be attached and references defined.
    It is used for keeping and access to
    topological objects and their evolution. All
    topological objects are stored in the one
    user-protected TNaming_UsedShapes
    attribute at the root label of the data
    framework. This attribute contains map with all
    topological shapes, used in this document.
    To all other labels TNaming_NamedShape
    attribute can be added. This attribute contains
    references (hooks) to shapes from the
    TNaming_UsedShapes attribute and evolution
    of these shapes. TNaming_NamedShape
    attribute contains a set of pairs of hooks: old
    shape and new shape (see the figure below).
    It allows not only get the topological shapes by
    the labels, but also trace evolution of the
    shapes and correctly resolve dependent
    shapes by the changed one.
    If shape is just-created, then the old shape for
    accorded named shape is an empty shape. If
    a shape is deleted, then the new shape in this named shape is empty.
    Different algorithms may dispose sub-shapes
    of the result shape at the individual label depending on necessity:
    -  If a sub-shape must have some extra attributes (material of
    each face or color of each edge). In this case a specific sub-shape is
    placed to the separate label (usually, sub-label of the result shape label)
    with all attributes of this sub-shape.
    -  If topological naming is needed, a necessary and sufficient
    (for selected sub-shapes identification) set of sub-shapes is
    placed to the child labels of the result
    shape label. As usual, as far as basic solids and closed shells are
    concerned, all faces of the shape are disposed. Edges and vertices
    sub-shapes can be identified as intersection of contiguous faces.
    Modified/generated shapes may be placed to one named shape and
    identified as this named shape and source named shape that also can be
    identified with used algorithms.
    TNaming_NamedShape may contain a few
    pairs of hooks with the same evolution. In this
    case topology shape, which belongs to the
    named shape, is a compound of new shapes.
    The data model contains both the topology
    and the hooks, and functions handle both
    topological entities and hooks. Consider the
    case of a box function, which creates a solid
    with six faces and six hooks. Each hook is
    attached to a face. If you want, you can also
    have this function create hooks for edges and
    vertices as well as for faces. For the sake of
    simplicity though, let's limit the example.
    Not all functions can define explicit hooks for
    all topological entities they create, but all
    topological entities can be turned into hooks
    when necessary. This is where topological naming is necessary.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Substitute(*args):
        """
        Substitute(TDF_Label labelsource, TDF_Label labelcible, NCollection_DataMap_TopoDS_Shape_TopoDS_Shape_TopTools_ShapeMapHasher mapOldNew)

        Subtituter les  shapes  sur les structures de   source
        vers cible

        :type labelsource: OCC.wrapper.TDF.TDF_Label
        :type labelcible: OCC.wrapper.TDF.TDF_Label
        :type mapOldNew: OCC.wrapper.TopTools.TopTools_DataMapOfShapeShape

        """
        return _TNaming.TNaming__Substitute(*args)

    Substitute = staticmethod(Substitute)

    def Update(*args):
        """
        Update(TDF_Label label, NCollection_DataMap_TopoDS_Shape_TopoDS_Shape_TopTools_ShapeMapHasher mapOldNew)

        Mise a jour des shapes du label  et de ses fils en
        tenant compte des  substitutions decrite par
        mapOldNew.

        Warning: le  remplacement du shape est  fait    dans tous
        les    attributs  qui  le contiennent meme si ceux
        ci ne sont pas associees a des sous-labels de <Label>.

        :type label: OCC.wrapper.TDF.TDF_Label
        :type mapOldNew: OCC.wrapper.TopTools.TopTools_DataMapOfShapeShape

        """
        return _TNaming.TNaming__Update(*args)

    Update = staticmethod(Update)

    def Displace(*args):
        """
        Displace(TDF_Label label, TopLoc_Location aLocation, Standard_Boolean const WithOld)

        Application de la Location sur les shapes du label
        et  de   ses   sous   labels.

        :type label: OCC.wrapper.TDF.TDF_Label
        :type aLocation: OCC.wrapper.TopLoc.TopLoc_Location
        :type WithOld: bool

        """
        return _TNaming.TNaming__Displace(*args)

    Displace = staticmethod(Displace)

    def ChangeShapes(*args):
        """
        ChangeShapes(TDF_Label label, NCollection_DataMap_TopoDS_Shape_TopoDS_Shape_TopTools_ShapeMapHasher M)

        Remplace  les  shapes du label et  des sous-labels
        par des copies.

        :type label: OCC.wrapper.TDF.TDF_Label
        :type M: OCC.wrapper.TopTools.TopTools_DataMapOfShapeShape

        """
        return _TNaming.TNaming__ChangeShapes(*args)

    ChangeShapes = staticmethod(ChangeShapes)

    def Transform(*args):
        """
        Transform(TDF_Label label, gp_Trsf aTransformation)

        Application de la transformation sur les shapes du
        label et de ses sous labels.
        Warning: le  remplacement du shape est  fait    dans tous
        les    attributs  qui  le contiennent meme si ceux
        ci ne sont pas associees a des sous-labels de <Label>.

        :type label: OCC.wrapper.TDF.TDF_Label
        :type aTransformation: OCC.wrapper.gp.gp_Trsf

        """
        return _TNaming.TNaming__Transform(*args)

    Transform = staticmethod(Transform)

    def Replicate(*args):
        """
        Replicate(Handle_TNaming_NamedShape NS, gp_Trsf T, TDF_Label L)
        Replicate(TopoDS_Shape SH, gp_Trsf T, TDF_Label L)

        Replicates the shape with the transformation <T>
        on the label <L> (and sub-labels if necessary)
        (TNaming_GENERATED is set)

        :type SH: OCC.wrapper.TopoDS.TopoDS_Shape
        :type T: OCC.wrapper.gp.gp_Trsf
        :type L: OCC.wrapper.TDF.TDF_Label

        """
        return _TNaming.TNaming__Replicate(*args)

    Replicate = staticmethod(Replicate)

    def MakeShape(*args):
        """
        MakeShape(NCollection_Map_TopoDS_Shape_TopTools_ShapeMapHasher MS) -> TopoDS_Shape

        Builds shape from map content

        :type MS: OCC.wrapper.TopTools.TopTools_MapOfShape
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _TNaming.TNaming__MakeShape(*args)

    MakeShape = staticmethod(MakeShape)

    def FindUniqueContext(*args):
        """
        FindUniqueContext(TopoDS_Shape S, TopoDS_Shape Context) -> TopoDS_Shape

        Find unique context of shape <S>

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :type Context: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _TNaming.TNaming__FindUniqueContext(*args)

    FindUniqueContext = staticmethod(FindUniqueContext)

    def FindUniqueContextSet(*args):
        """
        FindUniqueContextSet(TopoDS_Shape S, TopoDS_Shape Context, Handle_TopTools_HArray1OfShape Arr) -> TopoDS_Shape

        Find unique context of shape <S>,which is pure concatenation
        of atomic shapes (Compound). The result is concatenation of
        single contexts

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :type Context: OCC.wrapper.TopoDS.TopoDS_Shape
        :type Arr: OCC.wrapper.TopTools.Handle_TopTools_HArray1OfShape
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _TNaming.TNaming__FindUniqueContextSet(*args)

    FindUniqueContextSet = staticmethod(FindUniqueContextSet)

    def SubstituteSShape(*args):
        """
        SubstituteSShape(TDF_Label accesslabel, TopoDS_Shape From, TopoDS_Shape To) -> Standard_Boolean

        Subtitutes shape in source structure

        :type accesslabel: OCC.wrapper.TDF.TDF_Label
        :type From: OCC.wrapper.TopoDS.TopoDS_Shape
        :type To: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TNaming.TNaming__SubstituteSShape(*args)

    SubstituteSShape = staticmethod(SubstituteSShape)

    def OuterWire(*args):
        """
        OuterWire(TopoDS_Face theFace, TopoDS_Wire theWire) -> Standard_Boolean

        Returns True if outer wire is found and the found wire in <theWire>.

        :type theFace: OCC.wrapper.TopoDS.TopoDS_Face
        :type theWire: OCC.wrapper.TopoDS.TopoDS_Wire
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TNaming.TNaming__OuterWire(*args)

    OuterWire = staticmethod(OuterWire)

    def OuterShell(*args):
        """
        OuterShell(TopoDS_Solid theSolid, TopoDS_Shell theShell) -> Standard_Boolean

        Returns True if outer Shell is found and the found shell in <theShell>.
        Print of TNaming enumeration
        =============================

        :type theSolid: OCC.wrapper.TopoDS.TopoDS_Solid
        :type theShell: OCC.wrapper.TopoDS.TopoDS_Shell
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TNaming.TNaming__OuterShell(*args)

    OuterShell = staticmethod(OuterShell)

    def IDList(*args):
        """
        IDList(NCollection_List_Standard_GUID anIDList)

        Appends to <anIDList> the list of the attributes
        IDs of this package. CAUTION: <anIDList> is NOT
        cleared before use.

        :type anIDList: OCC.wrapper.TDF.TDF_IDList

        """
        return _TNaming.TNaming__IDList(*args)

    IDList = staticmethod(IDList)

    def Print(*args):
        """
        Print(TNaming_Evolution const EVOL, Standard_OStream & S) -> Standard_OStream
        Print(TNaming_NameType const NAME, Standard_OStream & S) -> Standard_OStream
        Print(TDF_Label ACCESS, Standard_OStream & S) -> Standard_OStream &

        Prints the content of UsedShapes private  attribute as a String Table on
        the Stream <S> and returns <S>.

        :type ACCESS: OCC.wrapper.TDF.TDF_Label
        :type S: OCC.wrapper.Standard.Standard_OStream
        :rtype: OCC.wrapper.Standard.Standard_OStream

        """
        return _TNaming.TNaming__Print(*args)

    Print = staticmethod(Print)

    def __init__(self):
        """
        A topological attribute can be seen as a hook
        into the topological structure. To this hook,
        data can be attached and references defined.
        It is used for keeping and access to
        topological objects and their evolution. All
        topological objects are stored in the one
        user-protected TNaming_UsedShapes
        attribute at the root label of the data
        framework. This attribute contains map with all
        topological shapes, used in this document.
        To all other labels TNaming_NamedShape
        attribute can be added. This attribute contains
        references (hooks) to shapes from the
        TNaming_UsedShapes attribute and evolution
        of these shapes. TNaming_NamedShape
        attribute contains a set of pairs of hooks: old
        shape and new shape (see the figure below).
        It allows not only get the topological shapes by
        the labels, but also trace evolution of the
        shapes and correctly resolve dependent
        shapes by the changed one.
        If shape is just-created, then the old shape for
        accorded named shape is an empty shape. If
        a shape is deleted, then the new shape in this named shape is empty.
        Different algorithms may dispose sub-shapes
        of the result shape at the individual label depending on necessity:
        -  If a sub-shape must have some extra attributes (material of
        each face or color of each edge). In this case a specific sub-shape is
        placed to the separate label (usually, sub-label of the result shape label)
        with all attributes of this sub-shape.
        -  If topological naming is needed, a necessary and sufficient
        (for selected sub-shapes identification) set of sub-shapes is
        placed to the child labels of the result
        shape label. As usual, as far as basic solids and closed shells are
        concerned, all faces of the shape are disposed. Edges and vertices
        sub-shapes can be identified as intersection of contiguous faces.
        Modified/generated shapes may be placed to one named shape and
        identified as this named shape and source named shape that also can be
        identified with used algorithms.
        TNaming_NamedShape may contain a few
        pairs of hooks with the same evolution. In this
        case topology shape, which belongs to the
        named shape, is a compound of new shapes.
        The data model contains both the topology
        and the hooks, and functions handle both
        topological entities and hooks. Consider the
        case of a box function, which creates a solid
        with six faces and six hooks. Each hook is
        attached to a face. If you want, you can also
        have this function create hooks for edges and
        vertices as well as for faces. For the sake of
        simplicity though, let's limit the example.
        Not all functions can define explicit hooks for
        all topological entities they create, but all
        topological entities can be turned into hooks
        when necessary. This is where topological naming is necessary.
        """
        this = _TNaming.new_TNaming_()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _TNaming.delete_TNaming_
TNaming__swigregister = _TNaming.TNaming__swigregister
TNaming__swigregister(TNaming_)

def TNaming__Substitute(*args):
    """
    TNaming__Substitute(TDF_Label labelsource, TDF_Label labelcible, NCollection_DataMap_TopoDS_Shape_TopoDS_Shape_TopTools_ShapeMapHasher mapOldNew)

    Subtituter les  shapes  sur les structures de   source
    vers cible

    :type labelsource: OCC.wrapper.TDF.TDF_Label
    :type labelcible: OCC.wrapper.TDF.TDF_Label
    :type mapOldNew: OCC.wrapper.TopTools.TopTools_DataMapOfShapeShape

    """
    return _TNaming.TNaming__Substitute(*args)

def TNaming__Update(*args):
    """
    TNaming__Update(TDF_Label label, NCollection_DataMap_TopoDS_Shape_TopoDS_Shape_TopTools_ShapeMapHasher mapOldNew)

    Mise a jour des shapes du label  et de ses fils en
    tenant compte des  substitutions decrite par
    mapOldNew.

    Warning: le  remplacement du shape est  fait    dans tous
    les    attributs  qui  le contiennent meme si ceux
    ci ne sont pas associees a des sous-labels de <Label>.

    :type label: OCC.wrapper.TDF.TDF_Label
    :type mapOldNew: OCC.wrapper.TopTools.TopTools_DataMapOfShapeShape

    """
    return _TNaming.TNaming__Update(*args)

def TNaming__Displace(*args):
    """
    TNaming__Displace(TDF_Label label, TopLoc_Location aLocation, Standard_Boolean const WithOld)

    Application de la Location sur les shapes du label
    et  de   ses   sous   labels.

    :type label: OCC.wrapper.TDF.TDF_Label
    :type aLocation: OCC.wrapper.TopLoc.TopLoc_Location
    :type WithOld: bool

    """
    return _TNaming.TNaming__Displace(*args)

def TNaming__ChangeShapes(*args):
    """
    TNaming__ChangeShapes(TDF_Label label, NCollection_DataMap_TopoDS_Shape_TopoDS_Shape_TopTools_ShapeMapHasher M)

    Remplace  les  shapes du label et  des sous-labels
    par des copies.

    :type label: OCC.wrapper.TDF.TDF_Label
    :type M: OCC.wrapper.TopTools.TopTools_DataMapOfShapeShape

    """
    return _TNaming.TNaming__ChangeShapes(*args)

def TNaming__Transform(*args):
    """
    TNaming__Transform(TDF_Label label, gp_Trsf aTransformation)

    Application de la transformation sur les shapes du
    label et de ses sous labels.
    Warning: le  remplacement du shape est  fait    dans tous
    les    attributs  qui  le contiennent meme si ceux
    ci ne sont pas associees a des sous-labels de <Label>.

    :type label: OCC.wrapper.TDF.TDF_Label
    :type aTransformation: OCC.wrapper.gp.gp_Trsf

    """
    return _TNaming.TNaming__Transform(*args)

def TNaming__Replicate(*args):
    """
    Replicate(Handle_TNaming_NamedShape NS, gp_Trsf T, TDF_Label L)
    TNaming__Replicate(TopoDS_Shape SH, gp_Trsf T, TDF_Label L)

    Replicates the shape with the transformation <T>
    on the label <L> (and sub-labels if necessary)
    (TNaming_GENERATED is set)

    :type SH: OCC.wrapper.TopoDS.TopoDS_Shape
    :type T: OCC.wrapper.gp.gp_Trsf
    :type L: OCC.wrapper.TDF.TDF_Label

    """
    return _TNaming.TNaming__Replicate(*args)

def TNaming__MakeShape(*args):
    """
    TNaming__MakeShape(NCollection_Map_TopoDS_Shape_TopTools_ShapeMapHasher MS) -> TopoDS_Shape

    Builds shape from map content

    :type MS: OCC.wrapper.TopTools.TopTools_MapOfShape
    :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

    """
    return _TNaming.TNaming__MakeShape(*args)

def TNaming__FindUniqueContext(*args):
    """
    TNaming__FindUniqueContext(TopoDS_Shape S, TopoDS_Shape Context) -> TopoDS_Shape

    Find unique context of shape <S>

    :type S: OCC.wrapper.TopoDS.TopoDS_Shape
    :type Context: OCC.wrapper.TopoDS.TopoDS_Shape
    :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

    """
    return _TNaming.TNaming__FindUniqueContext(*args)

def TNaming__FindUniqueContextSet(*args):
    """
    TNaming__FindUniqueContextSet(TopoDS_Shape S, TopoDS_Shape Context, Handle_TopTools_HArray1OfShape Arr) -> TopoDS_Shape

    Find unique context of shape <S>,which is pure concatenation
    of atomic shapes (Compound). The result is concatenation of
    single contexts

    :type S: OCC.wrapper.TopoDS.TopoDS_Shape
    :type Context: OCC.wrapper.TopoDS.TopoDS_Shape
    :type Arr: OCC.wrapper.TopTools.Handle_TopTools_HArray1OfShape
    :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

    """
    return _TNaming.TNaming__FindUniqueContextSet(*args)

def TNaming__SubstituteSShape(*args):
    """
    TNaming__SubstituteSShape(TDF_Label accesslabel, TopoDS_Shape From, TopoDS_Shape To) -> Standard_Boolean

    Subtitutes shape in source structure

    :type accesslabel: OCC.wrapper.TDF.TDF_Label
    :type From: OCC.wrapper.TopoDS.TopoDS_Shape
    :type To: OCC.wrapper.TopoDS.TopoDS_Shape
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _TNaming.TNaming__SubstituteSShape(*args)

def TNaming__OuterWire(*args):
    """
    TNaming__OuterWire(TopoDS_Face theFace, TopoDS_Wire theWire) -> Standard_Boolean

    Returns True if outer wire is found and the found wire in <theWire>.

    :type theFace: OCC.wrapper.TopoDS.TopoDS_Face
    :type theWire: OCC.wrapper.TopoDS.TopoDS_Wire
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _TNaming.TNaming__OuterWire(*args)

def TNaming__OuterShell(*args):
    """
    TNaming__OuterShell(TopoDS_Solid theSolid, TopoDS_Shell theShell) -> Standard_Boolean

    Returns True if outer Shell is found and the found shell in <theShell>.
    Print of TNaming enumeration
    =============================

    :type theSolid: OCC.wrapper.TopoDS.TopoDS_Solid
    :type theShell: OCC.wrapper.TopoDS.TopoDS_Shell
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _TNaming.TNaming__OuterShell(*args)

def TNaming__IDList(*args):
    """
    TNaming__IDList(NCollection_List_Standard_GUID anIDList)

    Appends to <anIDList> the list of the attributes
    IDs of this package. CAUTION: <anIDList> is NOT
    cleared before use.

    :type anIDList: OCC.wrapper.TDF.TDF_IDList

    """
    return _TNaming.TNaming__IDList(*args)

def TNaming__Print(*args):
    """
    Print(TNaming_Evolution const EVOL, Standard_OStream & S) -> Standard_OStream
    Print(TNaming_NameType const NAME, Standard_OStream & S) -> Standard_OStream
    TNaming__Print(TDF_Label ACCESS, Standard_OStream & S) -> Standard_OStream &

    Prints the content of UsedShapes private  attribute as a String Table on
    the Stream <S> and returns <S>.

    :type ACCESS: OCC.wrapper.TDF.TDF_Label
    :type S: OCC.wrapper.Standard.Standard_OStream
    :rtype: OCC.wrapper.Standard.Standard_OStream

    """
    return _TNaming.TNaming__Print(*args)

class TNaming_Builder(object):
    """
    A tool to create and maintain topological attributes.
    Constructor creates an empty
    TNaming_NamedShape attribute at the given
    label. It allows adding "old shape" and "new
    shape" pairs with the specified evolution to this
    named shape. One evolution type per one
    builder must be used.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(TNaming_Builder self, TDF_Label aLabel) -> TNaming_Builder

        Create an   Builder.
        Warning:  Before Addition copies the current Value, and clear

        :type aLabel: OCC.wrapper.TDF.TDF_Label

        """
        this = _TNaming.new_TNaming_Builder(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Generated(self, *args):
        """
        Generated(TNaming_Builder self, TopoDS_Shape newShape)
        Generated(TNaming_Builder self, TopoDS_Shape oldShape, TopoDS_Shape newShape)

        Records the shape newShape which was
        generated from the shape oldShape during a topological construction.
        As an example, consider the case of a face
        generated from an edge in construction of a prism.

        :type oldShape: OCC.wrapper.TopoDS.TopoDS_Shape
        :type newShape: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _TNaming.TNaming_Builder_Generated(self, *args)


    def Delete(self, *args):
        """
        Delete(TNaming_Builder self, TopoDS_Shape oldShape)

        Records the shape oldShape which was deleted from the current label.
        As an example, consider the case of a face removed by a Boolean operation.

        :type oldShape: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _TNaming.TNaming_Builder_Delete(self, *args)


    def Modify(self, *args):
        """
        Modify(TNaming_Builder self, TopoDS_Shape oldShape, TopoDS_Shape newShape)

        Records the shape newShape which is a
        modification of the shape oldShape.
        As an example, consider the case of a face split
        or merged in a Boolean operation.

        :type oldShape: OCC.wrapper.TopoDS.TopoDS_Shape
        :type newShape: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _TNaming.TNaming_Builder_Modify(self, *args)


    def Select(self, *args):
        """
        Select(TNaming_Builder self, TopoDS_Shape aShape, TopoDS_Shape inShape)

        Add a  Shape to the current label ,  This Shape is
        unmodified.  Used for example  to define a set
        of shapes under a label.

        :type aShape: OCC.wrapper.TopoDS.TopoDS_Shape
        :type inShape: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _TNaming.TNaming_Builder_Select(self, *args)


    def NamedShape(self, *args):
        """
        NamedShape(TNaming_Builder self) -> Handle_TNaming_NamedShape

        Returns the NamedShape which has been built or is under construction.

        :rtype: OCC.wrapper.TNaming.Handle_TNaming_NamedShape

        """
        return _TNaming.TNaming_Builder_NamedShape(self, *args)

    __swig_destroy__ = _TNaming.delete_TNaming_Builder
TNaming_Builder_swigregister = _TNaming.TNaming_Builder_swigregister
TNaming_Builder_swigregister(TNaming_Builder)


try:
	TopTools_IndexedDataMapOfShapeListOfShape = TopTools.NCollection_IndexedDataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_ShapeMapHasher
except AttributeError:
	pass # does not exist, probably ignored

class Handle_TNaming_NamedShape(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_TNaming_NamedShape self)

        Nullify the handle


        """
        return _TNaming.Handle_TNaming_NamedShape_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_TNaming_NamedShape self) -> bool

        Check for being null

        :rtype: bool

        """
        return _TNaming.Handle_TNaming_NamedShape_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_TNaming_NamedShape self, TNaming_NamedShape thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _TNaming.Handle_TNaming_NamedShape_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_TNaming_NamedShape self, Handle_TNaming_NamedShape theHandle) -> Handle_TNaming_NamedShape
        assign(Handle_TNaming_NamedShape self, TNaming_NamedShape thePtr) -> Handle_TNaming_NamedShape
        assign(Handle_TNaming_NamedShape self, Handle_TNaming_NamedShape theHandle) -> Handle_TNaming_NamedShape

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _TNaming.Handle_TNaming_NamedShape_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_TNaming_NamedShape self) -> TNaming_NamedShape

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _TNaming.Handle_TNaming_NamedShape_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_TNaming_NamedShape self) -> TNaming_NamedShape

        Member access operator (note non-const)

        :rtype: T *

        """
        return _TNaming.Handle_TNaming_NamedShape___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_TNaming_NamedShape self) -> TNaming_NamedShape

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _TNaming.Handle_TNaming_NamedShape___ref__(self, *args)


    def __hash__(self):
        return _TNaming.Handle_TNaming_NamedShape___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _TNaming.Handle_TNaming_NamedShape___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _TNaming.new_Handle_TNaming_NamedShape(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_TNaming.Handle_TNaming_NamedShape_DownCast)
    __swig_destroy__ = _TNaming.delete_Handle_TNaming_NamedShape

    def GetID(self, *args):
        """
        class method
        ============
        Returns the GUID for named shapes.

        :rtype: OCC.wrapper.Standard.Standard_GUID

        """
        res = _TNaming.Handle_TNaming_NamedShape_GetID(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def IsEmpty(self, *args):
        """
        IsEmpty(Handle_TNaming_NamedShape self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TNaming.Handle_TNaming_NamedShape_IsEmpty(self, *args)


    def Get(self, *args):
        """
        Get(Handle_TNaming_NamedShape self) -> TopoDS_Shape

        Returns the shapes contained in <NS>. Returns a null
        shape if IsEmpty.

        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _TNaming.Handle_TNaming_NamedShape_Get(self, *args)


    def Evolution(self, *args):
        """
        Evolution(Handle_TNaming_NamedShape self) -> TNaming_Evolution

        Returns the Evolution of the attribute.

        :rtype: OCC.wrapper.TNaming.TNaming_Evolution

        """
        return _TNaming.Handle_TNaming_NamedShape_Evolution(self, *args)


    def Version(self, *args):
        """
        Version(Handle_TNaming_NamedShape self) -> Standard_Integer

        Returns the Version of the attribute.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TNaming.Handle_TNaming_NamedShape_Version(self, *args)


    def SetVersion(self, *args):
        """
        SetVersion(Handle_TNaming_NamedShape self, Standard_Integer const version)

        Set the Version of the attribute.

        :type version: int

        """
        return _TNaming.Handle_TNaming_NamedShape_SetVersion(self, *args)


    def Clear(self, *args):
        """Clear(Handle_TNaming_NamedShape self)"""
        return _TNaming.Handle_TNaming_NamedShape_Clear(self, *args)


    def ID(self, *args):
        """
        Returns the ID of the attribute.

        :rtype: OCC.wrapper.Standard.Standard_GUID

        """
        res = _TNaming.Handle_TNaming_NamedShape_ID(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def BackupCopy(self, *args):
        """
        BackupCopy(Handle_TNaming_NamedShape self) -> Handle_TDF_Attribute

        Copies  the attribute  contents into  a  new other
        attribute. It is used by Backup().

        :rtype: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TNaming.Handle_TNaming_NamedShape_BackupCopy(self, *args)


    def Restore(self, *args):
        """
        Restore(Handle_TNaming_NamedShape self, Handle_TDF_Attribute anAttribute)

        Restores the contents from <anAttribute> into this
        one. It is used when aborting a transaction.

        :type anAttribute: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TNaming.Handle_TNaming_NamedShape_Restore(self, *args)


    def DeltaOnRemoval(self, *args):
        """
        DeltaOnRemoval(Handle_TNaming_NamedShape self) -> Handle_TDF_DeltaOnRemoval

        Makes a DeltaOnRemoval on <me> because <me> has
        disappeared from the DS.

        :rtype: OCC.wrapper.TDF.Handle_TDF_DeltaOnRemoval

        """
        return _TNaming.Handle_TNaming_NamedShape_DeltaOnRemoval(self, *args)


    def NewEmpty(self, *args):
        """
        NewEmpty(Handle_TNaming_NamedShape self) -> Handle_TDF_Attribute

        Returns an new empty attribute from the good end
        type. It is used by the copy algorithm.

        :rtype: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TNaming.Handle_TNaming_NamedShape_NewEmpty(self, *args)


    def Paste(self, *args):
        """
        Paste(Handle_TNaming_NamedShape self, Handle_TDF_Attribute intoAttribute, Handle_TDF_RelocationTable aRelocTationable)

        This method is different from the "Copy" one,
        because it is used when copying an attribute from
        a source structure into a target structure. This
        method pastes the current attribute to the label
        corresponding to the insertor. The pasted
        attribute may be a brand new one or a new version
        of the previous one.

        :type intoAttribute: OCC.wrapper.TDF.Handle_TDF_Attribute
        :type aRelocTationable: OCC.wrapper.TDF.Handle_TDF_RelocationTable

        """
        return _TNaming.Handle_TNaming_NamedShape_Paste(self, *args)


    def References(self, *args):
        """
        References(Handle_TNaming_NamedShape self, Handle_TDF_DataSet aDataSet)

        Adds the directly referenced attributes and labels
        to <aDataSet>. "Directly" means we have only to
        look at the first level of references.

        :type aDataSet: OCC.wrapper.TDF.Handle_TDF_DataSet

        """
        return _TNaming.Handle_TNaming_NamedShape_References(self, *args)


    def BeforeRemoval(self, *args):
        """
        BeforeRemoval(Handle_TNaming_NamedShape self)

        Something to do before removing an Attribute from
        a label.


        """
        return _TNaming.Handle_TNaming_NamedShape_BeforeRemoval(self, *args)


    def BeforeUndo(self, *args):
        """
        BeforeUndo(Handle_TNaming_NamedShape self, Handle_TDF_AttributeDelta anAttDelta, Standard_Boolean const forceIt) -> Standard_Boolean

        Something to do before applying <anAttDelta>

        :type anAttDelta: OCC.wrapper.TDF.Handle_TDF_AttributeDelta
        :type forceIt: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TNaming.Handle_TNaming_NamedShape_BeforeUndo(self, *args)


    def AfterUndo(self, *args):
        """
        AfterUndo(Handle_TNaming_NamedShape self, Handle_TDF_AttributeDelta anAttDelta, Standard_Boolean const forceIt) -> Standard_Boolean

        Something to do after applying <anAttDelta>.

        :type anAttDelta: OCC.wrapper.TDF.Handle_TDF_AttributeDelta
        :type forceIt: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TNaming.Handle_TNaming_NamedShape_AfterUndo(self, *args)


    def Dump(self, *args):
        """
        Dump(Handle_TNaming_NamedShape self, Standard_OStream & anOS) -> Standard_OStream &

        Dumps the attribute on <aStream>.

        :type anOS: OCC.wrapper.Standard.Standard_OStream
        :rtype: OCC.wrapper.Standard.Standard_OStream

        """
        return _TNaming.Handle_TNaming_NamedShape_Dump(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_TNaming_NamedShape self) -> char const *

        :rtype: const char *

        """
        return _TNaming.Handle_TNaming_NamedShape_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TNaming.Handle_TNaming_NamedShape_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TNaming.Handle_TNaming_NamedShape_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetID(self, *args):
        """
        SetID(Handle_TNaming_NamedShape self, Standard_GUID arg2)
        SetID(Handle_TNaming_NamedShape self)

        Sets default ID defined in nested class (to be used for attributes having User ID feature).


        """
        return _TNaming.Handle_TNaming_NamedShape_SetID(self, *args)


    def Label(self, *args):
        """
        Label(Handle_TNaming_NamedShape self) -> TDF_Label

        Returns   the   label to which  the   attribute is
        attached. If the  label is not  included in a  DF,
        the label is null. See Label.
        Warning
        If the label is not included in a data
        framework, it is null.
        This function should not be redefined inline.

        :rtype: OCC.wrapper.TDF.TDF_Label

        """
        return _TNaming.Handle_TNaming_NamedShape_Label(self, *args)


    def Transaction(self, *args):
        """
        Transaction(Handle_TNaming_NamedShape self) -> Standard_Integer

        Returns the transaction index in which the
        attribute has been created or modified.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TNaming.Handle_TNaming_NamedShape_Transaction(self, *args)


    def UntilTransaction(self, *args):
        """
        UntilTransaction(Handle_TNaming_NamedShape self) -> Standard_Integer

        Returns the upper transaction index until which
        the attribute is/was valid. This number may
        vary. A removed attribute validity range is
        reduced to its transaction index.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TNaming.Handle_TNaming_NamedShape_UntilTransaction(self, *args)


    def IsValid(self, *args):
        """
        IsValid(Handle_TNaming_NamedShape self) -> Standard_Boolean

        Returns true if the attribute is valid; i.e. not a
        backuped or removed one.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TNaming.Handle_TNaming_NamedShape_IsValid(self, *args)


    def IsNew(self, *args):
        """
        IsNew(Handle_TNaming_NamedShape self) -> Standard_Boolean

        Returns true if the attribute has no backup

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TNaming.Handle_TNaming_NamedShape_IsNew(self, *args)


    def IsForgotten(self, *args):
        """
        IsForgotten(Handle_TNaming_NamedShape self) -> Standard_Boolean

        Returns true if the attribute forgotten status is
        set.

        ShortCut Methods concerning associated attributes
        =================================================

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TNaming.Handle_TNaming_NamedShape_IsForgotten(self, *args)


    def IsAttribute(self, *args):
        """
        IsAttribute(Handle_TNaming_NamedShape self, Standard_GUID anID) -> Standard_Boolean

        Returns true if it  exists an associated attribute
        of <me> with <anID> as ID.

        :type anID: OCC.wrapper.Standard.Standard_GUID
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TNaming.Handle_TNaming_NamedShape_IsAttribute(self, *args)


    def FindAttribute(self, *args):
        """
        FindAttribute(Handle_TNaming_NamedShape self, Standard_GUID anID, Handle_TDF_Attribute anAttribute) -> Standard_Boolean

        Finds an associated  attribute of  <me>, according
        to <anID>.  the returned <anAttribute> is a  valid
        one. The  method  returns  True if   found,  False
        otherwise.   A removed attribute  cannot be found using
        this  method.

        :type anID: OCC.wrapper.Standard.Standard_GUID
        :type anAttribute: OCC.wrapper.TDF.Handle_TDF_Attribute
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TNaming.Handle_TNaming_NamedShape_FindAttribute(self, *args)


    def AddAttribute(self, *args):
        """
        AddAttribute(Handle_TNaming_NamedShape self, Handle_TDF_Attribute other)

        Adds   an   Attribute <other>  to  the   label  of
        <me>.Raises if there is  already  one of the same
        GUID fhan <other>.

        :type other: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TNaming.Handle_TNaming_NamedShape_AddAttribute(self, *args)


    def ForgetAttribute(self, *args):
        """
        ForgetAttribute(Handle_TNaming_NamedShape self, Standard_GUID aguid) -> Standard_Boolean

        Forgets  the Attribute of  GUID <aguid> associated
        to the label of <me>. Be  carefull that if <me> is
        the attribute of <guid>, <me> will have a null label
        after this call.  If  the attribute doesn't  exist
        returns False. Otherwise returns True.

        :type aguid: OCC.wrapper.Standard.Standard_GUID
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TNaming.Handle_TNaming_NamedShape_ForgetAttribute(self, *args)


    def ForgetAllAttributes(self, *args):
        """
        ForgetAllAttributes(Handle_TNaming_NamedShape self, Standard_Boolean const clearChildren)

        Forgets all the  attributes attached to  the label
        of <me>.    Does   it   on  the  sub-labels   if
        <clearChildren> is set  to true.  Of  course, this
        method  is  compatible with Transaction  &  Delta
        mecanisms. Be carefull  that  if <me> will have a
        null label after this call

        :type clearChildren: bool

        """
        return _TNaming.Handle_TNaming_NamedShape_ForgetAllAttributes(self, *args)


    def AfterAddition(self, *args):
        """
        AfterAddition(Handle_TNaming_NamedShape self)

        Something to do after adding an Attribute to a label.


        """
        return _TNaming.Handle_TNaming_NamedShape_AfterAddition(self, *args)


    def BeforeForget(self, *args):
        """
        BeforeForget(Handle_TNaming_NamedShape self)

        Something to do before forgetting an Attribute to a
        label.


        """
        return _TNaming.Handle_TNaming_NamedShape_BeforeForget(self, *args)


    def AfterResume(self, *args):
        """
        AfterResume(Handle_TNaming_NamedShape self)

        Something to do after resuming an Attribute from
        a label.


        """
        return _TNaming.Handle_TNaming_NamedShape_AfterResume(self, *args)


    def AfterRetrieval(self, *args):
        """
        AfterRetrieval(Handle_TNaming_NamedShape self, Standard_Boolean const forceIt) -> Standard_Boolean

        Something to do AFTER creation of an attribute by
        persistent-transient translation. The returned
        status says if AfterUndo has been performed (true)
        or if this callback must be called once again
        further (false). If <forceIt> is set to true, the
        method MUST perform and return true. Does nothing
        by default and returns true.

        :type forceIt: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TNaming.Handle_TNaming_NamedShape_AfterRetrieval(self, *args)


    def BeforeCommitTransaction(self, *args):
        """
        BeforeCommitTransaction(Handle_TNaming_NamedShape self)

        A callback.
        By default does nothing.
        It is called by TDF_Data::CommitTransaction() method.


        """
        return _TNaming.Handle_TNaming_NamedShape_BeforeCommitTransaction(self, *args)


    def Backup(self, *args):
        """
        Backup(Handle_TNaming_NamedShape self)

        Backups the attribute. The backuped attribute is
        flagged "Backuped" and not "Valid".

        The method does nothing:

        1) If the attribute transaction number is equal to
        the current transaction number (the attribute has
        already been backuped).

        2) If the attribute is not attached to a label.


        """
        return _TNaming.Handle_TNaming_NamedShape_Backup(self, *args)


    def IsBackuped(self, *args):
        """
        IsBackuped(Handle_TNaming_NamedShape self) -> Standard_Boolean

        Returns true if the attribute backup status is
        set. This status is set/unset by the
        Backup() method.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TNaming.Handle_TNaming_NamedShape_IsBackuped(self, *args)


    def DeltaOnAddition(self, *args):
        """
        DeltaOnAddition(Handle_TNaming_NamedShape self) -> Handle_TDF_DeltaOnAddition

        Makes an AttributeDelta because <me>
        appeared. The only known use of a redefinition of
        this method is to return a null handle (no delta).

        :rtype: OCC.wrapper.TDF.Handle_TDF_DeltaOnAddition

        """
        return _TNaming.Handle_TNaming_NamedShape_DeltaOnAddition(self, *args)


    def DeltaOnForget(self, *args):
        """
        DeltaOnForget(Handle_TNaming_NamedShape self) -> Handle_TDF_DeltaOnForget

        Makes an AttributeDelta because <me> has been
        forgotten.

        :rtype: OCC.wrapper.TDF.Handle_TDF_DeltaOnForget

        """
        return _TNaming.Handle_TNaming_NamedShape_DeltaOnForget(self, *args)


    def DeltaOnResume(self, *args):
        """
        DeltaOnResume(Handle_TNaming_NamedShape self) -> Handle_TDF_DeltaOnResume

        Makes an AttributeDelta because <me> has been
        resumed.

        :rtype: OCC.wrapper.TDF.Handle_TDF_DeltaOnResume

        """
        return _TNaming.Handle_TNaming_NamedShape_DeltaOnResume(self, *args)


    def __lshift__(self, *args):
        """
        __lshift__(Handle_TNaming_NamedShape self, Standard_OStream & anOS) -> Standard_OStream &

        :type anOS: OCC.wrapper.Standard.Standard_OStream
        :rtype: OCC.wrapper.Standard.Standard_OStream

        """
        return _TNaming.Handle_TNaming_NamedShape___lshift__(self, *args)


    def ExtendedDump(self, *args):
        """
        ExtendedDump(Handle_TNaming_NamedShape self, Standard_OStream & anOS, TDF_IDFilter aFilter, NCollection_IndexedMap_Handle_TDF_Attribute_TColStd_MapTransientHasher aMap)

        Dumps the attribute content on <aStream>, using
        <aMap> like this: if an attribute is not in the
        map, first put add it to the map and then dump it.
        Use the map rank instead of dumping each attribute
        field.

        :type anOS: OCC.wrapper.Standard.Standard_OStream
        :type aFilter: OCC.wrapper.TDF.TDF_IDFilter
        :type aMap: OCC.wrapper.TDF.TDF_AttributeIndexedMap

        """
        return _TNaming.Handle_TNaming_NamedShape_ExtendedDump(self, *args)


    def Forget(self, *args):
        """
        Forget(Handle_TNaming_NamedShape self, Standard_Integer const aTransaction)

        Forgets the attribute. <aTransaction> is the
        current transaction in which the forget is done. A
        forgotten attribute is also flagged not "Valid".

        A forgotten attribute is invisible. Set also the
        "Valid" status to False. Obvioulsy, DF cannot
        empty an attribute (this has a semantic
        signification), but can remove it from the
        structure. So, a forgotten attribute is NOT an empty
        one, but a soon DEAD one.

        Should be private.

        :type aTransaction: int

        """
        return _TNaming.Handle_TNaming_NamedShape_Forget(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_TNaming_NamedShape self)

        Memory deallocator for transient classes


        """
        return _TNaming.Handle_TNaming_NamedShape_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_TNaming_NamedShape self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_TNaming_NamedShape self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TNaming.Handle_TNaming_NamedShape_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_TNaming_NamedShape self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_TNaming_NamedShape self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TNaming.Handle_TNaming_NamedShape_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_TNaming_NamedShape self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _TNaming.Handle_TNaming_NamedShape_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_TNaming_NamedShape self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TNaming.Handle_TNaming_NamedShape_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_TNaming_NamedShape self)

        Increments the reference counter of this object


        """
        return _TNaming.Handle_TNaming_NamedShape_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_TNaming_NamedShape self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TNaming.Handle_TNaming_NamedShape_DecrementRefCounter(self, *args)

Handle_TNaming_NamedShape_swigregister = _TNaming.Handle_TNaming_NamedShape_swigregister
Handle_TNaming_NamedShape_swigregister(Handle_TNaming_NamedShape)

def Handle_TNaming_NamedShape_DownCast(thing):
    return _TNaming.Handle_TNaming_NamedShape_DownCast(thing)
Handle_TNaming_NamedShape_DownCast = _TNaming.Handle_TNaming_NamedShape_DownCast

class NCollection_DataMap_TopoDS_Shape_TNaming_PtrRefShape_TopTools_ShapeMapHasher(NCollection.NCollection_BaseMap):
    """
    Purpose:     The DataMap is a Map to store keys with associated
    Items. See Map  from NCollection for  a discussion
    about the number of buckets.

    The DataMap can be seen as an extended array where
    the Keys  are the   indices.  For this reason  the
    operator () is defined on DataMap to fetch an Item
    from a Key. So the following syntax can be used :

    anItem = aMap(aKey);
    aMap(aKey) = anItem;

    This analogy has its  limit.   aMap(aKey) = anItem
    can  be done only  if aKey was previously bound to
    an item in the map.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_DataMap_TopoDS_Shape_TNaming_PtrRefShape_TopTools_ShapeMapHasher self) -> NCollection_DataMap< TopoDS_Shape,TNaming_RefShape *,TopTools_ShapeMapHasher >::iterator

        Returns an iterator pointing to the first element in the map.

        :rtype: iterator

        """
        return _TNaming.NCollection_DataMap_TopoDS_Shape_TNaming_PtrRefShape_TopTools_ShapeMapHasher_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_DataMap_TopoDS_Shape_TNaming_PtrRefShape_TopTools_ShapeMapHasher self) -> NCollection_DataMap< TopoDS_Shape,TNaming_RefShape *,TopTools_ShapeMapHasher >::iterator

        Returns an iterator referring to the past-the-end element in the map.

        :rtype: iterator

        """
        return _TNaming.NCollection_DataMap_TopoDS_Shape_TNaming_PtrRefShape_TopTools_ShapeMapHasher_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_DataMap_TopoDS_Shape_TNaming_PtrRefShape_TopTools_ShapeMapHasher self) -> NCollection_DataMap< TopoDS_Shape,TNaming_RefShape *,TopTools_ShapeMapHasher >::const_iterator

        Returns a const iterator pointing to the first element in the map.

        :rtype: const_iterator

        """
        return _TNaming.NCollection_DataMap_TopoDS_Shape_TNaming_PtrRefShape_TopTools_ShapeMapHasher_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_DataMap_TopoDS_Shape_TNaming_PtrRefShape_TopTools_ShapeMapHasher self) -> NCollection_DataMap< TopoDS_Shape,TNaming_RefShape *,TopTools_ShapeMapHasher >::const_iterator

        Returns a const iterator referring to the past-the-end element in the map.

        :rtype: const_iterator

        """
        return _TNaming.NCollection_DataMap_TopoDS_Shape_TNaming_PtrRefShape_TopTools_ShapeMapHasher_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     The DataMap is a Map to store keys with associated
        Items. See Map  from NCollection for  a discussion
        about the number of buckets.

        The DataMap can be seen as an extended array where
        the Keys  are the   indices.  For this reason  the
        operator () is defined on DataMap to fetch an Item
        from a Key. So the following syntax can be used :

        anItem = aMap(aKey);
        aMap(aKey) = anItem;

        This analogy has its  limit.   aMap(aKey) = anItem
        can  be done only  if aKey was previously bound to
        an item in the map.
        """
        this = _TNaming.new_NCollection_DataMap_TopoDS_Shape_TNaming_PtrRefShape_TopTools_ShapeMapHasher(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Exchange(self, *args):
        """
        Exchange(NCollection_DataMap_TopoDS_Shape_TNaming_PtrRefShape_TopTools_ShapeMapHasher self, NCollection_DataMap_TopoDS_Shape_TNaming_PtrRefShape_TopTools_ShapeMapHasher theOther)

        Exchange the content of two maps without re-allocations.
        Notice that allocators will be swapped as well!

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _TNaming.NCollection_DataMap_TopoDS_Shape_TNaming_PtrRefShape_TopTools_ShapeMapHasher_Exchange(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_DataMap_TopoDS_Shape_TNaming_PtrRefShape_TopTools_ShapeMapHasher self, NCollection_DataMap_TopoDS_Shape_TNaming_PtrRefShape_TopTools_ShapeMapHasher theOther) -> NCollection_DataMap_TopoDS_Shape_TNaming_PtrRefShape_TopTools_ShapeMapHasher

        Assignment.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _TNaming.NCollection_DataMap_TopoDS_Shape_TNaming_PtrRefShape_TopTools_ShapeMapHasher_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_DataMap_TopoDS_Shape_TNaming_PtrRefShape_TopTools_ShapeMapHasher self, NCollection_DataMap_TopoDS_Shape_TNaming_PtrRefShape_TopTools_ShapeMapHasher theOther) -> NCollection_DataMap_TopoDS_Shape_TNaming_PtrRefShape_TopTools_ShapeMapHasher

        Assignment operator

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _TNaming.NCollection_DataMap_TopoDS_Shape_TNaming_PtrRefShape_TopTools_ShapeMapHasher_assign(self, *args)


    def ReSize(self, *args):
        """
        ReSize(NCollection_DataMap_TopoDS_Shape_TNaming_PtrRefShape_TopTools_ShapeMapHasher self, Standard_Integer const N)

        ReSize

        :type N: int

        """
        return _TNaming.NCollection_DataMap_TopoDS_Shape_TNaming_PtrRefShape_TopTools_ShapeMapHasher_ReSize(self, *args)


    def Bind(self, *args):
        """
        Bind(NCollection_DataMap_TopoDS_Shape_TNaming_PtrRefShape_TopTools_ShapeMapHasher self, TopoDS_Shape theKey, TNaming_RefShape theItem) -> Standard_Boolean

        Bind binds Item to Key in map.
        @param theKey  key to add/update
        @param theItem new item; overrides value previously bound to the key, if any
        @return Standard_True if Key was not bound already

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TNaming.NCollection_DataMap_TopoDS_Shape_TNaming_PtrRefShape_TopTools_ShapeMapHasher_Bind(self, *args)


    def Bound(self, *args):
        """
        Bound(NCollection_DataMap_TopoDS_Shape_TNaming_PtrRefShape_TopTools_ShapeMapHasher self, TopoDS_Shape theKey, TNaming_RefShape theItem) -> TNaming_RefShape **

        Bound binds Item to Key in map. Returns modifiable Item 

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: TheItemType *

        """
        return _TNaming.NCollection_DataMap_TopoDS_Shape_TNaming_PtrRefShape_TopTools_ShapeMapHasher_Bound(self, *args)


    def IsBound(self, *args):
        """
        IsBound(NCollection_DataMap_TopoDS_Shape_TNaming_PtrRefShape_TopTools_ShapeMapHasher self, TopoDS_Shape theKey) -> Standard_Boolean

        IsBound

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TNaming.NCollection_DataMap_TopoDS_Shape_TNaming_PtrRefShape_TopTools_ShapeMapHasher_IsBound(self, *args)


    def UnBind(self, *args):
        """
        UnBind(NCollection_DataMap_TopoDS_Shape_TNaming_PtrRefShape_TopTools_ShapeMapHasher self, TopoDS_Shape theKey) -> Standard_Boolean

        UnBind removes Item Key pair from map

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TNaming.NCollection_DataMap_TopoDS_Shape_TNaming_PtrRefShape_TopTools_ShapeMapHasher_UnBind(self, *args)


    def Seek(self, *args):
        """
        Seek(NCollection_DataMap_TopoDS_Shape_TNaming_PtrRefShape_TopTools_ShapeMapHasher self, TopoDS_Shape theKey) -> TNaming_RefShape *const *

        Seek returns pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: const TheItemType *

        """
        return _TNaming.NCollection_DataMap_TopoDS_Shape_TNaming_PtrRefShape_TopTools_ShapeMapHasher_Seek(self, *args)


    def Find(self, *args):
        """
        Find returns the Item for Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _TNaming.NCollection_DataMap_TopoDS_Shape_TNaming_PtrRefShape_TopTools_ShapeMapHasher_Find(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeSeek(self, *args):
        """
        ChangeSeek(NCollection_DataMap_TopoDS_Shape_TNaming_PtrRefShape_TopTools_ShapeMapHasher self, TopoDS_Shape theKey) -> TNaming_RefShape **

        ChangeSeek returns modifiable pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: TheItemType *

        """
        return _TNaming.NCollection_DataMap_TopoDS_Shape_TNaming_PtrRefShape_TopTools_ShapeMapHasher_ChangeSeek(self, *args)


    def ChangeFind(self, *args):
        """
        ChangeFind(NCollection_DataMap_TopoDS_Shape_TNaming_PtrRefShape_TopTools_ShapeMapHasher self, TopoDS_Shape theKey) -> TNaming_RefShape *&

        ChangeFind returns mofifiable Item by Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: TheItemType &

        """
        return _TNaming.NCollection_DataMap_TopoDS_Shape_TNaming_PtrRefShape_TopTools_ShapeMapHasher_ChangeFind(self, *args)


    def __call__(self, *args):
        """
        operator ()

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _TNaming.NCollection_DataMap_TopoDS_Shape_TNaming_PtrRefShape_TopTools_ShapeMapHasher___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Clear(self, *args):
        """
        Clear(NCollection_DataMap_TopoDS_Shape_TNaming_PtrRefShape_TopTools_ShapeMapHasher self, Standard_Boolean const doReleaseMemory)
        Clear(NCollection_DataMap_TopoDS_Shape_TNaming_PtrRefShape_TopTools_ShapeMapHasher self, Handle_NCollection_BaseAllocator theAllocator)

        Clear data and reset allocator

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _TNaming.NCollection_DataMap_TopoDS_Shape_TNaming_PtrRefShape_TopTools_ShapeMapHasher_Clear(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_DataMap_TopoDS_Shape_TNaming_PtrRefShape_TopTools_ShapeMapHasher self) -> Standard_Integer

        Size

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TNaming.NCollection_DataMap_TopoDS_Shape_TNaming_PtrRefShape_TopTools_ShapeMapHasher_Size(self, *args)


    def __iter__(self):
        return _TNaming.NCollection_DataMap_TopoDS_Shape_TNaming_PtrRefShape_TopTools_ShapeMapHasher___iter__(self)
    __swig_destroy__ = _TNaming.delete_NCollection_DataMap_TopoDS_Shape_TNaming_PtrRefShape_TopTools_ShapeMapHasher
NCollection_DataMap_TopoDS_Shape_TNaming_PtrRefShape_TopTools_ShapeMapHasher_swigregister = _TNaming.NCollection_DataMap_TopoDS_Shape_TNaming_PtrRefShape_TopTools_ShapeMapHasher_swigregister
NCollection_DataMap_TopoDS_Shape_TNaming_PtrRefShape_TopTools_ShapeMapHasher_swigregister(NCollection_DataMap_TopoDS_Shape_TNaming_PtrRefShape_TopTools_ShapeMapHasher)

class NCollection_DataMap_TopoDS_Shape_TNaming_PtrRefShape_TopTools_ShapeMapHasher_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _TNaming.new_NCollection_DataMap_TopoDS_Shape_TNaming_PtrRefShape_TopTools_ShapeMapHasher_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _TNaming.delete_NCollection_DataMap_TopoDS_Shape_TNaming_PtrRefShape_TopTools_ShapeMapHasher_IteratorHelper

    def __next__(self):
        return _TNaming.NCollection_DataMap_TopoDS_Shape_TNaming_PtrRefShape_TopTools_ShapeMapHasher_IteratorHelper___next__(self)
NCollection_DataMap_TopoDS_Shape_TNaming_PtrRefShape_TopTools_ShapeMapHasher_IteratorHelper_swigregister = _TNaming.NCollection_DataMap_TopoDS_Shape_TNaming_PtrRefShape_TopTools_ShapeMapHasher_IteratorHelper_swigregister
NCollection_DataMap_TopoDS_Shape_TNaming_PtrRefShape_TopTools_ShapeMapHasher_IteratorHelper_swigregister(NCollection_DataMap_TopoDS_Shape_TNaming_PtrRefShape_TopTools_ShapeMapHasher_IteratorHelper)


try:
	TNaming_DataMapOfShapePtrRefShape = NCollection_DataMap_TopoDS_Shape_TNaming_PtrRefShape_TopTools_ShapeMapHasher
except NameError:
	pass # does not exist, probably ignored

class Handle_TNaming_DeltaOnRemoval(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_TNaming_DeltaOnRemoval self)

        Nullify the handle


        """
        return _TNaming.Handle_TNaming_DeltaOnRemoval_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_TNaming_DeltaOnRemoval self) -> bool

        Check for being null

        :rtype: bool

        """
        return _TNaming.Handle_TNaming_DeltaOnRemoval_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_TNaming_DeltaOnRemoval self, TNaming_DeltaOnRemoval thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _TNaming.Handle_TNaming_DeltaOnRemoval_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_TNaming_DeltaOnRemoval self, Handle_TNaming_DeltaOnRemoval theHandle) -> Handle_TNaming_DeltaOnRemoval
        assign(Handle_TNaming_DeltaOnRemoval self, TNaming_DeltaOnRemoval thePtr) -> Handle_TNaming_DeltaOnRemoval
        assign(Handle_TNaming_DeltaOnRemoval self, Handle_TNaming_DeltaOnRemoval theHandle) -> Handle_TNaming_DeltaOnRemoval

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _TNaming.Handle_TNaming_DeltaOnRemoval_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_TNaming_DeltaOnRemoval self) -> TNaming_DeltaOnRemoval

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _TNaming.Handle_TNaming_DeltaOnRemoval_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_TNaming_DeltaOnRemoval self) -> TNaming_DeltaOnRemoval

        Member access operator (note non-const)

        :rtype: T *

        """
        return _TNaming.Handle_TNaming_DeltaOnRemoval___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_TNaming_DeltaOnRemoval self) -> TNaming_DeltaOnRemoval

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _TNaming.Handle_TNaming_DeltaOnRemoval___ref__(self, *args)


    def __hash__(self):
        return _TNaming.Handle_TNaming_DeltaOnRemoval___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _TNaming.Handle_TNaming_DeltaOnRemoval___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _TNaming.new_Handle_TNaming_DeltaOnRemoval(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_TNaming.Handle_TNaming_DeltaOnRemoval_DownCast)
    __swig_destroy__ = _TNaming.delete_Handle_TNaming_DeltaOnRemoval

    def Apply(self, *args):
        """
        Apply(Handle_TNaming_DeltaOnRemoval self)

        Applies the delta to the attribute.


        """
        return _TNaming.Handle_TNaming_DeltaOnRemoval_Apply(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_TNaming_DeltaOnRemoval self) -> char const *

        :rtype: const char *

        """
        return _TNaming.Handle_TNaming_DeltaOnRemoval_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TNaming.Handle_TNaming_DeltaOnRemoval_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TNaming.Handle_TNaming_DeltaOnRemoval_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Label(self, *args):
        """
        Label(Handle_TNaming_DeltaOnRemoval self) -> TDF_Label

        Returns the label concerned by <me>.

        :rtype: OCC.wrapper.TDF.TDF_Label

        """
        return _TNaming.Handle_TNaming_DeltaOnRemoval_Label(self, *args)


    def Attribute(self, *args):
        """
        Attribute(Handle_TNaming_DeltaOnRemoval self) -> Handle_TDF_Attribute

        Returns the reference attribute.

        :rtype: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TNaming.Handle_TNaming_DeltaOnRemoval_Attribute(self, *args)


    def ID(self, *args):
        """
        ID(Handle_TNaming_DeltaOnRemoval self) -> Standard_GUID

        Returns the ID of the attribute concerned by <me>.

        :rtype: OCC.wrapper.Standard.Standard_GUID

        """
        return _TNaming.Handle_TNaming_DeltaOnRemoval_ID(self, *args)


    def Dump(self, *args):
        """
        Dump(Handle_TNaming_DeltaOnRemoval self, Standard_OStream & OS) -> Standard_OStream &

        Dumps the contents.

        :type OS: OCC.wrapper.Standard.Standard_OStream
        :rtype: OCC.wrapper.Standard.Standard_OStream

        """
        return _TNaming.Handle_TNaming_DeltaOnRemoval_Dump(self, *args)


    def __lshift__(self, *args):
        """
        __lshift__(Handle_TNaming_DeltaOnRemoval self, Standard_OStream & OS) -> Standard_OStream &

        :type OS: OCC.wrapper.Standard.Standard_OStream
        :rtype: OCC.wrapper.Standard.Standard_OStream

        """
        return _TNaming.Handle_TNaming_DeltaOnRemoval___lshift__(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_TNaming_DeltaOnRemoval self)

        Memory deallocator for transient classes


        """
        return _TNaming.Handle_TNaming_DeltaOnRemoval_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_TNaming_DeltaOnRemoval self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_TNaming_DeltaOnRemoval self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TNaming.Handle_TNaming_DeltaOnRemoval_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_TNaming_DeltaOnRemoval self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_TNaming_DeltaOnRemoval self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TNaming.Handle_TNaming_DeltaOnRemoval_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_TNaming_DeltaOnRemoval self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _TNaming.Handle_TNaming_DeltaOnRemoval_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_TNaming_DeltaOnRemoval self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TNaming.Handle_TNaming_DeltaOnRemoval_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_TNaming_DeltaOnRemoval self)

        Increments the reference counter of this object


        """
        return _TNaming.Handle_TNaming_DeltaOnRemoval_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_TNaming_DeltaOnRemoval self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TNaming.Handle_TNaming_DeltaOnRemoval_DecrementRefCounter(self, *args)

Handle_TNaming_DeltaOnRemoval_swigregister = _TNaming.Handle_TNaming_DeltaOnRemoval_swigregister
Handle_TNaming_DeltaOnRemoval_swigregister(Handle_TNaming_DeltaOnRemoval)

def Handle_TNaming_DeltaOnRemoval_DownCast(thing):
    return _TNaming.Handle_TNaming_DeltaOnRemoval_DownCast(thing)
Handle_TNaming_DeltaOnRemoval_DownCast = _TNaming.Handle_TNaming_DeltaOnRemoval_DownCast

class TNaming_SameShapeIterator(object):
    """
    To iterate on   all  the label which contained  a
    given shape.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(TNaming_SameShapeIterator self, TopoDS_Shape aShape, TDF_Label access) -> TNaming_SameShapeIterator

        :type aShape: OCC.wrapper.TopoDS.TopoDS_Shape
        :type access: OCC.wrapper.TDF.TDF_Label

        """
        this = _TNaming.new_TNaming_SameShapeIterator(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def More(self, *args):
        """
        More(TNaming_SameShapeIterator self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TNaming.TNaming_SameShapeIterator_More(self, *args)


    def Next(self, *args):
        """Next(TNaming_SameShapeIterator self)"""
        return _TNaming.TNaming_SameShapeIterator_Next(self, *args)


    def Label(self, *args):
        """
        Label(TNaming_SameShapeIterator self) -> TDF_Label

        :rtype: OCC.wrapper.TDF.TDF_Label

        """
        return _TNaming.TNaming_SameShapeIterator_Label(self, *args)

    __swig_destroy__ = _TNaming.delete_TNaming_SameShapeIterator
TNaming_SameShapeIterator_swigregister = _TNaming.TNaming_SameShapeIterator_swigregister
TNaming_SameShapeIterator_swigregister(TNaming_SameShapeIterator)

class Handle_TNaming_DeltaOnModification(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_TNaming_DeltaOnModification self)

        Nullify the handle


        """
        return _TNaming.Handle_TNaming_DeltaOnModification_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_TNaming_DeltaOnModification self) -> bool

        Check for being null

        :rtype: bool

        """
        return _TNaming.Handle_TNaming_DeltaOnModification_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_TNaming_DeltaOnModification self, TNaming_DeltaOnModification thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _TNaming.Handle_TNaming_DeltaOnModification_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_TNaming_DeltaOnModification self, Handle_TNaming_DeltaOnModification theHandle) -> Handle_TNaming_DeltaOnModification
        assign(Handle_TNaming_DeltaOnModification self, TNaming_DeltaOnModification thePtr) -> Handle_TNaming_DeltaOnModification
        assign(Handle_TNaming_DeltaOnModification self, Handle_TNaming_DeltaOnModification theHandle) -> Handle_TNaming_DeltaOnModification

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _TNaming.Handle_TNaming_DeltaOnModification_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_TNaming_DeltaOnModification self) -> TNaming_DeltaOnModification

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _TNaming.Handle_TNaming_DeltaOnModification_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_TNaming_DeltaOnModification self) -> TNaming_DeltaOnModification

        Member access operator (note non-const)

        :rtype: T *

        """
        return _TNaming.Handle_TNaming_DeltaOnModification___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_TNaming_DeltaOnModification self) -> TNaming_DeltaOnModification

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _TNaming.Handle_TNaming_DeltaOnModification___ref__(self, *args)


    def __hash__(self):
        return _TNaming.Handle_TNaming_DeltaOnModification___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _TNaming.Handle_TNaming_DeltaOnModification___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _TNaming.new_Handle_TNaming_DeltaOnModification(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_TNaming.Handle_TNaming_DeltaOnModification_DownCast)
    __swig_destroy__ = _TNaming.delete_Handle_TNaming_DeltaOnModification

    def Apply(self, *args):
        """
        Apply(Handle_TNaming_DeltaOnModification self)

        Applies the delta to the attribute.


        """
        return _TNaming.Handle_TNaming_DeltaOnModification_Apply(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_TNaming_DeltaOnModification self) -> char const *

        :rtype: const char *

        """
        return _TNaming.Handle_TNaming_DeltaOnModification_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TNaming.Handle_TNaming_DeltaOnModification_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TNaming.Handle_TNaming_DeltaOnModification_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Label(self, *args):
        """
        Label(Handle_TNaming_DeltaOnModification self) -> TDF_Label

        Returns the label concerned by <me>.

        :rtype: OCC.wrapper.TDF.TDF_Label

        """
        return _TNaming.Handle_TNaming_DeltaOnModification_Label(self, *args)


    def Attribute(self, *args):
        """
        Attribute(Handle_TNaming_DeltaOnModification self) -> Handle_TDF_Attribute

        Returns the reference attribute.

        :rtype: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TNaming.Handle_TNaming_DeltaOnModification_Attribute(self, *args)


    def ID(self, *args):
        """
        ID(Handle_TNaming_DeltaOnModification self) -> Standard_GUID

        Returns the ID of the attribute concerned by <me>.

        :rtype: OCC.wrapper.Standard.Standard_GUID

        """
        return _TNaming.Handle_TNaming_DeltaOnModification_ID(self, *args)


    def Dump(self, *args):
        """
        Dump(Handle_TNaming_DeltaOnModification self, Standard_OStream & OS) -> Standard_OStream &

        Dumps the contents.

        :type OS: OCC.wrapper.Standard.Standard_OStream
        :rtype: OCC.wrapper.Standard.Standard_OStream

        """
        return _TNaming.Handle_TNaming_DeltaOnModification_Dump(self, *args)


    def __lshift__(self, *args):
        """
        __lshift__(Handle_TNaming_DeltaOnModification self, Standard_OStream & OS) -> Standard_OStream &

        :type OS: OCC.wrapper.Standard.Standard_OStream
        :rtype: OCC.wrapper.Standard.Standard_OStream

        """
        return _TNaming.Handle_TNaming_DeltaOnModification___lshift__(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_TNaming_DeltaOnModification self)

        Memory deallocator for transient classes


        """
        return _TNaming.Handle_TNaming_DeltaOnModification_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_TNaming_DeltaOnModification self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_TNaming_DeltaOnModification self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TNaming.Handle_TNaming_DeltaOnModification_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_TNaming_DeltaOnModification self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_TNaming_DeltaOnModification self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TNaming.Handle_TNaming_DeltaOnModification_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_TNaming_DeltaOnModification self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _TNaming.Handle_TNaming_DeltaOnModification_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_TNaming_DeltaOnModification self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TNaming.Handle_TNaming_DeltaOnModification_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_TNaming_DeltaOnModification self)

        Increments the reference counter of this object


        """
        return _TNaming.Handle_TNaming_DeltaOnModification_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_TNaming_DeltaOnModification self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TNaming.Handle_TNaming_DeltaOnModification_DecrementRefCounter(self, *args)

Handle_TNaming_DeltaOnModification_swigregister = _TNaming.Handle_TNaming_DeltaOnModification_swigregister
Handle_TNaming_DeltaOnModification_swigregister(Handle_TNaming_DeltaOnModification)

def Handle_TNaming_DeltaOnModification_DownCast(thing):
    return _TNaming.Handle_TNaming_DeltaOnModification_DownCast(thing)
Handle_TNaming_DeltaOnModification_DownCast = _TNaming.Handle_TNaming_DeltaOnModification_DownCast

class TNaming_Scope(object):
    """
    this class manage a scope of labels
    ===================================
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(TNaming_Scope self) -> TNaming_Scope
        __init__(TNaming_Scope self, Standard_Boolean const WithValid) -> TNaming_Scope
        __init__(TNaming_Scope self, NCollection_Map_TDF_Label_TDF_LabelMapHasher valid) -> TNaming_Scope

        create a scope with a map. WithValid = TRUE.

        :type valid: OCC.wrapper.TDF.TDF_LabelMap

        """
        this = _TNaming.new_TNaming_Scope(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def WithValid(self, *args):
        """
        WithValid(TNaming_Scope self) -> Standard_Boolean
        WithValid(TNaming_Scope self, Standard_Boolean const mode)

        :type mode: bool

        """
        return _TNaming.TNaming_Scope_WithValid(self, *args)


    def ClearValid(self, *args):
        """ClearValid(TNaming_Scope self)"""
        return _TNaming.TNaming_Scope_ClearValid(self, *args)


    def Valid(self, *args):
        """
        Valid(TNaming_Scope self, TDF_Label L)

        :type L: OCC.wrapper.TDF.TDF_Label

        """
        return _TNaming.TNaming_Scope_Valid(self, *args)


    def ValidChildren(self, *args):
        """
        ValidChildren(TNaming_Scope self, TDF_Label L, Standard_Boolean const withroot)

        :type L: OCC.wrapper.TDF.TDF_Label
        :type withroot: bool

        """
        return _TNaming.TNaming_Scope_ValidChildren(self, *args)


    def Unvalid(self, *args):
        """
        Unvalid(TNaming_Scope self, TDF_Label L)

        :type L: OCC.wrapper.TDF.TDF_Label

        """
        return _TNaming.TNaming_Scope_Unvalid(self, *args)


    def UnvalidChildren(self, *args):
        """
        UnvalidChildren(TNaming_Scope self, TDF_Label L, Standard_Boolean const withroot)

        :type L: OCC.wrapper.TDF.TDF_Label
        :type withroot: bool

        """
        return _TNaming.TNaming_Scope_UnvalidChildren(self, *args)


    def IsValid(self, *args):
        """
        IsValid(TNaming_Scope self, TDF_Label L) -> Standard_Boolean

        :type L: OCC.wrapper.TDF.TDF_Label
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TNaming.TNaming_Scope_IsValid(self, *args)


    def GetValid(self, *args):
        """
        :rtype: OCC.wrapper.TDF.TDF_LabelMap

        """
        res = _TNaming.TNaming_Scope_GetValid(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValid(self, *args):
        """
        ChangeValid(TNaming_Scope self) -> NCollection_Map_TDF_Label_TDF_LabelMapHasher

        :rtype: OCC.wrapper.TDF.TDF_LabelMap

        """
        return _TNaming.TNaming_Scope_ChangeValid(self, *args)


    def CurrentShape(self, *args):
        """
        CurrentShape(TNaming_Scope self, Handle_TNaming_NamedShape NS) -> TopoDS_Shape

        Returns  the current  value of  <NS> according to the
        Valid Scope.

        :type NS: OCC.wrapper.TNaming.Handle_TNaming_NamedShape
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _TNaming.TNaming_Scope_CurrentShape(self, *args)

    __swig_destroy__ = _TNaming.delete_TNaming_Scope
TNaming_Scope_swigregister = _TNaming.TNaming_Scope_swigregister
TNaming_Scope_swigregister(TNaming_Scope)


try:
	TopTools_ListOfShape = TopoDS.NCollection_List_TopoDS_Shape
except AttributeError:
	pass # does not exist, probably ignored


try:
	TopTools_MapOfShape = TopTools.NCollection_Map_TopoDS_Shape_TopTools_ShapeMapHasher
except AttributeError:
	pass # does not exist, probably ignored

class Handle_TNaming_Naming(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_TNaming_Naming self)

        Nullify the handle


        """
        return _TNaming.Handle_TNaming_Naming_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_TNaming_Naming self) -> bool

        Check for being null

        :rtype: bool

        """
        return _TNaming.Handle_TNaming_Naming_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_TNaming_Naming self, TNaming_Naming thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _TNaming.Handle_TNaming_Naming_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_TNaming_Naming self, Handle_TNaming_Naming theHandle) -> Handle_TNaming_Naming
        assign(Handle_TNaming_Naming self, TNaming_Naming thePtr) -> Handle_TNaming_Naming
        assign(Handle_TNaming_Naming self, Handle_TNaming_Naming theHandle) -> Handle_TNaming_Naming

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _TNaming.Handle_TNaming_Naming_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_TNaming_Naming self) -> TNaming_Naming

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _TNaming.Handle_TNaming_Naming_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_TNaming_Naming self) -> TNaming_Naming

        Member access operator (note non-const)

        :rtype: T *

        """
        return _TNaming.Handle_TNaming_Naming___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_TNaming_Naming self) -> TNaming_Naming

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _TNaming.Handle_TNaming_Naming___ref__(self, *args)


    def __hash__(self):
        return _TNaming.Handle_TNaming_Naming___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _TNaming.Handle_TNaming_Naming___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _TNaming.new_Handle_TNaming_Naming(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_TNaming.Handle_TNaming_Naming_DownCast)
    __swig_destroy__ = _TNaming.delete_Handle_TNaming_Naming

    def GetID(self, *args):
        """
        following code from TDesignStd
        ==============================

        :rtype: OCC.wrapper.Standard.Standard_GUID

        """
        res = _TNaming.Handle_TNaming_Naming_GetID(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Insert(self, *args):
        """
        Insert(Handle_TNaming_Naming self, TDF_Label under) -> Handle_TNaming_Naming

        :type under: OCC.wrapper.TDF.TDF_Label
        :rtype: OCC.wrapper.TNaming.Handle_TNaming_Naming

        """
        return _TNaming.Handle_TNaming_Naming_Insert(self, *args)


    def Name(self, *args):
        """
        Name(Handle_TNaming_Naming self, TDF_Label where, TopoDS_Shape Selection, TopoDS_Shape Context, Standard_Boolean const Geometry, Standard_Boolean const KeepOrientation, Standard_Boolean const BNproblem) -> Handle_TNaming_NamedShape

        Creates  a   Namimg  attribute  at  label <where>   to
        identify  the   shape   <Selection>.    Geometry is
        Standard_True  if   we  are  only  interested  by  the
        underlying   geometry     (e.g.     setting   a
        constraint). <Context> is  used to find neighbours  of
        <S> when required by the naming.
        If KeepOrientation is True the Selection orientation is taken
        into  account. BNproblem == True points out that Context sub-shapes
        in  DF have orientation differences with Context shape itself.
        instance method
        ===============

        :type where: OCC.wrapper.TDF.TDF_Label
        :type Selection: OCC.wrapper.TopoDS.TopoDS_Shape
        :type Context: OCC.wrapper.TopoDS.TopoDS_Shape
        :type Geometry: bool
        :type KeepOrientation: bool
        :type BNproblem: bool
        :rtype: OCC.wrapper.TNaming.Handle_TNaming_NamedShape

        """
        return _TNaming.Handle_TNaming_Naming_Name(self, *args)


    def IsDefined(self, *args):
        """
        IsDefined(Handle_TNaming_Naming self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TNaming.Handle_TNaming_Naming_IsDefined(self, *args)


    def GetName(self, *args):
        """
        :rtype: OCC.wrapper.TNaming.TNaming_Name

        """
        res = _TNaming.Handle_TNaming_Naming_GetName(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeName(self, *args):
        """
        ChangeName(Handle_TNaming_Naming self) -> TNaming_Name

        :rtype: OCC.wrapper.TNaming.TNaming_Name

        """
        return _TNaming.Handle_TNaming_Naming_ChangeName(self, *args)


    def Regenerate(self, *args):
        """
        Regenerate(Handle_TNaming_Naming self, NCollection_Map_TDF_Label_TDF_LabelMapHasher scope) -> Standard_Boolean

        regenerate only the Name associated to me

        :type scope: OCC.wrapper.TDF.TDF_LabelMap
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TNaming.Handle_TNaming_Naming_Regenerate(self, *args)


    def Solve(self, *args):
        """
        Solve(Handle_TNaming_Naming self, NCollection_Map_TDF_Label_TDF_LabelMapHasher scope) -> Standard_Boolean

        Regenerate recursively the  whole name with scope.  If
        scope  is empty it  means that  all the labels  of the
        framework are valid.

        :type scope: OCC.wrapper.TDF.TDF_LabelMap
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TNaming.Handle_TNaming_Naming_Solve(self, *args)


    def ID(self, *args):
        """
        Deferred methods from TDF_Attribute
        ===================================

        :rtype: OCC.wrapper.Standard.Standard_GUID

        """
        res = _TNaming.Handle_TNaming_Naming_ID(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def NewEmpty(self, *args):
        """
        NewEmpty(Handle_TNaming_Naming self) -> Handle_TDF_Attribute

        :rtype: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TNaming.Handle_TNaming_Naming_NewEmpty(self, *args)


    def Restore(self, *args):
        """
        Restore(Handle_TNaming_Naming self, Handle_TDF_Attribute With)

        :type With: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TNaming.Handle_TNaming_Naming_Restore(self, *args)


    def Paste(self, *args):
        """
        Paste(Handle_TNaming_Naming self, Handle_TDF_Attribute Into, Handle_TDF_RelocationTable RT)

        :type Into: OCC.wrapper.TDF.Handle_TDF_Attribute
        :type RT: OCC.wrapper.TDF.Handle_TDF_RelocationTable

        """
        return _TNaming.Handle_TNaming_Naming_Paste(self, *args)


    def References(self, *args):
        """
        References(Handle_TNaming_Naming self, Handle_TDF_DataSet aDataSet)

        :type aDataSet: OCC.wrapper.TDF.Handle_TDF_DataSet

        """
        return _TNaming.Handle_TNaming_Naming_References(self, *args)


    def Dump(self, *args):
        """
        Dump(Handle_TNaming_Naming self, Standard_OStream & anOS) -> Standard_OStream &

        :type anOS: OCC.wrapper.Standard.Standard_OStream
        :rtype: OCC.wrapper.Standard.Standard_OStream

        """
        return _TNaming.Handle_TNaming_Naming_Dump(self, *args)


    def ExtendedDump(self, *args):
        """
        ExtendedDump(Handle_TNaming_Naming self, Standard_OStream & anOS, TDF_IDFilter aFilter, NCollection_IndexedMap_Handle_TDF_Attribute_TColStd_MapTransientHasher aMap)

        :type anOS: OCC.wrapper.Standard.Standard_OStream
        :type aFilter: OCC.wrapper.TDF.TDF_IDFilter
        :type aMap: OCC.wrapper.TDF.TDF_AttributeIndexedMap

        """
        return _TNaming.Handle_TNaming_Naming_ExtendedDump(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_TNaming_Naming self) -> char const *

        :rtype: const char *

        """
        return _TNaming.Handle_TNaming_Naming_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TNaming.Handle_TNaming_Naming_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TNaming.Handle_TNaming_Naming_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetID(self, *args):
        """
        SetID(Handle_TNaming_Naming self, Standard_GUID arg2)
        SetID(Handle_TNaming_Naming self)

        Sets default ID defined in nested class (to be used for attributes having User ID feature).


        """
        return _TNaming.Handle_TNaming_Naming_SetID(self, *args)


    def Label(self, *args):
        """
        Label(Handle_TNaming_Naming self) -> TDF_Label

        Returns   the   label to which  the   attribute is
        attached. If the  label is not  included in a  DF,
        the label is null. See Label.
        Warning
        If the label is not included in a data
        framework, it is null.
        This function should not be redefined inline.

        :rtype: OCC.wrapper.TDF.TDF_Label

        """
        return _TNaming.Handle_TNaming_Naming_Label(self, *args)


    def Transaction(self, *args):
        """
        Transaction(Handle_TNaming_Naming self) -> Standard_Integer

        Returns the transaction index in which the
        attribute has been created or modified.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TNaming.Handle_TNaming_Naming_Transaction(self, *args)


    def UntilTransaction(self, *args):
        """
        UntilTransaction(Handle_TNaming_Naming self) -> Standard_Integer

        Returns the upper transaction index until which
        the attribute is/was valid. This number may
        vary. A removed attribute validity range is
        reduced to its transaction index.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TNaming.Handle_TNaming_Naming_UntilTransaction(self, *args)


    def IsValid(self, *args):
        """
        IsValid(Handle_TNaming_Naming self) -> Standard_Boolean

        Returns true if the attribute is valid; i.e. not a
        backuped or removed one.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TNaming.Handle_TNaming_Naming_IsValid(self, *args)


    def IsNew(self, *args):
        """
        IsNew(Handle_TNaming_Naming self) -> Standard_Boolean

        Returns true if the attribute has no backup

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TNaming.Handle_TNaming_Naming_IsNew(self, *args)


    def IsForgotten(self, *args):
        """
        IsForgotten(Handle_TNaming_Naming self) -> Standard_Boolean

        Returns true if the attribute forgotten status is
        set.

        ShortCut Methods concerning associated attributes
        =================================================

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TNaming.Handle_TNaming_Naming_IsForgotten(self, *args)


    def IsAttribute(self, *args):
        """
        IsAttribute(Handle_TNaming_Naming self, Standard_GUID anID) -> Standard_Boolean

        Returns true if it  exists an associated attribute
        of <me> with <anID> as ID.

        :type anID: OCC.wrapper.Standard.Standard_GUID
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TNaming.Handle_TNaming_Naming_IsAttribute(self, *args)


    def FindAttribute(self, *args):
        """
        FindAttribute(Handle_TNaming_Naming self, Standard_GUID anID, Handle_TDF_Attribute anAttribute) -> Standard_Boolean

        Finds an associated  attribute of  <me>, according
        to <anID>.  the returned <anAttribute> is a  valid
        one. The  method  returns  True if   found,  False
        otherwise.   A removed attribute  cannot be found using
        this  method.

        :type anID: OCC.wrapper.Standard.Standard_GUID
        :type anAttribute: OCC.wrapper.TDF.Handle_TDF_Attribute
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TNaming.Handle_TNaming_Naming_FindAttribute(self, *args)


    def AddAttribute(self, *args):
        """
        AddAttribute(Handle_TNaming_Naming self, Handle_TDF_Attribute other)

        Adds   an   Attribute <other>  to  the   label  of
        <me>.Raises if there is  already  one of the same
        GUID fhan <other>.

        :type other: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TNaming.Handle_TNaming_Naming_AddAttribute(self, *args)


    def ForgetAttribute(self, *args):
        """
        ForgetAttribute(Handle_TNaming_Naming self, Standard_GUID aguid) -> Standard_Boolean

        Forgets  the Attribute of  GUID <aguid> associated
        to the label of <me>. Be  carefull that if <me> is
        the attribute of <guid>, <me> will have a null label
        after this call.  If  the attribute doesn't  exist
        returns False. Otherwise returns True.

        :type aguid: OCC.wrapper.Standard.Standard_GUID
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TNaming.Handle_TNaming_Naming_ForgetAttribute(self, *args)


    def ForgetAllAttributes(self, *args):
        """
        ForgetAllAttributes(Handle_TNaming_Naming self, Standard_Boolean const clearChildren)

        Forgets all the  attributes attached to  the label
        of <me>.    Does   it   on  the  sub-labels   if
        <clearChildren> is set  to true.  Of  course, this
        method  is  compatible with Transaction  &  Delta
        mecanisms. Be carefull  that  if <me> will have a
        null label after this call

        :type clearChildren: bool

        """
        return _TNaming.Handle_TNaming_Naming_ForgetAllAttributes(self, *args)


    def AfterAddition(self, *args):
        """
        AfterAddition(Handle_TNaming_Naming self)

        Something to do after adding an Attribute to a label.


        """
        return _TNaming.Handle_TNaming_Naming_AfterAddition(self, *args)


    def BeforeRemoval(self, *args):
        """
        BeforeRemoval(Handle_TNaming_Naming self)

        Something to do before removing an Attribute from
        a label.


        """
        return _TNaming.Handle_TNaming_Naming_BeforeRemoval(self, *args)


    def BeforeForget(self, *args):
        """
        BeforeForget(Handle_TNaming_Naming self)

        Something to do before forgetting an Attribute to a
        label.


        """
        return _TNaming.Handle_TNaming_Naming_BeforeForget(self, *args)


    def AfterResume(self, *args):
        """
        AfterResume(Handle_TNaming_Naming self)

        Something to do after resuming an Attribute from
        a label.


        """
        return _TNaming.Handle_TNaming_Naming_AfterResume(self, *args)


    def AfterRetrieval(self, *args):
        """
        AfterRetrieval(Handle_TNaming_Naming self, Standard_Boolean const forceIt) -> Standard_Boolean

        Something to do AFTER creation of an attribute by
        persistent-transient translation. The returned
        status says if AfterUndo has been performed (true)
        or if this callback must be called once again
        further (false). If <forceIt> is set to true, the
        method MUST perform and return true. Does nothing
        by default and returns true.

        :type forceIt: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TNaming.Handle_TNaming_Naming_AfterRetrieval(self, *args)


    def BeforeUndo(self, *args):
        """
        BeforeUndo(Handle_TNaming_Naming self, Handle_TDF_AttributeDelta anAttDelta, Standard_Boolean const forceIt) -> Standard_Boolean

        Something to do before applying <anAttDelta>. The
        returned status says if AfterUndo has been
        performed (true) or if this callback must be
        called once again further (false). If <forceIt> is
        set to true, the method MUST perform and return
        true. Does nothing by default and returns true.

        :type anAttDelta: OCC.wrapper.TDF.Handle_TDF_AttributeDelta
        :type forceIt: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TNaming.Handle_TNaming_Naming_BeforeUndo(self, *args)


    def AfterUndo(self, *args):
        """
        AfterUndo(Handle_TNaming_Naming self, Handle_TDF_AttributeDelta anAttDelta, Standard_Boolean const forceIt) -> Standard_Boolean

        Something to do after applying <anAttDelta>. The
        returned status says if AfterUndo has been
        performed (true) or if this callback must be
        called once again further (false). If <forceIt> is
        set to true, the method MUST perform and return
        true. Does nothing by default and returns true.

        :type anAttDelta: OCC.wrapper.TDF.Handle_TDF_AttributeDelta
        :type forceIt: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TNaming.Handle_TNaming_Naming_AfterUndo(self, *args)


    def BeforeCommitTransaction(self, *args):
        """
        BeforeCommitTransaction(Handle_TNaming_Naming self)

        A callback.
        By default does nothing.
        It is called by TDF_Data::CommitTransaction() method.


        """
        return _TNaming.Handle_TNaming_Naming_BeforeCommitTransaction(self, *args)


    def Backup(self, *args):
        """
        Backup(Handle_TNaming_Naming self)

        Backups the attribute. The backuped attribute is
        flagged "Backuped" and not "Valid".

        The method does nothing:

        1) If the attribute transaction number is equal to
        the current transaction number (the attribute has
        already been backuped).

        2) If the attribute is not attached to a label.


        """
        return _TNaming.Handle_TNaming_Naming_Backup(self, *args)


    def IsBackuped(self, *args):
        """
        IsBackuped(Handle_TNaming_Naming self) -> Standard_Boolean

        Returns true if the attribute backup status is
        set. This status is set/unset by the
        Backup() method.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TNaming.Handle_TNaming_Naming_IsBackuped(self, *args)


    def BackupCopy(self, *args):
        """
        BackupCopy(Handle_TNaming_Naming self) -> Handle_TDF_Attribute

        Copies  the attribute  contents into  a  new other
        attribute. It is used by Backup().

        :rtype: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TNaming.Handle_TNaming_Naming_BackupCopy(self, *args)


    def DeltaOnAddition(self, *args):
        """
        DeltaOnAddition(Handle_TNaming_Naming self) -> Handle_TDF_DeltaOnAddition

        Makes an AttributeDelta because <me>
        appeared. The only known use of a redefinition of
        this method is to return a null handle (no delta).

        :rtype: OCC.wrapper.TDF.Handle_TDF_DeltaOnAddition

        """
        return _TNaming.Handle_TNaming_Naming_DeltaOnAddition(self, *args)


    def DeltaOnForget(self, *args):
        """
        DeltaOnForget(Handle_TNaming_Naming self) -> Handle_TDF_DeltaOnForget

        Makes an AttributeDelta because <me> has been
        forgotten.

        :rtype: OCC.wrapper.TDF.Handle_TDF_DeltaOnForget

        """
        return _TNaming.Handle_TNaming_Naming_DeltaOnForget(self, *args)


    def DeltaOnResume(self, *args):
        """
        DeltaOnResume(Handle_TNaming_Naming self) -> Handle_TDF_DeltaOnResume

        Makes an AttributeDelta because <me> has been
        resumed.

        :rtype: OCC.wrapper.TDF.Handle_TDF_DeltaOnResume

        """
        return _TNaming.Handle_TNaming_Naming_DeltaOnResume(self, *args)


    def DeltaOnRemoval(self, *args):
        """
        DeltaOnRemoval(Handle_TNaming_Naming self) -> Handle_TDF_DeltaOnRemoval

        Makes a DeltaOnRemoval on <me> because <me> has
        disappeared from the DS.

        :rtype: OCC.wrapper.TDF.Handle_TDF_DeltaOnRemoval

        """
        return _TNaming.Handle_TNaming_Naming_DeltaOnRemoval(self, *args)


    def __lshift__(self, *args):
        """
        __lshift__(Handle_TNaming_Naming self, Standard_OStream & anOS) -> Standard_OStream &

        :type anOS: OCC.wrapper.Standard.Standard_OStream
        :rtype: OCC.wrapper.Standard.Standard_OStream

        """
        return _TNaming.Handle_TNaming_Naming___lshift__(self, *args)


    def Forget(self, *args):
        """
        Forget(Handle_TNaming_Naming self, Standard_Integer const aTransaction)

        Forgets the attribute. <aTransaction> is the
        current transaction in which the forget is done. A
        forgotten attribute is also flagged not "Valid".

        A forgotten attribute is invisible. Set also the
        "Valid" status to False. Obvioulsy, DF cannot
        empty an attribute (this has a semantic
        signification), but can remove it from the
        structure. So, a forgotten attribute is NOT an empty
        one, but a soon DEAD one.

        Should be private.

        :type aTransaction: int

        """
        return _TNaming.Handle_TNaming_Naming_Forget(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_TNaming_Naming self)

        Memory deallocator for transient classes


        """
        return _TNaming.Handle_TNaming_Naming_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_TNaming_Naming self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_TNaming_Naming self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TNaming.Handle_TNaming_Naming_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_TNaming_Naming self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_TNaming_Naming self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TNaming.Handle_TNaming_Naming_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_TNaming_Naming self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _TNaming.Handle_TNaming_Naming_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_TNaming_Naming self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TNaming.Handle_TNaming_Naming_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_TNaming_Naming self)

        Increments the reference counter of this object


        """
        return _TNaming.Handle_TNaming_Naming_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_TNaming_Naming self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TNaming.Handle_TNaming_Naming_DecrementRefCounter(self, *args)

Handle_TNaming_Naming_swigregister = _TNaming.Handle_TNaming_Naming_swigregister
Handle_TNaming_Naming_swigregister(Handle_TNaming_Naming)

def Handle_TNaming_Naming_DownCast(thing):
    return _TNaming.Handle_TNaming_Naming_DownCast(thing)
Handle_TNaming_Naming_DownCast = _TNaming.Handle_TNaming_Naming_DownCast

class NCollection_Map_Handle_TNaming_NamedShape_TNaming_NamedShapeHasher(NCollection.NCollection_BaseMap):
    """
    Purpose:     Single hashed Map. This  Map is used  to store and
    retrieve keys in linear time.

    The ::Iterator class can be  used to explore  the
    content of the map. It is not  wise to iterate and
    modify a map in parallel.

    To compute  the hashcode of  the key the  function
    ::HashCode must be defined in the global namespace

    To compare two keys the function ::IsEqual must be
    defined in the global namespace.

    The performance of  a Map is conditionned  by  its
    number of buckets that  should be kept greater  to
    the number   of keys.  This  map has  an automatic
    management of the number of buckets. It is resized
    when  the number of Keys  becomes greater than the
    number of buckets.

    If you have a fair  idea of the number of  objects
    you  can save on automatic   resizing by giving  a
    number of buckets  at creation or using the ReSize
    method. This should be  consider only for  crucial
    optimisation issues.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def cbegin(self, *args):
        """
        cbegin(NCollection_Map_Handle_TNaming_NamedShape_TNaming_NamedShapeHasher self) -> NCollection_Map< opencascade::handle< TNaming_NamedShape >,TNaming_NamedShapeHasher >::const_iterator

        Returns a const iterator pointing to the first element in the map.

        :rtype: const_iterator

        """
        return _TNaming.NCollection_Map_Handle_TNaming_NamedShape_TNaming_NamedShapeHasher_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Map_Handle_TNaming_NamedShape_TNaming_NamedShapeHasher self) -> NCollection_Map< opencascade::handle< TNaming_NamedShape >,TNaming_NamedShapeHasher >::const_iterator

        Returns a const iterator referring to the past-the-end element in the map.

        :rtype: const_iterator

        """
        return _TNaming.NCollection_Map_Handle_TNaming_NamedShape_TNaming_NamedShapeHasher_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     Single hashed Map. This  Map is used  to store and
        retrieve keys in linear time.

        The ::Iterator class can be  used to explore  the
        content of the map. It is not  wise to iterate and
        modify a map in parallel.

        To compute  the hashcode of  the key the  function
        ::HashCode must be defined in the global namespace

        To compare two keys the function ::IsEqual must be
        defined in the global namespace.

        The performance of  a Map is conditionned  by  its
        number of buckets that  should be kept greater  to
        the number   of keys.  This  map has  an automatic
        management of the number of buckets. It is resized
        when  the number of Keys  becomes greater than the
        number of buckets.

        If you have a fair  idea of the number of  objects
        you  can save on automatic   resizing by giving  a
        number of buckets  at creation or using the ReSize
        method. This should be  consider only for  crucial
        optimisation issues.
        """
        this = _TNaming.new_NCollection_Map_Handle_TNaming_NamedShape_TNaming_NamedShapeHasher(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Exchange(self, *args):
        """
        Exchange(NCollection_Map_Handle_TNaming_NamedShape_TNaming_NamedShapeHasher self, NCollection_Map_Handle_TNaming_NamedShape_TNaming_NamedShapeHasher theOther)

        Exchange the content of two maps without re-allocations.
        Notice that allocators will be swapped as well!

        :type theOther: OCC.wrapper.NCollection.NCollection_Map

        """
        return _TNaming.NCollection_Map_Handle_TNaming_NamedShape_TNaming_NamedShapeHasher_Exchange(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Map_Handle_TNaming_NamedShape_TNaming_NamedShapeHasher self, NCollection_Map_Handle_TNaming_NamedShape_TNaming_NamedShapeHasher theOther) -> NCollection_Map_Handle_TNaming_NamedShape_TNaming_NamedShapeHasher

        Assign.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_Map
        :rtype: OCC.wrapper.NCollection.NCollection_Map

        """
        return _TNaming.NCollection_Map_Handle_TNaming_NamedShape_TNaming_NamedShapeHasher_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Map_Handle_TNaming_NamedShape_TNaming_NamedShapeHasher self, NCollection_Map_Handle_TNaming_NamedShape_TNaming_NamedShapeHasher theOther) -> NCollection_Map_Handle_TNaming_NamedShape_TNaming_NamedShapeHasher

        Assign operator

        :type theOther: OCC.wrapper.NCollection.NCollection_Map
        :rtype: OCC.wrapper.NCollection.NCollection_Map

        """
        return _TNaming.NCollection_Map_Handle_TNaming_NamedShape_TNaming_NamedShapeHasher_assign(self, *args)


    def ReSize(self, *args):
        """
        ReSize(NCollection_Map_Handle_TNaming_NamedShape_TNaming_NamedShapeHasher self, Standard_Integer const N)

        ReSize

        :type N: int

        """
        return _TNaming.NCollection_Map_Handle_TNaming_NamedShape_TNaming_NamedShapeHasher_ReSize(self, *args)


    def Add(self, *args):
        """
        Add(NCollection_Map_Handle_TNaming_NamedShape_TNaming_NamedShapeHasher self, Handle_TNaming_NamedShape K) -> Standard_Boolean

        Add

        :type K: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TNaming.NCollection_Map_Handle_TNaming_NamedShape_TNaming_NamedShapeHasher_Add(self, *args)


    def Added(self, *args):
        """
        Added: add a new key if not yet in the map, and return 
        reference to either newly added or previously existing object

        :type K: const TheKeyType &
        :rtype: const TheKeyType &

        """
        res = _TNaming.NCollection_Map_Handle_TNaming_NamedShape_TNaming_NamedShapeHasher_Added(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Remove(self, *args):
        """
        Remove(NCollection_Map_Handle_TNaming_NamedShape_TNaming_NamedShapeHasher self, Handle_TNaming_NamedShape K) -> Standard_Boolean

        Remove

        :type K: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TNaming.NCollection_Map_Handle_TNaming_NamedShape_TNaming_NamedShapeHasher_Remove(self, *args)


    def Clear(self, *args):
        """
        Clear(NCollection_Map_Handle_TNaming_NamedShape_TNaming_NamedShapeHasher self, Standard_Boolean const doReleaseMemory)
        Clear(NCollection_Map_Handle_TNaming_NamedShape_TNaming_NamedShapeHasher self, Handle_NCollection_BaseAllocator theAllocator)

        Clear data and reset allocator

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _TNaming.NCollection_Map_Handle_TNaming_NamedShape_TNaming_NamedShapeHasher_Clear(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_Map_Handle_TNaming_NamedShape_TNaming_NamedShapeHasher self) -> Standard_Integer

        Size

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TNaming.NCollection_Map_Handle_TNaming_NamedShape_TNaming_NamedShapeHasher_Size(self, *args)


    def IsEqual(self, *args):
        """
        IsEqual(NCollection_Map_Handle_TNaming_NamedShape_TNaming_NamedShapeHasher self, NCollection_Map_Handle_TNaming_NamedShape_TNaming_NamedShapeHasher theOther) -> Standard_Boolean

        @return true if two maps contains exactly the same keys

        :type theOther: OCC.wrapper.NCollection.NCollection_Map
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TNaming.NCollection_Map_Handle_TNaming_NamedShape_TNaming_NamedShapeHasher_IsEqual(self, *args)


    def Contains(self, *args):
        """
        Contains(NCollection_Map_Handle_TNaming_NamedShape_TNaming_NamedShapeHasher self, Handle_TNaming_NamedShape K) -> Standard_Boolean
        Contains(NCollection_Map_Handle_TNaming_NamedShape_TNaming_NamedShapeHasher self, NCollection_Map_Handle_TNaming_NamedShape_TNaming_NamedShapeHasher theOther) -> Standard_Boolean

        @return true if this map contains ALL keys of another map.

        :type theOther: OCC.wrapper.NCollection.NCollection_Map
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TNaming.NCollection_Map_Handle_TNaming_NamedShape_TNaming_NamedShapeHasher_Contains(self, *args)


    def Union(self, *args):
        """
        Union(NCollection_Map_Handle_TNaming_NamedShape_TNaming_NamedShapeHasher self, NCollection_Map_Handle_TNaming_NamedShape_TNaming_NamedShapeHasher theLeft, NCollection_Map_Handle_TNaming_NamedShape_TNaming_NamedShapeHasher theRight)

        Sets this Map to be the result of union (aka addition, fuse, merge, boolean OR) operation between two given Maps
        The new Map contains the values that are contained either in the first map or in the second map or in both.
        All previous content of this Map is cleared.
        This map (result of the boolean operation) can also be passed as one of operands.

        :type theLeft: OCC.wrapper.NCollection.NCollection_Map
        :type theRight: OCC.wrapper.NCollection.NCollection_Map

        """
        return _TNaming.NCollection_Map_Handle_TNaming_NamedShape_TNaming_NamedShapeHasher_Union(self, *args)


    def Unite(self, *args):
        """
        Unite(NCollection_Map_Handle_TNaming_NamedShape_TNaming_NamedShapeHasher self, NCollection_Map_Handle_TNaming_NamedShape_TNaming_NamedShapeHasher theOther) -> Standard_Boolean

        Apply to this Map the boolean operation union (aka addition, fuse, merge, boolean OR) with another (given) Map.
        The result contains the values that were previously contained in this map or contained in the given (operand) map.
        This algorithm is similar to method Union().
        Returns True if contents of this map is changed.

        :type theOther: OCC.wrapper.NCollection.NCollection_Map
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TNaming.NCollection_Map_Handle_TNaming_NamedShape_TNaming_NamedShapeHasher_Unite(self, *args)


    def HasIntersection(self, *args):
        """
        HasIntersection(NCollection_Map_Handle_TNaming_NamedShape_TNaming_NamedShapeHasher self, NCollection_Map_Handle_TNaming_NamedShape_TNaming_NamedShapeHasher theMap) -> Standard_Boolean

        Returns true if this and theMap have common elements.

        :type theMap: OCC.wrapper.NCollection.NCollection_Map
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TNaming.NCollection_Map_Handle_TNaming_NamedShape_TNaming_NamedShapeHasher_HasIntersection(self, *args)


    def Intersection(self, *args):
        """
        Intersection(NCollection_Map_Handle_TNaming_NamedShape_TNaming_NamedShapeHasher self, NCollection_Map_Handle_TNaming_NamedShape_TNaming_NamedShapeHasher theLeft, NCollection_Map_Handle_TNaming_NamedShape_TNaming_NamedShapeHasher theRight)

        Sets this Map to be the result of intersection (aka multiplication, common, boolean AND) operation between two given Maps.
        The new Map contains only the values that are contained in both map operands.
        All previous content of this Map is cleared.
        This same map (result of the boolean operation) can also be used as one of operands.

        :type theLeft: OCC.wrapper.NCollection.NCollection_Map
        :type theRight: OCC.wrapper.NCollection.NCollection_Map

        """
        return _TNaming.NCollection_Map_Handle_TNaming_NamedShape_TNaming_NamedShapeHasher_Intersection(self, *args)


    def Intersect(self, *args):
        """
        Intersect(NCollection_Map_Handle_TNaming_NamedShape_TNaming_NamedShapeHasher self, NCollection_Map_Handle_TNaming_NamedShape_TNaming_NamedShapeHasher theOther) -> Standard_Boolean

        Apply to this Map the intersection operation (aka multiplication, common, boolean AND) with another (given) Map.
        The result contains only the values that are contained in both this and the given maps.
        This algorithm is similar to method Intersection().
        Returns True if contents of this map is changed.

        :type theOther: OCC.wrapper.NCollection.NCollection_Map
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TNaming.NCollection_Map_Handle_TNaming_NamedShape_TNaming_NamedShapeHasher_Intersect(self, *args)


    def Subtraction(self, *args):
        """
        Subtraction(NCollection_Map_Handle_TNaming_NamedShape_TNaming_NamedShapeHasher self, NCollection_Map_Handle_TNaming_NamedShape_TNaming_NamedShapeHasher theLeft, NCollection_Map_Handle_TNaming_NamedShape_TNaming_NamedShapeHasher theRight)

        Sets this Map to be the result of subtraction (aka set-theoretic difference, relative complement,
        exclude, cut, boolean NOT) operation between two given Maps.
        The new Map contains only the values that are contained in the first map operands and not contained in the second one.
        All previous content of this Map is cleared.

        :type theLeft: OCC.wrapper.NCollection.NCollection_Map
        :type theRight: OCC.wrapper.NCollection.NCollection_Map

        """
        return _TNaming.NCollection_Map_Handle_TNaming_NamedShape_TNaming_NamedShapeHasher_Subtraction(self, *args)


    def Subtract(self, *args):
        """
        Subtract(NCollection_Map_Handle_TNaming_NamedShape_TNaming_NamedShapeHasher self, NCollection_Map_Handle_TNaming_NamedShape_TNaming_NamedShapeHasher theOther) -> Standard_Boolean

        Apply to this Map the subtraction (aka set-theoretic difference, relative complement,
        exclude, cut, boolean NOT) operation with another (given) Map.
        The result contains only the values that were previously contained in this map and not contained in this map.
        This algorithm is similar to method Subtract() with two operands.
        Returns True if contents of this map is changed.

        :type theOther: OCC.wrapper.NCollection.NCollection_Map
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TNaming.NCollection_Map_Handle_TNaming_NamedShape_TNaming_NamedShapeHasher_Subtract(self, *args)


    def Difference(self, *args):
        """
        Difference(NCollection_Map_Handle_TNaming_NamedShape_TNaming_NamedShapeHasher self, NCollection_Map_Handle_TNaming_NamedShape_TNaming_NamedShapeHasher theLeft, NCollection_Map_Handle_TNaming_NamedShape_TNaming_NamedShapeHasher theRight)

        Sets this Map to be the result of symmetric difference (aka exclusive disjunction, boolean XOR) operation between two given Maps.
        The new Map contains the values that are contained only in the first or the second operand maps but not in both.
        All previous content of this Map is cleared. This map (result of the boolean operation) can also be used as one of operands.

        :type theLeft: OCC.wrapper.NCollection.NCollection_Map
        :type theRight: OCC.wrapper.NCollection.NCollection_Map

        """
        return _TNaming.NCollection_Map_Handle_TNaming_NamedShape_TNaming_NamedShapeHasher_Difference(self, *args)


    def Differ(self, *args):
        """
        Differ(NCollection_Map_Handle_TNaming_NamedShape_TNaming_NamedShapeHasher self, NCollection_Map_Handle_TNaming_NamedShape_TNaming_NamedShapeHasher theOther) -> Standard_Boolean

        Apply to this Map the symmetric difference (aka exclusive disjunction, boolean XOR) operation with another (given) Map.
        The result contains the values that are contained only in this or the operand map, but not in both.
        This algorithm is similar to method Difference().
        Returns True if contents of this map is changed.

        :type theOther: OCC.wrapper.NCollection.NCollection_Map
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TNaming.NCollection_Map_Handle_TNaming_NamedShape_TNaming_NamedShapeHasher_Differ(self, *args)


    def __iter__(self):
        return _TNaming.NCollection_Map_Handle_TNaming_NamedShape_TNaming_NamedShapeHasher___iter__(self)
    __swig_destroy__ = _TNaming.delete_NCollection_Map_Handle_TNaming_NamedShape_TNaming_NamedShapeHasher
NCollection_Map_Handle_TNaming_NamedShape_TNaming_NamedShapeHasher_swigregister = _TNaming.NCollection_Map_Handle_TNaming_NamedShape_TNaming_NamedShapeHasher_swigregister
NCollection_Map_Handle_TNaming_NamedShape_TNaming_NamedShapeHasher_swigregister(NCollection_Map_Handle_TNaming_NamedShape_TNaming_NamedShapeHasher)

class NCollection_Map_Handle_TNaming_NamedShape_TNaming_NamedShapeHasher_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _TNaming.new_NCollection_Map_Handle_TNaming_NamedShape_TNaming_NamedShapeHasher_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _TNaming.delete_NCollection_Map_Handle_TNaming_NamedShape_TNaming_NamedShapeHasher_IteratorHelper

    def __next__(self):
        return _TNaming.NCollection_Map_Handle_TNaming_NamedShape_TNaming_NamedShapeHasher_IteratorHelper___next__(self)
NCollection_Map_Handle_TNaming_NamedShape_TNaming_NamedShapeHasher_IteratorHelper_swigregister = _TNaming.NCollection_Map_Handle_TNaming_NamedShape_TNaming_NamedShapeHasher_IteratorHelper_swigregister
NCollection_Map_Handle_TNaming_NamedShape_TNaming_NamedShapeHasher_IteratorHelper_swigregister(NCollection_Map_Handle_TNaming_NamedShape_TNaming_NamedShapeHasher_IteratorHelper)


try:
	TNaming_MapOfNamedShape = NCollection_Map_Handle_TNaming_NamedShape_TNaming_NamedShapeHasher
except NameError:
	pass # does not exist, probably ignored

class TNaming_TranslateTool(Standard.Standard_Transient):
    """
    tool to copy underlying TShape of a Shape.
    The TranslateTool class is provided to support the
    translation of topological data structures  Transient
    to  Transient.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_TNaming_TranslateTool
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_TNaming_TranslateTool(self) 
            return h


    def Add(self, *args):
        """
        Add(TNaming_TranslateTool self, TopoDS_Shape S1, TopoDS_Shape S2)

        :type S1: OCC.wrapper.TopoDS.TopoDS_Shape
        :type S2: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _TNaming.TNaming_TranslateTool_Add(self, *args)


    def MakeVertex(self, *args):
        """
        MakeVertex(TNaming_TranslateTool self, TopoDS_Shape S)

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _TNaming.TNaming_TranslateTool_MakeVertex(self, *args)


    def MakeEdge(self, *args):
        """
        MakeEdge(TNaming_TranslateTool self, TopoDS_Shape S)

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _TNaming.TNaming_TranslateTool_MakeEdge(self, *args)


    def MakeWire(self, *args):
        """
        MakeWire(TNaming_TranslateTool self, TopoDS_Shape S)

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _TNaming.TNaming_TranslateTool_MakeWire(self, *args)


    def MakeFace(self, *args):
        """
        MakeFace(TNaming_TranslateTool self, TopoDS_Shape S)

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _TNaming.TNaming_TranslateTool_MakeFace(self, *args)


    def MakeShell(self, *args):
        """
        MakeShell(TNaming_TranslateTool self, TopoDS_Shape S)

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _TNaming.TNaming_TranslateTool_MakeShell(self, *args)


    def MakeSolid(self, *args):
        """
        MakeSolid(TNaming_TranslateTool self, TopoDS_Shape S)

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _TNaming.TNaming_TranslateTool_MakeSolid(self, *args)


    def MakeCompSolid(self, *args):
        """
        MakeCompSolid(TNaming_TranslateTool self, TopoDS_Shape S)

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _TNaming.TNaming_TranslateTool_MakeCompSolid(self, *args)


    def MakeCompound(self, *args):
        """
        MakeCompound(TNaming_TranslateTool self, TopoDS_Shape S)

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _TNaming.TNaming_TranslateTool_MakeCompound(self, *args)


    def UpdateVertex(self, *args):
        """
        UpdateVertex(TNaming_TranslateTool self, TopoDS_Shape S1, TopoDS_Shape S2, NCollection_IndexedDataMap_Handle_Standard_Transient_Handle_Standard_Transient_TColStd_MapTransientHasher M)

        :type S1: OCC.wrapper.TopoDS.TopoDS_Shape
        :type S2: OCC.wrapper.TopoDS.TopoDS_Shape
        :type M: OCC.wrapper.TColStd.TColStd_IndexedDataMapOfTransientTransient

        """
        return _TNaming.TNaming_TranslateTool_UpdateVertex(self, *args)


    def UpdateEdge(self, *args):
        """
        UpdateEdge(TNaming_TranslateTool self, TopoDS_Shape S1, TopoDS_Shape S2, NCollection_IndexedDataMap_Handle_Standard_Transient_Handle_Standard_Transient_TColStd_MapTransientHasher M)

        :type S1: OCC.wrapper.TopoDS.TopoDS_Shape
        :type S2: OCC.wrapper.TopoDS.TopoDS_Shape
        :type M: OCC.wrapper.TColStd.TColStd_IndexedDataMapOfTransientTransient

        """
        return _TNaming.TNaming_TranslateTool_UpdateEdge(self, *args)


    def UpdateFace(self, *args):
        """
        UpdateFace(TNaming_TranslateTool self, TopoDS_Shape S1, TopoDS_Shape S2, NCollection_IndexedDataMap_Handle_Standard_Transient_Handle_Standard_Transient_TColStd_MapTransientHasher M)

        :type S1: OCC.wrapper.TopoDS.TopoDS_Shape
        :type S2: OCC.wrapper.TopoDS.TopoDS_Shape
        :type M: OCC.wrapper.TColStd.TColStd_IndexedDataMapOfTransientTransient

        """
        return _TNaming.TNaming_TranslateTool_UpdateFace(self, *args)


    def UpdateShape(self, *args):
        """
        UpdateShape(TNaming_TranslateTool self, TopoDS_Shape S1, TopoDS_Shape S2)

        :type S1: OCC.wrapper.TopoDS.TopoDS_Shape
        :type S2: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _TNaming.TNaming_TranslateTool_UpdateShape(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _TNaming.TNaming_TranslateTool_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _TNaming.TNaming_TranslateTool_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TNaming.TNaming_TranslateTool_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __init__(self):
        """
        tool to copy underlying TShape of a Shape.
        The TranslateTool class is provided to support the
        translation of topological data structures  Transient
        to  Transient.
        """
        this = _TNaming.new_TNaming_TranslateTool()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle



    __swig_destroy__ = _TNaming.delete_TNaming_TranslateTool
TNaming_TranslateTool_swigregister = _TNaming.TNaming_TranslateTool_swigregister
TNaming_TranslateTool_swigregister(TNaming_TranslateTool)

def TNaming_TranslateTool_get_type_name(*args):
    """
    TNaming_TranslateTool_get_type_name() -> char const *

    :rtype: const char *

    """
    return _TNaming.TNaming_TranslateTool_get_type_name(*args)

def TNaming_TranslateTool_get_type_descriptor(*args):
    """
    TNaming_TranslateTool_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _TNaming.TNaming_TranslateTool_get_type_descriptor(*args)

class TNaming_Tool(object):
    """
    A tool to get information on the topology of a
    named shape attribute.
    This information is typically a TopoDS_Shape object.
    Using this tool, relations between named shapes
    are also accessible.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def CurrentShape(*args):
        """
        CurrentShape(Handle_TNaming_NamedShape NS) -> TopoDS_Shape
        CurrentShape(Handle_TNaming_NamedShape NS, NCollection_Map_TDF_Label_TDF_LabelMapHasher Updated) -> TopoDS_Shape

        Returns the shape CurrentShape contained in
        the named shape attribute NS, and present in
        the updated attribute map Updated.
        CurrentShape is the current state of the entities
        if they have been modified in other attributes of the same data structure.
        Each call to this function creates a new compound.
        Warning
        Only the contents of Updated are searched.R

        :type NS: OCC.wrapper.TNaming.Handle_TNaming_NamedShape
        :type Updated: OCC.wrapper.TDF.TDF_LabelMap
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _TNaming.TNaming_Tool_CurrentShape(*args)

    CurrentShape = staticmethod(CurrentShape)

    def CurrentNamedShape(*args):
        """
        CurrentNamedShape(Handle_TNaming_NamedShape NS, NCollection_Map_TDF_Label_TDF_LabelMapHasher Updated) -> Handle_TNaming_NamedShape
        CurrentNamedShape(Handle_TNaming_NamedShape NS) -> Handle_TNaming_NamedShape

        Returns NamedShape the last Modification of <NS>.

        :type NS: OCC.wrapper.TNaming.Handle_TNaming_NamedShape
        :rtype: OCC.wrapper.TNaming.Handle_TNaming_NamedShape

        """
        return _TNaming.TNaming_Tool_CurrentNamedShape(*args)

    CurrentNamedShape = staticmethod(CurrentNamedShape)

    def NamedShape(*args):
        """
        NamedShape(TopoDS_Shape aShape, TDF_Label anAcces) -> Handle_TNaming_NamedShape

        Returns the named shape attribute defined by
        the shape aShape and the label anAccess.
        This attribute is returned as a new shape.
        You call this function, if you need to create a
        topological attribute for existing data.
        Example
        class MyPkg_MyClass
        {
        public: Standard_Boolean
        SameEdge(const
        Handle(OCafTest_Line)& , const
        Handle(CafTest_Line)& );
        };

        Standard_Boolean
        MyPkg_MyClass::SameEdge
        (const Handle(OCafTest_Line)& L1
        const Handle(OCafTest_Line)& L2)
        { Handle(TNaming_NamedShape)
        NS1 = L1->NamedShape();
        Handle(TNaming_NamedShape)
        NS2 = L2->NamedShape();

        return
        BRepTools::Compare(NS1->Get(),NS2->Get());
        }
        In the example above, the function SameEdge is
        created to compare the edges having two lines
        for geometric supports. If these edges are found
        by BRepTools::Compare to be within the same
        tolerance, they are considered to be the same.
        Warning
        To avoid sharing of names, a SELECTED
        attribute will not be returned. Sharing of names
        makes it harder to manage the data structure.
        When the user of the name is removed, for
        example, it is difficult to know whether the name
        should be destroyed.

        :type aShape: OCC.wrapper.TopoDS.TopoDS_Shape
        :type anAcces: OCC.wrapper.TDF.TDF_Label
        :rtype: OCC.wrapper.TNaming.Handle_TNaming_NamedShape

        """
        return _TNaming.TNaming_Tool_NamedShape(*args)

    NamedShape = staticmethod(NamedShape)

    def GetShape(*args):
        """
        GetShape(Handle_TNaming_NamedShape NS) -> TopoDS_Shape

        Returns the entities stored in the named shape attribute NS.
        If there is only one old-new pair, the new shape
        is returned. Otherwise, a Compound is returned.
        This compound is made out of all the new shapes found.
        Each call to this function creates a new compound.

        :type NS: OCC.wrapper.TNaming.Handle_TNaming_NamedShape
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _TNaming.TNaming_Tool_GetShape(*args)

    GetShape = staticmethod(GetShape)

    def OriginalShape(*args):
        """
        OriginalShape(Handle_TNaming_NamedShape NS) -> TopoDS_Shape

        Returns the shape contained as OldShape in <NS>

        :type NS: OCC.wrapper.TNaming.Handle_TNaming_NamedShape
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _TNaming.TNaming_Tool_OriginalShape(*args)

    OriginalShape = staticmethod(OriginalShape)

    def GeneratedShape(*args):
        """
        GeneratedShape(TopoDS_Shape S, Handle_TNaming_NamedShape Generation) -> TopoDS_Shape

        Returns the shape generated from S or by a
        modification of S and contained in the named
        shape Generation.

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :type Generation: OCC.wrapper.TNaming.Handle_TNaming_NamedShape
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _TNaming.TNaming_Tool_GeneratedShape(*args)

    GeneratedShape = staticmethod(GeneratedShape)

    def Collect(*args):
        """
        Collect(Handle_TNaming_NamedShape NS, NCollection_Map_Handle_TNaming_NamedShape_TNaming_NamedShapeHasher Labels, Standard_Boolean const OnlyModif)

        :type NS: OCC.wrapper.TNaming.Handle_TNaming_NamedShape
        :type Labels: OCC.wrapper.TNaming.TNaming_MapOfNamedShape
        :type OnlyModif: bool

        """
        return _TNaming.TNaming_Tool_Collect(*args)

    Collect = staticmethod(Collect)

    def HasLabel(*args):
        """
        HasLabel(TDF_Label access, TopoDS_Shape aShape) -> Standard_Boolean

        Returns True if <aShape> appears under a label.(DP)

        :type access: OCC.wrapper.TDF.TDF_Label
        :type aShape: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TNaming.TNaming_Tool_HasLabel(*args)

    HasLabel = staticmethod(HasLabel)

    def Label(*args):
        """
        Label(TDF_Label access, TopoDS_Shape aShape) -> TDF_Label

        Returns  the label  of   the first apparition  of
        <aShape>.  Transdef  is a value of the transaction
        of the first apparition of <aShape>.

        :type access: OCC.wrapper.TDF.TDF_Label
        :type aShape: OCC.wrapper.TopoDS.TopoDS_Shape
        :type TransDef: int
        :rtype: OCC.wrapper.TDF.TDF_Label

        """
        return _TNaming.TNaming_Tool_Label(*args)

    Label = staticmethod(Label)

    def InitialShape(*args):
        """
        InitialShape(TopoDS_Shape aShape, TDF_Label anAcces, NCollection_List_TDF_Label Labels) -> TopoDS_Shape

        Returns the shape created from the shape
        aShape contained in the attribute anAcces.

        :type aShape: OCC.wrapper.TopoDS.TopoDS_Shape
        :type anAcces: OCC.wrapper.TDF.TDF_Label
        :type Labels: OCC.wrapper.TDF.TDF_LabelList
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _TNaming.TNaming_Tool_InitialShape(*args)

    InitialShape = staticmethod(InitialShape)

    def ValidUntil(*args):
        """
        ValidUntil(TDF_Label access, TopoDS_Shape S) -> Standard_Integer

        Returns the last transaction where the creation of S
        is valid.

        :type access: OCC.wrapper.TDF.TDF_Label
        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TNaming.TNaming_Tool_ValidUntil(*args)

    ValidUntil = staticmethod(ValidUntil)

    def FindShape(*args):
        """
        FindShape(NCollection_Map_TDF_Label_TDF_LabelMapHasher Valid, NCollection_Map_TDF_Label_TDF_LabelMapHasher Forbiden, Handle_TNaming_NamedShape Arg, TopoDS_Shape S)

        Returns the current shape (a Wire or a Shell) built (in the data framework)
        from the the shapes of the argument named shape.
        It is used for IDENTITY name type computation.

        :type Valid: OCC.wrapper.TDF.TDF_LabelMap
        :type Forbiden: OCC.wrapper.TDF.TDF_LabelMap
        :type Arg: OCC.wrapper.TNaming.Handle_TNaming_NamedShape
        :type S: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _TNaming.TNaming_Tool_FindShape(*args)

    FindShape = staticmethod(FindShape)

    def __init__(self):
        """
        A tool to get information on the topology of a
        named shape attribute.
        This information is typically a TopoDS_Shape object.
        Using this tool, relations between named shapes
        are also accessible.
        """
        this = _TNaming.new_TNaming_Tool()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _TNaming.delete_TNaming_Tool
TNaming_Tool_swigregister = _TNaming.TNaming_Tool_swigregister
TNaming_Tool_swigregister(TNaming_Tool)

def TNaming_Tool_CurrentShape(*args):
    """
    CurrentShape(Handle_TNaming_NamedShape NS) -> TopoDS_Shape
    TNaming_Tool_CurrentShape(Handle_TNaming_NamedShape NS, NCollection_Map_TDF_Label_TDF_LabelMapHasher Updated) -> TopoDS_Shape

    Returns the shape CurrentShape contained in
    the named shape attribute NS, and present in
    the updated attribute map Updated.
    CurrentShape is the current state of the entities
    if they have been modified in other attributes of the same data structure.
    Each call to this function creates a new compound.
    Warning
    Only the contents of Updated are searched.R

    :type NS: OCC.wrapper.TNaming.Handle_TNaming_NamedShape
    :type Updated: OCC.wrapper.TDF.TDF_LabelMap
    :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

    """
    return _TNaming.TNaming_Tool_CurrentShape(*args)

def TNaming_Tool_CurrentNamedShape(*args):
    """
    CurrentNamedShape(Handle_TNaming_NamedShape NS, NCollection_Map_TDF_Label_TDF_LabelMapHasher Updated) -> Handle_TNaming_NamedShape
    TNaming_Tool_CurrentNamedShape(Handle_TNaming_NamedShape NS) -> Handle_TNaming_NamedShape

    Returns NamedShape the last Modification of <NS>.

    :type NS: OCC.wrapper.TNaming.Handle_TNaming_NamedShape
    :rtype: OCC.wrapper.TNaming.Handle_TNaming_NamedShape

    """
    return _TNaming.TNaming_Tool_CurrentNamedShape(*args)

def TNaming_Tool_NamedShape(*args):
    """
    TNaming_Tool_NamedShape(TopoDS_Shape aShape, TDF_Label anAcces) -> Handle_TNaming_NamedShape

    Returns the named shape attribute defined by
    the shape aShape and the label anAccess.
    This attribute is returned as a new shape.
    You call this function, if you need to create a
    topological attribute for existing data.
    Example
    class MyPkg_MyClass
    {
    public: Standard_Boolean
    SameEdge(const
    Handle(OCafTest_Line)& , const
    Handle(CafTest_Line)& );
    };

    Standard_Boolean
    MyPkg_MyClass::SameEdge
    (const Handle(OCafTest_Line)& L1
    const Handle(OCafTest_Line)& L2)
    { Handle(TNaming_NamedShape)
    NS1 = L1->NamedShape();
    Handle(TNaming_NamedShape)
    NS2 = L2->NamedShape();

    return
    BRepTools::Compare(NS1->Get(),NS2->Get());
    }
    In the example above, the function SameEdge is
    created to compare the edges having two lines
    for geometric supports. If these edges are found
    by BRepTools::Compare to be within the same
    tolerance, they are considered to be the same.
    Warning
    To avoid sharing of names, a SELECTED
    attribute will not be returned. Sharing of names
    makes it harder to manage the data structure.
    When the user of the name is removed, for
    example, it is difficult to know whether the name
    should be destroyed.

    :type aShape: OCC.wrapper.TopoDS.TopoDS_Shape
    :type anAcces: OCC.wrapper.TDF.TDF_Label
    :rtype: OCC.wrapper.TNaming.Handle_TNaming_NamedShape

    """
    return _TNaming.TNaming_Tool_NamedShape(*args)

def TNaming_Tool_GetShape(*args):
    """
    TNaming_Tool_GetShape(Handle_TNaming_NamedShape NS) -> TopoDS_Shape

    Returns the entities stored in the named shape attribute NS.
    If there is only one old-new pair, the new shape
    is returned. Otherwise, a Compound is returned.
    This compound is made out of all the new shapes found.
    Each call to this function creates a new compound.

    :type NS: OCC.wrapper.TNaming.Handle_TNaming_NamedShape
    :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

    """
    return _TNaming.TNaming_Tool_GetShape(*args)

def TNaming_Tool_OriginalShape(*args):
    """
    TNaming_Tool_OriginalShape(Handle_TNaming_NamedShape NS) -> TopoDS_Shape

    Returns the shape contained as OldShape in <NS>

    :type NS: OCC.wrapper.TNaming.Handle_TNaming_NamedShape
    :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

    """
    return _TNaming.TNaming_Tool_OriginalShape(*args)

def TNaming_Tool_GeneratedShape(*args):
    """
    TNaming_Tool_GeneratedShape(TopoDS_Shape S, Handle_TNaming_NamedShape Generation) -> TopoDS_Shape

    Returns the shape generated from S or by a
    modification of S and contained in the named
    shape Generation.

    :type S: OCC.wrapper.TopoDS.TopoDS_Shape
    :type Generation: OCC.wrapper.TNaming.Handle_TNaming_NamedShape
    :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

    """
    return _TNaming.TNaming_Tool_GeneratedShape(*args)

def TNaming_Tool_Collect(*args):
    """
    TNaming_Tool_Collect(Handle_TNaming_NamedShape NS, NCollection_Map_Handle_TNaming_NamedShape_TNaming_NamedShapeHasher Labels, Standard_Boolean const OnlyModif)

    :type NS: OCC.wrapper.TNaming.Handle_TNaming_NamedShape
    :type Labels: OCC.wrapper.TNaming.TNaming_MapOfNamedShape
    :type OnlyModif: bool

    """
    return _TNaming.TNaming_Tool_Collect(*args)

def TNaming_Tool_HasLabel(*args):
    """
    TNaming_Tool_HasLabel(TDF_Label access, TopoDS_Shape aShape) -> Standard_Boolean

    Returns True if <aShape> appears under a label.(DP)

    :type access: OCC.wrapper.TDF.TDF_Label
    :type aShape: OCC.wrapper.TopoDS.TopoDS_Shape
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _TNaming.TNaming_Tool_HasLabel(*args)

def TNaming_Tool_Label(*args):
    """
    TNaming_Tool_Label(TDF_Label access, TopoDS_Shape aShape) -> TDF_Label

    Returns  the label  of   the first apparition  of
    <aShape>.  Transdef  is a value of the transaction
    of the first apparition of <aShape>.

    :type access: OCC.wrapper.TDF.TDF_Label
    :type aShape: OCC.wrapper.TopoDS.TopoDS_Shape
    :type TransDef: int
    :rtype: OCC.wrapper.TDF.TDF_Label

    """
    return _TNaming.TNaming_Tool_Label(*args)

def TNaming_Tool_InitialShape(*args):
    """
    TNaming_Tool_InitialShape(TopoDS_Shape aShape, TDF_Label anAcces, NCollection_List_TDF_Label Labels) -> TopoDS_Shape

    Returns the shape created from the shape
    aShape contained in the attribute anAcces.

    :type aShape: OCC.wrapper.TopoDS.TopoDS_Shape
    :type anAcces: OCC.wrapper.TDF.TDF_Label
    :type Labels: OCC.wrapper.TDF.TDF_LabelList
    :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

    """
    return _TNaming.TNaming_Tool_InitialShape(*args)

def TNaming_Tool_ValidUntil(*args):
    """
    TNaming_Tool_ValidUntil(TDF_Label access, TopoDS_Shape S) -> Standard_Integer

    Returns the last transaction where the creation of S
    is valid.

    :type access: OCC.wrapper.TDF.TDF_Label
    :type S: OCC.wrapper.TopoDS.TopoDS_Shape
    :rtype: OCC.wrapper.Standard.Standard_Integer

    """
    return _TNaming.TNaming_Tool_ValidUntil(*args)

def TNaming_Tool_FindShape(*args):
    """
    TNaming_Tool_FindShape(NCollection_Map_TDF_Label_TDF_LabelMapHasher Valid, NCollection_Map_TDF_Label_TDF_LabelMapHasher Forbiden, Handle_TNaming_NamedShape Arg, TopoDS_Shape S)

    Returns the current shape (a Wire or a Shell) built (in the data framework)
    from the the shapes of the argument named shape.
    It is used for IDENTITY name type computation.

    :type Valid: OCC.wrapper.TDF.TDF_LabelMap
    :type Forbiden: OCC.wrapper.TDF.TDF_LabelMap
    :type Arg: OCC.wrapper.TNaming.Handle_TNaming_NamedShape
    :type S: OCC.wrapper.TopoDS.TopoDS_Shape

    """
    return _TNaming.TNaming_Tool_FindShape(*args)

class TNaming_IteratorOnShapesSet(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(TNaming_IteratorOnShapesSet self) -> TNaming_IteratorOnShapesSet
        __init__(TNaming_IteratorOnShapesSet self, TNaming_ShapesSet S) -> TNaming_IteratorOnShapesSet

        :type S: OCC.wrapper.TNaming.TNaming_ShapesSet

        """
        this = _TNaming.new_TNaming_IteratorOnShapesSet(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(TNaming_IteratorOnShapesSet self, TNaming_ShapesSet S)

        Initialize the iteration

        :type S: OCC.wrapper.TNaming.TNaming_ShapesSet

        """
        return _TNaming.TNaming_IteratorOnShapesSet_Init(self, *args)


    def More(self, *args):
        """
        More(TNaming_IteratorOnShapesSet self) -> Standard_Boolean

        Returns True if there is a current Item in
        the iteration.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TNaming.TNaming_IteratorOnShapesSet_More(self, *args)


    def Next(self, *args):
        """
        Next(TNaming_IteratorOnShapesSet self)

        Move to the next Item


        """
        return _TNaming.TNaming_IteratorOnShapesSet_Next(self, *args)


    def Value(self, *args):
        """
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _TNaming.TNaming_IteratorOnShapesSet_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _TNaming.delete_TNaming_IteratorOnShapesSet
TNaming_IteratorOnShapesSet_swigregister = _TNaming.TNaming_IteratorOnShapesSet_swigregister
TNaming_IteratorOnShapesSet_swigregister(TNaming_IteratorOnShapesSet)

class TNaming_Selector(object):
    """
    This class provides a single API for selection of shapes.
    This involves both identification and selection of
    shapes in the data framework.
    If the selected shape is modified, this selector will
    solve its identifications.
    This class is the user interface for topological
    naming resources.
    * The   <IsIdentified> method returns  (if exists)
    the NamedShape which  contains a given shape. The
    definition of  an  identified shape is :   a Shape
    handled by a NamedShape  (this shape  is the only
    one stored) , which  has the TNaming_PRImITIVE evolution

    *  The   <Select> method  returns   ALWAYS a  new
    NamedShape at the given  label, which contains the
    argument  selected  shape.    When  calling  this
    method, the sub-hierarchy of <label> is first cleared,
    then a TNaming_NamedShape   is ALWAYS created  at
    this <label>, with the TNaming_SELECTED evolution.
    The <Naming attribute> is associated to the selected
    shape which store the arguments of the selection .
    If the given selected shape was already identified
    (method IsIdentified)   , this   Naming attribute
    contains  the reference (Identity  code)  to the
    argument shape.

    * The <Solve> method  update the current value of
    the NamedShape, according to the <Naming> attribute.
    A boolean status  is    returned to say  if  the
    algorithm succeed   or not.  To read   the current
    value    of the selected    Named  Shape  use the
    TNaming_Tool::GetShape    method,    as  for  any
    NamedShape attribute.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def IsIdentified(*args):
        """
        IsIdentified(TDF_Label access, TopoDS_Shape selection, Handle_TNaming_NamedShape NS, Standard_Boolean const Geometry) -> Standard_Boolean

        To know if a shape is already identified (not selected)
        =======================================================

        The label access defines the point of access to the data framework.
        selection is the shape for which we want to know
        whether it is identified or not.
        If true, NS is returned as the identity of selection.
        If Geometry is true, NS will be the named shape
        containing the first appearance of selection and
        not any other shape. In other words, selection
        must be the only shape stored in NS.

        :type access: OCC.wrapper.TDF.TDF_Label
        :type selection: OCC.wrapper.TopoDS.TopoDS_Shape
        :type NS: OCC.wrapper.TNaming.Handle_TNaming_NamedShape
        :type Geometry: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TNaming.TNaming_Selector_IsIdentified(*args)

    IsIdentified = staticmethod(IsIdentified)

    def __init__(self, *args):
        """
        __init__(TNaming_Selector self, TDF_Label aLabel) -> TNaming_Selector

        Create a selector on this label
        to select a shape.
        ==================

        :type aLabel: OCC.wrapper.TDF.TDF_Label

        """
        this = _TNaming.new_TNaming_Selector(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Select(self, *args):
        """
        Select(TNaming_Selector self, TopoDS_Shape Selection, TopoDS_Shape Context, Standard_Boolean const Geometry, Standard_Boolean const KeepOrientatation) -> Standard_Boolean
        Select(TNaming_Selector self, TopoDS_Shape Selection, Standard_Boolean const Geometry, Standard_Boolean const KeepOrientatation) -> Standard_Boolean

        Creates a topological naming on the label
        aLabel given as an argument at construction time.
        If successful, the shape Selection is now
        identified in the named shape returned in NamedShape.
        If Geometry is true, NamedShape contains the
        first appearance of Selection.

        :type Selection: OCC.wrapper.TopoDS.TopoDS_Shape
        :type Geometry: bool
        :type KeepOrientatation: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TNaming.TNaming_Selector_Select(self, *args)


    def Solve(self, *args):
        """
        Solve(TNaming_Selector self, NCollection_Map_TDF_Label_TDF_LabelMapHasher Valid) -> Standard_Boolean

        Updates the topological naming on the label
        aLabel given as an argument at construction time.
        The underlying shape returned in the method
        NamedShape is updated.
        To read this shape, use the method TNaming_Tool::GetShape

        :type Valid: OCC.wrapper.TDF.TDF_LabelMap
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TNaming.TNaming_Selector_Solve(self, *args)


    def Arguments(self, *args):
        """
        Arguments(TNaming_Selector self, NCollection_Map_Handle_TDF_Attribute_TColStd_MapTransientHasher args)

        Returns the attribute list args.
        This list contains the named shape on which the topological naming was built.

        :type args: OCC.wrapper.TDF.TDF_AttributeMap

        """
        return _TNaming.TNaming_Selector_Arguments(self, *args)


    def NamedShape(self, *args):
        """
        NamedShape(TNaming_Selector self) -> Handle_TNaming_NamedShape

        Returns the NamedShape build or under construction,
        which contains the topological naming..

        :rtype: OCC.wrapper.TNaming.Handle_TNaming_NamedShape

        """
        return _TNaming.TNaming_Selector_NamedShape(self, *args)

    __swig_destroy__ = _TNaming.delete_TNaming_Selector
TNaming_Selector_swigregister = _TNaming.TNaming_Selector_swigregister
TNaming_Selector_swigregister(TNaming_Selector)

def TNaming_Selector_IsIdentified(*args):
    """
    TNaming_Selector_IsIdentified(TDF_Label access, TopoDS_Shape selection, Handle_TNaming_NamedShape NS, Standard_Boolean const Geometry) -> Standard_Boolean

    To know if a shape is already identified (not selected)
    =======================================================

    The label access defines the point of access to the data framework.
    selection is the shape for which we want to know
    whether it is identified or not.
    If true, NS is returned as the identity of selection.
    If Geometry is true, NS will be the named shape
    containing the first appearance of selection and
    not any other shape. In other words, selection
    must be the only shape stored in NS.

    :type access: OCC.wrapper.TDF.TDF_Label
    :type selection: OCC.wrapper.TopoDS.TopoDS_Shape
    :type NS: OCC.wrapper.TNaming.Handle_TNaming_NamedShape
    :type Geometry: bool
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _TNaming.TNaming_Selector_IsIdentified(*args)

class TNaming_Name(object):
    """store the arguments of Naming."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(TNaming_Name self) -> TNaming_Name

        store the arguments of Naming.
        """
        this = _TNaming.new_TNaming_Name(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Append(self, *args):
        """
        Append(TNaming_Name self, Handle_TNaming_NamedShape arg)

        :type arg: OCC.wrapper.TNaming.Handle_TNaming_NamedShape

        """
        return _TNaming.TNaming_Name_Append(self, *args)


    def Type(self, *args):
        """
        Type(TNaming_Name self, TNaming_NameType const aType)
        Type(TNaming_Name self) -> TNaming_NameType

        :rtype: OCC.wrapper.TNaming.TNaming_NameType

        """
        return _TNaming.TNaming_Name_Type(self, *args)


    def ShapeType(self, *args):
        """
        ShapeType(TNaming_Name self, TopAbs_ShapeEnum const aType)
        ShapeType(TNaming_Name self) -> TopAbs_ShapeEnum

        :rtype: OCC.wrapper.TopAbs.TopAbs_ShapeEnum

        """
        return _TNaming.TNaming_Name_ShapeType(self, *args)


    def Shape(self, *args):
        """
        Shape(TNaming_Name self, TopoDS_Shape theShape)
        Shape(TNaming_Name self) -> TopoDS_Shape

        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _TNaming.TNaming_Name_Shape(self, *args)


    def Arguments(self, *args):
        """
        :rtype: OCC.wrapper.TNaming.TNaming_ListOfNamedShape

        """
        res = _TNaming.TNaming_Name_Arguments(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def StopNamedShape(self, *args):
        """
        StopNamedShape(TNaming_Name self, Handle_TNaming_NamedShape arg)
        StopNamedShape(TNaming_Name self) -> Handle_TNaming_NamedShape

        :rtype: OCC.wrapper.TNaming.Handle_TNaming_NamedShape

        """
        return _TNaming.TNaming_Name_StopNamedShape(self, *args)


    def Index(self, *args):
        """
        Index(TNaming_Name self, Standard_Integer const I)
        Index(TNaming_Name self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TNaming.TNaming_Name_Index(self, *args)


    def ContextLabel(self, *args):
        """
        :rtype: OCC.wrapper.TDF.TDF_Label

        """
        res = _TNaming.TNaming_Name_ContextLabel(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Orientation(self, *args):
        """
        Orientation(TNaming_Name self, TopAbs_Orientation const theOrientation)
        Orientation(TNaming_Name self) -> TopAbs_Orientation

        :rtype: OCC.wrapper.TopAbs.TopAbs_Orientation

        """
        return _TNaming.TNaming_Name_Orientation(self, *args)


    def Solve(self, *args):
        """
        Solve(TNaming_Name self, TDF_Label aLab, NCollection_Map_TDF_Label_TDF_LabelMapHasher Valid) -> Standard_Boolean

        :type aLab: OCC.wrapper.TDF.TDF_Label
        :type Valid: OCC.wrapper.TDF.TDF_LabelMap
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TNaming.TNaming_Name_Solve(self, *args)


    def Paste(self, *args):
        """
        Paste(TNaming_Name self, TNaming_Name into, Handle_TDF_RelocationTable RT)

        :type into: OCC.wrapper.TNaming.TNaming_Name
        :type RT: OCC.wrapper.TDF.Handle_TDF_RelocationTable

        """
        return _TNaming.TNaming_Name_Paste(self, *args)

    __swig_destroy__ = _TNaming.delete_TNaming_Name
TNaming_Name_swigregister = _TNaming.TNaming_Name_swigregister
TNaming_Name_swigregister(TNaming_Name)

class TNaming_Translator(object):
    """only  for  Shape  Copy  test - to move in DNaming"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(TNaming_Translator self) -> TNaming_Translator

        only  for  Shape  Copy  test - to move in DNaming
        """
        this = _TNaming.new_TNaming_Translator(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Add(self, *args):
        """
        Add(TNaming_Translator self, TopoDS_Shape aShape)

        :type aShape: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _TNaming.TNaming_Translator_Add(self, *args)


    def Perform(self, *args):
        """Perform(TNaming_Translator self)"""
        return _TNaming.TNaming_Translator_Perform(self, *args)


    def IsDone(self, *args):
        """
        IsDone(TNaming_Translator self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TNaming.TNaming_Translator_IsDone(self, *args)


    def Copied(self, *args):
        """
        returns  DataMap  of  results;  (shape <-> copied  shape)

        :rtype: OCC.wrapper.TopTools.TopTools_DataMapOfShapeShape

        """
        res = _TNaming.TNaming_Translator_Copied(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DumpMap(self, *args):
        """
        DumpMap(TNaming_Translator self, Standard_Boolean const isWrite)

        :type isWrite: bool

        """
        return _TNaming.TNaming_Translator_DumpMap(self, *args)

    __swig_destroy__ = _TNaming.delete_TNaming_Translator
TNaming_Translator_swigregister = _TNaming.TNaming_Translator_swigregister
TNaming_Translator_swigregister(TNaming_Translator)

class Handle_TNaming_TranslateTool(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_TNaming_TranslateTool self)

        Nullify the handle


        """
        return _TNaming.Handle_TNaming_TranslateTool_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_TNaming_TranslateTool self) -> bool

        Check for being null

        :rtype: bool

        """
        return _TNaming.Handle_TNaming_TranslateTool_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_TNaming_TranslateTool self, TNaming_TranslateTool thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _TNaming.Handle_TNaming_TranslateTool_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_TNaming_TranslateTool self, Handle_TNaming_TranslateTool theHandle) -> Handle_TNaming_TranslateTool
        assign(Handle_TNaming_TranslateTool self, TNaming_TranslateTool thePtr) -> Handle_TNaming_TranslateTool
        assign(Handle_TNaming_TranslateTool self, Handle_TNaming_TranslateTool theHandle) -> Handle_TNaming_TranslateTool

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _TNaming.Handle_TNaming_TranslateTool_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_TNaming_TranslateTool self) -> TNaming_TranslateTool

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _TNaming.Handle_TNaming_TranslateTool_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_TNaming_TranslateTool self) -> TNaming_TranslateTool

        Member access operator (note non-const)

        :rtype: T *

        """
        return _TNaming.Handle_TNaming_TranslateTool___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_TNaming_TranslateTool self) -> TNaming_TranslateTool

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _TNaming.Handle_TNaming_TranslateTool___ref__(self, *args)


    def __hash__(self):
        return _TNaming.Handle_TNaming_TranslateTool___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _TNaming.Handle_TNaming_TranslateTool___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _TNaming.new_Handle_TNaming_TranslateTool(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_TNaming.Handle_TNaming_TranslateTool_DownCast)
    __swig_destroy__ = _TNaming.delete_Handle_TNaming_TranslateTool

    def Add(self, *args):
        """
        Add(Handle_TNaming_TranslateTool self, TopoDS_Shape S1, TopoDS_Shape S2)

        :type S1: OCC.wrapper.TopoDS.TopoDS_Shape
        :type S2: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _TNaming.Handle_TNaming_TranslateTool_Add(self, *args)


    def MakeVertex(self, *args):
        """
        MakeVertex(Handle_TNaming_TranslateTool self, TopoDS_Shape S)

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _TNaming.Handle_TNaming_TranslateTool_MakeVertex(self, *args)


    def MakeEdge(self, *args):
        """
        MakeEdge(Handle_TNaming_TranslateTool self, TopoDS_Shape S)

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _TNaming.Handle_TNaming_TranslateTool_MakeEdge(self, *args)


    def MakeWire(self, *args):
        """
        MakeWire(Handle_TNaming_TranslateTool self, TopoDS_Shape S)

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _TNaming.Handle_TNaming_TranslateTool_MakeWire(self, *args)


    def MakeFace(self, *args):
        """
        MakeFace(Handle_TNaming_TranslateTool self, TopoDS_Shape S)

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _TNaming.Handle_TNaming_TranslateTool_MakeFace(self, *args)


    def MakeShell(self, *args):
        """
        MakeShell(Handle_TNaming_TranslateTool self, TopoDS_Shape S)

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _TNaming.Handle_TNaming_TranslateTool_MakeShell(self, *args)


    def MakeSolid(self, *args):
        """
        MakeSolid(Handle_TNaming_TranslateTool self, TopoDS_Shape S)

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _TNaming.Handle_TNaming_TranslateTool_MakeSolid(self, *args)


    def MakeCompSolid(self, *args):
        """
        MakeCompSolid(Handle_TNaming_TranslateTool self, TopoDS_Shape S)

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _TNaming.Handle_TNaming_TranslateTool_MakeCompSolid(self, *args)


    def MakeCompound(self, *args):
        """
        MakeCompound(Handle_TNaming_TranslateTool self, TopoDS_Shape S)

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _TNaming.Handle_TNaming_TranslateTool_MakeCompound(self, *args)


    def UpdateVertex(self, *args):
        """
        UpdateVertex(Handle_TNaming_TranslateTool self, TopoDS_Shape S1, TopoDS_Shape S2, NCollection_IndexedDataMap_Handle_Standard_Transient_Handle_Standard_Transient_TColStd_MapTransientHasher M)

        :type S1: OCC.wrapper.TopoDS.TopoDS_Shape
        :type S2: OCC.wrapper.TopoDS.TopoDS_Shape
        :type M: OCC.wrapper.TColStd.TColStd_IndexedDataMapOfTransientTransient

        """
        return _TNaming.Handle_TNaming_TranslateTool_UpdateVertex(self, *args)


    def UpdateEdge(self, *args):
        """
        UpdateEdge(Handle_TNaming_TranslateTool self, TopoDS_Shape S1, TopoDS_Shape S2, NCollection_IndexedDataMap_Handle_Standard_Transient_Handle_Standard_Transient_TColStd_MapTransientHasher M)

        :type S1: OCC.wrapper.TopoDS.TopoDS_Shape
        :type S2: OCC.wrapper.TopoDS.TopoDS_Shape
        :type M: OCC.wrapper.TColStd.TColStd_IndexedDataMapOfTransientTransient

        """
        return _TNaming.Handle_TNaming_TranslateTool_UpdateEdge(self, *args)


    def UpdateFace(self, *args):
        """
        UpdateFace(Handle_TNaming_TranslateTool self, TopoDS_Shape S1, TopoDS_Shape S2, NCollection_IndexedDataMap_Handle_Standard_Transient_Handle_Standard_Transient_TColStd_MapTransientHasher M)

        :type S1: OCC.wrapper.TopoDS.TopoDS_Shape
        :type S2: OCC.wrapper.TopoDS.TopoDS_Shape
        :type M: OCC.wrapper.TColStd.TColStd_IndexedDataMapOfTransientTransient

        """
        return _TNaming.Handle_TNaming_TranslateTool_UpdateFace(self, *args)


    def UpdateShape(self, *args):
        """
        UpdateShape(Handle_TNaming_TranslateTool self, TopoDS_Shape S1, TopoDS_Shape S2)

        :type S1: OCC.wrapper.TopoDS.TopoDS_Shape
        :type S2: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _TNaming.Handle_TNaming_TranslateTool_UpdateShape(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_TNaming_TranslateTool self) -> char const *

        :rtype: const char *

        """
        return _TNaming.Handle_TNaming_TranslateTool_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TNaming.Handle_TNaming_TranslateTool_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TNaming.Handle_TNaming_TranslateTool_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_TNaming_TranslateTool self)

        Memory deallocator for transient classes


        """
        return _TNaming.Handle_TNaming_TranslateTool_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_TNaming_TranslateTool self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_TNaming_TranslateTool self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TNaming.Handle_TNaming_TranslateTool_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_TNaming_TranslateTool self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_TNaming_TranslateTool self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TNaming.Handle_TNaming_TranslateTool_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_TNaming_TranslateTool self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _TNaming.Handle_TNaming_TranslateTool_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_TNaming_TranslateTool self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TNaming.Handle_TNaming_TranslateTool_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_TNaming_TranslateTool self)

        Increments the reference counter of this object


        """
        return _TNaming.Handle_TNaming_TranslateTool_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_TNaming_TranslateTool self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TNaming.Handle_TNaming_TranslateTool_DecrementRefCounter(self, *args)

Handle_TNaming_TranslateTool_swigregister = _TNaming.Handle_TNaming_TranslateTool_swigregister
Handle_TNaming_TranslateTool_swigregister(Handle_TNaming_TranslateTool)

def Handle_TNaming_TranslateTool_DownCast(thing):
    return _TNaming.Handle_TNaming_TranslateTool_DownCast(thing)
Handle_TNaming_TranslateTool_DownCast = _TNaming.Handle_TNaming_TranslateTool_DownCast

class TNaming_Identifier(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(TNaming_Identifier self, TDF_Label Lab, TopoDS_Shape S, TopoDS_Shape Context, Standard_Boolean const Geom) -> TNaming_Identifier
        __init__(TNaming_Identifier self, TDF_Label Lab, TopoDS_Shape S, Handle_TNaming_NamedShape ContextNS, Standard_Boolean const Geom) -> TNaming_Identifier

        :type Lab: OCC.wrapper.TDF.TDF_Label
        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :type ContextNS: OCC.wrapper.TNaming.Handle_TNaming_NamedShape
        :type Geom: bool

        """
        this = _TNaming.new_TNaming_Identifier(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def IsDone(self, *args):
        """
        IsDone(TNaming_Identifier self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TNaming.TNaming_Identifier_IsDone(self, *args)


    def Type(self, *args):
        """
        Type(TNaming_Identifier self) -> TNaming_NameType

        :rtype: OCC.wrapper.TNaming.TNaming_NameType

        """
        return _TNaming.TNaming_Identifier_Type(self, *args)


    def IsFeature(self, *args):
        """
        IsFeature(TNaming_Identifier self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TNaming.TNaming_Identifier_IsFeature(self, *args)


    def Feature(self, *args):
        """
        Feature(TNaming_Identifier self) -> Handle_TNaming_NamedShape

        :rtype: OCC.wrapper.TNaming.Handle_TNaming_NamedShape

        """
        return _TNaming.TNaming_Identifier_Feature(self, *args)


    def InitArgs(self, *args):
        """InitArgs(TNaming_Identifier self)"""
        return _TNaming.TNaming_Identifier_InitArgs(self, *args)


    def MoreArgs(self, *args):
        """
        MoreArgs(TNaming_Identifier self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TNaming.TNaming_Identifier_MoreArgs(self, *args)


    def NextArg(self, *args):
        """NextArg(TNaming_Identifier self)"""
        return _TNaming.TNaming_Identifier_NextArg(self, *args)


    def ArgIsFeature(self, *args):
        """
        ArgIsFeature(TNaming_Identifier self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TNaming.TNaming_Identifier_ArgIsFeature(self, *args)


    def FeatureArg(self, *args):
        """
        FeatureArg(TNaming_Identifier self) -> Handle_TNaming_NamedShape

        :rtype: OCC.wrapper.TNaming.Handle_TNaming_NamedShape

        """
        return _TNaming.TNaming_Identifier_FeatureArg(self, *args)


    def ShapeArg(self, *args):
        """
        ShapeArg(TNaming_Identifier self) -> TopoDS_Shape

        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _TNaming.TNaming_Identifier_ShapeArg(self, *args)


    def ShapeContext(self, *args):
        """
        ShapeContext(TNaming_Identifier self) -> TopoDS_Shape

        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _TNaming.TNaming_Identifier_ShapeContext(self, *args)


    def NamedShapeOfGeneration(self, *args):
        """
        NamedShapeOfGeneration(TNaming_Identifier self) -> Handle_TNaming_NamedShape

        :rtype: OCC.wrapper.TNaming.Handle_TNaming_NamedShape

        """
        return _TNaming.TNaming_Identifier_NamedShapeOfGeneration(self, *args)


    def AncestorIdentification(self, *args):
        """
        AncestorIdentification(TNaming_Identifier self, TNaming_Localizer Localizer, TopoDS_Shape Context)

        :type Localizer: OCC.wrapper.TNaming.TNaming_Localizer
        :type Context: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _TNaming.TNaming_Identifier_AncestorIdentification(self, *args)


    def PrimitiveIdentification(self, *args):
        """
        PrimitiveIdentification(TNaming_Identifier self, TNaming_Localizer Localizer, Handle_TNaming_NamedShape NS)

        :type Localizer: OCC.wrapper.TNaming.TNaming_Localizer
        :type NS: OCC.wrapper.TNaming.Handle_TNaming_NamedShape

        """
        return _TNaming.TNaming_Identifier_PrimitiveIdentification(self, *args)


    def GeneratedIdentification(self, *args):
        """
        GeneratedIdentification(TNaming_Identifier self, TNaming_Localizer Localizer, Handle_TNaming_NamedShape NS)

        :type Localizer: OCC.wrapper.TNaming.TNaming_Localizer
        :type NS: OCC.wrapper.TNaming.Handle_TNaming_NamedShape

        """
        return _TNaming.TNaming_Identifier_GeneratedIdentification(self, *args)


    def Identification(self, *args):
        """
        Identification(TNaming_Identifier self, TNaming_Localizer Localizer, Handle_TNaming_NamedShape NS)

        :type Localizer: OCC.wrapper.TNaming.TNaming_Localizer
        :type NS: OCC.wrapper.TNaming.Handle_TNaming_NamedShape

        """
        return _TNaming.TNaming_Identifier_Identification(self, *args)

    __swig_destroy__ = _TNaming.delete_TNaming_Identifier
TNaming_Identifier_swigregister = _TNaming.TNaming_Identifier_swigregister
TNaming_Identifier_swigregister(TNaming_Identifier)




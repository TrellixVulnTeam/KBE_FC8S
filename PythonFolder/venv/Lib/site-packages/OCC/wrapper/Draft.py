# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_Draft')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_Draft')
    _Draft = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_Draft', [dirname(__file__)])
        except ImportError:
            import _Draft
            return _Draft
        try:
            _mod = imp.load_module('_Draft', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _Draft = swig_import_helper()
    del swig_import_helper
else:
    import _Draft
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


class SwigPyIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _Draft.delete_SwigPyIterator

    def value(self):
        return _Draft.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _Draft.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _Draft.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _Draft.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _Draft.SwigPyIterator_equal(self, x)

    def copy(self):
        return _Draft.SwigPyIterator_copy(self)

    def next(self):
        return _Draft.SwigPyIterator_next(self)

    def __next__(self):
        return _Draft.SwigPyIterator___next__(self)

    def previous(self):
        return _Draft.SwigPyIterator_previous(self)

    def advance(self, n):
        return _Draft.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _Draft.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _Draft.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _Draft.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _Draft.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _Draft.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _Draft.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self
SwigPyIterator_swigregister = _Draft.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

class NCollection_CellFilter_InspectorXYZ(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _Draft.NCollection_CellFilter_InspectorXYZ_Dimension
    Coord = staticmethod(_Draft.NCollection_CellFilter_InspectorXYZ_Coord)

    def Shift(self, thePnt, theTol):
        return _Draft.NCollection_CellFilter_InspectorXYZ_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _Draft.new_NCollection_CellFilter_InspectorXYZ()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _Draft.delete_NCollection_CellFilter_InspectorXYZ
NCollection_CellFilter_InspectorXYZ_swigregister = _Draft.NCollection_CellFilter_InspectorXYZ_swigregister
NCollection_CellFilter_InspectorXYZ_swigregister(NCollection_CellFilter_InspectorXYZ)

def NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt):
    return _Draft.NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt)
NCollection_CellFilter_InspectorXYZ_Coord = _Draft.NCollection_CellFilter_InspectorXYZ_Coord

class NCollection_CellFilter_InspectorXY(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _Draft.NCollection_CellFilter_InspectorXY_Dimension
    Coord = staticmethod(_Draft.NCollection_CellFilter_InspectorXY_Coord)

    def Shift(self, thePnt, theTol):
        return _Draft.NCollection_CellFilter_InspectorXY_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _Draft.new_NCollection_CellFilter_InspectorXY()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _Draft.delete_NCollection_CellFilter_InspectorXY
NCollection_CellFilter_InspectorXY_swigregister = _Draft.NCollection_CellFilter_InspectorXY_swigregister
NCollection_CellFilter_InspectorXY_swigregister(NCollection_CellFilter_InspectorXY)

def NCollection_CellFilter_InspectorXY_Coord(i, thePnt):
    return _Draft.NCollection_CellFilter_InspectorXY_Coord(i, thePnt)
NCollection_CellFilter_InspectorXY_Coord = _Draft.NCollection_CellFilter_InspectorXY_Coord


def ptr_to_number(item):
    return _Draft.ptr_to_number(item)
ptr_to_number = _Draft.ptr_to_number

def HashCode(*args):
    return _Draft.HashCode(*args)
HashCode = _Draft.HashCode

def ptr_equal(a, b):
    return _Draft.ptr_equal(a, b)
ptr_equal = _Draft.ptr_equal
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Geom2d
else:
    import Geom2d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import GeomAbs
else:
    import GeomAbs
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColStd
else:
    import TColStd
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TCollection
else:
    import TCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Standard
else:
    import Standard
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import NCollection
else:
    import NCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import gp
else:
    import gp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColgp
else:
    import TColgp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Geom
else:
    import Geom
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopAbs
else:
    import TopAbs
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import BRepTools
else:
    import BRepTools
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Bnd
else:
    import Bnd
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Poly
else:
    import Poly
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TShort
else:
    import TShort
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Message
else:
    import Message
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopLoc
else:
    import TopLoc
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopoDS
else:
    import TopoDS
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopTools
else:
    import TopTools
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import BRep
else:
    import BRep
del _swig_python_version_info
Draft_NoError = _Draft.Draft_NoError
Draft_FaceRecomputation = _Draft.Draft_FaceRecomputation
Draft_EdgeRecomputation = _Draft.Draft_EdgeRecomputation
Draft_VertexRecomputation = _Draft.Draft_VertexRecomputation
class Draft_FaceInfo(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Draft_FaceInfo self) -> Draft_FaceInfo
        __init__(Draft_FaceInfo self, Handle_Geom_Surface S, Standard_Boolean const HasNewGeometry) -> Draft_FaceInfo

        :type S: OCC.wrapper.Geom.Handle_Geom_Surface
        :type HasNewGeometry: bool

        """
        this = _Draft.new_Draft_FaceInfo(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def NewGeometry(self, *args):
        """
        NewGeometry(Draft_FaceInfo self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Draft.Draft_FaceInfo_NewGeometry(self, *args)


    def Add(self, *args):
        """
        Add(Draft_FaceInfo self, TopoDS_Face F)

        :type F: OCC.wrapper.TopoDS.TopoDS_Face

        """
        return _Draft.Draft_FaceInfo_Add(self, *args)


    def FirstFace(self, *args):
        """
        :rtype: OCC.wrapper.TopoDS.TopoDS_Face

        """
        res = _Draft.Draft_FaceInfo_FirstFace(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SecondFace(self, *args):
        """
        :rtype: OCC.wrapper.TopoDS.TopoDS_Face

        """
        res = _Draft.Draft_FaceInfo_SecondFace(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Geometry(self, *args):
        """
        :rtype: OCC.wrapper.Geom.Handle_Geom_Surface

        """
        res = _Draft.Draft_FaceInfo_Geometry(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeGeometry(self, *args):
        """
        ChangeGeometry(Draft_FaceInfo self) -> Handle_Geom_Surface

        :rtype: OCC.wrapper.Geom.Handle_Geom_Surface

        """
        return _Draft.Draft_FaceInfo_ChangeGeometry(self, *args)


    def RootFace(self, *args):
        """
        :rtype: OCC.wrapper.TopoDS.TopoDS_Face

        """
        res = _Draft.Draft_FaceInfo_RootFace(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeCurve(self, *args):
        """
        ChangeCurve(Draft_FaceInfo self) -> Handle_Geom_Curve

        :rtype: OCC.wrapper.Geom.Handle_Geom_Curve

        """
        return _Draft.Draft_FaceInfo_ChangeCurve(self, *args)


    def Curve(self, *args):
        """
        :rtype: OCC.wrapper.Geom.Handle_Geom_Curve

        """
        res = _Draft.Draft_FaceInfo_Curve(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Draft.delete_Draft_FaceInfo
Draft_FaceInfo_swigregister = _Draft.Draft_FaceInfo_swigregister
Draft_FaceInfo_swigregister(Draft_FaceInfo)

class Draft_EdgeInfo(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Draft_EdgeInfo self) -> Draft_EdgeInfo
        __init__(Draft_EdgeInfo self, Standard_Boolean const HasNewGeometry) -> Draft_EdgeInfo

        :type HasNewGeometry: bool

        """
        this = _Draft.new_Draft_EdgeInfo(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Add(self, *args):
        """
        Add(Draft_EdgeInfo self, TopoDS_Face F)

        :type F: OCC.wrapper.TopoDS.TopoDS_Face

        """
        return _Draft.Draft_EdgeInfo_Add(self, *args)


    def Tangent(self, *args):
        """
        Tangent(Draft_EdgeInfo self, gp_Pnt P)

        :type P: OCC.wrapper.gp.gp_Pnt

        """
        return _Draft.Draft_EdgeInfo_Tangent(self, *args)


    def IsTangent(self, *args):
        """
        IsTangent(Draft_EdgeInfo self, gp_Pnt P) -> Standard_Boolean

        :type P: OCC.wrapper.gp.gp_Pnt
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Draft.Draft_EdgeInfo_IsTangent(self, *args)


    def NewGeometry(self, *args):
        """
        NewGeometry(Draft_EdgeInfo self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Draft.Draft_EdgeInfo_NewGeometry(self, *args)


    def SetNewGeometry(self, *args):
        """
        SetNewGeometry(Draft_EdgeInfo self, Standard_Boolean const NewGeom)

        :type NewGeom: bool

        """
        return _Draft.Draft_EdgeInfo_SetNewGeometry(self, *args)


    def Geometry(self, *args):
        """
        :rtype: OCC.wrapper.Geom.Handle_Geom_Curve

        """
        res = _Draft.Draft_EdgeInfo_Geometry(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def FirstFace(self, *args):
        """
        :rtype: OCC.wrapper.TopoDS.TopoDS_Face

        """
        res = _Draft.Draft_EdgeInfo_FirstFace(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SecondFace(self, *args):
        """
        :rtype: OCC.wrapper.TopoDS.TopoDS_Face

        """
        res = _Draft.Draft_EdgeInfo_SecondFace(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def FirstPC(self, *args):
        """
        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Curve

        """
        res = _Draft.Draft_EdgeInfo_FirstPC(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SecondPC(self, *args):
        """
        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Curve

        """
        res = _Draft.Draft_EdgeInfo_SecondPC(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeGeometry(self, *args):
        """
        ChangeGeometry(Draft_EdgeInfo self) -> Handle_Geom_Curve

        :rtype: OCC.wrapper.Geom.Handle_Geom_Curve

        """
        return _Draft.Draft_EdgeInfo_ChangeGeometry(self, *args)


    def ChangeFirstPC(self, *args):
        """
        ChangeFirstPC(Draft_EdgeInfo self) -> Handle_Geom2d_Curve

        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Curve

        """
        return _Draft.Draft_EdgeInfo_ChangeFirstPC(self, *args)


    def ChangeSecondPC(self, *args):
        """
        ChangeSecondPC(Draft_EdgeInfo self) -> Handle_Geom2d_Curve

        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Curve

        """
        return _Draft.Draft_EdgeInfo_ChangeSecondPC(self, *args)


    def RootFace(self, *args):
        """
        :rtype: OCC.wrapper.TopoDS.TopoDS_Face

        """
        res = _Draft.Draft_EdgeInfo_RootFace(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Tolerance(self, *args):
        """
        Tolerance(Draft_EdgeInfo self, Standard_Real const tol)
        Tolerance(Draft_EdgeInfo self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Draft.Draft_EdgeInfo_Tolerance(self, *args)

    __swig_destroy__ = _Draft.delete_Draft_EdgeInfo
Draft_EdgeInfo_swigregister = _Draft.Draft_EdgeInfo_swigregister
Draft_EdgeInfo_swigregister(Draft_EdgeInfo)

class NCollection_IndexedDataMap_TopoDS_Face_Draft_FaceInfo_TopTools_ShapeMapHasher(NCollection.NCollection_BaseMap):
    """
    Purpose:     An indexed map is used  to store keys and to  bind
    an index to them.  Each  new key stored in the map
    gets an index.  Index are  incremented as keys are
    stored in the map. A key can be found by the index
    and an index by the key.  No  key but the last can
    be  removed so the  indices   are in the range 1..
    Extent.  An Item is stored with each key.

    This   class is   similar  to  IndexedMap     from
    NCollection  with the Item as  a new feature. Note
    the important difference on  the operator  ().  In
    the IndexedMap this operator returns  the Key.  In
    the IndexedDataMap this operator returns the Item.

    See  the  class   Map   from NCollection   for   a
    discussion about the number of buckets.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_IndexedDataMap_TopoDS_Face_Draft_FaceInfo_TopTools_ShapeMapHasher self) -> NCollection_IndexedDataMap< TopoDS_Face,Draft_FaceInfo,TopTools_ShapeMapHasher >::iterator

        Returns an iterator pointing to the first element in the map.

        :rtype: iterator

        """
        return _Draft.NCollection_IndexedDataMap_TopoDS_Face_Draft_FaceInfo_TopTools_ShapeMapHasher_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_IndexedDataMap_TopoDS_Face_Draft_FaceInfo_TopTools_ShapeMapHasher self) -> NCollection_IndexedDataMap< TopoDS_Face,Draft_FaceInfo,TopTools_ShapeMapHasher >::iterator

        Returns an iterator referring to the past-the-end element in the map.

        :rtype: iterator

        """
        return _Draft.NCollection_IndexedDataMap_TopoDS_Face_Draft_FaceInfo_TopTools_ShapeMapHasher_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_IndexedDataMap_TopoDS_Face_Draft_FaceInfo_TopTools_ShapeMapHasher self) -> NCollection_IndexedDataMap< TopoDS_Face,Draft_FaceInfo,TopTools_ShapeMapHasher >::const_iterator

        Returns a const iterator pointing to the first element in the map.

        :rtype: const_iterator

        """
        return _Draft.NCollection_IndexedDataMap_TopoDS_Face_Draft_FaceInfo_TopTools_ShapeMapHasher_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_IndexedDataMap_TopoDS_Face_Draft_FaceInfo_TopTools_ShapeMapHasher self) -> NCollection_IndexedDataMap< TopoDS_Face,Draft_FaceInfo,TopTools_ShapeMapHasher >::const_iterator

        Returns a const iterator referring to the past-the-end element in the map.

        :rtype: const_iterator

        """
        return _Draft.NCollection_IndexedDataMap_TopoDS_Face_Draft_FaceInfo_TopTools_ShapeMapHasher_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     An indexed map is used  to store keys and to  bind
        an index to them.  Each  new key stored in the map
        gets an index.  Index are  incremented as keys are
        stored in the map. A key can be found by the index
        and an index by the key.  No  key but the last can
        be  removed so the  indices   are in the range 1..
        Extent.  An Item is stored with each key.

        This   class is   similar  to  IndexedMap     from
        NCollection  with the Item as  a new feature. Note
        the important difference on  the operator  ().  In
        the IndexedMap this operator returns  the Key.  In
        the IndexedDataMap this operator returns the Item.

        See  the  class   Map   from NCollection   for   a
        discussion about the number of buckets.
        """
        this = _Draft.new_NCollection_IndexedDataMap_TopoDS_Face_Draft_FaceInfo_TopTools_ShapeMapHasher(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Exchange(self, *args):
        """
        Exchange(NCollection_IndexedDataMap_TopoDS_Face_Draft_FaceInfo_TopTools_ShapeMapHasher self, NCollection_IndexedDataMap_TopoDS_Face_Draft_FaceInfo_TopTools_ShapeMapHasher theOther)

        Exchange the content of two maps without re-allocations.
        Notice that allocators will be swapped as well!

        :type theOther: OCC.wrapper.NCollection.NCollection_IndexedDataMap

        """
        return _Draft.NCollection_IndexedDataMap_TopoDS_Face_Draft_FaceInfo_TopTools_ShapeMapHasher_Exchange(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_IndexedDataMap_TopoDS_Face_Draft_FaceInfo_TopTools_ShapeMapHasher self, NCollection_IndexedDataMap_TopoDS_Face_Draft_FaceInfo_TopTools_ShapeMapHasher theOther) -> NCollection_IndexedDataMap_TopoDS_Face_Draft_FaceInfo_TopTools_ShapeMapHasher

        Assignment.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_IndexedDataMap
        :rtype: OCC.wrapper.NCollection.NCollection_IndexedDataMap

        """
        return _Draft.NCollection_IndexedDataMap_TopoDS_Face_Draft_FaceInfo_TopTools_ShapeMapHasher_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_IndexedDataMap_TopoDS_Face_Draft_FaceInfo_TopTools_ShapeMapHasher self, NCollection_IndexedDataMap_TopoDS_Face_Draft_FaceInfo_TopTools_ShapeMapHasher theOther) -> NCollection_IndexedDataMap_TopoDS_Face_Draft_FaceInfo_TopTools_ShapeMapHasher

        Assignment operator

        :type theOther: OCC.wrapper.NCollection.NCollection_IndexedDataMap
        :rtype: OCC.wrapper.NCollection.NCollection_IndexedDataMap

        """
        return _Draft.NCollection_IndexedDataMap_TopoDS_Face_Draft_FaceInfo_TopTools_ShapeMapHasher_assign(self, *args)


    def ReSize(self, *args):
        """
        ReSize(NCollection_IndexedDataMap_TopoDS_Face_Draft_FaceInfo_TopTools_ShapeMapHasher self, Standard_Integer const N)

        ReSize

        :type N: int

        """
        return _Draft.NCollection_IndexedDataMap_TopoDS_Face_Draft_FaceInfo_TopTools_ShapeMapHasher_ReSize(self, *args)


    def Add(self, *args):
        """
        Add(NCollection_IndexedDataMap_TopoDS_Face_Draft_FaceInfo_TopTools_ShapeMapHasher self, TopoDS_Face theKey1, Draft_FaceInfo theItem) -> Standard_Integer

        Returns the Index of already bound Key or appends new Key with specified Item value.
        @param theKey1 Key to search (and to bind, if it was not bound already)
        @param theItem Item value to set for newly bound Key; ignored if Key was already bound
        @return index of Key

        :type theKey1: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Draft.NCollection_IndexedDataMap_TopoDS_Face_Draft_FaceInfo_TopTools_ShapeMapHasher_Add(self, *args)


    def Contains(self, *args):
        """
        Contains(NCollection_IndexedDataMap_TopoDS_Face_Draft_FaceInfo_TopTools_ShapeMapHasher self, TopoDS_Face theKey1) -> Standard_Boolean

        Contains

        :type theKey1: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Draft.NCollection_IndexedDataMap_TopoDS_Face_Draft_FaceInfo_TopTools_ShapeMapHasher_Contains(self, *args)


    def Substitute(self, *args):
        """
        Substitute(NCollection_IndexedDataMap_TopoDS_Face_Draft_FaceInfo_TopTools_ShapeMapHasher self, Standard_Integer const theIndex, TopoDS_Face theKey1, Draft_FaceInfo theItem)

        Substitute

        :type theIndex: int
        :type theKey1: const TheKeyType &
        :type theItem: const TheItemType &

        """
        return _Draft.NCollection_IndexedDataMap_TopoDS_Face_Draft_FaceInfo_TopTools_ShapeMapHasher_Substitute(self, *args)


    def Swap(self, *args):
        """
        Swap(NCollection_IndexedDataMap_TopoDS_Face_Draft_FaceInfo_TopTools_ShapeMapHasher self, Standard_Integer const theIndex1, Standard_Integer const theIndex2)

        Swaps two elements with the given indices.

        :type theIndex1: int
        :type theIndex2: int

        """
        return _Draft.NCollection_IndexedDataMap_TopoDS_Face_Draft_FaceInfo_TopTools_ShapeMapHasher_Swap(self, *args)


    def RemoveLast(self, *args):
        """
        RemoveLast(NCollection_IndexedDataMap_TopoDS_Face_Draft_FaceInfo_TopTools_ShapeMapHasher self)

        RemoveLast


        """
        return _Draft.NCollection_IndexedDataMap_TopoDS_Face_Draft_FaceInfo_TopTools_ShapeMapHasher_RemoveLast(self, *args)


    def RemoveFromIndex(self, *args):
        """
        RemoveFromIndex(NCollection_IndexedDataMap_TopoDS_Face_Draft_FaceInfo_TopTools_ShapeMapHasher self, Standard_Integer const theIndex)

        Remove the key of the given index.
        Caution! The index of the last key can be changed.

        :type theIndex: int

        """
        return _Draft.NCollection_IndexedDataMap_TopoDS_Face_Draft_FaceInfo_TopTools_ShapeMapHasher_RemoveFromIndex(self, *args)


    def RemoveKey(self, *args):
        """
        RemoveKey(NCollection_IndexedDataMap_TopoDS_Face_Draft_FaceInfo_TopTools_ShapeMapHasher self, TopoDS_Face theKey1)

        Remove the given key.
        Caution! The index of the last key can be changed.

        :type theKey1: const TheKeyType &

        """
        return _Draft.NCollection_IndexedDataMap_TopoDS_Face_Draft_FaceInfo_TopTools_ShapeMapHasher_RemoveKey(self, *args)


    def FindKey(self, *args):
        """
        FindKey

        :type theIndex: int
        :rtype: const TheKeyType &

        """
        res = _Draft.NCollection_IndexedDataMap_TopoDS_Face_Draft_FaceInfo_TopTools_ShapeMapHasher_FindKey(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def FindFromIndex(self, *args):
        """
        FindFromIndex

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _Draft.NCollection_IndexedDataMap_TopoDS_Face_Draft_FaceInfo_TopTools_ShapeMapHasher_FindFromIndex(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFromIndex(self, *args):
        """
        ChangeFromIndex(NCollection_IndexedDataMap_TopoDS_Face_Draft_FaceInfo_TopTools_ShapeMapHasher self, Standard_Integer const theIndex) -> Draft_FaceInfo

        ChangeFromIndex

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _Draft.NCollection_IndexedDataMap_TopoDS_Face_Draft_FaceInfo_TopTools_ShapeMapHasher_ChangeFromIndex(self, *args)


    def __call__(self, *args):
        """
        operator ()

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _Draft.NCollection_IndexedDataMap_TopoDS_Face_Draft_FaceInfo_TopTools_ShapeMapHasher___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def FindIndex(self, *args):
        """
        FindIndex(NCollection_IndexedDataMap_TopoDS_Face_Draft_FaceInfo_TopTools_ShapeMapHasher self, TopoDS_Face theKey1) -> Standard_Integer

        FindIndex

        :type theKey1: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Draft.NCollection_IndexedDataMap_TopoDS_Face_Draft_FaceInfo_TopTools_ShapeMapHasher_FindIndex(self, *args)


    def ChangeFromKey(self, *args):
        """
        ChangeFromKey(NCollection_IndexedDataMap_TopoDS_Face_Draft_FaceInfo_TopTools_ShapeMapHasher self, TopoDS_Face theKey1) -> Draft_FaceInfo

        ChangeFromKey

        :type theKey1: const TheKeyType &
        :rtype: TheItemType &

        """
        return _Draft.NCollection_IndexedDataMap_TopoDS_Face_Draft_FaceInfo_TopTools_ShapeMapHasher_ChangeFromKey(self, *args)


    def Seek(self, *args):
        """
        Seek(NCollection_IndexedDataMap_TopoDS_Face_Draft_FaceInfo_TopTools_ShapeMapHasher self, TopoDS_Face theKey1) -> Draft_FaceInfo

        Seek returns pointer to Item by Key. Returns
        NULL if Key was not found.

        :type theKey1: const TheKeyType &
        :rtype: const TheItemType *

        """
        return _Draft.NCollection_IndexedDataMap_TopoDS_Face_Draft_FaceInfo_TopTools_ShapeMapHasher_Seek(self, *args)


    def ChangeSeek(self, *args):
        """
        ChangeSeek(NCollection_IndexedDataMap_TopoDS_Face_Draft_FaceInfo_TopTools_ShapeMapHasher self, TopoDS_Face theKey1) -> Draft_FaceInfo

        ChangeSeek returns modifiable pointer to Item by Key. Returns
        NULL if Key was not found.

        :type theKey1: const TheKeyType &
        :rtype: TheItemType *

        """
        return _Draft.NCollection_IndexedDataMap_TopoDS_Face_Draft_FaceInfo_TopTools_ShapeMapHasher_ChangeSeek(self, *args)


    def FindFromKey(self, *args):
        """
        FindFromKey

        :type theKey1: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _Draft.NCollection_IndexedDataMap_TopoDS_Face_Draft_FaceInfo_TopTools_ShapeMapHasher_FindFromKey(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Clear(self, *args):
        """
        Clear(NCollection_IndexedDataMap_TopoDS_Face_Draft_FaceInfo_TopTools_ShapeMapHasher self, Standard_Boolean const doReleaseMemory)
        Clear(NCollection_IndexedDataMap_TopoDS_Face_Draft_FaceInfo_TopTools_ShapeMapHasher self, Handle_NCollection_BaseAllocator theAllocator)

        Clear data and reset allocator

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _Draft.NCollection_IndexedDataMap_TopoDS_Face_Draft_FaceInfo_TopTools_ShapeMapHasher_Clear(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_IndexedDataMap_TopoDS_Face_Draft_FaceInfo_TopTools_ShapeMapHasher self) -> Standard_Integer

        Size

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Draft.NCollection_IndexedDataMap_TopoDS_Face_Draft_FaceInfo_TopTools_ShapeMapHasher_Size(self, *args)


    def __iter__(self):
        return _Draft.NCollection_IndexedDataMap_TopoDS_Face_Draft_FaceInfo_TopTools_ShapeMapHasher___iter__(self)
    __swig_destroy__ = _Draft.delete_NCollection_IndexedDataMap_TopoDS_Face_Draft_FaceInfo_TopTools_ShapeMapHasher
NCollection_IndexedDataMap_TopoDS_Face_Draft_FaceInfo_TopTools_ShapeMapHasher_swigregister = _Draft.NCollection_IndexedDataMap_TopoDS_Face_Draft_FaceInfo_TopTools_ShapeMapHasher_swigregister
NCollection_IndexedDataMap_TopoDS_Face_Draft_FaceInfo_TopTools_ShapeMapHasher_swigregister(NCollection_IndexedDataMap_TopoDS_Face_Draft_FaceInfo_TopTools_ShapeMapHasher)

class NCollection_IndexedDataMap_TopoDS_Face_Draft_FaceInfo_TopTools_ShapeMapHasher_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _Draft.new_NCollection_IndexedDataMap_TopoDS_Face_Draft_FaceInfo_TopTools_ShapeMapHasher_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _Draft.delete_NCollection_IndexedDataMap_TopoDS_Face_Draft_FaceInfo_TopTools_ShapeMapHasher_IteratorHelper

    def __next__(self):
        return _Draft.NCollection_IndexedDataMap_TopoDS_Face_Draft_FaceInfo_TopTools_ShapeMapHasher_IteratorHelper___next__(self)
NCollection_IndexedDataMap_TopoDS_Face_Draft_FaceInfo_TopTools_ShapeMapHasher_IteratorHelper_swigregister = _Draft.NCollection_IndexedDataMap_TopoDS_Face_Draft_FaceInfo_TopTools_ShapeMapHasher_IteratorHelper_swigregister
NCollection_IndexedDataMap_TopoDS_Face_Draft_FaceInfo_TopTools_ShapeMapHasher_IteratorHelper_swigregister(NCollection_IndexedDataMap_TopoDS_Face_Draft_FaceInfo_TopTools_ShapeMapHasher_IteratorHelper)


try:
	Draft_IndexedDataMapOfFaceFaceInfo = NCollection_IndexedDataMap_TopoDS_Face_Draft_FaceInfo_TopTools_ShapeMapHasher
except NameError:
	pass # does not exist, probably ignored

class Draft_(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Angle(*args):
        """
        Angle(TopoDS_Face F, gp_Dir Direction) -> Standard_Real

        Returns the draft angle of the  face <F> using the
        direction <Direction>.  The  method is valid for :
        - Plane  faces,
        - Cylindrical or conical faces, when the direction
        of the axis of the surface is colinear with the
        direction.
        Otherwise, the exception DomainError is raised.

        :type F: OCC.wrapper.TopoDS.TopoDS_Face
        :type Direction: OCC.wrapper.gp.gp_Dir
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Draft.Draft__Angle(*args)

    Angle = staticmethod(Angle)

    def __init__(self):
        this = _Draft.new_Draft_()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _Draft.delete_Draft_
Draft__swigregister = _Draft.Draft__swigregister
Draft__swigregister(Draft_)

def Draft__Angle(*args):
    """
    Draft__Angle(TopoDS_Face F, gp_Dir Direction) -> Standard_Real

    Returns the draft angle of the  face <F> using the
    direction <Direction>.  The  method is valid for :
    - Plane  faces,
    - Cylindrical or conical faces, when the direction
    of the axis of the surface is colinear with the
    direction.
    Otherwise, the exception DomainError is raised.

    :type F: OCC.wrapper.TopoDS.TopoDS_Face
    :type Direction: OCC.wrapper.gp.gp_Dir
    :rtype: OCC.wrapper.Standard.Standard_Real

    """
    return _Draft.Draft__Angle(*args)

class NCollection_IndexedDataMap_TopoDS_Edge_Draft_EdgeInfo_TopTools_ShapeMapHasher(NCollection.NCollection_BaseMap):
    """
    Purpose:     An indexed map is used  to store keys and to  bind
    an index to them.  Each  new key stored in the map
    gets an index.  Index are  incremented as keys are
    stored in the map. A key can be found by the index
    and an index by the key.  No  key but the last can
    be  removed so the  indices   are in the range 1..
    Extent.  An Item is stored with each key.

    This   class is   similar  to  IndexedMap     from
    NCollection  with the Item as  a new feature. Note
    the important difference on  the operator  ().  In
    the IndexedMap this operator returns  the Key.  In
    the IndexedDataMap this operator returns the Item.

    See  the  class   Map   from NCollection   for   a
    discussion about the number of buckets.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_IndexedDataMap_TopoDS_Edge_Draft_EdgeInfo_TopTools_ShapeMapHasher self) -> NCollection_IndexedDataMap< TopoDS_Edge,Draft_EdgeInfo,TopTools_ShapeMapHasher >::iterator

        Returns an iterator pointing to the first element in the map.

        :rtype: iterator

        """
        return _Draft.NCollection_IndexedDataMap_TopoDS_Edge_Draft_EdgeInfo_TopTools_ShapeMapHasher_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_IndexedDataMap_TopoDS_Edge_Draft_EdgeInfo_TopTools_ShapeMapHasher self) -> NCollection_IndexedDataMap< TopoDS_Edge,Draft_EdgeInfo,TopTools_ShapeMapHasher >::iterator

        Returns an iterator referring to the past-the-end element in the map.

        :rtype: iterator

        """
        return _Draft.NCollection_IndexedDataMap_TopoDS_Edge_Draft_EdgeInfo_TopTools_ShapeMapHasher_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_IndexedDataMap_TopoDS_Edge_Draft_EdgeInfo_TopTools_ShapeMapHasher self) -> NCollection_IndexedDataMap< TopoDS_Edge,Draft_EdgeInfo,TopTools_ShapeMapHasher >::const_iterator

        Returns a const iterator pointing to the first element in the map.

        :rtype: const_iterator

        """
        return _Draft.NCollection_IndexedDataMap_TopoDS_Edge_Draft_EdgeInfo_TopTools_ShapeMapHasher_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_IndexedDataMap_TopoDS_Edge_Draft_EdgeInfo_TopTools_ShapeMapHasher self) -> NCollection_IndexedDataMap< TopoDS_Edge,Draft_EdgeInfo,TopTools_ShapeMapHasher >::const_iterator

        Returns a const iterator referring to the past-the-end element in the map.

        :rtype: const_iterator

        """
        return _Draft.NCollection_IndexedDataMap_TopoDS_Edge_Draft_EdgeInfo_TopTools_ShapeMapHasher_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     An indexed map is used  to store keys and to  bind
        an index to them.  Each  new key stored in the map
        gets an index.  Index are  incremented as keys are
        stored in the map. A key can be found by the index
        and an index by the key.  No  key but the last can
        be  removed so the  indices   are in the range 1..
        Extent.  An Item is stored with each key.

        This   class is   similar  to  IndexedMap     from
        NCollection  with the Item as  a new feature. Note
        the important difference on  the operator  ().  In
        the IndexedMap this operator returns  the Key.  In
        the IndexedDataMap this operator returns the Item.

        See  the  class   Map   from NCollection   for   a
        discussion about the number of buckets.
        """
        this = _Draft.new_NCollection_IndexedDataMap_TopoDS_Edge_Draft_EdgeInfo_TopTools_ShapeMapHasher(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Exchange(self, *args):
        """
        Exchange(NCollection_IndexedDataMap_TopoDS_Edge_Draft_EdgeInfo_TopTools_ShapeMapHasher self, NCollection_IndexedDataMap_TopoDS_Edge_Draft_EdgeInfo_TopTools_ShapeMapHasher theOther)

        Exchange the content of two maps without re-allocations.
        Notice that allocators will be swapped as well!

        :type theOther: OCC.wrapper.NCollection.NCollection_IndexedDataMap

        """
        return _Draft.NCollection_IndexedDataMap_TopoDS_Edge_Draft_EdgeInfo_TopTools_ShapeMapHasher_Exchange(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_IndexedDataMap_TopoDS_Edge_Draft_EdgeInfo_TopTools_ShapeMapHasher self, NCollection_IndexedDataMap_TopoDS_Edge_Draft_EdgeInfo_TopTools_ShapeMapHasher theOther) -> NCollection_IndexedDataMap_TopoDS_Edge_Draft_EdgeInfo_TopTools_ShapeMapHasher

        Assignment.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_IndexedDataMap
        :rtype: OCC.wrapper.NCollection.NCollection_IndexedDataMap

        """
        return _Draft.NCollection_IndexedDataMap_TopoDS_Edge_Draft_EdgeInfo_TopTools_ShapeMapHasher_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_IndexedDataMap_TopoDS_Edge_Draft_EdgeInfo_TopTools_ShapeMapHasher self, NCollection_IndexedDataMap_TopoDS_Edge_Draft_EdgeInfo_TopTools_ShapeMapHasher theOther) -> NCollection_IndexedDataMap_TopoDS_Edge_Draft_EdgeInfo_TopTools_ShapeMapHasher

        Assignment operator

        :type theOther: OCC.wrapper.NCollection.NCollection_IndexedDataMap
        :rtype: OCC.wrapper.NCollection.NCollection_IndexedDataMap

        """
        return _Draft.NCollection_IndexedDataMap_TopoDS_Edge_Draft_EdgeInfo_TopTools_ShapeMapHasher_assign(self, *args)


    def ReSize(self, *args):
        """
        ReSize(NCollection_IndexedDataMap_TopoDS_Edge_Draft_EdgeInfo_TopTools_ShapeMapHasher self, Standard_Integer const N)

        ReSize

        :type N: int

        """
        return _Draft.NCollection_IndexedDataMap_TopoDS_Edge_Draft_EdgeInfo_TopTools_ShapeMapHasher_ReSize(self, *args)


    def Add(self, *args):
        """
        Add(NCollection_IndexedDataMap_TopoDS_Edge_Draft_EdgeInfo_TopTools_ShapeMapHasher self, TopoDS_Edge theKey1, Draft_EdgeInfo theItem) -> Standard_Integer

        Returns the Index of already bound Key or appends new Key with specified Item value.
        @param theKey1 Key to search (and to bind, if it was not bound already)
        @param theItem Item value to set for newly bound Key; ignored if Key was already bound
        @return index of Key

        :type theKey1: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Draft.NCollection_IndexedDataMap_TopoDS_Edge_Draft_EdgeInfo_TopTools_ShapeMapHasher_Add(self, *args)


    def Contains(self, *args):
        """
        Contains(NCollection_IndexedDataMap_TopoDS_Edge_Draft_EdgeInfo_TopTools_ShapeMapHasher self, TopoDS_Edge theKey1) -> Standard_Boolean

        Contains

        :type theKey1: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Draft.NCollection_IndexedDataMap_TopoDS_Edge_Draft_EdgeInfo_TopTools_ShapeMapHasher_Contains(self, *args)


    def Substitute(self, *args):
        """
        Substitute(NCollection_IndexedDataMap_TopoDS_Edge_Draft_EdgeInfo_TopTools_ShapeMapHasher self, Standard_Integer const theIndex, TopoDS_Edge theKey1, Draft_EdgeInfo theItem)

        Substitute

        :type theIndex: int
        :type theKey1: const TheKeyType &
        :type theItem: const TheItemType &

        """
        return _Draft.NCollection_IndexedDataMap_TopoDS_Edge_Draft_EdgeInfo_TopTools_ShapeMapHasher_Substitute(self, *args)


    def Swap(self, *args):
        """
        Swap(NCollection_IndexedDataMap_TopoDS_Edge_Draft_EdgeInfo_TopTools_ShapeMapHasher self, Standard_Integer const theIndex1, Standard_Integer const theIndex2)

        Swaps two elements with the given indices.

        :type theIndex1: int
        :type theIndex2: int

        """
        return _Draft.NCollection_IndexedDataMap_TopoDS_Edge_Draft_EdgeInfo_TopTools_ShapeMapHasher_Swap(self, *args)


    def RemoveLast(self, *args):
        """
        RemoveLast(NCollection_IndexedDataMap_TopoDS_Edge_Draft_EdgeInfo_TopTools_ShapeMapHasher self)

        RemoveLast


        """
        return _Draft.NCollection_IndexedDataMap_TopoDS_Edge_Draft_EdgeInfo_TopTools_ShapeMapHasher_RemoveLast(self, *args)


    def RemoveFromIndex(self, *args):
        """
        RemoveFromIndex(NCollection_IndexedDataMap_TopoDS_Edge_Draft_EdgeInfo_TopTools_ShapeMapHasher self, Standard_Integer const theIndex)

        Remove the key of the given index.
        Caution! The index of the last key can be changed.

        :type theIndex: int

        """
        return _Draft.NCollection_IndexedDataMap_TopoDS_Edge_Draft_EdgeInfo_TopTools_ShapeMapHasher_RemoveFromIndex(self, *args)


    def RemoveKey(self, *args):
        """
        RemoveKey(NCollection_IndexedDataMap_TopoDS_Edge_Draft_EdgeInfo_TopTools_ShapeMapHasher self, TopoDS_Edge theKey1)

        Remove the given key.
        Caution! The index of the last key can be changed.

        :type theKey1: const TheKeyType &

        """
        return _Draft.NCollection_IndexedDataMap_TopoDS_Edge_Draft_EdgeInfo_TopTools_ShapeMapHasher_RemoveKey(self, *args)


    def FindKey(self, *args):
        """
        FindKey

        :type theIndex: int
        :rtype: const TheKeyType &

        """
        res = _Draft.NCollection_IndexedDataMap_TopoDS_Edge_Draft_EdgeInfo_TopTools_ShapeMapHasher_FindKey(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def FindFromIndex(self, *args):
        """
        FindFromIndex

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _Draft.NCollection_IndexedDataMap_TopoDS_Edge_Draft_EdgeInfo_TopTools_ShapeMapHasher_FindFromIndex(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFromIndex(self, *args):
        """
        ChangeFromIndex(NCollection_IndexedDataMap_TopoDS_Edge_Draft_EdgeInfo_TopTools_ShapeMapHasher self, Standard_Integer const theIndex) -> Draft_EdgeInfo

        ChangeFromIndex

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _Draft.NCollection_IndexedDataMap_TopoDS_Edge_Draft_EdgeInfo_TopTools_ShapeMapHasher_ChangeFromIndex(self, *args)


    def __call__(self, *args):
        """
        operator ()

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _Draft.NCollection_IndexedDataMap_TopoDS_Edge_Draft_EdgeInfo_TopTools_ShapeMapHasher___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def FindIndex(self, *args):
        """
        FindIndex(NCollection_IndexedDataMap_TopoDS_Edge_Draft_EdgeInfo_TopTools_ShapeMapHasher self, TopoDS_Edge theKey1) -> Standard_Integer

        FindIndex

        :type theKey1: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Draft.NCollection_IndexedDataMap_TopoDS_Edge_Draft_EdgeInfo_TopTools_ShapeMapHasher_FindIndex(self, *args)


    def ChangeFromKey(self, *args):
        """
        ChangeFromKey(NCollection_IndexedDataMap_TopoDS_Edge_Draft_EdgeInfo_TopTools_ShapeMapHasher self, TopoDS_Edge theKey1) -> Draft_EdgeInfo

        ChangeFromKey

        :type theKey1: const TheKeyType &
        :rtype: TheItemType &

        """
        return _Draft.NCollection_IndexedDataMap_TopoDS_Edge_Draft_EdgeInfo_TopTools_ShapeMapHasher_ChangeFromKey(self, *args)


    def Seek(self, *args):
        """
        Seek(NCollection_IndexedDataMap_TopoDS_Edge_Draft_EdgeInfo_TopTools_ShapeMapHasher self, TopoDS_Edge theKey1) -> Draft_EdgeInfo

        Seek returns pointer to Item by Key. Returns
        NULL if Key was not found.

        :type theKey1: const TheKeyType &
        :rtype: const TheItemType *

        """
        return _Draft.NCollection_IndexedDataMap_TopoDS_Edge_Draft_EdgeInfo_TopTools_ShapeMapHasher_Seek(self, *args)


    def ChangeSeek(self, *args):
        """
        ChangeSeek(NCollection_IndexedDataMap_TopoDS_Edge_Draft_EdgeInfo_TopTools_ShapeMapHasher self, TopoDS_Edge theKey1) -> Draft_EdgeInfo

        ChangeSeek returns modifiable pointer to Item by Key. Returns
        NULL if Key was not found.

        :type theKey1: const TheKeyType &
        :rtype: TheItemType *

        """
        return _Draft.NCollection_IndexedDataMap_TopoDS_Edge_Draft_EdgeInfo_TopTools_ShapeMapHasher_ChangeSeek(self, *args)


    def FindFromKey(self, *args):
        """
        FindFromKey

        :type theKey1: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _Draft.NCollection_IndexedDataMap_TopoDS_Edge_Draft_EdgeInfo_TopTools_ShapeMapHasher_FindFromKey(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Clear(self, *args):
        """
        Clear(NCollection_IndexedDataMap_TopoDS_Edge_Draft_EdgeInfo_TopTools_ShapeMapHasher self, Standard_Boolean const doReleaseMemory)
        Clear(NCollection_IndexedDataMap_TopoDS_Edge_Draft_EdgeInfo_TopTools_ShapeMapHasher self, Handle_NCollection_BaseAllocator theAllocator)

        Clear data and reset allocator

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _Draft.NCollection_IndexedDataMap_TopoDS_Edge_Draft_EdgeInfo_TopTools_ShapeMapHasher_Clear(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_IndexedDataMap_TopoDS_Edge_Draft_EdgeInfo_TopTools_ShapeMapHasher self) -> Standard_Integer

        Size

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Draft.NCollection_IndexedDataMap_TopoDS_Edge_Draft_EdgeInfo_TopTools_ShapeMapHasher_Size(self, *args)


    def __iter__(self):
        return _Draft.NCollection_IndexedDataMap_TopoDS_Edge_Draft_EdgeInfo_TopTools_ShapeMapHasher___iter__(self)
    __swig_destroy__ = _Draft.delete_NCollection_IndexedDataMap_TopoDS_Edge_Draft_EdgeInfo_TopTools_ShapeMapHasher
NCollection_IndexedDataMap_TopoDS_Edge_Draft_EdgeInfo_TopTools_ShapeMapHasher_swigregister = _Draft.NCollection_IndexedDataMap_TopoDS_Edge_Draft_EdgeInfo_TopTools_ShapeMapHasher_swigregister
NCollection_IndexedDataMap_TopoDS_Edge_Draft_EdgeInfo_TopTools_ShapeMapHasher_swigregister(NCollection_IndexedDataMap_TopoDS_Edge_Draft_EdgeInfo_TopTools_ShapeMapHasher)

class NCollection_IndexedDataMap_TopoDS_Edge_Draft_EdgeInfo_TopTools_ShapeMapHasher_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _Draft.new_NCollection_IndexedDataMap_TopoDS_Edge_Draft_EdgeInfo_TopTools_ShapeMapHasher_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _Draft.delete_NCollection_IndexedDataMap_TopoDS_Edge_Draft_EdgeInfo_TopTools_ShapeMapHasher_IteratorHelper

    def __next__(self):
        return _Draft.NCollection_IndexedDataMap_TopoDS_Edge_Draft_EdgeInfo_TopTools_ShapeMapHasher_IteratorHelper___next__(self)
NCollection_IndexedDataMap_TopoDS_Edge_Draft_EdgeInfo_TopTools_ShapeMapHasher_IteratorHelper_swigregister = _Draft.NCollection_IndexedDataMap_TopoDS_Edge_Draft_EdgeInfo_TopTools_ShapeMapHasher_IteratorHelper_swigregister
NCollection_IndexedDataMap_TopoDS_Edge_Draft_EdgeInfo_TopTools_ShapeMapHasher_IteratorHelper_swigregister(NCollection_IndexedDataMap_TopoDS_Edge_Draft_EdgeInfo_TopTools_ShapeMapHasher_IteratorHelper)


try:
	Draft_IndexedDataMapOfEdgeEdgeInfo = NCollection_IndexedDataMap_TopoDS_Edge_Draft_EdgeInfo_TopTools_ShapeMapHasher
except NameError:
	pass # does not exist, probably ignored

class Draft_VertexInfo(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """__init__(Draft_VertexInfo self) -> Draft_VertexInfo"""
        this = _Draft.new_Draft_VertexInfo(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Add(self, *args):
        """
        Add(Draft_VertexInfo self, TopoDS_Edge E)

        :type E: OCC.wrapper.TopoDS.TopoDS_Edge

        """
        return _Draft.Draft_VertexInfo_Add(self, *args)


    def Geometry(self, *args):
        """
        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        res = _Draft.Draft_VertexInfo_Geometry(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Parameter(self, *args):
        """
        Parameter(Draft_VertexInfo self, TopoDS_Edge E) -> Standard_Real

        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Draft.Draft_VertexInfo_Parameter(self, *args)


    def InitEdgeIterator(self, *args):
        """InitEdgeIterator(Draft_VertexInfo self)"""
        return _Draft.Draft_VertexInfo_InitEdgeIterator(self, *args)


    def Edge(self, *args):
        """
        :rtype: OCC.wrapper.TopoDS.TopoDS_Edge

        """
        res = _Draft.Draft_VertexInfo_Edge(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def NextEdge(self, *args):
        """NextEdge(Draft_VertexInfo self)"""
        return _Draft.Draft_VertexInfo_NextEdge(self, *args)


    def MoreEdge(self, *args):
        """
        MoreEdge(Draft_VertexInfo self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Draft.Draft_VertexInfo_MoreEdge(self, *args)


    def ChangeGeometry(self, *args):
        """
        ChangeGeometry(Draft_VertexInfo self) -> gp_Pnt

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _Draft.Draft_VertexInfo_ChangeGeometry(self, *args)


    def ChangeParameter(self, *args):
        """
        ChangeParameter(Draft_VertexInfo self, TopoDS_Edge E) -> Standard_Real &

        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Draft.Draft_VertexInfo_ChangeParameter(self, *args)

    __swig_destroy__ = _Draft.delete_Draft_VertexInfo
Draft_VertexInfo_swigregister = _Draft.Draft_VertexInfo_swigregister
Draft_VertexInfo_swigregister(Draft_VertexInfo)

class Draft_Modification(BRepTools.BRepTools_Modification):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Draft_Modification
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Draft_Modification(self) 
            return h


    def __init__(self, *args):
        """
        __init__(Draft_Modification self, TopoDS_Shape S) -> Draft_Modification

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        this = _Draft.new_Draft_Modification(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Clear(self, *args):
        """
        Clear(Draft_Modification self)

        Resets on the same shape.


        """
        return _Draft.Draft_Modification_Clear(self, *args)


    def Init(self, *args):
        """
        Init(Draft_Modification self, TopoDS_Shape S)

        Changes the basis shape and resets.

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _Draft.Draft_Modification_Init(self, *args)


    def Add(self, *args):
        """
        Add(Draft_Modification self, TopoDS_Face F, gp_Dir Direction, Standard_Real const Angle, gp_Pln NeutralPlane, Standard_Boolean const Flag) -> Standard_Boolean

        Adds  the  face  F    and propagates    the  draft
        modification to  its  neighbour faces if they  are
        tangent. If an error occurs, will return False and
        ProblematicShape  will  return the "bad" face.

        :type F: OCC.wrapper.TopoDS.TopoDS_Face
        :type Direction: OCC.wrapper.gp.gp_Dir
        :type Angle: float
        :type NeutralPlane: OCC.wrapper.gp.gp_Pln
        :type Flag: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Draft.Draft_Modification_Add(self, *args)


    def Remove(self, *args):
        """
        Remove(Draft_Modification self, TopoDS_Face F)

        Removes the face F and the neighbour faces if they
        are tangent.   It will be  necessary to  call this
        method if  the  method Add returns Standard_False,
        to unset ProblematicFace.

        :type F: OCC.wrapper.TopoDS.TopoDS_Face

        """
        return _Draft.Draft_Modification_Remove(self, *args)


    def Perform(self, *args):
        """
        Perform(Draft_Modification self)

        Performs the draft angle modification and sets the
        value returned by the method  IsDone.  If an error
        occurs, IsDone  will return Standard_False, and an
        error status will  be  given by the  method Error,
        and the  shape on which  the problem appeared will
        be given by ProblematicShape


        """
        return _Draft.Draft_Modification_Perform(self, *args)


    def IsDone(self, *args):
        """
        IsDone(Draft_Modification self) -> Standard_Boolean

        Returns  True  if   Perform has  been  succesfully
        called. Otherwise more information can be obtained
        using the methods Error() and ProblematicShape().

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Draft.Draft_Modification_IsDone(self, *args)


    def Error(self, *args):
        """
        Error(Draft_Modification self) -> Draft_ErrorStatus

        :rtype: OCC.wrapper.Draft.Draft_ErrorStatus

        """
        return _Draft.Draft_Modification_Error(self, *args)


    def ProblematicShape(self, *args):
        """
        Returns the shape (Face,  Edge or Vertex) on which
        an error occured.

        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _Draft.Draft_Modification_ProblematicShape(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ConnectedFaces(self, *args):
        """
        Returns all  the  faces   which  have been   added
        together with the face <F>.

        :type F: OCC.wrapper.TopoDS.TopoDS_Face
        :rtype: OCC.wrapper.TopTools.TopTools_ListOfShape

        """
        res = _Draft.Draft_Modification_ConnectedFaces(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ModifiedFaces(self, *args):
        """
        Returns all the faces  on which a modification has
        been given.

        :rtype: OCC.wrapper.TopTools.TopTools_ListOfShape

        """
        res = _Draft.Draft_Modification_ModifiedFaces(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def NewSurface(self, *args):
        """
        NewSurface(Draft_Modification self, TopoDS_Face F, Handle_Geom_Surface S, TopLoc_Location L) -> Standard_Boolean

        Returns Standard_True if   the face <F>  has  been
        modified.  In this case,  <S> is the new geometric
        support of the  face,  <L> the new  location,<Tol>
        the   new tolerance.<RevWires>  has  to  be set to
        Standard_True when   the modification reverses the
        normal   of  the  surface.(the  wires   have to be
        reversed).  <RevFace>    has    to  be   set    to
        Standard_True  if  the orientation of the modified
        face changes in  the shells which contain it. Here
        it will be set to Standard_False.

        Otherwise, returns Standard_False, and <S>,   <L>,
        <Tol> , <RevWires> ,<RevFace> are not  significant.

        :type F: OCC.wrapper.TopoDS.TopoDS_Face
        :type S: OCC.wrapper.Geom.Handle_Geom_Surface
        :type L: OCC.wrapper.TopLoc.TopLoc_Location
        :type Tol: float
        :type RevWires: bool
        :type RevFace: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Draft.Draft_Modification_NewSurface(self, *args)


    def NewCurve(self, *args):
        """
        NewCurve(Draft_Modification self, TopoDS_Edge E, Handle_Geom_Curve C, TopLoc_Location L) -> Standard_Boolean

        Returns Standard_True  if  the edge  <E> has  been
        modified.  In this case,  <C> is the new geometric
        support of the  edge, <L> the  new location, <Tol>
        the         new    tolerance.   Otherwise, returns
        Standard_False,    and  <C>,  <L>,   <Tol> are not
        significant.

        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :type C: OCC.wrapper.Geom.Handle_Geom_Curve
        :type L: OCC.wrapper.TopLoc.TopLoc_Location
        :type Tol: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Draft.Draft_Modification_NewCurve(self, *args)


    def NewPoint(self, *args):
        """
        NewPoint(Draft_Modification self, TopoDS_Vertex V, gp_Pnt P) -> Standard_Boolean

        Returns  Standard_True if the  vertex <V> has been
        modified.  In this  case, <P> is the new geometric
        support of the vertex,   <Tol> the new  tolerance.
        Otherwise, returns Standard_False, and <P>,  <Tol>
        are not significant.

        :type V: OCC.wrapper.TopoDS.TopoDS_Vertex
        :type P: OCC.wrapper.gp.gp_Pnt
        :type Tol: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Draft.Draft_Modification_NewPoint(self, *args)


    def NewCurve2d(self, *args):
        """
        NewCurve2d(Draft_Modification self, TopoDS_Edge E, TopoDS_Face F, TopoDS_Edge NewE, TopoDS_Face NewF, Handle_Geom2d_Curve C) -> Standard_Boolean

        Returns Standard_True if  the edge  <E> has a  new
        curve on surface on the face <F>.In this case, <C>
        is the new geometric support of  the edge, <L> the
        new location, <Tol> the new tolerance.

        Otherwise, returns  Standard_False, and <C>,  <L>,
        <Tol> are not significant.

        <NewE> is the new  edge created from  <E>.  <NewF>
        is the new face created from <F>. They may be usefull.

        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :type F: OCC.wrapper.TopoDS.TopoDS_Face
        :type NewE: OCC.wrapper.TopoDS.TopoDS_Edge
        :type NewF: OCC.wrapper.TopoDS.TopoDS_Face
        :type C: OCC.wrapper.Geom2d.Handle_Geom2d_Curve
        :type Tol: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Draft.Draft_Modification_NewCurve2d(self, *args)


    def NewParameter(self, *args):
        """
        NewParameter(Draft_Modification self, TopoDS_Vertex V, TopoDS_Edge E) -> Standard_Boolean

        Returns Standard_True if the Vertex  <V> has a new
        parameter on the  edge <E>. In  this case,  <P> is
        the parameter,    <Tol>  the     new    tolerance.
        Otherwise, returns Standard_False, and <P>,  <Tol>
        are not significant.

        :type V: OCC.wrapper.TopoDS.TopoDS_Vertex
        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :type P: float
        :type Tol: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Draft.Draft_Modification_NewParameter(self, *args)


    def Continuity(self, *args):
        """
        Continuity(Draft_Modification self, TopoDS_Edge E, TopoDS_Face F1, TopoDS_Face F2, TopoDS_Edge NewE, TopoDS_Face NewF1, TopoDS_Face NewF2) -> GeomAbs_Shape

        Returns the  continuity of  <NewE> between <NewF1>
        and <NewF2>.

        <NewE> is the new  edge created from <E>.  <NewF1>
        (resp. <NewF2>) is the new  face created from <F1>
        (resp. <F2>).

        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :type F1: OCC.wrapper.TopoDS.TopoDS_Face
        :type F2: OCC.wrapper.TopoDS.TopoDS_Face
        :type NewE: OCC.wrapper.TopoDS.TopoDS_Edge
        :type NewF1: OCC.wrapper.TopoDS.TopoDS_Face
        :type NewF2: OCC.wrapper.TopoDS.TopoDS_Face
        :rtype: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _Draft.Draft_Modification_Continuity(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Draft.Draft_Modification_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Draft.Draft_Modification_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Draft.Draft_Modification_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Draft.delete_Draft_Modification
Draft_Modification_swigregister = _Draft.Draft_Modification_swigregister
Draft_Modification_swigregister(Draft_Modification)

def Draft_Modification_get_type_name(*args):
    """
    Draft_Modification_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Draft.Draft_Modification_get_type_name(*args)

def Draft_Modification_get_type_descriptor(*args):
    """
    Draft_Modification_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Draft.Draft_Modification_get_type_descriptor(*args)

class Handle_Draft_Modification(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Draft_Modification self)

        Nullify the handle


        """
        return _Draft.Handle_Draft_Modification_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Draft_Modification self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Draft.Handle_Draft_Modification_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Draft_Modification self, Draft_Modification thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Draft.Handle_Draft_Modification_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Draft_Modification self, Handle_Draft_Modification theHandle) -> Handle_Draft_Modification
        assign(Handle_Draft_Modification self, Draft_Modification thePtr) -> Handle_Draft_Modification
        assign(Handle_Draft_Modification self, Handle_Draft_Modification theHandle) -> Handle_Draft_Modification

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Draft.Handle_Draft_Modification_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Draft_Modification self) -> Draft_Modification

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Draft.Handle_Draft_Modification_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Draft_Modification self) -> Draft_Modification

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Draft.Handle_Draft_Modification___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Draft_Modification self) -> Draft_Modification

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Draft.Handle_Draft_Modification___ref__(self, *args)


    def __hash__(self):
        return _Draft.Handle_Draft_Modification___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Draft.Handle_Draft_Modification___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Draft.new_Handle_Draft_Modification(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Draft.Handle_Draft_Modification_DownCast)
    __swig_destroy__ = _Draft.delete_Handle_Draft_Modification

    def Clear(self, *args):
        """
        Clear(Handle_Draft_Modification self)

        Resets on the same shape.


        """
        return _Draft.Handle_Draft_Modification_Clear(self, *args)


    def Init(self, *args):
        """
        Init(Handle_Draft_Modification self, TopoDS_Shape S)

        Changes the basis shape and resets.

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _Draft.Handle_Draft_Modification_Init(self, *args)


    def Add(self, *args):
        """
        Add(Handle_Draft_Modification self, TopoDS_Face F, gp_Dir Direction, Standard_Real const Angle, gp_Pln NeutralPlane, Standard_Boolean const Flag) -> Standard_Boolean

        Adds  the  face  F    and propagates    the  draft
        modification to  its  neighbour faces if they  are
        tangent. If an error occurs, will return False and
        ProblematicShape  will  return the "bad" face.

        :type F: OCC.wrapper.TopoDS.TopoDS_Face
        :type Direction: OCC.wrapper.gp.gp_Dir
        :type Angle: float
        :type NeutralPlane: OCC.wrapper.gp.gp_Pln
        :type Flag: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Draft.Handle_Draft_Modification_Add(self, *args)


    def Remove(self, *args):
        """
        Remove(Handle_Draft_Modification self, TopoDS_Face F)

        Removes the face F and the neighbour faces if they
        are tangent.   It will be  necessary to  call this
        method if  the  method Add returns Standard_False,
        to unset ProblematicFace.

        :type F: OCC.wrapper.TopoDS.TopoDS_Face

        """
        return _Draft.Handle_Draft_Modification_Remove(self, *args)


    def Perform(self, *args):
        """
        Perform(Handle_Draft_Modification self)

        Performs the draft angle modification and sets the
        value returned by the method  IsDone.  If an error
        occurs, IsDone  will return Standard_False, and an
        error status will  be  given by the  method Error,
        and the  shape on which  the problem appeared will
        be given by ProblematicShape


        """
        return _Draft.Handle_Draft_Modification_Perform(self, *args)


    def IsDone(self, *args):
        """
        IsDone(Handle_Draft_Modification self) -> Standard_Boolean

        Returns  True  if   Perform has  been  succesfully
        called. Otherwise more information can be obtained
        using the methods Error() and ProblematicShape().

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Draft.Handle_Draft_Modification_IsDone(self, *args)


    def Error(self, *args):
        """
        Error(Handle_Draft_Modification self) -> Draft_ErrorStatus

        :rtype: OCC.wrapper.Draft.Draft_ErrorStatus

        """
        return _Draft.Handle_Draft_Modification_Error(self, *args)


    def ProblematicShape(self, *args):
        """
        Returns the shape (Face,  Edge or Vertex) on which
        an error occured.

        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _Draft.Handle_Draft_Modification_ProblematicShape(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ConnectedFaces(self, *args):
        """
        Returns all  the  faces   which  have been   added
        together with the face <F>.

        :type F: OCC.wrapper.TopoDS.TopoDS_Face
        :rtype: OCC.wrapper.TopTools.TopTools_ListOfShape

        """
        res = _Draft.Handle_Draft_Modification_ConnectedFaces(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ModifiedFaces(self, *args):
        """
        Returns all the faces  on which a modification has
        been given.

        :rtype: OCC.wrapper.TopTools.TopTools_ListOfShape

        """
        res = _Draft.Handle_Draft_Modification_ModifiedFaces(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def NewSurface(self, *args):
        """
        NewSurface(Handle_Draft_Modification self, TopoDS_Face F, Handle_Geom_Surface S, TopLoc_Location L) -> Standard_Boolean

        Returns Standard_True if   the face <F>  has  been
        modified.  In this case,  <S> is the new geometric
        support of the  face,  <L> the new  location,<Tol>
        the   new tolerance.<RevWires>  has  to  be set to
        Standard_True when   the modification reverses the
        normal   of  the  surface.(the  wires   have to be
        reversed).  <RevFace>    has    to  be   set    to
        Standard_True  if  the orientation of the modified
        face changes in  the shells which contain it. Here
        it will be set to Standard_False.

        Otherwise, returns Standard_False, and <S>,   <L>,
        <Tol> , <RevWires> ,<RevFace> are not  significant.

        :type F: OCC.wrapper.TopoDS.TopoDS_Face
        :type S: OCC.wrapper.Geom.Handle_Geom_Surface
        :type L: OCC.wrapper.TopLoc.TopLoc_Location
        :type Tol: float
        :type RevWires: bool
        :type RevFace: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Draft.Handle_Draft_Modification_NewSurface(self, *args)


    def NewCurve(self, *args):
        """
        NewCurve(Handle_Draft_Modification self, TopoDS_Edge E, Handle_Geom_Curve C, TopLoc_Location L) -> Standard_Boolean

        Returns Standard_True  if  the edge  <E> has  been
        modified.  In this case,  <C> is the new geometric
        support of the  edge, <L> the  new location, <Tol>
        the         new    tolerance.   Otherwise, returns
        Standard_False,    and  <C>,  <L>,   <Tol> are not
        significant.

        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :type C: OCC.wrapper.Geom.Handle_Geom_Curve
        :type L: OCC.wrapper.TopLoc.TopLoc_Location
        :type Tol: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Draft.Handle_Draft_Modification_NewCurve(self, *args)


    def NewPoint(self, *args):
        """
        NewPoint(Handle_Draft_Modification self, TopoDS_Vertex V, gp_Pnt P) -> Standard_Boolean

        Returns  Standard_True if the  vertex <V> has been
        modified.  In this  case, <P> is the new geometric
        support of the vertex,   <Tol> the new  tolerance.
        Otherwise, returns Standard_False, and <P>,  <Tol>
        are not significant.

        :type V: OCC.wrapper.TopoDS.TopoDS_Vertex
        :type P: OCC.wrapper.gp.gp_Pnt
        :type Tol: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Draft.Handle_Draft_Modification_NewPoint(self, *args)


    def NewCurve2d(self, *args):
        """
        NewCurve2d(Handle_Draft_Modification self, TopoDS_Edge E, TopoDS_Face F, TopoDS_Edge NewE, TopoDS_Face NewF, Handle_Geom2d_Curve C) -> Standard_Boolean

        Returns Standard_True if  the edge  <E> has a  new
        curve on surface on the face <F>.In this case, <C>
        is the new geometric support of  the edge, <L> the
        new location, <Tol> the new tolerance.

        Otherwise, returns  Standard_False, and <C>,  <L>,
        <Tol> are not significant.

        <NewE> is the new  edge created from  <E>.  <NewF>
        is the new face created from <F>. They may be usefull.

        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :type F: OCC.wrapper.TopoDS.TopoDS_Face
        :type NewE: OCC.wrapper.TopoDS.TopoDS_Edge
        :type NewF: OCC.wrapper.TopoDS.TopoDS_Face
        :type C: OCC.wrapper.Geom2d.Handle_Geom2d_Curve
        :type Tol: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Draft.Handle_Draft_Modification_NewCurve2d(self, *args)


    def NewParameter(self, *args):
        """
        NewParameter(Handle_Draft_Modification self, TopoDS_Vertex V, TopoDS_Edge E) -> Standard_Boolean

        Returns Standard_True if the Vertex  <V> has a new
        parameter on the  edge <E>. In  this case,  <P> is
        the parameter,    <Tol>  the     new    tolerance.
        Otherwise, returns Standard_False, and <P>,  <Tol>
        are not significant.

        :type V: OCC.wrapper.TopoDS.TopoDS_Vertex
        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :type P: float
        :type Tol: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Draft.Handle_Draft_Modification_NewParameter(self, *args)


    def Continuity(self, *args):
        """
        Continuity(Handle_Draft_Modification self, TopoDS_Edge E, TopoDS_Face F1, TopoDS_Face F2, TopoDS_Edge NewE, TopoDS_Face NewF1, TopoDS_Face NewF2) -> GeomAbs_Shape

        Returns the  continuity of  <NewE> between <NewF1>
        and <NewF2>.

        <NewE> is the new  edge created from <E>.  <NewF1>
        (resp. <NewF2>) is the new  face created from <F1>
        (resp. <F2>).

        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :type F1: OCC.wrapper.TopoDS.TopoDS_Face
        :type F2: OCC.wrapper.TopoDS.TopoDS_Face
        :type NewE: OCC.wrapper.TopoDS.TopoDS_Edge
        :type NewF1: OCC.wrapper.TopoDS.TopoDS_Face
        :type NewF2: OCC.wrapper.TopoDS.TopoDS_Face
        :rtype: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _Draft.Handle_Draft_Modification_Continuity(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Draft_Modification self) -> char const *

        :rtype: const char *

        """
        return _Draft.Handle_Draft_Modification_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Draft.Handle_Draft_Modification_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Draft.Handle_Draft_Modification_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def NewTriangulation(self, *args):
        """
        NewTriangulation(Handle_Draft_Modification self, TopoDS_Face F, Handle_Poly_Triangulation T) -> Standard_Boolean

        Returns true if the face has been modified according to changed triangulation.
        If the face has been modified:
        - T is a new triangulation on the face

        :type F: OCC.wrapper.TopoDS.TopoDS_Face
        :type T: OCC.wrapper.Poly.Handle_Poly_Triangulation
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Draft.Handle_Draft_Modification_NewTriangulation(self, *args)


    def NewPolygon(self, *args):
        """
        NewPolygon(Handle_Draft_Modification self, TopoDS_Edge E, Handle_Poly_Polygon3D P) -> Standard_Boolean

        Returns true if the edge has been modified according to changed polygon.
        If the edge has been modified:
        - P is a new polygon

        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :type P: OCC.wrapper.Poly.Handle_Poly_Polygon3D
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Draft.Handle_Draft_Modification_NewPolygon(self, *args)


    def NewPolygonOnTriangulation(self, *args):
        """
        NewPolygonOnTriangulation(Handle_Draft_Modification self, TopoDS_Edge E, TopoDS_Face F, Handle_Poly_PolygonOnTriangulation P) -> Standard_Boolean

        Returns true if the edge has been modified according to changed polygon on triangulation.
        If the edge has been modified:
        - P is a new polygon on triangulation

        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :type F: OCC.wrapper.TopoDS.TopoDS_Face
        :type P: OCC.wrapper.Poly.Handle_Poly_PolygonOnTriangulation
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Draft.Handle_Draft_Modification_NewPolygonOnTriangulation(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_Draft_Modification self)

        Memory deallocator for transient classes


        """
        return _Draft.Handle_Draft_Modification_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Draft_Modification self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Draft_Modification self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Draft.Handle_Draft_Modification_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Draft_Modification self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Draft_Modification self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Draft.Handle_Draft_Modification_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Draft_Modification self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Draft.Handle_Draft_Modification_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Draft_Modification self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Draft.Handle_Draft_Modification_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Draft_Modification self)

        Increments the reference counter of this object


        """
        return _Draft.Handle_Draft_Modification_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Draft_Modification self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Draft.Handle_Draft_Modification_DecrementRefCounter(self, *args)

Handle_Draft_Modification_swigregister = _Draft.Handle_Draft_Modification_swigregister
Handle_Draft_Modification_swigregister(Handle_Draft_Modification)

def Handle_Draft_Modification_DownCast(thing):
    return _Draft.Handle_Draft_Modification_DownCast(thing)
Handle_Draft_Modification_DownCast = _Draft.Handle_Draft_Modification_DownCast

class NCollection_IndexedDataMap_TopoDS_Vertex_Draft_VertexInfo_TopTools_ShapeMapHasher(NCollection.NCollection_BaseMap):
    """
    Purpose:     An indexed map is used  to store keys and to  bind
    an index to them.  Each  new key stored in the map
    gets an index.  Index are  incremented as keys are
    stored in the map. A key can be found by the index
    and an index by the key.  No  key but the last can
    be  removed so the  indices   are in the range 1..
    Extent.  An Item is stored with each key.

    This   class is   similar  to  IndexedMap     from
    NCollection  with the Item as  a new feature. Note
    the important difference on  the operator  ().  In
    the IndexedMap this operator returns  the Key.  In
    the IndexedDataMap this operator returns the Item.

    See  the  class   Map   from NCollection   for   a
    discussion about the number of buckets.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_IndexedDataMap_TopoDS_Vertex_Draft_VertexInfo_TopTools_ShapeMapHasher self) -> NCollection_IndexedDataMap< TopoDS_Vertex,Draft_VertexInfo,TopTools_ShapeMapHasher >::iterator

        Returns an iterator pointing to the first element in the map.

        :rtype: iterator

        """
        return _Draft.NCollection_IndexedDataMap_TopoDS_Vertex_Draft_VertexInfo_TopTools_ShapeMapHasher_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_IndexedDataMap_TopoDS_Vertex_Draft_VertexInfo_TopTools_ShapeMapHasher self) -> NCollection_IndexedDataMap< TopoDS_Vertex,Draft_VertexInfo,TopTools_ShapeMapHasher >::iterator

        Returns an iterator referring to the past-the-end element in the map.

        :rtype: iterator

        """
        return _Draft.NCollection_IndexedDataMap_TopoDS_Vertex_Draft_VertexInfo_TopTools_ShapeMapHasher_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_IndexedDataMap_TopoDS_Vertex_Draft_VertexInfo_TopTools_ShapeMapHasher self) -> NCollection_IndexedDataMap< TopoDS_Vertex,Draft_VertexInfo,TopTools_ShapeMapHasher >::const_iterator

        Returns a const iterator pointing to the first element in the map.

        :rtype: const_iterator

        """
        return _Draft.NCollection_IndexedDataMap_TopoDS_Vertex_Draft_VertexInfo_TopTools_ShapeMapHasher_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_IndexedDataMap_TopoDS_Vertex_Draft_VertexInfo_TopTools_ShapeMapHasher self) -> NCollection_IndexedDataMap< TopoDS_Vertex,Draft_VertexInfo,TopTools_ShapeMapHasher >::const_iterator

        Returns a const iterator referring to the past-the-end element in the map.

        :rtype: const_iterator

        """
        return _Draft.NCollection_IndexedDataMap_TopoDS_Vertex_Draft_VertexInfo_TopTools_ShapeMapHasher_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     An indexed map is used  to store keys and to  bind
        an index to them.  Each  new key stored in the map
        gets an index.  Index are  incremented as keys are
        stored in the map. A key can be found by the index
        and an index by the key.  No  key but the last can
        be  removed so the  indices   are in the range 1..
        Extent.  An Item is stored with each key.

        This   class is   similar  to  IndexedMap     from
        NCollection  with the Item as  a new feature. Note
        the important difference on  the operator  ().  In
        the IndexedMap this operator returns  the Key.  In
        the IndexedDataMap this operator returns the Item.

        See  the  class   Map   from NCollection   for   a
        discussion about the number of buckets.
        """
        this = _Draft.new_NCollection_IndexedDataMap_TopoDS_Vertex_Draft_VertexInfo_TopTools_ShapeMapHasher(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Exchange(self, *args):
        """
        Exchange(NCollection_IndexedDataMap_TopoDS_Vertex_Draft_VertexInfo_TopTools_ShapeMapHasher self, NCollection_IndexedDataMap_TopoDS_Vertex_Draft_VertexInfo_TopTools_ShapeMapHasher theOther)

        Exchange the content of two maps without re-allocations.
        Notice that allocators will be swapped as well!

        :type theOther: OCC.wrapper.NCollection.NCollection_IndexedDataMap

        """
        return _Draft.NCollection_IndexedDataMap_TopoDS_Vertex_Draft_VertexInfo_TopTools_ShapeMapHasher_Exchange(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_IndexedDataMap_TopoDS_Vertex_Draft_VertexInfo_TopTools_ShapeMapHasher self, NCollection_IndexedDataMap_TopoDS_Vertex_Draft_VertexInfo_TopTools_ShapeMapHasher theOther) -> NCollection_IndexedDataMap_TopoDS_Vertex_Draft_VertexInfo_TopTools_ShapeMapHasher

        Assignment.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_IndexedDataMap
        :rtype: OCC.wrapper.NCollection.NCollection_IndexedDataMap

        """
        return _Draft.NCollection_IndexedDataMap_TopoDS_Vertex_Draft_VertexInfo_TopTools_ShapeMapHasher_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_IndexedDataMap_TopoDS_Vertex_Draft_VertexInfo_TopTools_ShapeMapHasher self, NCollection_IndexedDataMap_TopoDS_Vertex_Draft_VertexInfo_TopTools_ShapeMapHasher theOther) -> NCollection_IndexedDataMap_TopoDS_Vertex_Draft_VertexInfo_TopTools_ShapeMapHasher

        Assignment operator

        :type theOther: OCC.wrapper.NCollection.NCollection_IndexedDataMap
        :rtype: OCC.wrapper.NCollection.NCollection_IndexedDataMap

        """
        return _Draft.NCollection_IndexedDataMap_TopoDS_Vertex_Draft_VertexInfo_TopTools_ShapeMapHasher_assign(self, *args)


    def ReSize(self, *args):
        """
        ReSize(NCollection_IndexedDataMap_TopoDS_Vertex_Draft_VertexInfo_TopTools_ShapeMapHasher self, Standard_Integer const N)

        ReSize

        :type N: int

        """
        return _Draft.NCollection_IndexedDataMap_TopoDS_Vertex_Draft_VertexInfo_TopTools_ShapeMapHasher_ReSize(self, *args)


    def Add(self, *args):
        """
        Add(NCollection_IndexedDataMap_TopoDS_Vertex_Draft_VertexInfo_TopTools_ShapeMapHasher self, TopoDS_Vertex theKey1, Draft_VertexInfo theItem) -> Standard_Integer

        Returns the Index of already bound Key or appends new Key with specified Item value.
        @param theKey1 Key to search (and to bind, if it was not bound already)
        @param theItem Item value to set for newly bound Key; ignored if Key was already bound
        @return index of Key

        :type theKey1: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Draft.NCollection_IndexedDataMap_TopoDS_Vertex_Draft_VertexInfo_TopTools_ShapeMapHasher_Add(self, *args)


    def Contains(self, *args):
        """
        Contains(NCollection_IndexedDataMap_TopoDS_Vertex_Draft_VertexInfo_TopTools_ShapeMapHasher self, TopoDS_Vertex theKey1) -> Standard_Boolean

        Contains

        :type theKey1: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Draft.NCollection_IndexedDataMap_TopoDS_Vertex_Draft_VertexInfo_TopTools_ShapeMapHasher_Contains(self, *args)


    def Substitute(self, *args):
        """
        Substitute(NCollection_IndexedDataMap_TopoDS_Vertex_Draft_VertexInfo_TopTools_ShapeMapHasher self, Standard_Integer const theIndex, TopoDS_Vertex theKey1, Draft_VertexInfo theItem)

        Substitute

        :type theIndex: int
        :type theKey1: const TheKeyType &
        :type theItem: const TheItemType &

        """
        return _Draft.NCollection_IndexedDataMap_TopoDS_Vertex_Draft_VertexInfo_TopTools_ShapeMapHasher_Substitute(self, *args)


    def Swap(self, *args):
        """
        Swap(NCollection_IndexedDataMap_TopoDS_Vertex_Draft_VertexInfo_TopTools_ShapeMapHasher self, Standard_Integer const theIndex1, Standard_Integer const theIndex2)

        Swaps two elements with the given indices.

        :type theIndex1: int
        :type theIndex2: int

        """
        return _Draft.NCollection_IndexedDataMap_TopoDS_Vertex_Draft_VertexInfo_TopTools_ShapeMapHasher_Swap(self, *args)


    def RemoveLast(self, *args):
        """
        RemoveLast(NCollection_IndexedDataMap_TopoDS_Vertex_Draft_VertexInfo_TopTools_ShapeMapHasher self)

        RemoveLast


        """
        return _Draft.NCollection_IndexedDataMap_TopoDS_Vertex_Draft_VertexInfo_TopTools_ShapeMapHasher_RemoveLast(self, *args)


    def RemoveFromIndex(self, *args):
        """
        RemoveFromIndex(NCollection_IndexedDataMap_TopoDS_Vertex_Draft_VertexInfo_TopTools_ShapeMapHasher self, Standard_Integer const theIndex)

        Remove the key of the given index.
        Caution! The index of the last key can be changed.

        :type theIndex: int

        """
        return _Draft.NCollection_IndexedDataMap_TopoDS_Vertex_Draft_VertexInfo_TopTools_ShapeMapHasher_RemoveFromIndex(self, *args)


    def RemoveKey(self, *args):
        """
        RemoveKey(NCollection_IndexedDataMap_TopoDS_Vertex_Draft_VertexInfo_TopTools_ShapeMapHasher self, TopoDS_Vertex theKey1)

        Remove the given key.
        Caution! The index of the last key can be changed.

        :type theKey1: const TheKeyType &

        """
        return _Draft.NCollection_IndexedDataMap_TopoDS_Vertex_Draft_VertexInfo_TopTools_ShapeMapHasher_RemoveKey(self, *args)


    def FindKey(self, *args):
        """
        FindKey

        :type theIndex: int
        :rtype: const TheKeyType &

        """
        res = _Draft.NCollection_IndexedDataMap_TopoDS_Vertex_Draft_VertexInfo_TopTools_ShapeMapHasher_FindKey(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def FindFromIndex(self, *args):
        """
        FindFromIndex

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _Draft.NCollection_IndexedDataMap_TopoDS_Vertex_Draft_VertexInfo_TopTools_ShapeMapHasher_FindFromIndex(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFromIndex(self, *args):
        """
        ChangeFromIndex(NCollection_IndexedDataMap_TopoDS_Vertex_Draft_VertexInfo_TopTools_ShapeMapHasher self, Standard_Integer const theIndex) -> Draft_VertexInfo

        ChangeFromIndex

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _Draft.NCollection_IndexedDataMap_TopoDS_Vertex_Draft_VertexInfo_TopTools_ShapeMapHasher_ChangeFromIndex(self, *args)


    def __call__(self, *args):
        """
        operator ()

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _Draft.NCollection_IndexedDataMap_TopoDS_Vertex_Draft_VertexInfo_TopTools_ShapeMapHasher___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def FindIndex(self, *args):
        """
        FindIndex(NCollection_IndexedDataMap_TopoDS_Vertex_Draft_VertexInfo_TopTools_ShapeMapHasher self, TopoDS_Vertex theKey1) -> Standard_Integer

        FindIndex

        :type theKey1: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Draft.NCollection_IndexedDataMap_TopoDS_Vertex_Draft_VertexInfo_TopTools_ShapeMapHasher_FindIndex(self, *args)


    def ChangeFromKey(self, *args):
        """
        ChangeFromKey(NCollection_IndexedDataMap_TopoDS_Vertex_Draft_VertexInfo_TopTools_ShapeMapHasher self, TopoDS_Vertex theKey1) -> Draft_VertexInfo

        ChangeFromKey

        :type theKey1: const TheKeyType &
        :rtype: TheItemType &

        """
        return _Draft.NCollection_IndexedDataMap_TopoDS_Vertex_Draft_VertexInfo_TopTools_ShapeMapHasher_ChangeFromKey(self, *args)


    def Seek(self, *args):
        """
        Seek(NCollection_IndexedDataMap_TopoDS_Vertex_Draft_VertexInfo_TopTools_ShapeMapHasher self, TopoDS_Vertex theKey1) -> Draft_VertexInfo

        Seek returns pointer to Item by Key. Returns
        NULL if Key was not found.

        :type theKey1: const TheKeyType &
        :rtype: const TheItemType *

        """
        return _Draft.NCollection_IndexedDataMap_TopoDS_Vertex_Draft_VertexInfo_TopTools_ShapeMapHasher_Seek(self, *args)


    def ChangeSeek(self, *args):
        """
        ChangeSeek(NCollection_IndexedDataMap_TopoDS_Vertex_Draft_VertexInfo_TopTools_ShapeMapHasher self, TopoDS_Vertex theKey1) -> Draft_VertexInfo

        ChangeSeek returns modifiable pointer to Item by Key. Returns
        NULL if Key was not found.

        :type theKey1: const TheKeyType &
        :rtype: TheItemType *

        """
        return _Draft.NCollection_IndexedDataMap_TopoDS_Vertex_Draft_VertexInfo_TopTools_ShapeMapHasher_ChangeSeek(self, *args)


    def FindFromKey(self, *args):
        """
        FindFromKey

        :type theKey1: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _Draft.NCollection_IndexedDataMap_TopoDS_Vertex_Draft_VertexInfo_TopTools_ShapeMapHasher_FindFromKey(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Clear(self, *args):
        """
        Clear(NCollection_IndexedDataMap_TopoDS_Vertex_Draft_VertexInfo_TopTools_ShapeMapHasher self, Standard_Boolean const doReleaseMemory)
        Clear(NCollection_IndexedDataMap_TopoDS_Vertex_Draft_VertexInfo_TopTools_ShapeMapHasher self, Handle_NCollection_BaseAllocator theAllocator)

        Clear data and reset allocator

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _Draft.NCollection_IndexedDataMap_TopoDS_Vertex_Draft_VertexInfo_TopTools_ShapeMapHasher_Clear(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_IndexedDataMap_TopoDS_Vertex_Draft_VertexInfo_TopTools_ShapeMapHasher self) -> Standard_Integer

        Size

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Draft.NCollection_IndexedDataMap_TopoDS_Vertex_Draft_VertexInfo_TopTools_ShapeMapHasher_Size(self, *args)


    def __iter__(self):
        return _Draft.NCollection_IndexedDataMap_TopoDS_Vertex_Draft_VertexInfo_TopTools_ShapeMapHasher___iter__(self)
    __swig_destroy__ = _Draft.delete_NCollection_IndexedDataMap_TopoDS_Vertex_Draft_VertexInfo_TopTools_ShapeMapHasher
NCollection_IndexedDataMap_TopoDS_Vertex_Draft_VertexInfo_TopTools_ShapeMapHasher_swigregister = _Draft.NCollection_IndexedDataMap_TopoDS_Vertex_Draft_VertexInfo_TopTools_ShapeMapHasher_swigregister
NCollection_IndexedDataMap_TopoDS_Vertex_Draft_VertexInfo_TopTools_ShapeMapHasher_swigregister(NCollection_IndexedDataMap_TopoDS_Vertex_Draft_VertexInfo_TopTools_ShapeMapHasher)

class NCollection_IndexedDataMap_TopoDS_Vertex_Draft_VertexInfo_TopTools_ShapeMapHasher_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _Draft.new_NCollection_IndexedDataMap_TopoDS_Vertex_Draft_VertexInfo_TopTools_ShapeMapHasher_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _Draft.delete_NCollection_IndexedDataMap_TopoDS_Vertex_Draft_VertexInfo_TopTools_ShapeMapHasher_IteratorHelper

    def __next__(self):
        return _Draft.NCollection_IndexedDataMap_TopoDS_Vertex_Draft_VertexInfo_TopTools_ShapeMapHasher_IteratorHelper___next__(self)
NCollection_IndexedDataMap_TopoDS_Vertex_Draft_VertexInfo_TopTools_ShapeMapHasher_IteratorHelper_swigregister = _Draft.NCollection_IndexedDataMap_TopoDS_Vertex_Draft_VertexInfo_TopTools_ShapeMapHasher_IteratorHelper_swigregister
NCollection_IndexedDataMap_TopoDS_Vertex_Draft_VertexInfo_TopTools_ShapeMapHasher_IteratorHelper_swigregister(NCollection_IndexedDataMap_TopoDS_Vertex_Draft_VertexInfo_TopTools_ShapeMapHasher_IteratorHelper)


try:
	Draft_IndexedDataMapOfVertexVertexInfo = NCollection_IndexedDataMap_TopoDS_Vertex_Draft_VertexInfo_TopTools_ShapeMapHasher
except NameError:
	pass # does not exist, probably ignored




# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_TDocStd')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_TDocStd')
    _TDocStd = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_TDocStd', [dirname(__file__)])
        except ImportError:
            import _TDocStd
            return _TDocStd
        try:
            _mod = imp.load_module('_TDocStd', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _TDocStd = swig_import_helper()
    del swig_import_helper
else:
    import _TDocStd
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


class SwigPyIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _TDocStd.delete_SwigPyIterator

    def value(self):
        return _TDocStd.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _TDocStd.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _TDocStd.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _TDocStd.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _TDocStd.SwigPyIterator_equal(self, x)

    def copy(self):
        return _TDocStd.SwigPyIterator_copy(self)

    def next(self):
        return _TDocStd.SwigPyIterator_next(self)

    def __next__(self):
        return _TDocStd.SwigPyIterator___next__(self)

    def previous(self):
        return _TDocStd.SwigPyIterator_previous(self)

    def advance(self, n):
        return _TDocStd.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _TDocStd.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _TDocStd.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _TDocStd.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _TDocStd.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _TDocStd.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _TDocStd.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self
SwigPyIterator_swigregister = _TDocStd.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

class NCollection_CellFilter_InspectorXYZ(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _TDocStd.NCollection_CellFilter_InspectorXYZ_Dimension
    Coord = staticmethod(_TDocStd.NCollection_CellFilter_InspectorXYZ_Coord)

    def Shift(self, thePnt, theTol):
        return _TDocStd.NCollection_CellFilter_InspectorXYZ_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _TDocStd.new_NCollection_CellFilter_InspectorXYZ()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _TDocStd.delete_NCollection_CellFilter_InspectorXYZ
NCollection_CellFilter_InspectorXYZ_swigregister = _TDocStd.NCollection_CellFilter_InspectorXYZ_swigregister
NCollection_CellFilter_InspectorXYZ_swigregister(NCollection_CellFilter_InspectorXYZ)

def NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt):
    return _TDocStd.NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt)
NCollection_CellFilter_InspectorXYZ_Coord = _TDocStd.NCollection_CellFilter_InspectorXYZ_Coord

class NCollection_CellFilter_InspectorXY(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _TDocStd.NCollection_CellFilter_InspectorXY_Dimension
    Coord = staticmethod(_TDocStd.NCollection_CellFilter_InspectorXY_Coord)

    def Shift(self, thePnt, theTol):
        return _TDocStd.NCollection_CellFilter_InspectorXY_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _TDocStd.new_NCollection_CellFilter_InspectorXY()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _TDocStd.delete_NCollection_CellFilter_InspectorXY
NCollection_CellFilter_InspectorXY_swigregister = _TDocStd.NCollection_CellFilter_InspectorXY_swigregister
NCollection_CellFilter_InspectorXY_swigregister(NCollection_CellFilter_InspectorXY)

def NCollection_CellFilter_InspectorXY_Coord(i, thePnt):
    return _TDocStd.NCollection_CellFilter_InspectorXY_Coord(i, thePnt)
NCollection_CellFilter_InspectorXY_Coord = _TDocStd.NCollection_CellFilter_InspectorXY_Coord


def ptr_to_number(item):
    return _TDocStd.ptr_to_number(item)
ptr_to_number = _TDocStd.ptr_to_number

def HashCode(*args):
    return _TDocStd.HashCode(*args)
HashCode = _TDocStd.HashCode

def ptr_equal(a, b):
    return _TDocStd.ptr_equal(a, b)
ptr_equal = _TDocStd.ptr_equal
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import CDF
else:
    import CDF
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import CDM
else:
    import CDM
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Resource
else:
    import Resource
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TCollection
else:
    import TCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Standard
else:
    import Standard
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import NCollection
else:
    import NCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColStd
else:
    import TColStd
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Message
else:
    import Message
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import PCDM
else:
    import PCDM
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import LDOM
else:
    import LDOM
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Storage
else:
    import Storage
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TDF
else:
    import TDF
del _swig_python_version_info
class TDocStd_ApplicationDelta(Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_TDocStd_ApplicationDelta
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_TDocStd_ApplicationDelta(self) 
            return h


    def __init__(self, *args):
        """__init__(TDocStd_ApplicationDelta self) -> TDocStd_ApplicationDelta"""
        this = _TDocStd.new_TDocStd_ApplicationDelta(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def GetDocuments(self, *args):
        """
        GetDocuments(TDocStd_ApplicationDelta self) -> NCollection_Sequence_Handle_TDocStd_Document

        :rtype: OCC.wrapper.TDocStd.TDocStd_SequenceOfDocument

        """
        return _TDocStd.TDocStd_ApplicationDelta_GetDocuments(self, *args)


    def GetName(self, *args):
        """
        :rtype: OCC.wrapper.TCollection.TCollection_ExtendedString

        """
        res = _TDocStd.TDocStd_ApplicationDelta_GetName(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetName(self, *args):
        """
        SetName(TDocStd_ApplicationDelta self, TCollection_ExtendedString theName)

        :type theName: OCC.wrapper.TCollection.TCollection_ExtendedString

        """
        return _TDocStd.TDocStd_ApplicationDelta_SetName(self, *args)


    def Dump(self, *args):
        """
        Dump(TDocStd_ApplicationDelta self, Standard_OStream & anOS)

        :type anOS: OCC.wrapper.Standard.Standard_OStream

        """
        return _TDocStd.TDocStd_ApplicationDelta_Dump(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _TDocStd.TDocStd_ApplicationDelta_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _TDocStd.TDocStd_ApplicationDelta_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TDocStd.TDocStd_ApplicationDelta_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _TDocStd.delete_TDocStd_ApplicationDelta
TDocStd_ApplicationDelta_swigregister = _TDocStd.TDocStd_ApplicationDelta_swigregister
TDocStd_ApplicationDelta_swigregister(TDocStd_ApplicationDelta)

def TDocStd_ApplicationDelta_get_type_name(*args):
    """
    TDocStd_ApplicationDelta_get_type_name() -> char const *

    :rtype: const char *

    """
    return _TDocStd.TDocStd_ApplicationDelta_get_type_name(*args)

def TDocStd_ApplicationDelta_get_type_descriptor(*args):
    """
    TDocStd_ApplicationDelta_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _TDocStd.TDocStd_ApplicationDelta_get_type_descriptor(*args)

class TDocStd_Application(CDF.CDF_Application):
    """
    The abstract root class for all application classes.
    They are in charge of:
    -   Creating documents
    -   Storing documents and retrieving them
    -   Initializing document views.
    To create a useful OCAF-based application, you
    derive a class from Application and implement
    the methods below. You will have to redefine the
    deferred (virtual) methods Formats,
    InitDocument, and Resources, and override others.
    The application is a container for a document,
    which in its turn is the container of the data
    framework made up of labels and attributes.
    Besides furnishing a container for documents,
    TDocStd_Application provides the following
    services for them:
    -   Creation of new documents
    -   Activation of documents in sessions of an application
    -   Storage and retrieval of documents
    -   Initialization of document views.
    Note:
    If a client needs detailed information concerning
    the events during the Open/Store operation, a MessageDriver
    based on Message_PrinterOStream may be used. In case of need client
    can implement his own version inheriting from Message_Printer class 
    and add it to the Messanger.
    Also the trace level of messages can be tuned by setting trace level (SetTraceLevel (Gravity )) for the used Printer.
    By default, trace level is Message_Info, so that all messages are output.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_TDocStd_Application
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_TDocStd_Application(self) 
            return h


    def __init__(self, *args):
        """
        __init__(TDocStd_Application self) -> TDocStd_Application

        Constructs the new instance and registers it in CDM_Session


        """
        this = _TDocStd.new_TDocStd_Application(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def IsDriverLoaded(self, *args):
        """
        IsDriverLoaded(TDocStd_Application self) -> Standard_Boolean

        Check if meta data driver was successfully loaded
        by the application constructor

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDocStd.TDocStd_Application_IsDriverLoaded(self, *args)


    def MessageDriver(self, *args):
        """
        MessageDriver(TDocStd_Application self) -> Handle_Message_Messenger

        Redefines message driver, by default outputs to cout.

        :rtype: OCC.wrapper.Message.Handle_Message_Messenger

        """
        return _TDocStd.TDocStd_Application_MessageDriver(self, *args)


    def Resources(self, *args):
        """
        Resources(TDocStd_Application self) -> Handle_Resource_Manager

        Returns resource manager defining supported persistent formats.

        Default implementation loads resource file with name ResourcesName(),
        unless field myResources is already initialized (either by
        previous call or in any other way).

        The resource manager should define:

        * Format name for each file extension supported:
        - [Extension].FileFormat: [Format]

        * For each format supported (as returned by Formats()),
        its extension, description string, and (when applicable)
        GUIDs of storage and retrieval plugins:
        - [Format].Description: [Description]
        - [Format].FileExtension: [Extension]
        - [Format].RetrievalPlugin: [GUID] (optional)
        - [Format].StoragePlugin: [GUID] (optional)

        :rtype: OCC.wrapper.Resource.Handle_Resource_Manager

        """
        return _TDocStd.TDocStd_Application_Resources(self, *args)


    def ResourcesName(self, *args):
        """
        ResourcesName(TDocStd_Application self) -> Standard_CString

        Returns the name of the file containing the
        resources of this application, for support of legacy
        method of loading formats data from resource files.

        Method DefineFormat() can be used to define all necessary
        parameters explicitly without actually using resource files.

        In a resource file, the application associates the 
        schema name of the document with the storage and
        retrieval plug-ins that are to be loaded for each
        document. On retrieval, the application reads the
        schema name in the heading of the CSF file and
        loads the plug-in indicated in the resource file.
        This plug-in instantiates the actual driver for
        transient-persistent conversion.
        Your application can bring this process into play
        by defining a class which inherits
        CDF_Application and redefines the function
        which returns the appropriate resources file. At
        this point, the function Retrieve and the class
        CDF_Store can be called. This allows you to
        deal with storage and retrieval of - as well as
        copying and pasting - documents.
        To implement a class like this, several virtual
        functions should be redefined. In particular, you
        must redefine the abstract function Resources
        inherited from the superclass CDM_Application.

        Default implementation returns empty string.

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _TDocStd.TDocStd_Application_ResourcesName(self, *args)


    def DefineFormat(self, *args):
        """
        DefineFormat(TDocStd_Application self, TCollection_AsciiString theFormat, TCollection_AsciiString theDescription, TCollection_AsciiString theExtension, Handle_PCDM_RetrievalDriver theReader, Handle_PCDM_StorageDriver theWriter)

        Sets up resources and registers read and storage drivers for
        the specified format.

        @param theFormat - unique name for the format, used to identify it.
        @param theDescription - textual description of the format.
        @param theExtension - extension of the files in that format. 
        The same extension can be used by several formats.
        @param theReader - instance of the read driver for the format.
        Null value is allowed (no possibility to read).
        @param theWriter - instance of the write driver for the format.
        Null value is allowed (no possibility to write).

        :type theFormat: OCC.wrapper.TCollection.TCollection_AsciiString
        :type theDescription: OCC.wrapper.TCollection.TCollection_AsciiString
        :type theExtension: OCC.wrapper.TCollection.TCollection_AsciiString
        :type theReader: OCC.wrapper.PCDM.Handle_PCDM_RetrievalDriver
        :type theWriter: OCC.wrapper.PCDM.Handle_PCDM_StorageDriver

        """
        return _TDocStd.TDocStd_Application_DefineFormat(self, *args)


    def ReadingFormats(self, *args):
        """
        ReadingFormats(TDocStd_Application self, NCollection_Sequence_TCollection_AsciiString theFormats)

        Returns the sequence of reading formats supported by the application.

        @param theFormats - sequence of reading formats. Output parameter.

        :type theFormats: OCC.wrapper.TColStd.TColStd_SequenceOfAsciiString

        """
        return _TDocStd.TDocStd_Application_ReadingFormats(self, *args)


    def WritingFormats(self, *args):
        """
        WritingFormats(TDocStd_Application self, NCollection_Sequence_TCollection_AsciiString theFormats)

        Returns the sequence of writing formats supported by the application.

        @param theFormats - sequence of writing formats. Output parameter.

        :type theFormats: OCC.wrapper.TColStd.TColStd_SequenceOfAsciiString

        """
        return _TDocStd.TDocStd_Application_WritingFormats(self, *args)


    def NbDocuments(self, *args):
        """
        NbDocuments(TDocStd_Application self) -> Standard_Integer

        returns the number of documents handled by the current applicative session.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDocStd.TDocStd_Application_NbDocuments(self, *args)


    def GetDocument(self, *args):
        """
        GetDocument(TDocStd_Application self, Standard_Integer const index, Handle_TDocStd_Document aDoc)

        Constructs the new document aDoc.
        aDoc is identified by the index index which is
        any integer between 1 and n where n is the
        number of documents returned by NbDocument.
        Example
        Handle(TDocStd_Application)
        anApp;
        if (!CafTest::Find(A)) return 1;
        Handle(TDocStd) aDoc;
        Standard_Integer nbdoc = anApp->NbDocuments();
        for (Standard_Integer i = 1; i <= nbdoc; i++) {
        aApp->GetDocument(i,aDoc);

        :type index: int
        :type aDoc: OCC.wrapper.TDocStd.Handle_TDocStd_Document

        """
        return _TDocStd.TDocStd_Application_GetDocument(self, *args)


    def NewDocument(self, *args):
        """
        NewDocument(TDocStd_Application self, TCollection_ExtendedString format, Handle_TDocStd_Document aDoc)

        Constructs the empty new document aDoc.
        This document will have the format format.
        If InitDocument is redefined for a specific
        application, the new document is handled by the
        applicative session.

        :type format: OCC.wrapper.TCollection.TCollection_ExtendedString
        :type aDoc: OCC.wrapper.TDocStd.Handle_TDocStd_Document

        """
        return _TDocStd.TDocStd_Application_NewDocument(self, *args)


    def InitDocument(self, *args):
        """
        InitDocument(TDocStd_Application self, Handle_TDocStd_Document aDoc)

        Initialize the document aDoc for the applicative session.
        This virtual function is called by NewDocument
        and is to be redefined for each specific application.
        Modified flag (different of disk version)
        =============
        to open/save a document
        =======================

        :type aDoc: OCC.wrapper.TDocStd.Handle_TDocStd_Document

        """
        return _TDocStd.TDocStd_Application_InitDocument(self, *args)


    def Close(self, *args):
        """
        Close(TDocStd_Application self, Handle_TDocStd_Document aDoc)

        Close the given document. the document is not any more
        handled by the applicative session.

        :type aDoc: OCC.wrapper.TDocStd.Handle_TDocStd_Document

        """
        return _TDocStd.TDocStd_Application_Close(self, *args)


    def IsInSession(self, *args):
        """
        IsInSession(TDocStd_Application self, TCollection_ExtendedString path) -> Standard_Integer

        Returns an index for the document found in the
        path path in this applicative session.
        If the returned value is 0, the document is not
        present in the applicative session.
        This method can be used for the interactive part
        of an application. For instance, on a call to
        Open, the document to be opened may already
        be in memory. IsInSession checks to see if this
        is the case. Open can be made to depend on
        the value of the index returned: if IsInSession
        returns 0, the document is opened; if it returns
        another value, a message is displayed asking the
        user if he wants to override the version of the
        document in memory.
        Example:
        Standard_Integer insession = A->IsInSession(aDoc);
        if (insession > 0) {
        cout << "document " << insession << " is already in session" << endl;
        return 0;
        }

        :type path: OCC.wrapper.TCollection.TCollection_ExtendedString
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDocStd.TDocStd_Application_IsInSession(self, *args)


    def Open(self, *args):
        """
        Open(TDocStd_Application self, TCollection_ExtendedString path, Handle_TDocStd_Document aDoc) -> PCDM_ReaderStatus
        Open(TDocStd_Application self, Standard_IStream & theIStream, Handle_TDocStd_Document theDoc) -> PCDM_ReaderStatus

        Retrieves aDoc from standard SEEKABLE stream theIStream.
        the stream should support SEEK fuctionality

        :type theIStream: OCC.wrapper.Standard.Standard_IStream
        :type theDoc: OCC.wrapper.TDocStd.Handle_TDocStd_Document
        :rtype: OCC.wrapper.PCDM.PCDM_ReaderStatus

        """
        return _TDocStd.TDocStd_Application_Open(self, *args)


    def SaveAs(self, *args):
        """
        SaveAs(TDocStd_Application self, Handle_TDocStd_Document aDoc, TCollection_ExtendedString path) -> PCDM_StoreStatus
        SaveAs(TDocStd_Application self, Handle_TDocStd_Document theDoc, Standard_OStream & theOStream) -> PCDM_StoreStatus
        SaveAs(TDocStd_Application self, Handle_TDocStd_Document aDoc, TCollection_ExtendedString path, TCollection_ExtendedString theStatusMessage) -> PCDM_StoreStatus
        SaveAs(TDocStd_Application self, Handle_TDocStd_Document theDoc, Standard_OStream & theOStream, TCollection_ExtendedString theStatusMessage) -> PCDM_StoreStatus

        Save theDoc TO standard SEEKABLE stream theOStream.
        the stream should support SEEK fuctionality

        :type theDoc: OCC.wrapper.TDocStd.Handle_TDocStd_Document
        :type theOStream: OCC.wrapper.Standard.Standard_OStream
        :type theStatusMessage: OCC.wrapper.TCollection.TCollection_ExtendedString
        :rtype: OCC.wrapper.PCDM.PCDM_StoreStatus

        """
        return _TDocStd.TDocStd_Application_SaveAs(self, *args)


    def Save(self, *args):
        """
        Save(TDocStd_Application self, Handle_TDocStd_Document aDoc) -> PCDM_StoreStatus
        Save(TDocStd_Application self, Handle_TDocStd_Document aDoc, TCollection_ExtendedString theStatusMessage) -> PCDM_StoreStatus

        Save the document overwriting the previous file

        :type aDoc: OCC.wrapper.TDocStd.Handle_TDocStd_Document
        :type theStatusMessage: OCC.wrapper.TCollection.TCollection_ExtendedString
        :rtype: OCC.wrapper.PCDM.PCDM_StoreStatus

        """
        return _TDocStd.TDocStd_Application_Save(self, *args)


    def OnOpenTransaction(self, *args):
        """
        OnOpenTransaction(TDocStd_Application self, Handle_TDocStd_Document theDoc)

        Notification that is fired at each OpenTransaction event.

        :type theDoc: OCC.wrapper.TDocStd.Handle_TDocStd_Document

        """
        return _TDocStd.TDocStd_Application_OnOpenTransaction(self, *args)


    def OnCommitTransaction(self, *args):
        """
        OnCommitTransaction(TDocStd_Application self, Handle_TDocStd_Document theDoc)

        Notification that is fired at each CommitTransaction event.

        :type theDoc: OCC.wrapper.TDocStd.Handle_TDocStd_Document

        """
        return _TDocStd.TDocStd_Application_OnCommitTransaction(self, *args)


    def OnAbortTransaction(self, *args):
        """
        OnAbortTransaction(TDocStd_Application self, Handle_TDocStd_Document theDoc)

        Notification that is fired at each AbortTransaction event.

        :type theDoc: OCC.wrapper.TDocStd.Handle_TDocStd_Document

        """
        return _TDocStd.TDocStd_Application_OnAbortTransaction(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _TDocStd.TDocStd_Application_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _TDocStd.TDocStd_Application_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TDocStd.TDocStd_Application_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _TDocStd.delete_TDocStd_Application
TDocStd_Application_swigregister = _TDocStd.TDocStd_Application_swigregister
TDocStd_Application_swigregister(TDocStd_Application)

def TDocStd_Application_get_type_name(*args):
    """
    TDocStd_Application_get_type_name() -> char const *

    :rtype: const char *

    """
    return _TDocStd.TDocStd_Application_get_type_name(*args)

def TDocStd_Application_get_type_descriptor(*args):
    """
    TDocStd_Application_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _TDocStd.TDocStd_Application_get_type_descriptor(*args)

class TDocStd_XLinkRoot(TDF.TDF_Attribute):
    """
    This attribute is the root of all external
    references contained in a Data from TDF. Only one
    instance of this class is added to the TDF_Data
    root label. Starting from this attribute all the
    Reference are linked together, to be found
    easely.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_TDocStd_XLinkRoot
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_TDocStd_XLinkRoot(self) 
            return h


    def GetID(*args):
        """
        GetID() -> Standard_GUID

        Returns the ID: 2a96b61d-ec8b-11d0-bee7-080009dc3333

        :rtype: OCC.wrapper.Standard.Standard_GUID

        """
        return _TDocStd.TDocStd_XLinkRoot_GetID(*args)

    GetID = staticmethod(GetID)

    def Set(*args):
        """
        Set(Handle_TDF_Data aDF) -> Handle_TDocStd_XLinkRoot

        Sets an empty XLinkRoot to Root or gets the
        existing one. Only one attribute per TDF_Data.

        :type aDF: OCC.wrapper.TDF.Handle_TDF_Data
        :rtype: OCC.wrapper.TDocStd.Handle_TDocStd_XLinkRoot

        """
        return _TDocStd.TDocStd_XLinkRoot_Set(*args)

    Set = staticmethod(Set)

    def Insert(*args):
        """
        Insert(TDocStd_XLink anXLinkPtr)

        Inserts <anXLinkPtr> at the beginning of the XLink chain.

        :type anXLinkPtr: OCC.wrapper.TDocStd.TDocStd_XLinkPtr

        """
        return _TDocStd.TDocStd_XLinkRoot_Insert(*args)

    Insert = staticmethod(Insert)

    def Remove(*args):
        """
        Remove(TDocStd_XLink anXLinkPtr)

        Removes <anXLinkPtr> from the XLink chain, if it exists.

        :type anXLinkPtr: OCC.wrapper.TDocStd.TDocStd_XLinkPtr

        """
        return _TDocStd.TDocStd_XLinkRoot_Remove(*args)

    Remove = staticmethod(Remove)

    def ID(self, *args):
        """
        Returns the ID of the attribute.

        :rtype: OCC.wrapper.Standard.Standard_GUID

        """
        res = _TDocStd.TDocStd_XLinkRoot_ID(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def BackupCopy(self, *args):
        """
        BackupCopy(TDocStd_XLinkRoot self) -> Handle_TDF_Attribute

        Returns a null handle.

        :rtype: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TDocStd.TDocStd_XLinkRoot_BackupCopy(self, *args)


    def Restore(self, *args):
        """
        Restore(TDocStd_XLinkRoot self, Handle_TDF_Attribute anAttribute)

        Does nothing.

        :type anAttribute: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TDocStd.TDocStd_XLinkRoot_Restore(self, *args)


    def NewEmpty(self, *args):
        """
        NewEmpty(TDocStd_XLinkRoot self) -> Handle_TDF_Attribute

        Returns a null handle.

        :rtype: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TDocStd.TDocStd_XLinkRoot_NewEmpty(self, *args)


    def Paste(self, *args):
        """
        Paste(TDocStd_XLinkRoot self, Handle_TDF_Attribute intoAttribute, Handle_TDF_RelocationTable aRelocationTable)

        Does nothing.

        :type intoAttribute: OCC.wrapper.TDF.Handle_TDF_Attribute
        :type aRelocationTable: OCC.wrapper.TDF.Handle_TDF_RelocationTable

        """
        return _TDocStd.TDocStd_XLinkRoot_Paste(self, *args)


    def Dump(self, *args):
        """
        Dump(TDocStd_XLinkRoot self, Standard_OStream & anOS) -> Standard_OStream &

        Dumps the attribute on <aStream>.

        :type anOS: OCC.wrapper.Standard.Standard_OStream
        :rtype: OCC.wrapper.Standard.Standard_OStream

        """
        return _TDocStd.TDocStd_XLinkRoot_Dump(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _TDocStd.TDocStd_XLinkRoot_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _TDocStd.TDocStd_XLinkRoot_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TDocStd.TDocStd_XLinkRoot_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _TDocStd.delete_TDocStd_XLinkRoot
TDocStd_XLinkRoot_swigregister = _TDocStd.TDocStd_XLinkRoot_swigregister
TDocStd_XLinkRoot_swigregister(TDocStd_XLinkRoot)

def TDocStd_XLinkRoot_GetID(*args):
    """
    TDocStd_XLinkRoot_GetID() -> Standard_GUID

    Returns the ID: 2a96b61d-ec8b-11d0-bee7-080009dc3333

    :rtype: OCC.wrapper.Standard.Standard_GUID

    """
    return _TDocStd.TDocStd_XLinkRoot_GetID(*args)

def TDocStd_XLinkRoot_Set(*args):
    """
    TDocStd_XLinkRoot_Set(Handle_TDF_Data aDF) -> Handle_TDocStd_XLinkRoot

    Sets an empty XLinkRoot to Root or gets the
    existing one. Only one attribute per TDF_Data.

    :type aDF: OCC.wrapper.TDF.Handle_TDF_Data
    :rtype: OCC.wrapper.TDocStd.Handle_TDocStd_XLinkRoot

    """
    return _TDocStd.TDocStd_XLinkRoot_Set(*args)

def TDocStd_XLinkRoot_Insert(*args):
    """
    TDocStd_XLinkRoot_Insert(TDocStd_XLink anXLinkPtr)

    Inserts <anXLinkPtr> at the beginning of the XLink chain.

    :type anXLinkPtr: OCC.wrapper.TDocStd.TDocStd_XLinkPtr

    """
    return _TDocStd.TDocStd_XLinkRoot_Insert(*args)

def TDocStd_XLinkRoot_Remove(*args):
    """
    TDocStd_XLinkRoot_Remove(TDocStd_XLink anXLinkPtr)

    Removes <anXLinkPtr> from the XLink chain, if it exists.

    :type anXLinkPtr: OCC.wrapper.TDocStd.TDocStd_XLinkPtr

    """
    return _TDocStd.TDocStd_XLinkRoot_Remove(*args)

def TDocStd_XLinkRoot_get_type_name(*args):
    """
    TDocStd_XLinkRoot_get_type_name() -> char const *

    :rtype: const char *

    """
    return _TDocStd.TDocStd_XLinkRoot_get_type_name(*args)

def TDocStd_XLinkRoot_get_type_descriptor(*args):
    """
    TDocStd_XLinkRoot_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _TDocStd.TDocStd_XLinkRoot_get_type_descriptor(*args)

class TDocStd_Document(CDM.CDM_Document):
    """
    The contents of a TDocStd_Application, a
    document is a container for a data framework
    composed of labels and attributes. As such,
    TDocStd_Document is the entry point into the data framework.
    To gain access to the data, you create a document as follows:
    Handle(TDocStd_Document) MyDF = new TDocStd_Document
    The document also allows you to manage:
    -   modifications, providing Undo and Redo functions.
    -   command transactions.
    Warning: The only data saved is the framework (TDF_Data)
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_TDocStd_Document
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_TDocStd_Document(self) 
            return h


    def Get(*args):
        """
        Get(TDF_Label L) -> Handle_TDocStd_Document

        Will Abort any execution, clear fields
        returns the    document which contains <L>.  raises  an
        exception if the document is not found.

        :type L: OCC.wrapper.TDF.TDF_Label
        :rtype: OCC.wrapper.TDocStd.Handle_TDocStd_Document

        """
        return _TDocStd.TDocStd_Document_Get(*args)

    Get = staticmethod(Get)

    def __init__(self, *args):
        """
        __init__(TDocStd_Document self, TCollection_ExtendedString astorageformat) -> TDocStd_Document

        Constructs a document object defined by the
        string astorageformat.

        :type astorageformat: OCC.wrapper.TCollection.TCollection_ExtendedString

        """
        this = _TDocStd.new_TDocStd_Document(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def IsSaved(self, *args):
        """
        IsSaved(TDocStd_Document self) -> Standard_Boolean

        the document is saved in a file.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDocStd.TDocStd_Document_IsSaved(self, *args)


    def IsChanged(self, *args):
        """
        IsChanged(TDocStd_Document self) -> Standard_Boolean

        returns True if document differs from the state of last saving.
        this method have to be called only wroking in the transaction mode

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDocStd.TDocStd_Document_IsChanged(self, *args)


    def SetSaved(self, *args):
        """
        SetSaved(TDocStd_Document self)

        This method have to be called to show document that it has been saved


        """
        return _TDocStd.TDocStd_Document_SetSaved(self, *args)


    def SetSavedTime(self, *args):
        """
        SetSavedTime(TDocStd_Document self, Standard_Integer const theTime)

        Say to document what it is not saved.
        Use value, returned earlier by GetSavedTime().

        :type theTime: int

        """
        return _TDocStd.TDocStd_Document_SetSavedTime(self, *args)


    def GetSavedTime(self, *args):
        """
        GetSavedTime(TDocStd_Document self) -> Standard_Integer

        Returns value of <mySavedTime> to be used later in SetSavedTime()

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDocStd.TDocStd_Document_GetSavedTime(self, *args)


    def GetName(self, *args):
        """
        GetName(TDocStd_Document self) -> TCollection_ExtendedString

        raise if <me> is not saved.

        :rtype: OCC.wrapper.TCollection.TCollection_ExtendedString

        """
        return _TDocStd.TDocStd_Document_GetName(self, *args)


    def GetPath(self, *args):
        """
        GetPath(TDocStd_Document self) -> TCollection_ExtendedString

        returns the OS  path of the  file, in wich one <me> is
        saved. Raise an exception if <me> is not saved.

        :rtype: OCC.wrapper.TCollection.TCollection_ExtendedString

        """
        return _TDocStd.TDocStd_Document_GetPath(self, *args)


    def SetData(self, *args):
        """
        SetData(TDocStd_Document self, Handle_TDF_Data data)

        :type data: OCC.wrapper.TDF.Handle_TDF_Data

        """
        return _TDocStd.TDocStd_Document_SetData(self, *args)


    def GetData(self, *args):
        """
        GetData(TDocStd_Document self) -> Handle_TDF_Data

        :rtype: OCC.wrapper.TDF.Handle_TDF_Data

        """
        return _TDocStd.TDocStd_Document_GetData(self, *args)


    def Main(self, *args):
        """
        Main(TDocStd_Document self) -> TDF_Label

        Returns the main label in this data framework.
        By definition, this is the label with the entry 0:1.

        :rtype: OCC.wrapper.TDF.TDF_Label

        """
        return _TDocStd.TDocStd_Document_Main(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(TDocStd_Document self) -> Standard_Boolean

        Returns True if the main label has no attributes

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDocStd.TDocStd_Document_IsEmpty(self, *args)


    def IsValid(self, *args):
        """
        IsValid(TDocStd_Document self) -> Standard_Boolean

        Returns False if the  document has been modified
        but not recomputed.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDocStd.TDocStd_Document_IsValid(self, *args)


    def SetModified(self, *args):
        """
        SetModified(TDocStd_Document self, TDF_Label L)

        Notify the label as modified, the Document becomes UnValid.
        returns True if <L> has been notified as modified.

        :type L: OCC.wrapper.TDF.TDF_Label

        """
        return _TDocStd.TDocStd_Document_SetModified(self, *args)


    def PurgeModified(self, *args):
        """
        PurgeModified(TDocStd_Document self)

        Remove all modifications. After this call The document
        becomesagain Valid.


        """
        return _TDocStd.TDocStd_Document_PurgeModified(self, *args)


    def GetModified(self, *args):
        """
        Returns the labels which have been modified in
        this document.

        :rtype: OCC.wrapper.TDF.TDF_LabelMap

        """
        res = _TDocStd.TDocStd_Document_GetModified(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def NewCommand(self, *args):
        """
        NewCommand(TDocStd_Document self)

        Launches a new command. This command may be undone.


        """
        return _TDocStd.TDocStd_Document_NewCommand(self, *args)


    def HasOpenCommand(self, *args):
        """
        HasOpenCommand(TDocStd_Document self) -> Standard_Boolean

        returns True if a Command transaction is open in the curret .

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDocStd.TDocStd_Document_HasOpenCommand(self, *args)


    def OpenCommand(self, *args):
        """
        OpenCommand(TDocStd_Document self)

        Opens a new command transaction in this document.
        You can use HasOpenCommand to see whether a command is already open.
        Exceptions
        Standard_DomainError if a command is already open in this document.


        """
        return _TDocStd.TDocStd_Document_OpenCommand(self, *args)


    def CommitCommand(self, *args):
        """
        CommitCommand(TDocStd_Document self) -> Standard_Boolean

        Commits documents transactions and fills the
        transaction manager with documents that have
        been changed during the transaction.
        If no command transaction is open, nothing is done.
        Returns True if a new delta has been added to myUndos.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDocStd.TDocStd_Document_CommitCommand(self, *args)


    def AbortCommand(self, *args):
        """
        AbortCommand(TDocStd_Document self)

        Abort the  Command  transaction. Does nothing If there is
        no Command transaction open.


        """
        return _TDocStd.TDocStd_Document_AbortCommand(self, *args)


    def GetUndoLimit(self, *args):
        """
        GetUndoLimit(TDocStd_Document self) -> Standard_Integer

        The current limit on the number of undos

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDocStd.TDocStd_Document_GetUndoLimit(self, *args)


    def SetUndoLimit(self, *args):
        """
        SetUndoLimit(TDocStd_Document self, Standard_Integer const L)

        Set the  limit on  the number of  Undo Delta  stored 0
        will disable  Undo  on the  document A negative  value
        means no limit. Note that by default Undo is disabled.
        Enabling  it will  take effect with  the next  call to
        NewCommand. Of course this limit is the same for Redo

        :type L: int

        """
        return _TDocStd.TDocStd_Document_SetUndoLimit(self, *args)


    def ClearUndos(self, *args):
        """
        ClearUndos(TDocStd_Document self)

        Remove all stored Undos and Redos


        """
        return _TDocStd.TDocStd_Document_ClearUndos(self, *args)


    def ClearRedos(self, *args):
        """
        ClearRedos(TDocStd_Document self)

        Remove all stored Redos


        """
        return _TDocStd.TDocStd_Document_ClearRedos(self, *args)


    def GetAvailableUndos(self, *args):
        """
        GetAvailableUndos(TDocStd_Document self) -> Standard_Integer

        Returns the number of undos stored in this
        document. If this figure is greater than 0, the method Undo
        can be used.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDocStd.TDocStd_Document_GetAvailableUndos(self, *args)


    def Undo(self, *args):
        """
        Undo(TDocStd_Document self) -> Standard_Boolean

        Will UNDO  one step, returns  False if no undo was
        done (Undos == 0).
        Otherwise, true is returned and one step in the
        list of undoes is undone.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDocStd.TDocStd_Document_Undo(self, *args)


    def GetAvailableRedos(self, *args):
        """
        GetAvailableRedos(TDocStd_Document self) -> Standard_Integer

        Returns the number of redos stored in this
        document. If this figure is greater than 0, the method Redo
        can be used.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDocStd.TDocStd_Document_GetAvailableRedos(self, *args)


    def Redo(self, *args):
        """
        Redo(TDocStd_Document self) -> Standard_Boolean

        Will REDO  one step, returns  False if no redo was
        done (Redos == 0).
        Otherwise, true is returned, and one step in the list of redoes is done again.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDocStd.TDocStd_Document_Redo(self, *args)


    def GetUndos(self, *args):
        """
        :rtype: OCC.wrapper.TDF.TDF_DeltaList

        """
        res = _TDocStd.TDocStd_Document_GetUndos(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def GetRedos(self, *args):
        """
        :rtype: OCC.wrapper.TDF.TDF_DeltaList

        """
        res = _TDocStd.TDocStd_Document_GetRedos(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def RemoveFirstUndo(self, *args):
        """
        RemoveFirstUndo(TDocStd_Document self)

        Removes the first undo in the list of document undos.
        It is used in the application when the undo limit is exceed.


        """
        return _TDocStd.TDocStd_Document_RemoveFirstUndo(self, *args)


    def InitDeltaCompaction(self, *args):
        """
        InitDeltaCompaction(TDocStd_Document self) -> Standard_Boolean

        Initializes the procedure of delta compaction
        Returns false if there is no delta to compact
        Marks the last delta as a "from" delta

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDocStd.TDocStd_Document_InitDeltaCompaction(self, *args)


    def PerformDeltaCompaction(self, *args):
        """
        PerformDeltaCompaction(TDocStd_Document self) -> Standard_Boolean

        Performs the procedure of delta compaction
        Makes all deltas starting from "from" delta
        till the last one to be one delta.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDocStd.TDocStd_Document_PerformDeltaCompaction(self, *args)


    def UpdateReferences(self, *args):
        """
        UpdateReferences(TDocStd_Document self, TCollection_AsciiString aDocEntry)

        Set   modifications on  labels  impacted  by  external
        references to the entry.  The document becomes invalid
        and must be recomputed.

        :type aDocEntry: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _TDocStd.TDocStd_Document_UpdateReferences(self, *args)


    def Recompute(self, *args):
        """
        Recompute(TDocStd_Document self)

        Recompute if the document was  not valid and propagate
        the reccorded modification.


        """
        return _TDocStd.TDocStd_Document_Recompute(self, *args)


    def Update(self, *args):
        """
        Update(TDocStd_Document self, Handle_CDM_Document aToDocument, Standard_Integer const aReferenceIdentifier, Standard_Address const aModifContext)

        This method Update   will be called
        to signal the end   of the modified references list.
        The    document     should    be  recomputed     and
        UpdateFromDocuments  should be called.  Update should
        returns True in case  of success, false otherwise.  In
        case of Failure, additional information can be given in
        ErrorString.
        Update the document by propagation
        ==================================
        Update   the    document    from   internal   stored
        modifications.   If   you   want  to   undoing  this
        operation, please call NewCommand before.
        to change format (advanced programming)
        ================

        :type aToDocument: OCC.wrapper.CDM.Handle_CDM_Document
        :type aReferenceIdentifier: int
        :type aModifContext: OCC.wrapper.Standard.Standard_Address

        """
        return _TDocStd.TDocStd_Document_Update(self, *args)


    def StorageFormat(self, *args):
        """
        StorageFormat(TDocStd_Document self) -> TCollection_ExtendedString

        :rtype: OCC.wrapper.TCollection.TCollection_ExtendedString

        """
        return _TDocStd.TDocStd_Document_StorageFormat(self, *args)


    def SetEmptyLabelsSavingMode(self, *args):
        """
        SetEmptyLabelsSavingMode(TDocStd_Document self, Standard_Boolean const isAllowed)

        Sets saving mode for empty labels. If Standard_True, empty labels will be saved.

        :type isAllowed: bool

        """
        return _TDocStd.TDocStd_Document_SetEmptyLabelsSavingMode(self, *args)


    def EmptyLabelsSavingMode(self, *args):
        """
        EmptyLabelsSavingMode(TDocStd_Document self) -> Standard_Boolean

        Returns saving mode for empty labels.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDocStd.TDocStd_Document_EmptyLabelsSavingMode(self, *args)


    def ChangeStorageFormat(self, *args):
        """
        ChangeStorageFormat(TDocStd_Document self, TCollection_ExtendedString newStorageFormat)

        methods for the nested transaction mode

        :type newStorageFormat: OCC.wrapper.TCollection.TCollection_ExtendedString

        """
        return _TDocStd.TDocStd_Document_ChangeStorageFormat(self, *args)


    def SetNestedTransactionMode(self, *args):
        """
        SetNestedTransactionMode(TDocStd_Document self, Standard_Boolean const isAllowed)

        Sets nested transaction mode if isAllowed == Standard_True

        :type isAllowed: bool

        """
        return _TDocStd.TDocStd_Document_SetNestedTransactionMode(self, *args)


    def IsNestedTransactionMode(self, *args):
        """
        IsNestedTransactionMode(TDocStd_Document self) -> Standard_Boolean

        Returns Standard_True if mode is set

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDocStd.TDocStd_Document_IsNestedTransactionMode(self, *args)


    def SetModificationMode(self, *args):
        """
        SetModificationMode(TDocStd_Document self, Standard_Boolean const theTransactionOnly)

        if theTransactionOnly is True changes is denied outside transactions

        :type theTransactionOnly: bool

        """
        return _TDocStd.TDocStd_Document_SetModificationMode(self, *args)


    def ModificationMode(self, *args):
        """
        ModificationMode(TDocStd_Document self) -> Standard_Boolean

        returns True if changes allowed only inside transactions

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDocStd.TDocStd_Document_ModificationMode(self, *args)


    def BeforeClose(self, *args):
        """
        BeforeClose(TDocStd_Document self)

        Prepares document for closing


        """
        return _TDocStd.TDocStd_Document_BeforeClose(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _TDocStd.TDocStd_Document_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _TDocStd.TDocStd_Document_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TDocStd.TDocStd_Document_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _TDocStd.delete_TDocStd_Document
TDocStd_Document_swigregister = _TDocStd.TDocStd_Document_swigregister
TDocStd_Document_swigregister(TDocStd_Document)

def TDocStd_Document_Get(*args):
    """
    TDocStd_Document_Get(TDF_Label L) -> Handle_TDocStd_Document

    Will Abort any execution, clear fields
    returns the    document which contains <L>.  raises  an
    exception if the document is not found.

    :type L: OCC.wrapper.TDF.TDF_Label
    :rtype: OCC.wrapper.TDocStd.Handle_TDocStd_Document

    """
    return _TDocStd.TDocStd_Document_Get(*args)

def TDocStd_Document_get_type_name(*args):
    """
    TDocStd_Document_get_type_name() -> char const *

    :rtype: const char *

    """
    return _TDocStd.TDocStd_Document_get_type_name(*args)

def TDocStd_Document_get_type_descriptor(*args):
    """
    TDocStd_Document_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _TDocStd.TDocStd_Document_get_type_descriptor(*args)

class TDocStd_CompoundDelta(TDF.TDF_Delta):
    """
    A delta set is available at <aSourceTime>. If
    applied, it restores the TDF_Data in the state it
    was at <aTargetTime>.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_TDocStd_CompoundDelta
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_TDocStd_CompoundDelta(self) 
            return h


    def __init__(self, *args):
        """
        __init__(TDocStd_CompoundDelta self) -> TDocStd_CompoundDelta

        Creates a compound delta.
        Validates <me> at <aBeginTime>. If applied, it
        restores the TDF_Data in the state it was at
        <anEndTime>. Reserved to TDF_Data.


        """
        this = _TDocStd.new_TDocStd_CompoundDelta(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _TDocStd.TDocStd_CompoundDelta_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _TDocStd.TDocStd_CompoundDelta_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TDocStd.TDocStd_CompoundDelta_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _TDocStd.delete_TDocStd_CompoundDelta
TDocStd_CompoundDelta_swigregister = _TDocStd.TDocStd_CompoundDelta_swigregister
TDocStd_CompoundDelta_swigregister(TDocStd_CompoundDelta)

def TDocStd_CompoundDelta_get_type_name(*args):
    """
    TDocStd_CompoundDelta_get_type_name() -> char const *

    :rtype: const char *

    """
    return _TDocStd.TDocStd_CompoundDelta_get_type_name(*args)

def TDocStd_CompoundDelta_get_type_descriptor(*args):
    """
    TDocStd_CompoundDelta_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _TDocStd.TDocStd_CompoundDelta_get_type_descriptor(*args)

class TDocStd_PathParser(object):
    """parse an OS path"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(TDocStd_PathParser self, TCollection_ExtendedString path) -> TDocStd_PathParser

        :type path: OCC.wrapper.TCollection.TCollection_ExtendedString

        """
        this = _TDocStd.new_TDocStd_PathParser(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Parse(self, *args):
        """Parse(TDocStd_PathParser self)"""
        return _TDocStd.TDocStd_PathParser_Parse(self, *args)


    def Trek(self, *args):
        """
        Trek(TDocStd_PathParser self) -> TCollection_ExtendedString

        :rtype: OCC.wrapper.TCollection.TCollection_ExtendedString

        """
        return _TDocStd.TDocStd_PathParser_Trek(self, *args)


    def Name(self, *args):
        """
        Name(TDocStd_PathParser self) -> TCollection_ExtendedString

        :rtype: OCC.wrapper.TCollection.TCollection_ExtendedString

        """
        return _TDocStd.TDocStd_PathParser_Name(self, *args)


    def Extension(self, *args):
        """
        Extension(TDocStd_PathParser self) -> TCollection_ExtendedString

        :rtype: OCC.wrapper.TCollection.TCollection_ExtendedString

        """
        return _TDocStd.TDocStd_PathParser_Extension(self, *args)


    def Path(self, *args):
        """
        Path(TDocStd_PathParser self) -> TCollection_ExtendedString

        :rtype: OCC.wrapper.TCollection.TCollection_ExtendedString

        """
        return _TDocStd.TDocStd_PathParser_Path(self, *args)


    def Length(self, *args):
        """
        Length(TDocStd_PathParser self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDocStd.TDocStd_PathParser_Length(self, *args)

    __swig_destroy__ = _TDocStd.delete_TDocStd_PathParser
TDocStd_PathParser_swigregister = _TDocStd.TDocStd_PathParser_swigregister
TDocStd_PathParser_swigregister(TDocStd_PathParser)

class Handle_TDocStd_Document(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_TDocStd_Document self)

        Nullify the handle


        """
        return _TDocStd.Handle_TDocStd_Document_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_TDocStd_Document self) -> bool

        Check for being null

        :rtype: bool

        """
        return _TDocStd.Handle_TDocStd_Document_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_TDocStd_Document self, TDocStd_Document thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _TDocStd.Handle_TDocStd_Document_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_TDocStd_Document self, Handle_TDocStd_Document theHandle) -> Handle_TDocStd_Document
        assign(Handle_TDocStd_Document self, TDocStd_Document thePtr) -> Handle_TDocStd_Document
        assign(Handle_TDocStd_Document self, Handle_TDocStd_Document theHandle) -> Handle_TDocStd_Document

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _TDocStd.Handle_TDocStd_Document_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_TDocStd_Document self) -> TDocStd_Document

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _TDocStd.Handle_TDocStd_Document_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_TDocStd_Document self) -> TDocStd_Document

        Member access operator (note non-const)

        :rtype: T *

        """
        return _TDocStd.Handle_TDocStd_Document___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_TDocStd_Document self) -> TDocStd_Document

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _TDocStd.Handle_TDocStd_Document___ref__(self, *args)


    def __hash__(self):
        return _TDocStd.Handle_TDocStd_Document___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _TDocStd.Handle_TDocStd_Document___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _TDocStd.new_Handle_TDocStd_Document(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_TDocStd.Handle_TDocStd_Document_DownCast)
    __swig_destroy__ = _TDocStd.delete_Handle_TDocStd_Document

    def Get(self, *args):
        """
        Get(Handle_TDocStd_Document self, TDF_Label L) -> Handle_TDocStd_Document

        Will Abort any execution, clear fields
        returns the    document which contains <L>.  raises  an
        exception if the document is not found.

        :type L: OCC.wrapper.TDF.TDF_Label
        :rtype: OCC.wrapper.TDocStd.Handle_TDocStd_Document

        """
        return _TDocStd.Handle_TDocStd_Document_Get(self, *args)


    def IsSaved(self, *args):
        """
        IsSaved(Handle_TDocStd_Document self) -> Standard_Boolean

        the document is saved in a file.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDocStd.Handle_TDocStd_Document_IsSaved(self, *args)


    def IsChanged(self, *args):
        """
        IsChanged(Handle_TDocStd_Document self) -> Standard_Boolean

        returns True if document differs from the state of last saving.
        this method have to be called only wroking in the transaction mode

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDocStd.Handle_TDocStd_Document_IsChanged(self, *args)


    def SetSaved(self, *args):
        """
        SetSaved(Handle_TDocStd_Document self)

        This method have to be called to show document that it has been saved


        """
        return _TDocStd.Handle_TDocStd_Document_SetSaved(self, *args)


    def SetSavedTime(self, *args):
        """
        SetSavedTime(Handle_TDocStd_Document self, Standard_Integer const theTime)

        Say to document what it is not saved.
        Use value, returned earlier by GetSavedTime().

        :type theTime: int

        """
        return _TDocStd.Handle_TDocStd_Document_SetSavedTime(self, *args)


    def GetSavedTime(self, *args):
        """
        GetSavedTime(Handle_TDocStd_Document self) -> Standard_Integer

        Returns value of <mySavedTime> to be used later in SetSavedTime()

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDocStd.Handle_TDocStd_Document_GetSavedTime(self, *args)


    def GetName(self, *args):
        """
        GetName(Handle_TDocStd_Document self) -> TCollection_ExtendedString

        raise if <me> is not saved.

        :rtype: OCC.wrapper.TCollection.TCollection_ExtendedString

        """
        return _TDocStd.Handle_TDocStd_Document_GetName(self, *args)


    def GetPath(self, *args):
        """
        GetPath(Handle_TDocStd_Document self) -> TCollection_ExtendedString

        returns the OS  path of the  file, in wich one <me> is
        saved. Raise an exception if <me> is not saved.

        :rtype: OCC.wrapper.TCollection.TCollection_ExtendedString

        """
        return _TDocStd.Handle_TDocStd_Document_GetPath(self, *args)


    def SetData(self, *args):
        """
        SetData(Handle_TDocStd_Document self, Handle_TDF_Data data)

        :type data: OCC.wrapper.TDF.Handle_TDF_Data

        """
        return _TDocStd.Handle_TDocStd_Document_SetData(self, *args)


    def GetData(self, *args):
        """
        GetData(Handle_TDocStd_Document self) -> Handle_TDF_Data

        :rtype: OCC.wrapper.TDF.Handle_TDF_Data

        """
        return _TDocStd.Handle_TDocStd_Document_GetData(self, *args)


    def Main(self, *args):
        """
        Main(Handle_TDocStd_Document self) -> TDF_Label

        Returns the main label in this data framework.
        By definition, this is the label with the entry 0:1.

        :rtype: OCC.wrapper.TDF.TDF_Label

        """
        return _TDocStd.Handle_TDocStd_Document_Main(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(Handle_TDocStd_Document self) -> Standard_Boolean

        Returns True if the main label has no attributes

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDocStd.Handle_TDocStd_Document_IsEmpty(self, *args)


    def IsValid(self, *args):
        """
        IsValid(Handle_TDocStd_Document self) -> Standard_Boolean

        Returns False if the  document has been modified
        but not recomputed.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDocStd.Handle_TDocStd_Document_IsValid(self, *args)


    def SetModified(self, *args):
        """
        SetModified(Handle_TDocStd_Document self, TDF_Label L)

        Notify the label as modified, the Document becomes UnValid.
        returns True if <L> has been notified as modified.

        :type L: OCC.wrapper.TDF.TDF_Label

        """
        return _TDocStd.Handle_TDocStd_Document_SetModified(self, *args)


    def PurgeModified(self, *args):
        """
        PurgeModified(Handle_TDocStd_Document self)

        Remove all modifications. After this call The document
        becomesagain Valid.


        """
        return _TDocStd.Handle_TDocStd_Document_PurgeModified(self, *args)


    def GetModified(self, *args):
        """
        Returns the labels which have been modified in
        this document.

        :rtype: OCC.wrapper.TDF.TDF_LabelMap

        """
        res = _TDocStd.Handle_TDocStd_Document_GetModified(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def NewCommand(self, *args):
        """
        NewCommand(Handle_TDocStd_Document self)

        Launches a new command. This command may be undone.


        """
        return _TDocStd.Handle_TDocStd_Document_NewCommand(self, *args)


    def HasOpenCommand(self, *args):
        """
        HasOpenCommand(Handle_TDocStd_Document self) -> Standard_Boolean

        returns True if a Command transaction is open in the curret .

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDocStd.Handle_TDocStd_Document_HasOpenCommand(self, *args)


    def OpenCommand(self, *args):
        """
        OpenCommand(Handle_TDocStd_Document self)

        Opens a new command transaction in this document.
        You can use HasOpenCommand to see whether a command is already open.
        Exceptions
        Standard_DomainError if a command is already open in this document.


        """
        return _TDocStd.Handle_TDocStd_Document_OpenCommand(self, *args)


    def CommitCommand(self, *args):
        """
        CommitCommand(Handle_TDocStd_Document self) -> Standard_Boolean

        Commits documents transactions and fills the
        transaction manager with documents that have
        been changed during the transaction.
        If no command transaction is open, nothing is done.
        Returns True if a new delta has been added to myUndos.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDocStd.Handle_TDocStd_Document_CommitCommand(self, *args)


    def AbortCommand(self, *args):
        """
        AbortCommand(Handle_TDocStd_Document self)

        Abort the  Command  transaction. Does nothing If there is
        no Command transaction open.


        """
        return _TDocStd.Handle_TDocStd_Document_AbortCommand(self, *args)


    def GetUndoLimit(self, *args):
        """
        GetUndoLimit(Handle_TDocStd_Document self) -> Standard_Integer

        The current limit on the number of undos

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDocStd.Handle_TDocStd_Document_GetUndoLimit(self, *args)


    def SetUndoLimit(self, *args):
        """
        SetUndoLimit(Handle_TDocStd_Document self, Standard_Integer const L)

        Set the  limit on  the number of  Undo Delta  stored 0
        will disable  Undo  on the  document A negative  value
        means no limit. Note that by default Undo is disabled.
        Enabling  it will  take effect with  the next  call to
        NewCommand. Of course this limit is the same for Redo

        :type L: int

        """
        return _TDocStd.Handle_TDocStd_Document_SetUndoLimit(self, *args)


    def ClearUndos(self, *args):
        """
        ClearUndos(Handle_TDocStd_Document self)

        Remove all stored Undos and Redos


        """
        return _TDocStd.Handle_TDocStd_Document_ClearUndos(self, *args)


    def ClearRedos(self, *args):
        """
        ClearRedos(Handle_TDocStd_Document self)

        Remove all stored Redos


        """
        return _TDocStd.Handle_TDocStd_Document_ClearRedos(self, *args)


    def GetAvailableUndos(self, *args):
        """
        GetAvailableUndos(Handle_TDocStd_Document self) -> Standard_Integer

        Returns the number of undos stored in this
        document. If this figure is greater than 0, the method Undo
        can be used.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDocStd.Handle_TDocStd_Document_GetAvailableUndos(self, *args)


    def Undo(self, *args):
        """
        Undo(Handle_TDocStd_Document self) -> Standard_Boolean

        Will UNDO  one step, returns  False if no undo was
        done (Undos == 0).
        Otherwise, true is returned and one step in the
        list of undoes is undone.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDocStd.Handle_TDocStd_Document_Undo(self, *args)


    def GetAvailableRedos(self, *args):
        """
        GetAvailableRedos(Handle_TDocStd_Document self) -> Standard_Integer

        Returns the number of redos stored in this
        document. If this figure is greater than 0, the method Redo
        can be used.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDocStd.Handle_TDocStd_Document_GetAvailableRedos(self, *args)


    def Redo(self, *args):
        """
        Redo(Handle_TDocStd_Document self) -> Standard_Boolean

        Will REDO  one step, returns  False if no redo was
        done (Redos == 0).
        Otherwise, true is returned, and one step in the list of redoes is done again.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDocStd.Handle_TDocStd_Document_Redo(self, *args)


    def GetUndos(self, *args):
        """
        :rtype: OCC.wrapper.TDF.TDF_DeltaList

        """
        res = _TDocStd.Handle_TDocStd_Document_GetUndos(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def GetRedos(self, *args):
        """
        :rtype: OCC.wrapper.TDF.TDF_DeltaList

        """
        res = _TDocStd.Handle_TDocStd_Document_GetRedos(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def RemoveFirstUndo(self, *args):
        """
        RemoveFirstUndo(Handle_TDocStd_Document self)

        Removes the first undo in the list of document undos.
        It is used in the application when the undo limit is exceed.


        """
        return _TDocStd.Handle_TDocStd_Document_RemoveFirstUndo(self, *args)


    def InitDeltaCompaction(self, *args):
        """
        InitDeltaCompaction(Handle_TDocStd_Document self) -> Standard_Boolean

        Initializes the procedure of delta compaction
        Returns false if there is no delta to compact
        Marks the last delta as a "from" delta

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDocStd.Handle_TDocStd_Document_InitDeltaCompaction(self, *args)


    def PerformDeltaCompaction(self, *args):
        """
        PerformDeltaCompaction(Handle_TDocStd_Document self) -> Standard_Boolean

        Performs the procedure of delta compaction
        Makes all deltas starting from "from" delta
        till the last one to be one delta.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDocStd.Handle_TDocStd_Document_PerformDeltaCompaction(self, *args)


    def UpdateReferences(self, *args):
        """
        UpdateReferences(Handle_TDocStd_Document self, TCollection_AsciiString aDocEntry)

        Set   modifications on  labels  impacted  by  external
        references to the entry.  The document becomes invalid
        and must be recomputed.

        :type aDocEntry: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _TDocStd.Handle_TDocStd_Document_UpdateReferences(self, *args)


    def Recompute(self, *args):
        """
        Recompute(Handle_TDocStd_Document self)

        Recompute if the document was  not valid and propagate
        the reccorded modification.


        """
        return _TDocStd.Handle_TDocStd_Document_Recompute(self, *args)


    def Update(self, *args):
        """
        Update(Handle_TDocStd_Document self, Handle_CDM_Document aToDocument, Standard_Integer const aReferenceIdentifier, Standard_Address const aModifContext)

        This method Update   will be called
        to signal the end   of the modified references list.
        The    document     should    be  recomputed     and
        UpdateFromDocuments  should be called.  Update should
        returns True in case  of success, false otherwise.  In
        case of Failure, additional information can be given in
        ErrorString.
        Update the document by propagation
        ==================================
        Update   the    document    from   internal   stored
        modifications.   If   you   want  to   undoing  this
        operation, please call NewCommand before.
        to change format (advanced programming)
        ================

        :type aToDocument: OCC.wrapper.CDM.Handle_CDM_Document
        :type aReferenceIdentifier: int
        :type aModifContext: OCC.wrapper.Standard.Standard_Address

        """
        return _TDocStd.Handle_TDocStd_Document_Update(self, *args)


    def StorageFormat(self, *args):
        """
        StorageFormat(Handle_TDocStd_Document self) -> TCollection_ExtendedString

        :rtype: OCC.wrapper.TCollection.TCollection_ExtendedString

        """
        return _TDocStd.Handle_TDocStd_Document_StorageFormat(self, *args)


    def SetEmptyLabelsSavingMode(self, *args):
        """
        SetEmptyLabelsSavingMode(Handle_TDocStd_Document self, Standard_Boolean const isAllowed)

        Sets saving mode for empty labels. If Standard_True, empty labels will be saved.

        :type isAllowed: bool

        """
        return _TDocStd.Handle_TDocStd_Document_SetEmptyLabelsSavingMode(self, *args)


    def EmptyLabelsSavingMode(self, *args):
        """
        EmptyLabelsSavingMode(Handle_TDocStd_Document self) -> Standard_Boolean

        Returns saving mode for empty labels.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDocStd.Handle_TDocStd_Document_EmptyLabelsSavingMode(self, *args)


    def ChangeStorageFormat(self, *args):
        """
        ChangeStorageFormat(Handle_TDocStd_Document self, TCollection_ExtendedString newStorageFormat)

        methods for the nested transaction mode

        :type newStorageFormat: OCC.wrapper.TCollection.TCollection_ExtendedString

        """
        return _TDocStd.Handle_TDocStd_Document_ChangeStorageFormat(self, *args)


    def SetNestedTransactionMode(self, *args):
        """
        SetNestedTransactionMode(Handle_TDocStd_Document self, Standard_Boolean const isAllowed)

        Sets nested transaction mode if isAllowed == Standard_True

        :type isAllowed: bool

        """
        return _TDocStd.Handle_TDocStd_Document_SetNestedTransactionMode(self, *args)


    def IsNestedTransactionMode(self, *args):
        """
        IsNestedTransactionMode(Handle_TDocStd_Document self) -> Standard_Boolean

        Returns Standard_True if mode is set

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDocStd.Handle_TDocStd_Document_IsNestedTransactionMode(self, *args)


    def SetModificationMode(self, *args):
        """
        SetModificationMode(Handle_TDocStd_Document self, Standard_Boolean const theTransactionOnly)

        if theTransactionOnly is True changes is denied outside transactions

        :type theTransactionOnly: bool

        """
        return _TDocStd.Handle_TDocStd_Document_SetModificationMode(self, *args)


    def ModificationMode(self, *args):
        """
        ModificationMode(Handle_TDocStd_Document self) -> Standard_Boolean

        returns True if changes allowed only inside transactions

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDocStd.Handle_TDocStd_Document_ModificationMode(self, *args)


    def BeforeClose(self, *args):
        """
        BeforeClose(Handle_TDocStd_Document self)

        Prepares document for closing


        """
        return _TDocStd.Handle_TDocStd_Document_BeforeClose(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_TDocStd_Document self) -> char const *

        :rtype: const char *

        """
        return _TDocStd.Handle_TDocStd_Document_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TDocStd.Handle_TDocStd_Document_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TDocStd.Handle_TDocStd_Document_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Extensions(self, *args):
        """
        Extensions(Handle_TDocStd_Document self, NCollection_Sequence_TCollection_ExtendedString Extensions)

        by default empties the extensions.

        :type Extensions: OCC.wrapper.TColStd.TColStd_SequenceOfExtendedString

        """
        return _TDocStd.Handle_TDocStd_Document_Extensions(self, *args)


    def GetAlternativeDocument(self, *args):
        """
        GetAlternativeDocument(Handle_TDocStd_Document self, TCollection_ExtendedString aFormat, Handle_CDM_Document anAlternativeDocument) -> Standard_Boolean

        This method can be redefined to extract another document in
        a different format. For example, to extract a Shape
        from an applicative document.

        :type aFormat: OCC.wrapper.TCollection.TCollection_ExtendedString
        :type anAlternativeDocument: OCC.wrapper.CDM.Handle_CDM_Document
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDocStd.Handle_TDocStd_Document_GetAlternativeDocument(self, *args)


    def CreateReference(self, *args):
        """
        CreateReference(Handle_TDocStd_Document self, Handle_CDM_Document anOtherDocument) -> Standard_Integer
        CreateReference(Handle_TDocStd_Document self, Handle_CDM_MetaData aMetaData, Standard_Integer const aReferenceIdentifier, Handle_CDM_Application anApplication, Standard_Integer const aToDocumentVersion, Standard_Boolean const UseStorageConfiguration)
        CreateReference(Handle_TDocStd_Document self, Handle_CDM_MetaData aMetaData, Handle_CDM_Application anApplication, Standard_Integer const aDocumentVersion, Standard_Boolean const UseStorageConfiguration) -> Standard_Integer

        :type aMetaData: OCC.wrapper.CDM.Handle_CDM_MetaData
        :type anApplication: OCC.wrapper.CDM.Handle_CDM_Application
        :type aDocumentVersion: int
        :type UseStorageConfiguration: bool
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDocStd.Handle_TDocStd_Document_CreateReference(self, *args)


    def RemoveReference(self, *args):
        """
        RemoveReference(Handle_TDocStd_Document self, Standard_Integer const aReferenceIdentifier)

        Removes the reference between the From Document and the
        To Document identified by a reference identifier.

        :type aReferenceIdentifier: int

        """
        return _TDocStd.Handle_TDocStd_Document_RemoveReference(self, *args)


    def RemoveAllReferences(self, *args):
        """
        RemoveAllReferences(Handle_TDocStd_Document self)

        Removes all references having this document for From Document.


        """
        return _TDocStd.Handle_TDocStd_Document_RemoveAllReferences(self, *args)


    def Document(self, *args):
        """
        Document(Handle_TDocStd_Document self, Standard_Integer const aReferenceIdentifier) -> Handle_CDM_Document

        Returns the To Document  of the reference identified by
        aReferenceIdentifier. If the ToDocument is stored and
        has not yet been retrieved, this method will retrieve it.

        :type aReferenceIdentifier: int
        :rtype: OCC.wrapper.CDM.Handle_CDM_Document

        """
        return _TDocStd.Handle_TDocStd_Document_Document(self, *args)


    def IsInSession(self, *args):
        """
        IsInSession(Handle_TDocStd_Document self, Standard_Integer const aReferenceIdentifier) -> Standard_Boolean

        returns True if   the  To Document of the  reference
        identified by aReferenceIdentifier is in session,  False
        if it corresponds to a not yet retrieved document.

        :type aReferenceIdentifier: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDocStd.Handle_TDocStd_Document_IsInSession(self, *args)


    def IsStored(self, *args):
        """
        IsStored(Handle_TDocStd_Document self, Standard_Integer const aReferenceIdentifier) -> Standard_Boolean
        IsStored(Handle_TDocStd_Document self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDocStd.Handle_TDocStd_Document_IsStored(self, *args)


    def Name(self, *args):
        """
        Name(Handle_TDocStd_Document self, Standard_Integer const aReferenceIdentifier) -> TCollection_ExtendedString

        returns the name of the metadata of the To Document of
        the reference identified by aReferenceIdentifier.

        :type aReferenceIdentifier: int
        :rtype: OCC.wrapper.TCollection.TCollection_ExtendedString

        """
        return _TDocStd.Handle_TDocStd_Document_Name(self, *args)


    def UpdateFromDocuments(self, *args):
        """
        UpdateFromDocuments(Handle_TDocStd_Document self, Standard_Address const aModifContext)

        call  virtual  method   Update  on  all   referencing
        documents.   This method keeps  the list  of the --
        documents  to process.It may  be the starting of an
        update -- cycle. If  not,  the reentrant calls made by
        Update  method (without argument)  will append the
        referencing documents to the list and call the Update method
        (with arguments). Only the first call to UpdateFromDocuments
        generate call to Update().

        :type aModifContext: OCC.wrapper.Standard.Standard_Address

        """
        return _TDocStd.Handle_TDocStd_Document_UpdateFromDocuments(self, *args)


    def ToReferencesNumber(self, *args):
        """
        ToReferencesNumber(Handle_TDocStd_Document self) -> Standard_Integer

        returns the number of references having this document as
        From Document.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDocStd.Handle_TDocStd_Document_ToReferencesNumber(self, *args)


    def FromReferencesNumber(self, *args):
        """
        FromReferencesNumber(Handle_TDocStd_Document self) -> Standard_Integer

        returns the number of references having this document as
        To Document.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDocStd.Handle_TDocStd_Document_FromReferencesNumber(self, *args)


    def ShallowReferences(self, *args):
        """
        ShallowReferences(Handle_TDocStd_Document self, Handle_CDM_Document aDocument) -> Standard_Boolean

        returns True is this document references aDocument;

        :type aDocument: OCC.wrapper.CDM.Handle_CDM_Document
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDocStd.Handle_TDocStd_Document_ShallowReferences(self, *args)


    def DeepReferences(self, *args):
        """
        DeepReferences(Handle_TDocStd_Document self, Handle_CDM_Document aDocument) -> Standard_Boolean

        returns True is this document references aDocument;

        :type aDocument: OCC.wrapper.CDM.Handle_CDM_Document
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDocStd.Handle_TDocStd_Document_DeepReferences(self, *args)


    def CopyReference(self, *args):
        """
        CopyReference(Handle_TDocStd_Document self, Handle_CDM_Document aFromDocument, Standard_Integer const aReferenceIdentifier) -> Standard_Integer

        Copies a  reference  to  this document.   This  method
        avoid retrieval of referenced document.  The arguments
        are  the  original  document  and a  valid  reference
        identifier Returns the  local identifier.

        :type aFromDocument: OCC.wrapper.CDM.Handle_CDM_Document
        :type aReferenceIdentifier: int
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDocStd.Handle_TDocStd_Document_CopyReference(self, *args)


    def IsReadOnly(self, *args):
        """
        IsReadOnly(Handle_TDocStd_Document self) -> Standard_Boolean
        IsReadOnly(Handle_TDocStd_Document self, Standard_Integer const aReferenceIdentifier) -> Standard_Boolean

        indicates that the referenced document cannot be modified,

        :type aReferenceIdentifier: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDocStd.Handle_TDocStd_Document_IsReadOnly(self, *args)


    def SetIsReadOnly(self, *args):
        """SetIsReadOnly(Handle_TDocStd_Document self)"""
        return _TDocStd.Handle_TDocStd_Document_SetIsReadOnly(self, *args)


    def UnsetIsReadOnly(self, *args):
        """UnsetIsReadOnly(Handle_TDocStd_Document self)"""
        return _TDocStd.Handle_TDocStd_Document_UnsetIsReadOnly(self, *args)


    def Modify(self, *args):
        """
        Modify(Handle_TDocStd_Document self)

        Indicates that this document has been modified.
        This method increments the modification counter.


        """
        return _TDocStd.Handle_TDocStd_Document_Modify(self, *args)


    def Modifications(self, *args):
        """
        Modifications(Handle_TDocStd_Document self) -> Standard_Integer

        returns the current modification counter.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDocStd.Handle_TDocStd_Document_Modifications(self, *args)


    def UnModify(self, *args):
        """UnModify(Handle_TDocStd_Document self)"""
        return _TDocStd.Handle_TDocStd_Document_UnModify(self, *args)


    def IsUpToDate(self, *args):
        """
        IsUpToDate(Handle_TDocStd_Document self, Standard_Integer const aReferenceIdentifier) -> Standard_Boolean

        returns true if the modification counter found in the given
        reference is equal to the actual modification counter of
        the To Document. This method is able to deal with a reference
        to a not retrieved document.

        :type aReferenceIdentifier: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDocStd.Handle_TDocStd_Document_IsUpToDate(self, *args)


    def SetIsUpToDate(self, *args):
        """
        SetIsUpToDate(Handle_TDocStd_Document self, Standard_Integer const aReferenceIdentifier)

        Resets the modification counter in the given reference
        to the actual modification counter of its To Document.
        This method should be called after the application has updated
        this document.

        :type aReferenceIdentifier: int

        """
        return _TDocStd.Handle_TDocStd_Document_SetIsUpToDate(self, *args)


    def SetComment(self, *args):
        """
        SetComment(Handle_TDocStd_Document self, TCollection_ExtendedString aComment)

        associates a comment with this document.

        :type aComment: OCC.wrapper.TCollection.TCollection_ExtendedString

        """
        return _TDocStd.Handle_TDocStd_Document_SetComment(self, *args)


    def AddComment(self, *args):
        """
        AddComment(Handle_TDocStd_Document self, TCollection_ExtendedString aComment)

        appends a comment into comments of this document.

        :type aComment: OCC.wrapper.TCollection.TCollection_ExtendedString

        """
        return _TDocStd.Handle_TDocStd_Document_AddComment(self, *args)


    def SetComments(self, *args):
        """
        SetComments(Handle_TDocStd_Document self, NCollection_Sequence_TCollection_ExtendedString aComments)

        associates a comments with this document.

        :type aComments: OCC.wrapper.TColStd.TColStd_SequenceOfExtendedString

        """
        return _TDocStd.Handle_TDocStd_Document_SetComments(self, *args)


    def Comments(self, *args):
        """
        Comments(Handle_TDocStd_Document self, NCollection_Sequence_TCollection_ExtendedString aComments)

        returns the associated comments through <aComments>.
        Returns empty sequence if no comments are associated.

        :type aComments: OCC.wrapper.TColStd.TColStd_SequenceOfExtendedString

        """
        return _TDocStd.Handle_TDocStd_Document_Comments(self, *args)


    def Comment(self, *args):
        """
        Comment(Handle_TDocStd_Document self) -> Standard_ExtString

        returns the first of associated comments. By defaut
        the comment is an empty string.

        :rtype: OCC.wrapper.Standard.Standard_ExtString

        """
        return _TDocStd.Handle_TDocStd_Document_Comment(self, *args)


    def Presentation(self, *args):
        """
        Presentation(Handle_TDocStd_Document self) -> Standard_ExtString

        Returns an alphanumeric string identifying this document
        in a unique manner in the current process. The presentation
        may change when the document is stored.
        Tries to get the 'FileFormat`.Presentation resource
        This item is used to give a default presentation
        to the document.

        :rtype: OCC.wrapper.Standard.Standard_ExtString

        """
        return _TDocStd.Handle_TDocStd_Document_Presentation(self, *args)


    def FindFromPresentation(self, *args):
        """
        FindFromPresentation(Handle_TDocStd_Document self, TCollection_ExtendedString aPresentation) -> Handle_CDM_Document

        returns the document having the given alphanumeric presentation.

        :type aPresentation: OCC.wrapper.TCollection.TCollection_ExtendedString
        :rtype: OCC.wrapper.CDM.Handle_CDM_Document

        """
        return _TDocStd.Handle_TDocStd_Document_FindFromPresentation(self, *args)


    def FindPresentation(self, *args):
        """
        FindPresentation(Handle_TDocStd_Document self, TCollection_ExtendedString aPresentation) -> Standard_Boolean

        indicates whether a document having the given presentation
        does exist.

        :type aPresentation: OCC.wrapper.TCollection.TCollection_ExtendedString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDocStd.Handle_TDocStd_Document_FindPresentation(self, *args)


    def StorageVersion(self, *args):
        """
        StorageVersion(Handle_TDocStd_Document self) -> Standard_Integer

        returns  the value of  the modification counter at the
        time of storage. By default returns 0.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDocStd.Handle_TDocStd_Document_StorageVersion(self, *args)


    def SetMetaData(self, *args):
        """
        SetMetaData(Handle_TDocStd_Document self, Handle_CDM_MetaData aMetaData)

        associates database  information to  a document which
        has been stored.  The name of the  document is now the
        name which has beenused to store the data.

        :type aMetaData: OCC.wrapper.CDM.Handle_CDM_MetaData

        """
        return _TDocStd.Handle_TDocStd_Document_SetMetaData(self, *args)


    def UnsetIsStored(self, *args):
        """UnsetIsStored(Handle_TDocStd_Document self)"""
        return _TDocStd.Handle_TDocStd_Document_UnsetIsStored(self, *args)


    def MetaData(self, *args):
        """
        MetaData(Handle_TDocStd_Document self) -> Handle_CDM_MetaData

        :rtype: OCC.wrapper.CDM.Handle_CDM_MetaData

        """
        return _TDocStd.Handle_TDocStd_Document_MetaData(self, *args)


    def Folder(self, *args):
        """
        Folder(Handle_TDocStd_Document self) -> TCollection_ExtendedString

        :rtype: OCC.wrapper.TCollection.TCollection_ExtendedString

        """
        return _TDocStd.Handle_TDocStd_Document_Folder(self, *args)


    def SetRequestedFolder(self, *args):
        """
        SetRequestedFolder(Handle_TDocStd_Document self, TCollection_ExtendedString aFolder)

        defines the folder in which the object should be stored.

        :type aFolder: OCC.wrapper.TCollection.TCollection_ExtendedString

        """
        return _TDocStd.Handle_TDocStd_Document_SetRequestedFolder(self, *args)


    def RequestedFolder(self, *args):
        """
        RequestedFolder(Handle_TDocStd_Document self) -> TCollection_ExtendedString

        :rtype: OCC.wrapper.TCollection.TCollection_ExtendedString

        """
        return _TDocStd.Handle_TDocStd_Document_RequestedFolder(self, *args)


    def HasRequestedFolder(self, *args):
        """
        HasRequestedFolder(Handle_TDocStd_Document self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDocStd.Handle_TDocStd_Document_HasRequestedFolder(self, *args)


    def SetRequestedName(self, *args):
        """
        SetRequestedName(Handle_TDocStd_Document self, TCollection_ExtendedString aName)

        defines the name under which the object should be stored.

        :type aName: OCC.wrapper.TCollection.TCollection_ExtendedString

        """
        return _TDocStd.Handle_TDocStd_Document_SetRequestedName(self, *args)


    def RequestedName(self, *args):
        """
        RequestedName(Handle_TDocStd_Document self) -> TCollection_ExtendedString

        determines  under  which the document  is  going to be
        store.  By default the name of the document wil be --
        used.  If the document has  no name  its presentation
        will be used.

        :rtype: OCC.wrapper.TCollection.TCollection_ExtendedString

        """
        return _TDocStd.Handle_TDocStd_Document_RequestedName(self, *args)


    def SetRequestedPreviousVersion(self, *args):
        """
        SetRequestedPreviousVersion(Handle_TDocStd_Document self, TCollection_ExtendedString aPreviousVersion)

        :type aPreviousVersion: OCC.wrapper.TCollection.TCollection_ExtendedString

        """
        return _TDocStd.Handle_TDocStd_Document_SetRequestedPreviousVersion(self, *args)


    def UnsetRequestedPreviousVersion(self, *args):
        """UnsetRequestedPreviousVersion(Handle_TDocStd_Document self)"""
        return _TDocStd.Handle_TDocStd_Document_UnsetRequestedPreviousVersion(self, *args)


    def HasRequestedPreviousVersion(self, *args):
        """
        HasRequestedPreviousVersion(Handle_TDocStd_Document self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDocStd.Handle_TDocStd_Document_HasRequestedPreviousVersion(self, *args)


    def RequestedPreviousVersion(self, *args):
        """
        RequestedPreviousVersion(Handle_TDocStd_Document self) -> TCollection_ExtendedString

        :rtype: OCC.wrapper.TCollection.TCollection_ExtendedString

        """
        return _TDocStd.Handle_TDocStd_Document_RequestedPreviousVersion(self, *args)


    def SetRequestedComment(self, *args):
        """
        SetRequestedComment(Handle_TDocStd_Document self, TCollection_ExtendedString aComment)

        defines the Comment with  which the object should be stored.

        :type aComment: OCC.wrapper.TCollection.TCollection_ExtendedString

        """
        return _TDocStd.Handle_TDocStd_Document_SetRequestedComment(self, *args)


    def RequestedComment(self, *args):
        """
        RequestedComment(Handle_TDocStd_Document self) -> TCollection_ExtendedString

        :rtype: OCC.wrapper.TCollection.TCollection_ExtendedString

        """
        return _TDocStd.Handle_TDocStd_Document_RequestedComment(self, *args)


    def LoadResources(self, *args):
        """
        LoadResources(Handle_TDocStd_Document self)

        read (or rereads) the following resource.


        """
        return _TDocStd.Handle_TDocStd_Document_LoadResources(self, *args)


    def FindFileExtension(self, *args):
        """
        FindFileExtension(Handle_TDocStd_Document self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDocStd.Handle_TDocStd_Document_FindFileExtension(self, *args)


    def FileExtension(self, *args):
        """
        FileExtension(Handle_TDocStd_Document self) -> TCollection_ExtendedString

        gets the Desktop.Domain.Application.`FileFormat`.FileExtension resource.

        :rtype: OCC.wrapper.TCollection.TCollection_ExtendedString

        """
        return _TDocStd.Handle_TDocStd_Document_FileExtension(self, *args)


    def FindDescription(self, *args):
        """
        FindDescription(Handle_TDocStd_Document self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDocStd.Handle_TDocStd_Document_FindDescription(self, *args)


    def Description(self, *args):
        """
        Description(Handle_TDocStd_Document self) -> TCollection_ExtendedString

        gets the `FileFormat`.Description resource.

        :rtype: OCC.wrapper.TCollection.TCollection_ExtendedString

        """
        return _TDocStd.Handle_TDocStd_Document_Description(self, *args)


    def IsModified(self, *args):
        """
        IsModified(Handle_TDocStd_Document self) -> Standard_Boolean

        returns  true  if the   version is greater  than   the
        storage version

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDocStd.Handle_TDocStd_Document_IsModified(self, *args)


    def Print(self, *args):
        """
        Print(Handle_TDocStd_Document self, Standard_OStream & anOStream) -> Standard_OStream &

        :type anOStream: OCC.wrapper.Standard.Standard_OStream
        :rtype: OCC.wrapper.Standard.Standard_OStream

        """
        return _TDocStd.Handle_TDocStd_Document_Print(self, *args)


    def IsOpened(self, *args):
        """
        IsOpened(Handle_TDocStd_Document self) -> Standard_Boolean
        IsOpened(Handle_TDocStd_Document self, Standard_Integer const aReferenceIdentifier) -> Standard_Boolean

        returns true if  the   document corresponding to  the
        given   reference has    been retrieved  and  opened.
        Otherwise returns false. This method does not retrieve
        the referenced document

        :type aReferenceIdentifier: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDocStd.Handle_TDocStd_Document_IsOpened(self, *args)


    def Open(self, *args):
        """
        Open(Handle_TDocStd_Document self, Handle_CDM_Application anApplication)

        :type anApplication: OCC.wrapper.CDM.Handle_CDM_Application

        """
        return _TDocStd.Handle_TDocStd_Document_Open(self, *args)


    def CanClose(self, *args):
        """
        CanClose(Handle_TDocStd_Document self) -> CDM_CanCloseStatus

        :rtype: OCC.wrapper.CDM.CDM_CanCloseStatus

        """
        return _TDocStd.Handle_TDocStd_Document_CanClose(self, *args)


    def Close(self, *args):
        """Close(Handle_TDocStd_Document self)"""
        return _TDocStd.Handle_TDocStd_Document_Close(self, *args)


    def Application(self, *args):
        """
        :rtype: OCC.wrapper.CDM.Handle_CDM_Application

        """
        res = _TDocStd.Handle_TDocStd_Document_Application(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def CanCloseReference(self, *args):
        """
        CanCloseReference(Handle_TDocStd_Document self, Handle_CDM_Document aDocument, Standard_Integer const aReferenceIdentifier) -> Standard_Boolean

        A  referenced  document  may  indicate   through  this
        virtual  method that it does  not allow the closing of
        aDocument  which  it references through  the reference
        aReferenceIdentifier. By default returns Standard_True;;

        :type aDocument: OCC.wrapper.CDM.Handle_CDM_Document
        :type aReferenceIdentifier: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDocStd.Handle_TDocStd_Document_CanCloseReference(self, *args)


    def CloseReference(self, *args):
        """
        CloseReference(Handle_TDocStd_Document self, Handle_CDM_Document aDocument, Standard_Integer const aReferenceIdentifier)

        A referenced document may update its internal
        data structure when {aDocument} which it references
        through the reference {aReferenceIdentifier} is being closed.
        By default this method does nothing.

        :type aDocument: OCC.wrapper.CDM.Handle_CDM_Document
        :type aReferenceIdentifier: int

        """
        return _TDocStd.Handle_TDocStd_Document_CloseReference(self, *args)


    def ReferenceCounter(self, *args):
        """
        ReferenceCounter(Handle_TDocStd_Document self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDocStd.Handle_TDocStd_Document_ReferenceCounter(self, *args)


    def Reference(self, *args):
        """
        Reference(Handle_TDocStd_Document self, Standard_Integer const aReferenceIdentifier) -> Handle_CDM_Reference

        :type aReferenceIdentifier: int
        :rtype: OCC.wrapper.CDM.Handle_CDM_Reference

        """
        return _TDocStd.Handle_TDocStd_Document_Reference(self, *args)


    def SetModifications(self, *args):
        """
        SetModifications(Handle_TDocStd_Document self, Standard_Integer const Modifications)

        :type Modifications: int

        """
        return _TDocStd.Handle_TDocStd_Document_SetModifications(self, *args)


    def SetReferenceCounter(self, *args):
        """
        SetReferenceCounter(Handle_TDocStd_Document self, Standard_Integer const aReferenceCounter)

        :type aReferenceCounter: int

        """
        return _TDocStd.Handle_TDocStd_Document_SetReferenceCounter(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_TDocStd_Document self)

        Memory deallocator for transient classes


        """
        return _TDocStd.Handle_TDocStd_Document_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_TDocStd_Document self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_TDocStd_Document self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDocStd.Handle_TDocStd_Document_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_TDocStd_Document self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_TDocStd_Document self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDocStd.Handle_TDocStd_Document_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_TDocStd_Document self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _TDocStd.Handle_TDocStd_Document_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_TDocStd_Document self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDocStd.Handle_TDocStd_Document_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_TDocStd_Document self)

        Increments the reference counter of this object


        """
        return _TDocStd.Handle_TDocStd_Document_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_TDocStd_Document self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDocStd.Handle_TDocStd_Document_DecrementRefCounter(self, *args)

Handle_TDocStd_Document_swigregister = _TDocStd.Handle_TDocStd_Document_swigregister
Handle_TDocStd_Document_swigregister(Handle_TDocStd_Document)

def Handle_TDocStd_Document_DownCast(thing):
    return _TDocStd.Handle_TDocStd_Document_DownCast(thing)
Handle_TDocStd_Document_DownCast = _TDocStd.Handle_TDocStd_Document_DownCast

class Handle_TDocStd_CompoundDelta(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_TDocStd_CompoundDelta self)

        Nullify the handle


        """
        return _TDocStd.Handle_TDocStd_CompoundDelta_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_TDocStd_CompoundDelta self) -> bool

        Check for being null

        :rtype: bool

        """
        return _TDocStd.Handle_TDocStd_CompoundDelta_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_TDocStd_CompoundDelta self, TDocStd_CompoundDelta thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _TDocStd.Handle_TDocStd_CompoundDelta_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_TDocStd_CompoundDelta self, Handle_TDocStd_CompoundDelta theHandle) -> Handle_TDocStd_CompoundDelta
        assign(Handle_TDocStd_CompoundDelta self, TDocStd_CompoundDelta thePtr) -> Handle_TDocStd_CompoundDelta
        assign(Handle_TDocStd_CompoundDelta self, Handle_TDocStd_CompoundDelta theHandle) -> Handle_TDocStd_CompoundDelta

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _TDocStd.Handle_TDocStd_CompoundDelta_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_TDocStd_CompoundDelta self) -> TDocStd_CompoundDelta

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _TDocStd.Handle_TDocStd_CompoundDelta_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_TDocStd_CompoundDelta self) -> TDocStd_CompoundDelta

        Member access operator (note non-const)

        :rtype: T *

        """
        return _TDocStd.Handle_TDocStd_CompoundDelta___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_TDocStd_CompoundDelta self) -> TDocStd_CompoundDelta

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _TDocStd.Handle_TDocStd_CompoundDelta___ref__(self, *args)


    def __hash__(self):
        return _TDocStd.Handle_TDocStd_CompoundDelta___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _TDocStd.Handle_TDocStd_CompoundDelta___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _TDocStd.new_Handle_TDocStd_CompoundDelta(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_TDocStd.Handle_TDocStd_CompoundDelta_DownCast)
    __swig_destroy__ = _TDocStd.delete_Handle_TDocStd_CompoundDelta

    def get_type_name(self, *args):
        """
        get_type_name(Handle_TDocStd_CompoundDelta self) -> char const *

        :rtype: const char *

        """
        return _TDocStd.Handle_TDocStd_CompoundDelta_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TDocStd.Handle_TDocStd_CompoundDelta_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TDocStd.Handle_TDocStd_CompoundDelta_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def IsEmpty(self, *args):
        """
        IsEmpty(Handle_TDocStd_CompoundDelta self) -> Standard_Boolean

        Returns true if there is nothing to undo.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDocStd.Handle_TDocStd_CompoundDelta_IsEmpty(self, *args)


    def IsApplicable(self, *args):
        """
        IsApplicable(Handle_TDocStd_CompoundDelta self, Standard_Integer const aCurrentTime) -> Standard_Boolean

        Returns true if the Undo action of <me> is
        applicable at <aCurrentTime>.

        :type aCurrentTime: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDocStd.Handle_TDocStd_CompoundDelta_IsApplicable(self, *args)


    def BeginTime(self, *args):
        """
        BeginTime(Handle_TDocStd_CompoundDelta self) -> Standard_Integer

        Returns the field <myBeginTime>.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDocStd.Handle_TDocStd_CompoundDelta_BeginTime(self, *args)


    def EndTime(self, *args):
        """
        EndTime(Handle_TDocStd_CompoundDelta self) -> Standard_Integer

        Returns the field <myEndTime>.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDocStd.Handle_TDocStd_CompoundDelta_EndTime(self, *args)


    def Labels(self, *args):
        """
        Labels(Handle_TDocStd_CompoundDelta self, NCollection_List_TDF_Label aLabelList)

        Adds in <aLabelList> the labels of the attribute deltas.
        Caution: <aLabelList> is not cleared before use.

        :type aLabelList: OCC.wrapper.TDF.TDF_LabelList

        """
        return _TDocStd.Handle_TDocStd_CompoundDelta_Labels(self, *args)


    def AttributeDeltas(self, *args):
        """
        Returns the field <myAttDeltaList>.

        :rtype: OCC.wrapper.TDF.TDF_AttributeDeltaList

        """
        res = _TDocStd.Handle_TDocStd_CompoundDelta_AttributeDeltas(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Name(self, *args):
        """
        Name(Handle_TDocStd_CompoundDelta self) -> TCollection_ExtendedString

        Returns a name associated with this delta.

        :rtype: OCC.wrapper.TCollection.TCollection_ExtendedString

        """
        return _TDocStd.Handle_TDocStd_CompoundDelta_Name(self, *args)


    def SetName(self, *args):
        """
        SetName(Handle_TDocStd_CompoundDelta self, TCollection_ExtendedString theName)

        Associates a name <theName> with this delta

        :type theName: OCC.wrapper.TCollection.TCollection_ExtendedString

        """
        return _TDocStd.Handle_TDocStd_CompoundDelta_SetName(self, *args)


    def Dump(self, *args):
        """
        Dump(Handle_TDocStd_CompoundDelta self, Standard_OStream & OS)

        :type OS: OCC.wrapper.Standard.Standard_OStream

        """
        return _TDocStd.Handle_TDocStd_CompoundDelta_Dump(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_TDocStd_CompoundDelta self)

        Memory deallocator for transient classes


        """
        return _TDocStd.Handle_TDocStd_CompoundDelta_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_TDocStd_CompoundDelta self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_TDocStd_CompoundDelta self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDocStd.Handle_TDocStd_CompoundDelta_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_TDocStd_CompoundDelta self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_TDocStd_CompoundDelta self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDocStd.Handle_TDocStd_CompoundDelta_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_TDocStd_CompoundDelta self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _TDocStd.Handle_TDocStd_CompoundDelta_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_TDocStd_CompoundDelta self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDocStd.Handle_TDocStd_CompoundDelta_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_TDocStd_CompoundDelta self)

        Increments the reference counter of this object


        """
        return _TDocStd.Handle_TDocStd_CompoundDelta_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_TDocStd_CompoundDelta self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDocStd.Handle_TDocStd_CompoundDelta_DecrementRefCounter(self, *args)

Handle_TDocStd_CompoundDelta_swigregister = _TDocStd.Handle_TDocStd_CompoundDelta_swigregister
Handle_TDocStd_CompoundDelta_swigregister(Handle_TDocStd_CompoundDelta)

def Handle_TDocStd_CompoundDelta_DownCast(thing):
    return _TDocStd.Handle_TDocStd_CompoundDelta_DownCast(thing)
Handle_TDocStd_CompoundDelta_DownCast = _TDocStd.Handle_TDocStd_CompoundDelta_DownCast

class Handle_TDocStd_Application(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_TDocStd_Application self)

        Nullify the handle


        """
        return _TDocStd.Handle_TDocStd_Application_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_TDocStd_Application self) -> bool

        Check for being null

        :rtype: bool

        """
        return _TDocStd.Handle_TDocStd_Application_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_TDocStd_Application self, TDocStd_Application thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _TDocStd.Handle_TDocStd_Application_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_TDocStd_Application self, Handle_TDocStd_Application theHandle) -> Handle_TDocStd_Application
        assign(Handle_TDocStd_Application self, TDocStd_Application thePtr) -> Handle_TDocStd_Application
        assign(Handle_TDocStd_Application self, Handle_TDocStd_Application theHandle) -> Handle_TDocStd_Application

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _TDocStd.Handle_TDocStd_Application_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_TDocStd_Application self) -> TDocStd_Application

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _TDocStd.Handle_TDocStd_Application_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_TDocStd_Application self) -> TDocStd_Application

        Member access operator (note non-const)

        :rtype: T *

        """
        return _TDocStd.Handle_TDocStd_Application___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_TDocStd_Application self) -> TDocStd_Application

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _TDocStd.Handle_TDocStd_Application___ref__(self, *args)


    def __hash__(self):
        return _TDocStd.Handle_TDocStd_Application___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _TDocStd.Handle_TDocStd_Application___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _TDocStd.new_Handle_TDocStd_Application(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_TDocStd.Handle_TDocStd_Application_DownCast)
    __swig_destroy__ = _TDocStd.delete_Handle_TDocStd_Application

    def IsDriverLoaded(self, *args):
        """
        IsDriverLoaded(Handle_TDocStd_Application self) -> Standard_Boolean

        Check if meta data driver was successfully loaded
        by the application constructor

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDocStd.Handle_TDocStd_Application_IsDriverLoaded(self, *args)


    def MessageDriver(self, *args):
        """
        MessageDriver(Handle_TDocStd_Application self) -> Handle_Message_Messenger

        Redefines message driver, by default outputs to cout.

        :rtype: OCC.wrapper.Message.Handle_Message_Messenger

        """
        return _TDocStd.Handle_TDocStd_Application_MessageDriver(self, *args)


    def Resources(self, *args):
        """
        Resources(Handle_TDocStd_Application self) -> Handle_Resource_Manager

        Returns resource manager defining supported persistent formats.

        Default implementation loads resource file with name ResourcesName(),
        unless field myResources is already initialized (either by
        previous call or in any other way).

        The resource manager should define:

        * Format name for each file extension supported:
        - [Extension].FileFormat: [Format]

        * For each format supported (as returned by Formats()),
        its extension, description string, and (when applicable)
        GUIDs of storage and retrieval plugins:
        - [Format].Description: [Description]
        - [Format].FileExtension: [Extension]
        - [Format].RetrievalPlugin: [GUID] (optional)
        - [Format].StoragePlugin: [GUID] (optional)

        :rtype: OCC.wrapper.Resource.Handle_Resource_Manager

        """
        return _TDocStd.Handle_TDocStd_Application_Resources(self, *args)


    def ResourcesName(self, *args):
        """
        ResourcesName(Handle_TDocStd_Application self) -> Standard_CString

        Returns the name of the file containing the
        resources of this application, for support of legacy
        method of loading formats data from resource files.

        Method DefineFormat() can be used to define all necessary
        parameters explicitly without actually using resource files.

        In a resource file, the application associates the 
        schema name of the document with the storage and
        retrieval plug-ins that are to be loaded for each
        document. On retrieval, the application reads the
        schema name in the heading of the CSF file and
        loads the plug-in indicated in the resource file.
        This plug-in instantiates the actual driver for
        transient-persistent conversion.
        Your application can bring this process into play
        by defining a class which inherits
        CDF_Application and redefines the function
        which returns the appropriate resources file. At
        this point, the function Retrieve and the class
        CDF_Store can be called. This allows you to
        deal with storage and retrieval of - as well as
        copying and pasting - documents.
        To implement a class like this, several virtual
        functions should be redefined. In particular, you
        must redefine the abstract function Resources
        inherited from the superclass CDM_Application.

        Default implementation returns empty string.

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _TDocStd.Handle_TDocStd_Application_ResourcesName(self, *args)


    def DefineFormat(self, *args):
        """
        DefineFormat(Handle_TDocStd_Application self, TCollection_AsciiString theFormat, TCollection_AsciiString theDescription, TCollection_AsciiString theExtension, Handle_PCDM_RetrievalDriver theReader, Handle_PCDM_StorageDriver theWriter)

        Sets up resources and registers read and storage drivers for
        the specified format.

        @param theFormat - unique name for the format, used to identify it.
        @param theDescription - textual description of the format.
        @param theExtension - extension of the files in that format. 
        The same extension can be used by several formats.
        @param theReader - instance of the read driver for the format.
        Null value is allowed (no possibility to read).
        @param theWriter - instance of the write driver for the format.
        Null value is allowed (no possibility to write).

        :type theFormat: OCC.wrapper.TCollection.TCollection_AsciiString
        :type theDescription: OCC.wrapper.TCollection.TCollection_AsciiString
        :type theExtension: OCC.wrapper.TCollection.TCollection_AsciiString
        :type theReader: OCC.wrapper.PCDM.Handle_PCDM_RetrievalDriver
        :type theWriter: OCC.wrapper.PCDM.Handle_PCDM_StorageDriver

        """
        return _TDocStd.Handle_TDocStd_Application_DefineFormat(self, *args)


    def ReadingFormats(self, *args):
        """
        ReadingFormats(Handle_TDocStd_Application self, NCollection_Sequence_TCollection_AsciiString theFormats)

        Returns the sequence of reading formats supported by the application.

        @param theFormats - sequence of reading formats. Output parameter.

        :type theFormats: OCC.wrapper.TColStd.TColStd_SequenceOfAsciiString

        """
        return _TDocStd.Handle_TDocStd_Application_ReadingFormats(self, *args)


    def WritingFormats(self, *args):
        """
        WritingFormats(Handle_TDocStd_Application self, NCollection_Sequence_TCollection_AsciiString theFormats)

        Returns the sequence of writing formats supported by the application.

        @param theFormats - sequence of writing formats. Output parameter.

        :type theFormats: OCC.wrapper.TColStd.TColStd_SequenceOfAsciiString

        """
        return _TDocStd.Handle_TDocStd_Application_WritingFormats(self, *args)


    def NbDocuments(self, *args):
        """
        NbDocuments(Handle_TDocStd_Application self) -> Standard_Integer

        returns the number of documents handled by the current applicative session.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDocStd.Handle_TDocStd_Application_NbDocuments(self, *args)


    def GetDocument(self, *args):
        """
        GetDocument(Handle_TDocStd_Application self, Standard_Integer const index, Handle_TDocStd_Document aDoc)

        Constructs the new document aDoc.
        aDoc is identified by the index index which is
        any integer between 1 and n where n is the
        number of documents returned by NbDocument.
        Example
        Handle(TDocStd_Application)
        anApp;
        if (!CafTest::Find(A)) return 1;
        Handle(TDocStd) aDoc;
        Standard_Integer nbdoc = anApp->NbDocuments();
        for (Standard_Integer i = 1; i <= nbdoc; i++) {
        aApp->GetDocument(i,aDoc);

        :type index: int
        :type aDoc: OCC.wrapper.TDocStd.Handle_TDocStd_Document

        """
        return _TDocStd.Handle_TDocStd_Application_GetDocument(self, *args)


    def NewDocument(self, *args):
        """
        NewDocument(Handle_TDocStd_Application self, TCollection_ExtendedString format, Handle_TDocStd_Document aDoc)

        Constructs the empty new document aDoc.
        This document will have the format format.
        If InitDocument is redefined for a specific
        application, the new document is handled by the
        applicative session.

        :type format: OCC.wrapper.TCollection.TCollection_ExtendedString
        :type aDoc: OCC.wrapper.TDocStd.Handle_TDocStd_Document

        """
        return _TDocStd.Handle_TDocStd_Application_NewDocument(self, *args)


    def InitDocument(self, *args):
        """
        InitDocument(Handle_TDocStd_Application self, Handle_TDocStd_Document aDoc)

        Initialize the document aDoc for the applicative session.
        This virtual function is called by NewDocument
        and is to be redefined for each specific application.
        Modified flag (different of disk version)
        =============
        to open/save a document
        =======================

        :type aDoc: OCC.wrapper.TDocStd.Handle_TDocStd_Document

        """
        return _TDocStd.Handle_TDocStd_Application_InitDocument(self, *args)


    def Close(self, *args):
        """
        Close(Handle_TDocStd_Application self, Handle_TDocStd_Document aDoc)

        Close the given document. the document is not any more
        handled by the applicative session.

        :type aDoc: OCC.wrapper.TDocStd.Handle_TDocStd_Document

        """
        return _TDocStd.Handle_TDocStd_Application_Close(self, *args)


    def IsInSession(self, *args):
        """
        IsInSession(Handle_TDocStd_Application self, TCollection_ExtendedString path) -> Standard_Integer

        Returns an index for the document found in the
        path path in this applicative session.
        If the returned value is 0, the document is not
        present in the applicative session.
        This method can be used for the interactive part
        of an application. For instance, on a call to
        Open, the document to be opened may already
        be in memory. IsInSession checks to see if this
        is the case. Open can be made to depend on
        the value of the index returned: if IsInSession
        returns 0, the document is opened; if it returns
        another value, a message is displayed asking the
        user if he wants to override the version of the
        document in memory.
        Example:
        Standard_Integer insession = A->IsInSession(aDoc);
        if (insession > 0) {
        cout << "document " << insession << " is already in session" << endl;
        return 0;
        }

        :type path: OCC.wrapper.TCollection.TCollection_ExtendedString
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDocStd.Handle_TDocStd_Application_IsInSession(self, *args)


    def Open(self, *args):
        """
        Open(Handle_TDocStd_Application self, TCollection_ExtendedString path, Handle_TDocStd_Document aDoc) -> PCDM_ReaderStatus
        Open(Handle_TDocStd_Application self, Standard_IStream & theIStream, Handle_TDocStd_Document theDoc) -> PCDM_ReaderStatus

        Retrieves aDoc from standard SEEKABLE stream theIStream.
        the stream should support SEEK fuctionality

        :type theIStream: OCC.wrapper.Standard.Standard_IStream
        :type theDoc: OCC.wrapper.TDocStd.Handle_TDocStd_Document
        :rtype: OCC.wrapper.PCDM.PCDM_ReaderStatus

        """
        return _TDocStd.Handle_TDocStd_Application_Open(self, *args)


    def SaveAs(self, *args):
        """
        SaveAs(Handle_TDocStd_Application self, Handle_TDocStd_Document aDoc, TCollection_ExtendedString path) -> PCDM_StoreStatus
        SaveAs(Handle_TDocStd_Application self, Handle_TDocStd_Document theDoc, Standard_OStream & theOStream) -> PCDM_StoreStatus
        SaveAs(Handle_TDocStd_Application self, Handle_TDocStd_Document aDoc, TCollection_ExtendedString path, TCollection_ExtendedString theStatusMessage) -> PCDM_StoreStatus
        SaveAs(Handle_TDocStd_Application self, Handle_TDocStd_Document theDoc, Standard_OStream & theOStream, TCollection_ExtendedString theStatusMessage) -> PCDM_StoreStatus

        Save theDoc TO standard SEEKABLE stream theOStream.
        the stream should support SEEK fuctionality

        :type theDoc: OCC.wrapper.TDocStd.Handle_TDocStd_Document
        :type theOStream: OCC.wrapper.Standard.Standard_OStream
        :type theStatusMessage: OCC.wrapper.TCollection.TCollection_ExtendedString
        :rtype: OCC.wrapper.PCDM.PCDM_StoreStatus

        """
        return _TDocStd.Handle_TDocStd_Application_SaveAs(self, *args)


    def Save(self, *args):
        """
        Save(Handle_TDocStd_Application self, Handle_TDocStd_Document aDoc) -> PCDM_StoreStatus
        Save(Handle_TDocStd_Application self, Handle_TDocStd_Document aDoc, TCollection_ExtendedString theStatusMessage) -> PCDM_StoreStatus

        Save the document overwriting the previous file

        :type aDoc: OCC.wrapper.TDocStd.Handle_TDocStd_Document
        :type theStatusMessage: OCC.wrapper.TCollection.TCollection_ExtendedString
        :rtype: OCC.wrapper.PCDM.PCDM_StoreStatus

        """
        return _TDocStd.Handle_TDocStd_Application_Save(self, *args)


    def OnOpenTransaction(self, *args):
        """
        OnOpenTransaction(Handle_TDocStd_Application self, Handle_TDocStd_Document theDoc)

        Notification that is fired at each OpenTransaction event.

        :type theDoc: OCC.wrapper.TDocStd.Handle_TDocStd_Document

        """
        return _TDocStd.Handle_TDocStd_Application_OnOpenTransaction(self, *args)


    def OnCommitTransaction(self, *args):
        """
        OnCommitTransaction(Handle_TDocStd_Application self, Handle_TDocStd_Document theDoc)

        Notification that is fired at each CommitTransaction event.

        :type theDoc: OCC.wrapper.TDocStd.Handle_TDocStd_Document

        """
        return _TDocStd.Handle_TDocStd_Application_OnCommitTransaction(self, *args)


    def OnAbortTransaction(self, *args):
        """
        OnAbortTransaction(Handle_TDocStd_Application self, Handle_TDocStd_Document theDoc)

        Notification that is fired at each AbortTransaction event.

        :type theDoc: OCC.wrapper.TDocStd.Handle_TDocStd_Document

        """
        return _TDocStd.Handle_TDocStd_Application_OnAbortTransaction(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_TDocStd_Application self) -> char const *

        :rtype: const char *

        """
        return _TDocStd.Handle_TDocStd_Application_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TDocStd.Handle_TDocStd_Application_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TDocStd.Handle_TDocStd_Application_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Load(self, *args):
        """
        Load(Handle_TDocStd_Application self, Standard_GUID aGUID) -> Handle_CDF_Application

        plugs an application.

        Open is used
        - for opening a Document that has been created in an application
        - for opening a Document from the database
        - for opening a Document from a file.
        The Open methods always add the document in the session directory and
        calls the virtual Activate method. The document is considered to be
        opened until Close is used. To be storable, a document must be
        opened by an application since the application resources are
        needed to store it.

        :type aGUID: OCC.wrapper.Standard.Standard_GUID
        :rtype: OCC.wrapper.CDF.Handle_CDF_Application

        """
        return _TDocStd.Handle_TDocStd_Application_Load(self, *args)


    def CanClose(self, *args):
        """
        CanClose(Handle_TDocStd_Application self, Handle_CDM_Document aDocument) -> CDM_CanCloseStatus

        :type aDocument: OCC.wrapper.CDM.Handle_CDM_Document
        :rtype: OCC.wrapper.CDM.CDM_CanCloseStatus

        """
        return _TDocStd.Handle_TDocStd_Application_CanClose(self, *args)


    def Retrieve(self, *args):
        """
        Retrieve(Handle_TDocStd_Application self, TCollection_ExtendedString aFolder, TCollection_ExtendedString aName, Standard_Boolean const UseStorageConfiguration) -> Handle_CDM_Document
        Retrieve(Handle_TDocStd_Application self, TCollection_ExtendedString aFolder, TCollection_ExtendedString aName, TCollection_ExtendedString aVersion, Standard_Boolean const UseStorageConfiguration) -> Handle_CDM_Document

        This method retrieves  a  document from the database.
        If the  Document references other documents which have
        been  updated, the  latest version of  these documents
        will    be   used  if   {UseStorageConfiguration}  is
        Standard_True.  --  If the DBMS is  only  based on the
        OS, this syntax  should not be used.

        If the DBMS is EUCLID/Design Manager, {aFolder}, {aName}
        and  {aVersion} have the form they have in
        EUCLID/Design Manager. For example:

        Handle(CDM_Document) theDocument=myApplication->Retrieve("|user|cascade","box","2");
        A link is kept with the database through an instance
        of CDM_MetaData

        :type aFolder: OCC.wrapper.TCollection.TCollection_ExtendedString
        :type aName: OCC.wrapper.TCollection.TCollection_ExtendedString
        :type aVersion: OCC.wrapper.TCollection.TCollection_ExtendedString
        :type UseStorageConfiguration: bool
        :rtype: OCC.wrapper.CDM.Handle_CDM_Document

        """
        return _TDocStd.Handle_TDocStd_Application_Retrieve(self, *args)


    def CanRetrieve(self, *args):
        """
        CanRetrieve(Handle_TDocStd_Application self, TCollection_ExtendedString aFolder, TCollection_ExtendedString aName) -> PCDM_ReaderStatus
        CanRetrieve(Handle_TDocStd_Application self, TCollection_ExtendedString aFolder, TCollection_ExtendedString aName, TCollection_ExtendedString aVersion) -> PCDM_ReaderStatus

        :type aFolder: OCC.wrapper.TCollection.TCollection_ExtendedString
        :type aName: OCC.wrapper.TCollection.TCollection_ExtendedString
        :type aVersion: OCC.wrapper.TCollection.TCollection_ExtendedString
        :rtype: OCC.wrapper.PCDM.PCDM_ReaderStatus

        """
        return _TDocStd.Handle_TDocStd_Application_CanRetrieve(self, *args)


    def GetRetrieveStatus(self, *args):
        """
        GetRetrieveStatus(Handle_TDocStd_Application self) -> PCDM_ReaderStatus

        Checks  status  after  Retrieve

        :rtype: OCC.wrapper.PCDM.PCDM_ReaderStatus

        """
        return _TDocStd.Handle_TDocStd_Application_GetRetrieveStatus(self, *args)


    def Read(self, *args):
        """
        Read(Handle_TDocStd_Application self, Standard_IStream & theIStream) -> Handle_CDM_Document

        Reads aDoc from standard SEEKABLE stream theIStream,
        the stream should support SEEK fuctionality

        :type theIStream: OCC.wrapper.Standard.Standard_IStream
        :rtype: OCC.wrapper.CDM.Handle_CDM_Document

        """
        return _TDocStd.Handle_TDocStd_Application_Read(self, *args)


    def ReaderFromFormat(self, *args):
        """
        ReaderFromFormat(Handle_TDocStd_Application self, TCollection_ExtendedString aFormat) -> Handle_PCDM_Reader

        Returns instance of read driver for specified format.

        Default implementation uses plugin mechanism to load reader dynamically.
        For this to work, application resources should define GUID of
        the plugin as value of [Format].RetrievalPlugin, and "Plugin"
        resource should define name of plugin library to be loaded as
        value of [GUID].Location. Plugin library should provide
        method PLUGINFACTORY returning instance of the reader for the
        same GUID (see Plugin_Macro.hxx).

        In case if reader is not available, will raise Standard_NoSuchObject
        or other exception if raised by plugin loader.

        :type aFormat: OCC.wrapper.TCollection.TCollection_ExtendedString
        :rtype: OCC.wrapper.PCDM.Handle_PCDM_Reader

        """
        return _TDocStd.Handle_TDocStd_Application_ReaderFromFormat(self, *args)


    def WriterFromFormat(self, *args):
        """
        WriterFromFormat(Handle_TDocStd_Application self, TCollection_ExtendedString aFormat) -> Handle_PCDM_StorageDriver

        Returns instance of storage driver for specified format.

        Default implementation uses plugin mechanism to load driver dynamically.
        For this to work, application resources should define GUID of
        the plugin as value of [Format].StoragePlugin, and "Plugin"
        resource should define name of plugin library to be loaded as
        value of [GUID].Location. Plugin library should provide
        method PLUGINFACTORY returning instance of the reader for the
        same GUID (see Plugin_Macro.hxx).

        In case if driver is not available, will raise Standard_NoSuchObject
        or other exception if raised by plugin loader.

        :type aFormat: OCC.wrapper.TCollection.TCollection_ExtendedString
        :rtype: OCC.wrapper.PCDM.Handle_PCDM_StorageDriver

        """
        return _TDocStd.Handle_TDocStd_Application_WriterFromFormat(self, *args)


    def Format(self, *args):
        """
        Format(Handle_TDocStd_Application self, TCollection_ExtendedString aFileName, TCollection_ExtendedString theFormat) -> Standard_Boolean

        try to  retrieve a Format  directly in the  file or in
        application   resource  by using   extension. returns
        True if found;

        :type aFileName: OCC.wrapper.TCollection.TCollection_ExtendedString
        :type theFormat: OCC.wrapper.TCollection.TCollection_ExtendedString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDocStd.Handle_TDocStd_Application_Format(self, *args)


    def DefaultFolder(self, *args):
        """
        DefaultFolder(Handle_TDocStd_Application self) -> Standard_ExtString

        :rtype: OCC.wrapper.Standard.Standard_ExtString

        """
        return _TDocStd.Handle_TDocStd_Application_DefaultFolder(self, *args)


    def SetDefaultFolder(self, *args):
        """
        SetDefaultFolder(Handle_TDocStd_Application self, Standard_ExtString const aFolder) -> Standard_Boolean

        :type aFolder: OCC.wrapper.Standard.Standard_ExtString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDocStd.Handle_TDocStd_Application_SetDefaultFolder(self, *args)


    def BeginOfUpdate(self, *args):
        """
        BeginOfUpdate(Handle_TDocStd_Application self, Handle_CDM_Document aDocument)

        this method is called before the update of a document.
        By default, writes in MessageDriver().

        :type aDocument: OCC.wrapper.CDM.Handle_CDM_Document

        """
        return _TDocStd.Handle_TDocStd_Application_BeginOfUpdate(self, *args)


    def EndOfUpdate(self, *args):
        """
        EndOfUpdate(Handle_TDocStd_Application self, Handle_CDM_Document aDocument, Standard_Boolean const theStatus, TCollection_ExtendedString ErrorString)

        this method is called affter the update of a document.
        By default, writes in MessageDriver().

        :type aDocument: OCC.wrapper.CDM.Handle_CDM_Document
        :type theStatus: bool
        :type ErrorString: OCC.wrapper.TCollection.TCollection_ExtendedString

        """
        return _TDocStd.Handle_TDocStd_Application_EndOfUpdate(self, *args)


    def Write(self, *args):
        """
        Write(Handle_TDocStd_Application self, Standard_ExtString const aString)

        writes the string in the application MessagerDriver.

        :type aString: OCC.wrapper.Standard.Standard_ExtString

        """
        return _TDocStd.Handle_TDocStd_Application_Write(self, *args)


    def Name(self, *args):
        """
        Name(Handle_TDocStd_Application self) -> TCollection_ExtendedString

        Returns the application name.

        :rtype: OCC.wrapper.TCollection.TCollection_ExtendedString

        """
        return _TDocStd.Handle_TDocStd_Application_Name(self, *args)


    def Version(self, *args):
        """
        Version(Handle_TDocStd_Application self) -> TCollection_AsciiString

        Returns the application version.

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _TDocStd.Handle_TDocStd_Application_Version(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_TDocStd_Application self)

        Memory deallocator for transient classes


        """
        return _TDocStd.Handle_TDocStd_Application_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_TDocStd_Application self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_TDocStd_Application self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDocStd.Handle_TDocStd_Application_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_TDocStd_Application self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_TDocStd_Application self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDocStd.Handle_TDocStd_Application_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_TDocStd_Application self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _TDocStd.Handle_TDocStd_Application_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_TDocStd_Application self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDocStd.Handle_TDocStd_Application_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_TDocStd_Application self)

        Increments the reference counter of this object


        """
        return _TDocStd.Handle_TDocStd_Application_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_TDocStd_Application self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDocStd.Handle_TDocStd_Application_DecrementRefCounter(self, *args)

Handle_TDocStd_Application_swigregister = _TDocStd.Handle_TDocStd_Application_swigregister
Handle_TDocStd_Application_swigregister(Handle_TDocStd_Application)

def Handle_TDocStd_Application_DownCast(thing):
    return _TDocStd.Handle_TDocStd_Application_DownCast(thing)
Handle_TDocStd_Application_DownCast = _TDocStd.Handle_TDocStd_Application_DownCast

class Handle_TDocStd_ApplicationDelta(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_TDocStd_ApplicationDelta self)

        Nullify the handle


        """
        return _TDocStd.Handle_TDocStd_ApplicationDelta_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_TDocStd_ApplicationDelta self) -> bool

        Check for being null

        :rtype: bool

        """
        return _TDocStd.Handle_TDocStd_ApplicationDelta_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_TDocStd_ApplicationDelta self, TDocStd_ApplicationDelta thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _TDocStd.Handle_TDocStd_ApplicationDelta_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_TDocStd_ApplicationDelta self, Handle_TDocStd_ApplicationDelta theHandle) -> Handle_TDocStd_ApplicationDelta
        assign(Handle_TDocStd_ApplicationDelta self, TDocStd_ApplicationDelta thePtr) -> Handle_TDocStd_ApplicationDelta
        assign(Handle_TDocStd_ApplicationDelta self, Handle_TDocStd_ApplicationDelta theHandle) -> Handle_TDocStd_ApplicationDelta

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _TDocStd.Handle_TDocStd_ApplicationDelta_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_TDocStd_ApplicationDelta self) -> TDocStd_ApplicationDelta

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _TDocStd.Handle_TDocStd_ApplicationDelta_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_TDocStd_ApplicationDelta self) -> TDocStd_ApplicationDelta

        Member access operator (note non-const)

        :rtype: T *

        """
        return _TDocStd.Handle_TDocStd_ApplicationDelta___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_TDocStd_ApplicationDelta self) -> TDocStd_ApplicationDelta

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _TDocStd.Handle_TDocStd_ApplicationDelta___ref__(self, *args)


    def __hash__(self):
        return _TDocStd.Handle_TDocStd_ApplicationDelta___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _TDocStd.Handle_TDocStd_ApplicationDelta___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _TDocStd.new_Handle_TDocStd_ApplicationDelta(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_TDocStd.Handle_TDocStd_ApplicationDelta_DownCast)
    __swig_destroy__ = _TDocStd.delete_Handle_TDocStd_ApplicationDelta

    def GetDocuments(self, *args):
        """
        GetDocuments(Handle_TDocStd_ApplicationDelta self) -> NCollection_Sequence_Handle_TDocStd_Document

        :rtype: OCC.wrapper.TDocStd.TDocStd_SequenceOfDocument

        """
        return _TDocStd.Handle_TDocStd_ApplicationDelta_GetDocuments(self, *args)


    def GetName(self, *args):
        """
        :rtype: OCC.wrapper.TCollection.TCollection_ExtendedString

        """
        res = _TDocStd.Handle_TDocStd_ApplicationDelta_GetName(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetName(self, *args):
        """
        SetName(Handle_TDocStd_ApplicationDelta self, TCollection_ExtendedString theName)

        :type theName: OCC.wrapper.TCollection.TCollection_ExtendedString

        """
        return _TDocStd.Handle_TDocStd_ApplicationDelta_SetName(self, *args)


    def Dump(self, *args):
        """
        Dump(Handle_TDocStd_ApplicationDelta self, Standard_OStream & anOS)

        :type anOS: OCC.wrapper.Standard.Standard_OStream

        """
        return _TDocStd.Handle_TDocStd_ApplicationDelta_Dump(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_TDocStd_ApplicationDelta self) -> char const *

        :rtype: const char *

        """
        return _TDocStd.Handle_TDocStd_ApplicationDelta_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TDocStd.Handle_TDocStd_ApplicationDelta_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TDocStd.Handle_TDocStd_ApplicationDelta_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_TDocStd_ApplicationDelta self)

        Memory deallocator for transient classes


        """
        return _TDocStd.Handle_TDocStd_ApplicationDelta_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_TDocStd_ApplicationDelta self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_TDocStd_ApplicationDelta self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDocStd.Handle_TDocStd_ApplicationDelta_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_TDocStd_ApplicationDelta self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_TDocStd_ApplicationDelta self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDocStd.Handle_TDocStd_ApplicationDelta_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_TDocStd_ApplicationDelta self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _TDocStd.Handle_TDocStd_ApplicationDelta_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_TDocStd_ApplicationDelta self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDocStd.Handle_TDocStd_ApplicationDelta_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_TDocStd_ApplicationDelta self)

        Increments the reference counter of this object


        """
        return _TDocStd.Handle_TDocStd_ApplicationDelta_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_TDocStd_ApplicationDelta self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDocStd.Handle_TDocStd_ApplicationDelta_DecrementRefCounter(self, *args)

Handle_TDocStd_ApplicationDelta_swigregister = _TDocStd.Handle_TDocStd_ApplicationDelta_swigregister
Handle_TDocStd_ApplicationDelta_swigregister(Handle_TDocStd_ApplicationDelta)

def Handle_TDocStd_ApplicationDelta_DownCast(thing):
    return _TDocStd.Handle_TDocStd_ApplicationDelta_DownCast(thing)
Handle_TDocStd_ApplicationDelta_DownCast = _TDocStd.Handle_TDocStd_ApplicationDelta_DownCast

class TDocStd_MultiTransactionManager(Standard.Standard_Transient):
    """
    Class for synchronization of transactions within multiple documents.
    Each transaction of this class involvess one transaction in each modified document.

    The documents to be synchronized should be added explicitly to
    the manager; then its interface is uesd to ensure that all transactions
    (Open/Commit, Undo/Redo) are performed synchronously in all managed documents.

    The current implementation does not support nested transactions
    on multitransaction manager level. It only sets the flag enabling
    or disabling nested transactions in all its documents, so that
    a nested transaction can be opened for each particular document
    with TDocStd_Document class interface.

    NOTE: When you invoke CommitTransaction of multi transaction
    manager, all nested transaction of its documents will be closed (commited).
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_TDocStd_MultiTransactionManager
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_TDocStd_MultiTransactionManager(self) 
            return h


    def __init__(self, *args):
        """
        __init__(TDocStd_MultiTransactionManager self) -> TDocStd_MultiTransactionManager

        Constructor


        """
        this = _TDocStd.new_TDocStd_MultiTransactionManager(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def SetUndoLimit(self, *args):
        """
        SetUndoLimit(TDocStd_MultiTransactionManager self, Standard_Integer const theLimit)

        Sets undo limit for the manager and all documents.

        :type theLimit: int

        """
        return _TDocStd.TDocStd_MultiTransactionManager_SetUndoLimit(self, *args)


    def GetUndoLimit(self, *args):
        """
        GetUndoLimit(TDocStd_MultiTransactionManager self) -> Standard_Integer

        Returns undo limit for the manager.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDocStd.TDocStd_MultiTransactionManager_GetUndoLimit(self, *args)


    def Undo(self, *args):
        """
        Undo(TDocStd_MultiTransactionManager self)

        Undoes the current transaction of the manager.
        It calls the Undo () method of the document being
        on top of the manager list of undos (list.First())
        and moves the list item to the top of the list of manager
        redos (list.Prepend(item)).


        """
        return _TDocStd.TDocStd_MultiTransactionManager_Undo(self, *args)


    def Redo(self, *args):
        """
        Redo(TDocStd_MultiTransactionManager self)

        Redoes the current transaction of the application. It calls
        the Redo () method of the document being on top of the
        manager list of redos (list.First()) and moves the list
        item to the top of the list of manager undos (list.Prepend(item)).


        """
        return _TDocStd.TDocStd_MultiTransactionManager_Redo(self, *args)


    def GetAvailableUndos(self, *args):
        """
        Returns available manager undos.

        :rtype: OCC.wrapper.TDocStd.TDocStd_SequenceOfApplicationDelta

        """
        res = _TDocStd.TDocStd_MultiTransactionManager_GetAvailableUndos(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def GetAvailableRedos(self, *args):
        """
        Returns available manager redos.

        :rtype: OCC.wrapper.TDocStd.TDocStd_SequenceOfApplicationDelta

        """
        res = _TDocStd.TDocStd_MultiTransactionManager_GetAvailableRedos(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def OpenCommand(self, *args):
        """
        OpenCommand(TDocStd_MultiTransactionManager self)

        Opens transaction in each document and sets the flag that
        transaction is opened. If there are already opened transactions in the documents,
        these transactions will be aborted before openning new ones.


        """
        return _TDocStd.TDocStd_MultiTransactionManager_OpenCommand(self, *args)


    def AbortCommand(self, *args):
        """
        AbortCommand(TDocStd_MultiTransactionManager self)

        Unsets the flag of started manager transaction and aborts
        transaction in each document.


        """
        return _TDocStd.TDocStd_MultiTransactionManager_AbortCommand(self, *args)


    def CommitCommand(self, *args):
        """
        CommitCommand(TDocStd_MultiTransactionManager self) -> Standard_Boolean
        CommitCommand(TDocStd_MultiTransactionManager self, TCollection_ExtendedString theName) -> Standard_Boolean

        Makes the same steps as the previous function but defines the name for transaction.
        Returns True if new data has been added to myUndos.

        :type theName: OCC.wrapper.TCollection.TCollection_ExtendedString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDocStd.TDocStd_MultiTransactionManager_CommitCommand(self, *args)


    def HasOpenCommand(self, *args):
        """
        HasOpenCommand(TDocStd_MultiTransactionManager self) -> Standard_Boolean

        Returns true if a transaction is opened.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDocStd.TDocStd_MultiTransactionManager_HasOpenCommand(self, *args)


    def RemoveLastUndo(self, *args):
        """
        RemoveLastUndo(TDocStd_MultiTransactionManager self)

        Removes undo information from the list of undos of the manager and
        all documents which have been modified during the transaction.


        """
        return _TDocStd.TDocStd_MultiTransactionManager_RemoveLastUndo(self, *args)


    def DumpTransaction(self, *args):
        """
        DumpTransaction(TDocStd_MultiTransactionManager self, Standard_OStream & theOS)

        Dumps transactions in undos and redos

        :type theOS: OCC.wrapper.Standard.Standard_OStream

        """
        return _TDocStd.TDocStd_MultiTransactionManager_DumpTransaction(self, *args)


    def AddDocument(self, *args):
        """
        AddDocument(TDocStd_MultiTransactionManager self, Handle_TDocStd_Document theDoc)

        Adds the document to the transaction manager and
        checks if it has been already added

        :type theDoc: OCC.wrapper.TDocStd.Handle_TDocStd_Document

        """
        return _TDocStd.TDocStd_MultiTransactionManager_AddDocument(self, *args)


    def RemoveDocument(self, *args):
        """
        RemoveDocument(TDocStd_MultiTransactionManager self, Handle_TDocStd_Document theDoc)

        Removes the document from the transaction manager.

        :type theDoc: OCC.wrapper.TDocStd.Handle_TDocStd_Document

        """
        return _TDocStd.TDocStd_MultiTransactionManager_RemoveDocument(self, *args)


    def Documents(self, *args):
        """
        Returns the added documents to the transaction manager.

        :rtype: OCC.wrapper.TDocStd.TDocStd_SequenceOfDocument

        """
        res = _TDocStd.TDocStd_MultiTransactionManager_Documents(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetNestedTransactionMode(self, *args):
        """
        SetNestedTransactionMode(TDocStd_MultiTransactionManager self, Standard_Boolean const isAllowed)

        Sets nested transaction mode if isAllowed == Standard_True
        NOTE: field myIsNestedTransactionMode exists only for synchronization
        between several documents and has no effect on transactions
        of multitransaction manager.

        :type isAllowed: bool

        """
        return _TDocStd.TDocStd_MultiTransactionManager_SetNestedTransactionMode(self, *args)


    def IsNestedTransactionMode(self, *args):
        """
        IsNestedTransactionMode(TDocStd_MultiTransactionManager self) -> Standard_Boolean

        Returns Standard_True if NestedTransaction mode is set.
        Methods for protection of changes outside transactions

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDocStd.TDocStd_MultiTransactionManager_IsNestedTransactionMode(self, *args)


    def SetModificationMode(self, *args):
        """
        SetModificationMode(TDocStd_MultiTransactionManager self, Standard_Boolean const theTransactionOnly)

        If theTransactionOnly is True, denies all changes outside transactions.

        :type theTransactionOnly: bool

        """
        return _TDocStd.TDocStd_MultiTransactionManager_SetModificationMode(self, *args)


    def ModificationMode(self, *args):
        """
        ModificationMode(TDocStd_MultiTransactionManager self) -> Standard_Boolean

        Returns True if changes are allowed only inside transactions.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDocStd.TDocStd_MultiTransactionManager_ModificationMode(self, *args)


    def ClearUndos(self, *args):
        """
        ClearUndos(TDocStd_MultiTransactionManager self)

        Clears undos in the manager and in documents.


        """
        return _TDocStd.TDocStd_MultiTransactionManager_ClearUndos(self, *args)


    def ClearRedos(self, *args):
        """
        ClearRedos(TDocStd_MultiTransactionManager self)

        Clears redos in the manager and in documents.


        """
        return _TDocStd.TDocStd_MultiTransactionManager_ClearRedos(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _TDocStd.TDocStd_MultiTransactionManager_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _TDocStd.TDocStd_MultiTransactionManager_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TDocStd.TDocStd_MultiTransactionManager_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _TDocStd.delete_TDocStd_MultiTransactionManager
TDocStd_MultiTransactionManager_swigregister = _TDocStd.TDocStd_MultiTransactionManager_swigregister
TDocStd_MultiTransactionManager_swigregister(TDocStd_MultiTransactionManager)

def TDocStd_MultiTransactionManager_get_type_name(*args):
    """
    TDocStd_MultiTransactionManager_get_type_name() -> char const *

    :rtype: const char *

    """
    return _TDocStd.TDocStd_MultiTransactionManager_get_type_name(*args)

def TDocStd_MultiTransactionManager_get_type_descriptor(*args):
    """
    TDocStd_MultiTransactionManager_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _TDocStd.TDocStd_MultiTransactionManager_get_type_descriptor(*args)

class TDocStd_XLink(TDF.TDF_Attribute):
    """
    An attribute to store the path and the entry of
    external links.
    These refer from one data structure to a data
    structure in another document.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_TDocStd_XLink
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_TDocStd_XLink(self) 
            return h


    def Set(*args):
        """
        Set(TDF_Label atLabel) -> Handle_TDocStd_XLink

        Sets an empty external reference, at the label aLabel.

        :type atLabel: OCC.wrapper.TDF.TDF_Label
        :rtype: OCC.wrapper.TDocStd.Handle_TDocStd_XLink

        """
        return _TDocStd.TDocStd_XLink_Set(*args)

    Set = staticmethod(Set)

    def __init__(self, *args):
        """
        __init__(TDocStd_XLink self) -> TDocStd_XLink

        Initializes fields.


        """
        this = _TDocStd.new_TDocStd_XLink(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Update(self, *args):
        """
        Update(TDocStd_XLink self) -> Handle_TDF_Reference

        Updates the data referenced in this external link attribute.

        :rtype: OCC.wrapper.TDF.Handle_TDF_Reference

        """
        return _TDocStd.TDocStd_XLink_Update(self, *args)


    def ID(self, *args):
        """
        Returns the ID of the attribute.

        :rtype: OCC.wrapper.Standard.Standard_GUID

        """
        res = _TDocStd.TDocStd_XLink_ID(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def GetID(*args):
        """
        GetID() -> Standard_GUID

        Returns the GUID for external links.

        :rtype: OCC.wrapper.Standard.Standard_GUID

        """
        return _TDocStd.TDocStd_XLink_GetID(*args)

    GetID = staticmethod(GetID)

    def DocumentEntry(self, *args):
        """
        Returns the contents of the document identified by aDocEntry.
        aDocEntry provides external data to this external link attribute.

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        res = _TDocStd.TDocStd_XLink_DocumentEntry(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def LabelEntry(self, *args):
        """
        Returns the contents of the field <myLabelEntry>.

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        res = _TDocStd.TDocStd_XLink_LabelEntry(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def AfterAddition(self, *args):
        """
        AfterAddition(TDocStd_XLink self)

        Updates the XLinkRoot attribute by adding <me>
        to its list.


        """
        return _TDocStd.TDocStd_XLink_AfterAddition(self, *args)


    def BeforeRemoval(self, *args):
        """
        BeforeRemoval(TDocStd_XLink self)

        Updates the XLinkRoot attribute by removing <me>
        from its list.


        """
        return _TDocStd.TDocStd_XLink_BeforeRemoval(self, *args)


    def BeforeUndo(self, *args):
        """
        BeforeUndo(TDocStd_XLink self, Handle_TDF_AttributeDelta anAttDelta, Standard_Boolean const forceIt) -> Standard_Boolean

        Something to do before applying <anAttDelta>.

        :type anAttDelta: OCC.wrapper.TDF.Handle_TDF_AttributeDelta
        :type forceIt: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDocStd.TDocStd_XLink_BeforeUndo(self, *args)


    def AfterUndo(self, *args):
        """
        AfterUndo(TDocStd_XLink self, Handle_TDF_AttributeDelta anAttDelta, Standard_Boolean const forceIt) -> Standard_Boolean

        Something to do after applying <anAttDelta>.

        :type anAttDelta: OCC.wrapper.TDF.Handle_TDF_AttributeDelta
        :type forceIt: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDocStd.TDocStd_XLink_AfterUndo(self, *args)


    def BackupCopy(self, *args):
        """
        BackupCopy(TDocStd_XLink self) -> Handle_TDF_Attribute

        Returns a null handle. Raise allways for ,it is
        nonsense to use this method.

        :rtype: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TDocStd.TDocStd_XLink_BackupCopy(self, *args)


    def Restore(self, *args):
        """
        Restore(TDocStd_XLink self, Handle_TDF_Attribute anAttribute)

        Does nothing.

        :type anAttribute: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TDocStd.TDocStd_XLink_Restore(self, *args)


    def NewEmpty(self, *args):
        """
        NewEmpty(TDocStd_XLink self) -> Handle_TDF_Attribute

        Returns a null handle.

        :rtype: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TDocStd.TDocStd_XLink_NewEmpty(self, *args)


    def Paste(self, *args):
        """
        Paste(TDocStd_XLink self, Handle_TDF_Attribute intoAttribute, Handle_TDF_RelocationTable aRelocationTable)

        Does nothing.

        :type intoAttribute: OCC.wrapper.TDF.Handle_TDF_Attribute
        :type aRelocationTable: OCC.wrapper.TDF.Handle_TDF_RelocationTable

        """
        return _TDocStd.TDocStd_XLink_Paste(self, *args)


    def Dump(self, *args):
        """
        Dump(TDocStd_XLink self, Standard_OStream & anOS) -> Standard_OStream &

        Dumps the attribute on <aStream>.

        :type anOS: OCC.wrapper.Standard.Standard_OStream
        :rtype: OCC.wrapper.Standard.Standard_OStream

        """
        return _TDocStd.TDocStd_XLink_Dump(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _TDocStd.TDocStd_XLink_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _TDocStd.TDocStd_XLink_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TDocStd.TDocStd_XLink_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _TDocStd.delete_TDocStd_XLink
TDocStd_XLink_swigregister = _TDocStd.TDocStd_XLink_swigregister
TDocStd_XLink_swigregister(TDocStd_XLink)

def TDocStd_XLink_Set(*args):
    """
    TDocStd_XLink_Set(TDF_Label atLabel) -> Handle_TDocStd_XLink

    Sets an empty external reference, at the label aLabel.

    :type atLabel: OCC.wrapper.TDF.TDF_Label
    :rtype: OCC.wrapper.TDocStd.Handle_TDocStd_XLink

    """
    return _TDocStd.TDocStd_XLink_Set(*args)

def TDocStd_XLink_GetID(*args):
    """
    TDocStd_XLink_GetID() -> Standard_GUID

    Returns the GUID for external links.

    :rtype: OCC.wrapper.Standard.Standard_GUID

    """
    return _TDocStd.TDocStd_XLink_GetID(*args)

def TDocStd_XLink_get_type_name(*args):
    """
    TDocStd_XLink_get_type_name() -> char const *

    :rtype: const char *

    """
    return _TDocStd.TDocStd_XLink_get_type_name(*args)

def TDocStd_XLink_get_type_descriptor(*args):
    """
    TDocStd_XLink_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _TDocStd.TDocStd_XLink_get_type_descriptor(*args)


try:
	TDF_IDMap = TDF.NCollection_Map_Standard_GUID_Standard_GUID
except AttributeError:
	pass # does not exist, probably ignored

class NCollection_Sequence_Handle_TDocStd_Document(NCollection.NCollection_BaseSequence):
    """
    Purpose:     Definition of a sequence of elements indexed by
    an Integer in range of 1..n
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Sequence_Handle_TDocStd_Document self) -> NCollection_Sequence< opencascade::handle< TDocStd_Document > >::iterator

        Returns an iterator pointing to the first element in the sequence.

        :rtype: iterator

        """
        return _TDocStd.NCollection_Sequence_Handle_TDocStd_Document_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Sequence_Handle_TDocStd_Document self) -> NCollection_Sequence< opencascade::handle< TDocStd_Document > >::iterator

        Returns an iterator referring to the past-the-end element in the sequence.

        :rtype: iterator

        """
        return _TDocStd.NCollection_Sequence_Handle_TDocStd_Document_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Sequence_Handle_TDocStd_Document self) -> NCollection_Sequence< opencascade::handle< TDocStd_Document > >::const_iterator

        Returns a const iterator pointing to the first element in the sequence.

        :rtype: const_iterator

        """
        return _TDocStd.NCollection_Sequence_Handle_TDocStd_Document_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Sequence_Handle_TDocStd_Document self) -> NCollection_Sequence< opencascade::handle< TDocStd_Document > >::const_iterator

        Returns a const iterator referring to the past-the-end element in the sequence.

        :rtype: const_iterator

        """
        return _TDocStd.NCollection_Sequence_Handle_TDocStd_Document_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     Definition of a sequence of elements indexed by
        an Integer in range of 1..n
        """
        this = _TDocStd.new_NCollection_Sequence_Handle_TDocStd_Document(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Size(self, *args):
        """
        Size(NCollection_Sequence_Handle_TDocStd_Document self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDocStd.NCollection_Sequence_Handle_TDocStd_Document_Size(self, *args)


    def Length(self, *args):
        """
        Length(NCollection_Sequence_Handle_TDocStd_Document self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDocStd.NCollection_Sequence_Handle_TDocStd_Document_Length(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Sequence_Handle_TDocStd_Document self) -> Standard_Integer

        Method for consistency with other collections.
        @return Lower bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDocStd.NCollection_Sequence_Handle_TDocStd_Document_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Sequence_Handle_TDocStd_Document self) -> Standard_Integer

        Method for consistency with other collections.
        @return Upper bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDocStd.NCollection_Sequence_Handle_TDocStd_Document_Upper(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Sequence_Handle_TDocStd_Document self) -> Standard_Boolean

        Empty query

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDocStd.NCollection_Sequence_Handle_TDocStd_Document_IsEmpty(self, *args)


    def Reverse(self, *args):
        """
        Reverse(NCollection_Sequence_Handle_TDocStd_Document self)

        Reverse sequence


        """
        return _TDocStd.NCollection_Sequence_Handle_TDocStd_Document_Reverse(self, *args)


    def Exchange(self, *args):
        """
        Exchange(NCollection_Sequence_Handle_TDocStd_Document self, Standard_Integer const I, Standard_Integer const J)

        Exchange two members

        :type I: int
        :type J: int

        """
        return _TDocStd.NCollection_Sequence_Handle_TDocStd_Document_Exchange(self, *args)


    def delNode(*args):
        """
        delNode(NCollection_SeqNode theNode, Handle_NCollection_BaseAllocator theAl)

        Static deleter to be passed to BaseSequence

        :type theNode: OCC.wrapper.NCollection.NCollection_SeqNode
        :type theAl: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _TDocStd.NCollection_Sequence_Handle_TDocStd_Document_delNode(*args)

    delNode = staticmethod(delNode)

    def Clear(self, *args):
        """
        Clear(NCollection_Sequence_Handle_TDocStd_Document self, Handle_NCollection_BaseAllocator theAllocator=0)

        Clear the items out, take a new allocator if non null

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _TDocStd.NCollection_Sequence_Handle_TDocStd_Document_Clear(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Sequence_Handle_TDocStd_Document self, NCollection_Sequence_Handle_TDocStd_Document theOther) -> NCollection_Sequence_Handle_TDocStd_Document

        Replace this sequence by the items of theOther.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_Sequence
        :rtype: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _TDocStd.NCollection_Sequence_Handle_TDocStd_Document_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Sequence_Handle_TDocStd_Document self, NCollection_Sequence_Handle_TDocStd_Document theOther) -> NCollection_Sequence_Handle_TDocStd_Document

        Replacement operator

        :type theOther: OCC.wrapper.NCollection.NCollection_Sequence
        :rtype: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _TDocStd.NCollection_Sequence_Handle_TDocStd_Document_assign(self, *args)


    def Remove(self, *args):
        """
        Remove(NCollection_Sequence_Handle_TDocStd_Document self, NCollection_Sequence< opencascade::handle< TDocStd_Document > >::Iterator & thePosition)
        Remove(NCollection_Sequence_Handle_TDocStd_Document self, Standard_Integer const theIndex)
        Remove(NCollection_Sequence_Handle_TDocStd_Document self, Standard_Integer const theFromIndex, Standard_Integer const theToIndex)

        Remove range of items

        :type theFromIndex: int
        :type theToIndex: int

        """
        return _TDocStd.NCollection_Sequence_Handle_TDocStd_Document_Remove(self, *args)


    def Append(self, *args):
        """
        Append(NCollection_Sequence_Handle_TDocStd_Document self, Handle_TDocStd_Document theItem)
        Append(NCollection_Sequence_Handle_TDocStd_Document self, NCollection_Sequence_Handle_TDocStd_Document theSeq)

        Append another sequence (making it empty)

        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _TDocStd.NCollection_Sequence_Handle_TDocStd_Document_Append(self, *args)


    def Prepend(self, *args):
        """
        Prepend(NCollection_Sequence_Handle_TDocStd_Document self, Handle_TDocStd_Document theItem)
        Prepend(NCollection_Sequence_Handle_TDocStd_Document self, NCollection_Sequence_Handle_TDocStd_Document theSeq)

        Prepend another sequence (making it empty)

        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _TDocStd.NCollection_Sequence_Handle_TDocStd_Document_Prepend(self, *args)


    def InsertBefore(self, *args):
        """
        InsertBefore(NCollection_Sequence_Handle_TDocStd_Document self, Standard_Integer const theIndex, Handle_TDocStd_Document theItem)
        InsertBefore(NCollection_Sequence_Handle_TDocStd_Document self, Standard_Integer const theIndex, NCollection_Sequence_Handle_TDocStd_Document theSeq)

        InsertBefore theIndex another sequence

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _TDocStd.NCollection_Sequence_Handle_TDocStd_Document_InsertBefore(self, *args)


    def InsertAfter(self, *args):
        """
        InsertAfter(NCollection_Sequence_Handle_TDocStd_Document self, NCollection_Sequence< opencascade::handle< TDocStd_Document > >::Iterator & thePosition, Handle_TDocStd_Document theItem)
        InsertAfter(NCollection_Sequence_Handle_TDocStd_Document self, Standard_Integer const theIndex, NCollection_Sequence_Handle_TDocStd_Document theSeq)
        InsertAfter(NCollection_Sequence_Handle_TDocStd_Document self, Standard_Integer const theIndex, Handle_TDocStd_Document theItem)

        InsertAfter theIndex another sequence

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _TDocStd.NCollection_Sequence_Handle_TDocStd_Document_InsertAfter(self, *args)


    def Split(self, *args):
        """
        Split(NCollection_Sequence_Handle_TDocStd_Document self, Standard_Integer const theIndex, NCollection_Sequence_Handle_TDocStd_Document theSeq)

        Split in two sequences

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _TDocStd.NCollection_Sequence_Handle_TDocStd_Document_Split(self, *args)


    def First(self, *args):
        """
        First item access

        :rtype: const TheItemType &

        """
        res = _TDocStd.NCollection_Sequence_Handle_TDocStd_Document_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Sequence_Handle_TDocStd_Document self) -> Handle_TDocStd_Document

        First item access

        :rtype: TheItemType &

        """
        return _TDocStd.NCollection_Sequence_Handle_TDocStd_Document_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        Last item access

        :rtype: const TheItemType &

        """
        res = _TDocStd.NCollection_Sequence_Handle_TDocStd_Document_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Sequence_Handle_TDocStd_Document self) -> Handle_TDocStd_Document

        Last item access

        :rtype: TheItemType &

        """
        return _TDocStd.NCollection_Sequence_Handle_TDocStd_Document_ChangeLast(self, *args)


    def Value(self, *args):
        """
        Constant item access by theIndex

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _TDocStd.NCollection_Sequence_Handle_TDocStd_Document_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Sequence_Handle_TDocStd_Document self, Standard_Integer const theIndex) -> Handle_TDocStd_Document

        Variable item access by theIndex

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _TDocStd.NCollection_Sequence_Handle_TDocStd_Document_ChangeValue(self, *args)


    def __call__(self, *args):
        """
        Constant operator()

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _TDocStd.NCollection_Sequence_Handle_TDocStd_Document___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetValue(self, *args):
        """
        SetValue(NCollection_Sequence_Handle_TDocStd_Document self, Standard_Integer const theIndex, Handle_TDocStd_Document theItem)

        Set item value by theIndex

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _TDocStd.NCollection_Sequence_Handle_TDocStd_Document_SetValue(self, *args)


    def __iter__(self):
        return _TDocStd.NCollection_Sequence_Handle_TDocStd_Document___iter__(self)
    __swig_destroy__ = _TDocStd.delete_NCollection_Sequence_Handle_TDocStd_Document
NCollection_Sequence_Handle_TDocStd_Document_swigregister = _TDocStd.NCollection_Sequence_Handle_TDocStd_Document_swigregister
NCollection_Sequence_Handle_TDocStd_Document_swigregister(NCollection_Sequence_Handle_TDocStd_Document)

def NCollection_Sequence_Handle_TDocStd_Document_delNode(*args):
    """
    NCollection_Sequence_Handle_TDocStd_Document_delNode(NCollection_SeqNode theNode, Handle_NCollection_BaseAllocator theAl)

    Static deleter to be passed to BaseSequence

    :type theNode: OCC.wrapper.NCollection.NCollection_SeqNode
    :type theAl: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

    """
    return _TDocStd.NCollection_Sequence_Handle_TDocStd_Document_delNode(*args)

class NCollection_Sequence_Handle_TDocStd_Document_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _TDocStd.new_NCollection_Sequence_Handle_TDocStd_Document_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _TDocStd.delete_NCollection_Sequence_Handle_TDocStd_Document_IteratorHelper

    def __next__(self):
        return _TDocStd.NCollection_Sequence_Handle_TDocStd_Document_IteratorHelper___next__(self)
NCollection_Sequence_Handle_TDocStd_Document_IteratorHelper_swigregister = _TDocStd.NCollection_Sequence_Handle_TDocStd_Document_IteratorHelper_swigregister
NCollection_Sequence_Handle_TDocStd_Document_IteratorHelper_swigregister(NCollection_Sequence_Handle_TDocStd_Document_IteratorHelper)


try:
	TDocStd_SequenceOfDocument = NCollection_Sequence_Handle_TDocStd_Document
except NameError:
	pass # does not exist, probably ignored

class TDocStd_Owner(TDF.TDF_Attribute):
    """
    This  attribute located  at  the  root label  of the
    framework contains  a   back reference to   the  owner
    TDocStd_Document, providing acces to the document from
    any label.  private class Owner;
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_TDocStd_Owner
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_TDocStd_Owner(self) 
            return h


    def GetID(*args):
        """
        GetID() -> Standard_GUID

        class methods
        =============

        :rtype: OCC.wrapper.Standard.Standard_GUID

        """
        return _TDocStd.TDocStd_Owner_GetID(*args)

    GetID = staticmethod(GetID)

    def __init__(self, *args):
        """
        __init__(TDocStd_Owner self) -> TDocStd_Owner

        This  attribute located  at  the  root label  of the
        framework contains  a   back reference to   the  owner
        TDocStd_Document, providing acces to the document from
        any label.  private class Owner;
        """
        this = _TDocStd.new_TDocStd_Owner(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def SetDocument(self, *args):
        """
        SetDocument(TDocStd_Owner self, Handle_TDF_Data indata, Handle_TDocStd_Document doc)
        SetDocument(TDocStd_Owner self, Handle_TDocStd_Document document)

        :type document: OCC.wrapper.TDocStd.Handle_TDocStd_Document

        """
        return _TDocStd.TDocStd_Owner_SetDocument(self, *args)


    def GetDocument(self, *args):
        """
        GetDocument(TDocStd_Owner self, Handle_TDF_Data ofdata) -> Handle_TDocStd_Document
        GetDocument(TDocStd_Owner self) -> Handle_TDocStd_Document

        :rtype: OCC.wrapper.TDocStd.Handle_TDocStd_Document

        """
        return _TDocStd.TDocStd_Owner_GetDocument(self, *args)


    def ID(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Standard_GUID

        """
        res = _TDocStd.TDocStd_Owner_ID(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Restore(self, *args):
        """
        Restore(TDocStd_Owner self, Handle_TDF_Attribute With)

        :type With: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TDocStd.TDocStd_Owner_Restore(self, *args)


    def NewEmpty(self, *args):
        """
        NewEmpty(TDocStd_Owner self) -> Handle_TDF_Attribute

        :rtype: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TDocStd.TDocStd_Owner_NewEmpty(self, *args)


    def Paste(self, *args):
        """
        Paste(TDocStd_Owner self, Handle_TDF_Attribute Into, Handle_TDF_RelocationTable RT)

        :type Into: OCC.wrapper.TDF.Handle_TDF_Attribute
        :type RT: OCC.wrapper.TDF.Handle_TDF_RelocationTable

        """
        return _TDocStd.TDocStd_Owner_Paste(self, *args)


    def Dump(self, *args):
        """
        Dump(TDocStd_Owner self, Standard_OStream & anOS) -> Standard_OStream &

        :type anOS: OCC.wrapper.Standard.Standard_OStream
        :rtype: OCC.wrapper.Standard.Standard_OStream

        """
        return _TDocStd.TDocStd_Owner_Dump(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _TDocStd.TDocStd_Owner_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _TDocStd.TDocStd_Owner_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TDocStd.TDocStd_Owner_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _TDocStd.delete_TDocStd_Owner
TDocStd_Owner_swigregister = _TDocStd.TDocStd_Owner_swigregister
TDocStd_Owner_swigregister(TDocStd_Owner)

def TDocStd_Owner_GetID(*args):
    """
    TDocStd_Owner_GetID() -> Standard_GUID

    class methods
    =============

    :rtype: OCC.wrapper.Standard.Standard_GUID

    """
    return _TDocStd.TDocStd_Owner_GetID(*args)

def TDocStd_Owner_get_type_name(*args):
    """
    TDocStd_Owner_get_type_name() -> char const *

    :rtype: const char *

    """
    return _TDocStd.TDocStd_Owner_get_type_name(*args)

def TDocStd_Owner_get_type_descriptor(*args):
    """
    TDocStd_Owner_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _TDocStd.TDocStd_Owner_get_type_descriptor(*args)

class NCollection_Sequence_Handle_TDocStd_ApplicationDelta(NCollection.NCollection_BaseSequence):
    """
    Purpose:     Definition of a sequence of elements indexed by
    an Integer in range of 1..n
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Sequence_Handle_TDocStd_ApplicationDelta self) -> NCollection_Sequence< opencascade::handle< TDocStd_ApplicationDelta > >::iterator

        Returns an iterator pointing to the first element in the sequence.

        :rtype: iterator

        """
        return _TDocStd.NCollection_Sequence_Handle_TDocStd_ApplicationDelta_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Sequence_Handle_TDocStd_ApplicationDelta self) -> NCollection_Sequence< opencascade::handle< TDocStd_ApplicationDelta > >::iterator

        Returns an iterator referring to the past-the-end element in the sequence.

        :rtype: iterator

        """
        return _TDocStd.NCollection_Sequence_Handle_TDocStd_ApplicationDelta_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Sequence_Handle_TDocStd_ApplicationDelta self) -> NCollection_Sequence< opencascade::handle< TDocStd_ApplicationDelta > >::const_iterator

        Returns a const iterator pointing to the first element in the sequence.

        :rtype: const_iterator

        """
        return _TDocStd.NCollection_Sequence_Handle_TDocStd_ApplicationDelta_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Sequence_Handle_TDocStd_ApplicationDelta self) -> NCollection_Sequence< opencascade::handle< TDocStd_ApplicationDelta > >::const_iterator

        Returns a const iterator referring to the past-the-end element in the sequence.

        :rtype: const_iterator

        """
        return _TDocStd.NCollection_Sequence_Handle_TDocStd_ApplicationDelta_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     Definition of a sequence of elements indexed by
        an Integer in range of 1..n
        """
        this = _TDocStd.new_NCollection_Sequence_Handle_TDocStd_ApplicationDelta(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Size(self, *args):
        """
        Size(NCollection_Sequence_Handle_TDocStd_ApplicationDelta self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDocStd.NCollection_Sequence_Handle_TDocStd_ApplicationDelta_Size(self, *args)


    def Length(self, *args):
        """
        Length(NCollection_Sequence_Handle_TDocStd_ApplicationDelta self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDocStd.NCollection_Sequence_Handle_TDocStd_ApplicationDelta_Length(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Sequence_Handle_TDocStd_ApplicationDelta self) -> Standard_Integer

        Method for consistency with other collections.
        @return Lower bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDocStd.NCollection_Sequence_Handle_TDocStd_ApplicationDelta_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Sequence_Handle_TDocStd_ApplicationDelta self) -> Standard_Integer

        Method for consistency with other collections.
        @return Upper bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDocStd.NCollection_Sequence_Handle_TDocStd_ApplicationDelta_Upper(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Sequence_Handle_TDocStd_ApplicationDelta self) -> Standard_Boolean

        Empty query

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDocStd.NCollection_Sequence_Handle_TDocStd_ApplicationDelta_IsEmpty(self, *args)


    def Reverse(self, *args):
        """
        Reverse(NCollection_Sequence_Handle_TDocStd_ApplicationDelta self)

        Reverse sequence


        """
        return _TDocStd.NCollection_Sequence_Handle_TDocStd_ApplicationDelta_Reverse(self, *args)


    def Exchange(self, *args):
        """
        Exchange(NCollection_Sequence_Handle_TDocStd_ApplicationDelta self, Standard_Integer const I, Standard_Integer const J)

        Exchange two members

        :type I: int
        :type J: int

        """
        return _TDocStd.NCollection_Sequence_Handle_TDocStd_ApplicationDelta_Exchange(self, *args)


    def delNode(*args):
        """
        delNode(NCollection_SeqNode theNode, Handle_NCollection_BaseAllocator theAl)

        Static deleter to be passed to BaseSequence

        :type theNode: OCC.wrapper.NCollection.NCollection_SeqNode
        :type theAl: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _TDocStd.NCollection_Sequence_Handle_TDocStd_ApplicationDelta_delNode(*args)

    delNode = staticmethod(delNode)

    def Clear(self, *args):
        """
        Clear(NCollection_Sequence_Handle_TDocStd_ApplicationDelta self, Handle_NCollection_BaseAllocator theAllocator=0)

        Clear the items out, take a new allocator if non null

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _TDocStd.NCollection_Sequence_Handle_TDocStd_ApplicationDelta_Clear(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Sequence_Handle_TDocStd_ApplicationDelta self, NCollection_Sequence_Handle_TDocStd_ApplicationDelta theOther) -> NCollection_Sequence_Handle_TDocStd_ApplicationDelta

        Replace this sequence by the items of theOther.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_Sequence
        :rtype: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _TDocStd.NCollection_Sequence_Handle_TDocStd_ApplicationDelta_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Sequence_Handle_TDocStd_ApplicationDelta self, NCollection_Sequence_Handle_TDocStd_ApplicationDelta theOther) -> NCollection_Sequence_Handle_TDocStd_ApplicationDelta

        Replacement operator

        :type theOther: OCC.wrapper.NCollection.NCollection_Sequence
        :rtype: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _TDocStd.NCollection_Sequence_Handle_TDocStd_ApplicationDelta_assign(self, *args)


    def Remove(self, *args):
        """
        Remove(NCollection_Sequence_Handle_TDocStd_ApplicationDelta self, NCollection_Sequence< opencascade::handle< TDocStd_ApplicationDelta > >::Iterator & thePosition)
        Remove(NCollection_Sequence_Handle_TDocStd_ApplicationDelta self, Standard_Integer const theIndex)
        Remove(NCollection_Sequence_Handle_TDocStd_ApplicationDelta self, Standard_Integer const theFromIndex, Standard_Integer const theToIndex)

        Remove range of items

        :type theFromIndex: int
        :type theToIndex: int

        """
        return _TDocStd.NCollection_Sequence_Handle_TDocStd_ApplicationDelta_Remove(self, *args)


    def Append(self, *args):
        """
        Append(NCollection_Sequence_Handle_TDocStd_ApplicationDelta self, Handle_TDocStd_ApplicationDelta theItem)
        Append(NCollection_Sequence_Handle_TDocStd_ApplicationDelta self, NCollection_Sequence_Handle_TDocStd_ApplicationDelta theSeq)

        Append another sequence (making it empty)

        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _TDocStd.NCollection_Sequence_Handle_TDocStd_ApplicationDelta_Append(self, *args)


    def Prepend(self, *args):
        """
        Prepend(NCollection_Sequence_Handle_TDocStd_ApplicationDelta self, Handle_TDocStd_ApplicationDelta theItem)
        Prepend(NCollection_Sequence_Handle_TDocStd_ApplicationDelta self, NCollection_Sequence_Handle_TDocStd_ApplicationDelta theSeq)

        Prepend another sequence (making it empty)

        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _TDocStd.NCollection_Sequence_Handle_TDocStd_ApplicationDelta_Prepend(self, *args)


    def InsertBefore(self, *args):
        """
        InsertBefore(NCollection_Sequence_Handle_TDocStd_ApplicationDelta self, Standard_Integer const theIndex, Handle_TDocStd_ApplicationDelta theItem)
        InsertBefore(NCollection_Sequence_Handle_TDocStd_ApplicationDelta self, Standard_Integer const theIndex, NCollection_Sequence_Handle_TDocStd_ApplicationDelta theSeq)

        InsertBefore theIndex another sequence

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _TDocStd.NCollection_Sequence_Handle_TDocStd_ApplicationDelta_InsertBefore(self, *args)


    def InsertAfter(self, *args):
        """
        InsertAfter(NCollection_Sequence_Handle_TDocStd_ApplicationDelta self, NCollection_Sequence< opencascade::handle< TDocStd_ApplicationDelta > >::Iterator & thePosition, Handle_TDocStd_ApplicationDelta theItem)
        InsertAfter(NCollection_Sequence_Handle_TDocStd_ApplicationDelta self, Standard_Integer const theIndex, NCollection_Sequence_Handle_TDocStd_ApplicationDelta theSeq)
        InsertAfter(NCollection_Sequence_Handle_TDocStd_ApplicationDelta self, Standard_Integer const theIndex, Handle_TDocStd_ApplicationDelta theItem)

        InsertAfter theIndex another sequence

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _TDocStd.NCollection_Sequence_Handle_TDocStd_ApplicationDelta_InsertAfter(self, *args)


    def Split(self, *args):
        """
        Split(NCollection_Sequence_Handle_TDocStd_ApplicationDelta self, Standard_Integer const theIndex, NCollection_Sequence_Handle_TDocStd_ApplicationDelta theSeq)

        Split in two sequences

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _TDocStd.NCollection_Sequence_Handle_TDocStd_ApplicationDelta_Split(self, *args)


    def First(self, *args):
        """
        First item access

        :rtype: const TheItemType &

        """
        res = _TDocStd.NCollection_Sequence_Handle_TDocStd_ApplicationDelta_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Sequence_Handle_TDocStd_ApplicationDelta self) -> Handle_TDocStd_ApplicationDelta

        First item access

        :rtype: TheItemType &

        """
        return _TDocStd.NCollection_Sequence_Handle_TDocStd_ApplicationDelta_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        Last item access

        :rtype: const TheItemType &

        """
        res = _TDocStd.NCollection_Sequence_Handle_TDocStd_ApplicationDelta_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Sequence_Handle_TDocStd_ApplicationDelta self) -> Handle_TDocStd_ApplicationDelta

        Last item access

        :rtype: TheItemType &

        """
        return _TDocStd.NCollection_Sequence_Handle_TDocStd_ApplicationDelta_ChangeLast(self, *args)


    def Value(self, *args):
        """
        Constant item access by theIndex

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _TDocStd.NCollection_Sequence_Handle_TDocStd_ApplicationDelta_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Sequence_Handle_TDocStd_ApplicationDelta self, Standard_Integer const theIndex) -> Handle_TDocStd_ApplicationDelta

        Variable item access by theIndex

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _TDocStd.NCollection_Sequence_Handle_TDocStd_ApplicationDelta_ChangeValue(self, *args)


    def __call__(self, *args):
        """
        Constant operator()

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _TDocStd.NCollection_Sequence_Handle_TDocStd_ApplicationDelta___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetValue(self, *args):
        """
        SetValue(NCollection_Sequence_Handle_TDocStd_ApplicationDelta self, Standard_Integer const theIndex, Handle_TDocStd_ApplicationDelta theItem)

        Set item value by theIndex

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _TDocStd.NCollection_Sequence_Handle_TDocStd_ApplicationDelta_SetValue(self, *args)


    def __iter__(self):
        return _TDocStd.NCollection_Sequence_Handle_TDocStd_ApplicationDelta___iter__(self)
    __swig_destroy__ = _TDocStd.delete_NCollection_Sequence_Handle_TDocStd_ApplicationDelta
NCollection_Sequence_Handle_TDocStd_ApplicationDelta_swigregister = _TDocStd.NCollection_Sequence_Handle_TDocStd_ApplicationDelta_swigregister
NCollection_Sequence_Handle_TDocStd_ApplicationDelta_swigregister(NCollection_Sequence_Handle_TDocStd_ApplicationDelta)

def NCollection_Sequence_Handle_TDocStd_ApplicationDelta_delNode(*args):
    """
    NCollection_Sequence_Handle_TDocStd_ApplicationDelta_delNode(NCollection_SeqNode theNode, Handle_NCollection_BaseAllocator theAl)

    Static deleter to be passed to BaseSequence

    :type theNode: OCC.wrapper.NCollection.NCollection_SeqNode
    :type theAl: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

    """
    return _TDocStd.NCollection_Sequence_Handle_TDocStd_ApplicationDelta_delNode(*args)

class NCollection_Sequence_Handle_TDocStd_ApplicationDelta_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _TDocStd.new_NCollection_Sequence_Handle_TDocStd_ApplicationDelta_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _TDocStd.delete_NCollection_Sequence_Handle_TDocStd_ApplicationDelta_IteratorHelper

    def __next__(self):
        return _TDocStd.NCollection_Sequence_Handle_TDocStd_ApplicationDelta_IteratorHelper___next__(self)
NCollection_Sequence_Handle_TDocStd_ApplicationDelta_IteratorHelper_swigregister = _TDocStd.NCollection_Sequence_Handle_TDocStd_ApplicationDelta_IteratorHelper_swigregister
NCollection_Sequence_Handle_TDocStd_ApplicationDelta_IteratorHelper_swigregister(NCollection_Sequence_Handle_TDocStd_ApplicationDelta_IteratorHelper)


try:
	TDocStd_SequenceOfApplicationDelta = NCollection_Sequence_Handle_TDocStd_ApplicationDelta
except NameError:
	pass # does not exist, probably ignored

class TDocStd_Context(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """__init__(TDocStd_Context self) -> TDocStd_Context"""
        this = _TDocStd.new_TDocStd_Context(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def SetModifiedReferences(self, *args):
        """
        SetModifiedReferences(TDocStd_Context self, Standard_Boolean const Mod)

        :type Mod: bool

        """
        return _TDocStd.TDocStd_Context_SetModifiedReferences(self, *args)


    def ModifiedReferences(self, *args):
        """
        ModifiedReferences(TDocStd_Context self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDocStd.TDocStd_Context_ModifiedReferences(self, *args)

    __swig_destroy__ = _TDocStd.delete_TDocStd_Context
TDocStd_Context_swigregister = _TDocStd.TDocStd_Context_swigregister
TDocStd_Context_swigregister(TDocStd_Context)

class NCollection_DataMap_TDF_Label_TDF_IDMap_TDF_LabelMapHasher(NCollection.NCollection_BaseMap):
    """
    Purpose:     The DataMap is a Map to store keys with associated
    Items. See Map  from NCollection for  a discussion
    about the number of buckets.

    The DataMap can be seen as an extended array where
    the Keys  are the   indices.  For this reason  the
    operator () is defined on DataMap to fetch an Item
    from a Key. So the following syntax can be used :

    anItem = aMap(aKey);
    aMap(aKey) = anItem;

    This analogy has its  limit.   aMap(aKey) = anItem
    can  be done only  if aKey was previously bound to
    an item in the map.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_DataMap_TDF_Label_TDF_IDMap_TDF_LabelMapHasher self) -> NCollection_DataMap< TDF_Label,TDF_IDMap,TDF_LabelMapHasher >::iterator

        Returns an iterator pointing to the first element in the map.

        :rtype: iterator

        """
        return _TDocStd.NCollection_DataMap_TDF_Label_TDF_IDMap_TDF_LabelMapHasher_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_DataMap_TDF_Label_TDF_IDMap_TDF_LabelMapHasher self) -> NCollection_DataMap< TDF_Label,TDF_IDMap,TDF_LabelMapHasher >::iterator

        Returns an iterator referring to the past-the-end element in the map.

        :rtype: iterator

        """
        return _TDocStd.NCollection_DataMap_TDF_Label_TDF_IDMap_TDF_LabelMapHasher_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_DataMap_TDF_Label_TDF_IDMap_TDF_LabelMapHasher self) -> NCollection_DataMap< TDF_Label,TDF_IDMap,TDF_LabelMapHasher >::const_iterator

        Returns a const iterator pointing to the first element in the map.

        :rtype: const_iterator

        """
        return _TDocStd.NCollection_DataMap_TDF_Label_TDF_IDMap_TDF_LabelMapHasher_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_DataMap_TDF_Label_TDF_IDMap_TDF_LabelMapHasher self) -> NCollection_DataMap< TDF_Label,TDF_IDMap,TDF_LabelMapHasher >::const_iterator

        Returns a const iterator referring to the past-the-end element in the map.

        :rtype: const_iterator

        """
        return _TDocStd.NCollection_DataMap_TDF_Label_TDF_IDMap_TDF_LabelMapHasher_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     The DataMap is a Map to store keys with associated
        Items. See Map  from NCollection for  a discussion
        about the number of buckets.

        The DataMap can be seen as an extended array where
        the Keys  are the   indices.  For this reason  the
        operator () is defined on DataMap to fetch an Item
        from a Key. So the following syntax can be used :

        anItem = aMap(aKey);
        aMap(aKey) = anItem;

        This analogy has its  limit.   aMap(aKey) = anItem
        can  be done only  if aKey was previously bound to
        an item in the map.
        """
        this = _TDocStd.new_NCollection_DataMap_TDF_Label_TDF_IDMap_TDF_LabelMapHasher(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Exchange(self, *args):
        """
        Exchange(NCollection_DataMap_TDF_Label_TDF_IDMap_TDF_LabelMapHasher self, NCollection_DataMap_TDF_Label_TDF_IDMap_TDF_LabelMapHasher theOther)

        Exchange the content of two maps without re-allocations.
        Notice that allocators will be swapped as well!

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _TDocStd.NCollection_DataMap_TDF_Label_TDF_IDMap_TDF_LabelMapHasher_Exchange(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_DataMap_TDF_Label_TDF_IDMap_TDF_LabelMapHasher self, NCollection_DataMap_TDF_Label_TDF_IDMap_TDF_LabelMapHasher theOther) -> NCollection_DataMap_TDF_Label_TDF_IDMap_TDF_LabelMapHasher

        Assignment.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _TDocStd.NCollection_DataMap_TDF_Label_TDF_IDMap_TDF_LabelMapHasher_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_DataMap_TDF_Label_TDF_IDMap_TDF_LabelMapHasher self, NCollection_DataMap_TDF_Label_TDF_IDMap_TDF_LabelMapHasher theOther) -> NCollection_DataMap_TDF_Label_TDF_IDMap_TDF_LabelMapHasher

        Assignment operator

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _TDocStd.NCollection_DataMap_TDF_Label_TDF_IDMap_TDF_LabelMapHasher_assign(self, *args)


    def ReSize(self, *args):
        """
        ReSize(NCollection_DataMap_TDF_Label_TDF_IDMap_TDF_LabelMapHasher self, Standard_Integer const N)

        ReSize

        :type N: int

        """
        return _TDocStd.NCollection_DataMap_TDF_Label_TDF_IDMap_TDF_LabelMapHasher_ReSize(self, *args)


    def Bind(self, *args):
        """
        Bind(NCollection_DataMap_TDF_Label_TDF_IDMap_TDF_LabelMapHasher self, TDF_Label theKey, NCollection_Map_Standard_GUID_Standard_GUID theItem) -> Standard_Boolean

        Bind binds Item to Key in map.
        @param theKey  key to add/update
        @param theItem new item; overrides value previously bound to the key, if any
        @return Standard_True if Key was not bound already

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDocStd.NCollection_DataMap_TDF_Label_TDF_IDMap_TDF_LabelMapHasher_Bind(self, *args)


    def Bound(self, *args):
        """
        Bound(NCollection_DataMap_TDF_Label_TDF_IDMap_TDF_LabelMapHasher self, TDF_Label theKey, NCollection_Map_Standard_GUID_Standard_GUID theItem) -> NCollection_Map_Standard_GUID_Standard_GUID

        Bound binds Item to Key in map. Returns modifiable Item 

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: TheItemType *

        """
        return _TDocStd.NCollection_DataMap_TDF_Label_TDF_IDMap_TDF_LabelMapHasher_Bound(self, *args)


    def IsBound(self, *args):
        """
        IsBound(NCollection_DataMap_TDF_Label_TDF_IDMap_TDF_LabelMapHasher self, TDF_Label theKey) -> Standard_Boolean

        IsBound

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDocStd.NCollection_DataMap_TDF_Label_TDF_IDMap_TDF_LabelMapHasher_IsBound(self, *args)


    def UnBind(self, *args):
        """
        UnBind(NCollection_DataMap_TDF_Label_TDF_IDMap_TDF_LabelMapHasher self, TDF_Label theKey) -> Standard_Boolean

        UnBind removes Item Key pair from map

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDocStd.NCollection_DataMap_TDF_Label_TDF_IDMap_TDF_LabelMapHasher_UnBind(self, *args)


    def Seek(self, *args):
        """
        Seek(NCollection_DataMap_TDF_Label_TDF_IDMap_TDF_LabelMapHasher self, TDF_Label theKey) -> NCollection_Map_Standard_GUID_Standard_GUID

        Seek returns pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: const TheItemType *

        """
        return _TDocStd.NCollection_DataMap_TDF_Label_TDF_IDMap_TDF_LabelMapHasher_Seek(self, *args)


    def Find(self, *args):
        """
        Find returns the Item for Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _TDocStd.NCollection_DataMap_TDF_Label_TDF_IDMap_TDF_LabelMapHasher_Find(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeSeek(self, *args):
        """
        ChangeSeek(NCollection_DataMap_TDF_Label_TDF_IDMap_TDF_LabelMapHasher self, TDF_Label theKey) -> NCollection_Map_Standard_GUID_Standard_GUID

        ChangeSeek returns modifiable pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: TheItemType *

        """
        return _TDocStd.NCollection_DataMap_TDF_Label_TDF_IDMap_TDF_LabelMapHasher_ChangeSeek(self, *args)


    def ChangeFind(self, *args):
        """
        ChangeFind(NCollection_DataMap_TDF_Label_TDF_IDMap_TDF_LabelMapHasher self, TDF_Label theKey) -> NCollection_Map_Standard_GUID_Standard_GUID

        ChangeFind returns mofifiable Item by Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: TheItemType &

        """
        return _TDocStd.NCollection_DataMap_TDF_Label_TDF_IDMap_TDF_LabelMapHasher_ChangeFind(self, *args)


    def __call__(self, *args):
        """
        operator ()

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _TDocStd.NCollection_DataMap_TDF_Label_TDF_IDMap_TDF_LabelMapHasher___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Clear(self, *args):
        """
        Clear(NCollection_DataMap_TDF_Label_TDF_IDMap_TDF_LabelMapHasher self, Standard_Boolean const doReleaseMemory)
        Clear(NCollection_DataMap_TDF_Label_TDF_IDMap_TDF_LabelMapHasher self, Handle_NCollection_BaseAllocator theAllocator)

        Clear data and reset allocator

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _TDocStd.NCollection_DataMap_TDF_Label_TDF_IDMap_TDF_LabelMapHasher_Clear(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_DataMap_TDF_Label_TDF_IDMap_TDF_LabelMapHasher self) -> Standard_Integer

        Size

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDocStd.NCollection_DataMap_TDF_Label_TDF_IDMap_TDF_LabelMapHasher_Size(self, *args)


    def __iter__(self):
        return _TDocStd.NCollection_DataMap_TDF_Label_TDF_IDMap_TDF_LabelMapHasher___iter__(self)
    __swig_destroy__ = _TDocStd.delete_NCollection_DataMap_TDF_Label_TDF_IDMap_TDF_LabelMapHasher
NCollection_DataMap_TDF_Label_TDF_IDMap_TDF_LabelMapHasher_swigregister = _TDocStd.NCollection_DataMap_TDF_Label_TDF_IDMap_TDF_LabelMapHasher_swigregister
NCollection_DataMap_TDF_Label_TDF_IDMap_TDF_LabelMapHasher_swigregister(NCollection_DataMap_TDF_Label_TDF_IDMap_TDF_LabelMapHasher)

class NCollection_DataMap_TDF_Label_TDF_IDMap_TDF_LabelMapHasher_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _TDocStd.new_NCollection_DataMap_TDF_Label_TDF_IDMap_TDF_LabelMapHasher_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _TDocStd.delete_NCollection_DataMap_TDF_Label_TDF_IDMap_TDF_LabelMapHasher_IteratorHelper

    def __next__(self):
        return _TDocStd.NCollection_DataMap_TDF_Label_TDF_IDMap_TDF_LabelMapHasher_IteratorHelper___next__(self)
NCollection_DataMap_TDF_Label_TDF_IDMap_TDF_LabelMapHasher_IteratorHelper_swigregister = _TDocStd.NCollection_DataMap_TDF_Label_TDF_IDMap_TDF_LabelMapHasher_IteratorHelper_swigregister
NCollection_DataMap_TDF_Label_TDF_IDMap_TDF_LabelMapHasher_IteratorHelper_swigregister(NCollection_DataMap_TDF_Label_TDF_IDMap_TDF_LabelMapHasher_IteratorHelper)


try:
	TDocStd_LabelIDMapDataMap = NCollection_DataMap_TDF_Label_TDF_IDMap_TDF_LabelMapHasher
except NameError:
	pass # does not exist, probably ignored

class TDocStd_Modified(TDF.TDF_Attribute):
    """
    Transient     attribute   wich     register modified
    labels. This attribute is attached to root label.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_TDocStd_Modified
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_TDocStd_Modified(self) 
            return h


    def Add(*args):
        """
        Add(TDF_Label alabel) -> Standard_Boolean

        :type alabel: OCC.wrapper.TDF.TDF_Label
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDocStd.TDocStd_Modified_Add(*args)

    Add = staticmethod(Add)

    def Remove(*args):
        """
        Remove(TDF_Label alabel) -> Standard_Boolean

        :type alabel: OCC.wrapper.TDF.TDF_Label
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDocStd.TDocStd_Modified_Remove(*args)

    Remove = staticmethod(Remove)

    def Contains(*args):
        """
        Contains(TDF_Label alabel) -> Standard_Boolean

        :type alabel: OCC.wrapper.TDF.TDF_Label
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDocStd.TDocStd_Modified_Contains(*args)

    Contains = staticmethod(Contains)

    def GetID(*args):
        """
        GetID() -> Standard_GUID

        Modified methods
        ================

        :rtype: OCC.wrapper.Standard.Standard_GUID

        """
        return _TDocStd.TDocStd_Modified_GetID(*args)

    GetID = staticmethod(GetID)

    def __init__(self, *args):
        """
        __init__(TDocStd_Modified self) -> TDocStd_Modified

        Transient     attribute   wich     register modified
        labels. This attribute is attached to root label.
        """
        this = _TDocStd.new_TDocStd_Modified(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def IsEmpty(self, *args):
        """
        IsEmpty(TDocStd_Modified self, TDF_Label access) -> Standard_Boolean
        IsEmpty(TDocStd_Modified self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDocStd.TDocStd_Modified_IsEmpty(self, *args)


    def Clear(self, *args):
        """
        Clear(TDocStd_Modified self, TDF_Label access)
        Clear(TDocStd_Modified self)

        remove all modified labels. becomes empty

        :type access: OCC.wrapper.TDF.TDF_Label

        """
        return _TDocStd.TDocStd_Modified_Clear(self, *args)


    def AddLabel(self, *args):
        """
        AddLabel(TDocStd_Modified self, TDF_Label L) -> Standard_Boolean

        add <L> as modified

        :type L: OCC.wrapper.TDF.TDF_Label
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDocStd.TDocStd_Modified_AddLabel(self, *args)


    def RemoveLabel(self, *args):
        """
        RemoveLabel(TDocStd_Modified self, TDF_Label L) -> Standard_Boolean

        remove  <L> as modified

        :type L: OCC.wrapper.TDF.TDF_Label
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDocStd.TDocStd_Modified_RemoveLabel(self, *args)


    def Get(self, *args):
        """
        returns modified label map

        :rtype: OCC.wrapper.TDF.TDF_LabelMap

        """
        res = _TDocStd.TDocStd_Modified_Get(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ID(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Standard_GUID

        """
        res = _TDocStd.TDocStd_Modified_ID(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Restore(self, *args):
        """
        Restore(TDocStd_Modified self, Handle_TDF_Attribute With)

        :type With: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TDocStd.TDocStd_Modified_Restore(self, *args)


    def NewEmpty(self, *args):
        """
        NewEmpty(TDocStd_Modified self) -> Handle_TDF_Attribute

        :rtype: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TDocStd.TDocStd_Modified_NewEmpty(self, *args)


    def Paste(self, *args):
        """
        Paste(TDocStd_Modified self, Handle_TDF_Attribute Into, Handle_TDF_RelocationTable RT)

        :type Into: OCC.wrapper.TDF.Handle_TDF_Attribute
        :type RT: OCC.wrapper.TDF.Handle_TDF_RelocationTable

        """
        return _TDocStd.TDocStd_Modified_Paste(self, *args)


    def Dump(self, *args):
        """
        Dump(TDocStd_Modified self, Standard_OStream & anOS) -> Standard_OStream &

        :type anOS: OCC.wrapper.Standard.Standard_OStream
        :rtype: OCC.wrapper.Standard.Standard_OStream

        """
        return _TDocStd.TDocStd_Modified_Dump(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _TDocStd.TDocStd_Modified_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _TDocStd.TDocStd_Modified_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TDocStd.TDocStd_Modified_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _TDocStd.delete_TDocStd_Modified
TDocStd_Modified_swigregister = _TDocStd.TDocStd_Modified_swigregister
TDocStd_Modified_swigregister(TDocStd_Modified)

def TDocStd_Modified_Add(*args):
    """
    TDocStd_Modified_Add(TDF_Label alabel) -> Standard_Boolean

    :type alabel: OCC.wrapper.TDF.TDF_Label
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _TDocStd.TDocStd_Modified_Add(*args)

def TDocStd_Modified_Remove(*args):
    """
    TDocStd_Modified_Remove(TDF_Label alabel) -> Standard_Boolean

    :type alabel: OCC.wrapper.TDF.TDF_Label
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _TDocStd.TDocStd_Modified_Remove(*args)

def TDocStd_Modified_Contains(*args):
    """
    TDocStd_Modified_Contains(TDF_Label alabel) -> Standard_Boolean

    :type alabel: OCC.wrapper.TDF.TDF_Label
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _TDocStd.TDocStd_Modified_Contains(*args)

def TDocStd_Modified_GetID(*args):
    """
    TDocStd_Modified_GetID() -> Standard_GUID

    Modified methods
    ================

    :rtype: OCC.wrapper.Standard.Standard_GUID

    """
    return _TDocStd.TDocStd_Modified_GetID(*args)

def TDocStd_Modified_get_type_name(*args):
    """
    TDocStd_Modified_get_type_name() -> char const *

    :rtype: const char *

    """
    return _TDocStd.TDocStd_Modified_get_type_name(*args)

def TDocStd_Modified_get_type_descriptor(*args):
    """
    TDocStd_Modified_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _TDocStd.TDocStd_Modified_get_type_descriptor(*args)

class Handle_TDocStd_Owner(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_TDocStd_Owner self)

        Nullify the handle


        """
        return _TDocStd.Handle_TDocStd_Owner_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_TDocStd_Owner self) -> bool

        Check for being null

        :rtype: bool

        """
        return _TDocStd.Handle_TDocStd_Owner_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_TDocStd_Owner self, TDocStd_Owner thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _TDocStd.Handle_TDocStd_Owner_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_TDocStd_Owner self, Handle_TDocStd_Owner theHandle) -> Handle_TDocStd_Owner
        assign(Handle_TDocStd_Owner self, TDocStd_Owner thePtr) -> Handle_TDocStd_Owner
        assign(Handle_TDocStd_Owner self, Handle_TDocStd_Owner theHandle) -> Handle_TDocStd_Owner

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _TDocStd.Handle_TDocStd_Owner_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_TDocStd_Owner self) -> TDocStd_Owner

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _TDocStd.Handle_TDocStd_Owner_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_TDocStd_Owner self) -> TDocStd_Owner

        Member access operator (note non-const)

        :rtype: T *

        """
        return _TDocStd.Handle_TDocStd_Owner___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_TDocStd_Owner self) -> TDocStd_Owner

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _TDocStd.Handle_TDocStd_Owner___ref__(self, *args)


    def __hash__(self):
        return _TDocStd.Handle_TDocStd_Owner___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _TDocStd.Handle_TDocStd_Owner___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _TDocStd.new_Handle_TDocStd_Owner(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_TDocStd.Handle_TDocStd_Owner_DownCast)
    __swig_destroy__ = _TDocStd.delete_Handle_TDocStd_Owner

    def GetID(self, *args):
        """
        class methods
        =============

        :rtype: OCC.wrapper.Standard.Standard_GUID

        """
        res = _TDocStd.Handle_TDocStd_Owner_GetID(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetDocument(self, *args):
        """
        SetDocument(Handle_TDocStd_Owner self, Handle_TDF_Data indata, Handle_TDocStd_Document doc)
        SetDocument(Handle_TDocStd_Owner self, Handle_TDocStd_Document document)

        :type document: OCC.wrapper.TDocStd.Handle_TDocStd_Document

        """
        return _TDocStd.Handle_TDocStd_Owner_SetDocument(self, *args)


    def GetDocument(self, *args):
        """
        GetDocument(Handle_TDocStd_Owner self, Handle_TDF_Data ofdata) -> Handle_TDocStd_Document
        GetDocument(Handle_TDocStd_Owner self) -> Handle_TDocStd_Document

        :rtype: OCC.wrapper.TDocStd.Handle_TDocStd_Document

        """
        return _TDocStd.Handle_TDocStd_Owner_GetDocument(self, *args)


    def ID(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Standard_GUID

        """
        res = _TDocStd.Handle_TDocStd_Owner_ID(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Restore(self, *args):
        """
        Restore(Handle_TDocStd_Owner self, Handle_TDF_Attribute With)

        :type With: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TDocStd.Handle_TDocStd_Owner_Restore(self, *args)


    def NewEmpty(self, *args):
        """
        NewEmpty(Handle_TDocStd_Owner self) -> Handle_TDF_Attribute

        :rtype: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TDocStd.Handle_TDocStd_Owner_NewEmpty(self, *args)


    def Paste(self, *args):
        """
        Paste(Handle_TDocStd_Owner self, Handle_TDF_Attribute Into, Handle_TDF_RelocationTable RT)

        :type Into: OCC.wrapper.TDF.Handle_TDF_Attribute
        :type RT: OCC.wrapper.TDF.Handle_TDF_RelocationTable

        """
        return _TDocStd.Handle_TDocStd_Owner_Paste(self, *args)


    def Dump(self, *args):
        """
        Dump(Handle_TDocStd_Owner self, Standard_OStream & anOS) -> Standard_OStream &

        :type anOS: OCC.wrapper.Standard.Standard_OStream
        :rtype: OCC.wrapper.Standard.Standard_OStream

        """
        return _TDocStd.Handle_TDocStd_Owner_Dump(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_TDocStd_Owner self) -> char const *

        :rtype: const char *

        """
        return _TDocStd.Handle_TDocStd_Owner_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TDocStd.Handle_TDocStd_Owner_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TDocStd.Handle_TDocStd_Owner_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetID(self, *args):
        """
        SetID(Handle_TDocStd_Owner self, Standard_GUID arg2)
        SetID(Handle_TDocStd_Owner self)

        Sets default ID defined in nested class (to be used for attributes having User ID feature).


        """
        return _TDocStd.Handle_TDocStd_Owner_SetID(self, *args)


    def Label(self, *args):
        """
        Label(Handle_TDocStd_Owner self) -> TDF_Label

        Returns   the   label to which  the   attribute is
        attached. If the  label is not  included in a  DF,
        the label is null. See Label.
        Warning
        If the label is not included in a data
        framework, it is null.
        This function should not be redefined inline.

        :rtype: OCC.wrapper.TDF.TDF_Label

        """
        return _TDocStd.Handle_TDocStd_Owner_Label(self, *args)


    def Transaction(self, *args):
        """
        Transaction(Handle_TDocStd_Owner self) -> Standard_Integer

        Returns the transaction index in which the
        attribute has been created or modified.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDocStd.Handle_TDocStd_Owner_Transaction(self, *args)


    def UntilTransaction(self, *args):
        """
        UntilTransaction(Handle_TDocStd_Owner self) -> Standard_Integer

        Returns the upper transaction index until which
        the attribute is/was valid. This number may
        vary. A removed attribute validity range is
        reduced to its transaction index.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDocStd.Handle_TDocStd_Owner_UntilTransaction(self, *args)


    def IsValid(self, *args):
        """
        IsValid(Handle_TDocStd_Owner self) -> Standard_Boolean

        Returns true if the attribute is valid; i.e. not a
        backuped or removed one.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDocStd.Handle_TDocStd_Owner_IsValid(self, *args)


    def IsNew(self, *args):
        """
        IsNew(Handle_TDocStd_Owner self) -> Standard_Boolean

        Returns true if the attribute has no backup

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDocStd.Handle_TDocStd_Owner_IsNew(self, *args)


    def IsForgotten(self, *args):
        """
        IsForgotten(Handle_TDocStd_Owner self) -> Standard_Boolean

        Returns true if the attribute forgotten status is
        set.

        ShortCut Methods concerning associated attributes
        =================================================

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDocStd.Handle_TDocStd_Owner_IsForgotten(self, *args)


    def IsAttribute(self, *args):
        """
        IsAttribute(Handle_TDocStd_Owner self, Standard_GUID anID) -> Standard_Boolean

        Returns true if it  exists an associated attribute
        of <me> with <anID> as ID.

        :type anID: OCC.wrapper.Standard.Standard_GUID
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDocStd.Handle_TDocStd_Owner_IsAttribute(self, *args)


    def FindAttribute(self, *args):
        """
        FindAttribute(Handle_TDocStd_Owner self, Standard_GUID anID, Handle_TDF_Attribute anAttribute) -> Standard_Boolean

        Finds an associated  attribute of  <me>, according
        to <anID>.  the returned <anAttribute> is a  valid
        one. The  method  returns  True if   found,  False
        otherwise.   A removed attribute  cannot be found using
        this  method.

        :type anID: OCC.wrapper.Standard.Standard_GUID
        :type anAttribute: OCC.wrapper.TDF.Handle_TDF_Attribute
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDocStd.Handle_TDocStd_Owner_FindAttribute(self, *args)


    def AddAttribute(self, *args):
        """
        AddAttribute(Handle_TDocStd_Owner self, Handle_TDF_Attribute other)

        Adds   an   Attribute <other>  to  the   label  of
        <me>.Raises if there is  already  one of the same
        GUID fhan <other>.

        :type other: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TDocStd.Handle_TDocStd_Owner_AddAttribute(self, *args)


    def ForgetAttribute(self, *args):
        """
        ForgetAttribute(Handle_TDocStd_Owner self, Standard_GUID aguid) -> Standard_Boolean

        Forgets  the Attribute of  GUID <aguid> associated
        to the label of <me>. Be  carefull that if <me> is
        the attribute of <guid>, <me> will have a null label
        after this call.  If  the attribute doesn't  exist
        returns False. Otherwise returns True.

        :type aguid: OCC.wrapper.Standard.Standard_GUID
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDocStd.Handle_TDocStd_Owner_ForgetAttribute(self, *args)


    def ForgetAllAttributes(self, *args):
        """
        ForgetAllAttributes(Handle_TDocStd_Owner self, Standard_Boolean const clearChildren)

        Forgets all the  attributes attached to  the label
        of <me>.    Does   it   on  the  sub-labels   if
        <clearChildren> is set  to true.  Of  course, this
        method  is  compatible with Transaction  &  Delta
        mecanisms. Be carefull  that  if <me> will have a
        null label after this call

        :type clearChildren: bool

        """
        return _TDocStd.Handle_TDocStd_Owner_ForgetAllAttributes(self, *args)


    def AfterAddition(self, *args):
        """
        AfterAddition(Handle_TDocStd_Owner self)

        Something to do after adding an Attribute to a label.


        """
        return _TDocStd.Handle_TDocStd_Owner_AfterAddition(self, *args)


    def BeforeRemoval(self, *args):
        """
        BeforeRemoval(Handle_TDocStd_Owner self)

        Something to do before removing an Attribute from
        a label.


        """
        return _TDocStd.Handle_TDocStd_Owner_BeforeRemoval(self, *args)


    def BeforeForget(self, *args):
        """
        BeforeForget(Handle_TDocStd_Owner self)

        Something to do before forgetting an Attribute to a
        label.


        """
        return _TDocStd.Handle_TDocStd_Owner_BeforeForget(self, *args)


    def AfterResume(self, *args):
        """
        AfterResume(Handle_TDocStd_Owner self)

        Something to do after resuming an Attribute from
        a label.


        """
        return _TDocStd.Handle_TDocStd_Owner_AfterResume(self, *args)


    def AfterRetrieval(self, *args):
        """
        AfterRetrieval(Handle_TDocStd_Owner self, Standard_Boolean const forceIt) -> Standard_Boolean

        Something to do AFTER creation of an attribute by
        persistent-transient translation. The returned
        status says if AfterUndo has been performed (true)
        or if this callback must be called once again
        further (false). If <forceIt> is set to true, the
        method MUST perform and return true. Does nothing
        by default and returns true.

        :type forceIt: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDocStd.Handle_TDocStd_Owner_AfterRetrieval(self, *args)


    def BeforeUndo(self, *args):
        """
        BeforeUndo(Handle_TDocStd_Owner self, Handle_TDF_AttributeDelta anAttDelta, Standard_Boolean const forceIt) -> Standard_Boolean

        Something to do before applying <anAttDelta>. The
        returned status says if AfterUndo has been
        performed (true) or if this callback must be
        called once again further (false). If <forceIt> is
        set to true, the method MUST perform and return
        true. Does nothing by default and returns true.

        :type anAttDelta: OCC.wrapper.TDF.Handle_TDF_AttributeDelta
        :type forceIt: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDocStd.Handle_TDocStd_Owner_BeforeUndo(self, *args)


    def AfterUndo(self, *args):
        """
        AfterUndo(Handle_TDocStd_Owner self, Handle_TDF_AttributeDelta anAttDelta, Standard_Boolean const forceIt) -> Standard_Boolean

        Something to do after applying <anAttDelta>. The
        returned status says if AfterUndo has been
        performed (true) or if this callback must be
        called once again further (false). If <forceIt> is
        set to true, the method MUST perform and return
        true. Does nothing by default and returns true.

        :type anAttDelta: OCC.wrapper.TDF.Handle_TDF_AttributeDelta
        :type forceIt: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDocStd.Handle_TDocStd_Owner_AfterUndo(self, *args)


    def BeforeCommitTransaction(self, *args):
        """
        BeforeCommitTransaction(Handle_TDocStd_Owner self)

        A callback.
        By default does nothing.
        It is called by TDF_Data::CommitTransaction() method.


        """
        return _TDocStd.Handle_TDocStd_Owner_BeforeCommitTransaction(self, *args)


    def Backup(self, *args):
        """
        Backup(Handle_TDocStd_Owner self)

        Backups the attribute. The backuped attribute is
        flagged "Backuped" and not "Valid".

        The method does nothing:

        1) If the attribute transaction number is equal to
        the current transaction number (the attribute has
        already been backuped).

        2) If the attribute is not attached to a label.


        """
        return _TDocStd.Handle_TDocStd_Owner_Backup(self, *args)


    def IsBackuped(self, *args):
        """
        IsBackuped(Handle_TDocStd_Owner self) -> Standard_Boolean

        Returns true if the attribute backup status is
        set. This status is set/unset by the
        Backup() method.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDocStd.Handle_TDocStd_Owner_IsBackuped(self, *args)


    def BackupCopy(self, *args):
        """
        BackupCopy(Handle_TDocStd_Owner self) -> Handle_TDF_Attribute

        Copies  the attribute  contents into  a  new other
        attribute. It is used by Backup().

        :rtype: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TDocStd.Handle_TDocStd_Owner_BackupCopy(self, *args)


    def DeltaOnAddition(self, *args):
        """
        DeltaOnAddition(Handle_TDocStd_Owner self) -> Handle_TDF_DeltaOnAddition

        Makes an AttributeDelta because <me>
        appeared. The only known use of a redefinition of
        this method is to return a null handle (no delta).

        :rtype: OCC.wrapper.TDF.Handle_TDF_DeltaOnAddition

        """
        return _TDocStd.Handle_TDocStd_Owner_DeltaOnAddition(self, *args)


    def DeltaOnForget(self, *args):
        """
        DeltaOnForget(Handle_TDocStd_Owner self) -> Handle_TDF_DeltaOnForget

        Makes an AttributeDelta because <me> has been
        forgotten.

        :rtype: OCC.wrapper.TDF.Handle_TDF_DeltaOnForget

        """
        return _TDocStd.Handle_TDocStd_Owner_DeltaOnForget(self, *args)


    def DeltaOnResume(self, *args):
        """
        DeltaOnResume(Handle_TDocStd_Owner self) -> Handle_TDF_DeltaOnResume

        Makes an AttributeDelta because <me> has been
        resumed.

        :rtype: OCC.wrapper.TDF.Handle_TDF_DeltaOnResume

        """
        return _TDocStd.Handle_TDocStd_Owner_DeltaOnResume(self, *args)


    def DeltaOnRemoval(self, *args):
        """
        DeltaOnRemoval(Handle_TDocStd_Owner self) -> Handle_TDF_DeltaOnRemoval

        Makes a DeltaOnRemoval on <me> because <me> has
        disappeared from the DS.

        :rtype: OCC.wrapper.TDF.Handle_TDF_DeltaOnRemoval

        """
        return _TDocStd.Handle_TDocStd_Owner_DeltaOnRemoval(self, *args)


    def References(self, *args):
        """
        References(Handle_TDocStd_Owner self, Handle_TDF_DataSet aDataSet)

        Adds the first level referenced attributes and labels
        to <aDataSet>.

        For this, use the AddLabel or AddAttribute of
        DataSet.

        If there is none, do not implement the method.

        :type aDataSet: OCC.wrapper.TDF.Handle_TDF_DataSet

        """
        return _TDocStd.Handle_TDocStd_Owner_References(self, *args)


    def __lshift__(self, *args):
        """
        __lshift__(Handle_TDocStd_Owner self, Standard_OStream & anOS) -> Standard_OStream &

        :type anOS: OCC.wrapper.Standard.Standard_OStream
        :rtype: OCC.wrapper.Standard.Standard_OStream

        """
        return _TDocStd.Handle_TDocStd_Owner___lshift__(self, *args)


    def ExtendedDump(self, *args):
        """
        ExtendedDump(Handle_TDocStd_Owner self, Standard_OStream & anOS, TDF_IDFilter aFilter, NCollection_IndexedMap_Handle_TDF_Attribute_TColStd_MapTransientHasher aMap)

        Dumps the attribute content on <aStream>, using
        <aMap> like this: if an attribute is not in the
        map, first put add it to the map and then dump it.
        Use the map rank instead of dumping each attribute
        field.

        :type anOS: OCC.wrapper.Standard.Standard_OStream
        :type aFilter: OCC.wrapper.TDF.TDF_IDFilter
        :type aMap: OCC.wrapper.TDF.TDF_AttributeIndexedMap

        """
        return _TDocStd.Handle_TDocStd_Owner_ExtendedDump(self, *args)


    def Forget(self, *args):
        """
        Forget(Handle_TDocStd_Owner self, Standard_Integer const aTransaction)

        Forgets the attribute. <aTransaction> is the
        current transaction in which the forget is done. A
        forgotten attribute is also flagged not "Valid".

        A forgotten attribute is invisible. Set also the
        "Valid" status to False. Obvioulsy, DF cannot
        empty an attribute (this has a semantic
        signification), but can remove it from the
        structure. So, a forgotten attribute is NOT an empty
        one, but a soon DEAD one.

        Should be private.

        :type aTransaction: int

        """
        return _TDocStd.Handle_TDocStd_Owner_Forget(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_TDocStd_Owner self)

        Memory deallocator for transient classes


        """
        return _TDocStd.Handle_TDocStd_Owner_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_TDocStd_Owner self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_TDocStd_Owner self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDocStd.Handle_TDocStd_Owner_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_TDocStd_Owner self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_TDocStd_Owner self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDocStd.Handle_TDocStd_Owner_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_TDocStd_Owner self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _TDocStd.Handle_TDocStd_Owner_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_TDocStd_Owner self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDocStd.Handle_TDocStd_Owner_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_TDocStd_Owner self)

        Increments the reference counter of this object


        """
        return _TDocStd.Handle_TDocStd_Owner_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_TDocStd_Owner self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDocStd.Handle_TDocStd_Owner_DecrementRefCounter(self, *args)

Handle_TDocStd_Owner_swigregister = _TDocStd.Handle_TDocStd_Owner_swigregister
Handle_TDocStd_Owner_swigregister(Handle_TDocStd_Owner)

def Handle_TDocStd_Owner_DownCast(thing):
    return _TDocStd.Handle_TDocStd_Owner_DownCast(thing)
Handle_TDocStd_Owner_DownCast = _TDocStd.Handle_TDocStd_Owner_DownCast

class TDocStd_XLinkIterator(object):
    """
    Iterates on Reference attributes.
    This is an iterator giving all the external references
    of a Document.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(TDocStd_XLinkIterator self) -> TDocStd_XLinkIterator
        __init__(TDocStd_XLinkIterator self, Handle_TDocStd_Document D) -> TDocStd_XLinkIterator

        Creates an iterator on Reference of <D>.

        :type D: OCC.wrapper.TDocStd.Handle_TDocStd_Document

        """
        this = _TDocStd.new_TDocStd_XLinkIterator(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Initialize(self, *args):
        """
        Initialize(TDocStd_XLinkIterator self, Handle_TDocStd_Document D)

        Restarts an iteration with <D>.

        :type D: OCC.wrapper.TDocStd.Handle_TDocStd_Document

        """
        return _TDocStd.TDocStd_XLinkIterator_Initialize(self, *args)


    def More(self, *args):
        """
        More(TDocStd_XLinkIterator self) -> Standard_Boolean

        Returns True if there is a current Item in the
        iteration.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDocStd.TDocStd_XLinkIterator_More(self, *args)


    def Next(self, *args):
        """
        Next(TDocStd_XLinkIterator self)

        Move to the next item; raises if there is no more item.


        """
        return _TDocStd.TDocStd_XLinkIterator_Next(self, *args)


    def Value(self, *args):
        """
        Value(TDocStd_XLinkIterator self) -> TDocStd_XLink

        Returns the current item; a null handle if there is none.

        :rtype: OCC.wrapper.TDocStd.TDocStd_XLinkPtr

        """
        return _TDocStd.TDocStd_XLinkIterator_Value(self, *args)

    __swig_destroy__ = _TDocStd.delete_TDocStd_XLinkIterator
TDocStd_XLinkIterator_swigregister = _TDocStd.TDocStd_XLinkIterator_swigregister
TDocStd_XLinkIterator_swigregister(TDocStd_XLinkIterator)

class Handle_TDocStd_XLinkRoot(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_TDocStd_XLinkRoot self)

        Nullify the handle


        """
        return _TDocStd.Handle_TDocStd_XLinkRoot_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_TDocStd_XLinkRoot self) -> bool

        Check for being null

        :rtype: bool

        """
        return _TDocStd.Handle_TDocStd_XLinkRoot_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_TDocStd_XLinkRoot self, TDocStd_XLinkRoot thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _TDocStd.Handle_TDocStd_XLinkRoot_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_TDocStd_XLinkRoot self, Handle_TDocStd_XLinkRoot theHandle) -> Handle_TDocStd_XLinkRoot
        assign(Handle_TDocStd_XLinkRoot self, TDocStd_XLinkRoot thePtr) -> Handle_TDocStd_XLinkRoot
        assign(Handle_TDocStd_XLinkRoot self, Handle_TDocStd_XLinkRoot theHandle) -> Handle_TDocStd_XLinkRoot

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _TDocStd.Handle_TDocStd_XLinkRoot_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_TDocStd_XLinkRoot self) -> TDocStd_XLinkRoot

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _TDocStd.Handle_TDocStd_XLinkRoot_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_TDocStd_XLinkRoot self) -> TDocStd_XLinkRoot

        Member access operator (note non-const)

        :rtype: T *

        """
        return _TDocStd.Handle_TDocStd_XLinkRoot___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_TDocStd_XLinkRoot self) -> TDocStd_XLinkRoot

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _TDocStd.Handle_TDocStd_XLinkRoot___ref__(self, *args)


    def __hash__(self):
        return _TDocStd.Handle_TDocStd_XLinkRoot___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _TDocStd.Handle_TDocStd_XLinkRoot___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _TDocStd.new_Handle_TDocStd_XLinkRoot(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_TDocStd.Handle_TDocStd_XLinkRoot_DownCast)
    __swig_destroy__ = _TDocStd.delete_Handle_TDocStd_XLinkRoot

    def GetID(self, *args):
        """
        Returns the ID: 2a96b61d-ec8b-11d0-bee7-080009dc3333

        :rtype: OCC.wrapper.Standard.Standard_GUID

        """
        res = _TDocStd.Handle_TDocStd_XLinkRoot_GetID(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Set(self, *args):
        """
        Set(Handle_TDocStd_XLinkRoot self, Handle_TDF_Data aDF) -> Handle_TDocStd_XLinkRoot

        Sets an empty XLinkRoot to Root or gets the
        existing one. Only one attribute per TDF_Data.

        :type aDF: OCC.wrapper.TDF.Handle_TDF_Data
        :rtype: OCC.wrapper.TDocStd.Handle_TDocStd_XLinkRoot

        """
        return _TDocStd.Handle_TDocStd_XLinkRoot_Set(self, *args)


    def Insert(self, *args):
        """
        Insert(Handle_TDocStd_XLinkRoot self, TDocStd_XLink anXLinkPtr)

        Inserts <anXLinkPtr> at the beginning of the XLink chain.

        :type anXLinkPtr: OCC.wrapper.TDocStd.TDocStd_XLinkPtr

        """
        return _TDocStd.Handle_TDocStd_XLinkRoot_Insert(self, *args)


    def Remove(self, *args):
        """
        Remove(Handle_TDocStd_XLinkRoot self, TDocStd_XLink anXLinkPtr)

        Removes <anXLinkPtr> from the XLink chain, if it exists.

        :type anXLinkPtr: OCC.wrapper.TDocStd.TDocStd_XLinkPtr

        """
        return _TDocStd.Handle_TDocStd_XLinkRoot_Remove(self, *args)


    def ID(self, *args):
        """
        Returns the ID of the attribute.

        :rtype: OCC.wrapper.Standard.Standard_GUID

        """
        res = _TDocStd.Handle_TDocStd_XLinkRoot_ID(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def BackupCopy(self, *args):
        """
        BackupCopy(Handle_TDocStd_XLinkRoot self) -> Handle_TDF_Attribute

        Returns a null handle.

        :rtype: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TDocStd.Handle_TDocStd_XLinkRoot_BackupCopy(self, *args)


    def Restore(self, *args):
        """
        Restore(Handle_TDocStd_XLinkRoot self, Handle_TDF_Attribute anAttribute)

        Does nothing.

        :type anAttribute: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TDocStd.Handle_TDocStd_XLinkRoot_Restore(self, *args)


    def NewEmpty(self, *args):
        """
        NewEmpty(Handle_TDocStd_XLinkRoot self) -> Handle_TDF_Attribute

        Returns a null handle.

        :rtype: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TDocStd.Handle_TDocStd_XLinkRoot_NewEmpty(self, *args)


    def Paste(self, *args):
        """
        Paste(Handle_TDocStd_XLinkRoot self, Handle_TDF_Attribute intoAttribute, Handle_TDF_RelocationTable aRelocationTable)

        Does nothing.

        :type intoAttribute: OCC.wrapper.TDF.Handle_TDF_Attribute
        :type aRelocationTable: OCC.wrapper.TDF.Handle_TDF_RelocationTable

        """
        return _TDocStd.Handle_TDocStd_XLinkRoot_Paste(self, *args)


    def Dump(self, *args):
        """
        Dump(Handle_TDocStd_XLinkRoot self, Standard_OStream & anOS) -> Standard_OStream &

        Dumps the attribute on <aStream>.

        :type anOS: OCC.wrapper.Standard.Standard_OStream
        :rtype: OCC.wrapper.Standard.Standard_OStream

        """
        return _TDocStd.Handle_TDocStd_XLinkRoot_Dump(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_TDocStd_XLinkRoot self) -> char const *

        :rtype: const char *

        """
        return _TDocStd.Handle_TDocStd_XLinkRoot_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TDocStd.Handle_TDocStd_XLinkRoot_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TDocStd.Handle_TDocStd_XLinkRoot_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetID(self, *args):
        """
        SetID(Handle_TDocStd_XLinkRoot self, Standard_GUID arg2)
        SetID(Handle_TDocStd_XLinkRoot self)

        Sets default ID defined in nested class (to be used for attributes having User ID feature).


        """
        return _TDocStd.Handle_TDocStd_XLinkRoot_SetID(self, *args)


    def Label(self, *args):
        """
        Label(Handle_TDocStd_XLinkRoot self) -> TDF_Label

        Returns   the   label to which  the   attribute is
        attached. If the  label is not  included in a  DF,
        the label is null. See Label.
        Warning
        If the label is not included in a data
        framework, it is null.
        This function should not be redefined inline.

        :rtype: OCC.wrapper.TDF.TDF_Label

        """
        return _TDocStd.Handle_TDocStd_XLinkRoot_Label(self, *args)


    def Transaction(self, *args):
        """
        Transaction(Handle_TDocStd_XLinkRoot self) -> Standard_Integer

        Returns the transaction index in which the
        attribute has been created or modified.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDocStd.Handle_TDocStd_XLinkRoot_Transaction(self, *args)


    def UntilTransaction(self, *args):
        """
        UntilTransaction(Handle_TDocStd_XLinkRoot self) -> Standard_Integer

        Returns the upper transaction index until which
        the attribute is/was valid. This number may
        vary. A removed attribute validity range is
        reduced to its transaction index.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDocStd.Handle_TDocStd_XLinkRoot_UntilTransaction(self, *args)


    def IsValid(self, *args):
        """
        IsValid(Handle_TDocStd_XLinkRoot self) -> Standard_Boolean

        Returns true if the attribute is valid; i.e. not a
        backuped or removed one.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDocStd.Handle_TDocStd_XLinkRoot_IsValid(self, *args)


    def IsNew(self, *args):
        """
        IsNew(Handle_TDocStd_XLinkRoot self) -> Standard_Boolean

        Returns true if the attribute has no backup

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDocStd.Handle_TDocStd_XLinkRoot_IsNew(self, *args)


    def IsForgotten(self, *args):
        """
        IsForgotten(Handle_TDocStd_XLinkRoot self) -> Standard_Boolean

        Returns true if the attribute forgotten status is
        set.

        ShortCut Methods concerning associated attributes
        =================================================

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDocStd.Handle_TDocStd_XLinkRoot_IsForgotten(self, *args)


    def IsAttribute(self, *args):
        """
        IsAttribute(Handle_TDocStd_XLinkRoot self, Standard_GUID anID) -> Standard_Boolean

        Returns true if it  exists an associated attribute
        of <me> with <anID> as ID.

        :type anID: OCC.wrapper.Standard.Standard_GUID
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDocStd.Handle_TDocStd_XLinkRoot_IsAttribute(self, *args)


    def FindAttribute(self, *args):
        """
        FindAttribute(Handle_TDocStd_XLinkRoot self, Standard_GUID anID, Handle_TDF_Attribute anAttribute) -> Standard_Boolean

        Finds an associated  attribute of  <me>, according
        to <anID>.  the returned <anAttribute> is a  valid
        one. The  method  returns  True if   found,  False
        otherwise.   A removed attribute  cannot be found using
        this  method.

        :type anID: OCC.wrapper.Standard.Standard_GUID
        :type anAttribute: OCC.wrapper.TDF.Handle_TDF_Attribute
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDocStd.Handle_TDocStd_XLinkRoot_FindAttribute(self, *args)


    def AddAttribute(self, *args):
        """
        AddAttribute(Handle_TDocStd_XLinkRoot self, Handle_TDF_Attribute other)

        Adds   an   Attribute <other>  to  the   label  of
        <me>.Raises if there is  already  one of the same
        GUID fhan <other>.

        :type other: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TDocStd.Handle_TDocStd_XLinkRoot_AddAttribute(self, *args)


    def ForgetAttribute(self, *args):
        """
        ForgetAttribute(Handle_TDocStd_XLinkRoot self, Standard_GUID aguid) -> Standard_Boolean

        Forgets  the Attribute of  GUID <aguid> associated
        to the label of <me>. Be  carefull that if <me> is
        the attribute of <guid>, <me> will have a null label
        after this call.  If  the attribute doesn't  exist
        returns False. Otherwise returns True.

        :type aguid: OCC.wrapper.Standard.Standard_GUID
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDocStd.Handle_TDocStd_XLinkRoot_ForgetAttribute(self, *args)


    def ForgetAllAttributes(self, *args):
        """
        ForgetAllAttributes(Handle_TDocStd_XLinkRoot self, Standard_Boolean const clearChildren)

        Forgets all the  attributes attached to  the label
        of <me>.    Does   it   on  the  sub-labels   if
        <clearChildren> is set  to true.  Of  course, this
        method  is  compatible with Transaction  &  Delta
        mecanisms. Be carefull  that  if <me> will have a
        null label after this call

        :type clearChildren: bool

        """
        return _TDocStd.Handle_TDocStd_XLinkRoot_ForgetAllAttributes(self, *args)


    def AfterAddition(self, *args):
        """
        AfterAddition(Handle_TDocStd_XLinkRoot self)

        Something to do after adding an Attribute to a label.


        """
        return _TDocStd.Handle_TDocStd_XLinkRoot_AfterAddition(self, *args)


    def BeforeRemoval(self, *args):
        """
        BeforeRemoval(Handle_TDocStd_XLinkRoot self)

        Something to do before removing an Attribute from
        a label.


        """
        return _TDocStd.Handle_TDocStd_XLinkRoot_BeforeRemoval(self, *args)


    def BeforeForget(self, *args):
        """
        BeforeForget(Handle_TDocStd_XLinkRoot self)

        Something to do before forgetting an Attribute to a
        label.


        """
        return _TDocStd.Handle_TDocStd_XLinkRoot_BeforeForget(self, *args)


    def AfterResume(self, *args):
        """
        AfterResume(Handle_TDocStd_XLinkRoot self)

        Something to do after resuming an Attribute from
        a label.


        """
        return _TDocStd.Handle_TDocStd_XLinkRoot_AfterResume(self, *args)


    def AfterRetrieval(self, *args):
        """
        AfterRetrieval(Handle_TDocStd_XLinkRoot self, Standard_Boolean const forceIt) -> Standard_Boolean

        Something to do AFTER creation of an attribute by
        persistent-transient translation. The returned
        status says if AfterUndo has been performed (true)
        or if this callback must be called once again
        further (false). If <forceIt> is set to true, the
        method MUST perform and return true. Does nothing
        by default and returns true.

        :type forceIt: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDocStd.Handle_TDocStd_XLinkRoot_AfterRetrieval(self, *args)


    def BeforeUndo(self, *args):
        """
        BeforeUndo(Handle_TDocStd_XLinkRoot self, Handle_TDF_AttributeDelta anAttDelta, Standard_Boolean const forceIt) -> Standard_Boolean

        Something to do before applying <anAttDelta>. The
        returned status says if AfterUndo has been
        performed (true) or if this callback must be
        called once again further (false). If <forceIt> is
        set to true, the method MUST perform and return
        true. Does nothing by default and returns true.

        :type anAttDelta: OCC.wrapper.TDF.Handle_TDF_AttributeDelta
        :type forceIt: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDocStd.Handle_TDocStd_XLinkRoot_BeforeUndo(self, *args)


    def AfterUndo(self, *args):
        """
        AfterUndo(Handle_TDocStd_XLinkRoot self, Handle_TDF_AttributeDelta anAttDelta, Standard_Boolean const forceIt) -> Standard_Boolean

        Something to do after applying <anAttDelta>. The
        returned status says if AfterUndo has been
        performed (true) or if this callback must be
        called once again further (false). If <forceIt> is
        set to true, the method MUST perform and return
        true. Does nothing by default and returns true.

        :type anAttDelta: OCC.wrapper.TDF.Handle_TDF_AttributeDelta
        :type forceIt: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDocStd.Handle_TDocStd_XLinkRoot_AfterUndo(self, *args)


    def BeforeCommitTransaction(self, *args):
        """
        BeforeCommitTransaction(Handle_TDocStd_XLinkRoot self)

        A callback.
        By default does nothing.
        It is called by TDF_Data::CommitTransaction() method.


        """
        return _TDocStd.Handle_TDocStd_XLinkRoot_BeforeCommitTransaction(self, *args)


    def Backup(self, *args):
        """
        Backup(Handle_TDocStd_XLinkRoot self)

        Backups the attribute. The backuped attribute is
        flagged "Backuped" and not "Valid".

        The method does nothing:

        1) If the attribute transaction number is equal to
        the current transaction number (the attribute has
        already been backuped).

        2) If the attribute is not attached to a label.


        """
        return _TDocStd.Handle_TDocStd_XLinkRoot_Backup(self, *args)


    def IsBackuped(self, *args):
        """
        IsBackuped(Handle_TDocStd_XLinkRoot self) -> Standard_Boolean

        Returns true if the attribute backup status is
        set. This status is set/unset by the
        Backup() method.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDocStd.Handle_TDocStd_XLinkRoot_IsBackuped(self, *args)


    def DeltaOnAddition(self, *args):
        """
        DeltaOnAddition(Handle_TDocStd_XLinkRoot self) -> Handle_TDF_DeltaOnAddition

        Makes an AttributeDelta because <me>
        appeared. The only known use of a redefinition of
        this method is to return a null handle (no delta).

        :rtype: OCC.wrapper.TDF.Handle_TDF_DeltaOnAddition

        """
        return _TDocStd.Handle_TDocStd_XLinkRoot_DeltaOnAddition(self, *args)


    def DeltaOnForget(self, *args):
        """
        DeltaOnForget(Handle_TDocStd_XLinkRoot self) -> Handle_TDF_DeltaOnForget

        Makes an AttributeDelta because <me> has been
        forgotten.

        :rtype: OCC.wrapper.TDF.Handle_TDF_DeltaOnForget

        """
        return _TDocStd.Handle_TDocStd_XLinkRoot_DeltaOnForget(self, *args)


    def DeltaOnResume(self, *args):
        """
        DeltaOnResume(Handle_TDocStd_XLinkRoot self) -> Handle_TDF_DeltaOnResume

        Makes an AttributeDelta because <me> has been
        resumed.

        :rtype: OCC.wrapper.TDF.Handle_TDF_DeltaOnResume

        """
        return _TDocStd.Handle_TDocStd_XLinkRoot_DeltaOnResume(self, *args)


    def DeltaOnRemoval(self, *args):
        """
        DeltaOnRemoval(Handle_TDocStd_XLinkRoot self) -> Handle_TDF_DeltaOnRemoval

        Makes a DeltaOnRemoval on <me> because <me> has
        disappeared from the DS.

        :rtype: OCC.wrapper.TDF.Handle_TDF_DeltaOnRemoval

        """
        return _TDocStd.Handle_TDocStd_XLinkRoot_DeltaOnRemoval(self, *args)


    def References(self, *args):
        """
        References(Handle_TDocStd_XLinkRoot self, Handle_TDF_DataSet aDataSet)

        Adds the first level referenced attributes and labels
        to <aDataSet>.

        For this, use the AddLabel or AddAttribute of
        DataSet.

        If there is none, do not implement the method.

        :type aDataSet: OCC.wrapper.TDF.Handle_TDF_DataSet

        """
        return _TDocStd.Handle_TDocStd_XLinkRoot_References(self, *args)


    def __lshift__(self, *args):
        """
        __lshift__(Handle_TDocStd_XLinkRoot self, Standard_OStream & anOS) -> Standard_OStream &

        :type anOS: OCC.wrapper.Standard.Standard_OStream
        :rtype: OCC.wrapper.Standard.Standard_OStream

        """
        return _TDocStd.Handle_TDocStd_XLinkRoot___lshift__(self, *args)


    def ExtendedDump(self, *args):
        """
        ExtendedDump(Handle_TDocStd_XLinkRoot self, Standard_OStream & anOS, TDF_IDFilter aFilter, NCollection_IndexedMap_Handle_TDF_Attribute_TColStd_MapTransientHasher aMap)

        Dumps the attribute content on <aStream>, using
        <aMap> like this: if an attribute is not in the
        map, first put add it to the map and then dump it.
        Use the map rank instead of dumping each attribute
        field.

        :type anOS: OCC.wrapper.Standard.Standard_OStream
        :type aFilter: OCC.wrapper.TDF.TDF_IDFilter
        :type aMap: OCC.wrapper.TDF.TDF_AttributeIndexedMap

        """
        return _TDocStd.Handle_TDocStd_XLinkRoot_ExtendedDump(self, *args)


    def Forget(self, *args):
        """
        Forget(Handle_TDocStd_XLinkRoot self, Standard_Integer const aTransaction)

        Forgets the attribute. <aTransaction> is the
        current transaction in which the forget is done. A
        forgotten attribute is also flagged not "Valid".

        A forgotten attribute is invisible. Set also the
        "Valid" status to False. Obvioulsy, DF cannot
        empty an attribute (this has a semantic
        signification), but can remove it from the
        structure. So, a forgotten attribute is NOT an empty
        one, but a soon DEAD one.

        Should be private.

        :type aTransaction: int

        """
        return _TDocStd.Handle_TDocStd_XLinkRoot_Forget(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_TDocStd_XLinkRoot self)

        Memory deallocator for transient classes


        """
        return _TDocStd.Handle_TDocStd_XLinkRoot_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_TDocStd_XLinkRoot self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_TDocStd_XLinkRoot self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDocStd.Handle_TDocStd_XLinkRoot_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_TDocStd_XLinkRoot self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_TDocStd_XLinkRoot self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDocStd.Handle_TDocStd_XLinkRoot_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_TDocStd_XLinkRoot self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _TDocStd.Handle_TDocStd_XLinkRoot_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_TDocStd_XLinkRoot self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDocStd.Handle_TDocStd_XLinkRoot_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_TDocStd_XLinkRoot self)

        Increments the reference counter of this object


        """
        return _TDocStd.Handle_TDocStd_XLinkRoot_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_TDocStd_XLinkRoot self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDocStd.Handle_TDocStd_XLinkRoot_DecrementRefCounter(self, *args)

Handle_TDocStd_XLinkRoot_swigregister = _TDocStd.Handle_TDocStd_XLinkRoot_swigregister
Handle_TDocStd_XLinkRoot_swigregister(Handle_TDocStd_XLinkRoot)

def Handle_TDocStd_XLinkRoot_DownCast(thing):
    return _TDocStd.Handle_TDocStd_XLinkRoot_DownCast(thing)
Handle_TDocStd_XLinkRoot_DownCast = _TDocStd.Handle_TDocStd_XLinkRoot_DownCast

class TDocStd_(object):
    """
    This package define  CAF main classes.

    * The standard application root class

    * The standard document wich contains data

    * The external reference mechanism between documents

    * Attributes for Document management
    Standard documents offer you a ready-to-use
    document containing a TDF-based data
    structure. The documents themselves are
    contained in a class inheriting from
    TDocStd_Application which manages creation,
    storage and retrieval of documents.
    You can implement undo and redo in your
    document, and refer from the data framework of
    one document to that of another one. This is
    done by means of external link attributes, which
    store the path and the entry of external links. To
    sum up, standard documents alone provide
    access to the data framework. They also allow
    you to:
    -   Update external links
    -   Manage the saving and opening of data
    -   Manage undo/redo functionality.
    Note
    For information on the relations between this
    component of OCAF and the others, refer to the
    OCAF User's Guide.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def IDList(*args):
        """
        IDList(NCollection_List_Standard_GUID anIDList)

        specific GUID of this package
        =============================
        Appends to <anIDList> the list of the attributes
        IDs of this package. CAUTION: <anIDList> is NOT
        cleared before use.

        :type anIDList: OCC.wrapper.TDF.TDF_IDList

        """
        return _TDocStd.TDocStd__IDList(*args)

    IDList = staticmethod(IDList)

    def __init__(self):
        """
        This package define  CAF main classes.

        * The standard application root class

        * The standard document wich contains data

        * The external reference mechanism between documents

        * Attributes for Document management
        Standard documents offer you a ready-to-use
        document containing a TDF-based data
        structure. The documents themselves are
        contained in a class inheriting from
        TDocStd_Application which manages creation,
        storage and retrieval of documents.
        You can implement undo and redo in your
        document, and refer from the data framework of
        one document to that of another one. This is
        done by means of external link attributes, which
        store the path and the entry of external links. To
        sum up, standard documents alone provide
        access to the data framework. They also allow
        you to:
        -   Update external links
        -   Manage the saving and opening of data
        -   Manage undo/redo functionality.
        Note
        For information on the relations between this
        component of OCAF and the others, refer to the
        OCAF User's Guide.
        """
        this = _TDocStd.new_TDocStd_()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _TDocStd.delete_TDocStd_
TDocStd__swigregister = _TDocStd.TDocStd__swigregister
TDocStd__swigregister(TDocStd_)

def TDocStd__IDList(*args):
    """
    TDocStd__IDList(NCollection_List_Standard_GUID anIDList)

    specific GUID of this package
    =============================
    Appends to <anIDList> the list of the attributes
    IDs of this package. CAUTION: <anIDList> is NOT
    cleared before use.

    :type anIDList: OCC.wrapper.TDF.TDF_IDList

    """
    return _TDocStd.TDocStd__IDList(*args)

class Handle_TDocStd_Modified(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_TDocStd_Modified self)

        Nullify the handle


        """
        return _TDocStd.Handle_TDocStd_Modified_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_TDocStd_Modified self) -> bool

        Check for being null

        :rtype: bool

        """
        return _TDocStd.Handle_TDocStd_Modified_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_TDocStd_Modified self, TDocStd_Modified thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _TDocStd.Handle_TDocStd_Modified_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_TDocStd_Modified self, Handle_TDocStd_Modified theHandle) -> Handle_TDocStd_Modified
        assign(Handle_TDocStd_Modified self, TDocStd_Modified thePtr) -> Handle_TDocStd_Modified
        assign(Handle_TDocStd_Modified self, Handle_TDocStd_Modified theHandle) -> Handle_TDocStd_Modified

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _TDocStd.Handle_TDocStd_Modified_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_TDocStd_Modified self) -> TDocStd_Modified

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _TDocStd.Handle_TDocStd_Modified_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_TDocStd_Modified self) -> TDocStd_Modified

        Member access operator (note non-const)

        :rtype: T *

        """
        return _TDocStd.Handle_TDocStd_Modified___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_TDocStd_Modified self) -> TDocStd_Modified

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _TDocStd.Handle_TDocStd_Modified___ref__(self, *args)


    def __hash__(self):
        return _TDocStd.Handle_TDocStd_Modified___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _TDocStd.Handle_TDocStd_Modified___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _TDocStd.new_Handle_TDocStd_Modified(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_TDocStd.Handle_TDocStd_Modified_DownCast)
    __swig_destroy__ = _TDocStd.delete_Handle_TDocStd_Modified

    def IsEmpty(self, *args):
        """
        IsEmpty(Handle_TDocStd_Modified self, TDF_Label access) -> Standard_Boolean
        IsEmpty(Handle_TDocStd_Modified self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDocStd.Handle_TDocStd_Modified_IsEmpty(self, *args)


    def Add(self, *args):
        """
        Add(Handle_TDocStd_Modified self, TDF_Label alabel) -> Standard_Boolean

        :type alabel: OCC.wrapper.TDF.TDF_Label
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDocStd.Handle_TDocStd_Modified_Add(self, *args)


    def Remove(self, *args):
        """
        Remove(Handle_TDocStd_Modified self, TDF_Label alabel) -> Standard_Boolean

        :type alabel: OCC.wrapper.TDF.TDF_Label
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDocStd.Handle_TDocStd_Modified_Remove(self, *args)


    def Contains(self, *args):
        """
        Contains(Handle_TDocStd_Modified self, TDF_Label alabel) -> Standard_Boolean

        :type alabel: OCC.wrapper.TDF.TDF_Label
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDocStd.Handle_TDocStd_Modified_Contains(self, *args)


    def Get(self, *args):
        """
        returns modified label map

        :rtype: OCC.wrapper.TDF.TDF_LabelMap

        """
        res = _TDocStd.Handle_TDocStd_Modified_Get(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Clear(self, *args):
        """
        Clear(Handle_TDocStd_Modified self, TDF_Label access)
        Clear(Handle_TDocStd_Modified self)

        remove all modified labels. becomes empty

        :type access: OCC.wrapper.TDF.TDF_Label

        """
        return _TDocStd.Handle_TDocStd_Modified_Clear(self, *args)


    def GetID(self, *args):
        """
        Modified methods
        ================

        :rtype: OCC.wrapper.Standard.Standard_GUID

        """
        res = _TDocStd.Handle_TDocStd_Modified_GetID(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def AddLabel(self, *args):
        """
        AddLabel(Handle_TDocStd_Modified self, TDF_Label L) -> Standard_Boolean

        add <L> as modified

        :type L: OCC.wrapper.TDF.TDF_Label
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDocStd.Handle_TDocStd_Modified_AddLabel(self, *args)


    def RemoveLabel(self, *args):
        """
        RemoveLabel(Handle_TDocStd_Modified self, TDF_Label L) -> Standard_Boolean

        remove  <L> as modified

        :type L: OCC.wrapper.TDF.TDF_Label
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDocStd.Handle_TDocStd_Modified_RemoveLabel(self, *args)


    def ID(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Standard_GUID

        """
        res = _TDocStd.Handle_TDocStd_Modified_ID(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Restore(self, *args):
        """
        Restore(Handle_TDocStd_Modified self, Handle_TDF_Attribute With)

        :type With: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TDocStd.Handle_TDocStd_Modified_Restore(self, *args)


    def NewEmpty(self, *args):
        """
        NewEmpty(Handle_TDocStd_Modified self) -> Handle_TDF_Attribute

        :rtype: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TDocStd.Handle_TDocStd_Modified_NewEmpty(self, *args)


    def Paste(self, *args):
        """
        Paste(Handle_TDocStd_Modified self, Handle_TDF_Attribute Into, Handle_TDF_RelocationTable RT)

        :type Into: OCC.wrapper.TDF.Handle_TDF_Attribute
        :type RT: OCC.wrapper.TDF.Handle_TDF_RelocationTable

        """
        return _TDocStd.Handle_TDocStd_Modified_Paste(self, *args)


    def Dump(self, *args):
        """
        Dump(Handle_TDocStd_Modified self, Standard_OStream & anOS) -> Standard_OStream &

        :type anOS: OCC.wrapper.Standard.Standard_OStream
        :rtype: OCC.wrapper.Standard.Standard_OStream

        """
        return _TDocStd.Handle_TDocStd_Modified_Dump(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_TDocStd_Modified self) -> char const *

        :rtype: const char *

        """
        return _TDocStd.Handle_TDocStd_Modified_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TDocStd.Handle_TDocStd_Modified_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TDocStd.Handle_TDocStd_Modified_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetID(self, *args):
        """
        SetID(Handle_TDocStd_Modified self, Standard_GUID arg2)
        SetID(Handle_TDocStd_Modified self)

        Sets default ID defined in nested class (to be used for attributes having User ID feature).


        """
        return _TDocStd.Handle_TDocStd_Modified_SetID(self, *args)


    def Label(self, *args):
        """
        Label(Handle_TDocStd_Modified self) -> TDF_Label

        Returns   the   label to which  the   attribute is
        attached. If the  label is not  included in a  DF,
        the label is null. See Label.
        Warning
        If the label is not included in a data
        framework, it is null.
        This function should not be redefined inline.

        :rtype: OCC.wrapper.TDF.TDF_Label

        """
        return _TDocStd.Handle_TDocStd_Modified_Label(self, *args)


    def Transaction(self, *args):
        """
        Transaction(Handle_TDocStd_Modified self) -> Standard_Integer

        Returns the transaction index in which the
        attribute has been created or modified.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDocStd.Handle_TDocStd_Modified_Transaction(self, *args)


    def UntilTransaction(self, *args):
        """
        UntilTransaction(Handle_TDocStd_Modified self) -> Standard_Integer

        Returns the upper transaction index until which
        the attribute is/was valid. This number may
        vary. A removed attribute validity range is
        reduced to its transaction index.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDocStd.Handle_TDocStd_Modified_UntilTransaction(self, *args)


    def IsValid(self, *args):
        """
        IsValid(Handle_TDocStd_Modified self) -> Standard_Boolean

        Returns true if the attribute is valid; i.e. not a
        backuped or removed one.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDocStd.Handle_TDocStd_Modified_IsValid(self, *args)


    def IsNew(self, *args):
        """
        IsNew(Handle_TDocStd_Modified self) -> Standard_Boolean

        Returns true if the attribute has no backup

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDocStd.Handle_TDocStd_Modified_IsNew(self, *args)


    def IsForgotten(self, *args):
        """
        IsForgotten(Handle_TDocStd_Modified self) -> Standard_Boolean

        Returns true if the attribute forgotten status is
        set.

        ShortCut Methods concerning associated attributes
        =================================================

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDocStd.Handle_TDocStd_Modified_IsForgotten(self, *args)


    def IsAttribute(self, *args):
        """
        IsAttribute(Handle_TDocStd_Modified self, Standard_GUID anID) -> Standard_Boolean

        Returns true if it  exists an associated attribute
        of <me> with <anID> as ID.

        :type anID: OCC.wrapper.Standard.Standard_GUID
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDocStd.Handle_TDocStd_Modified_IsAttribute(self, *args)


    def FindAttribute(self, *args):
        """
        FindAttribute(Handle_TDocStd_Modified self, Standard_GUID anID, Handle_TDF_Attribute anAttribute) -> Standard_Boolean

        Finds an associated  attribute of  <me>, according
        to <anID>.  the returned <anAttribute> is a  valid
        one. The  method  returns  True if   found,  False
        otherwise.   A removed attribute  cannot be found using
        this  method.

        :type anID: OCC.wrapper.Standard.Standard_GUID
        :type anAttribute: OCC.wrapper.TDF.Handle_TDF_Attribute
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDocStd.Handle_TDocStd_Modified_FindAttribute(self, *args)


    def AddAttribute(self, *args):
        """
        AddAttribute(Handle_TDocStd_Modified self, Handle_TDF_Attribute other)

        Adds   an   Attribute <other>  to  the   label  of
        <me>.Raises if there is  already  one of the same
        GUID fhan <other>.

        :type other: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TDocStd.Handle_TDocStd_Modified_AddAttribute(self, *args)


    def ForgetAttribute(self, *args):
        """
        ForgetAttribute(Handle_TDocStd_Modified self, Standard_GUID aguid) -> Standard_Boolean

        Forgets  the Attribute of  GUID <aguid> associated
        to the label of <me>. Be  carefull that if <me> is
        the attribute of <guid>, <me> will have a null label
        after this call.  If  the attribute doesn't  exist
        returns False. Otherwise returns True.

        :type aguid: OCC.wrapper.Standard.Standard_GUID
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDocStd.Handle_TDocStd_Modified_ForgetAttribute(self, *args)


    def ForgetAllAttributes(self, *args):
        """
        ForgetAllAttributes(Handle_TDocStd_Modified self, Standard_Boolean const clearChildren)

        Forgets all the  attributes attached to  the label
        of <me>.    Does   it   on  the  sub-labels   if
        <clearChildren> is set  to true.  Of  course, this
        method  is  compatible with Transaction  &  Delta
        mecanisms. Be carefull  that  if <me> will have a
        null label after this call

        :type clearChildren: bool

        """
        return _TDocStd.Handle_TDocStd_Modified_ForgetAllAttributes(self, *args)


    def AfterAddition(self, *args):
        """
        AfterAddition(Handle_TDocStd_Modified self)

        Something to do after adding an Attribute to a label.


        """
        return _TDocStd.Handle_TDocStd_Modified_AfterAddition(self, *args)


    def BeforeRemoval(self, *args):
        """
        BeforeRemoval(Handle_TDocStd_Modified self)

        Something to do before removing an Attribute from
        a label.


        """
        return _TDocStd.Handle_TDocStd_Modified_BeforeRemoval(self, *args)


    def BeforeForget(self, *args):
        """
        BeforeForget(Handle_TDocStd_Modified self)

        Something to do before forgetting an Attribute to a
        label.


        """
        return _TDocStd.Handle_TDocStd_Modified_BeforeForget(self, *args)


    def AfterResume(self, *args):
        """
        AfterResume(Handle_TDocStd_Modified self)

        Something to do after resuming an Attribute from
        a label.


        """
        return _TDocStd.Handle_TDocStd_Modified_AfterResume(self, *args)


    def AfterRetrieval(self, *args):
        """
        AfterRetrieval(Handle_TDocStd_Modified self, Standard_Boolean const forceIt) -> Standard_Boolean

        Something to do AFTER creation of an attribute by
        persistent-transient translation. The returned
        status says if AfterUndo has been performed (true)
        or if this callback must be called once again
        further (false). If <forceIt> is set to true, the
        method MUST perform and return true. Does nothing
        by default and returns true.

        :type forceIt: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDocStd.Handle_TDocStd_Modified_AfterRetrieval(self, *args)


    def BeforeUndo(self, *args):
        """
        BeforeUndo(Handle_TDocStd_Modified self, Handle_TDF_AttributeDelta anAttDelta, Standard_Boolean const forceIt) -> Standard_Boolean

        Something to do before applying <anAttDelta>. The
        returned status says if AfterUndo has been
        performed (true) or if this callback must be
        called once again further (false). If <forceIt> is
        set to true, the method MUST perform and return
        true. Does nothing by default and returns true.

        :type anAttDelta: OCC.wrapper.TDF.Handle_TDF_AttributeDelta
        :type forceIt: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDocStd.Handle_TDocStd_Modified_BeforeUndo(self, *args)


    def AfterUndo(self, *args):
        """
        AfterUndo(Handle_TDocStd_Modified self, Handle_TDF_AttributeDelta anAttDelta, Standard_Boolean const forceIt) -> Standard_Boolean

        Something to do after applying <anAttDelta>. The
        returned status says if AfterUndo has been
        performed (true) or if this callback must be
        called once again further (false). If <forceIt> is
        set to true, the method MUST perform and return
        true. Does nothing by default and returns true.

        :type anAttDelta: OCC.wrapper.TDF.Handle_TDF_AttributeDelta
        :type forceIt: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDocStd.Handle_TDocStd_Modified_AfterUndo(self, *args)


    def BeforeCommitTransaction(self, *args):
        """
        BeforeCommitTransaction(Handle_TDocStd_Modified self)

        A callback.
        By default does nothing.
        It is called by TDF_Data::CommitTransaction() method.


        """
        return _TDocStd.Handle_TDocStd_Modified_BeforeCommitTransaction(self, *args)


    def Backup(self, *args):
        """
        Backup(Handle_TDocStd_Modified self)

        Backups the attribute. The backuped attribute is
        flagged "Backuped" and not "Valid".

        The method does nothing:

        1) If the attribute transaction number is equal to
        the current transaction number (the attribute has
        already been backuped).

        2) If the attribute is not attached to a label.


        """
        return _TDocStd.Handle_TDocStd_Modified_Backup(self, *args)


    def IsBackuped(self, *args):
        """
        IsBackuped(Handle_TDocStd_Modified self) -> Standard_Boolean

        Returns true if the attribute backup status is
        set. This status is set/unset by the
        Backup() method.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDocStd.Handle_TDocStd_Modified_IsBackuped(self, *args)


    def BackupCopy(self, *args):
        """
        BackupCopy(Handle_TDocStd_Modified self) -> Handle_TDF_Attribute

        Copies  the attribute  contents into  a  new other
        attribute. It is used by Backup().

        :rtype: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TDocStd.Handle_TDocStd_Modified_BackupCopy(self, *args)


    def DeltaOnAddition(self, *args):
        """
        DeltaOnAddition(Handle_TDocStd_Modified self) -> Handle_TDF_DeltaOnAddition

        Makes an AttributeDelta because <me>
        appeared. The only known use of a redefinition of
        this method is to return a null handle (no delta).

        :rtype: OCC.wrapper.TDF.Handle_TDF_DeltaOnAddition

        """
        return _TDocStd.Handle_TDocStd_Modified_DeltaOnAddition(self, *args)


    def DeltaOnForget(self, *args):
        """
        DeltaOnForget(Handle_TDocStd_Modified self) -> Handle_TDF_DeltaOnForget

        Makes an AttributeDelta because <me> has been
        forgotten.

        :rtype: OCC.wrapper.TDF.Handle_TDF_DeltaOnForget

        """
        return _TDocStd.Handle_TDocStd_Modified_DeltaOnForget(self, *args)


    def DeltaOnResume(self, *args):
        """
        DeltaOnResume(Handle_TDocStd_Modified self) -> Handle_TDF_DeltaOnResume

        Makes an AttributeDelta because <me> has been
        resumed.

        :rtype: OCC.wrapper.TDF.Handle_TDF_DeltaOnResume

        """
        return _TDocStd.Handle_TDocStd_Modified_DeltaOnResume(self, *args)


    def DeltaOnRemoval(self, *args):
        """
        DeltaOnRemoval(Handle_TDocStd_Modified self) -> Handle_TDF_DeltaOnRemoval

        Makes a DeltaOnRemoval on <me> because <me> has
        disappeared from the DS.

        :rtype: OCC.wrapper.TDF.Handle_TDF_DeltaOnRemoval

        """
        return _TDocStd.Handle_TDocStd_Modified_DeltaOnRemoval(self, *args)


    def References(self, *args):
        """
        References(Handle_TDocStd_Modified self, Handle_TDF_DataSet aDataSet)

        Adds the first level referenced attributes and labels
        to <aDataSet>.

        For this, use the AddLabel or AddAttribute of
        DataSet.

        If there is none, do not implement the method.

        :type aDataSet: OCC.wrapper.TDF.Handle_TDF_DataSet

        """
        return _TDocStd.Handle_TDocStd_Modified_References(self, *args)


    def __lshift__(self, *args):
        """
        __lshift__(Handle_TDocStd_Modified self, Standard_OStream & anOS) -> Standard_OStream &

        :type anOS: OCC.wrapper.Standard.Standard_OStream
        :rtype: OCC.wrapper.Standard.Standard_OStream

        """
        return _TDocStd.Handle_TDocStd_Modified___lshift__(self, *args)


    def ExtendedDump(self, *args):
        """
        ExtendedDump(Handle_TDocStd_Modified self, Standard_OStream & anOS, TDF_IDFilter aFilter, NCollection_IndexedMap_Handle_TDF_Attribute_TColStd_MapTransientHasher aMap)

        Dumps the attribute content on <aStream>, using
        <aMap> like this: if an attribute is not in the
        map, first put add it to the map and then dump it.
        Use the map rank instead of dumping each attribute
        field.

        :type anOS: OCC.wrapper.Standard.Standard_OStream
        :type aFilter: OCC.wrapper.TDF.TDF_IDFilter
        :type aMap: OCC.wrapper.TDF.TDF_AttributeIndexedMap

        """
        return _TDocStd.Handle_TDocStd_Modified_ExtendedDump(self, *args)


    def Forget(self, *args):
        """
        Forget(Handle_TDocStd_Modified self, Standard_Integer const aTransaction)

        Forgets the attribute. <aTransaction> is the
        current transaction in which the forget is done. A
        forgotten attribute is also flagged not "Valid".

        A forgotten attribute is invisible. Set also the
        "Valid" status to False. Obvioulsy, DF cannot
        empty an attribute (this has a semantic
        signification), but can remove it from the
        structure. So, a forgotten attribute is NOT an empty
        one, but a soon DEAD one.

        Should be private.

        :type aTransaction: int

        """
        return _TDocStd.Handle_TDocStd_Modified_Forget(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_TDocStd_Modified self)

        Memory deallocator for transient classes


        """
        return _TDocStd.Handle_TDocStd_Modified_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_TDocStd_Modified self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_TDocStd_Modified self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDocStd.Handle_TDocStd_Modified_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_TDocStd_Modified self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_TDocStd_Modified self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDocStd.Handle_TDocStd_Modified_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_TDocStd_Modified self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _TDocStd.Handle_TDocStd_Modified_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_TDocStd_Modified self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDocStd.Handle_TDocStd_Modified_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_TDocStd_Modified self)

        Increments the reference counter of this object


        """
        return _TDocStd.Handle_TDocStd_Modified_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_TDocStd_Modified self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDocStd.Handle_TDocStd_Modified_DecrementRefCounter(self, *args)

Handle_TDocStd_Modified_swigregister = _TDocStd.Handle_TDocStd_Modified_swigregister
Handle_TDocStd_Modified_swigregister(Handle_TDocStd_Modified)

def Handle_TDocStd_Modified_DownCast(thing):
    return _TDocStd.Handle_TDocStd_Modified_DownCast(thing)
Handle_TDocStd_Modified_DownCast = _TDocStd.Handle_TDocStd_Modified_DownCast

class Handle_TDocStd_XLink(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_TDocStd_XLink self)

        Nullify the handle


        """
        return _TDocStd.Handle_TDocStd_XLink_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_TDocStd_XLink self) -> bool

        Check for being null

        :rtype: bool

        """
        return _TDocStd.Handle_TDocStd_XLink_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_TDocStd_XLink self, TDocStd_XLink thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _TDocStd.Handle_TDocStd_XLink_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_TDocStd_XLink self, Handle_TDocStd_XLink theHandle) -> Handle_TDocStd_XLink
        assign(Handle_TDocStd_XLink self, TDocStd_XLink thePtr) -> Handle_TDocStd_XLink
        assign(Handle_TDocStd_XLink self, Handle_TDocStd_XLink theHandle) -> Handle_TDocStd_XLink

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _TDocStd.Handle_TDocStd_XLink_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_TDocStd_XLink self) -> TDocStd_XLink

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _TDocStd.Handle_TDocStd_XLink_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_TDocStd_XLink self) -> TDocStd_XLink

        Member access operator (note non-const)

        :rtype: T *

        """
        return _TDocStd.Handle_TDocStd_XLink___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_TDocStd_XLink self) -> TDocStd_XLink

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _TDocStd.Handle_TDocStd_XLink___ref__(self, *args)


    def __hash__(self):
        return _TDocStd.Handle_TDocStd_XLink___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _TDocStd.Handle_TDocStd_XLink___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _TDocStd.new_Handle_TDocStd_XLink(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_TDocStd.Handle_TDocStd_XLink_DownCast)
    __swig_destroy__ = _TDocStd.delete_Handle_TDocStd_XLink

    def Set(self, *args):
        """
        Set(Handle_TDocStd_XLink self, TDF_Label atLabel) -> Handle_TDocStd_XLink

        Sets an empty external reference, at the label aLabel.

        :type atLabel: OCC.wrapper.TDF.TDF_Label
        :rtype: OCC.wrapper.TDocStd.Handle_TDocStd_XLink

        """
        return _TDocStd.Handle_TDocStd_XLink_Set(self, *args)


    def Update(self, *args):
        """
        Update(Handle_TDocStd_XLink self) -> Handle_TDF_Reference

        Updates the data referenced in this external link attribute.

        :rtype: OCC.wrapper.TDF.Handle_TDF_Reference

        """
        return _TDocStd.Handle_TDocStd_XLink_Update(self, *args)


    def ID(self, *args):
        """
        Returns the ID of the attribute.

        :rtype: OCC.wrapper.Standard.Standard_GUID

        """
        res = _TDocStd.Handle_TDocStd_XLink_ID(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def GetID(self, *args):
        """
        Returns the GUID for external links.

        :rtype: OCC.wrapper.Standard.Standard_GUID

        """
        res = _TDocStd.Handle_TDocStd_XLink_GetID(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DocumentEntry(self, *args):
        """
        Returns the contents of the document identified by aDocEntry.
        aDocEntry provides external data to this external link attribute.

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        res = _TDocStd.Handle_TDocStd_XLink_DocumentEntry(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def LabelEntry(self, *args):
        """
        Returns the contents of the field <myLabelEntry>.

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        res = _TDocStd.Handle_TDocStd_XLink_LabelEntry(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def AfterAddition(self, *args):
        """
        AfterAddition(Handle_TDocStd_XLink self)

        Updates the XLinkRoot attribute by adding <me>
        to its list.


        """
        return _TDocStd.Handle_TDocStd_XLink_AfterAddition(self, *args)


    def BeforeRemoval(self, *args):
        """
        BeforeRemoval(Handle_TDocStd_XLink self)

        Updates the XLinkRoot attribute by removing <me>
        from its list.


        """
        return _TDocStd.Handle_TDocStd_XLink_BeforeRemoval(self, *args)


    def BeforeUndo(self, *args):
        """
        BeforeUndo(Handle_TDocStd_XLink self, Handle_TDF_AttributeDelta anAttDelta, Standard_Boolean const forceIt) -> Standard_Boolean

        Something to do before applying <anAttDelta>.

        :type anAttDelta: OCC.wrapper.TDF.Handle_TDF_AttributeDelta
        :type forceIt: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDocStd.Handle_TDocStd_XLink_BeforeUndo(self, *args)


    def AfterUndo(self, *args):
        """
        AfterUndo(Handle_TDocStd_XLink self, Handle_TDF_AttributeDelta anAttDelta, Standard_Boolean const forceIt) -> Standard_Boolean

        Something to do after applying <anAttDelta>.

        :type anAttDelta: OCC.wrapper.TDF.Handle_TDF_AttributeDelta
        :type forceIt: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDocStd.Handle_TDocStd_XLink_AfterUndo(self, *args)


    def BackupCopy(self, *args):
        """
        BackupCopy(Handle_TDocStd_XLink self) -> Handle_TDF_Attribute

        Returns a null handle. Raise allways for ,it is
        nonsense to use this method.

        :rtype: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TDocStd.Handle_TDocStd_XLink_BackupCopy(self, *args)


    def Restore(self, *args):
        """
        Restore(Handle_TDocStd_XLink self, Handle_TDF_Attribute anAttribute)

        Does nothing.

        :type anAttribute: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TDocStd.Handle_TDocStd_XLink_Restore(self, *args)


    def NewEmpty(self, *args):
        """
        NewEmpty(Handle_TDocStd_XLink self) -> Handle_TDF_Attribute

        Returns a null handle.

        :rtype: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TDocStd.Handle_TDocStd_XLink_NewEmpty(self, *args)


    def Paste(self, *args):
        """
        Paste(Handle_TDocStd_XLink self, Handle_TDF_Attribute intoAttribute, Handle_TDF_RelocationTable aRelocationTable)

        Does nothing.

        :type intoAttribute: OCC.wrapper.TDF.Handle_TDF_Attribute
        :type aRelocationTable: OCC.wrapper.TDF.Handle_TDF_RelocationTable

        """
        return _TDocStd.Handle_TDocStd_XLink_Paste(self, *args)


    def Dump(self, *args):
        """
        Dump(Handle_TDocStd_XLink self, Standard_OStream & anOS) -> Standard_OStream &

        Dumps the attribute on <aStream>.

        :type anOS: OCC.wrapper.Standard.Standard_OStream
        :rtype: OCC.wrapper.Standard.Standard_OStream

        """
        return _TDocStd.Handle_TDocStd_XLink_Dump(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_TDocStd_XLink self) -> char const *

        :rtype: const char *

        """
        return _TDocStd.Handle_TDocStd_XLink_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TDocStd.Handle_TDocStd_XLink_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TDocStd.Handle_TDocStd_XLink_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetID(self, *args):
        """
        SetID(Handle_TDocStd_XLink self, Standard_GUID arg2)
        SetID(Handle_TDocStd_XLink self)

        Sets default ID defined in nested class (to be used for attributes having User ID feature).


        """
        return _TDocStd.Handle_TDocStd_XLink_SetID(self, *args)


    def Label(self, *args):
        """
        Label(Handle_TDocStd_XLink self) -> TDF_Label

        Returns   the   label to which  the   attribute is
        attached. If the  label is not  included in a  DF,
        the label is null. See Label.
        Warning
        If the label is not included in a data
        framework, it is null.
        This function should not be redefined inline.

        :rtype: OCC.wrapper.TDF.TDF_Label

        """
        return _TDocStd.Handle_TDocStd_XLink_Label(self, *args)


    def Transaction(self, *args):
        """
        Transaction(Handle_TDocStd_XLink self) -> Standard_Integer

        Returns the transaction index in which the
        attribute has been created or modified.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDocStd.Handle_TDocStd_XLink_Transaction(self, *args)


    def UntilTransaction(self, *args):
        """
        UntilTransaction(Handle_TDocStd_XLink self) -> Standard_Integer

        Returns the upper transaction index until which
        the attribute is/was valid. This number may
        vary. A removed attribute validity range is
        reduced to its transaction index.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDocStd.Handle_TDocStd_XLink_UntilTransaction(self, *args)


    def IsValid(self, *args):
        """
        IsValid(Handle_TDocStd_XLink self) -> Standard_Boolean

        Returns true if the attribute is valid; i.e. not a
        backuped or removed one.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDocStd.Handle_TDocStd_XLink_IsValid(self, *args)


    def IsNew(self, *args):
        """
        IsNew(Handle_TDocStd_XLink self) -> Standard_Boolean

        Returns true if the attribute has no backup

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDocStd.Handle_TDocStd_XLink_IsNew(self, *args)


    def IsForgotten(self, *args):
        """
        IsForgotten(Handle_TDocStd_XLink self) -> Standard_Boolean

        Returns true if the attribute forgotten status is
        set.

        ShortCut Methods concerning associated attributes
        =================================================

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDocStd.Handle_TDocStd_XLink_IsForgotten(self, *args)


    def IsAttribute(self, *args):
        """
        IsAttribute(Handle_TDocStd_XLink self, Standard_GUID anID) -> Standard_Boolean

        Returns true if it  exists an associated attribute
        of <me> with <anID> as ID.

        :type anID: OCC.wrapper.Standard.Standard_GUID
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDocStd.Handle_TDocStd_XLink_IsAttribute(self, *args)


    def FindAttribute(self, *args):
        """
        FindAttribute(Handle_TDocStd_XLink self, Standard_GUID anID, Handle_TDF_Attribute anAttribute) -> Standard_Boolean

        Finds an associated  attribute of  <me>, according
        to <anID>.  the returned <anAttribute> is a  valid
        one. The  method  returns  True if   found,  False
        otherwise.   A removed attribute  cannot be found using
        this  method.

        :type anID: OCC.wrapper.Standard.Standard_GUID
        :type anAttribute: OCC.wrapper.TDF.Handle_TDF_Attribute
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDocStd.Handle_TDocStd_XLink_FindAttribute(self, *args)


    def AddAttribute(self, *args):
        """
        AddAttribute(Handle_TDocStd_XLink self, Handle_TDF_Attribute other)

        Adds   an   Attribute <other>  to  the   label  of
        <me>.Raises if there is  already  one of the same
        GUID fhan <other>.

        :type other: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TDocStd.Handle_TDocStd_XLink_AddAttribute(self, *args)


    def ForgetAttribute(self, *args):
        """
        ForgetAttribute(Handle_TDocStd_XLink self, Standard_GUID aguid) -> Standard_Boolean

        Forgets  the Attribute of  GUID <aguid> associated
        to the label of <me>. Be  carefull that if <me> is
        the attribute of <guid>, <me> will have a null label
        after this call.  If  the attribute doesn't  exist
        returns False. Otherwise returns True.

        :type aguid: OCC.wrapper.Standard.Standard_GUID
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDocStd.Handle_TDocStd_XLink_ForgetAttribute(self, *args)


    def ForgetAllAttributes(self, *args):
        """
        ForgetAllAttributes(Handle_TDocStd_XLink self, Standard_Boolean const clearChildren)

        Forgets all the  attributes attached to  the label
        of <me>.    Does   it   on  the  sub-labels   if
        <clearChildren> is set  to true.  Of  course, this
        method  is  compatible with Transaction  &  Delta
        mecanisms. Be carefull  that  if <me> will have a
        null label after this call

        :type clearChildren: bool

        """
        return _TDocStd.Handle_TDocStd_XLink_ForgetAllAttributes(self, *args)


    def BeforeForget(self, *args):
        """
        BeforeForget(Handle_TDocStd_XLink self)

        Something to do before forgetting an Attribute to a
        label.


        """
        return _TDocStd.Handle_TDocStd_XLink_BeforeForget(self, *args)


    def AfterResume(self, *args):
        """
        AfterResume(Handle_TDocStd_XLink self)

        Something to do after resuming an Attribute from
        a label.


        """
        return _TDocStd.Handle_TDocStd_XLink_AfterResume(self, *args)


    def AfterRetrieval(self, *args):
        """
        AfterRetrieval(Handle_TDocStd_XLink self, Standard_Boolean const forceIt) -> Standard_Boolean

        Something to do AFTER creation of an attribute by
        persistent-transient translation. The returned
        status says if AfterUndo has been performed (true)
        or if this callback must be called once again
        further (false). If <forceIt> is set to true, the
        method MUST perform and return true. Does nothing
        by default and returns true.

        :type forceIt: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDocStd.Handle_TDocStd_XLink_AfterRetrieval(self, *args)


    def BeforeCommitTransaction(self, *args):
        """
        BeforeCommitTransaction(Handle_TDocStd_XLink self)

        A callback.
        By default does nothing.
        It is called by TDF_Data::CommitTransaction() method.


        """
        return _TDocStd.Handle_TDocStd_XLink_BeforeCommitTransaction(self, *args)


    def Backup(self, *args):
        """
        Backup(Handle_TDocStd_XLink self)

        Backups the attribute. The backuped attribute is
        flagged "Backuped" and not "Valid".

        The method does nothing:

        1) If the attribute transaction number is equal to
        the current transaction number (the attribute has
        already been backuped).

        2) If the attribute is not attached to a label.


        """
        return _TDocStd.Handle_TDocStd_XLink_Backup(self, *args)


    def IsBackuped(self, *args):
        """
        IsBackuped(Handle_TDocStd_XLink self) -> Standard_Boolean

        Returns true if the attribute backup status is
        set. This status is set/unset by the
        Backup() method.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDocStd.Handle_TDocStd_XLink_IsBackuped(self, *args)


    def DeltaOnAddition(self, *args):
        """
        DeltaOnAddition(Handle_TDocStd_XLink self) -> Handle_TDF_DeltaOnAddition

        Makes an AttributeDelta because <me>
        appeared. The only known use of a redefinition of
        this method is to return a null handle (no delta).

        :rtype: OCC.wrapper.TDF.Handle_TDF_DeltaOnAddition

        """
        return _TDocStd.Handle_TDocStd_XLink_DeltaOnAddition(self, *args)


    def DeltaOnForget(self, *args):
        """
        DeltaOnForget(Handle_TDocStd_XLink self) -> Handle_TDF_DeltaOnForget

        Makes an AttributeDelta because <me> has been
        forgotten.

        :rtype: OCC.wrapper.TDF.Handle_TDF_DeltaOnForget

        """
        return _TDocStd.Handle_TDocStd_XLink_DeltaOnForget(self, *args)


    def DeltaOnResume(self, *args):
        """
        DeltaOnResume(Handle_TDocStd_XLink self) -> Handle_TDF_DeltaOnResume

        Makes an AttributeDelta because <me> has been
        resumed.

        :rtype: OCC.wrapper.TDF.Handle_TDF_DeltaOnResume

        """
        return _TDocStd.Handle_TDocStd_XLink_DeltaOnResume(self, *args)


    def DeltaOnRemoval(self, *args):
        """
        DeltaOnRemoval(Handle_TDocStd_XLink self) -> Handle_TDF_DeltaOnRemoval

        Makes a DeltaOnRemoval on <me> because <me> has
        disappeared from the DS.

        :rtype: OCC.wrapper.TDF.Handle_TDF_DeltaOnRemoval

        """
        return _TDocStd.Handle_TDocStd_XLink_DeltaOnRemoval(self, *args)


    def References(self, *args):
        """
        References(Handle_TDocStd_XLink self, Handle_TDF_DataSet aDataSet)

        Adds the first level referenced attributes and labels
        to <aDataSet>.

        For this, use the AddLabel or AddAttribute of
        DataSet.

        If there is none, do not implement the method.

        :type aDataSet: OCC.wrapper.TDF.Handle_TDF_DataSet

        """
        return _TDocStd.Handle_TDocStd_XLink_References(self, *args)


    def __lshift__(self, *args):
        """
        __lshift__(Handle_TDocStd_XLink self, Standard_OStream & anOS) -> Standard_OStream &

        :type anOS: OCC.wrapper.Standard.Standard_OStream
        :rtype: OCC.wrapper.Standard.Standard_OStream

        """
        return _TDocStd.Handle_TDocStd_XLink___lshift__(self, *args)


    def ExtendedDump(self, *args):
        """
        ExtendedDump(Handle_TDocStd_XLink self, Standard_OStream & anOS, TDF_IDFilter aFilter, NCollection_IndexedMap_Handle_TDF_Attribute_TColStd_MapTransientHasher aMap)

        Dumps the attribute content on <aStream>, using
        <aMap> like this: if an attribute is not in the
        map, first put add it to the map and then dump it.
        Use the map rank instead of dumping each attribute
        field.

        :type anOS: OCC.wrapper.Standard.Standard_OStream
        :type aFilter: OCC.wrapper.TDF.TDF_IDFilter
        :type aMap: OCC.wrapper.TDF.TDF_AttributeIndexedMap

        """
        return _TDocStd.Handle_TDocStd_XLink_ExtendedDump(self, *args)


    def Forget(self, *args):
        """
        Forget(Handle_TDocStd_XLink self, Standard_Integer const aTransaction)

        Forgets the attribute. <aTransaction> is the
        current transaction in which the forget is done. A
        forgotten attribute is also flagged not "Valid".

        A forgotten attribute is invisible. Set also the
        "Valid" status to False. Obvioulsy, DF cannot
        empty an attribute (this has a semantic
        signification), but can remove it from the
        structure. So, a forgotten attribute is NOT an empty
        one, but a soon DEAD one.

        Should be private.

        :type aTransaction: int

        """
        return _TDocStd.Handle_TDocStd_XLink_Forget(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_TDocStd_XLink self)

        Memory deallocator for transient classes


        """
        return _TDocStd.Handle_TDocStd_XLink_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_TDocStd_XLink self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_TDocStd_XLink self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDocStd.Handle_TDocStd_XLink_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_TDocStd_XLink self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_TDocStd_XLink self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDocStd.Handle_TDocStd_XLink_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_TDocStd_XLink self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _TDocStd.Handle_TDocStd_XLink_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_TDocStd_XLink self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDocStd.Handle_TDocStd_XLink_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_TDocStd_XLink self)

        Increments the reference counter of this object


        """
        return _TDocStd.Handle_TDocStd_XLink_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_TDocStd_XLink self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDocStd.Handle_TDocStd_XLink_DecrementRefCounter(self, *args)

Handle_TDocStd_XLink_swigregister = _TDocStd.Handle_TDocStd_XLink_swigregister
Handle_TDocStd_XLink_swigregister(Handle_TDocStd_XLink)

def Handle_TDocStd_XLink_DownCast(thing):
    return _TDocStd.Handle_TDocStd_XLink_DownCast(thing)
Handle_TDocStd_XLink_DownCast = _TDocStd.Handle_TDocStd_XLink_DownCast

class TDocStd_XLinkTool(object):
    """
    This  tool class  is  used to copy  the content of
    source label   under  target label.   Only child
    labels and  attributes   of  source are   copied.
    attributes located   out of source  scope are  not
    copied by this algorithm.
    Depending  of   the called  method  an   external
    reference is set  in  the the target  document  to
    registred the externallink.
    Provide services to set, update and perform
    external references.
    Warning1: Nothing is provided in this class  about the
    opportunity to copy, set a link or  update  it.
    Such decisions must be under application control.
    Warning2: If the document manages shapes, use after copy
    TNaming::ChangeShapes(target,M) to make copy of
    shapes.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(TDocStd_XLinkTool self) -> TDocStd_XLinkTool

        This  tool class  is  used to copy  the content of
        source label   under  target label.   Only child
        labels and  attributes   of  source are   copied.
        attributes located   out of source  scope are  not
        copied by this algorithm.
        Depending  of   the called  method  an   external
        reference is set  in  the the target  document  to
        registred the externallink.
        Provide services to set, update and perform
        external references.
        Warning1: Nothing is provided in this class  about the
        opportunity to copy, set a link or  update  it.
        Such decisions must be under application control.
        Warning2: If the document manages shapes, use after copy
        TNaming::ChangeShapes(target,M) to make copy of
        shapes.
        """
        this = _TDocStd.new_TDocStd_XLinkTool(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def CopyWithLink(self, *args):
        """
        CopyWithLink(TDocStd_XLinkTool self, TDF_Label intarget, TDF_Label fromsource)

        Copies the content of the label <fromsource> to the label <intarget>.
        The link is registred with an XLink attribute by <intarget>
        label.  if  the    content  of <fromsource>   is  not
        self-contained,  and/or <intarget> has already an XLink
        attribute, an exception is raised.

        :type intarget: OCC.wrapper.TDF.TDF_Label
        :type fromsource: OCC.wrapper.TDF.TDF_Label

        """
        return _TDocStd.TDocStd_XLinkTool_CopyWithLink(self, *args)


    def UpdateLink(self, *args):
        """
        UpdateLink(TDocStd_XLinkTool self, TDF_Label L)

        Update the external reference set   at <L>.
        Example
        Handle(TDocStd_Document) aDoc;
        if
        (!OCAFTest::GetDocument(1,aDoc)) return 1;
        Handle(TDataStd_Reference) aRef;
        TDocStd_XLinkTool xlinktool;
        if
        (!OCAFTest::Find(aDoc,2),TDataStd_Reference::GetID(),aRef) return 1;
        xlinktool.UpdateLink(aRef->Label());
        Exceptions
        Standard_DomainError if <L> has no XLink attribute.

        :type L: OCC.wrapper.TDF.TDF_Label

        """
        return _TDocStd.TDocStd_XLinkTool_UpdateLink(self, *args)


    def Copy(self, *args):
        """
        Copy(TDocStd_XLinkTool self, TDF_Label intarget, TDF_Label fromsource)

        Copy    the   content     of    <fromsource>   under
        <intarget>. Noone link is registred. noone check is done.
        Example
        Handle(TDocStd_Document) DOC, XDOC;
        TDF_Label L, XL;
        TDocStd_XLinkTool xlinktool;
        xlinktool.Copy(L,XL);
        Exceptions:
        Standard_DomainError if the contents of
        fromsource are not entirely in the scope of this
        label, in other words, are not self-contained.
        !!! ==> Warning:
        If the document manages shapes use the next way:
        TDocStd_XLinkTool xlinktool;
        xlinktool.Copy(L,XL);
        TopTools_DataMapOfShapeShape M;
        TNaming::ChangeShapes(target,M);

        :type intarget: OCC.wrapper.TDF.TDF_Label
        :type fromsource: OCC.wrapper.TDF.TDF_Label

        """
        return _TDocStd.TDocStd_XLinkTool_Copy(self, *args)


    def IsDone(self, *args):
        """
        IsDone(TDocStd_XLinkTool self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDocStd.TDocStd_XLinkTool_IsDone(self, *args)


    def DataSet(self, *args):
        """
        DataSet(TDocStd_XLinkTool self) -> Handle_TDF_DataSet

        :rtype: OCC.wrapper.TDF.Handle_TDF_DataSet

        """
        return _TDocStd.TDocStd_XLinkTool_DataSet(self, *args)


    def RelocationTable(self, *args):
        """
        RelocationTable(TDocStd_XLinkTool self) -> Handle_TDF_RelocationTable

        :rtype: OCC.wrapper.TDF.Handle_TDF_RelocationTable

        """
        return _TDocStd.TDocStd_XLinkTool_RelocationTable(self, *args)

    __swig_destroy__ = _TDocStd.delete_TDocStd_XLinkTool
TDocStd_XLinkTool_swigregister = _TDocStd.TDocStd_XLinkTool_swigregister
TDocStd_XLinkTool_swigregister(TDocStd_XLinkTool)

class Handle_TDocStd_MultiTransactionManager(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_TDocStd_MultiTransactionManager self)

        Nullify the handle


        """
        return _TDocStd.Handle_TDocStd_MultiTransactionManager_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_TDocStd_MultiTransactionManager self) -> bool

        Check for being null

        :rtype: bool

        """
        return _TDocStd.Handle_TDocStd_MultiTransactionManager_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_TDocStd_MultiTransactionManager self, TDocStd_MultiTransactionManager thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _TDocStd.Handle_TDocStd_MultiTransactionManager_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_TDocStd_MultiTransactionManager self, Handle_TDocStd_MultiTransactionManager theHandle) -> Handle_TDocStd_MultiTransactionManager
        assign(Handle_TDocStd_MultiTransactionManager self, TDocStd_MultiTransactionManager thePtr) -> Handle_TDocStd_MultiTransactionManager
        assign(Handle_TDocStd_MultiTransactionManager self, Handle_TDocStd_MultiTransactionManager theHandle) -> Handle_TDocStd_MultiTransactionManager

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _TDocStd.Handle_TDocStd_MultiTransactionManager_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_TDocStd_MultiTransactionManager self) -> TDocStd_MultiTransactionManager

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _TDocStd.Handle_TDocStd_MultiTransactionManager_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_TDocStd_MultiTransactionManager self) -> TDocStd_MultiTransactionManager

        Member access operator (note non-const)

        :rtype: T *

        """
        return _TDocStd.Handle_TDocStd_MultiTransactionManager___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_TDocStd_MultiTransactionManager self) -> TDocStd_MultiTransactionManager

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _TDocStd.Handle_TDocStd_MultiTransactionManager___ref__(self, *args)


    def __hash__(self):
        return _TDocStd.Handle_TDocStd_MultiTransactionManager___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _TDocStd.Handle_TDocStd_MultiTransactionManager___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _TDocStd.new_Handle_TDocStd_MultiTransactionManager(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_TDocStd.Handle_TDocStd_MultiTransactionManager_DownCast)
    __swig_destroy__ = _TDocStd.delete_Handle_TDocStd_MultiTransactionManager

    def SetUndoLimit(self, *args):
        """
        SetUndoLimit(Handle_TDocStd_MultiTransactionManager self, Standard_Integer const theLimit)

        Sets undo limit for the manager and all documents.

        :type theLimit: int

        """
        return _TDocStd.Handle_TDocStd_MultiTransactionManager_SetUndoLimit(self, *args)


    def GetUndoLimit(self, *args):
        """
        GetUndoLimit(Handle_TDocStd_MultiTransactionManager self) -> Standard_Integer

        Returns undo limit for the manager.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDocStd.Handle_TDocStd_MultiTransactionManager_GetUndoLimit(self, *args)


    def Undo(self, *args):
        """
        Undo(Handle_TDocStd_MultiTransactionManager self)

        Undoes the current transaction of the manager.
        It calls the Undo () method of the document being
        on top of the manager list of undos (list.First())
        and moves the list item to the top of the list of manager
        redos (list.Prepend(item)).


        """
        return _TDocStd.Handle_TDocStd_MultiTransactionManager_Undo(self, *args)


    def Redo(self, *args):
        """
        Redo(Handle_TDocStd_MultiTransactionManager self)

        Redoes the current transaction of the application. It calls
        the Redo () method of the document being on top of the
        manager list of redos (list.First()) and moves the list
        item to the top of the list of manager undos (list.Prepend(item)).


        """
        return _TDocStd.Handle_TDocStd_MultiTransactionManager_Redo(self, *args)


    def GetAvailableUndos(self, *args):
        """
        Returns available manager undos.

        :rtype: OCC.wrapper.TDocStd.TDocStd_SequenceOfApplicationDelta

        """
        res = _TDocStd.Handle_TDocStd_MultiTransactionManager_GetAvailableUndos(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def GetAvailableRedos(self, *args):
        """
        Returns available manager redos.

        :rtype: OCC.wrapper.TDocStd.TDocStd_SequenceOfApplicationDelta

        """
        res = _TDocStd.Handle_TDocStd_MultiTransactionManager_GetAvailableRedos(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def OpenCommand(self, *args):
        """
        OpenCommand(Handle_TDocStd_MultiTransactionManager self)

        Opens transaction in each document and sets the flag that
        transaction is opened. If there are already opened transactions in the documents,
        these transactions will be aborted before openning new ones.


        """
        return _TDocStd.Handle_TDocStd_MultiTransactionManager_OpenCommand(self, *args)


    def AbortCommand(self, *args):
        """
        AbortCommand(Handle_TDocStd_MultiTransactionManager self)

        Unsets the flag of started manager transaction and aborts
        transaction in each document.


        """
        return _TDocStd.Handle_TDocStd_MultiTransactionManager_AbortCommand(self, *args)


    def CommitCommand(self, *args):
        """
        CommitCommand(Handle_TDocStd_MultiTransactionManager self) -> Standard_Boolean
        CommitCommand(Handle_TDocStd_MultiTransactionManager self, TCollection_ExtendedString theName) -> Standard_Boolean

        Makes the same steps as the previous function but defines the name for transaction.
        Returns True if new data has been added to myUndos.

        :type theName: OCC.wrapper.TCollection.TCollection_ExtendedString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDocStd.Handle_TDocStd_MultiTransactionManager_CommitCommand(self, *args)


    def HasOpenCommand(self, *args):
        """
        HasOpenCommand(Handle_TDocStd_MultiTransactionManager self) -> Standard_Boolean

        Returns true if a transaction is opened.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDocStd.Handle_TDocStd_MultiTransactionManager_HasOpenCommand(self, *args)


    def RemoveLastUndo(self, *args):
        """
        RemoveLastUndo(Handle_TDocStd_MultiTransactionManager self)

        Removes undo information from the list of undos of the manager and
        all documents which have been modified during the transaction.


        """
        return _TDocStd.Handle_TDocStd_MultiTransactionManager_RemoveLastUndo(self, *args)


    def DumpTransaction(self, *args):
        """
        DumpTransaction(Handle_TDocStd_MultiTransactionManager self, Standard_OStream & theOS)

        Dumps transactions in undos and redos

        :type theOS: OCC.wrapper.Standard.Standard_OStream

        """
        return _TDocStd.Handle_TDocStd_MultiTransactionManager_DumpTransaction(self, *args)


    def AddDocument(self, *args):
        """
        AddDocument(Handle_TDocStd_MultiTransactionManager self, Handle_TDocStd_Document theDoc)

        Adds the document to the transaction manager and
        checks if it has been already added

        :type theDoc: OCC.wrapper.TDocStd.Handle_TDocStd_Document

        """
        return _TDocStd.Handle_TDocStd_MultiTransactionManager_AddDocument(self, *args)


    def RemoveDocument(self, *args):
        """
        RemoveDocument(Handle_TDocStd_MultiTransactionManager self, Handle_TDocStd_Document theDoc)

        Removes the document from the transaction manager.

        :type theDoc: OCC.wrapper.TDocStd.Handle_TDocStd_Document

        """
        return _TDocStd.Handle_TDocStd_MultiTransactionManager_RemoveDocument(self, *args)


    def Documents(self, *args):
        """
        Returns the added documents to the transaction manager.

        :rtype: OCC.wrapper.TDocStd.TDocStd_SequenceOfDocument

        """
        res = _TDocStd.Handle_TDocStd_MultiTransactionManager_Documents(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetNestedTransactionMode(self, *args):
        """
        SetNestedTransactionMode(Handle_TDocStd_MultiTransactionManager self, Standard_Boolean const isAllowed)

        Sets nested transaction mode if isAllowed == Standard_True
        NOTE: field myIsNestedTransactionMode exists only for synchronization
        between several documents and has no effect on transactions
        of multitransaction manager.

        :type isAllowed: bool

        """
        return _TDocStd.Handle_TDocStd_MultiTransactionManager_SetNestedTransactionMode(self, *args)


    def IsNestedTransactionMode(self, *args):
        """
        IsNestedTransactionMode(Handle_TDocStd_MultiTransactionManager self) -> Standard_Boolean

        Returns Standard_True if NestedTransaction mode is set.
        Methods for protection of changes outside transactions

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDocStd.Handle_TDocStd_MultiTransactionManager_IsNestedTransactionMode(self, *args)


    def SetModificationMode(self, *args):
        """
        SetModificationMode(Handle_TDocStd_MultiTransactionManager self, Standard_Boolean const theTransactionOnly)

        If theTransactionOnly is True, denies all changes outside transactions.

        :type theTransactionOnly: bool

        """
        return _TDocStd.Handle_TDocStd_MultiTransactionManager_SetModificationMode(self, *args)


    def ModificationMode(self, *args):
        """
        ModificationMode(Handle_TDocStd_MultiTransactionManager self) -> Standard_Boolean

        Returns True if changes are allowed only inside transactions.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDocStd.Handle_TDocStd_MultiTransactionManager_ModificationMode(self, *args)


    def ClearUndos(self, *args):
        """
        ClearUndos(Handle_TDocStd_MultiTransactionManager self)

        Clears undos in the manager and in documents.


        """
        return _TDocStd.Handle_TDocStd_MultiTransactionManager_ClearUndos(self, *args)


    def ClearRedos(self, *args):
        """
        ClearRedos(Handle_TDocStd_MultiTransactionManager self)

        Clears redos in the manager and in documents.


        """
        return _TDocStd.Handle_TDocStd_MultiTransactionManager_ClearRedos(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_TDocStd_MultiTransactionManager self) -> char const *

        :rtype: const char *

        """
        return _TDocStd.Handle_TDocStd_MultiTransactionManager_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TDocStd.Handle_TDocStd_MultiTransactionManager_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TDocStd.Handle_TDocStd_MultiTransactionManager_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_TDocStd_MultiTransactionManager self)

        Memory deallocator for transient classes


        """
        return _TDocStd.Handle_TDocStd_MultiTransactionManager_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_TDocStd_MultiTransactionManager self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_TDocStd_MultiTransactionManager self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDocStd.Handle_TDocStd_MultiTransactionManager_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_TDocStd_MultiTransactionManager self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_TDocStd_MultiTransactionManager self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDocStd.Handle_TDocStd_MultiTransactionManager_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_TDocStd_MultiTransactionManager self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _TDocStd.Handle_TDocStd_MultiTransactionManager_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_TDocStd_MultiTransactionManager self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDocStd.Handle_TDocStd_MultiTransactionManager_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_TDocStd_MultiTransactionManager self)

        Increments the reference counter of this object


        """
        return _TDocStd.Handle_TDocStd_MultiTransactionManager_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_TDocStd_MultiTransactionManager self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDocStd.Handle_TDocStd_MultiTransactionManager_DecrementRefCounter(self, *args)

Handle_TDocStd_MultiTransactionManager_swigregister = _TDocStd.Handle_TDocStd_MultiTransactionManager_swigregister
Handle_TDocStd_MultiTransactionManager_swigregister(Handle_TDocStd_MultiTransactionManager)

def Handle_TDocStd_MultiTransactionManager_DownCast(thing):
    return _TDocStd.Handle_TDocStd_MultiTransactionManager_DownCast(thing)
Handle_TDocStd_MultiTransactionManager_DownCast = _TDocStd.Handle_TDocStd_MultiTransactionManager_DownCast




# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_AppParCurves')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_AppParCurves')
    _AppParCurves = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_AppParCurves', [dirname(__file__)])
        except ImportError:
            import _AppParCurves
            return _AppParCurves
        try:
            _mod = imp.load_module('_AppParCurves', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _AppParCurves = swig_import_helper()
    del swig_import_helper
else:
    import _AppParCurves
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


class SwigPyIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _AppParCurves.delete_SwigPyIterator

    def value(self):
        return _AppParCurves.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _AppParCurves.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _AppParCurves.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _AppParCurves.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _AppParCurves.SwigPyIterator_equal(self, x)

    def copy(self):
        return _AppParCurves.SwigPyIterator_copy(self)

    def next(self):
        return _AppParCurves.SwigPyIterator_next(self)

    def __next__(self):
        return _AppParCurves.SwigPyIterator___next__(self)

    def previous(self):
        return _AppParCurves.SwigPyIterator_previous(self)

    def advance(self, n):
        return _AppParCurves.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _AppParCurves.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _AppParCurves.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _AppParCurves.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _AppParCurves.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _AppParCurves.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _AppParCurves.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self
SwigPyIterator_swigregister = _AppParCurves.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

class NCollection_CellFilter_InspectorXYZ(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _AppParCurves.NCollection_CellFilter_InspectorXYZ_Dimension
    Coord = staticmethod(_AppParCurves.NCollection_CellFilter_InspectorXYZ_Coord)

    def Shift(self, thePnt, theTol):
        return _AppParCurves.NCollection_CellFilter_InspectorXYZ_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _AppParCurves.new_NCollection_CellFilter_InspectorXYZ()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _AppParCurves.delete_NCollection_CellFilter_InspectorXYZ
NCollection_CellFilter_InspectorXYZ_swigregister = _AppParCurves.NCollection_CellFilter_InspectorXYZ_swigregister
NCollection_CellFilter_InspectorXYZ_swigregister(NCollection_CellFilter_InspectorXYZ)

def NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt):
    return _AppParCurves.NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt)
NCollection_CellFilter_InspectorXYZ_Coord = _AppParCurves.NCollection_CellFilter_InspectorXYZ_Coord

class NCollection_CellFilter_InspectorXY(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _AppParCurves.NCollection_CellFilter_InspectorXY_Dimension
    Coord = staticmethod(_AppParCurves.NCollection_CellFilter_InspectorXY_Coord)

    def Shift(self, thePnt, theTol):
        return _AppParCurves.NCollection_CellFilter_InspectorXY_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _AppParCurves.new_NCollection_CellFilter_InspectorXY()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _AppParCurves.delete_NCollection_CellFilter_InspectorXY
NCollection_CellFilter_InspectorXY_swigregister = _AppParCurves.NCollection_CellFilter_InspectorXY_swigregister
NCollection_CellFilter_InspectorXY_swigregister(NCollection_CellFilter_InspectorXY)

def NCollection_CellFilter_InspectorXY_Coord(i, thePnt):
    return _AppParCurves.NCollection_CellFilter_InspectorXY_Coord(i, thePnt)
NCollection_CellFilter_InspectorXY_Coord = _AppParCurves.NCollection_CellFilter_InspectorXY_Coord


def ptr_to_number(item):
    return _AppParCurves.ptr_to_number(item)
ptr_to_number = _AppParCurves.ptr_to_number

def HashCode(*args):
    return _AppParCurves.HashCode(*args)
HashCode = _AppParCurves.HashCode

def ptr_equal(a, b):
    return _AppParCurves.ptr_equal(a, b)
ptr_equal = _AppParCurves.ptr_equal
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import NCollection
else:
    import NCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Standard
else:
    import Standard
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import gp
else:
    import gp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColStd
else:
    import TColStd
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TCollection
else:
    import TCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColgp
else:
    import TColgp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import math
else:
    import math
del _swig_python_version_info
AppParCurves_NoConstraint = _AppParCurves.AppParCurves_NoConstraint
AppParCurves_PassPoint = _AppParCurves.AppParCurves_PassPoint
AppParCurves_TangencyPoint = _AppParCurves.AppParCurves_TangencyPoint
AppParCurves_CurvaturePoint = _AppParCurves.AppParCurves_CurvaturePoint
class AppParCurves_MultiCurve(object):
    """
    This class describes a MultiCurve approximating a Multiline.
    As a Multiline is a set of n lines, a MultiCurve is a set
    of n curves. These curves are Bezier curves.
    A MultiCurve is composed of m MultiPoint.
    The approximating degree of these n curves is the same for
    each one.

    Example of a MultiCurve composed of MultiPoints:

    P1______P2_____P3______P4________........_____PNbMPoints

    Q1______Q2_____Q3______Q4________........_____QNbMPoints
    .                                               .
    .                                               .
    .                                               .
    R1______R2_____R3______R4________........_____RNbMPoints

    Pi, Qi, ..., Ri are points of dimension 2 or 3.

    (Pi, Qi, ...Ri), i= 1,...NbPoles are MultiPoints.
    each MultiPoint has got NbPol Poles.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(AppParCurves_MultiCurve self) -> AppParCurves_MultiCurve
        __init__(AppParCurves_MultiCurve self, Standard_Integer const NbPol) -> AppParCurves_MultiCurve
        __init__(AppParCurves_MultiCurve self, NCollection_Array1_AppParCurves_MultiPoint tabMU) -> AppParCurves_MultiCurve

        creates a MultiCurve, describing Bezier curves all
        containing the same number of MultiPoint.
        Each MultiPoint must have NbCurves Poles.

        :type tabMU: OCC.wrapper.AppParCurves.AppParCurves_Array1OfMultiPoint

        """
        this = _AppParCurves.new_AppParCurves_MultiCurve(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def SetNbPoles(self, *args):
        """
        SetNbPoles(AppParCurves_MultiCurve self, Standard_Integer const nbPoles)

        The number of poles of the MultiCurve
        will be set to <nbPoles>.

        :type nbPoles: int

        """
        return _AppParCurves.AppParCurves_MultiCurve_SetNbPoles(self, *args)


    def SetValue(self, *args):
        """
        SetValue(AppParCurves_MultiCurve self, Standard_Integer const Index, AppParCurves_MultiPoint MPoint)

        sets the MultiPoint of range Index to the value
        <MPoint>.
        An exception is raised if Index <0 or Index >NbMPoint.

        :type Index: int
        :type MPoint: OCC.wrapper.AppParCurves.AppParCurves_MultiPoint

        """
        return _AppParCurves.AppParCurves_MultiCurve_SetValue(self, *args)


    def NbCurves(self, *args):
        """
        NbCurves(AppParCurves_MultiCurve self) -> Standard_Integer

        Returns the number of curves resulting from the
        approximation of a MultiLine.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AppParCurves.AppParCurves_MultiCurve_NbCurves(self, *args)


    def NbPoles(self, *args):
        """
        NbPoles(AppParCurves_MultiCurve self) -> Standard_Integer

        Returns the number of poles on curves resulting from the approximation of a MultiLine.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AppParCurves.AppParCurves_MultiCurve_NbPoles(self, *args)


    def Degree(self, *args):
        """
        Degree(AppParCurves_MultiCurve self) -> Standard_Integer

        returns the degree of the curves.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AppParCurves.AppParCurves_MultiCurve_Degree(self, *args)


    def Dimension(self, *args):
        """
        Dimension(AppParCurves_MultiCurve self, Standard_Integer const CuIndex) -> Standard_Integer

        returns the dimension of the CuIndex curve.
        An exception is raised if CuIndex<0 or CuIndex>NbCurves.

        :type CuIndex: int
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AppParCurves.AppParCurves_MultiCurve_Dimension(self, *args)


    def Curve(self, *args):
        """
        Curve(AppParCurves_MultiCurve self, Standard_Integer const CuIndex, NCollection_Array1_gp_Pnt TabPnt)
        Curve(AppParCurves_MultiCurve self, Standard_Integer const CuIndex, NCollection_Array1_gp_Pnt2d TabPnt)

        returns the Pole array of the curve of range CuIndex.
        An exception is raised if the dimension of the curve
        is 3d.

        :type CuIndex: int
        :type TabPnt: OCC.wrapper.TColgp.TColgp_Array1OfPnt2d

        """
        return _AppParCurves.AppParCurves_MultiCurve_Curve(self, *args)


    def Pole(self, *args):
        """
        returns the Nieme pole of the CuIndex curve.
        the curve must be a 3D curve.

        :type CuIndex: int
        :type Nieme: int
        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        res = _AppParCurves.AppParCurves_MultiCurve_Pole(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Pole2d(self, *args):
        """
        returns the Nieme pole of the CuIndex curve.
        the curve must be a 2D curve.

        :type CuIndex: int
        :type Nieme: int
        :rtype: OCC.wrapper.gp.gp_Pnt2d

        """
        res = _AppParCurves.AppParCurves_MultiCurve_Pole2d(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Transform(self, *args):
        """
        Transform(AppParCurves_MultiCurve self, Standard_Integer const CuIndex, Standard_Real const x, Standard_Real const dx, Standard_Real const y, Standard_Real const dy, Standard_Real const z, Standard_Real const dz)

        Applies a transformation to the curve of range
        <CuIndex>.
        newx = x + dx*oldx
        newy = y + dy*oldy    for all points of the curve.
        newz = z + dz*oldz

        :type CuIndex: int
        :type x: float
        :type dx: float
        :type y: float
        :type dy: float
        :type z: float
        :type dz: float

        """
        return _AppParCurves.AppParCurves_MultiCurve_Transform(self, *args)


    def Transform2d(self, *args):
        """
        Transform2d(AppParCurves_MultiCurve self, Standard_Integer const CuIndex, Standard_Real const x, Standard_Real const dx, Standard_Real const y, Standard_Real const dy)

        Applies a transformation to the Curve of range
        <CuIndex>.
        newx = x + dx*oldx
        newy = y + dy*oldy    for all points of the curve.

        :type CuIndex: int
        :type x: float
        :type dx: float
        :type y: float
        :type dy: float

        """
        return _AppParCurves.AppParCurves_MultiCurve_Transform2d(self, *args)


    def Value(self, *args):
        """
        returns the Index MultiPoint.
        An exception is raised if Index <0 or Index >Degree+1.

        :type Index: int
        :rtype: OCC.wrapper.AppParCurves.AppParCurves_MultiPoint

        """
        res = _AppParCurves.AppParCurves_MultiCurve_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def D1(self, *args):
        """
        D1(AppParCurves_MultiCurve self, Standard_Integer const CuIndex, Standard_Real const U, gp_Pnt Pt, gp_Vec V1)
        D1(AppParCurves_MultiCurve self, Standard_Integer const CuIndex, Standard_Real const U, gp_Pnt2d Pt, gp_Vec2d V1)

        returns the value of the point with a parameter U
        on the Bezier curve number CuIndex.
        An exception is raised if CuIndex <0 or > NbCurves.
        An exception is raised if the curve dimension is 2d.

        :type CuIndex: int
        :type U: float
        :type Pt: OCC.wrapper.gp.gp_Pnt2d
        :type V1: OCC.wrapper.gp.gp_Vec2d

        """
        return _AppParCurves.AppParCurves_MultiCurve_D1(self, *args)


    def D2(self, *args):
        """
        D2(AppParCurves_MultiCurve self, Standard_Integer const CuIndex, Standard_Real const U, gp_Pnt Pt, gp_Vec V1, gp_Vec V2)
        D2(AppParCurves_MultiCurve self, Standard_Integer const CuIndex, Standard_Real const U, gp_Pnt2d Pt, gp_Vec2d V1, gp_Vec2d V2)

        returns the value of the point with a parameter U
        on the Bezier curve number CuIndex.
        An exception is raised if CuIndex <0 or > NbCurves.
        An exception is raised if the curve dimension is 2d.

        :type CuIndex: int
        :type U: float
        :type Pt: OCC.wrapper.gp.gp_Pnt2d
        :type V1: OCC.wrapper.gp.gp_Vec2d
        :type V2: OCC.wrapper.gp.gp_Vec2d

        """
        return _AppParCurves.AppParCurves_MultiCurve_D2(self, *args)


    def Dump(self, *args):
        """
        Dump(AppParCurves_MultiCurve self, Standard_OStream & o)

        Prints on the stream o information on the current
        state of the object.
        Is used to redefine the operator <<.

        :type o: OCC.wrapper.Standard.Standard_OStream

        """
        return _AppParCurves.AppParCurves_MultiCurve_Dump(self, *args)

    __swig_destroy__ = _AppParCurves.delete_AppParCurves_MultiCurve
AppParCurves_MultiCurve_swigregister = _AppParCurves.AppParCurves_MultiCurve_swigregister
AppParCurves_MultiCurve_swigregister(AppParCurves_MultiCurve)

class AppParCurves_MultiBSpCurve(AppParCurves_MultiCurve):
    """
    This class describes a MultiBSpCurve approximating a Multiline.
    Just as a Multiline is a set of a given number of lines, a MultiBSpCurve is a set
    of a specified number of bsplines defined by:
    -   A specified number of MultiPoints - the poles of a specified number of curves
    -   The degree of approximation identical for each of the specified number of curves.

    Example of a MultiBSpCurve composed of a specified number of MultiPoints:

    P1______P2_____P3______P4________........_____PNbMPoints

    Q1______Q2_____Q3______Q4________........_____QNbMPoints
    .                                               .
    .                                               .
    .                                               .
    R1______R2_____R3______R4________........_____RNbMPoints

    Pi, Qi, ..., Ri are points of dimension 2 or 3.

    (Pi, Qi, ...Ri), i= 1,...NbPoles are MultiPoints.
    each MultiPoint has got NbPol Poles.
    MultiBSpCurves are created by the SplineValue method in the ComputeLine
    class, and by the Value method in TheVariational class. MultiBSpCurve
    provides the information required to create the BSpline defined by the approximation.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(AppParCurves_MultiBSpCurve self) -> AppParCurves_MultiBSpCurve
        __init__(AppParCurves_MultiBSpCurve self, Standard_Integer const NbPol) -> AppParCurves_MultiBSpCurve
        __init__(AppParCurves_MultiBSpCurve self, NCollection_Array1_AppParCurves_MultiPoint tabMU, NCollection_Array1_Standard_Real Knots, NCollection_Array1_Standard_Integer Mults) -> AppParCurves_MultiBSpCurve
        __init__(AppParCurves_MultiBSpCurve self, AppParCurves_MultiCurve SC, NCollection_Array1_Standard_Real Knots, NCollection_Array1_Standard_Integer Mults) -> AppParCurves_MultiBSpCurve

        creates a MultiBSpCurve, describing BSpline
        curves, taking control points from <SC>.

        :type SC: OCC.wrapper.AppParCurves.AppParCurves_MultiCurve
        :type Knots: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type Mults: OCC.wrapper.TColStd.TColStd_Array1OfInteger

        """
        this = _AppParCurves.new_AppParCurves_MultiBSpCurve(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def SetKnots(self, *args):
        """
        SetKnots(AppParCurves_MultiBSpCurve self, NCollection_Array1_Standard_Real theKnots)

        Knots of the multiBSpCurve are assigned to <theknots>.

        :type theKnots: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        return _AppParCurves.AppParCurves_MultiBSpCurve_SetKnots(self, *args)


    def SetMultiplicities(self, *args):
        """
        SetMultiplicities(AppParCurves_MultiBSpCurve self, NCollection_Array1_Standard_Integer theMults)

        Multiplicities of the multiBSpCurve are assigned
        to <theMults>.

        :type theMults: OCC.wrapper.TColStd.TColStd_Array1OfInteger

        """
        return _AppParCurves.AppParCurves_MultiBSpCurve_SetMultiplicities(self, *args)


    def Knots(self, *args):
        """
        Returns an array of Reals containing
        the multiplicities of curves resulting from the approximation.

        :rtype: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        res = _AppParCurves.AppParCurves_MultiBSpCurve_Knots(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Multiplicities(self, *args):
        """
        Returns an array of Reals containing the
        multiplicities of curves resulting from the approximation.

        :rtype: OCC.wrapper.TColStd.TColStd_Array1OfInteger

        """
        res = _AppParCurves.AppParCurves_MultiBSpCurve_Multiplicities(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Degree(self, *args):
        """
        Degree(AppParCurves_MultiBSpCurve self) -> Standard_Integer

        returns the degree of the curve(s).

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AppParCurves.AppParCurves_MultiBSpCurve_Degree(self, *args)


    def Value(self, *args):
        """
        returns the Index MultiPoint.
        An exception is raised if Index <0 or Index >Degree+1.

        :type Index: int
        :rtype: OCC.wrapper.AppParCurves.AppParCurves_MultiPoint

        """
        res = _AppParCurves.AppParCurves_MultiBSpCurve_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def D1(self, *args):
        """
        D1(AppParCurves_MultiBSpCurve self, Standard_Integer const CuIndex, Standard_Real const U, gp_Pnt Pt, gp_Vec V1)
        D1(AppParCurves_MultiBSpCurve self, Standard_Integer const CuIndex, Standard_Real const U, gp_Pnt2d Pt, gp_Vec2d V1)

        returns the value of the point with a parameter U
        on the BSpline curve number CuIndex.
        An exception is raised if CuIndex <0 or > NbCurves.
        An exception is raised if the curve dimension is 2d.

        :type CuIndex: int
        :type U: float
        :type Pt: OCC.wrapper.gp.gp_Pnt2d
        :type V1: OCC.wrapper.gp.gp_Vec2d

        """
        return _AppParCurves.AppParCurves_MultiBSpCurve_D1(self, *args)


    def D2(self, *args):
        """
        D2(AppParCurves_MultiBSpCurve self, Standard_Integer const CuIndex, Standard_Real const U, gp_Pnt Pt, gp_Vec V1, gp_Vec V2)
        D2(AppParCurves_MultiBSpCurve self, Standard_Integer const CuIndex, Standard_Real const U, gp_Pnt2d Pt, gp_Vec2d V1, gp_Vec2d V2)

        returns the value of the point with a parameter U
        on the BSpline curve number CuIndex.
        An exception is raised if CuIndex <0 or > NbCurves.
        An exception is raised if the curve dimension is 2d.

        :type CuIndex: int
        :type U: float
        :type Pt: OCC.wrapper.gp.gp_Pnt2d
        :type V1: OCC.wrapper.gp.gp_Vec2d
        :type V2: OCC.wrapper.gp.gp_Vec2d

        """
        return _AppParCurves.AppParCurves_MultiBSpCurve_D2(self, *args)


    def Dump(self, *args):
        """
        Dump(AppParCurves_MultiBSpCurve self, Standard_OStream & o)

        Prints on the stream o information on the current
        state of the object.
        Is used to redefine the operator <<.

        :type o: OCC.wrapper.Standard.Standard_OStream

        """
        return _AppParCurves.AppParCurves_MultiBSpCurve_Dump(self, *args)

    __swig_destroy__ = _AppParCurves.delete_AppParCurves_MultiBSpCurve
AppParCurves_MultiBSpCurve_swigregister = _AppParCurves.AppParCurves_MultiBSpCurve_swigregister
AppParCurves_MultiBSpCurve_swigregister(AppParCurves_MultiBSpCurve)

class AppParCurves_ConstraintCouple(object):
    """
    associates an index and a constraint for an object.
    This couple is used by AppDef_TheVariational when performing approximations.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(AppParCurves_ConstraintCouple self) -> AppParCurves_ConstraintCouple
        __init__(AppParCurves_ConstraintCouple self, Standard_Integer const TheIndex, AppParCurves_Constraint const Cons) -> AppParCurves_ConstraintCouple

        Create a couple the object <Index> will have the
        constraint <Cons>.

        :type TheIndex: int
        :type Cons: OCC.wrapper.AppParCurves.AppParCurves_Constraint

        """
        this = _AppParCurves.new_AppParCurves_ConstraintCouple(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Index(self, *args):
        """
        Index(AppParCurves_ConstraintCouple self) -> Standard_Integer

        returns the index of the constraint object.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AppParCurves.AppParCurves_ConstraintCouple_Index(self, *args)


    def Constraint(self, *args):
        """
        Constraint(AppParCurves_ConstraintCouple self) -> AppParCurves_Constraint

        returns the constraint of the object.

        :rtype: OCC.wrapper.AppParCurves.AppParCurves_Constraint

        """
        return _AppParCurves.AppParCurves_ConstraintCouple_Constraint(self, *args)


    def SetIndex(self, *args):
        """
        SetIndex(AppParCurves_ConstraintCouple self, Standard_Integer const TheIndex)

        Changes the index of the constraint object.

        :type TheIndex: int

        """
        return _AppParCurves.AppParCurves_ConstraintCouple_SetIndex(self, *args)


    def SetConstraint(self, *args):
        """
        SetConstraint(AppParCurves_ConstraintCouple self, AppParCurves_Constraint const Cons)

        Changes the constraint of the object.

        :type Cons: OCC.wrapper.AppParCurves.AppParCurves_Constraint

        """
        return _AppParCurves.AppParCurves_ConstraintCouple_SetConstraint(self, *args)

    __swig_destroy__ = _AppParCurves.delete_AppParCurves_ConstraintCouple
AppParCurves_ConstraintCouple_swigregister = _AppParCurves.AppParCurves_ConstraintCouple_swigregister
AppParCurves_ConstraintCouple_swigregister(AppParCurves_ConstraintCouple)

class AppParCurves_HArray1OfConstraintCouple(Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_AppParCurves_HArray1OfConstraintCouple
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_AppParCurves_HArray1OfConstraintCouple(self) 
            return h


    def __init__(self, *args):
        """
        __init__(AppParCurves_HArray1OfConstraintCouple self, Standard_Integer const theLower, Standard_Integer const theUpper) -> AppParCurves_HArray1OfConstraintCouple
        __init__(AppParCurves_HArray1OfConstraintCouple self, Standard_Integer const theLower, Standard_Integer const theUpper, AppParCurves_ConstraintCouple theValue) -> AppParCurves_HArray1OfConstraintCouple
        __init__(AppParCurves_HArray1OfConstraintCouple self, NCollection_Array1_AppParCurves_ConstraintCouple theOther) -> AppParCurves_HArray1OfConstraintCouple

        :type theOther: OCC.wrapper.AppParCurves.AppParCurves_Array1OfConstraintCouple

        """
        this = _AppParCurves.new_AppParCurves_HArray1OfConstraintCouple(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Array1(self, *args):
        """
        :rtype: OCC.wrapper.AppParCurves.AppParCurves_Array1OfConstraintCouple

        """
        res = _AppParCurves.AppParCurves_HArray1OfConstraintCouple_Array1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeArray1(self, *args):
        """
        ChangeArray1(AppParCurves_HArray1OfConstraintCouple self) -> NCollection_Array1_AppParCurves_ConstraintCouple

        :rtype: OCC.wrapper.AppParCurves.AppParCurves_Array1OfConstraintCouple

        """
        return _AppParCurves.AppParCurves_HArray1OfConstraintCouple_ChangeArray1(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _AppParCurves.AppParCurves_HArray1OfConstraintCouple_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _AppParCurves.AppParCurves_HArray1OfConstraintCouple_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _AppParCurves.AppParCurves_HArray1OfConstraintCouple_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _AppParCurves.delete_AppParCurves_HArray1OfConstraintCouple
AppParCurves_HArray1OfConstraintCouple_swigregister = _AppParCurves.AppParCurves_HArray1OfConstraintCouple_swigregister
AppParCurves_HArray1OfConstraintCouple_swigregister(AppParCurves_HArray1OfConstraintCouple)

def AppParCurves_HArray1OfConstraintCouple_get_type_name(*args):
    """
    AppParCurves_HArray1OfConstraintCouple_get_type_name() -> char const *

    :rtype: const char *

    """
    return _AppParCurves.AppParCurves_HArray1OfConstraintCouple_get_type_name(*args)

def AppParCurves_HArray1OfConstraintCouple_get_type_descriptor(*args):
    """
    AppParCurves_HArray1OfConstraintCouple_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _AppParCurves.AppParCurves_HArray1OfConstraintCouple_get_type_descriptor(*args)

class AppParCurves_HArray1OfMultiBSpCurve(Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_AppParCurves_HArray1OfMultiBSpCurve
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_AppParCurves_HArray1OfMultiBSpCurve(self) 
            return h


    def __init__(self, *args):
        """
        __init__(AppParCurves_HArray1OfMultiBSpCurve self, Standard_Integer const theLower, Standard_Integer const theUpper) -> AppParCurves_HArray1OfMultiBSpCurve
        __init__(AppParCurves_HArray1OfMultiBSpCurve self, Standard_Integer const theLower, Standard_Integer const theUpper, AppParCurves_MultiBSpCurve theValue) -> AppParCurves_HArray1OfMultiBSpCurve
        __init__(AppParCurves_HArray1OfMultiBSpCurve self, NCollection_Array1_AppParCurves_MultiBSpCurve theOther) -> AppParCurves_HArray1OfMultiBSpCurve

        :type theOther: OCC.wrapper.AppParCurves.AppParCurves_Array1OfMultiBSpCurve

        """
        this = _AppParCurves.new_AppParCurves_HArray1OfMultiBSpCurve(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Array1(self, *args):
        """
        :rtype: OCC.wrapper.AppParCurves.AppParCurves_Array1OfMultiBSpCurve

        """
        res = _AppParCurves.AppParCurves_HArray1OfMultiBSpCurve_Array1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeArray1(self, *args):
        """
        ChangeArray1(AppParCurves_HArray1OfMultiBSpCurve self) -> NCollection_Array1_AppParCurves_MultiBSpCurve

        :rtype: OCC.wrapper.AppParCurves.AppParCurves_Array1OfMultiBSpCurve

        """
        return _AppParCurves.AppParCurves_HArray1OfMultiBSpCurve_ChangeArray1(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _AppParCurves.AppParCurves_HArray1OfMultiBSpCurve_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _AppParCurves.AppParCurves_HArray1OfMultiBSpCurve_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _AppParCurves.AppParCurves_HArray1OfMultiBSpCurve_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _AppParCurves.delete_AppParCurves_HArray1OfMultiBSpCurve
AppParCurves_HArray1OfMultiBSpCurve_swigregister = _AppParCurves.AppParCurves_HArray1OfMultiBSpCurve_swigregister
AppParCurves_HArray1OfMultiBSpCurve_swigregister(AppParCurves_HArray1OfMultiBSpCurve)

def AppParCurves_HArray1OfMultiBSpCurve_get_type_name(*args):
    """
    AppParCurves_HArray1OfMultiBSpCurve_get_type_name() -> char const *

    :rtype: const char *

    """
    return _AppParCurves.AppParCurves_HArray1OfMultiBSpCurve_get_type_name(*args)

def AppParCurves_HArray1OfMultiBSpCurve_get_type_descriptor(*args):
    """
    AppParCurves_HArray1OfMultiBSpCurve_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _AppParCurves.AppParCurves_HArray1OfMultiBSpCurve_get_type_descriptor(*args)

class AppParCurves_HArray1OfMultiPoint(Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_AppParCurves_HArray1OfMultiPoint
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_AppParCurves_HArray1OfMultiPoint(self) 
            return h


    def __init__(self, *args):
        """
        __init__(AppParCurves_HArray1OfMultiPoint self, Standard_Integer const theLower, Standard_Integer const theUpper) -> AppParCurves_HArray1OfMultiPoint
        __init__(AppParCurves_HArray1OfMultiPoint self, Standard_Integer const theLower, Standard_Integer const theUpper, AppParCurves_MultiPoint theValue) -> AppParCurves_HArray1OfMultiPoint
        __init__(AppParCurves_HArray1OfMultiPoint self, NCollection_Array1_AppParCurves_MultiPoint theOther) -> AppParCurves_HArray1OfMultiPoint

        :type theOther: OCC.wrapper.AppParCurves.AppParCurves_Array1OfMultiPoint

        """
        this = _AppParCurves.new_AppParCurves_HArray1OfMultiPoint(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Array1(self, *args):
        """
        :rtype: OCC.wrapper.AppParCurves.AppParCurves_Array1OfMultiPoint

        """
        res = _AppParCurves.AppParCurves_HArray1OfMultiPoint_Array1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeArray1(self, *args):
        """
        ChangeArray1(AppParCurves_HArray1OfMultiPoint self) -> NCollection_Array1_AppParCurves_MultiPoint

        :rtype: OCC.wrapper.AppParCurves.AppParCurves_Array1OfMultiPoint

        """
        return _AppParCurves.AppParCurves_HArray1OfMultiPoint_ChangeArray1(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _AppParCurves.AppParCurves_HArray1OfMultiPoint_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _AppParCurves.AppParCurves_HArray1OfMultiPoint_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _AppParCurves.AppParCurves_HArray1OfMultiPoint_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _AppParCurves.delete_AppParCurves_HArray1OfMultiPoint
AppParCurves_HArray1OfMultiPoint_swigregister = _AppParCurves.AppParCurves_HArray1OfMultiPoint_swigregister
AppParCurves_HArray1OfMultiPoint_swigregister(AppParCurves_HArray1OfMultiPoint)

def AppParCurves_HArray1OfMultiPoint_get_type_name(*args):
    """
    AppParCurves_HArray1OfMultiPoint_get_type_name() -> char const *

    :rtype: const char *

    """
    return _AppParCurves.AppParCurves_HArray1OfMultiPoint_get_type_name(*args)

def AppParCurves_HArray1OfMultiPoint_get_type_descriptor(*args):
    """
    AppParCurves_HArray1OfMultiPoint_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _AppParCurves.AppParCurves_HArray1OfMultiPoint_get_type_descriptor(*args)

class Handle_AppParCurves_HArray1OfMultiBSpCurve(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_AppParCurves_HArray1OfMultiBSpCurve self)

        Nullify the handle


        """
        return _AppParCurves.Handle_AppParCurves_HArray1OfMultiBSpCurve_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_AppParCurves_HArray1OfMultiBSpCurve self) -> bool

        Check for being null

        :rtype: bool

        """
        return _AppParCurves.Handle_AppParCurves_HArray1OfMultiBSpCurve_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_AppParCurves_HArray1OfMultiBSpCurve self, AppParCurves_HArray1OfMultiBSpCurve thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _AppParCurves.Handle_AppParCurves_HArray1OfMultiBSpCurve_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_AppParCurves_HArray1OfMultiBSpCurve self, Handle_AppParCurves_HArray1OfMultiBSpCurve theHandle) -> Handle_AppParCurves_HArray1OfMultiBSpCurve
        assign(Handle_AppParCurves_HArray1OfMultiBSpCurve self, AppParCurves_HArray1OfMultiBSpCurve thePtr) -> Handle_AppParCurves_HArray1OfMultiBSpCurve
        assign(Handle_AppParCurves_HArray1OfMultiBSpCurve self, Handle_AppParCurves_HArray1OfMultiBSpCurve theHandle) -> Handle_AppParCurves_HArray1OfMultiBSpCurve

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _AppParCurves.Handle_AppParCurves_HArray1OfMultiBSpCurve_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_AppParCurves_HArray1OfMultiBSpCurve self) -> AppParCurves_HArray1OfMultiBSpCurve

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _AppParCurves.Handle_AppParCurves_HArray1OfMultiBSpCurve_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_AppParCurves_HArray1OfMultiBSpCurve self) -> AppParCurves_HArray1OfMultiBSpCurve

        Member access operator (note non-const)

        :rtype: T *

        """
        return _AppParCurves.Handle_AppParCurves_HArray1OfMultiBSpCurve___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_AppParCurves_HArray1OfMultiBSpCurve self) -> AppParCurves_HArray1OfMultiBSpCurve

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _AppParCurves.Handle_AppParCurves_HArray1OfMultiBSpCurve___ref__(self, *args)


    def __hash__(self):
        return _AppParCurves.Handle_AppParCurves_HArray1OfMultiBSpCurve___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _AppParCurves.Handle_AppParCurves_HArray1OfMultiBSpCurve___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _AppParCurves.new_Handle_AppParCurves_HArray1OfMultiBSpCurve(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_AppParCurves.Handle_AppParCurves_HArray1OfMultiBSpCurve_DownCast)
    __swig_destroy__ = _AppParCurves.delete_Handle_AppParCurves_HArray1OfMultiBSpCurve

    def Array1(self, *args):
        """
        :rtype: OCC.wrapper.AppParCurves.AppParCurves_Array1OfMultiBSpCurve

        """
        res = _AppParCurves.Handle_AppParCurves_HArray1OfMultiBSpCurve_Array1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeArray1(self, *args):
        """
        ChangeArray1(Handle_AppParCurves_HArray1OfMultiBSpCurve self) -> NCollection_Array1_AppParCurves_MultiBSpCurve

        :rtype: OCC.wrapper.AppParCurves.AppParCurves_Array1OfMultiBSpCurve

        """
        return _AppParCurves.Handle_AppParCurves_HArray1OfMultiBSpCurve_ChangeArray1(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_AppParCurves_HArray1OfMultiBSpCurve self) -> char const *

        :rtype: const char *

        """
        return _AppParCurves.Handle_AppParCurves_HArray1OfMultiBSpCurve_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _AppParCurves.Handle_AppParCurves_HArray1OfMultiBSpCurve_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _AppParCurves.Handle_AppParCurves_HArray1OfMultiBSpCurve_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_AppParCurves_HArray1OfMultiBSpCurve self)

        Memory deallocator for transient classes


        """
        return _AppParCurves.Handle_AppParCurves_HArray1OfMultiBSpCurve_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_AppParCurves_HArray1OfMultiBSpCurve self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_AppParCurves_HArray1OfMultiBSpCurve self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AppParCurves.Handle_AppParCurves_HArray1OfMultiBSpCurve_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_AppParCurves_HArray1OfMultiBSpCurve self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_AppParCurves_HArray1OfMultiBSpCurve self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AppParCurves.Handle_AppParCurves_HArray1OfMultiBSpCurve_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_AppParCurves_HArray1OfMultiBSpCurve self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _AppParCurves.Handle_AppParCurves_HArray1OfMultiBSpCurve_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_AppParCurves_HArray1OfMultiBSpCurve self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AppParCurves.Handle_AppParCurves_HArray1OfMultiBSpCurve_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_AppParCurves_HArray1OfMultiBSpCurve self)

        Increments the reference counter of this object


        """
        return _AppParCurves.Handle_AppParCurves_HArray1OfMultiBSpCurve_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_AppParCurves_HArray1OfMultiBSpCurve self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AppParCurves.Handle_AppParCurves_HArray1OfMultiBSpCurve_DecrementRefCounter(self, *args)

Handle_AppParCurves_HArray1OfMultiBSpCurve_swigregister = _AppParCurves.Handle_AppParCurves_HArray1OfMultiBSpCurve_swigregister
Handle_AppParCurves_HArray1OfMultiBSpCurve_swigregister(Handle_AppParCurves_HArray1OfMultiBSpCurve)

def Handle_AppParCurves_HArray1OfMultiBSpCurve_DownCast(thing):
    return _AppParCurves.Handle_AppParCurves_HArray1OfMultiBSpCurve_DownCast(thing)
Handle_AppParCurves_HArray1OfMultiBSpCurve_DownCast = _AppParCurves.Handle_AppParCurves_HArray1OfMultiBSpCurve_DownCast

class NCollection_Sequence_AppParCurves_MultiBSpCurve(NCollection.NCollection_BaseSequence):
    """
    Purpose:     Definition of a sequence of elements indexed by
    an Integer in range of 1..n
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Sequence_AppParCurves_MultiBSpCurve self) -> NCollection_Sequence< AppParCurves_MultiBSpCurve >::iterator

        Returns an iterator pointing to the first element in the sequence.

        :rtype: iterator

        """
        return _AppParCurves.NCollection_Sequence_AppParCurves_MultiBSpCurve_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Sequence_AppParCurves_MultiBSpCurve self) -> NCollection_Sequence< AppParCurves_MultiBSpCurve >::iterator

        Returns an iterator referring to the past-the-end element in the sequence.

        :rtype: iterator

        """
        return _AppParCurves.NCollection_Sequence_AppParCurves_MultiBSpCurve_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Sequence_AppParCurves_MultiBSpCurve self) -> NCollection_Sequence< AppParCurves_MultiBSpCurve >::const_iterator

        Returns a const iterator pointing to the first element in the sequence.

        :rtype: const_iterator

        """
        return _AppParCurves.NCollection_Sequence_AppParCurves_MultiBSpCurve_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Sequence_AppParCurves_MultiBSpCurve self) -> NCollection_Sequence< AppParCurves_MultiBSpCurve >::const_iterator

        Returns a const iterator referring to the past-the-end element in the sequence.

        :rtype: const_iterator

        """
        return _AppParCurves.NCollection_Sequence_AppParCurves_MultiBSpCurve_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     Definition of a sequence of elements indexed by
        an Integer in range of 1..n
        """
        this = _AppParCurves.new_NCollection_Sequence_AppParCurves_MultiBSpCurve(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Size(self, *args):
        """
        Size(NCollection_Sequence_AppParCurves_MultiBSpCurve self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AppParCurves.NCollection_Sequence_AppParCurves_MultiBSpCurve_Size(self, *args)


    def Length(self, *args):
        """
        Length(NCollection_Sequence_AppParCurves_MultiBSpCurve self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AppParCurves.NCollection_Sequence_AppParCurves_MultiBSpCurve_Length(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Sequence_AppParCurves_MultiBSpCurve self) -> Standard_Integer

        Method for consistency with other collections.
        @return Lower bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AppParCurves.NCollection_Sequence_AppParCurves_MultiBSpCurve_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Sequence_AppParCurves_MultiBSpCurve self) -> Standard_Integer

        Method for consistency with other collections.
        @return Upper bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AppParCurves.NCollection_Sequence_AppParCurves_MultiBSpCurve_Upper(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Sequence_AppParCurves_MultiBSpCurve self) -> Standard_Boolean

        Empty query

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AppParCurves.NCollection_Sequence_AppParCurves_MultiBSpCurve_IsEmpty(self, *args)


    def Reverse(self, *args):
        """
        Reverse(NCollection_Sequence_AppParCurves_MultiBSpCurve self)

        Reverse sequence


        """
        return _AppParCurves.NCollection_Sequence_AppParCurves_MultiBSpCurve_Reverse(self, *args)


    def Exchange(self, *args):
        """
        Exchange(NCollection_Sequence_AppParCurves_MultiBSpCurve self, Standard_Integer const I, Standard_Integer const J)

        Exchange two members

        :type I: int
        :type J: int

        """
        return _AppParCurves.NCollection_Sequence_AppParCurves_MultiBSpCurve_Exchange(self, *args)


    def delNode(*args):
        """
        delNode(NCollection_SeqNode theNode, Handle_NCollection_BaseAllocator theAl)

        Static deleter to be passed to BaseSequence

        :type theNode: OCC.wrapper.NCollection.NCollection_SeqNode
        :type theAl: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _AppParCurves.NCollection_Sequence_AppParCurves_MultiBSpCurve_delNode(*args)

    delNode = staticmethod(delNode)

    def Clear(self, *args):
        """
        Clear(NCollection_Sequence_AppParCurves_MultiBSpCurve self, Handle_NCollection_BaseAllocator theAllocator=0)

        Clear the items out, take a new allocator if non null

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _AppParCurves.NCollection_Sequence_AppParCurves_MultiBSpCurve_Clear(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Sequence_AppParCurves_MultiBSpCurve self, NCollection_Sequence_AppParCurves_MultiBSpCurve theOther) -> NCollection_Sequence_AppParCurves_MultiBSpCurve

        Replace this sequence by the items of theOther.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_Sequence
        :rtype: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _AppParCurves.NCollection_Sequence_AppParCurves_MultiBSpCurve_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Sequence_AppParCurves_MultiBSpCurve self, NCollection_Sequence_AppParCurves_MultiBSpCurve theOther) -> NCollection_Sequence_AppParCurves_MultiBSpCurve

        Replacement operator

        :type theOther: OCC.wrapper.NCollection.NCollection_Sequence
        :rtype: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _AppParCurves.NCollection_Sequence_AppParCurves_MultiBSpCurve_assign(self, *args)


    def Remove(self, *args):
        """
        Remove(NCollection_Sequence_AppParCurves_MultiBSpCurve self, NCollection_Sequence< AppParCurves_MultiBSpCurve >::Iterator & thePosition)
        Remove(NCollection_Sequence_AppParCurves_MultiBSpCurve self, Standard_Integer const theIndex)
        Remove(NCollection_Sequence_AppParCurves_MultiBSpCurve self, Standard_Integer const theFromIndex, Standard_Integer const theToIndex)

        Remove range of items

        :type theFromIndex: int
        :type theToIndex: int

        """
        return _AppParCurves.NCollection_Sequence_AppParCurves_MultiBSpCurve_Remove(self, *args)


    def Append(self, *args):
        """
        Append(NCollection_Sequence_AppParCurves_MultiBSpCurve self, AppParCurves_MultiBSpCurve theItem)
        Append(NCollection_Sequence_AppParCurves_MultiBSpCurve self, NCollection_Sequence_AppParCurves_MultiBSpCurve theSeq)

        Append another sequence (making it empty)

        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _AppParCurves.NCollection_Sequence_AppParCurves_MultiBSpCurve_Append(self, *args)


    def Prepend(self, *args):
        """
        Prepend(NCollection_Sequence_AppParCurves_MultiBSpCurve self, AppParCurves_MultiBSpCurve theItem)
        Prepend(NCollection_Sequence_AppParCurves_MultiBSpCurve self, NCollection_Sequence_AppParCurves_MultiBSpCurve theSeq)

        Prepend another sequence (making it empty)

        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _AppParCurves.NCollection_Sequence_AppParCurves_MultiBSpCurve_Prepend(self, *args)


    def InsertBefore(self, *args):
        """
        InsertBefore(NCollection_Sequence_AppParCurves_MultiBSpCurve self, Standard_Integer const theIndex, AppParCurves_MultiBSpCurve theItem)
        InsertBefore(NCollection_Sequence_AppParCurves_MultiBSpCurve self, Standard_Integer const theIndex, NCollection_Sequence_AppParCurves_MultiBSpCurve theSeq)

        InsertBefore theIndex another sequence

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _AppParCurves.NCollection_Sequence_AppParCurves_MultiBSpCurve_InsertBefore(self, *args)


    def InsertAfter(self, *args):
        """
        InsertAfter(NCollection_Sequence_AppParCurves_MultiBSpCurve self, NCollection_Sequence< AppParCurves_MultiBSpCurve >::Iterator & thePosition, AppParCurves_MultiBSpCurve theItem)
        InsertAfter(NCollection_Sequence_AppParCurves_MultiBSpCurve self, Standard_Integer const theIndex, NCollection_Sequence_AppParCurves_MultiBSpCurve theSeq)
        InsertAfter(NCollection_Sequence_AppParCurves_MultiBSpCurve self, Standard_Integer const theIndex, AppParCurves_MultiBSpCurve theItem)

        InsertAfter theIndex another sequence

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _AppParCurves.NCollection_Sequence_AppParCurves_MultiBSpCurve_InsertAfter(self, *args)


    def Split(self, *args):
        """
        Split(NCollection_Sequence_AppParCurves_MultiBSpCurve self, Standard_Integer const theIndex, NCollection_Sequence_AppParCurves_MultiBSpCurve theSeq)

        Split in two sequences

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _AppParCurves.NCollection_Sequence_AppParCurves_MultiBSpCurve_Split(self, *args)


    def First(self, *args):
        """
        First item access

        :rtype: const TheItemType &

        """
        res = _AppParCurves.NCollection_Sequence_AppParCurves_MultiBSpCurve_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Sequence_AppParCurves_MultiBSpCurve self) -> AppParCurves_MultiBSpCurve

        First item access

        :rtype: TheItemType &

        """
        return _AppParCurves.NCollection_Sequence_AppParCurves_MultiBSpCurve_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        Last item access

        :rtype: const TheItemType &

        """
        res = _AppParCurves.NCollection_Sequence_AppParCurves_MultiBSpCurve_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Sequence_AppParCurves_MultiBSpCurve self) -> AppParCurves_MultiBSpCurve

        Last item access

        :rtype: TheItemType &

        """
        return _AppParCurves.NCollection_Sequence_AppParCurves_MultiBSpCurve_ChangeLast(self, *args)


    def Value(self, *args):
        """
        Constant item access by theIndex

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _AppParCurves.NCollection_Sequence_AppParCurves_MultiBSpCurve_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Sequence_AppParCurves_MultiBSpCurve self, Standard_Integer const theIndex) -> AppParCurves_MultiBSpCurve

        Variable item access by theIndex

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _AppParCurves.NCollection_Sequence_AppParCurves_MultiBSpCurve_ChangeValue(self, *args)


    def __call__(self, *args):
        """
        Constant operator()

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _AppParCurves.NCollection_Sequence_AppParCurves_MultiBSpCurve___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetValue(self, *args):
        """
        SetValue(NCollection_Sequence_AppParCurves_MultiBSpCurve self, Standard_Integer const theIndex, AppParCurves_MultiBSpCurve theItem)

        Set item value by theIndex

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _AppParCurves.NCollection_Sequence_AppParCurves_MultiBSpCurve_SetValue(self, *args)


    def __iter__(self):
        return _AppParCurves.NCollection_Sequence_AppParCurves_MultiBSpCurve___iter__(self)
    __swig_destroy__ = _AppParCurves.delete_NCollection_Sequence_AppParCurves_MultiBSpCurve
NCollection_Sequence_AppParCurves_MultiBSpCurve_swigregister = _AppParCurves.NCollection_Sequence_AppParCurves_MultiBSpCurve_swigregister
NCollection_Sequence_AppParCurves_MultiBSpCurve_swigregister(NCollection_Sequence_AppParCurves_MultiBSpCurve)

def NCollection_Sequence_AppParCurves_MultiBSpCurve_delNode(*args):
    """
    NCollection_Sequence_AppParCurves_MultiBSpCurve_delNode(NCollection_SeqNode theNode, Handle_NCollection_BaseAllocator theAl)

    Static deleter to be passed to BaseSequence

    :type theNode: OCC.wrapper.NCollection.NCollection_SeqNode
    :type theAl: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

    """
    return _AppParCurves.NCollection_Sequence_AppParCurves_MultiBSpCurve_delNode(*args)

class NCollection_Sequence_AppParCurves_MultiBSpCurve_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _AppParCurves.new_NCollection_Sequence_AppParCurves_MultiBSpCurve_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _AppParCurves.delete_NCollection_Sequence_AppParCurves_MultiBSpCurve_IteratorHelper

    def __next__(self):
        return _AppParCurves.NCollection_Sequence_AppParCurves_MultiBSpCurve_IteratorHelper___next__(self)
NCollection_Sequence_AppParCurves_MultiBSpCurve_IteratorHelper_swigregister = _AppParCurves.NCollection_Sequence_AppParCurves_MultiBSpCurve_IteratorHelper_swigregister
NCollection_Sequence_AppParCurves_MultiBSpCurve_IteratorHelper_swigregister(NCollection_Sequence_AppParCurves_MultiBSpCurve_IteratorHelper)


try:
	AppParCurves_SequenceOfMultiBSpCurve = NCollection_Sequence_AppParCurves_MultiBSpCurve
except NameError:
	pass # does not exist, probably ignored

class NCollection_Array1_AppParCurves_MultiBSpCurve(object):
    """
    Purpose:     The class Array1 represents unidimensional arrays 
    of fixed size known at run time. 
    The range of the index is user defined.
    An array1 can be constructed with a "C array".
    This functionality is useful to call methods expecting
    an Array1. It allows to carry the bounds inside the arrays.

    Examples:    Item tab[100]; //  An example with a C array
    Array1OfItem ttab (tab[0],1,100);

    Array1OfItem tttab (ttab(10),10,20); // a slice of ttab

    If you want to reindex an array from 1 to Length do :

    Array1 tab1(tab(tab.Lower()),1,tab.Length());

    Warning:     Programs client of such a class must be independant
    of the range of the first element. Then, a C++ for
    loop must be written like this

    for (i = A.Lower(); i <= A.Upper(); i++)

    Changes:     In  comparison  to  TCollection  the  flag  isAllocated  was
    renamed into myDeletable (alike in  the Array2).  For naming
    compatibility the method IsAllocated remained in class along
    with IsDeletable.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Array1_AppParCurves_MultiBSpCurve self) -> NCollection_Array1< AppParCurves_MultiBSpCurve >::iterator

        Returns an iterator pointing to the first element in the array.

        :rtype: iterator

        """
        return _AppParCurves.NCollection_Array1_AppParCurves_MultiBSpCurve_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Array1_AppParCurves_MultiBSpCurve self) -> NCollection_Array1< AppParCurves_MultiBSpCurve >::iterator

        Returns an iterator referring to the past-the-end element in the array.

        :rtype: iterator

        """
        return _AppParCurves.NCollection_Array1_AppParCurves_MultiBSpCurve_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Array1_AppParCurves_MultiBSpCurve self) -> NCollection_Array1< AppParCurves_MultiBSpCurve >::const_iterator

        Returns a const iterator pointing to the first element in the array.

        :rtype: const_iterator

        """
        return _AppParCurves.NCollection_Array1_AppParCurves_MultiBSpCurve_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Array1_AppParCurves_MultiBSpCurve self) -> NCollection_Array1< AppParCurves_MultiBSpCurve >::const_iterator

        Returns a const iterator referring to the past-the-end element in the array.

        :rtype: const_iterator

        """
        return _AppParCurves.NCollection_Array1_AppParCurves_MultiBSpCurve_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     The class Array1 represents unidimensional arrays 
        of fixed size known at run time. 
        The range of the index is user defined.
        An array1 can be constructed with a "C array".
        This functionality is useful to call methods expecting
        an Array1. It allows to carry the bounds inside the arrays.

        Examples:    Item tab[100]; //  An example with a C array
        Array1OfItem ttab (tab[0],1,100);

        Array1OfItem tttab (ttab(10),10,20); // a slice of ttab

        If you want to reindex an array from 1 to Length do :

        Array1 tab1(tab(tab.Lower()),1,tab.Length());

        Warning:     Programs client of such a class must be independant
        of the range of the first element. Then, a C++ for
        loop must be written like this

        for (i = A.Lower(); i <= A.Upper(); i++)

        Changes:     In  comparison  to  TCollection  the  flag  isAllocated  was
        renamed into myDeletable (alike in  the Array2).  For naming
        compatibility the method IsAllocated remained in class along
        with IsDeletable.
        """
        this = _AppParCurves.new_NCollection_Array1_AppParCurves_MultiBSpCurve(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(NCollection_Array1_AppParCurves_MultiBSpCurve self, AppParCurves_MultiBSpCurve theValue)

        Initialise the items with theValue

        :type theValue: const TheItemType &

        """
        return _AppParCurves.NCollection_Array1_AppParCurves_MultiBSpCurve_Init(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_Array1_AppParCurves_MultiBSpCurve self) -> Standard_Integer

        Size query

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AppParCurves.NCollection_Array1_AppParCurves_MultiBSpCurve_Size(self, *args)


    def Length(self, *args):
        """
        Length(NCollection_Array1_AppParCurves_MultiBSpCurve self) -> Standard_Integer

        Length query (the same)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AppParCurves.NCollection_Array1_AppParCurves_MultiBSpCurve_Length(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Array1_AppParCurves_MultiBSpCurve self) -> Standard_Boolean

        Return TRUE if array has zero length.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AppParCurves.NCollection_Array1_AppParCurves_MultiBSpCurve_IsEmpty(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Array1_AppParCurves_MultiBSpCurve self) -> Standard_Integer

        Lower bound

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AppParCurves.NCollection_Array1_AppParCurves_MultiBSpCurve_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Array1_AppParCurves_MultiBSpCurve self) -> Standard_Integer

        Upper bound

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AppParCurves.NCollection_Array1_AppParCurves_MultiBSpCurve_Upper(self, *args)


    def IsDeletable(self, *args):
        """
        IsDeletable(NCollection_Array1_AppParCurves_MultiBSpCurve self) -> Standard_Boolean

        myDeletable flag

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AppParCurves.NCollection_Array1_AppParCurves_MultiBSpCurve_IsDeletable(self, *args)


    def IsAllocated(self, *args):
        """
        IsAllocated(NCollection_Array1_AppParCurves_MultiBSpCurve self) -> Standard_Boolean

        IsAllocated flag - for naming compatibility

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AppParCurves.NCollection_Array1_AppParCurves_MultiBSpCurve_IsAllocated(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Array1_AppParCurves_MultiBSpCurve self, NCollection_Array1_AppParCurves_MultiBSpCurve theOther) -> NCollection_Array1_AppParCurves_MultiBSpCurve

        Copies data of theOther array to this.
        This array should be pre-allocated and have the same length as theOther;
        otherwise exception Standard_DimensionMismatch is thrown.

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _AppParCurves.NCollection_Array1_AppParCurves_MultiBSpCurve_Assign(self, *args)


    def Move(self, *args):
        """
        Move(NCollection_Array1_AppParCurves_MultiBSpCurve self, NCollection_Array1_AppParCurves_MultiBSpCurve theOther) -> NCollection_Array1_AppParCurves_MultiBSpCurve

        Move assignment.
        This array will borrow all the data from theOther.
        The moved object will keep pointer to the memory buffer and
        range, but it will not free the buffer on destruction.

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _AppParCurves.NCollection_Array1_AppParCurves_MultiBSpCurve_Move(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Array1_AppParCurves_MultiBSpCurve self, NCollection_Array1_AppParCurves_MultiBSpCurve theOther) -> NCollection_Array1_AppParCurves_MultiBSpCurve
        assign(NCollection_Array1_AppParCurves_MultiBSpCurve self, NCollection_Array1_AppParCurves_MultiBSpCurve theOther) -> NCollection_Array1_AppParCurves_MultiBSpCurve

        Move assignment operator; @sa Move()

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1<TheItemType> &&
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _AppParCurves.NCollection_Array1_AppParCurves_MultiBSpCurve_assign(self, *args)


    def First(self, *args):
        """
        @return first element

        :rtype: const TheItemType &

        """
        res = _AppParCurves.NCollection_Array1_AppParCurves_MultiBSpCurve_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Array1_AppParCurves_MultiBSpCurve self) -> AppParCurves_MultiBSpCurve

        @return first element

        :rtype: TheItemType &

        """
        return _AppParCurves.NCollection_Array1_AppParCurves_MultiBSpCurve_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        @return last element

        :rtype: const TheItemType &

        """
        res = _AppParCurves.NCollection_Array1_AppParCurves_MultiBSpCurve_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Array1_AppParCurves_MultiBSpCurve self) -> AppParCurves_MultiBSpCurve

        @return last element

        :rtype: TheItemType &

        """
        return _AppParCurves.NCollection_Array1_AppParCurves_MultiBSpCurve_ChangeLast(self, *args)


    def Value(self, *args):
        """
        Constant value access

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _AppParCurves.NCollection_Array1_AppParCurves_MultiBSpCurve_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Array1_AppParCurves_MultiBSpCurve self, Standard_Integer const theIndex) -> AppParCurves_MultiBSpCurve

        Variable value access

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _AppParCurves.NCollection_Array1_AppParCurves_MultiBSpCurve_ChangeValue(self, *args)


    def __call__(self, *args):
        """
        operator() - alias to Value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _AppParCurves.NCollection_Array1_AppParCurves_MultiBSpCurve___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __getitem__(self, *args):
        """
        operator[] - alias to Value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _AppParCurves.NCollection_Array1_AppParCurves_MultiBSpCurve_at(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetValue(self, *args):
        """
        SetValue(NCollection_Array1_AppParCurves_MultiBSpCurve self, Standard_Integer const theIndex, AppParCurves_MultiBSpCurve theItem)

        Set value 

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _AppParCurves.NCollection_Array1_AppParCurves_MultiBSpCurve_SetValue(self, *args)


    def Resize(self, *args):
        """
        Resize(NCollection_Array1_AppParCurves_MultiBSpCurve self, Standard_Integer const theLower, Standard_Integer const theUpper, Standard_Boolean const theToCopyData)

        Resizes the array to specified bounds.
        No re-allocation will be done if length of array does not change,
        but existing values will not be discarded if theToCopyData set to FALSE.
        @param theLower new lower bound of array
        @param theUpper new upper bound of array
        @param theToCopyData flag to copy existing data into new array

        :type theLower: int
        :type theUpper: int
        :type theToCopyData: bool

        """
        return _AppParCurves.NCollection_Array1_AppParCurves_MultiBSpCurve_Resize(self, *args)

    __swig_destroy__ = _AppParCurves.delete_NCollection_Array1_AppParCurves_MultiBSpCurve
NCollection_Array1_AppParCurves_MultiBSpCurve_swigregister = _AppParCurves.NCollection_Array1_AppParCurves_MultiBSpCurve_swigregister
NCollection_Array1_AppParCurves_MultiBSpCurve_swigregister(NCollection_Array1_AppParCurves_MultiBSpCurve)


try:
	AppParCurves_Array1OfMultiBSpCurve = NCollection_Array1_AppParCurves_MultiBSpCurve
except NameError:
	pass # does not exist, probably ignored

class AppParCurves_MultiPoint(object):
    """
    This class describes Points composing a MultiPoint.
    These points can be 2D or 3D. The user must first give the
    3D Points and then the 2D Points.
    They are Poles of a Bezier Curve.
    This class is used either to define data input or
    results when performing the approximation of several lines in parallel.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(AppParCurves_MultiPoint self) -> AppParCurves_MultiPoint
        __init__(AppParCurves_MultiPoint self, Standard_Integer const NbPoints, Standard_Integer const NbPoints2d) -> AppParCurves_MultiPoint
        __init__(AppParCurves_MultiPoint self, NCollection_Array1_gp_Pnt tabP) -> AppParCurves_MultiPoint
        __init__(AppParCurves_MultiPoint self, NCollection_Array1_gp_Pnt2d tabP2d) -> AppParCurves_MultiPoint
        __init__(AppParCurves_MultiPoint self, NCollection_Array1_gp_Pnt tabP, NCollection_Array1_gp_Pnt2d tabP2d) -> AppParCurves_MultiPoint

        constructs a set of Points used to approximate a
        Multiline.
        These Points can be of 2 or 3 dimensions.
        Points will be initialized with SetPoint and SetPoint2d.
        NbPoints is the total number of Points.

        :type tabP: OCC.wrapper.TColgp.TColgp_Array1OfPnt
        :type tabP2d: OCC.wrapper.TColgp.TColgp_Array1OfPnt2d

        """
        this = _AppParCurves.new_AppParCurves_MultiPoint(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def SetPoint(self, *args):
        """
        SetPoint(AppParCurves_MultiPoint self, Standard_Integer const Index, gp_Pnt Point)

        the 3d Point of range Index of this MultiPoint is
        set to <Point>.
        An exception is raised if Index < 0 or
        Index > number of 3d Points.

        :type Index: int
        :type Point: OCC.wrapper.gp.gp_Pnt

        """
        return _AppParCurves.AppParCurves_MultiPoint_SetPoint(self, *args)


    def Point(self, *args):
        """
        returns the 3d Point of range Index.
        An exception is raised if Index < 0 or
        Index < number of 3d Points.

        :type Index: int
        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        res = _AppParCurves.AppParCurves_MultiPoint_Point(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetPoint2d(self, *args):
        """
        SetPoint2d(AppParCurves_MultiPoint self, Standard_Integer const Index, gp_Pnt2d Point)

        The 2d Point of range Index is set to <Point>.
        An exception is raised if Index > 3d Points or
        Index > total number of Points.

        :type Index: int
        :type Point: OCC.wrapper.gp.gp_Pnt2d

        """
        return _AppParCurves.AppParCurves_MultiPoint_SetPoint2d(self, *args)


    def Point2d(self, *args):
        """
        returns the 2d Point of range Index.
        An exception is raised if index <= number of
        3d Points or Index > total number of Points.

        :type Index: int
        :rtype: OCC.wrapper.gp.gp_Pnt2d

        """
        res = _AppParCurves.AppParCurves_MultiPoint_Point2d(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Dimension(self, *args):
        """
        Dimension(AppParCurves_MultiPoint self, Standard_Integer const Index) -> Standard_Integer

        returns the dimension of the point of range Index.
        An exception is raised if Index <0 or Index > NbCurves.

        :type Index: int
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AppParCurves.AppParCurves_MultiPoint_Dimension(self, *args)


    def NbPoints(self, *args):
        """
        NbPoints(AppParCurves_MultiPoint self) -> Standard_Integer

        returns the number of points of dimension 3D.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AppParCurves.AppParCurves_MultiPoint_NbPoints(self, *args)


    def NbPoints2d(self, *args):
        """
        NbPoints2d(AppParCurves_MultiPoint self) -> Standard_Integer

        returns the number of points of dimension 2D.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AppParCurves.AppParCurves_MultiPoint_NbPoints2d(self, *args)


    def Transform(self, *args):
        """
        Transform(AppParCurves_MultiPoint self, Standard_Integer const CuIndex, Standard_Real const x, Standard_Real const dx, Standard_Real const y, Standard_Real const dy, Standard_Real const z, Standard_Real const dz)

        Applies a transformation to the curve of range
        <CuIndex>.
        newx = x + dx*oldx
        newy = y + dy*oldy    for all points of the curve.
        newz = z + dz*oldz

        :type CuIndex: int
        :type x: float
        :type dx: float
        :type y: float
        :type dy: float
        :type z: float
        :type dz: float

        """
        return _AppParCurves.AppParCurves_MultiPoint_Transform(self, *args)


    def Transform2d(self, *args):
        """
        Transform2d(AppParCurves_MultiPoint self, Standard_Integer const CuIndex, Standard_Real const x, Standard_Real const dx, Standard_Real const y, Standard_Real const dy)

        Applies a transformation to the Curve of range
        <CuIndex>.
        newx = x + dx*oldx
        newy = y + dy*oldy    for all points of the curve.

        :type CuIndex: int
        :type x: float
        :type dx: float
        :type y: float
        :type dy: float

        """
        return _AppParCurves.AppParCurves_MultiPoint_Transform2d(self, *args)


    def Dump(self, *args):
        """
        Dump(AppParCurves_MultiPoint self, Standard_OStream & o)

        Prints on the stream o information on the current
        state of the object.
        Is used to redefine the operator <<.

        :type o: OCC.wrapper.Standard.Standard_OStream

        """
        return _AppParCurves.AppParCurves_MultiPoint_Dump(self, *args)

    __swig_destroy__ = _AppParCurves.delete_AppParCurves_MultiPoint
AppParCurves_MultiPoint_swigregister = _AppParCurves.AppParCurves_MultiPoint_swigregister
AppParCurves_MultiPoint_swigregister(AppParCurves_MultiPoint)

class AppParCurves_(object):
    """
    Parallel Approximation in n curves.
    This package gives all the algorithms used to approximate a MultiLine
    described by the tool MLineTool.
    The result of the approximation will be a MultiCurve.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def BernsteinMatrix(*args):
        """
        BernsteinMatrix(Standard_Integer const NbPoles, math_Vector U, math_Matrix A)

        :type NbPoles: int
        :type U: OCC.wrapper.math.math_Vector
        :type A: OCC.wrapper.math.math_Matrix

        """
        return _AppParCurves.AppParCurves__BernsteinMatrix(*args)

    BernsteinMatrix = staticmethod(BernsteinMatrix)

    def Bernstein(*args):
        """
        Bernstein(Standard_Integer const NbPoles, math_Vector U, math_Matrix A, math_Matrix DA)

        :type NbPoles: int
        :type U: OCC.wrapper.math.math_Vector
        :type A: OCC.wrapper.math.math_Matrix
        :type DA: OCC.wrapper.math.math_Matrix

        """
        return _AppParCurves.AppParCurves__Bernstein(*args)

    Bernstein = staticmethod(Bernstein)

    def SecondDerivativeBernstein(*args):
        """
        SecondDerivativeBernstein(Standard_Real const U, math_Vector DDA)

        :type U: float
        :type DDA: OCC.wrapper.math.math_Vector

        """
        return _AppParCurves.AppParCurves__SecondDerivativeBernstein(*args)

    SecondDerivativeBernstein = staticmethod(SecondDerivativeBernstein)

    def SplineFunction(*args):
        """
        SplineFunction(Standard_Integer const NbPoles, Standard_Integer const Degree, math_Vector Parameters, math_Vector FlatKnots, math_Matrix A, math_Matrix DA, math_IntegerVector Index)

        :type NbPoles: int
        :type Degree: int
        :type Parameters: OCC.wrapper.math.math_Vector
        :type FlatKnots: OCC.wrapper.math.math_Vector
        :type A: OCC.wrapper.math.math_Matrix
        :type DA: OCC.wrapper.math.math_Matrix
        :type Index: OCC.wrapper.math.math_IntegerVector

        """
        return _AppParCurves.AppParCurves__SplineFunction(*args)

    SplineFunction = staticmethod(SplineFunction)

    def __init__(self):
        """
        Parallel Approximation in n curves.
        This package gives all the algorithms used to approximate a MultiLine
        described by the tool MLineTool.
        The result of the approximation will be a MultiCurve.
        """
        this = _AppParCurves.new_AppParCurves_()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _AppParCurves.delete_AppParCurves_
AppParCurves__swigregister = _AppParCurves.AppParCurves__swigregister
AppParCurves__swigregister(AppParCurves_)

def AppParCurves__BernsteinMatrix(*args):
    """
    AppParCurves__BernsteinMatrix(Standard_Integer const NbPoles, math_Vector U, math_Matrix A)

    :type NbPoles: int
    :type U: OCC.wrapper.math.math_Vector
    :type A: OCC.wrapper.math.math_Matrix

    """
    return _AppParCurves.AppParCurves__BernsteinMatrix(*args)

def AppParCurves__Bernstein(*args):
    """
    AppParCurves__Bernstein(Standard_Integer const NbPoles, math_Vector U, math_Matrix A, math_Matrix DA)

    :type NbPoles: int
    :type U: OCC.wrapper.math.math_Vector
    :type A: OCC.wrapper.math.math_Matrix
    :type DA: OCC.wrapper.math.math_Matrix

    """
    return _AppParCurves.AppParCurves__Bernstein(*args)

def AppParCurves__SecondDerivativeBernstein(*args):
    """
    AppParCurves__SecondDerivativeBernstein(Standard_Real const U, math_Vector DDA)

    :type U: float
    :type DDA: OCC.wrapper.math.math_Vector

    """
    return _AppParCurves.AppParCurves__SecondDerivativeBernstein(*args)

def AppParCurves__SplineFunction(*args):
    """
    AppParCurves__SplineFunction(Standard_Integer const NbPoles, Standard_Integer const Degree, math_Vector Parameters, math_Vector FlatKnots, math_Matrix A, math_Matrix DA, math_IntegerVector Index)

    :type NbPoles: int
    :type Degree: int
    :type Parameters: OCC.wrapper.math.math_Vector
    :type FlatKnots: OCC.wrapper.math.math_Vector
    :type A: OCC.wrapper.math.math_Matrix
    :type DA: OCC.wrapper.math.math_Matrix
    :type Index: OCC.wrapper.math.math_IntegerVector

    """
    return _AppParCurves.AppParCurves__SplineFunction(*args)

class NCollection_Array1_AppParCurves_MultiCurve(object):
    """
    Purpose:     The class Array1 represents unidimensional arrays 
    of fixed size known at run time. 
    The range of the index is user defined.
    An array1 can be constructed with a "C array".
    This functionality is useful to call methods expecting
    an Array1. It allows to carry the bounds inside the arrays.

    Examples:    Item tab[100]; //  An example with a C array
    Array1OfItem ttab (tab[0],1,100);

    Array1OfItem tttab (ttab(10),10,20); // a slice of ttab

    If you want to reindex an array from 1 to Length do :

    Array1 tab1(tab(tab.Lower()),1,tab.Length());

    Warning:     Programs client of such a class must be independant
    of the range of the first element. Then, a C++ for
    loop must be written like this

    for (i = A.Lower(); i <= A.Upper(); i++)

    Changes:     In  comparison  to  TCollection  the  flag  isAllocated  was
    renamed into myDeletable (alike in  the Array2).  For naming
    compatibility the method IsAllocated remained in class along
    with IsDeletable.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Array1_AppParCurves_MultiCurve self) -> NCollection_Array1< AppParCurves_MultiCurve >::iterator

        Returns an iterator pointing to the first element in the array.

        :rtype: iterator

        """
        return _AppParCurves.NCollection_Array1_AppParCurves_MultiCurve_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Array1_AppParCurves_MultiCurve self) -> NCollection_Array1< AppParCurves_MultiCurve >::iterator

        Returns an iterator referring to the past-the-end element in the array.

        :rtype: iterator

        """
        return _AppParCurves.NCollection_Array1_AppParCurves_MultiCurve_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Array1_AppParCurves_MultiCurve self) -> NCollection_Array1< AppParCurves_MultiCurve >::const_iterator

        Returns a const iterator pointing to the first element in the array.

        :rtype: const_iterator

        """
        return _AppParCurves.NCollection_Array1_AppParCurves_MultiCurve_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Array1_AppParCurves_MultiCurve self) -> NCollection_Array1< AppParCurves_MultiCurve >::const_iterator

        Returns a const iterator referring to the past-the-end element in the array.

        :rtype: const_iterator

        """
        return _AppParCurves.NCollection_Array1_AppParCurves_MultiCurve_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     The class Array1 represents unidimensional arrays 
        of fixed size known at run time. 
        The range of the index is user defined.
        An array1 can be constructed with a "C array".
        This functionality is useful to call methods expecting
        an Array1. It allows to carry the bounds inside the arrays.

        Examples:    Item tab[100]; //  An example with a C array
        Array1OfItem ttab (tab[0],1,100);

        Array1OfItem tttab (ttab(10),10,20); // a slice of ttab

        If you want to reindex an array from 1 to Length do :

        Array1 tab1(tab(tab.Lower()),1,tab.Length());

        Warning:     Programs client of such a class must be independant
        of the range of the first element. Then, a C++ for
        loop must be written like this

        for (i = A.Lower(); i <= A.Upper(); i++)

        Changes:     In  comparison  to  TCollection  the  flag  isAllocated  was
        renamed into myDeletable (alike in  the Array2).  For naming
        compatibility the method IsAllocated remained in class along
        with IsDeletable.
        """
        this = _AppParCurves.new_NCollection_Array1_AppParCurves_MultiCurve(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(NCollection_Array1_AppParCurves_MultiCurve self, AppParCurves_MultiCurve theValue)

        Initialise the items with theValue

        :type theValue: const TheItemType &

        """
        return _AppParCurves.NCollection_Array1_AppParCurves_MultiCurve_Init(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_Array1_AppParCurves_MultiCurve self) -> Standard_Integer

        Size query

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AppParCurves.NCollection_Array1_AppParCurves_MultiCurve_Size(self, *args)


    def Length(self, *args):
        """
        Length(NCollection_Array1_AppParCurves_MultiCurve self) -> Standard_Integer

        Length query (the same)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AppParCurves.NCollection_Array1_AppParCurves_MultiCurve_Length(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Array1_AppParCurves_MultiCurve self) -> Standard_Boolean

        Return TRUE if array has zero length.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AppParCurves.NCollection_Array1_AppParCurves_MultiCurve_IsEmpty(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Array1_AppParCurves_MultiCurve self) -> Standard_Integer

        Lower bound

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AppParCurves.NCollection_Array1_AppParCurves_MultiCurve_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Array1_AppParCurves_MultiCurve self) -> Standard_Integer

        Upper bound

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AppParCurves.NCollection_Array1_AppParCurves_MultiCurve_Upper(self, *args)


    def IsDeletable(self, *args):
        """
        IsDeletable(NCollection_Array1_AppParCurves_MultiCurve self) -> Standard_Boolean

        myDeletable flag

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AppParCurves.NCollection_Array1_AppParCurves_MultiCurve_IsDeletable(self, *args)


    def IsAllocated(self, *args):
        """
        IsAllocated(NCollection_Array1_AppParCurves_MultiCurve self) -> Standard_Boolean

        IsAllocated flag - for naming compatibility

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AppParCurves.NCollection_Array1_AppParCurves_MultiCurve_IsAllocated(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Array1_AppParCurves_MultiCurve self, NCollection_Array1_AppParCurves_MultiCurve theOther) -> NCollection_Array1_AppParCurves_MultiCurve

        Copies data of theOther array to this.
        This array should be pre-allocated and have the same length as theOther;
        otherwise exception Standard_DimensionMismatch is thrown.

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _AppParCurves.NCollection_Array1_AppParCurves_MultiCurve_Assign(self, *args)


    def Move(self, *args):
        """
        Move(NCollection_Array1_AppParCurves_MultiCurve self, NCollection_Array1_AppParCurves_MultiCurve theOther) -> NCollection_Array1_AppParCurves_MultiCurve

        Move assignment.
        This array will borrow all the data from theOther.
        The moved object will keep pointer to the memory buffer and
        range, but it will not free the buffer on destruction.

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _AppParCurves.NCollection_Array1_AppParCurves_MultiCurve_Move(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Array1_AppParCurves_MultiCurve self, NCollection_Array1_AppParCurves_MultiCurve theOther) -> NCollection_Array1_AppParCurves_MultiCurve
        assign(NCollection_Array1_AppParCurves_MultiCurve self, NCollection_Array1_AppParCurves_MultiCurve theOther) -> NCollection_Array1_AppParCurves_MultiCurve

        Move assignment operator; @sa Move()

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1<TheItemType> &&
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _AppParCurves.NCollection_Array1_AppParCurves_MultiCurve_assign(self, *args)


    def First(self, *args):
        """
        @return first element

        :rtype: const TheItemType &

        """
        res = _AppParCurves.NCollection_Array1_AppParCurves_MultiCurve_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Array1_AppParCurves_MultiCurve self) -> AppParCurves_MultiCurve

        @return first element

        :rtype: TheItemType &

        """
        return _AppParCurves.NCollection_Array1_AppParCurves_MultiCurve_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        @return last element

        :rtype: const TheItemType &

        """
        res = _AppParCurves.NCollection_Array1_AppParCurves_MultiCurve_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Array1_AppParCurves_MultiCurve self) -> AppParCurves_MultiCurve

        @return last element

        :rtype: TheItemType &

        """
        return _AppParCurves.NCollection_Array1_AppParCurves_MultiCurve_ChangeLast(self, *args)


    def Value(self, *args):
        """
        Constant value access

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _AppParCurves.NCollection_Array1_AppParCurves_MultiCurve_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Array1_AppParCurves_MultiCurve self, Standard_Integer const theIndex) -> AppParCurves_MultiCurve

        Variable value access

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _AppParCurves.NCollection_Array1_AppParCurves_MultiCurve_ChangeValue(self, *args)


    def __call__(self, *args):
        """
        operator() - alias to Value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _AppParCurves.NCollection_Array1_AppParCurves_MultiCurve___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __getitem__(self, *args):
        """
        operator[] - alias to Value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _AppParCurves.NCollection_Array1_AppParCurves_MultiCurve_at(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetValue(self, *args):
        """
        SetValue(NCollection_Array1_AppParCurves_MultiCurve self, Standard_Integer const theIndex, AppParCurves_MultiCurve theItem)

        Set value 

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _AppParCurves.NCollection_Array1_AppParCurves_MultiCurve_SetValue(self, *args)


    def Resize(self, *args):
        """
        Resize(NCollection_Array1_AppParCurves_MultiCurve self, Standard_Integer const theLower, Standard_Integer const theUpper, Standard_Boolean const theToCopyData)

        Resizes the array to specified bounds.
        No re-allocation will be done if length of array does not change,
        but existing values will not be discarded if theToCopyData set to FALSE.
        @param theLower new lower bound of array
        @param theUpper new upper bound of array
        @param theToCopyData flag to copy existing data into new array

        :type theLower: int
        :type theUpper: int
        :type theToCopyData: bool

        """
        return _AppParCurves.NCollection_Array1_AppParCurves_MultiCurve_Resize(self, *args)

    __swig_destroy__ = _AppParCurves.delete_NCollection_Array1_AppParCurves_MultiCurve
NCollection_Array1_AppParCurves_MultiCurve_swigregister = _AppParCurves.NCollection_Array1_AppParCurves_MultiCurve_swigregister
NCollection_Array1_AppParCurves_MultiCurve_swigregister(NCollection_Array1_AppParCurves_MultiCurve)


try:
	AppParCurves_Array1OfMultiCurve = NCollection_Array1_AppParCurves_MultiCurve
except NameError:
	pass # does not exist, probably ignored

class Handle_AppParCurves_HArray1OfConstraintCouple(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_AppParCurves_HArray1OfConstraintCouple self)

        Nullify the handle


        """
        return _AppParCurves.Handle_AppParCurves_HArray1OfConstraintCouple_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_AppParCurves_HArray1OfConstraintCouple self) -> bool

        Check for being null

        :rtype: bool

        """
        return _AppParCurves.Handle_AppParCurves_HArray1OfConstraintCouple_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_AppParCurves_HArray1OfConstraintCouple self, AppParCurves_HArray1OfConstraintCouple thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _AppParCurves.Handle_AppParCurves_HArray1OfConstraintCouple_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_AppParCurves_HArray1OfConstraintCouple self, Handle_AppParCurves_HArray1OfConstraintCouple theHandle) -> Handle_AppParCurves_HArray1OfConstraintCouple
        assign(Handle_AppParCurves_HArray1OfConstraintCouple self, AppParCurves_HArray1OfConstraintCouple thePtr) -> Handle_AppParCurves_HArray1OfConstraintCouple
        assign(Handle_AppParCurves_HArray1OfConstraintCouple self, Handle_AppParCurves_HArray1OfConstraintCouple theHandle) -> Handle_AppParCurves_HArray1OfConstraintCouple

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _AppParCurves.Handle_AppParCurves_HArray1OfConstraintCouple_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_AppParCurves_HArray1OfConstraintCouple self) -> AppParCurves_HArray1OfConstraintCouple

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _AppParCurves.Handle_AppParCurves_HArray1OfConstraintCouple_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_AppParCurves_HArray1OfConstraintCouple self) -> AppParCurves_HArray1OfConstraintCouple

        Member access operator (note non-const)

        :rtype: T *

        """
        return _AppParCurves.Handle_AppParCurves_HArray1OfConstraintCouple___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_AppParCurves_HArray1OfConstraintCouple self) -> AppParCurves_HArray1OfConstraintCouple

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _AppParCurves.Handle_AppParCurves_HArray1OfConstraintCouple___ref__(self, *args)


    def __hash__(self):
        return _AppParCurves.Handle_AppParCurves_HArray1OfConstraintCouple___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _AppParCurves.Handle_AppParCurves_HArray1OfConstraintCouple___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _AppParCurves.new_Handle_AppParCurves_HArray1OfConstraintCouple(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_AppParCurves.Handle_AppParCurves_HArray1OfConstraintCouple_DownCast)
    __swig_destroy__ = _AppParCurves.delete_Handle_AppParCurves_HArray1OfConstraintCouple

    def Array1(self, *args):
        """
        :rtype: OCC.wrapper.AppParCurves.AppParCurves_Array1OfConstraintCouple

        """
        res = _AppParCurves.Handle_AppParCurves_HArray1OfConstraintCouple_Array1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeArray1(self, *args):
        """
        ChangeArray1(Handle_AppParCurves_HArray1OfConstraintCouple self) -> NCollection_Array1_AppParCurves_ConstraintCouple

        :rtype: OCC.wrapper.AppParCurves.AppParCurves_Array1OfConstraintCouple

        """
        return _AppParCurves.Handle_AppParCurves_HArray1OfConstraintCouple_ChangeArray1(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_AppParCurves_HArray1OfConstraintCouple self) -> char const *

        :rtype: const char *

        """
        return _AppParCurves.Handle_AppParCurves_HArray1OfConstraintCouple_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _AppParCurves.Handle_AppParCurves_HArray1OfConstraintCouple_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _AppParCurves.Handle_AppParCurves_HArray1OfConstraintCouple_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_AppParCurves_HArray1OfConstraintCouple self)

        Memory deallocator for transient classes


        """
        return _AppParCurves.Handle_AppParCurves_HArray1OfConstraintCouple_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_AppParCurves_HArray1OfConstraintCouple self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_AppParCurves_HArray1OfConstraintCouple self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AppParCurves.Handle_AppParCurves_HArray1OfConstraintCouple_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_AppParCurves_HArray1OfConstraintCouple self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_AppParCurves_HArray1OfConstraintCouple self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AppParCurves.Handle_AppParCurves_HArray1OfConstraintCouple_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_AppParCurves_HArray1OfConstraintCouple self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _AppParCurves.Handle_AppParCurves_HArray1OfConstraintCouple_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_AppParCurves_HArray1OfConstraintCouple self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AppParCurves.Handle_AppParCurves_HArray1OfConstraintCouple_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_AppParCurves_HArray1OfConstraintCouple self)

        Increments the reference counter of this object


        """
        return _AppParCurves.Handle_AppParCurves_HArray1OfConstraintCouple_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_AppParCurves_HArray1OfConstraintCouple self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AppParCurves.Handle_AppParCurves_HArray1OfConstraintCouple_DecrementRefCounter(self, *args)

Handle_AppParCurves_HArray1OfConstraintCouple_swigregister = _AppParCurves.Handle_AppParCurves_HArray1OfConstraintCouple_swigregister
Handle_AppParCurves_HArray1OfConstraintCouple_swigregister(Handle_AppParCurves_HArray1OfConstraintCouple)

def Handle_AppParCurves_HArray1OfConstraintCouple_DownCast(thing):
    return _AppParCurves.Handle_AppParCurves_HArray1OfConstraintCouple_DownCast(thing)
Handle_AppParCurves_HArray1OfConstraintCouple_DownCast = _AppParCurves.Handle_AppParCurves_HArray1OfConstraintCouple_DownCast

class NCollection_Array1_AppParCurves_ConstraintCouple(object):
    """
    Purpose:     The class Array1 represents unidimensional arrays 
    of fixed size known at run time. 
    The range of the index is user defined.
    An array1 can be constructed with a "C array".
    This functionality is useful to call methods expecting
    an Array1. It allows to carry the bounds inside the arrays.

    Examples:    Item tab[100]; //  An example with a C array
    Array1OfItem ttab (tab[0],1,100);

    Array1OfItem tttab (ttab(10),10,20); // a slice of ttab

    If you want to reindex an array from 1 to Length do :

    Array1 tab1(tab(tab.Lower()),1,tab.Length());

    Warning:     Programs client of such a class must be independant
    of the range of the first element. Then, a C++ for
    loop must be written like this

    for (i = A.Lower(); i <= A.Upper(); i++)

    Changes:     In  comparison  to  TCollection  the  flag  isAllocated  was
    renamed into myDeletable (alike in  the Array2).  For naming
    compatibility the method IsAllocated remained in class along
    with IsDeletable.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Array1_AppParCurves_ConstraintCouple self) -> NCollection_Array1< AppParCurves_ConstraintCouple >::iterator

        Returns an iterator pointing to the first element in the array.

        :rtype: iterator

        """
        return _AppParCurves.NCollection_Array1_AppParCurves_ConstraintCouple_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Array1_AppParCurves_ConstraintCouple self) -> NCollection_Array1< AppParCurves_ConstraintCouple >::iterator

        Returns an iterator referring to the past-the-end element in the array.

        :rtype: iterator

        """
        return _AppParCurves.NCollection_Array1_AppParCurves_ConstraintCouple_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Array1_AppParCurves_ConstraintCouple self) -> NCollection_Array1< AppParCurves_ConstraintCouple >::const_iterator

        Returns a const iterator pointing to the first element in the array.

        :rtype: const_iterator

        """
        return _AppParCurves.NCollection_Array1_AppParCurves_ConstraintCouple_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Array1_AppParCurves_ConstraintCouple self) -> NCollection_Array1< AppParCurves_ConstraintCouple >::const_iterator

        Returns a const iterator referring to the past-the-end element in the array.

        :rtype: const_iterator

        """
        return _AppParCurves.NCollection_Array1_AppParCurves_ConstraintCouple_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     The class Array1 represents unidimensional arrays 
        of fixed size known at run time. 
        The range of the index is user defined.
        An array1 can be constructed with a "C array".
        This functionality is useful to call methods expecting
        an Array1. It allows to carry the bounds inside the arrays.

        Examples:    Item tab[100]; //  An example with a C array
        Array1OfItem ttab (tab[0],1,100);

        Array1OfItem tttab (ttab(10),10,20); // a slice of ttab

        If you want to reindex an array from 1 to Length do :

        Array1 tab1(tab(tab.Lower()),1,tab.Length());

        Warning:     Programs client of such a class must be independant
        of the range of the first element. Then, a C++ for
        loop must be written like this

        for (i = A.Lower(); i <= A.Upper(); i++)

        Changes:     In  comparison  to  TCollection  the  flag  isAllocated  was
        renamed into myDeletable (alike in  the Array2).  For naming
        compatibility the method IsAllocated remained in class along
        with IsDeletable.
        """
        this = _AppParCurves.new_NCollection_Array1_AppParCurves_ConstraintCouple(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(NCollection_Array1_AppParCurves_ConstraintCouple self, AppParCurves_ConstraintCouple theValue)

        Initialise the items with theValue

        :type theValue: const TheItemType &

        """
        return _AppParCurves.NCollection_Array1_AppParCurves_ConstraintCouple_Init(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_Array1_AppParCurves_ConstraintCouple self) -> Standard_Integer

        Size query

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AppParCurves.NCollection_Array1_AppParCurves_ConstraintCouple_Size(self, *args)


    def Length(self, *args):
        """
        Length(NCollection_Array1_AppParCurves_ConstraintCouple self) -> Standard_Integer

        Length query (the same)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AppParCurves.NCollection_Array1_AppParCurves_ConstraintCouple_Length(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Array1_AppParCurves_ConstraintCouple self) -> Standard_Boolean

        Return TRUE if array has zero length.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AppParCurves.NCollection_Array1_AppParCurves_ConstraintCouple_IsEmpty(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Array1_AppParCurves_ConstraintCouple self) -> Standard_Integer

        Lower bound

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AppParCurves.NCollection_Array1_AppParCurves_ConstraintCouple_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Array1_AppParCurves_ConstraintCouple self) -> Standard_Integer

        Upper bound

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AppParCurves.NCollection_Array1_AppParCurves_ConstraintCouple_Upper(self, *args)


    def IsDeletable(self, *args):
        """
        IsDeletable(NCollection_Array1_AppParCurves_ConstraintCouple self) -> Standard_Boolean

        myDeletable flag

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AppParCurves.NCollection_Array1_AppParCurves_ConstraintCouple_IsDeletable(self, *args)


    def IsAllocated(self, *args):
        """
        IsAllocated(NCollection_Array1_AppParCurves_ConstraintCouple self) -> Standard_Boolean

        IsAllocated flag - for naming compatibility

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AppParCurves.NCollection_Array1_AppParCurves_ConstraintCouple_IsAllocated(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Array1_AppParCurves_ConstraintCouple self, NCollection_Array1_AppParCurves_ConstraintCouple theOther) -> NCollection_Array1_AppParCurves_ConstraintCouple

        Copies data of theOther array to this.
        This array should be pre-allocated and have the same length as theOther;
        otherwise exception Standard_DimensionMismatch is thrown.

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _AppParCurves.NCollection_Array1_AppParCurves_ConstraintCouple_Assign(self, *args)


    def Move(self, *args):
        """
        Move(NCollection_Array1_AppParCurves_ConstraintCouple self, NCollection_Array1_AppParCurves_ConstraintCouple theOther) -> NCollection_Array1_AppParCurves_ConstraintCouple

        Move assignment.
        This array will borrow all the data from theOther.
        The moved object will keep pointer to the memory buffer and
        range, but it will not free the buffer on destruction.

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _AppParCurves.NCollection_Array1_AppParCurves_ConstraintCouple_Move(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Array1_AppParCurves_ConstraintCouple self, NCollection_Array1_AppParCurves_ConstraintCouple theOther) -> NCollection_Array1_AppParCurves_ConstraintCouple
        assign(NCollection_Array1_AppParCurves_ConstraintCouple self, NCollection_Array1_AppParCurves_ConstraintCouple theOther) -> NCollection_Array1_AppParCurves_ConstraintCouple

        Move assignment operator; @sa Move()

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1<TheItemType> &&
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _AppParCurves.NCollection_Array1_AppParCurves_ConstraintCouple_assign(self, *args)


    def First(self, *args):
        """
        @return first element

        :rtype: const TheItemType &

        """
        res = _AppParCurves.NCollection_Array1_AppParCurves_ConstraintCouple_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Array1_AppParCurves_ConstraintCouple self) -> AppParCurves_ConstraintCouple

        @return first element

        :rtype: TheItemType &

        """
        return _AppParCurves.NCollection_Array1_AppParCurves_ConstraintCouple_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        @return last element

        :rtype: const TheItemType &

        """
        res = _AppParCurves.NCollection_Array1_AppParCurves_ConstraintCouple_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Array1_AppParCurves_ConstraintCouple self) -> AppParCurves_ConstraintCouple

        @return last element

        :rtype: TheItemType &

        """
        return _AppParCurves.NCollection_Array1_AppParCurves_ConstraintCouple_ChangeLast(self, *args)


    def Value(self, *args):
        """
        Constant value access

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _AppParCurves.NCollection_Array1_AppParCurves_ConstraintCouple_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Array1_AppParCurves_ConstraintCouple self, Standard_Integer const theIndex) -> AppParCurves_ConstraintCouple

        Variable value access

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _AppParCurves.NCollection_Array1_AppParCurves_ConstraintCouple_ChangeValue(self, *args)


    def __call__(self, *args):
        """
        operator() - alias to Value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _AppParCurves.NCollection_Array1_AppParCurves_ConstraintCouple___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __getitem__(self, *args):
        """
        operator[] - alias to Value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _AppParCurves.NCollection_Array1_AppParCurves_ConstraintCouple_at(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetValue(self, *args):
        """
        SetValue(NCollection_Array1_AppParCurves_ConstraintCouple self, Standard_Integer const theIndex, AppParCurves_ConstraintCouple theItem)

        Set value 

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _AppParCurves.NCollection_Array1_AppParCurves_ConstraintCouple_SetValue(self, *args)


    def Resize(self, *args):
        """
        Resize(NCollection_Array1_AppParCurves_ConstraintCouple self, Standard_Integer const theLower, Standard_Integer const theUpper, Standard_Boolean const theToCopyData)

        Resizes the array to specified bounds.
        No re-allocation will be done if length of array does not change,
        but existing values will not be discarded if theToCopyData set to FALSE.
        @param theLower new lower bound of array
        @param theUpper new upper bound of array
        @param theToCopyData flag to copy existing data into new array

        :type theLower: int
        :type theUpper: int
        :type theToCopyData: bool

        """
        return _AppParCurves.NCollection_Array1_AppParCurves_ConstraintCouple_Resize(self, *args)

    __swig_destroy__ = _AppParCurves.delete_NCollection_Array1_AppParCurves_ConstraintCouple
NCollection_Array1_AppParCurves_ConstraintCouple_swigregister = _AppParCurves.NCollection_Array1_AppParCurves_ConstraintCouple_swigregister
NCollection_Array1_AppParCurves_ConstraintCouple_swigregister(NCollection_Array1_AppParCurves_ConstraintCouple)


try:
	AppParCurves_Array1OfConstraintCouple = NCollection_Array1_AppParCurves_ConstraintCouple
except NameError:
	pass # does not exist, probably ignored

class NCollection_Sequence_AppParCurves_MultiCurve(NCollection.NCollection_BaseSequence):
    """
    Purpose:     Definition of a sequence of elements indexed by
    an Integer in range of 1..n
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Sequence_AppParCurves_MultiCurve self) -> NCollection_Sequence< AppParCurves_MultiCurve >::iterator

        Returns an iterator pointing to the first element in the sequence.

        :rtype: iterator

        """
        return _AppParCurves.NCollection_Sequence_AppParCurves_MultiCurve_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Sequence_AppParCurves_MultiCurve self) -> NCollection_Sequence< AppParCurves_MultiCurve >::iterator

        Returns an iterator referring to the past-the-end element in the sequence.

        :rtype: iterator

        """
        return _AppParCurves.NCollection_Sequence_AppParCurves_MultiCurve_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Sequence_AppParCurves_MultiCurve self) -> NCollection_Sequence< AppParCurves_MultiCurve >::const_iterator

        Returns a const iterator pointing to the first element in the sequence.

        :rtype: const_iterator

        """
        return _AppParCurves.NCollection_Sequence_AppParCurves_MultiCurve_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Sequence_AppParCurves_MultiCurve self) -> NCollection_Sequence< AppParCurves_MultiCurve >::const_iterator

        Returns a const iterator referring to the past-the-end element in the sequence.

        :rtype: const_iterator

        """
        return _AppParCurves.NCollection_Sequence_AppParCurves_MultiCurve_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     Definition of a sequence of elements indexed by
        an Integer in range of 1..n
        """
        this = _AppParCurves.new_NCollection_Sequence_AppParCurves_MultiCurve(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Size(self, *args):
        """
        Size(NCollection_Sequence_AppParCurves_MultiCurve self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AppParCurves.NCollection_Sequence_AppParCurves_MultiCurve_Size(self, *args)


    def Length(self, *args):
        """
        Length(NCollection_Sequence_AppParCurves_MultiCurve self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AppParCurves.NCollection_Sequence_AppParCurves_MultiCurve_Length(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Sequence_AppParCurves_MultiCurve self) -> Standard_Integer

        Method for consistency with other collections.
        @return Lower bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AppParCurves.NCollection_Sequence_AppParCurves_MultiCurve_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Sequence_AppParCurves_MultiCurve self) -> Standard_Integer

        Method for consistency with other collections.
        @return Upper bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AppParCurves.NCollection_Sequence_AppParCurves_MultiCurve_Upper(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Sequence_AppParCurves_MultiCurve self) -> Standard_Boolean

        Empty query

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AppParCurves.NCollection_Sequence_AppParCurves_MultiCurve_IsEmpty(self, *args)


    def Reverse(self, *args):
        """
        Reverse(NCollection_Sequence_AppParCurves_MultiCurve self)

        Reverse sequence


        """
        return _AppParCurves.NCollection_Sequence_AppParCurves_MultiCurve_Reverse(self, *args)


    def Exchange(self, *args):
        """
        Exchange(NCollection_Sequence_AppParCurves_MultiCurve self, Standard_Integer const I, Standard_Integer const J)

        Exchange two members

        :type I: int
        :type J: int

        """
        return _AppParCurves.NCollection_Sequence_AppParCurves_MultiCurve_Exchange(self, *args)


    def delNode(*args):
        """
        delNode(NCollection_SeqNode theNode, Handle_NCollection_BaseAllocator theAl)

        Static deleter to be passed to BaseSequence

        :type theNode: OCC.wrapper.NCollection.NCollection_SeqNode
        :type theAl: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _AppParCurves.NCollection_Sequence_AppParCurves_MultiCurve_delNode(*args)

    delNode = staticmethod(delNode)

    def Clear(self, *args):
        """
        Clear(NCollection_Sequence_AppParCurves_MultiCurve self, Handle_NCollection_BaseAllocator theAllocator=0)

        Clear the items out, take a new allocator if non null

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _AppParCurves.NCollection_Sequence_AppParCurves_MultiCurve_Clear(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Sequence_AppParCurves_MultiCurve self, NCollection_Sequence_AppParCurves_MultiCurve theOther) -> NCollection_Sequence_AppParCurves_MultiCurve

        Replace this sequence by the items of theOther.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_Sequence
        :rtype: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _AppParCurves.NCollection_Sequence_AppParCurves_MultiCurve_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Sequence_AppParCurves_MultiCurve self, NCollection_Sequence_AppParCurves_MultiCurve theOther) -> NCollection_Sequence_AppParCurves_MultiCurve

        Replacement operator

        :type theOther: OCC.wrapper.NCollection.NCollection_Sequence
        :rtype: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _AppParCurves.NCollection_Sequence_AppParCurves_MultiCurve_assign(self, *args)


    def Remove(self, *args):
        """
        Remove(NCollection_Sequence_AppParCurves_MultiCurve self, NCollection_Sequence< AppParCurves_MultiCurve >::Iterator & thePosition)
        Remove(NCollection_Sequence_AppParCurves_MultiCurve self, Standard_Integer const theIndex)
        Remove(NCollection_Sequence_AppParCurves_MultiCurve self, Standard_Integer const theFromIndex, Standard_Integer const theToIndex)

        Remove range of items

        :type theFromIndex: int
        :type theToIndex: int

        """
        return _AppParCurves.NCollection_Sequence_AppParCurves_MultiCurve_Remove(self, *args)


    def Append(self, *args):
        """
        Append(NCollection_Sequence_AppParCurves_MultiCurve self, AppParCurves_MultiCurve theItem)
        Append(NCollection_Sequence_AppParCurves_MultiCurve self, NCollection_Sequence_AppParCurves_MultiCurve theSeq)

        Append another sequence (making it empty)

        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _AppParCurves.NCollection_Sequence_AppParCurves_MultiCurve_Append(self, *args)


    def Prepend(self, *args):
        """
        Prepend(NCollection_Sequence_AppParCurves_MultiCurve self, AppParCurves_MultiCurve theItem)
        Prepend(NCollection_Sequence_AppParCurves_MultiCurve self, NCollection_Sequence_AppParCurves_MultiCurve theSeq)

        Prepend another sequence (making it empty)

        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _AppParCurves.NCollection_Sequence_AppParCurves_MultiCurve_Prepend(self, *args)


    def InsertBefore(self, *args):
        """
        InsertBefore(NCollection_Sequence_AppParCurves_MultiCurve self, Standard_Integer const theIndex, AppParCurves_MultiCurve theItem)
        InsertBefore(NCollection_Sequence_AppParCurves_MultiCurve self, Standard_Integer const theIndex, NCollection_Sequence_AppParCurves_MultiCurve theSeq)

        InsertBefore theIndex another sequence

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _AppParCurves.NCollection_Sequence_AppParCurves_MultiCurve_InsertBefore(self, *args)


    def InsertAfter(self, *args):
        """
        InsertAfter(NCollection_Sequence_AppParCurves_MultiCurve self, NCollection_Sequence< AppParCurves_MultiCurve >::Iterator & thePosition, AppParCurves_MultiCurve theItem)
        InsertAfter(NCollection_Sequence_AppParCurves_MultiCurve self, Standard_Integer const theIndex, NCollection_Sequence_AppParCurves_MultiCurve theSeq)
        InsertAfter(NCollection_Sequence_AppParCurves_MultiCurve self, Standard_Integer const theIndex, AppParCurves_MultiCurve theItem)

        InsertAfter theIndex another sequence

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _AppParCurves.NCollection_Sequence_AppParCurves_MultiCurve_InsertAfter(self, *args)


    def Split(self, *args):
        """
        Split(NCollection_Sequence_AppParCurves_MultiCurve self, Standard_Integer const theIndex, NCollection_Sequence_AppParCurves_MultiCurve theSeq)

        Split in two sequences

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _AppParCurves.NCollection_Sequence_AppParCurves_MultiCurve_Split(self, *args)


    def First(self, *args):
        """
        First item access

        :rtype: const TheItemType &

        """
        res = _AppParCurves.NCollection_Sequence_AppParCurves_MultiCurve_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Sequence_AppParCurves_MultiCurve self) -> AppParCurves_MultiCurve

        First item access

        :rtype: TheItemType &

        """
        return _AppParCurves.NCollection_Sequence_AppParCurves_MultiCurve_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        Last item access

        :rtype: const TheItemType &

        """
        res = _AppParCurves.NCollection_Sequence_AppParCurves_MultiCurve_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Sequence_AppParCurves_MultiCurve self) -> AppParCurves_MultiCurve

        Last item access

        :rtype: TheItemType &

        """
        return _AppParCurves.NCollection_Sequence_AppParCurves_MultiCurve_ChangeLast(self, *args)


    def Value(self, *args):
        """
        Constant item access by theIndex

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _AppParCurves.NCollection_Sequence_AppParCurves_MultiCurve_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Sequence_AppParCurves_MultiCurve self, Standard_Integer const theIndex) -> AppParCurves_MultiCurve

        Variable item access by theIndex

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _AppParCurves.NCollection_Sequence_AppParCurves_MultiCurve_ChangeValue(self, *args)


    def __call__(self, *args):
        """
        Constant operator()

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _AppParCurves.NCollection_Sequence_AppParCurves_MultiCurve___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetValue(self, *args):
        """
        SetValue(NCollection_Sequence_AppParCurves_MultiCurve self, Standard_Integer const theIndex, AppParCurves_MultiCurve theItem)

        Set item value by theIndex

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _AppParCurves.NCollection_Sequence_AppParCurves_MultiCurve_SetValue(self, *args)


    def __iter__(self):
        return _AppParCurves.NCollection_Sequence_AppParCurves_MultiCurve___iter__(self)
    __swig_destroy__ = _AppParCurves.delete_NCollection_Sequence_AppParCurves_MultiCurve
NCollection_Sequence_AppParCurves_MultiCurve_swigregister = _AppParCurves.NCollection_Sequence_AppParCurves_MultiCurve_swigregister
NCollection_Sequence_AppParCurves_MultiCurve_swigregister(NCollection_Sequence_AppParCurves_MultiCurve)

def NCollection_Sequence_AppParCurves_MultiCurve_delNode(*args):
    """
    NCollection_Sequence_AppParCurves_MultiCurve_delNode(NCollection_SeqNode theNode, Handle_NCollection_BaseAllocator theAl)

    Static deleter to be passed to BaseSequence

    :type theNode: OCC.wrapper.NCollection.NCollection_SeqNode
    :type theAl: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

    """
    return _AppParCurves.NCollection_Sequence_AppParCurves_MultiCurve_delNode(*args)

class NCollection_Sequence_AppParCurves_MultiCurve_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _AppParCurves.new_NCollection_Sequence_AppParCurves_MultiCurve_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _AppParCurves.delete_NCollection_Sequence_AppParCurves_MultiCurve_IteratorHelper

    def __next__(self):
        return _AppParCurves.NCollection_Sequence_AppParCurves_MultiCurve_IteratorHelper___next__(self)
NCollection_Sequence_AppParCurves_MultiCurve_IteratorHelper_swigregister = _AppParCurves.NCollection_Sequence_AppParCurves_MultiCurve_IteratorHelper_swigregister
NCollection_Sequence_AppParCurves_MultiCurve_IteratorHelper_swigregister(NCollection_Sequence_AppParCurves_MultiCurve_IteratorHelper)


try:
	AppParCurves_SequenceOfMultiCurve = NCollection_Sequence_AppParCurves_MultiCurve
except NameError:
	pass # does not exist, probably ignored

class Handle_AppParCurves_HArray1OfMultiPoint(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_AppParCurves_HArray1OfMultiPoint self)

        Nullify the handle


        """
        return _AppParCurves.Handle_AppParCurves_HArray1OfMultiPoint_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_AppParCurves_HArray1OfMultiPoint self) -> bool

        Check for being null

        :rtype: bool

        """
        return _AppParCurves.Handle_AppParCurves_HArray1OfMultiPoint_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_AppParCurves_HArray1OfMultiPoint self, AppParCurves_HArray1OfMultiPoint thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _AppParCurves.Handle_AppParCurves_HArray1OfMultiPoint_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_AppParCurves_HArray1OfMultiPoint self, Handle_AppParCurves_HArray1OfMultiPoint theHandle) -> Handle_AppParCurves_HArray1OfMultiPoint
        assign(Handle_AppParCurves_HArray1OfMultiPoint self, AppParCurves_HArray1OfMultiPoint thePtr) -> Handle_AppParCurves_HArray1OfMultiPoint
        assign(Handle_AppParCurves_HArray1OfMultiPoint self, Handle_AppParCurves_HArray1OfMultiPoint theHandle) -> Handle_AppParCurves_HArray1OfMultiPoint

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _AppParCurves.Handle_AppParCurves_HArray1OfMultiPoint_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_AppParCurves_HArray1OfMultiPoint self) -> AppParCurves_HArray1OfMultiPoint

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _AppParCurves.Handle_AppParCurves_HArray1OfMultiPoint_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_AppParCurves_HArray1OfMultiPoint self) -> AppParCurves_HArray1OfMultiPoint

        Member access operator (note non-const)

        :rtype: T *

        """
        return _AppParCurves.Handle_AppParCurves_HArray1OfMultiPoint___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_AppParCurves_HArray1OfMultiPoint self) -> AppParCurves_HArray1OfMultiPoint

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _AppParCurves.Handle_AppParCurves_HArray1OfMultiPoint___ref__(self, *args)


    def __hash__(self):
        return _AppParCurves.Handle_AppParCurves_HArray1OfMultiPoint___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _AppParCurves.Handle_AppParCurves_HArray1OfMultiPoint___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _AppParCurves.new_Handle_AppParCurves_HArray1OfMultiPoint(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_AppParCurves.Handle_AppParCurves_HArray1OfMultiPoint_DownCast)
    __swig_destroy__ = _AppParCurves.delete_Handle_AppParCurves_HArray1OfMultiPoint

    def Array1(self, *args):
        """
        :rtype: OCC.wrapper.AppParCurves.AppParCurves_Array1OfMultiPoint

        """
        res = _AppParCurves.Handle_AppParCurves_HArray1OfMultiPoint_Array1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeArray1(self, *args):
        """
        ChangeArray1(Handle_AppParCurves_HArray1OfMultiPoint self) -> NCollection_Array1_AppParCurves_MultiPoint

        :rtype: OCC.wrapper.AppParCurves.AppParCurves_Array1OfMultiPoint

        """
        return _AppParCurves.Handle_AppParCurves_HArray1OfMultiPoint_ChangeArray1(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_AppParCurves_HArray1OfMultiPoint self) -> char const *

        :rtype: const char *

        """
        return _AppParCurves.Handle_AppParCurves_HArray1OfMultiPoint_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _AppParCurves.Handle_AppParCurves_HArray1OfMultiPoint_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _AppParCurves.Handle_AppParCurves_HArray1OfMultiPoint_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_AppParCurves_HArray1OfMultiPoint self)

        Memory deallocator for transient classes


        """
        return _AppParCurves.Handle_AppParCurves_HArray1OfMultiPoint_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_AppParCurves_HArray1OfMultiPoint self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_AppParCurves_HArray1OfMultiPoint self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AppParCurves.Handle_AppParCurves_HArray1OfMultiPoint_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_AppParCurves_HArray1OfMultiPoint self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_AppParCurves_HArray1OfMultiPoint self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AppParCurves.Handle_AppParCurves_HArray1OfMultiPoint_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_AppParCurves_HArray1OfMultiPoint self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _AppParCurves.Handle_AppParCurves_HArray1OfMultiPoint_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_AppParCurves_HArray1OfMultiPoint self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AppParCurves.Handle_AppParCurves_HArray1OfMultiPoint_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_AppParCurves_HArray1OfMultiPoint self)

        Increments the reference counter of this object


        """
        return _AppParCurves.Handle_AppParCurves_HArray1OfMultiPoint_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_AppParCurves_HArray1OfMultiPoint self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AppParCurves.Handle_AppParCurves_HArray1OfMultiPoint_DecrementRefCounter(self, *args)

Handle_AppParCurves_HArray1OfMultiPoint_swigregister = _AppParCurves.Handle_AppParCurves_HArray1OfMultiPoint_swigregister
Handle_AppParCurves_HArray1OfMultiPoint_swigregister(Handle_AppParCurves_HArray1OfMultiPoint)

def Handle_AppParCurves_HArray1OfMultiPoint_DownCast(thing):
    return _AppParCurves.Handle_AppParCurves_HArray1OfMultiPoint_DownCast(thing)
Handle_AppParCurves_HArray1OfMultiPoint_DownCast = _AppParCurves.Handle_AppParCurves_HArray1OfMultiPoint_DownCast

class AppParCurves_HArray1OfMultiCurve(NCollection_Array1_AppParCurves_MultiCurve, Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_AppParCurves_HArray1OfMultiCurve
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_AppParCurves_HArray1OfMultiCurve(self) 
            return h


    def __init__(self, *args):
        """
        __init__(AppParCurves_HArray1OfMultiCurve self, Standard_Integer const theLower, Standard_Integer const theUpper) -> AppParCurves_HArray1OfMultiCurve
        __init__(AppParCurves_HArray1OfMultiCurve self, Standard_Integer const theLower, Standard_Integer const theUpper, AppParCurves_MultiCurve theValue) -> AppParCurves_HArray1OfMultiCurve
        __init__(AppParCurves_HArray1OfMultiCurve self, NCollection_Array1_AppParCurves_MultiCurve theOther) -> AppParCurves_HArray1OfMultiCurve

        :type theOther: OCC.wrapper.AppParCurves.AppParCurves_Array1OfMultiCurve

        """
        this = _AppParCurves.new_AppParCurves_HArray1OfMultiCurve(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Array1(self, *args):
        """
        :rtype: OCC.wrapper.AppParCurves.AppParCurves_Array1OfMultiCurve

        """
        res = _AppParCurves.AppParCurves_HArray1OfMultiCurve_Array1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeArray1(self, *args):
        """
        ChangeArray1(AppParCurves_HArray1OfMultiCurve self) -> NCollection_Array1_AppParCurves_MultiCurve

        :rtype: OCC.wrapper.AppParCurves.AppParCurves_Array1OfMultiCurve

        """
        return _AppParCurves.AppParCurves_HArray1OfMultiCurve_ChangeArray1(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _AppParCurves.AppParCurves_HArray1OfMultiCurve_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _AppParCurves.AppParCurves_HArray1OfMultiCurve_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _AppParCurves.AppParCurves_HArray1OfMultiCurve_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _AppParCurves.delete_AppParCurves_HArray1OfMultiCurve
AppParCurves_HArray1OfMultiCurve_swigregister = _AppParCurves.AppParCurves_HArray1OfMultiCurve_swigregister
AppParCurves_HArray1OfMultiCurve_swigregister(AppParCurves_HArray1OfMultiCurve)

def AppParCurves_HArray1OfMultiCurve_get_type_name(*args):
    """
    AppParCurves_HArray1OfMultiCurve_get_type_name() -> char const *

    :rtype: const char *

    """
    return _AppParCurves.AppParCurves_HArray1OfMultiCurve_get_type_name(*args)

def AppParCurves_HArray1OfMultiCurve_get_type_descriptor(*args):
    """
    AppParCurves_HArray1OfMultiCurve_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _AppParCurves.AppParCurves_HArray1OfMultiCurve_get_type_descriptor(*args)

class Handle_AppParCurves_HArray1OfMultiCurve(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_AppParCurves_HArray1OfMultiCurve self)

        Nullify the handle


        """
        return _AppParCurves.Handle_AppParCurves_HArray1OfMultiCurve_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_AppParCurves_HArray1OfMultiCurve self) -> bool

        Check for being null

        :rtype: bool

        """
        return _AppParCurves.Handle_AppParCurves_HArray1OfMultiCurve_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_AppParCurves_HArray1OfMultiCurve self, AppParCurves_HArray1OfMultiCurve thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _AppParCurves.Handle_AppParCurves_HArray1OfMultiCurve_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_AppParCurves_HArray1OfMultiCurve self, Handle_AppParCurves_HArray1OfMultiCurve theHandle) -> Handle_AppParCurves_HArray1OfMultiCurve
        assign(Handle_AppParCurves_HArray1OfMultiCurve self, AppParCurves_HArray1OfMultiCurve thePtr) -> Handle_AppParCurves_HArray1OfMultiCurve
        assign(Handle_AppParCurves_HArray1OfMultiCurve self, Handle_AppParCurves_HArray1OfMultiCurve theHandle) -> Handle_AppParCurves_HArray1OfMultiCurve

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _AppParCurves.Handle_AppParCurves_HArray1OfMultiCurve_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_AppParCurves_HArray1OfMultiCurve self) -> AppParCurves_HArray1OfMultiCurve

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _AppParCurves.Handle_AppParCurves_HArray1OfMultiCurve_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_AppParCurves_HArray1OfMultiCurve self) -> AppParCurves_HArray1OfMultiCurve

        Member access operator (note non-const)

        :rtype: T *

        """
        return _AppParCurves.Handle_AppParCurves_HArray1OfMultiCurve___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_AppParCurves_HArray1OfMultiCurve self) -> AppParCurves_HArray1OfMultiCurve

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _AppParCurves.Handle_AppParCurves_HArray1OfMultiCurve___ref__(self, *args)


    def __hash__(self):
        return _AppParCurves.Handle_AppParCurves_HArray1OfMultiCurve___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _AppParCurves.Handle_AppParCurves_HArray1OfMultiCurve___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _AppParCurves.new_Handle_AppParCurves_HArray1OfMultiCurve(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_AppParCurves.Handle_AppParCurves_HArray1OfMultiCurve_DownCast)
    __swig_destroy__ = _AppParCurves.delete_Handle_AppParCurves_HArray1OfMultiCurve

    def Array1(self, *args):
        """
        :rtype: OCC.wrapper.AppParCurves.AppParCurves_Array1OfMultiCurve

        """
        res = _AppParCurves.Handle_AppParCurves_HArray1OfMultiCurve_Array1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeArray1(self, *args):
        """
        ChangeArray1(Handle_AppParCurves_HArray1OfMultiCurve self) -> NCollection_Array1_AppParCurves_MultiCurve

        :rtype: OCC.wrapper.AppParCurves.AppParCurves_Array1OfMultiCurve

        """
        return _AppParCurves.Handle_AppParCurves_HArray1OfMultiCurve_ChangeArray1(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_AppParCurves_HArray1OfMultiCurve self) -> char const *

        :rtype: const char *

        """
        return _AppParCurves.Handle_AppParCurves_HArray1OfMultiCurve_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _AppParCurves.Handle_AppParCurves_HArray1OfMultiCurve_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _AppParCurves.Handle_AppParCurves_HArray1OfMultiCurve_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def begin(self, *args):
        """
        begin(Handle_AppParCurves_HArray1OfMultiCurve self) -> NCollection_Array1< AppParCurves_MultiCurve >::iterator

        Returns an iterator pointing to the first element in the array.

        :rtype: iterator

        """
        return _AppParCurves.Handle_AppParCurves_HArray1OfMultiCurve_begin(self, *args)


    def end(self, *args):
        """
        end(Handle_AppParCurves_HArray1OfMultiCurve self) -> NCollection_Array1< AppParCurves_MultiCurve >::iterator

        Returns an iterator referring to the past-the-end element in the array.

        :rtype: iterator

        """
        return _AppParCurves.Handle_AppParCurves_HArray1OfMultiCurve_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(Handle_AppParCurves_HArray1OfMultiCurve self) -> NCollection_Array1< AppParCurves_MultiCurve >::const_iterator

        Returns a const iterator pointing to the first element in the array.

        :rtype: const_iterator

        """
        return _AppParCurves.Handle_AppParCurves_HArray1OfMultiCurve_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(Handle_AppParCurves_HArray1OfMultiCurve self) -> NCollection_Array1< AppParCurves_MultiCurve >::const_iterator

        Returns a const iterator referring to the past-the-end element in the array.

        :rtype: const_iterator

        """
        return _AppParCurves.Handle_AppParCurves_HArray1OfMultiCurve_cend(self, *args)


    def Init(self, *args):
        """
        Init(Handle_AppParCurves_HArray1OfMultiCurve self, AppParCurves_MultiCurve theValue)

        Initialise the items with theValue

        :type theValue: const TheItemType &

        """
        return _AppParCurves.Handle_AppParCurves_HArray1OfMultiCurve_Init(self, *args)


    def Size(self, *args):
        """
        Size(Handle_AppParCurves_HArray1OfMultiCurve self) -> Standard_Integer

        Size query

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AppParCurves.Handle_AppParCurves_HArray1OfMultiCurve_Size(self, *args)


    def Length(self, *args):
        """
        Length(Handle_AppParCurves_HArray1OfMultiCurve self) -> Standard_Integer

        Length query (the same)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AppParCurves.Handle_AppParCurves_HArray1OfMultiCurve_Length(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(Handle_AppParCurves_HArray1OfMultiCurve self) -> Standard_Boolean

        Return TRUE if array has zero length.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AppParCurves.Handle_AppParCurves_HArray1OfMultiCurve_IsEmpty(self, *args)


    def Lower(self, *args):
        """
        Lower(Handle_AppParCurves_HArray1OfMultiCurve self) -> Standard_Integer

        Lower bound

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AppParCurves.Handle_AppParCurves_HArray1OfMultiCurve_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(Handle_AppParCurves_HArray1OfMultiCurve self) -> Standard_Integer

        Upper bound

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AppParCurves.Handle_AppParCurves_HArray1OfMultiCurve_Upper(self, *args)


    def IsDeletable(self, *args):
        """
        IsDeletable(Handle_AppParCurves_HArray1OfMultiCurve self) -> Standard_Boolean

        myDeletable flag

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AppParCurves.Handle_AppParCurves_HArray1OfMultiCurve_IsDeletable(self, *args)


    def IsAllocated(self, *args):
        """
        IsAllocated(Handle_AppParCurves_HArray1OfMultiCurve self) -> Standard_Boolean

        IsAllocated flag - for naming compatibility

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AppParCurves.Handle_AppParCurves_HArray1OfMultiCurve_IsAllocated(self, *args)


    def Assign(self, *args):
        """
        Assign(Handle_AppParCurves_HArray1OfMultiCurve self, NCollection_Array1_AppParCurves_MultiCurve theOther) -> NCollection_Array1_AppParCurves_MultiCurve

        Copies data of theOther array to this.
        This array should be pre-allocated and have the same length as theOther;
        otherwise exception Standard_DimensionMismatch is thrown.

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _AppParCurves.Handle_AppParCurves_HArray1OfMultiCurve_Assign(self, *args)


    def Move(self, *args):
        """
        Move(Handle_AppParCurves_HArray1OfMultiCurve self, NCollection_Array1_AppParCurves_MultiCurve theOther) -> NCollection_Array1_AppParCurves_MultiCurve

        Move assignment.
        This array will borrow all the data from theOther.
        The moved object will keep pointer to the memory buffer and
        range, but it will not free the buffer on destruction.

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _AppParCurves.Handle_AppParCurves_HArray1OfMultiCurve_Move(self, *args)


    def First(self, *args):
        """
        @return first element

        :rtype: const TheItemType &

        """
        res = _AppParCurves.Handle_AppParCurves_HArray1OfMultiCurve_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(Handle_AppParCurves_HArray1OfMultiCurve self) -> AppParCurves_MultiCurve

        @return first element

        :rtype: TheItemType &

        """
        return _AppParCurves.Handle_AppParCurves_HArray1OfMultiCurve_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        @return last element

        :rtype: const TheItemType &

        """
        res = _AppParCurves.Handle_AppParCurves_HArray1OfMultiCurve_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(Handle_AppParCurves_HArray1OfMultiCurve self) -> AppParCurves_MultiCurve

        @return last element

        :rtype: TheItemType &

        """
        return _AppParCurves.Handle_AppParCurves_HArray1OfMultiCurve_ChangeLast(self, *args)


    def Value(self, *args):
        """
        Constant value access

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _AppParCurves.Handle_AppParCurves_HArray1OfMultiCurve_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __call__(self, *args):
        """
        operator() - alias to Value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _AppParCurves.Handle_AppParCurves_HArray1OfMultiCurve___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __getitem__(self, *args):
        """
        operator[] - alias to Value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _AppParCurves.Handle_AppParCurves_HArray1OfMultiCurve_at(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(Handle_AppParCurves_HArray1OfMultiCurve self, Standard_Integer const theIndex) -> AppParCurves_MultiCurve

        Variable value access

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _AppParCurves.Handle_AppParCurves_HArray1OfMultiCurve_ChangeValue(self, *args)


    def SetValue(self, *args):
        """
        SetValue(Handle_AppParCurves_HArray1OfMultiCurve self, Standard_Integer const theIndex, AppParCurves_MultiCurve theItem)

        Set value 

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _AppParCurves.Handle_AppParCurves_HArray1OfMultiCurve_SetValue(self, *args)


    def Resize(self, *args):
        """
        Resize(Handle_AppParCurves_HArray1OfMultiCurve self, Standard_Integer const theLower, Standard_Integer const theUpper, Standard_Boolean const theToCopyData)

        Resizes the array to specified bounds.
        No re-allocation will be done if length of array does not change,
        but existing values will not be discarded if theToCopyData set to FALSE.
        @param theLower new lower bound of array
        @param theUpper new upper bound of array
        @param theToCopyData flag to copy existing data into new array

        :type theLower: int
        :type theUpper: int
        :type theToCopyData: bool

        """
        return _AppParCurves.Handle_AppParCurves_HArray1OfMultiCurve_Resize(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_AppParCurves_HArray1OfMultiCurve self)

        Memory deallocator for transient classes


        """
        return _AppParCurves.Handle_AppParCurves_HArray1OfMultiCurve_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_AppParCurves_HArray1OfMultiCurve self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_AppParCurves_HArray1OfMultiCurve self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AppParCurves.Handle_AppParCurves_HArray1OfMultiCurve_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_AppParCurves_HArray1OfMultiCurve self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_AppParCurves_HArray1OfMultiCurve self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AppParCurves.Handle_AppParCurves_HArray1OfMultiCurve_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_AppParCurves_HArray1OfMultiCurve self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _AppParCurves.Handle_AppParCurves_HArray1OfMultiCurve_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_AppParCurves_HArray1OfMultiCurve self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AppParCurves.Handle_AppParCurves_HArray1OfMultiCurve_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_AppParCurves_HArray1OfMultiCurve self)

        Increments the reference counter of this object


        """
        return _AppParCurves.Handle_AppParCurves_HArray1OfMultiCurve_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_AppParCurves_HArray1OfMultiCurve self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AppParCurves.Handle_AppParCurves_HArray1OfMultiCurve_DecrementRefCounter(self, *args)

Handle_AppParCurves_HArray1OfMultiCurve_swigregister = _AppParCurves.Handle_AppParCurves_HArray1OfMultiCurve_swigregister
Handle_AppParCurves_HArray1OfMultiCurve_swigregister(Handle_AppParCurves_HArray1OfMultiCurve)

def Handle_AppParCurves_HArray1OfMultiCurve_DownCast(thing):
    return _AppParCurves.Handle_AppParCurves_HArray1OfMultiCurve_DownCast(thing)
Handle_AppParCurves_HArray1OfMultiCurve_DownCast = _AppParCurves.Handle_AppParCurves_HArray1OfMultiCurve_DownCast

class NCollection_Array1_AppParCurves_MultiPoint(object):
    """
    Purpose:     The class Array1 represents unidimensional arrays 
    of fixed size known at run time. 
    The range of the index is user defined.
    An array1 can be constructed with a "C array".
    This functionality is useful to call methods expecting
    an Array1. It allows to carry the bounds inside the arrays.

    Examples:    Item tab[100]; //  An example with a C array
    Array1OfItem ttab (tab[0],1,100);

    Array1OfItem tttab (ttab(10),10,20); // a slice of ttab

    If you want to reindex an array from 1 to Length do :

    Array1 tab1(tab(tab.Lower()),1,tab.Length());

    Warning:     Programs client of such a class must be independant
    of the range of the first element. Then, a C++ for
    loop must be written like this

    for (i = A.Lower(); i <= A.Upper(); i++)

    Changes:     In  comparison  to  TCollection  the  flag  isAllocated  was
    renamed into myDeletable (alike in  the Array2).  For naming
    compatibility the method IsAllocated remained in class along
    with IsDeletable.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Array1_AppParCurves_MultiPoint self) -> NCollection_Array1< AppParCurves_MultiPoint >::iterator

        Returns an iterator pointing to the first element in the array.

        :rtype: iterator

        """
        return _AppParCurves.NCollection_Array1_AppParCurves_MultiPoint_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Array1_AppParCurves_MultiPoint self) -> NCollection_Array1< AppParCurves_MultiPoint >::iterator

        Returns an iterator referring to the past-the-end element in the array.

        :rtype: iterator

        """
        return _AppParCurves.NCollection_Array1_AppParCurves_MultiPoint_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Array1_AppParCurves_MultiPoint self) -> NCollection_Array1< AppParCurves_MultiPoint >::const_iterator

        Returns a const iterator pointing to the first element in the array.

        :rtype: const_iterator

        """
        return _AppParCurves.NCollection_Array1_AppParCurves_MultiPoint_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Array1_AppParCurves_MultiPoint self) -> NCollection_Array1< AppParCurves_MultiPoint >::const_iterator

        Returns a const iterator referring to the past-the-end element in the array.

        :rtype: const_iterator

        """
        return _AppParCurves.NCollection_Array1_AppParCurves_MultiPoint_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     The class Array1 represents unidimensional arrays 
        of fixed size known at run time. 
        The range of the index is user defined.
        An array1 can be constructed with a "C array".
        This functionality is useful to call methods expecting
        an Array1. It allows to carry the bounds inside the arrays.

        Examples:    Item tab[100]; //  An example with a C array
        Array1OfItem ttab (tab[0],1,100);

        Array1OfItem tttab (ttab(10),10,20); // a slice of ttab

        If you want to reindex an array from 1 to Length do :

        Array1 tab1(tab(tab.Lower()),1,tab.Length());

        Warning:     Programs client of such a class must be independant
        of the range of the first element. Then, a C++ for
        loop must be written like this

        for (i = A.Lower(); i <= A.Upper(); i++)

        Changes:     In  comparison  to  TCollection  the  flag  isAllocated  was
        renamed into myDeletable (alike in  the Array2).  For naming
        compatibility the method IsAllocated remained in class along
        with IsDeletable.
        """
        this = _AppParCurves.new_NCollection_Array1_AppParCurves_MultiPoint(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(NCollection_Array1_AppParCurves_MultiPoint self, AppParCurves_MultiPoint theValue)

        Initialise the items with theValue

        :type theValue: const TheItemType &

        """
        return _AppParCurves.NCollection_Array1_AppParCurves_MultiPoint_Init(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_Array1_AppParCurves_MultiPoint self) -> Standard_Integer

        Size query

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AppParCurves.NCollection_Array1_AppParCurves_MultiPoint_Size(self, *args)


    def Length(self, *args):
        """
        Length(NCollection_Array1_AppParCurves_MultiPoint self) -> Standard_Integer

        Length query (the same)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AppParCurves.NCollection_Array1_AppParCurves_MultiPoint_Length(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Array1_AppParCurves_MultiPoint self) -> Standard_Boolean

        Return TRUE if array has zero length.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AppParCurves.NCollection_Array1_AppParCurves_MultiPoint_IsEmpty(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Array1_AppParCurves_MultiPoint self) -> Standard_Integer

        Lower bound

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AppParCurves.NCollection_Array1_AppParCurves_MultiPoint_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Array1_AppParCurves_MultiPoint self) -> Standard_Integer

        Upper bound

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AppParCurves.NCollection_Array1_AppParCurves_MultiPoint_Upper(self, *args)


    def IsDeletable(self, *args):
        """
        IsDeletable(NCollection_Array1_AppParCurves_MultiPoint self) -> Standard_Boolean

        myDeletable flag

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AppParCurves.NCollection_Array1_AppParCurves_MultiPoint_IsDeletable(self, *args)


    def IsAllocated(self, *args):
        """
        IsAllocated(NCollection_Array1_AppParCurves_MultiPoint self) -> Standard_Boolean

        IsAllocated flag - for naming compatibility

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AppParCurves.NCollection_Array1_AppParCurves_MultiPoint_IsAllocated(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Array1_AppParCurves_MultiPoint self, NCollection_Array1_AppParCurves_MultiPoint theOther) -> NCollection_Array1_AppParCurves_MultiPoint

        Copies data of theOther array to this.
        This array should be pre-allocated and have the same length as theOther;
        otherwise exception Standard_DimensionMismatch is thrown.

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _AppParCurves.NCollection_Array1_AppParCurves_MultiPoint_Assign(self, *args)


    def Move(self, *args):
        """
        Move(NCollection_Array1_AppParCurves_MultiPoint self, NCollection_Array1_AppParCurves_MultiPoint theOther) -> NCollection_Array1_AppParCurves_MultiPoint

        Move assignment.
        This array will borrow all the data from theOther.
        The moved object will keep pointer to the memory buffer and
        range, but it will not free the buffer on destruction.

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _AppParCurves.NCollection_Array1_AppParCurves_MultiPoint_Move(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Array1_AppParCurves_MultiPoint self, NCollection_Array1_AppParCurves_MultiPoint theOther) -> NCollection_Array1_AppParCurves_MultiPoint
        assign(NCollection_Array1_AppParCurves_MultiPoint self, NCollection_Array1_AppParCurves_MultiPoint theOther) -> NCollection_Array1_AppParCurves_MultiPoint

        Move assignment operator; @sa Move()

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1<TheItemType> &&
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _AppParCurves.NCollection_Array1_AppParCurves_MultiPoint_assign(self, *args)


    def First(self, *args):
        """
        @return first element

        :rtype: const TheItemType &

        """
        res = _AppParCurves.NCollection_Array1_AppParCurves_MultiPoint_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Array1_AppParCurves_MultiPoint self) -> AppParCurves_MultiPoint

        @return first element

        :rtype: TheItemType &

        """
        return _AppParCurves.NCollection_Array1_AppParCurves_MultiPoint_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        @return last element

        :rtype: const TheItemType &

        """
        res = _AppParCurves.NCollection_Array1_AppParCurves_MultiPoint_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Array1_AppParCurves_MultiPoint self) -> AppParCurves_MultiPoint

        @return last element

        :rtype: TheItemType &

        """
        return _AppParCurves.NCollection_Array1_AppParCurves_MultiPoint_ChangeLast(self, *args)


    def Value(self, *args):
        """
        Constant value access

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _AppParCurves.NCollection_Array1_AppParCurves_MultiPoint_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Array1_AppParCurves_MultiPoint self, Standard_Integer const theIndex) -> AppParCurves_MultiPoint

        Variable value access

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _AppParCurves.NCollection_Array1_AppParCurves_MultiPoint_ChangeValue(self, *args)


    def __call__(self, *args):
        """
        operator() - alias to Value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _AppParCurves.NCollection_Array1_AppParCurves_MultiPoint___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __getitem__(self, *args):
        """
        operator[] - alias to Value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _AppParCurves.NCollection_Array1_AppParCurves_MultiPoint_at(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetValue(self, *args):
        """
        SetValue(NCollection_Array1_AppParCurves_MultiPoint self, Standard_Integer const theIndex, AppParCurves_MultiPoint theItem)

        Set value 

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _AppParCurves.NCollection_Array1_AppParCurves_MultiPoint_SetValue(self, *args)


    def Resize(self, *args):
        """
        Resize(NCollection_Array1_AppParCurves_MultiPoint self, Standard_Integer const theLower, Standard_Integer const theUpper, Standard_Boolean const theToCopyData)

        Resizes the array to specified bounds.
        No re-allocation will be done if length of array does not change,
        but existing values will not be discarded if theToCopyData set to FALSE.
        @param theLower new lower bound of array
        @param theUpper new upper bound of array
        @param theToCopyData flag to copy existing data into new array

        :type theLower: int
        :type theUpper: int
        :type theToCopyData: bool

        """
        return _AppParCurves.NCollection_Array1_AppParCurves_MultiPoint_Resize(self, *args)

    __swig_destroy__ = _AppParCurves.delete_NCollection_Array1_AppParCurves_MultiPoint
NCollection_Array1_AppParCurves_MultiPoint_swigregister = _AppParCurves.NCollection_Array1_AppParCurves_MultiPoint_swigregister
NCollection_Array1_AppParCurves_MultiPoint_swigregister(NCollection_Array1_AppParCurves_MultiPoint)


try:
	AppParCurves_Array1OfMultiPoint = NCollection_Array1_AppParCurves_MultiPoint
except NameError:
	pass # does not exist, probably ignored




# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_SelectMgr')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_SelectMgr')
    _SelectMgr = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_SelectMgr', [dirname(__file__)])
        except ImportError:
            import _SelectMgr
            return _SelectMgr
        try:
            _mod = imp.load_module('_SelectMgr', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _SelectMgr = swig_import_helper()
    del swig_import_helper
else:
    import _SelectMgr
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


class SwigPyIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _SelectMgr.delete_SwigPyIterator

    def value(self):
        return _SelectMgr.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _SelectMgr.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _SelectMgr.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _SelectMgr.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _SelectMgr.SwigPyIterator_equal(self, x)

    def copy(self):
        return _SelectMgr.SwigPyIterator_copy(self)

    def next(self):
        return _SelectMgr.SwigPyIterator_next(self)

    def __next__(self):
        return _SelectMgr.SwigPyIterator___next__(self)

    def previous(self):
        return _SelectMgr.SwigPyIterator_previous(self)

    def advance(self, n):
        return _SelectMgr.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _SelectMgr.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _SelectMgr.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _SelectMgr.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _SelectMgr.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _SelectMgr.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _SelectMgr.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self
SwigPyIterator_swigregister = _SelectMgr.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

class NCollection_CellFilter_InspectorXYZ(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _SelectMgr.NCollection_CellFilter_InspectorXYZ_Dimension
    Coord = staticmethod(_SelectMgr.NCollection_CellFilter_InspectorXYZ_Coord)

    def Shift(self, thePnt, theTol):
        return _SelectMgr.NCollection_CellFilter_InspectorXYZ_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _SelectMgr.new_NCollection_CellFilter_InspectorXYZ()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SelectMgr.delete_NCollection_CellFilter_InspectorXYZ
NCollection_CellFilter_InspectorXYZ_swigregister = _SelectMgr.NCollection_CellFilter_InspectorXYZ_swigregister
NCollection_CellFilter_InspectorXYZ_swigregister(NCollection_CellFilter_InspectorXYZ)

def NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt):
    return _SelectMgr.NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt)
NCollection_CellFilter_InspectorXYZ_Coord = _SelectMgr.NCollection_CellFilter_InspectorXYZ_Coord

class NCollection_CellFilter_InspectorXY(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _SelectMgr.NCollection_CellFilter_InspectorXY_Dimension
    Coord = staticmethod(_SelectMgr.NCollection_CellFilter_InspectorXY_Coord)

    def Shift(self, thePnt, theTol):
        return _SelectMgr.NCollection_CellFilter_InspectorXY_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _SelectMgr.new_NCollection_CellFilter_InspectorXY()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SelectMgr.delete_NCollection_CellFilter_InspectorXY
NCollection_CellFilter_InspectorXY_swigregister = _SelectMgr.NCollection_CellFilter_InspectorXY_swigregister
NCollection_CellFilter_InspectorXY_swigregister(NCollection_CellFilter_InspectorXY)

def NCollection_CellFilter_InspectorXY_Coord(i, thePnt):
    return _SelectMgr.NCollection_CellFilter_InspectorXY_Coord(i, thePnt)
NCollection_CellFilter_InspectorXY_Coord = _SelectMgr.NCollection_CellFilter_InspectorXY_Coord


def ptr_to_number(item):
    return _SelectMgr.ptr_to_number(item)
ptr_to_number = _SelectMgr.ptr_to_number

def HashCode(*args):
    return _SelectMgr.HashCode(*args)
HashCode = _SelectMgr.HashCode

def ptr_equal(a, b):
    return _SelectMgr.ptr_equal(a, b)
ptr_equal = _SelectMgr.ptr_equal
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import SelectBasics
else:
    import SelectBasics
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import NCollection
else:
    import NCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Standard
else:
    import Standard
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import gp
else:
    import gp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColStd
else:
    import TColStd
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TCollection
else:
    import TCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColgp
else:
    import TColgp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopLoc
else:
    import TopLoc
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Select3D
else:
    import Select3D
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import BVH
else:
    import BVH
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Poly
else:
    import Poly
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TShort
else:
    import TShort
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Graphic3d
else:
    import Graphic3d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Image
else:
    import Image
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Quantity
else:
    import Quantity
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Geom
else:
    import Geom
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import GeomAbs
else:
    import GeomAbs
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Aspect
else:
    import Aspect
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Font
else:
    import Font
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopoDS
else:
    import TopoDS
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopAbs
else:
    import TopAbs
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Message
else:
    import Message
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Geom2d
else:
    import Geom2d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import OSD
else:
    import OSD
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Bnd
else:
    import Bnd
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import PrsMgr
else:
    import PrsMgr
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import V3d
else:
    import V3d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Prs3d
else:
    import Prs3d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import HLRAlgo
else:
    import HLRAlgo
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopTools
else:
    import TopTools
del _swig_python_version_info
SelectMgr_SOS_Activated = _SelectMgr.SelectMgr_SOS_Activated
SelectMgr_SOS_Deactivated = _SelectMgr.SelectMgr_SOS_Deactivated
SelectMgr_SOS_Sleeping = _SelectMgr.SelectMgr_SOS_Sleeping
SelectMgr_SOS_Any = _SelectMgr.SelectMgr_SOS_Any
SelectMgr_SOS_Unknown = _SelectMgr.SelectMgr_SOS_Unknown
SelectMgr_TBU_Add = _SelectMgr.SelectMgr_TBU_Add
SelectMgr_TBU_Remove = _SelectMgr.SelectMgr_TBU_Remove
SelectMgr_TBU_Renew = _SelectMgr.SelectMgr_TBU_Renew
SelectMgr_TBU_Invalidate = _SelectMgr.SelectMgr_TBU_Invalidate
SelectMgr_TBU_None = _SelectMgr.SelectMgr_TBU_None
SelectMgr_TOU_Full = _SelectMgr.SelectMgr_TOU_Full
SelectMgr_TOU_Partial = _SelectMgr.SelectMgr_TOU_Partial
SelectMgr_TOU_None = _SelectMgr.SelectMgr_TOU_None
SelectMgr_PickingStrategy_FirstAcceptable = _SelectMgr.SelectMgr_PickingStrategy_FirstAcceptable
SelectMgr_PickingStrategy_OnlyTopmost = _SelectMgr.SelectMgr_PickingStrategy_OnlyTopmost
class SelectMgr_Filter(Standard.Standard_Transient):
    """
    The root class to define filter objects for selection.
    Advance handling of objects requires the services of
    filters. These only allow dynamic detection and
    selection of objects which correspond to the criteria defined in each.
    Eight standard filters inheriting SelectMgr_Filter are
    defined in Open CASCADE.
    You can create your own filters by defining new filter
    classes inheriting this framework. You use these
    filters by loading them into an AIS interactive context.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_SelectMgr_Filter
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_SelectMgr_Filter(self) 
            return h


    def IsOk(self, *args):
        """
        IsOk(SelectMgr_Filter self, Handle_SelectMgr_EntityOwner anObj) -> Standard_Boolean

        Indicates that the selected Interactive Object
        passes the filter. The owner, anObj, can be either
        direct or user. A direct owner is the corresponding
        construction element, whereas a user is the
        compound shape of which the entity forms a part.
        When an object is detected by the mouse - in AIS,
        this is done through a context selector - its owner
        is passed to the filter as an argument.
        If the object returns Standard_True, it is kept; if
        not, it is rejected.
        If you are creating a filter class inheriting this
        framework, and the daughter class is to be used in
        an AIS local context, you will need to implement the
        virtual function ActsOn.

        :type anObj: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _SelectMgr.SelectMgr_Filter_IsOk(self, *args)


    def ActsOn(self, *args):
        """
        ActsOn(SelectMgr_Filter self, TopAbs_ShapeEnum const aStandardMode) -> Standard_Boolean

        Returns true in an AIS local context, if this filter
        operates on a type of subshape defined in a filter
        class inheriting this framework.
        This function completes IsOk in an AIS local context.

        :type aStandardMode: OCC.wrapper.TopAbs.TopAbs_ShapeEnum
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _SelectMgr.SelectMgr_Filter_ActsOn(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _SelectMgr.SelectMgr_Filter_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _SelectMgr.SelectMgr_Filter_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _SelectMgr.SelectMgr_Filter_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _SelectMgr.delete_SelectMgr_Filter
SelectMgr_Filter_swigregister = _SelectMgr.SelectMgr_Filter_swigregister
SelectMgr_Filter_swigregister(SelectMgr_Filter)

def SelectMgr_Filter_get_type_name(*args):
    """
    SelectMgr_Filter_get_type_name() -> char const *

    :rtype: const char *

    """
    return _SelectMgr.SelectMgr_Filter_get_type_name(*args)

def SelectMgr_Filter_get_type_descriptor(*args):
    """
    SelectMgr_Filter_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _SelectMgr.SelectMgr_Filter_get_type_descriptor(*args)

class SelectMgr_CompositionFilter(SelectMgr_Filter):
    """
    A framework to define a compound filter composed of
    two or more simple filters.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_SelectMgr_CompositionFilter
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_SelectMgr_CompositionFilter(self) 
            return h


    def Add(self, *args):
        """
        Add(SelectMgr_CompositionFilter self, Handle_SelectMgr_Filter afilter)

        Adds the filter afilter to a filter object created by a
        filter class inheriting this framework.

        :type afilter: OCC.wrapper.SelectMgr.Handle_SelectMgr_Filter

        """
        return _SelectMgr.SelectMgr_CompositionFilter_Add(self, *args)


    def Remove(self, *args):
        """
        Remove(SelectMgr_CompositionFilter self, Handle_SelectMgr_Filter aFilter)

        Removes the filter aFilter from this framework.

        :type aFilter: OCC.wrapper.SelectMgr.Handle_SelectMgr_Filter

        """
        return _SelectMgr.SelectMgr_CompositionFilter_Remove(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(SelectMgr_CompositionFilter self) -> Standard_Boolean

        Returns true if this framework is empty.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _SelectMgr.SelectMgr_CompositionFilter_IsEmpty(self, *args)


    def IsIn(self, *args):
        """
        IsIn(SelectMgr_CompositionFilter self, Handle_SelectMgr_Filter aFilter) -> Standard_Boolean

        Returns true if the filter aFilter is in this framework.

        :type aFilter: OCC.wrapper.SelectMgr.Handle_SelectMgr_Filter
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _SelectMgr.SelectMgr_CompositionFilter_IsIn(self, *args)


    def StoredFilters(self, *args):
        """
        Returns the list of stored filters from this framework.

        :rtype: OCC.wrapper.SelectMgr.SelectMgr_ListOfFilter

        """
        res = _SelectMgr.SelectMgr_CompositionFilter_StoredFilters(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Clear(self, *args):
        """
        Clear(SelectMgr_CompositionFilter self)

        Clears the filters used in this framework.


        """
        return _SelectMgr.SelectMgr_CompositionFilter_Clear(self, *args)


    def ActsOn(self, *args):
        """
        ActsOn(SelectMgr_CompositionFilter self, TopAbs_ShapeEnum const aStandardMode) -> Standard_Boolean

        :type aStandardMode: OCC.wrapper.TopAbs.TopAbs_ShapeEnum
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _SelectMgr.SelectMgr_CompositionFilter_ActsOn(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _SelectMgr.SelectMgr_CompositionFilter_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _SelectMgr.SelectMgr_CompositionFilter_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _SelectMgr.SelectMgr_CompositionFilter_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _SelectMgr.delete_SelectMgr_CompositionFilter
SelectMgr_CompositionFilter_swigregister = _SelectMgr.SelectMgr_CompositionFilter_swigregister
SelectMgr_CompositionFilter_swigregister(SelectMgr_CompositionFilter)

def SelectMgr_CompositionFilter_get_type_name(*args):
    """
    SelectMgr_CompositionFilter_get_type_name() -> char const *

    :rtype: const char *

    """
    return _SelectMgr.SelectMgr_CompositionFilter_get_type_name(*args)

def SelectMgr_CompositionFilter_get_type_descriptor(*args):
    """
    SelectMgr_CompositionFilter_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _SelectMgr.SelectMgr_CompositionFilter_get_type_descriptor(*args)

class SelectMgr_SelectableObject(PrsMgr.PrsMgr_PresentableObject):
    """
    A framework to supply the structure of the object to be
    selected. At the first pick, this structure is created by
    calling the appropriate algorithm and retaining this
    framework for further picking.
    This abstract framework is inherited in Application
    Interactive Services (AIS), notably in AIS_InteractiveObject.
    Consequently, 3D selection should be handled by the
    relevant daughter classes and their member functions
    in AIS. This is particularly true in the creation of new interactive objects.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_SelectMgr_SelectableObject
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_SelectMgr_SelectableObject(self) 
            return h


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _SelectMgr.SelectMgr_SelectableObject_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _SelectMgr.SelectMgr_SelectableObject_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _SelectMgr.SelectMgr_SelectableObject_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def RecomputePrimitives(self, *args):
        """
        RecomputePrimitives(SelectMgr_SelectableObject self)
        RecomputePrimitives(SelectMgr_SelectableObject self, Standard_Integer const theMode)

        Re-computes the sensitive primitives which correspond to the <theMode>th selection mode.
        IMPORTANT: Do not use this method to update selection primitives except implementing custom selection manager!
        selection manager! This method does not take into account necessary BVH updates, but may invalidate
        the pointers it refers to. TO UPDATE SELECTION properly from outside classes, use method UpdateSelection.

        :type theMode: int

        """
        return _SelectMgr.SelectMgr_SelectableObject_RecomputePrimitives(self, *args)


    def AddSelection(self, *args):
        """
        AddSelection(SelectMgr_SelectableObject self, Handle_SelectMgr_Selection aSelection, Standard_Integer const aMode)

        Adds the selection aSelection with the selection mode
        index aMode to this framework.

        :type aSelection: OCC.wrapper.SelectMgr.Handle_SelectMgr_Selection
        :type aMode: int

        """
        return _SelectMgr.SelectMgr_SelectableObject_AddSelection(self, *args)


    def ClearSelections(self, *args):
        """
        ClearSelections(SelectMgr_SelectableObject self, Standard_Boolean const update)

        Empties all the selections in the SelectableObject
        <update> parameter defines whether all object's
        selections should be flagged for further update or not.
        This improved method can be used to recompute an
        object's selection (without redisplaying the object
        completely) when some selection mode is activated not for the first time.

        :type update: bool

        """
        return _SelectMgr.SelectMgr_SelectableObject_ClearSelections(self, *args)


    def Selection(self, *args):
        """
        Returns the selection having specified selection mode or NULL.

        :type theMode: int
        :rtype: OCC.wrapper.SelectMgr.Handle_SelectMgr_Selection

        """
        res = _SelectMgr.SelectMgr_SelectableObject_Selection(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def HasSelection(self, *args):
        """
        HasSelection(SelectMgr_SelectableObject self, Standard_Integer const theMode) -> Standard_Boolean

        Returns true if a selection corresponding to the selection mode theMode was computed for this object.

        :type theMode: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _SelectMgr.SelectMgr_SelectableObject_HasSelection(self, *args)


    def Selections(self, *args):
        """
        Return the sequence of selections.

        :rtype: OCC.wrapper.SelectMgr.SelectMgr_SequenceOfSelection

        """
        res = _SelectMgr.SelectMgr_SelectableObject_Selections(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Init(self, *args):
        """
        Init(SelectMgr_SelectableObject self)

        Begins the iteration scanning for sensitive primitives.


        """
        return _SelectMgr.SelectMgr_SelectableObject_Init(self, *args)


    def More(self, *args):
        """
        More(SelectMgr_SelectableObject self) -> Standard_Boolean

        Continues the iteration scanning for sensitive primitives.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _SelectMgr.SelectMgr_SelectableObject_More(self, *args)


    def Next(self, *args):
        """
        Next(SelectMgr_SelectableObject self)

        Continues the iteration scanning for sensitive primitives.


        """
        return _SelectMgr.SelectMgr_SelectableObject_Next(self, *args)


    def CurrentSelection(self, *args):
        """
        Returns the current selection in this framework.

        :rtype: OCC.wrapper.SelectMgr.Handle_SelectMgr_Selection

        """
        res = _SelectMgr.SelectMgr_SelectableObject_CurrentSelection(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ResetTransformation(self, *args):
        """
        ResetTransformation(SelectMgr_SelectableObject self)

        resets local transformation to identity.


        """
        return _SelectMgr.SelectMgr_SelectableObject_ResetTransformation(self, *args)


    def UpdateTransformation(self, *args):
        """
        UpdateTransformation(SelectMgr_SelectableObject self)

        Recomputes the location of the selection aSelection.


        """
        return _SelectMgr.SelectMgr_SelectableObject_UpdateTransformation(self, *args)


    def UpdateTransformations(self, *args):
        """
        UpdateTransformations(SelectMgr_SelectableObject self, Handle_SelectMgr_Selection aSelection)

        Updates locations in all sensitive entities from <aSelection>
        and in corresponding entity owners.

        :type aSelection: OCC.wrapper.SelectMgr.Handle_SelectMgr_Selection

        """
        return _SelectMgr.SelectMgr_SelectableObject_UpdateTransformations(self, *args)


    def HilightSelected(self, *args):
        """
        HilightSelected(SelectMgr_SelectableObject self, Handle_PrsMgr_PresentationManager PM, NCollection_Sequence_Handle_SelectMgr_EntityOwner Seq)

        Method which draws selected owners ( for fast presentation draw )

        :type PM: OCC.wrapper.SelectMgr.Handle_PrsMgr_PresentationManager3d
        :type Seq: OCC.wrapper.SelectMgr.SelectMgr_SequenceOfOwner

        """
        return _SelectMgr.SelectMgr_SelectableObject_HilightSelected(self, *args)


    def ClearSelected(self, *args):
        """
        ClearSelected(SelectMgr_SelectableObject self)

        Method which clear all selected owners belonging
        to this selectable object ( for fast presentation draw )


        """
        return _SelectMgr.SelectMgr_SelectableObject_ClearSelected(self, *args)


    def ClearDynamicHighlight(self, *args):
        """
        ClearDynamicHighlight(SelectMgr_SelectableObject self, Handle_PrsMgr_PresentationManager theMgr)

        Method that needs to be implemented when the object
        manages selection and dynamic highlighting on its own.
        Clears or invalidates dynamic highlight presentation.
        By default it clears immediate draw of given presentation
        manager.

        :type theMgr: OCC.wrapper.SelectMgr.Handle_PrsMgr_PresentationManager3d

        """
        return _SelectMgr.SelectMgr_SelectableObject_ClearDynamicHighlight(self, *args)


    def HilightOwnerWithColor(self, *args):
        """
        HilightOwnerWithColor(SelectMgr_SelectableObject self, Handle_PrsMgr_PresentationManager thePM, Handle_Prs3d_Drawer theStyle, Handle_SelectMgr_EntityOwner theOwner)

        Method which hilight an owner belonging to
        this selectable object  ( for fast presentation draw )

        :type thePM: OCC.wrapper.SelectMgr.Handle_PrsMgr_PresentationManager3d
        :type theStyle: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer
        :type theOwner: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner

        """
        return _SelectMgr.SelectMgr_SelectableObject_HilightOwnerWithColor(self, *args)


    def IsAutoHilight(self, *args):
        """
        IsAutoHilight(SelectMgr_SelectableObject self) -> Standard_Boolean

        If returns True, the old mechanism for highlighting
        selected objects is used (HilightSelected Method may be empty).
        If returns False, the HilightSelected method will be
        fully responsible for highlighting selected entity
        owners belonging to this selectable object.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _SelectMgr.SelectMgr_SelectableObject_IsAutoHilight(self, *args)


    def SetAutoHilight(self, *args):
        """
        SetAutoHilight(SelectMgr_SelectableObject self, Standard_Boolean const newAutoHilight)

        Set AutoHilight property to true or false
        Sets  up  Transform  Persistence Mode  for  this  object

        :type newAutoHilight: bool

        """
        return _SelectMgr.SelectMgr_SelectableObject_SetAutoHilight(self, *args)


    def GetHilightPresentation(self, *args):
        """
        GetHilightPresentation(SelectMgr_SelectableObject self, Handle_PrsMgr_PresentationManager TheMgr) -> Handle_Prs3d_Presentation

        :type TheMgr: OCC.wrapper.SelectMgr.Handle_PrsMgr_PresentationManager3d
        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation

        """
        return _SelectMgr.SelectMgr_SelectableObject_GetHilightPresentation(self, *args)


    def GetSelectPresentation(self, *args):
        """
        GetSelectPresentation(SelectMgr_SelectableObject self, Handle_PrsMgr_PresentationManager TheMgr) -> Handle_Prs3d_Presentation

        :type TheMgr: OCC.wrapper.SelectMgr.Handle_PrsMgr_PresentationManager3d
        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation

        """
        return _SelectMgr.SelectMgr_SelectableObject_GetSelectPresentation(self, *args)


    def ErasePresentations(self, *args):
        """
        ErasePresentations(SelectMgr_SelectableObject self, Standard_Boolean theToRemove)

        Removes presentations returned by GetHilightPresentation() and GetSelectPresentation().

        :type theToRemove: bool

        """
        return _SelectMgr.SelectMgr_SelectableObject_ErasePresentations(self, *args)


    def SetZLayer(self, *args):
        """
        SetZLayer(SelectMgr_SelectableObject self, Graphic3d_ZLayerId const theLayerId)

        Set Z layer ID and update all presentations of the selectable object.
        The layers mechanism allows drawing objects in higher layers in overlay of objects in lower layers.

        :type theLayerId: OCC.wrapper.Graphic3d.Graphic3d_ZLayerId

        """
        return _SelectMgr.SelectMgr_SelectableObject_SetZLayer(self, *args)


    def UpdateSelection(self, *args):
        """
        UpdateSelection(SelectMgr_SelectableObject self, Standard_Integer const theMode=-1)

        Sets update status FULL to selections of the object. Must be used as the only method of UpdateSelection
        from outer classes to prevent BVH structures from being outdated.

        :type theMode: int

        """
        return _SelectMgr.SelectMgr_SelectableObject_UpdateSelection(self, *args)


    def BoundingBox(self, *args):
        """
        BoundingBox(SelectMgr_SelectableObject self, Bnd_Box theBndBox)

        Returns bounding box of selectable object
        by storing its minimum and maximum 3d coordinates
        to output parameters

        :type theBndBox: OCC.wrapper.Bnd.Bnd_Box

        """
        return _SelectMgr.SelectMgr_SelectableObject_BoundingBox(self, *args)


    def SetAssemblyOwner(self, *args):
        """
        SetAssemblyOwner(SelectMgr_SelectableObject self, Handle_SelectMgr_EntityOwner theOwner, Standard_Integer const theMode=-1)

        Sets common entity owner for assembly sensitive object entities

        :type theOwner: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner
        :type theMode: int

        """
        return _SelectMgr.SelectMgr_SelectableObject_SetAssemblyOwner(self, *args)


    def BndBoxOfSelected(self, *args):
        """
        BndBoxOfSelected(SelectMgr_SelectableObject self, opencascade::handle< SelectMgr_IndexedMapOfOwner > const & theOwners) -> Bnd_Box

        Returns a bounding box of sensitive entities with the owners given
        if they are a part of activated selection

        :type theOwners: OCC.wrapper.SelectMgr.Handle_SelectMgr_IndexedMapOfOwner
        :rtype: OCC.wrapper.Bnd.Bnd_Box

        """
        return _SelectMgr.SelectMgr_SelectableObject_BndBoxOfSelected(self, *args)


    def GlobalSelectionMode(self, *args):
        """
        GlobalSelectionMode(SelectMgr_SelectableObject self) -> Standard_Integer

        Returns the mode for selection of object as a whole

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _SelectMgr.SelectMgr_SelectableObject_GlobalSelectionMode(self, *args)


    def GlobalSelOwner(self, *args):
        """
        GlobalSelOwner(SelectMgr_SelectableObject self) -> Handle_SelectMgr_EntityOwner

        Returns the owner of mode for selection of object as a whole

        :rtype: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner

        """
        return _SelectMgr.SelectMgr_SelectableObject_GlobalSelOwner(self, *args)


    def GetAssemblyOwner(self, *args):
        """
        Returns common entity owner if the object is an assembly

        :rtype: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner

        """
        res = _SelectMgr.SelectMgr_SelectableObject_GetAssemblyOwner(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _SelectMgr.delete_SelectMgr_SelectableObject
SelectMgr_SelectableObject_swigregister = _SelectMgr.SelectMgr_SelectableObject_swigregister
SelectMgr_SelectableObject_swigregister(SelectMgr_SelectableObject)

def SelectMgr_SelectableObject_get_type_name(*args):
    """
    SelectMgr_SelectableObject_get_type_name() -> char const *

    :rtype: const char *

    """
    return _SelectMgr.SelectMgr_SelectableObject_get_type_name(*args)

def SelectMgr_SelectableObject_get_type_descriptor(*args):
    """
    SelectMgr_SelectableObject_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _SelectMgr.SelectMgr_SelectableObject_get_type_descriptor(*args)

class SelectMgr_Selection(Standard.Standard_Transient):
    """
    Represents the state of a given selection mode for a
    Selectable Object. Contains all the sensitive entities available for this mode.
    An interactive object can have an indefinite number of
    modes of selection, each representing a
    "decomposition" into sensitive primitives; each
    primitive has an Owner (SelectMgr_EntityOwner)
    which allows us to identify the exact entity which has
    been detected. Each Selection mode is identified by
    an index. The set of sensitive primitives which
    correspond to a given mode is stocked in a
    SelectMgr_Selection object. By Convention, the
    default selection mode which allows us to grasp the
    Interactive object in its entirety will be mode 0.
    AIS_Trihedron : 4 selection modes
    -   mode 0 : selection of a trihedron
    -   mode 1 : selection of the origin of the trihedron
    -   mode 2 : selection of the axes
    -   mode 3 : selection of the planes XOY, YOZ, XOZ
    when you activate one of modes 1 2 3 4 , you pick AIS objects of type:
    -   AIS_Point
    -   AIS_Axis (and information on the type of axis)
    -   AIS_Plane (and information on the type of plane).
    AIS_PlaneTrihedron offers 3 selection modes:
    -   mode 0 : selection of the whole trihedron
    -   mode 1 : selection of the origin of the trihedron
    -   mode 2 : selection of the axes - same remarks as for the Trihedron.
    AIS_Shape : 7 maximum selection modes, depending
    on the complexity of the shape :
    -   mode 0 : selection of the AIS_Shape
    -   mode 1 : selection of the vertices
    -   mode 2 : selection of the edges
    -   mode 3 : selection of the wires
    -   mode 4 : selection of the faces
    -   mode 5 : selection of the shells
    -   mode 6 :   selection of the constituent solids.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_SelectMgr_Selection
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_SelectMgr_Selection(self) 
            return h


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _SelectMgr.SelectMgr_Selection_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _SelectMgr.SelectMgr_Selection_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _SelectMgr.SelectMgr_Selection_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __init__(self, *args):
        """
        __init__(SelectMgr_Selection self, Standard_Integer const theModeIdx=0) -> SelectMgr_Selection

        Constructs a selection object defined by the selection mode IdMode.
        The default setting 0 is the selection mode for a shape in its entirety.

        :type theModeIdx: int

        """
        this = _SelectMgr.new_SelectMgr_Selection(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Destroy(self, *args):
        """Destroy(SelectMgr_Selection self)"""
        return _SelectMgr.SelectMgr_Selection_Destroy(self, *args)


    def Add(self, *args):
        """
        Add(SelectMgr_Selection self, Handle_SelectBasics_SensitiveEntity theSensitive)

        Adds the sensitive primitive to the list of stored entities in this object.
        Raises NullObject if the primitive is a null handle.

        :type theSensitive: OCC.wrapper.SelectBasics.Handle_SelectBasics_SensitiveEntity

        """
        return _SelectMgr.SelectMgr_Selection_Add(self, *args)


    def Clear(self, *args):
        """
        Clear(SelectMgr_Selection self)

        empties the selection from all the stored entities


        """
        return _SelectMgr.SelectMgr_Selection_Clear(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(SelectMgr_Selection self) -> Standard_Boolean

        returns true if no sensitive entity is stored.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _SelectMgr.SelectMgr_Selection_IsEmpty(self, *args)


    def Mode(self, *args):
        """
        Mode(SelectMgr_Selection self) -> Standard_Integer

        returns the selection mode represented by this selection

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _SelectMgr.SelectMgr_Selection_Mode(self, *args)


    def Entities(self, *args):
        """
        Return entities.

        :rtype: OCC.wrapper.SelectMgr.NCollection_Vector_Handle_SelectMgr_SensitiveEntity

        """
        res = _SelectMgr.SelectMgr_Selection_Entities(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeEntities(self, *args):
        """
        ChangeEntities(SelectMgr_Selection self) -> NCollection_Vector_Handle_SelectMgr_SensitiveEntity

        Return entities.

        :rtype: OCC.wrapper.SelectMgr.NCollection_Vector_Handle_SelectMgr_SensitiveEntity

        """
        return _SelectMgr.SelectMgr_Selection_ChangeEntities(self, *args)


    def Init(self, *args):
        """
        Init(SelectMgr_Selection self)

        Begins an iteration scanning for sensitive primitives.


        """
        return _SelectMgr.SelectMgr_Selection_Init(self, *args)


    def More(self, *args):
        """
        More(SelectMgr_Selection self) -> Standard_Boolean

        Continues the iteration scanning for sensitive
        primitives with the mode defined in this framework.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _SelectMgr.SelectMgr_Selection_More(self, *args)


    def Next(self, *args):
        """
        Next(SelectMgr_Selection self)

        Returns the next sensitive primitive found in the
        iteration. This is a scan for entities with the mode
        defined in this framework.


        """
        return _SelectMgr.SelectMgr_Selection_Next(self, *args)


    def Sensitive(self, *args):
        """
        Returns any sensitive primitive in this framework.

        :rtype: OCC.wrapper.SelectMgr.Handle_SelectMgr_SensitiveEntity

        """
        res = _SelectMgr.SelectMgr_Selection_Sensitive(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def UpdateStatus(self, *args):
        """
        UpdateStatus(SelectMgr_Selection self) -> SelectMgr_TypeOfUpdate
        UpdateStatus(SelectMgr_Selection self, SelectMgr_TypeOfUpdate const theStatus)

        :type theStatus: OCC.wrapper.SelectMgr.SelectMgr_TypeOfUpdate

        """
        return _SelectMgr.SelectMgr_Selection_UpdateStatus(self, *args)


    def UpdateBVHStatus(self, *args):
        """
        UpdateBVHStatus(SelectMgr_Selection self, SelectMgr_TypeOfBVHUpdate const theStatus)

        :type theStatus: OCC.wrapper.SelectMgr.SelectMgr_TypeOfBVHUpdate

        """
        return _SelectMgr.SelectMgr_Selection_UpdateBVHStatus(self, *args)


    def BVHUpdateStatus(self, *args):
        """
        BVHUpdateStatus(SelectMgr_Selection self) -> SelectMgr_TypeOfBVHUpdate

        :rtype: OCC.wrapper.SelectMgr.SelectMgr_TypeOfBVHUpdate

        """
        return _SelectMgr.SelectMgr_Selection_BVHUpdateStatus(self, *args)


    def GetSelectionState(self, *args):
        """
        GetSelectionState(SelectMgr_Selection self) -> SelectMgr_StateOfSelection

        Returns status of selection

        :rtype: OCC.wrapper.SelectMgr.SelectMgr_StateOfSelection

        """
        return _SelectMgr.SelectMgr_Selection_GetSelectionState(self, *args)


    def SetSelectionState(self, *args):
        """
        SetSelectionState(SelectMgr_Selection self, SelectMgr_StateOfSelection const theState)

        Sets status of selection

        :type theState: OCC.wrapper.SelectMgr.SelectMgr_StateOfSelection

        """
        return _SelectMgr.SelectMgr_Selection_SetSelectionState(self, *args)


    def Sensitivity(self, *args):
        """
        Sensitivity(SelectMgr_Selection self) -> Standard_Integer

        Returns sensitivity of the selection

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _SelectMgr.SelectMgr_Selection_Sensitivity(self, *args)


    def SetSensitivity(self, *args):
        """
        SetSensitivity(SelectMgr_Selection self, Standard_Integer const theNewSens)

        Changes sensitivity of the selection and all its entities to the given value.
        IMPORTANT: This method does not update any outer selection structures, so for
        proper updates use SelectMgr_SelectionManager::SetSelectionSensitivity method.

        :type theNewSens: int

        """
        return _SelectMgr.SelectMgr_Selection_SetSensitivity(self, *args)

    __swig_destroy__ = _SelectMgr.delete_SelectMgr_Selection
SelectMgr_Selection_swigregister = _SelectMgr.SelectMgr_Selection_swigregister
SelectMgr_Selection_swigregister(SelectMgr_Selection)

def SelectMgr_Selection_get_type_name(*args):
    """
    SelectMgr_Selection_get_type_name() -> char const *

    :rtype: const char *

    """
    return _SelectMgr.SelectMgr_Selection_get_type_name(*args)

def SelectMgr_Selection_get_type_descriptor(*args):
    """
    SelectMgr_Selection_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _SelectMgr.SelectMgr_Selection_get_type_descriptor(*args)

class SelectMgr_ViewerSelector(Standard.Standard_Transient):
    """
    A framework to define finding, sorting the sensitive
    primitives in a view. Services are also provided to
    define the return of the owners of those primitives
    selected. The primitives are sorted by criteria such
    as priority of the primitive or its depth in the view
    relative to that of other primitives.
    Note that in 3D, the inheriting framework
    StdSelect_ViewerSelector3d   is only to be used
    if you do not want to use the services provided by
    AIS.
    Two tools are available to find and select objects
    found at a given position in the view. If you want to
    select the owners of all the objects detected at
    point x,y,z you use the Init - More - Next - Picked
    loop. If, on the other hand, you want to select only
    one object detected at that point, you use the Init -
    More - OnePicked loop. In this iteration, More is
    used to see if an object was picked and
    OnePicked, to get the object closest to the pick position.
    Viewer selectors are driven by
    SelectMgr_SelectionManager, and manipulate
    the SelectMgr_Selection objects given to them by
    the selection manager.

    Tolerances are applied to the entities in the following way:
    1. tolerance value stored in mytolerance will be used to calculate initial
    selecting frustum, which will be applied for intersection testing during
    BVH traverse;
    2. if tolerance of sensitive entity is less than mytolerance, the frustum for
    intersection detection will be resized according to its sensitivity.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_SelectMgr_ViewerSelector
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_SelectMgr_ViewerSelector(self) 
            return h


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _SelectMgr.SelectMgr_ViewerSelector_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _SelectMgr.SelectMgr_ViewerSelector_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _SelectMgr.SelectMgr_ViewerSelector_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Clear(self, *args):
        """
        Clear(SelectMgr_ViewerSelector self)

        Empties all the tables, removes all selections...


        """
        return _SelectMgr.SelectMgr_ViewerSelector_Clear(self, *args)


    def Sensitivity(self, *args):
        """
        Sensitivity(SelectMgr_ViewerSelector self) -> Standard_Real

        returns the Sensitivity of picking

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _SelectMgr.SelectMgr_ViewerSelector_Sensitivity(self, *args)


    def SortResult(self, *args):
        """
        SortResult(SelectMgr_ViewerSelector self)

        Sorts the detected entites by priority and distance.
        to be redefined if other criterion are used...


        """
        return _SelectMgr.SelectMgr_ViewerSelector_SortResult(self, *args)


    def OnePicked(self, *args):
        """
        OnePicked(SelectMgr_ViewerSelector self) -> Handle_SelectMgr_EntityOwner

        Returns the picked element with the highest priority,
        and which is the closest to the last successful mouse position.

        :rtype: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner

        """
        return _SelectMgr.SelectMgr_ViewerSelector_OnePicked(self, *args)


    def SetPickClosest(self, *args):
        """
        SetPickClosest(SelectMgr_ViewerSelector self, Standard_Boolean const theToPreferClosest)

        Set preference of selecting one object for OnePicked() method:
        - If True, objects with less depth (distance fron the view plane) are
        preferred regardless of priority (priority is used then to choose among
        objects with similar depth),
        - If False, objects with higher priority are preferred regardless of the
        depth which is used to choose among objects of the same priority.

        :type theToPreferClosest: bool

        """
        return _SelectMgr.SelectMgr_ViewerSelector_SetPickClosest(self, *args)


    def NbPicked(self, *args):
        """
        NbPicked(SelectMgr_ViewerSelector self) -> Standard_Integer

        Returns the number of detected owners.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _SelectMgr.SelectMgr_ViewerSelector_NbPicked(self, *args)


    def ClearPicked(self, *args):
        """
        ClearPicked(SelectMgr_ViewerSelector self)

        Clears picking results.


        """
        return _SelectMgr.SelectMgr_ViewerSelector_ClearPicked(self, *args)


    def PickedData(self, *args):
        """
        Returns the Entity for the object picked at specified position.
        @param theRank rank of detected object within range 1...NbPicked()

        :type theRank: int
        :rtype: OCC.wrapper.SelectMgr.SelectMgr_SortCriterion

        """
        res = _SelectMgr.SelectMgr_ViewerSelector_PickedData(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def PickedEntity(self, *args):
        """
        Returns the Entity for the object picked at specified position.
        @param theRank rank of detected object within range 1...NbPicked()

        :type theRank: int
        :rtype: OCC.wrapper.SelectBasics.Handle_SelectBasics_SensitiveEntity

        """
        res = _SelectMgr.SelectMgr_ViewerSelector_PickedEntity(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def PickedPoint(self, *args):
        """
        PickedPoint(SelectMgr_ViewerSelector self, Standard_Integer const theRank) -> gp_Pnt

        Returns the 3D point (intersection of picking axis with the object nearest to eye)
        for the object picked at specified position.
        @param theRank rank of detected object within range 1...NbPicked()

        :type theRank: int
        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _SelectMgr.SelectMgr_ViewerSelector_PickedPoint(self, *args)


    def Contains(self, *args):
        """
        Contains(SelectMgr_ViewerSelector self, Handle_SelectMgr_SelectableObject theObject) -> Standard_Boolean

        :type theObject: OCC.wrapper.SelectMgr.Handle_SelectMgr_SelectableObject
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _SelectMgr.SelectMgr_ViewerSelector_Contains(self, *args)


    def EntitySetBuilder(self, *args):
        """
        EntitySetBuilder(SelectMgr_ViewerSelector self) -> Handle_Select3D_BVHBuilder3d

        Returns the default builder used to construct BVH of entity set.

        :rtype: OCC.wrapper.SelectMgr.Handle_Select3D_BVHBuilder3d

        """
        return _SelectMgr.SelectMgr_ViewerSelector_EntitySetBuilder(self, *args)


    def SetEntitySetBuilder(self, *args):
        """
        SetEntitySetBuilder(SelectMgr_ViewerSelector self, Handle_Select3D_BVHBuilder3d theBuilder)

        Sets the default builder used to construct BVH of entity set.
        The new builder will be also assigned for already defined objects, but computed BVH trees will not be invalidated.

        :type theBuilder: OCC.wrapper.SelectMgr.Handle_Select3D_BVHBuilder3d

        """
        return _SelectMgr.SelectMgr_ViewerSelector_SetEntitySetBuilder(self, *args)


    def Modes(self, *args):
        """
        Modes(SelectMgr_ViewerSelector self, Handle_SelectMgr_SelectableObject theSelectableObject, NCollection_List_Standard_Integer theModeList, SelectMgr_StateOfSelection const theWantedState=SelectMgr_SOS_Any) -> Standard_Boolean

        Returns the list of selection modes ModeList found in
        this selector for the selectable object aSelectableObject.
        Returns true if aSelectableObject is referenced inside
        this selector; returns false if the object is not present
        in this selector.

        :type theSelectableObject: OCC.wrapper.SelectMgr.Handle_SelectMgr_SelectableObject
        :type theModeList: OCC.wrapper.TColStd.TColStd_ListOfInteger
        :type theWantedState: OCC.wrapper.SelectMgr.SelectMgr_StateOfSelection
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _SelectMgr.SelectMgr_ViewerSelector_Modes(self, *args)


    def IsActive(self, *args):
        """
        IsActive(SelectMgr_ViewerSelector self, Handle_SelectMgr_SelectableObject theSelectableObject, Standard_Integer const theMode) -> Standard_Boolean

        Returns true if the selectable object
        aSelectableObject having the selection mode aMode
        is active in this selector.

        :type theSelectableObject: OCC.wrapper.SelectMgr.Handle_SelectMgr_SelectableObject
        :type theMode: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _SelectMgr.SelectMgr_ViewerSelector_IsActive(self, *args)


    def IsInside(self, *args):
        """
        IsInside(SelectMgr_ViewerSelector self, Handle_SelectMgr_SelectableObject theSelectableObject, Standard_Integer const theMode) -> Standard_Boolean

        Returns true if the selectable object
        aSelectableObject having the selection mode aMode
        is in this selector.

        :type theSelectableObject: OCC.wrapper.SelectMgr.Handle_SelectMgr_SelectableObject
        :type theMode: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _SelectMgr.SelectMgr_ViewerSelector_IsInside(self, *args)


    def Status(self, *args):
        """
        Status(SelectMgr_ViewerSelector self, Handle_SelectMgr_Selection theSelection) -> SelectMgr_StateOfSelection
        Status(SelectMgr_ViewerSelector self, Handle_SelectMgr_SelectableObject theSelectableObject) -> TCollection_AsciiString

        :type theSelectableObject: OCC.wrapper.SelectMgr.Handle_SelectMgr_SelectableObject
        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _SelectMgr.SelectMgr_ViewerSelector_Status(self, *args)


    def ActiveOwners(self, *args):
        """
        ActiveOwners(SelectMgr_ViewerSelector self, NCollection_List< opencascade::handle< SelectBasics_EntityOwner > > & theOwners)

        Returns the list of active entity owners

        :type theOwners: OCC.wrapper.SelectMgr.NCollection_List_Handle_SelectBasics_EntityOwner

        """
        return _SelectMgr.SelectMgr_ViewerSelector_ActiveOwners(self, *args)


    def AddSelectableObject(self, *args):
        """
        AddSelectableObject(SelectMgr_ViewerSelector self, Handle_SelectMgr_SelectableObject theObject)

        Adds new object to the map of selectable objects

        :type theObject: OCC.wrapper.SelectMgr.Handle_SelectMgr_SelectableObject

        """
        return _SelectMgr.SelectMgr_ViewerSelector_AddSelectableObject(self, *args)


    def AddSelectionToObject(self, *args):
        """
        AddSelectionToObject(SelectMgr_ViewerSelector self, Handle_SelectMgr_SelectableObject theObject, Handle_SelectMgr_Selection theSelection)

        Adds new selection to the object and builds its BVH tree

        :type theObject: OCC.wrapper.SelectMgr.Handle_SelectMgr_SelectableObject
        :type theSelection: OCC.wrapper.SelectMgr.Handle_SelectMgr_Selection

        """
        return _SelectMgr.SelectMgr_ViewerSelector_AddSelectionToObject(self, *args)


    def MoveSelectableObject(self, *args):
        """
        MoveSelectableObject(SelectMgr_ViewerSelector self, Handle_SelectMgr_SelectableObject theObject)

        Moves existing object from set of not transform persistence objects
        to set of transform persistence objects (or vice versa).

        :type theObject: OCC.wrapper.SelectMgr.Handle_SelectMgr_SelectableObject

        """
        return _SelectMgr.SelectMgr_ViewerSelector_MoveSelectableObject(self, *args)


    def RemoveSelectableObject(self, *args):
        """
        RemoveSelectableObject(SelectMgr_ViewerSelector self, Handle_SelectMgr_SelectableObject theObject)

        Removes selectable object from map of selectable ones

        :type theObject: OCC.wrapper.SelectMgr.Handle_SelectMgr_SelectableObject

        """
        return _SelectMgr.SelectMgr_ViewerSelector_RemoveSelectableObject(self, *args)


    def RemoveSelectionOfObject(self, *args):
        """
        RemoveSelectionOfObject(SelectMgr_ViewerSelector self, Handle_SelectMgr_SelectableObject theObject, Handle_SelectMgr_Selection theSelection)

        Removes selection of the object and marks its BVH tree for rebuild

        :type theObject: OCC.wrapper.SelectMgr.Handle_SelectMgr_SelectableObject
        :type theSelection: OCC.wrapper.SelectMgr.Handle_SelectMgr_Selection

        """
        return _SelectMgr.SelectMgr_ViewerSelector_RemoveSelectionOfObject(self, *args)


    def RebuildObjectsTree(self, *args):
        """
        RebuildObjectsTree(SelectMgr_ViewerSelector self, Standard_Boolean const theIsForce)

        Marks BVH of selectable objects for rebuild. Parameter theIsForce set as true
        guarantees that 1st level BVH for the viewer selector will be rebuilt during this call

        :type theIsForce: bool

        """
        return _SelectMgr.SelectMgr_ViewerSelector_RebuildObjectsTree(self, *args)


    def RebuildSensitivesTree(self, *args):
        """
        RebuildSensitivesTree(SelectMgr_ViewerSelector self, Handle_SelectMgr_SelectableObject theObject, Standard_Boolean const theIsForce)

        Marks BVH of sensitive entities of particular selectable object for rebuild. Parameter
        theIsForce set as true guarantees that 2nd level BVH for the object given will be
        rebuilt during this call

        :type theObject: OCC.wrapper.SelectMgr.Handle_SelectMgr_SelectableObject
        :type theIsForce: bool

        """
        return _SelectMgr.SelectMgr_ViewerSelector_RebuildSensitivesTree(self, *args)


    def GetManager(self, *args):
        """
        GetManager(SelectMgr_ViewerSelector self) -> SelectMgr_SelectingVolumeManager

        Returns instance of selecting volume manager of the viewer selector

        :rtype: OCC.wrapper.SelectMgr.SelectMgr_SelectingVolumeManager

        """
        return _SelectMgr.SelectMgr_ViewerSelector_GetManager(self, *args)


    def ResetSelectionActivationStatus(self, *args):
        """
        ResetSelectionActivationStatus(SelectMgr_ViewerSelector self)

        Marks all added sensitive entities of all objects as non-selectable


        """
        return _SelectMgr.SelectMgr_ViewerSelector_ResetSelectionActivationStatus(self, *args)


    def AllowOverlapDetection(self, *args):
        """
        AllowOverlapDetection(SelectMgr_ViewerSelector self, Standard_Boolean const theIsToAllow)

        Is used for rectangular selection only
        If theIsToAllow is false, only fully included sensitives will be detected, otherwise the algorithm will
        mark both included and overlapped entities as matched

        :type theIsToAllow: bool

        """
        return _SelectMgr.SelectMgr_ViewerSelector_AllowOverlapDetection(self, *args)


    def Init(self, *args):
        """
        Init(SelectMgr_ViewerSelector self)

        Begins an iteration scanning for the owners detected at a position in the view.


        """
        return _SelectMgr.SelectMgr_ViewerSelector_Init(self, *args)


    def More(self, *args):
        """
        More(SelectMgr_ViewerSelector self) -> Standard_Boolean

        Continues the interation scanning for the owners detected at a position in the view,
        or continues the iteration scanning for the owner closest to the position in the view.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _SelectMgr.SelectMgr_ViewerSelector_More(self, *args)


    def Next(self, *args):
        """
        Next(SelectMgr_ViewerSelector self)

        Returns the next owner found in the iteration. This is
        a scan for the owners detected at a position in the view.


        """
        return _SelectMgr.SelectMgr_ViewerSelector_Next(self, *args)


    def Picked(self, *args):
        """
        Picked(SelectMgr_ViewerSelector self, Standard_Integer const theRank) -> Handle_SelectMgr_EntityOwner
        Picked(SelectMgr_ViewerSelector self) -> Handle_SelectMgr_EntityOwner

        Returns the current selected entity detected by the selector;

        :rtype: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner

        """
        return _SelectMgr.SelectMgr_ViewerSelector_Picked(self, *args)


    def InitDetected(self, *args):
        """
        InitDetected(SelectMgr_ViewerSelector self)

        Initializes internal iterator for stored detected sensitive entities


        """
        return _SelectMgr.SelectMgr_ViewerSelector_InitDetected(self, *args)


    def NextDetected(self, *args):
        """
        NextDetected(SelectMgr_ViewerSelector self)

        Makes a step along the map of detected sensitive entities and their owners


        """
        return _SelectMgr.SelectMgr_ViewerSelector_NextDetected(self, *args)


    def MoreDetected(self, *args):
        """
        MoreDetected(SelectMgr_ViewerSelector self) -> Standard_Boolean

        Returns true if iterator of map of detected sensitive entities has reached its end

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _SelectMgr.SelectMgr_ViewerSelector_MoreDetected(self, *args)


    def DetectedEntity(self, *args):
        """
        Returns sensitive entity that was detected during the previous run of selection algorithm

        :rtype: OCC.wrapper.SelectBasics.Handle_SelectBasics_SensitiveEntity

        """
        res = _SelectMgr.SelectMgr_ViewerSelector_DetectedEntity(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _SelectMgr.delete_SelectMgr_ViewerSelector
SelectMgr_ViewerSelector_swigregister = _SelectMgr.SelectMgr_ViewerSelector_swigregister
SelectMgr_ViewerSelector_swigregister(SelectMgr_ViewerSelector)

def SelectMgr_ViewerSelector_get_type_name(*args):
    """
    SelectMgr_ViewerSelector_get_type_name() -> char const *

    :rtype: const char *

    """
    return _SelectMgr.SelectMgr_ViewerSelector_get_type_name(*args)

def SelectMgr_ViewerSelector_get_type_descriptor(*args):
    """
    SelectMgr_ViewerSelector_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _SelectMgr.SelectMgr_ViewerSelector_get_type_descriptor(*args)

class SelectMgr_EntityOwner(SelectBasics.SelectBasics_EntityOwner):
    """
    A framework to define classes of owners of sensitive primitives.
    The owner is the link between application and
    selection data structures.
    For the application to make its own objects selectable,
    it must define owner classes inheriting this framework.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_SelectMgr_EntityOwner
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_SelectMgr_EntityOwner(self) 
            return h


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _SelectMgr.SelectMgr_EntityOwner_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _SelectMgr.SelectMgr_EntityOwner_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _SelectMgr.SelectMgr_EntityOwner_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __init__(self, *args):
        """
        __init__(SelectMgr_EntityOwner self, Standard_Integer const aPriority=0) -> SelectMgr_EntityOwner
        __init__(SelectMgr_EntityOwner self, Handle_SelectMgr_SelectableObject aSO, Standard_Integer const aPriority=0) -> SelectMgr_EntityOwner
        __init__(SelectMgr_EntityOwner self, Handle_SelectMgr_EntityOwner theOwner, Standard_Integer const aPriority=0) -> SelectMgr_EntityOwner

        Constructs a framework from existing one
        anSO being attributed the selection priority aPriority.

        :type theOwner: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner
        :type aPriority: int

        """
        this = _SelectMgr.new_SelectMgr_EntityOwner(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def HasSelectable(self, *args):
        """
        HasSelectable(SelectMgr_EntityOwner self) -> Standard_Boolean

        Returns true if there is a selectable object to serve as an owner.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _SelectMgr.SelectMgr_EntityOwner_HasSelectable(self, *args)


    def Selectable(self, *args):
        """
        Selectable(SelectMgr_EntityOwner self) -> Handle_SelectMgr_SelectableObject

        Returns a selectable object detected in the working context.

        :rtype: OCC.wrapper.SelectMgr.Handle_SelectMgr_SelectableObject

        """
        return _SelectMgr.SelectMgr_EntityOwner_Selectable(self, *args)


    def SetSelectable(self, *args):
        """
        SetSelectable(SelectMgr_EntityOwner self, Handle_SelectMgr_SelectableObject theSelObj)

        Sets the selectable object.

        :type theSelObj: OCC.wrapper.SelectMgr.Handle_SelectMgr_SelectableObject

        """
        return _SelectMgr.SelectMgr_EntityOwner_SetSelectable(self, *args)


    def IsHilighted(self, *args):
        """
        IsHilighted(SelectMgr_EntityOwner self, Handle_PrsMgr_PresentationManager aPM, Standard_Integer const aMode=0) -> Standard_Boolean

        Returns true if the presentation manager aPM
        highlights selections corresponding to the selection mode aMode.

        :type aPM: OCC.wrapper.PrsMgr.Handle_PrsMgr_PresentationManager
        :type aMode: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _SelectMgr.SelectMgr_EntityOwner_IsHilighted(self, *args)


    def HilightWithColor(self, *args):
        """
        HilightWithColor(SelectMgr_EntityOwner self, Handle_PrsMgr_PresentationManager thePM, Handle_Prs3d_Drawer theStyle, Standard_Integer const theMode=0)

        Highlights selectable object's presentation with mode theMode in presentation manager
        with given highlight style. Also a check for auto-highlight is performed - if
        selectable object manages highlighting on its own, execution will be passed to
        SelectMgr_SelectableObject::HilightOwnerWithColor method

        :type thePM: OCC.wrapper.SelectMgr.Handle_PrsMgr_PresentationManager3d
        :type theStyle: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer
        :type theMode: int

        """
        return _SelectMgr.SelectMgr_EntityOwner_HilightWithColor(self, *args)


    def Unhilight(self, *args):
        """
        Unhilight(SelectMgr_EntityOwner self, Handle_PrsMgr_PresentationManager thePrsMgr, Standard_Integer const theMode=0)

        Removes highlighting from the owner of a detected selectable object in the presentation manager.
        This object could be the owner of a sensitive primitive.
        @param thePrsMgr presentation manager
        @param theMode   obsolete argument for compatibility, should be ignored by implementations

        :type thePrsMgr: OCC.wrapper.PrsMgr.Handle_PrsMgr_PresentationManager
        :type theMode: int

        """
        return _SelectMgr.SelectMgr_EntityOwner_Unhilight(self, *args)


    def Clear(self, *args):
        """
        Clear(SelectMgr_EntityOwner self, Handle_PrsMgr_PresentationManager aPM, Standard_Integer const aMode=0)

        Clears the owners matching the value of the selection
        mode aMode from the presentation manager object aPM.

        :type aPM: OCC.wrapper.PrsMgr.Handle_PrsMgr_PresentationManager
        :type aMode: int

        """
        return _SelectMgr.SelectMgr_EntityOwner_Clear(self, *args)


    def HasLocation(self, *args):
        """
        HasLocation(SelectMgr_EntityOwner self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _SelectMgr.SelectMgr_EntityOwner_HasLocation(self, *args)


    def SetLocation(self, *args):
        """
        SetLocation(SelectMgr_EntityOwner self, TopLoc_Location aLoc)

        :type aLoc: OCC.wrapper.TopLoc.TopLoc_Location

        """
        return _SelectMgr.SelectMgr_EntityOwner_SetLocation(self, *args)


    def ResetLocation(self, *args):
        """ResetLocation(SelectMgr_EntityOwner self)"""
        return _SelectMgr.SelectMgr_EntityOwner_ResetLocation(self, *args)


    def Location(self, *args):
        """
        Location(SelectMgr_EntityOwner self) -> TopLoc_Location

        :rtype: OCC.wrapper.TopLoc.TopLoc_Location

        """
        return _SelectMgr.SelectMgr_EntityOwner_Location(self, *args)


    def SetSelected(self, *args):
        """
        SetSelected(SelectMgr_EntityOwner self, Standard_Boolean const theIsSelected)

        Set the state of the owner.
        @param theIsSelected [in] shows if owner is selected.

        :type theIsSelected: bool

        """
        return _SelectMgr.SelectMgr_EntityOwner_SetSelected(self, *args)


    def IsSelected(self, *args):
        """
        IsSelected(SelectMgr_EntityOwner self) -> Standard_Boolean

        @return Standard_True if the owner is selected.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _SelectMgr.SelectMgr_EntityOwner_IsSelected(self, *args)


    def State(self, *args):
        """
        State(SelectMgr_EntityOwner self, Standard_Integer const theStatus)
        State(SelectMgr_EntityOwner self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _SelectMgr.SelectMgr_EntityOwner_State(self, *args)


    def IsAutoHilight(self, *args):
        """
        IsAutoHilight(SelectMgr_EntityOwner self) -> Standard_Boolean

        if owner is not auto hilighted, for group contains many such owners
        will be called one method HilightSelected of SelectableObject

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _SelectMgr.SelectMgr_EntityOwner_IsAutoHilight(self, *args)


    def IsForcedHilight(self, *args):
        """
        IsForcedHilight(SelectMgr_EntityOwner self) -> Standard_Boolean

        if this method returns TRUE the owner will allways call method
        Hilight for SelectableObject when the owner is detected. By default
        it always return FALSE.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _SelectMgr.SelectMgr_EntityOwner_IsForcedHilight(self, *args)


    def SetZLayer(self, *args):
        """
        SetZLayer(SelectMgr_EntityOwner self, Graphic3d_ZLayerId const theLayerId)

        Set Z layer ID and update all presentations.

        :type theLayerId: OCC.wrapper.Graphic3d.Graphic3d_ZLayerId

        """
        return _SelectMgr.SelectMgr_EntityOwner_SetZLayer(self, *args)


    def UpdateHighlightTrsf(self, *args):
        """
        UpdateHighlightTrsf(SelectMgr_EntityOwner self, Handle_V3d_Viewer theViewer, Handle_PrsMgr_PresentationManager theManager, Standard_Integer const theDispMode)

        Implements immediate application of location transformation of parent object to dynamic highlight structure

        :type theViewer: OCC.wrapper.V3d.Handle_V3d_Viewer
        :type theManager: OCC.wrapper.SelectMgr.Handle_PrsMgr_PresentationManager3d
        :type theDispMode: int

        """
        return _SelectMgr.SelectMgr_EntityOwner_UpdateHighlightTrsf(self, *args)


    def IsSameSelectable(self, *args):
        """
        IsSameSelectable(SelectMgr_EntityOwner self, Handle_SelectMgr_SelectableObject theOther) -> Standard_Boolean

        Returns true if pointer to selectable object of this owner is equal to the given one

        :type theOther: OCC.wrapper.SelectMgr.Handle_SelectMgr_SelectableObject
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _SelectMgr.SelectMgr_EntityOwner_IsSameSelectable(self, *args)


    def ComesFromDecomposition(self, *args):
        """
        ComesFromDecomposition(SelectMgr_EntityOwner self) -> Standard_Boolean

        Returns TRUE if this owner points to a part of object and FALSE for entire object.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _SelectMgr.SelectMgr_EntityOwner_ComesFromDecomposition(self, *args)


    def SetComesFromDecomposition(self, *args):
        """
        SetComesFromDecomposition(SelectMgr_EntityOwner self, Standard_Boolean const theIsFromDecomposition)

        Sets flag indicating this owner points to a part of object (TRUE) or to entire object (FALSE).

        :type theIsFromDecomposition: bool

        """
        return _SelectMgr.SelectMgr_EntityOwner_SetComesFromDecomposition(self, *args)


    def Set(self, *args):
        """
        Set(SelectMgr_EntityOwner self, Handle_SelectMgr_SelectableObject theSelObj)

        Sets the selectable object.

        :type theSelObj: OCC.wrapper.SelectMgr.Handle_SelectMgr_SelectableObject

        """
        return _SelectMgr.SelectMgr_EntityOwner_Set(self, *args)

    __swig_destroy__ = _SelectMgr.delete_SelectMgr_EntityOwner
SelectMgr_EntityOwner_swigregister = _SelectMgr.SelectMgr_EntityOwner_swigregister
SelectMgr_EntityOwner_swigregister(SelectMgr_EntityOwner)

def SelectMgr_EntityOwner_get_type_name(*args):
    """
    SelectMgr_EntityOwner_get_type_name() -> char const *

    :rtype: const char *

    """
    return _SelectMgr.SelectMgr_EntityOwner_get_type_name(*args)

def SelectMgr_EntityOwner_get_type_descriptor(*args):
    """
    SelectMgr_EntityOwner_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _SelectMgr.SelectMgr_EntityOwner_get_type_descriptor(*args)

class SelectMgr_AndFilter(SelectMgr_CompositionFilter):
    """
    A framework to define a selection filter for two or
    more types of entity.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_SelectMgr_AndFilter
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_SelectMgr_AndFilter(self) 
            return h


    def __init__(self, *args):
        """
        __init__(SelectMgr_AndFilter self) -> SelectMgr_AndFilter

        Constructs an empty selection filter object for two or
        more types of entity.


        """
        this = _SelectMgr.new_SelectMgr_AndFilter(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def IsOk(self, *args):
        """
        IsOk(SelectMgr_AndFilter self, Handle_SelectMgr_EntityOwner anobj) -> Standard_Boolean

        :type anobj: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _SelectMgr.SelectMgr_AndFilter_IsOk(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _SelectMgr.SelectMgr_AndFilter_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _SelectMgr.SelectMgr_AndFilter_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _SelectMgr.SelectMgr_AndFilter_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _SelectMgr.delete_SelectMgr_AndFilter
SelectMgr_AndFilter_swigregister = _SelectMgr.SelectMgr_AndFilter_swigregister
SelectMgr_AndFilter_swigregister(SelectMgr_AndFilter)

def SelectMgr_AndFilter_get_type_name(*args):
    """
    SelectMgr_AndFilter_get_type_name() -> char const *

    :rtype: const char *

    """
    return _SelectMgr.SelectMgr_AndFilter_get_type_name(*args)

def SelectMgr_AndFilter_get_type_descriptor(*args):
    """
    SelectMgr_AndFilter_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _SelectMgr.SelectMgr_AndFilter_get_type_descriptor(*args)

class SelectMgr_SelectionManager(Standard.Standard_Transient):
    """
    A framework to manage selection from the point of view of viewer selectors.
    These can be added and removed, and selection modes can be activated and deactivated.
    In addition, objects may be known to all selectors or only to some.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_SelectMgr_SelectionManager
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_SelectMgr_SelectionManager(self) 
            return h


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _SelectMgr.SelectMgr_SelectionManager_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _SelectMgr.SelectMgr_SelectionManager_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _SelectMgr.SelectMgr_SelectionManager_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __init__(self, *args):
        """
        __init__(SelectMgr_SelectionManager self) -> SelectMgr_SelectionManager

        Constructs an empty selection manager object.


        """
        this = _SelectMgr.new_SelectMgr_SelectionManager(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Add(self, *args):
        """
        Add(SelectMgr_SelectionManager self, Handle_SelectMgr_ViewerSelector theSelector)

        Adds the viewer selector theSelector to the list of known items.

        :type theSelector: OCC.wrapper.SelectMgr.Handle_SelectMgr_ViewerSelector

        """
        return _SelectMgr.SelectMgr_SelectionManager_Add(self, *args)


    def Contains(self, *args):
        """
        Contains(SelectMgr_SelectionManager self, Handle_SelectMgr_ViewerSelector theSelector) -> Standard_Boolean
        Contains(SelectMgr_SelectionManager self, Handle_SelectMgr_SelectableObject theObject) -> Standard_Boolean

        Returns true if the manager contains the selectable object theObject.

        :type theObject: OCC.wrapper.SelectMgr.Handle_SelectMgr_SelectableObject
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _SelectMgr.SelectMgr_SelectionManager_Contains(self, *args)


    def Load(self, *args):
        """
        Load(SelectMgr_SelectionManager self, Handle_SelectMgr_SelectableObject theObject, Standard_Integer const theMode=-1)
        Load(SelectMgr_SelectionManager self, Handle_SelectMgr_SelectableObject theObject, Handle_SelectMgr_ViewerSelector theSelector, Standard_Integer const theMode=-1)

        Loads and computes selection mode theMode (if it is not equal to -1) and adds selectable object to BVH tree.
        Does not perform check of existence of theObject in global context before addition, but adds theSelector to local context.

        :type theObject: OCC.wrapper.SelectMgr.Handle_SelectMgr_SelectableObject
        :type theSelector: OCC.wrapper.SelectMgr.Handle_SelectMgr_ViewerSelector
        :type theMode: int

        """
        return _SelectMgr.SelectMgr_SelectionManager_Load(self, *args)


    def Remove(self, *args):
        """
        Remove(SelectMgr_SelectionManager self, Handle_SelectMgr_ViewerSelector theSelector)
        Remove(SelectMgr_SelectionManager self, Handle_SelectMgr_SelectableObject theObject)
        Remove(SelectMgr_SelectionManager self, Handle_SelectMgr_SelectableObject theObject, Handle_SelectMgr_ViewerSelector theSelector)

        Removes theObject from theSelector, does not clear selections and unbind theObject from context maps.

        :type theObject: OCC.wrapper.SelectMgr.Handle_SelectMgr_SelectableObject
        :type theSelector: OCC.wrapper.SelectMgr.Handle_SelectMgr_ViewerSelector

        """
        return _SelectMgr.SelectMgr_SelectionManager_Remove(self, *args)


    def Activate(self, *args):
        """
        Activate(SelectMgr_SelectionManager self, Handle_SelectMgr_SelectableObject theObject, Standard_Integer const theMode=0, Handle_SelectMgr_ViewerSelector theSelector)

        Activates the selection mode theMode in the selector theSelector for the selectable object anObject.
        By default, theMode is equal to 0. If theSelector is set to default (NULL), the selection with the mode theMode
        will be activated in all the viewers available.

        :type theObject: OCC.wrapper.SelectMgr.Handle_SelectMgr_SelectableObject
        :type theMode: int
        :type theSelector: OCC.wrapper.SelectMgr.Handle_SelectMgr_ViewerSelector

        """
        return _SelectMgr.SelectMgr_SelectionManager_Activate(self, *args)


    def Deactivate(self, *args):
        """
        Deactivate(SelectMgr_SelectionManager self, Handle_SelectMgr_SelectableObject theObject, Standard_Integer const theMode=-1, Handle_SelectMgr_ViewerSelector theSelector)

        Deactivates mode theMode of theObject in theSelector. If theMode value is set to default (-1), all
        active selection modes will be deactivated. Likewise, if theSelector value is set to default (NULL), theMode
        will be deactivated in all viewer selectors.

        :type theObject: OCC.wrapper.SelectMgr.Handle_SelectMgr_SelectableObject
        :type theMode: int
        :type theSelector: OCC.wrapper.SelectMgr.Handle_SelectMgr_ViewerSelector

        """
        return _SelectMgr.SelectMgr_SelectionManager_Deactivate(self, *args)


    def IsActivated(self, *args):
        """
        IsActivated(SelectMgr_SelectionManager self, Handle_SelectMgr_SelectableObject theObject, Standard_Integer const theMode=-1, Handle_SelectMgr_ViewerSelector theSelector) -> Standard_Boolean

        Returns true if the selection with theMode is active for the selectable object theObject and selector theSelector.
        If all parameters are set to default values, it returns it there is any active selection in any known viewer selector for
        object theObject.

        :type theObject: OCC.wrapper.SelectMgr.Handle_SelectMgr_SelectableObject
        :type theMode: int
        :type theSelector: OCC.wrapper.SelectMgr.Handle_SelectMgr_ViewerSelector
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _SelectMgr.SelectMgr_SelectionManager_IsActivated(self, *args)


    def ClearSelectionStructures(self, *args):
        """
        ClearSelectionStructures(SelectMgr_SelectionManager self, Handle_SelectMgr_SelectableObject theObj, Standard_Integer const theMode=-1, Handle_SelectMgr_ViewerSelector theSelector)

        Removes sensitive entities from all viewer selectors
        after method Clear() was called to the selection they belonged to
        or it was recomputed somehow.

        :type theObj: OCC.wrapper.SelectMgr.Handle_SelectMgr_SelectableObject
        :type theMode: int
        :type theSelector: OCC.wrapper.SelectMgr.Handle_SelectMgr_ViewerSelector

        """
        return _SelectMgr.SelectMgr_SelectionManager_ClearSelectionStructures(self, *args)


    def RestoreSelectionStructures(self, *args):
        """
        RestoreSelectionStructures(SelectMgr_SelectionManager self, Handle_SelectMgr_SelectableObject theObj, Standard_Integer const theMode=-1, Handle_SelectMgr_ViewerSelector theSelector)

        Re-adds newly calculated sensitive  entities of recomputed selection
        defined by mode theMode to all viewer selectors contained that selection.

        :type theObj: OCC.wrapper.SelectMgr.Handle_SelectMgr_SelectableObject
        :type theMode: int
        :type theSelector: OCC.wrapper.SelectMgr.Handle_SelectMgr_ViewerSelector

        """
        return _SelectMgr.SelectMgr_SelectionManager_RestoreSelectionStructures(self, *args)


    def RecomputeSelection(self, *args):
        """
        RecomputeSelection(SelectMgr_SelectionManager self, Handle_SelectMgr_SelectableObject theObject, Standard_Boolean const theIsForce, Standard_Integer const theMode=-1)

        Recomputes activated selections of theObject for all known viewer selectors according to theMode specified.
        If theMode is set to default (-1), then all activated selections will be recomputed. If theIsForce is set to true,
        then selection mode theMode for object theObject will be recomputed regardless of its activation status.

        :type theObject: OCC.wrapper.SelectMgr.Handle_SelectMgr_SelectableObject
        :type theIsForce: bool
        :type theMode: int

        """
        return _SelectMgr.SelectMgr_SelectionManager_RecomputeSelection(self, *args)


    def Update(self, *args):
        """
        Update(SelectMgr_SelectionManager self, Handle_SelectMgr_SelectableObject theObject, Standard_Boolean const theIsForce)
        Update(SelectMgr_SelectionManager self, Handle_SelectMgr_SelectableObject theObject, Handle_SelectMgr_ViewerSelector theSelector, Standard_Boolean const theIsForce)

        Updates all selections of theObject in specified viewer selector according to its current update status.
        If theIsForce is set to true, the call is equal to recomputation.

        :type theObject: OCC.wrapper.SelectMgr.Handle_SelectMgr_SelectableObject
        :type theSelector: OCC.wrapper.SelectMgr.Handle_SelectMgr_ViewerSelector
        :type theIsForce: bool

        """
        return _SelectMgr.SelectMgr_SelectionManager_Update(self, *args)


    def SetUpdateMode(self, *args):
        """
        SetUpdateMode(SelectMgr_SelectionManager self, Handle_SelectMgr_SelectableObject theObject, SelectMgr_TypeOfUpdate const theType)
        SetUpdateMode(SelectMgr_SelectionManager self, Handle_SelectMgr_SelectableObject theObject, Standard_Integer const theMode, SelectMgr_TypeOfUpdate const theType)

        Sets type of update of selection with theMode of theObject to the given theType.

        :type theObject: OCC.wrapper.SelectMgr.Handle_SelectMgr_SelectableObject
        :type theMode: int
        :type theType: OCC.wrapper.SelectMgr.SelectMgr_TypeOfUpdate

        """
        return _SelectMgr.SelectMgr_SelectionManager_SetUpdateMode(self, *args)


    def SetSelectionSensitivity(self, *args):
        """
        SetSelectionSensitivity(SelectMgr_SelectionManager self, Handle_SelectMgr_SelectableObject theObject, Standard_Integer const theMode, Standard_Integer const theNewSens)

        Allows to manage sensitivity of a particular selection of interactive object theObject and
        changes previous sensitivity value of all sensitive entities in selection with theMode
        to the given theNewSensitivity.

        :type theObject: OCC.wrapper.SelectMgr.Handle_SelectMgr_SelectableObject
        :type theMode: int
        :type theNewSens: int

        """
        return _SelectMgr.SelectMgr_SelectionManager_SetSelectionSensitivity(self, *args)


    def UpdateSelection(self, *args):
        """
        UpdateSelection(SelectMgr_SelectionManager self, Handle_SelectMgr_SelectableObject theObj)

        Re-adds selectable object in BVHs in all viewer selectors.

        :type theObj: OCC.wrapper.SelectMgr.Handle_SelectMgr_SelectableObject

        """
        return _SelectMgr.SelectMgr_SelectionManager_UpdateSelection(self, *args)

    __swig_destroy__ = _SelectMgr.delete_SelectMgr_SelectionManager
SelectMgr_SelectionManager_swigregister = _SelectMgr.SelectMgr_SelectionManager_swigregister
SelectMgr_SelectionManager_swigregister(SelectMgr_SelectionManager)

def SelectMgr_SelectionManager_get_type_name(*args):
    """
    SelectMgr_SelectionManager_get_type_name() -> char const *

    :rtype: const char *

    """
    return _SelectMgr.SelectMgr_SelectionManager_get_type_name(*args)

def SelectMgr_SelectionManager_get_type_descriptor(*args):
    """
    SelectMgr_SelectionManager_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _SelectMgr.SelectMgr_SelectionManager_get_type_descriptor(*args)

class SelectMgr_OrFilter(SelectMgr_CompositionFilter):
    """
    A framework to define an or selection filter.
    This selects one or another type of sensitive entity.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_SelectMgr_OrFilter
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_SelectMgr_OrFilter(self) 
            return h


    def __init__(self, *args):
        """
        __init__(SelectMgr_OrFilter self) -> SelectMgr_OrFilter

        Constructs an empty or selection filter.


        """
        this = _SelectMgr.new_SelectMgr_OrFilter(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def IsOk(self, *args):
        """
        IsOk(SelectMgr_OrFilter self, Handle_SelectMgr_EntityOwner anobj) -> Standard_Boolean

        :type anobj: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _SelectMgr.SelectMgr_OrFilter_IsOk(self, *args)


    def SetDisabledObjects(self, *args):
        """
        SetDisabledObjects(SelectMgr_OrFilter self, Handle_Graphic3d_NMapOfTransient theObjects)

        Disable selection of specified objects.

        :type theObjects: OCC.wrapper.SelectMgr.Handle_Graphic3d_NMapOfTransient

        """
        return _SelectMgr.SelectMgr_OrFilter_SetDisabledObjects(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _SelectMgr.SelectMgr_OrFilter_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _SelectMgr.SelectMgr_OrFilter_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _SelectMgr.SelectMgr_OrFilter_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _SelectMgr.delete_SelectMgr_OrFilter
SelectMgr_OrFilter_swigregister = _SelectMgr.SelectMgr_OrFilter_swigregister
SelectMgr_OrFilter_swigregister(SelectMgr_OrFilter)

def SelectMgr_OrFilter_get_type_name(*args):
    """
    SelectMgr_OrFilter_get_type_name() -> char const *

    :rtype: const char *

    """
    return _SelectMgr.SelectMgr_OrFilter_get_type_name(*args)

def SelectMgr_OrFilter_get_type_descriptor(*args):
    """
    SelectMgr_OrFilter_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _SelectMgr.SelectMgr_OrFilter_get_type_descriptor(*args)

class SelectMgr_SensitiveEntity(Standard.Standard_Transient):
    """
    The purpose of this class is to mark sensitive entities selectable or not
    depending on current active selection of parent object for proper BVH traverse
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_SelectMgr_SensitiveEntity
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_SelectMgr_SensitiveEntity(self) 
            return h


    def __init__(self, *args):
        """
        __init__(SelectMgr_SensitiveEntity self, Handle_SelectBasics_SensitiveEntity theEntity) -> SelectMgr_SensitiveEntity

        Creates new inactive for selection object with base entity theEntity

        :type theEntity: OCC.wrapper.SelectBasics.Handle_SelectBasics_SensitiveEntity

        """
        this = _SelectMgr.new_SelectMgr_SensitiveEntity(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Clear(self, *args):
        """
        Clear(SelectMgr_SensitiveEntity self)

        Clears up all resources and memory


        """
        return _SelectMgr.SelectMgr_SensitiveEntity_Clear(self, *args)


    def BaseSensitive(self, *args):
        """
        Returns related instance of SelectBasics class

        :rtype: OCC.wrapper.SelectBasics.Handle_SelectBasics_SensitiveEntity

        """
        res = _SelectMgr.SelectMgr_SensitiveEntity_BaseSensitive(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def IsActiveForSelection(self, *args):
        """
        IsActiveForSelection(SelectMgr_SensitiveEntity self) -> Standard_Boolean

        Returns true if this entity belongs to the active selection
        mode of parent object

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _SelectMgr.SelectMgr_SensitiveEntity_IsActiveForSelection(self, *args)


    def ResetSelectionActiveStatus(self, *args):
        """
        ResetSelectionActiveStatus(SelectMgr_SensitiveEntity self)

        Marks entity as inactive for selection


        """
        return _SelectMgr.SelectMgr_SensitiveEntity_ResetSelectionActiveStatus(self, *args)


    def SetActiveForSelection(self, *args):
        """
        SetActiveForSelection(SelectMgr_SensitiveEntity self)

        Marks entity as active for selection


        """
        return _SelectMgr.SelectMgr_SensitiveEntity_SetActiveForSelection(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _SelectMgr.SelectMgr_SensitiveEntity_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _SelectMgr.SelectMgr_SensitiveEntity_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _SelectMgr.SelectMgr_SensitiveEntity_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _SelectMgr.delete_SelectMgr_SensitiveEntity
SelectMgr_SensitiveEntity_swigregister = _SelectMgr.SelectMgr_SensitiveEntity_swigregister
SelectMgr_SensitiveEntity_swigregister(SelectMgr_SensitiveEntity)

def SelectMgr_SensitiveEntity_get_type_name(*args):
    """
    SelectMgr_SensitiveEntity_get_type_name() -> char const *

    :rtype: const char *

    """
    return _SelectMgr.SelectMgr_SensitiveEntity_get_type_name(*args)

def SelectMgr_SensitiveEntity_get_type_descriptor(*args):
    """
    SelectMgr_SensitiveEntity_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _SelectMgr.SelectMgr_SensitiveEntity_get_type_descriptor(*args)


try:
	Select3D_BVHBuilder3d = BVH_Builder_Standard_Real_
except NameError:
	pass # does not exist, probably ignored

class NCollection_Sequence_Handle_SelectMgr_Selection(NCollection.NCollection_BaseSequence):
    """
    Purpose:     Definition of a sequence of elements indexed by
    an Integer in range of 1..n
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Sequence_Handle_SelectMgr_Selection self) -> NCollection_Sequence< opencascade::handle< SelectMgr_Selection > >::iterator

        Returns an iterator pointing to the first element in the sequence.

        :rtype: iterator

        """
        return _SelectMgr.NCollection_Sequence_Handle_SelectMgr_Selection_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Sequence_Handle_SelectMgr_Selection self) -> NCollection_Sequence< opencascade::handle< SelectMgr_Selection > >::iterator

        Returns an iterator referring to the past-the-end element in the sequence.

        :rtype: iterator

        """
        return _SelectMgr.NCollection_Sequence_Handle_SelectMgr_Selection_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Sequence_Handle_SelectMgr_Selection self) -> NCollection_Sequence< opencascade::handle< SelectMgr_Selection > >::const_iterator

        Returns a const iterator pointing to the first element in the sequence.

        :rtype: const_iterator

        """
        return _SelectMgr.NCollection_Sequence_Handle_SelectMgr_Selection_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Sequence_Handle_SelectMgr_Selection self) -> NCollection_Sequence< opencascade::handle< SelectMgr_Selection > >::const_iterator

        Returns a const iterator referring to the past-the-end element in the sequence.

        :rtype: const_iterator

        """
        return _SelectMgr.NCollection_Sequence_Handle_SelectMgr_Selection_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     Definition of a sequence of elements indexed by
        an Integer in range of 1..n
        """
        this = _SelectMgr.new_NCollection_Sequence_Handle_SelectMgr_Selection(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Size(self, *args):
        """
        Size(NCollection_Sequence_Handle_SelectMgr_Selection self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _SelectMgr.NCollection_Sequence_Handle_SelectMgr_Selection_Size(self, *args)


    def Length(self, *args):
        """
        Length(NCollection_Sequence_Handle_SelectMgr_Selection self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _SelectMgr.NCollection_Sequence_Handle_SelectMgr_Selection_Length(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Sequence_Handle_SelectMgr_Selection self) -> Standard_Integer

        Method for consistency with other collections.
        @return Lower bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _SelectMgr.NCollection_Sequence_Handle_SelectMgr_Selection_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Sequence_Handle_SelectMgr_Selection self) -> Standard_Integer

        Method for consistency with other collections.
        @return Upper bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _SelectMgr.NCollection_Sequence_Handle_SelectMgr_Selection_Upper(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Sequence_Handle_SelectMgr_Selection self) -> Standard_Boolean

        Empty query

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _SelectMgr.NCollection_Sequence_Handle_SelectMgr_Selection_IsEmpty(self, *args)


    def Reverse(self, *args):
        """
        Reverse(NCollection_Sequence_Handle_SelectMgr_Selection self)

        Reverse sequence


        """
        return _SelectMgr.NCollection_Sequence_Handle_SelectMgr_Selection_Reverse(self, *args)


    def Exchange(self, *args):
        """
        Exchange(NCollection_Sequence_Handle_SelectMgr_Selection self, Standard_Integer const I, Standard_Integer const J)

        Exchange two members

        :type I: int
        :type J: int

        """
        return _SelectMgr.NCollection_Sequence_Handle_SelectMgr_Selection_Exchange(self, *args)


    def delNode(*args):
        """
        delNode(NCollection_SeqNode theNode, Handle_NCollection_BaseAllocator theAl)

        Static deleter to be passed to BaseSequence

        :type theNode: OCC.wrapper.NCollection.NCollection_SeqNode
        :type theAl: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _SelectMgr.NCollection_Sequence_Handle_SelectMgr_Selection_delNode(*args)

    delNode = staticmethod(delNode)

    def Clear(self, *args):
        """
        Clear(NCollection_Sequence_Handle_SelectMgr_Selection self, Handle_NCollection_BaseAllocator theAllocator=0)

        Clear the items out, take a new allocator if non null

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _SelectMgr.NCollection_Sequence_Handle_SelectMgr_Selection_Clear(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Sequence_Handle_SelectMgr_Selection self, NCollection_Sequence_Handle_SelectMgr_Selection theOther) -> NCollection_Sequence_Handle_SelectMgr_Selection

        Replace this sequence by the items of theOther.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_Sequence
        :rtype: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _SelectMgr.NCollection_Sequence_Handle_SelectMgr_Selection_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Sequence_Handle_SelectMgr_Selection self, NCollection_Sequence_Handle_SelectMgr_Selection theOther) -> NCollection_Sequence_Handle_SelectMgr_Selection

        Replacement operator

        :type theOther: OCC.wrapper.NCollection.NCollection_Sequence
        :rtype: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _SelectMgr.NCollection_Sequence_Handle_SelectMgr_Selection_assign(self, *args)


    def Remove(self, *args):
        """
        Remove(NCollection_Sequence_Handle_SelectMgr_Selection self, NCollection_Sequence< opencascade::handle< SelectMgr_Selection > >::Iterator & thePosition)
        Remove(NCollection_Sequence_Handle_SelectMgr_Selection self, Standard_Integer const theIndex)
        Remove(NCollection_Sequence_Handle_SelectMgr_Selection self, Standard_Integer const theFromIndex, Standard_Integer const theToIndex)

        Remove range of items

        :type theFromIndex: int
        :type theToIndex: int

        """
        return _SelectMgr.NCollection_Sequence_Handle_SelectMgr_Selection_Remove(self, *args)


    def Append(self, *args):
        """
        Append(NCollection_Sequence_Handle_SelectMgr_Selection self, Handle_SelectMgr_Selection theItem)
        Append(NCollection_Sequence_Handle_SelectMgr_Selection self, NCollection_Sequence_Handle_SelectMgr_Selection theSeq)

        Append another sequence (making it empty)

        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _SelectMgr.NCollection_Sequence_Handle_SelectMgr_Selection_Append(self, *args)


    def Prepend(self, *args):
        """
        Prepend(NCollection_Sequence_Handle_SelectMgr_Selection self, Handle_SelectMgr_Selection theItem)
        Prepend(NCollection_Sequence_Handle_SelectMgr_Selection self, NCollection_Sequence_Handle_SelectMgr_Selection theSeq)

        Prepend another sequence (making it empty)

        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _SelectMgr.NCollection_Sequence_Handle_SelectMgr_Selection_Prepend(self, *args)


    def InsertBefore(self, *args):
        """
        InsertBefore(NCollection_Sequence_Handle_SelectMgr_Selection self, Standard_Integer const theIndex, Handle_SelectMgr_Selection theItem)
        InsertBefore(NCollection_Sequence_Handle_SelectMgr_Selection self, Standard_Integer const theIndex, NCollection_Sequence_Handle_SelectMgr_Selection theSeq)

        InsertBefore theIndex another sequence

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _SelectMgr.NCollection_Sequence_Handle_SelectMgr_Selection_InsertBefore(self, *args)


    def InsertAfter(self, *args):
        """
        InsertAfter(NCollection_Sequence_Handle_SelectMgr_Selection self, NCollection_Sequence< opencascade::handle< SelectMgr_Selection > >::Iterator & thePosition, Handle_SelectMgr_Selection theItem)
        InsertAfter(NCollection_Sequence_Handle_SelectMgr_Selection self, Standard_Integer const theIndex, NCollection_Sequence_Handle_SelectMgr_Selection theSeq)
        InsertAfter(NCollection_Sequence_Handle_SelectMgr_Selection self, Standard_Integer const theIndex, Handle_SelectMgr_Selection theItem)

        InsertAfter theIndex another sequence

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _SelectMgr.NCollection_Sequence_Handle_SelectMgr_Selection_InsertAfter(self, *args)


    def Split(self, *args):
        """
        Split(NCollection_Sequence_Handle_SelectMgr_Selection self, Standard_Integer const theIndex, NCollection_Sequence_Handle_SelectMgr_Selection theSeq)

        Split in two sequences

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _SelectMgr.NCollection_Sequence_Handle_SelectMgr_Selection_Split(self, *args)


    def First(self, *args):
        """
        First item access

        :rtype: const TheItemType &

        """
        res = _SelectMgr.NCollection_Sequence_Handle_SelectMgr_Selection_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Sequence_Handle_SelectMgr_Selection self) -> Handle_SelectMgr_Selection

        First item access

        :rtype: TheItemType &

        """
        return _SelectMgr.NCollection_Sequence_Handle_SelectMgr_Selection_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        Last item access

        :rtype: const TheItemType &

        """
        res = _SelectMgr.NCollection_Sequence_Handle_SelectMgr_Selection_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Sequence_Handle_SelectMgr_Selection self) -> Handle_SelectMgr_Selection

        Last item access

        :rtype: TheItemType &

        """
        return _SelectMgr.NCollection_Sequence_Handle_SelectMgr_Selection_ChangeLast(self, *args)


    def Value(self, *args):
        """
        Constant item access by theIndex

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _SelectMgr.NCollection_Sequence_Handle_SelectMgr_Selection_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Sequence_Handle_SelectMgr_Selection self, Standard_Integer const theIndex) -> Handle_SelectMgr_Selection

        Variable item access by theIndex

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _SelectMgr.NCollection_Sequence_Handle_SelectMgr_Selection_ChangeValue(self, *args)


    def __call__(self, *args):
        """
        Constant operator()

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _SelectMgr.NCollection_Sequence_Handle_SelectMgr_Selection___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetValue(self, *args):
        """
        SetValue(NCollection_Sequence_Handle_SelectMgr_Selection self, Standard_Integer const theIndex, Handle_SelectMgr_Selection theItem)

        Set item value by theIndex

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _SelectMgr.NCollection_Sequence_Handle_SelectMgr_Selection_SetValue(self, *args)


    def __iter__(self):
        return _SelectMgr.NCollection_Sequence_Handle_SelectMgr_Selection___iter__(self)
    __swig_destroy__ = _SelectMgr.delete_NCollection_Sequence_Handle_SelectMgr_Selection
NCollection_Sequence_Handle_SelectMgr_Selection_swigregister = _SelectMgr.NCollection_Sequence_Handle_SelectMgr_Selection_swigregister
NCollection_Sequence_Handle_SelectMgr_Selection_swigregister(NCollection_Sequence_Handle_SelectMgr_Selection)

def NCollection_Sequence_Handle_SelectMgr_Selection_delNode(*args):
    """
    NCollection_Sequence_Handle_SelectMgr_Selection_delNode(NCollection_SeqNode theNode, Handle_NCollection_BaseAllocator theAl)

    Static deleter to be passed to BaseSequence

    :type theNode: OCC.wrapper.NCollection.NCollection_SeqNode
    :type theAl: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

    """
    return _SelectMgr.NCollection_Sequence_Handle_SelectMgr_Selection_delNode(*args)

class NCollection_Sequence_Handle_SelectMgr_Selection_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _SelectMgr.new_NCollection_Sequence_Handle_SelectMgr_Selection_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SelectMgr.delete_NCollection_Sequence_Handle_SelectMgr_Selection_IteratorHelper

    def __next__(self):
        return _SelectMgr.NCollection_Sequence_Handle_SelectMgr_Selection_IteratorHelper___next__(self)
NCollection_Sequence_Handle_SelectMgr_Selection_IteratorHelper_swigregister = _SelectMgr.NCollection_Sequence_Handle_SelectMgr_Selection_IteratorHelper_swigregister
NCollection_Sequence_Handle_SelectMgr_Selection_IteratorHelper_swigregister(NCollection_Sequence_Handle_SelectMgr_Selection_IteratorHelper)


try:
	SelectMgr_SequenceOfSelection = NCollection_Sequence_Handle_SelectMgr_Selection
except NameError:
	pass # does not exist, probably ignored

class Handle_SelectMgr_Selection(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_SelectMgr_Selection self)

        Nullify the handle


        """
        return _SelectMgr.Handle_SelectMgr_Selection_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_SelectMgr_Selection self) -> bool

        Check for being null

        :rtype: bool

        """
        return _SelectMgr.Handle_SelectMgr_Selection_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_SelectMgr_Selection self, SelectMgr_Selection thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _SelectMgr.Handle_SelectMgr_Selection_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_SelectMgr_Selection self, Handle_SelectMgr_Selection theHandle) -> Handle_SelectMgr_Selection
        assign(Handle_SelectMgr_Selection self, SelectMgr_Selection thePtr) -> Handle_SelectMgr_Selection
        assign(Handle_SelectMgr_Selection self, Handle_SelectMgr_Selection theHandle) -> Handle_SelectMgr_Selection

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _SelectMgr.Handle_SelectMgr_Selection_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_SelectMgr_Selection self) -> SelectMgr_Selection

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _SelectMgr.Handle_SelectMgr_Selection_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_SelectMgr_Selection self) -> SelectMgr_Selection

        Member access operator (note non-const)

        :rtype: T *

        """
        return _SelectMgr.Handle_SelectMgr_Selection___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_SelectMgr_Selection self) -> SelectMgr_Selection

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _SelectMgr.Handle_SelectMgr_Selection___ref__(self, *args)


    def __hash__(self):
        return _SelectMgr.Handle_SelectMgr_Selection___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _SelectMgr.Handle_SelectMgr_Selection___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _SelectMgr.new_Handle_SelectMgr_Selection(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_SelectMgr.Handle_SelectMgr_Selection_DownCast)
    __swig_destroy__ = _SelectMgr.delete_Handle_SelectMgr_Selection

    def get_type_name(self, *args):
        """
        get_type_name(Handle_SelectMgr_Selection self) -> char const *

        :rtype: const char *

        """
        return _SelectMgr.Handle_SelectMgr_Selection_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _SelectMgr.Handle_SelectMgr_Selection_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _SelectMgr.Handle_SelectMgr_Selection_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Destroy(self, *args):
        """Destroy(Handle_SelectMgr_Selection self)"""
        return _SelectMgr.Handle_SelectMgr_Selection_Destroy(self, *args)


    def Add(self, *args):
        """
        Add(Handle_SelectMgr_Selection self, Handle_SelectBasics_SensitiveEntity theSensitive)

        Adds the sensitive primitive to the list of stored entities in this object.
        Raises NullObject if the primitive is a null handle.

        :type theSensitive: OCC.wrapper.SelectBasics.Handle_SelectBasics_SensitiveEntity

        """
        return _SelectMgr.Handle_SelectMgr_Selection_Add(self, *args)


    def Clear(self, *args):
        """
        Clear(Handle_SelectMgr_Selection self)

        empties the selection from all the stored entities


        """
        return _SelectMgr.Handle_SelectMgr_Selection_Clear(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(Handle_SelectMgr_Selection self) -> Standard_Boolean

        returns true if no sensitive entity is stored.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _SelectMgr.Handle_SelectMgr_Selection_IsEmpty(self, *args)


    def Mode(self, *args):
        """
        Mode(Handle_SelectMgr_Selection self) -> Standard_Integer

        returns the selection mode represented by this selection

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _SelectMgr.Handle_SelectMgr_Selection_Mode(self, *args)


    def Entities(self, *args):
        """
        Return entities.

        :rtype: OCC.wrapper.SelectMgr.NCollection_Vector_Handle_SelectMgr_SensitiveEntity

        """
        res = _SelectMgr.Handle_SelectMgr_Selection_Entities(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeEntities(self, *args):
        """
        ChangeEntities(Handle_SelectMgr_Selection self) -> NCollection_Vector_Handle_SelectMgr_SensitiveEntity

        Return entities.

        :rtype: OCC.wrapper.SelectMgr.NCollection_Vector_Handle_SelectMgr_SensitiveEntity

        """
        return _SelectMgr.Handle_SelectMgr_Selection_ChangeEntities(self, *args)


    def Init(self, *args):
        """
        Init(Handle_SelectMgr_Selection self)

        Begins an iteration scanning for sensitive primitives.


        """
        return _SelectMgr.Handle_SelectMgr_Selection_Init(self, *args)


    def More(self, *args):
        """
        More(Handle_SelectMgr_Selection self) -> Standard_Boolean

        Continues the iteration scanning for sensitive
        primitives with the mode defined in this framework.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _SelectMgr.Handle_SelectMgr_Selection_More(self, *args)


    def Next(self, *args):
        """
        Next(Handle_SelectMgr_Selection self)

        Returns the next sensitive primitive found in the
        iteration. This is a scan for entities with the mode
        defined in this framework.


        """
        return _SelectMgr.Handle_SelectMgr_Selection_Next(self, *args)


    def Sensitive(self, *args):
        """
        Returns any sensitive primitive in this framework.

        :rtype: OCC.wrapper.SelectMgr.Handle_SelectMgr_SensitiveEntity

        """
        res = _SelectMgr.Handle_SelectMgr_Selection_Sensitive(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def UpdateStatus(self, *args):
        """
        UpdateStatus(Handle_SelectMgr_Selection self) -> SelectMgr_TypeOfUpdate
        UpdateStatus(Handle_SelectMgr_Selection self, SelectMgr_TypeOfUpdate const theStatus)

        :type theStatus: OCC.wrapper.SelectMgr.SelectMgr_TypeOfUpdate

        """
        return _SelectMgr.Handle_SelectMgr_Selection_UpdateStatus(self, *args)


    def UpdateBVHStatus(self, *args):
        """
        UpdateBVHStatus(Handle_SelectMgr_Selection self, SelectMgr_TypeOfBVHUpdate const theStatus)

        :type theStatus: OCC.wrapper.SelectMgr.SelectMgr_TypeOfBVHUpdate

        """
        return _SelectMgr.Handle_SelectMgr_Selection_UpdateBVHStatus(self, *args)


    def BVHUpdateStatus(self, *args):
        """
        BVHUpdateStatus(Handle_SelectMgr_Selection self) -> SelectMgr_TypeOfBVHUpdate

        :rtype: OCC.wrapper.SelectMgr.SelectMgr_TypeOfBVHUpdate

        """
        return _SelectMgr.Handle_SelectMgr_Selection_BVHUpdateStatus(self, *args)


    def GetSelectionState(self, *args):
        """
        GetSelectionState(Handle_SelectMgr_Selection self) -> SelectMgr_StateOfSelection

        Returns status of selection

        :rtype: OCC.wrapper.SelectMgr.SelectMgr_StateOfSelection

        """
        return _SelectMgr.Handle_SelectMgr_Selection_GetSelectionState(self, *args)


    def SetSelectionState(self, *args):
        """
        SetSelectionState(Handle_SelectMgr_Selection self, SelectMgr_StateOfSelection const theState)

        Sets status of selection

        :type theState: OCC.wrapper.SelectMgr.SelectMgr_StateOfSelection

        """
        return _SelectMgr.Handle_SelectMgr_Selection_SetSelectionState(self, *args)


    def Sensitivity(self, *args):
        """
        Sensitivity(Handle_SelectMgr_Selection self) -> Standard_Integer

        Returns sensitivity of the selection

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _SelectMgr.Handle_SelectMgr_Selection_Sensitivity(self, *args)


    def SetSensitivity(self, *args):
        """
        SetSensitivity(Handle_SelectMgr_Selection self, Standard_Integer const theNewSens)

        Changes sensitivity of the selection and all its entities to the given value.
        IMPORTANT: This method does not update any outer selection structures, so for
        proper updates use SelectMgr_SelectionManager::SetSelectionSensitivity method.

        :type theNewSens: int

        """
        return _SelectMgr.Handle_SelectMgr_Selection_SetSensitivity(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_SelectMgr_Selection self)

        Memory deallocator for transient classes


        """
        return _SelectMgr.Handle_SelectMgr_Selection_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_SelectMgr_Selection self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_SelectMgr_Selection self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _SelectMgr.Handle_SelectMgr_Selection_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_SelectMgr_Selection self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_SelectMgr_Selection self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _SelectMgr.Handle_SelectMgr_Selection_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_SelectMgr_Selection self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _SelectMgr.Handle_SelectMgr_Selection_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_SelectMgr_Selection self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _SelectMgr.Handle_SelectMgr_Selection_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_SelectMgr_Selection self)

        Increments the reference counter of this object


        """
        return _SelectMgr.Handle_SelectMgr_Selection_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_SelectMgr_Selection self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _SelectMgr.Handle_SelectMgr_Selection_DecrementRefCounter(self, *args)

Handle_SelectMgr_Selection_swigregister = _SelectMgr.Handle_SelectMgr_Selection_swigregister
Handle_SelectMgr_Selection_swigregister(Handle_SelectMgr_Selection)

def Handle_SelectMgr_Selection_DownCast(thing):
    return _SelectMgr.Handle_SelectMgr_Selection_DownCast(thing)
Handle_SelectMgr_Selection_DownCast = _SelectMgr.Handle_SelectMgr_Selection_DownCast

class Handle_SelectMgr_BaseFrustum(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_SelectMgr_BaseFrustum self)

        Nullify the handle


        """
        return _SelectMgr.Handle_SelectMgr_BaseFrustum_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_SelectMgr_BaseFrustum self) -> bool

        Check for being null

        :rtype: bool

        """
        return _SelectMgr.Handle_SelectMgr_BaseFrustum_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_SelectMgr_BaseFrustum self, SelectMgr_BaseFrustum * thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _SelectMgr.Handle_SelectMgr_BaseFrustum_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_SelectMgr_BaseFrustum self, Handle_SelectMgr_BaseFrustum theHandle) -> Handle_SelectMgr_BaseFrustum
        assign(Handle_SelectMgr_BaseFrustum self, SelectMgr_BaseFrustum const * thePtr) -> Handle_SelectMgr_BaseFrustum
        assign(Handle_SelectMgr_BaseFrustum self, Handle_SelectMgr_BaseFrustum theHandle) -> Handle_SelectMgr_BaseFrustum

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _SelectMgr.Handle_SelectMgr_BaseFrustum_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_SelectMgr_BaseFrustum self) -> SelectMgr_BaseFrustum *

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _SelectMgr.Handle_SelectMgr_BaseFrustum_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_SelectMgr_BaseFrustum self) -> SelectMgr_BaseFrustum *

        Member access operator (note non-const)

        :rtype: T *

        """
        return _SelectMgr.Handle_SelectMgr_BaseFrustum___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_SelectMgr_BaseFrustum self) -> SelectMgr_BaseFrustum &

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _SelectMgr.Handle_SelectMgr_BaseFrustum___ref__(self, *args)


    def __hash__(self):
        return _SelectMgr.Handle_SelectMgr_BaseFrustum___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _SelectMgr.Handle_SelectMgr_BaseFrustum___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _SelectMgr.new_Handle_SelectMgr_BaseFrustum(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_SelectMgr.Handle_SelectMgr_BaseFrustum_DownCast)
    __swig_destroy__ = _SelectMgr.delete_Handle_SelectMgr_BaseFrustum

    def Camera(self, *args):
        """
        Return camera definition.

        :rtype: OCC.wrapper.Graphic3d.Handle_Graphic3d_Camera

        """
        res = _SelectMgr.Handle_SelectMgr_BaseFrustum_Camera(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetCamera(self, *args):
        """
        SetCamera(Handle_SelectMgr_BaseFrustum self, Handle_Graphic3d_Camera theCamera)
        SetCamera(Handle_SelectMgr_BaseFrustum self, NCollection_Mat4_Standard_Real theProjection, NCollection_Mat4_Standard_Real theWorldView, Standard_Boolean const theIsOrthographic, Graphic3d_WorldViewProjState theWVPState)

        Passes camera projection and orientation matrices to builder

        :type theProjection: OCC.wrapper.Graphic3d.Graphic3d_Mat4d
        :type theWorldView: OCC.wrapper.Graphic3d.Graphic3d_Mat4d
        :type theIsOrthographic: bool
        :type theWVPState: OCC.wrapper.Graphic3d.Graphic3d_WorldViewProjState

        """
        return _SelectMgr.Handle_SelectMgr_BaseFrustum_SetCamera(self, *args)


    def ProjectionMatrix(self, *args):
        """
        @return current camera projection transformation common for all selecting volumes

        :rtype: OCC.wrapper.Graphic3d.Graphic3d_Mat4d

        """
        res = _SelectMgr.Handle_SelectMgr_BaseFrustum_ProjectionMatrix(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def WorldViewMatrix(self, *args):
        """
        @return current camera world view transformation common for all selecting volumes

        :rtype: OCC.wrapper.Graphic3d.Graphic3d_Mat4d

        """
        res = _SelectMgr.Handle_SelectMgr_BaseFrustum_WorldViewMatrix(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def WorldViewProjState(self, *args):
        """
        @return current camera world view projection transformation state

        :rtype: OCC.wrapper.Graphic3d.Graphic3d_WorldViewProjState

        """
        res = _SelectMgr.Handle_SelectMgr_BaseFrustum_WorldViewProjState(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetPixelTolerance(self, *args):
        """
        SetPixelTolerance(Handle_SelectMgr_BaseFrustum self, Standard_Integer const theTol)

        :type theTol: int

        """
        return _SelectMgr.Handle_SelectMgr_BaseFrustum_SetPixelTolerance(self, *args)


    def SetWindowSize(self, *args):
        """
        SetWindowSize(Handle_SelectMgr_BaseFrustum self, Standard_Integer const theWidth, Standard_Integer const theHeight)

        :type theWidth: int
        :type theHeight: int

        """
        return _SelectMgr.Handle_SelectMgr_BaseFrustum_SetWindowSize(self, *args)


    def WindowSize(self, *args):
        """
        WindowSize(Handle_SelectMgr_BaseFrustum self)

        :type theWidth: int
        :type theHeight: int

        """
        return _SelectMgr.Handle_SelectMgr_BaseFrustum_WindowSize(self, *args)


    def SetViewport(self, *args):
        """
        SetViewport(Handle_SelectMgr_BaseFrustum self, Standard_Real const theX, Standard_Real const theY, Standard_Real const theWidth, Standard_Real const theHeight)

        Passes viewport parameters to builder

        :type theX: float
        :type theY: float
        :type theWidth: float
        :type theHeight: float

        """
        return _SelectMgr.Handle_SelectMgr_BaseFrustum_SetViewport(self, *args)


    def SetBuilder(self, *args):
        """
        SetBuilder(Handle_SelectMgr_BaseFrustum self, Handle_SelectMgr_FrustumBuilder theBuilder)

        Nullifies the builder created in the constructor and copies the pointer given

        :type theBuilder: OCC.wrapper.SelectMgr.Handle_SelectMgr_FrustumBuilder

        """
        return _SelectMgr.Handle_SelectMgr_BaseFrustum_SetBuilder(self, *args)


    def Build(self, *args):
        """
        Build(Handle_SelectMgr_BaseFrustum self, gp_Pnt2d arg2)
        Build(Handle_SelectMgr_BaseFrustum self, gp_Pnt2d arg2, gp_Pnt2d arg3)
        Build(Handle_SelectMgr_BaseFrustum self, gp_Pnt2d arg2, gp_Pnt2d arg3, gp_Pnt2d arg4)
        Build(Handle_SelectMgr_BaseFrustum self, NCollection_Array1_gp_Pnt2d arg2)

        Builds selecting volumes set according to polyline points

        :type : OCC.wrapper.TColgp.TColgp_Array1OfPnt2d

        """
        return _SelectMgr.Handle_SelectMgr_BaseFrustum_Build(self, *args)


    def ScaleAndTransform(self, *args):
        """
        ScaleAndTransform(Handle_SelectMgr_BaseFrustum self, Standard_Integer const arg2, gp_GTrsf arg3) -> Handle_SelectMgr_BaseFrustum

        IMPORTANT: Scaling makes sense only for frustum built on a single point!
        Note that this method does not perform any checks on type of the frustum.
        Returns a copy of the frustum resized according to the scale factor given
        and transforms it using the matrix given.
        There are no default parameters, but in case if:
        - transformation only is needed: @theScaleFactor must be initialized as any negative value;
        - scale only is needed: @theTrsf must be set to gp_Identity.

        :type : int
        :type : OCC.wrapper.gp.gp_GTrsf
        :rtype: OCC.wrapper.SelectMgr.Handle_SelectMgr_BaseFrustum

        """
        return _SelectMgr.Handle_SelectMgr_BaseFrustum_ScaleAndTransform(self, *args)


    def Overlaps(self, *args):
        """
        Overlaps(Handle_SelectMgr_BaseFrustum self, NCollection_Vec3_Standard_Real theBoxMin, NCollection_Vec3_Standard_Real theBoxMax) -> Standard_Boolean
        Overlaps(Handle_SelectMgr_BaseFrustum self, NCollection_Vec3_Standard_Real theBoxMin, NCollection_Vec3_Standard_Real theBoxMax, Standard_Boolean * theInside=None) -> Standard_Boolean
        Overlaps(Handle_SelectMgr_BaseFrustum self, gp_Pnt thePnt) -> Standard_Boolean
        Overlaps(Handle_SelectMgr_BaseFrustum self, gp_Pnt thePnt) -> Standard_Boolean
        Overlaps(Handle_SelectMgr_BaseFrustum self, NCollection_Array1_gp_Pnt theArrayOfPnts, Select3D_TypeOfSensitivity theSensType) -> Standard_Boolean
        Overlaps(Handle_SelectMgr_BaseFrustum self, gp_Pnt thePnt1, gp_Pnt thePnt2) -> Standard_Boolean
        Overlaps(Handle_SelectMgr_BaseFrustum self, gp_Pnt thePt1, gp_Pnt thePt2, gp_Pnt thePt3, Select3D_TypeOfSensitivity theSensType) -> Standard_Boolean

        SAT intersection test between defined volume and given triangle. The test may
        be considered of interior part or boundary line defined by triangle vertices
        depending on given sensitivity type

        :type thePt1: OCC.wrapper.gp.gp_Pnt
        :type thePt2: OCC.wrapper.gp.gp_Pnt
        :type thePt3: OCC.wrapper.gp.gp_Pnt
        :type theSensType: OCC.wrapper.Select3D.Select3D_TypeOfSensitivity
        :type theDepth: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _SelectMgr.Handle_SelectMgr_BaseFrustum_Overlaps(self, *args)


    def DistToGeometryCenter(self, *args):
        """
        DistToGeometryCenter(Handle_SelectMgr_BaseFrustum self, gp_Pnt theCOG) -> Standard_Real

        Measures distance between 3d projection of user-picked
        screen point and given point theCOG

        :type theCOG: OCC.wrapper.gp.gp_Pnt
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _SelectMgr.Handle_SelectMgr_BaseFrustum_DistToGeometryCenter(self, *args)


    def DetectedPoint(self, *args):
        """
        DetectedPoint(Handle_SelectMgr_BaseFrustum self, Standard_Real const theDepth) -> gp_Pnt

        :type theDepth: float
        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _SelectMgr.Handle_SelectMgr_BaseFrustum_DetectedPoint(self, *args)


    def IsClipped(self, *args):
        """
        IsClipped(Handle_SelectMgr_BaseFrustum self, Graphic3d_SequenceOfHClipPlane thePlanes, Standard_Real const theDepth) -> Standard_Boolean

        Checks if the point of sensitive in which selection was detected belongs
        to the region defined by clipping planes

        :type thePlanes: OCC.wrapper.Graphic3d.Graphic3d_SequenceOfHClipPlane
        :type theDepth: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _SelectMgr.Handle_SelectMgr_BaseFrustum_IsClipped(self, *args)


    def SetViewClipping(self, *args):
        """
        SetViewClipping(Handle_SelectMgr_BaseFrustum self, Handle_Graphic3d_SequenceOfHClipPlane arg2)

        Valid for point selection only!
        Computes depth range for global (defined for the whole view) clipping planes.

        :type : OCC.wrapper.Graphic3d.Handle_Graphic3d_SequenceOfHClipPlane

        """
        return _SelectMgr.Handle_SelectMgr_BaseFrustum_SetViewClipping(self, *args)


    def SetViewClippingEnabled(self, *args):
        """
        SetViewClippingEnabled(Handle_SelectMgr_BaseFrustum self, Standard_Boolean const arg2) -> Standard_Boolean

        Set if view clipping plane is enabled or not.
        @return previous value of the flag

        :type : bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _SelectMgr.Handle_SelectMgr_BaseFrustum_SetViewClippingEnabled(self, *args)


    def GetPlanes(self, *args):
        """
        GetPlanes(Handle_SelectMgr_BaseFrustum self, NCollection_Vector< SelectMgr_Vec4 > & thePlaneEquations)

        Stores plane equation coefficients (in the following form:
        Ax + By + Cz + D = 0) to the given vector

        :type thePlaneEquations: OCC.wrapper.SelectMgr.NCollection_Vector_SelectMgr_Vec4

        """
        return _SelectMgr.Handle_SelectMgr_BaseFrustum_GetPlanes(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_SelectMgr_BaseFrustum self) -> char const *

        :rtype: const char *

        """
        return _SelectMgr.Handle_SelectMgr_BaseFrustum_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _SelectMgr.Handle_SelectMgr_BaseFrustum_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _SelectMgr.Handle_SelectMgr_BaseFrustum_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_SelectMgr_BaseFrustum self)

        Memory deallocator for transient classes


        """
        return _SelectMgr.Handle_SelectMgr_BaseFrustum_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_SelectMgr_BaseFrustum self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_SelectMgr_BaseFrustum self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _SelectMgr.Handle_SelectMgr_BaseFrustum_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_SelectMgr_BaseFrustum self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_SelectMgr_BaseFrustum self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _SelectMgr.Handle_SelectMgr_BaseFrustum_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_SelectMgr_BaseFrustum self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _SelectMgr.Handle_SelectMgr_BaseFrustum_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_SelectMgr_BaseFrustum self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _SelectMgr.Handle_SelectMgr_BaseFrustum_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_SelectMgr_BaseFrustum self)

        Increments the reference counter of this object


        """
        return _SelectMgr.Handle_SelectMgr_BaseFrustum_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_SelectMgr_BaseFrustum self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _SelectMgr.Handle_SelectMgr_BaseFrustum_DecrementRefCounter(self, *args)

Handle_SelectMgr_BaseFrustum_swigregister = _SelectMgr.Handle_SelectMgr_BaseFrustum_swigregister
Handle_SelectMgr_BaseFrustum_swigregister(Handle_SelectMgr_BaseFrustum)

def Handle_SelectMgr_BaseFrustum_DownCast(thing):
    return _SelectMgr.Handle_SelectMgr_BaseFrustum_DownCast(thing)
Handle_SelectMgr_BaseFrustum_DownCast = _SelectMgr.Handle_SelectMgr_BaseFrustum_DownCast

class Handle_SelectMgr_SelectableObject(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_SelectMgr_SelectableObject self)

        Nullify the handle


        """
        return _SelectMgr.Handle_SelectMgr_SelectableObject_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_SelectMgr_SelectableObject self) -> bool

        Check for being null

        :rtype: bool

        """
        return _SelectMgr.Handle_SelectMgr_SelectableObject_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_SelectMgr_SelectableObject self, SelectMgr_SelectableObject thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _SelectMgr.Handle_SelectMgr_SelectableObject_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_SelectMgr_SelectableObject self, Handle_SelectMgr_SelectableObject theHandle) -> Handle_SelectMgr_SelectableObject
        assign(Handle_SelectMgr_SelectableObject self, SelectMgr_SelectableObject thePtr) -> Handle_SelectMgr_SelectableObject
        assign(Handle_SelectMgr_SelectableObject self, Handle_SelectMgr_SelectableObject theHandle) -> Handle_SelectMgr_SelectableObject

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _SelectMgr.Handle_SelectMgr_SelectableObject_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_SelectMgr_SelectableObject self) -> SelectMgr_SelectableObject

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _SelectMgr.Handle_SelectMgr_SelectableObject_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_SelectMgr_SelectableObject self) -> SelectMgr_SelectableObject

        Member access operator (note non-const)

        :rtype: T *

        """
        return _SelectMgr.Handle_SelectMgr_SelectableObject___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_SelectMgr_SelectableObject self) -> SelectMgr_SelectableObject

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _SelectMgr.Handle_SelectMgr_SelectableObject___ref__(self, *args)


    def __hash__(self):
        return _SelectMgr.Handle_SelectMgr_SelectableObject___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _SelectMgr.Handle_SelectMgr_SelectableObject___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _SelectMgr.new_Handle_SelectMgr_SelectableObject(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_SelectMgr.Handle_SelectMgr_SelectableObject_DownCast)
    __swig_destroy__ = _SelectMgr.delete_Handle_SelectMgr_SelectableObject

    def get_type_name(self, *args):
        """
        get_type_name(Handle_SelectMgr_SelectableObject self) -> char const *

        :rtype: const char *

        """
        return _SelectMgr.Handle_SelectMgr_SelectableObject_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _SelectMgr.Handle_SelectMgr_SelectableObject_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _SelectMgr.Handle_SelectMgr_SelectableObject_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def RecomputePrimitives(self, *args):
        """
        RecomputePrimitives(Handle_SelectMgr_SelectableObject self)
        RecomputePrimitives(Handle_SelectMgr_SelectableObject self, Standard_Integer const theMode)

        Re-computes the sensitive primitives which correspond to the <theMode>th selection mode.
        IMPORTANT: Do not use this method to update selection primitives except implementing custom selection manager!
        selection manager! This method does not take into account necessary BVH updates, but may invalidate
        the pointers it refers to. TO UPDATE SELECTION properly from outside classes, use method UpdateSelection.

        :type theMode: int

        """
        return _SelectMgr.Handle_SelectMgr_SelectableObject_RecomputePrimitives(self, *args)


    def AddSelection(self, *args):
        """
        AddSelection(Handle_SelectMgr_SelectableObject self, Handle_SelectMgr_Selection aSelection, Standard_Integer const aMode)

        Adds the selection aSelection with the selection mode
        index aMode to this framework.

        :type aSelection: OCC.wrapper.SelectMgr.Handle_SelectMgr_Selection
        :type aMode: int

        """
        return _SelectMgr.Handle_SelectMgr_SelectableObject_AddSelection(self, *args)


    def ClearSelections(self, *args):
        """
        ClearSelections(Handle_SelectMgr_SelectableObject self, Standard_Boolean const update)

        Empties all the selections in the SelectableObject
        <update> parameter defines whether all object's
        selections should be flagged for further update or not.
        This improved method can be used to recompute an
        object's selection (without redisplaying the object
        completely) when some selection mode is activated not for the first time.

        :type update: bool

        """
        return _SelectMgr.Handle_SelectMgr_SelectableObject_ClearSelections(self, *args)


    def Selection(self, *args):
        """
        Returns the selection having specified selection mode or NULL.

        :type theMode: int
        :rtype: OCC.wrapper.SelectMgr.Handle_SelectMgr_Selection

        """
        res = _SelectMgr.Handle_SelectMgr_SelectableObject_Selection(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def HasSelection(self, *args):
        """
        HasSelection(Handle_SelectMgr_SelectableObject self, Standard_Integer const theMode) -> Standard_Boolean

        Returns true if a selection corresponding to the selection mode theMode was computed for this object.

        :type theMode: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _SelectMgr.Handle_SelectMgr_SelectableObject_HasSelection(self, *args)


    def Selections(self, *args):
        """
        Return the sequence of selections.

        :rtype: OCC.wrapper.SelectMgr.SelectMgr_SequenceOfSelection

        """
        res = _SelectMgr.Handle_SelectMgr_SelectableObject_Selections(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Init(self, *args):
        """
        Init(Handle_SelectMgr_SelectableObject self)

        Begins the iteration scanning for sensitive primitives.


        """
        return _SelectMgr.Handle_SelectMgr_SelectableObject_Init(self, *args)


    def More(self, *args):
        """
        More(Handle_SelectMgr_SelectableObject self) -> Standard_Boolean

        Continues the iteration scanning for sensitive primitives.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _SelectMgr.Handle_SelectMgr_SelectableObject_More(self, *args)


    def Next(self, *args):
        """
        Next(Handle_SelectMgr_SelectableObject self)

        Continues the iteration scanning for sensitive primitives.


        """
        return _SelectMgr.Handle_SelectMgr_SelectableObject_Next(self, *args)


    def CurrentSelection(self, *args):
        """
        Returns the current selection in this framework.

        :rtype: OCC.wrapper.SelectMgr.Handle_SelectMgr_Selection

        """
        res = _SelectMgr.Handle_SelectMgr_SelectableObject_CurrentSelection(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ResetTransformation(self, *args):
        """
        ResetTransformation(Handle_SelectMgr_SelectableObject self)

        resets local transformation to identity.


        """
        return _SelectMgr.Handle_SelectMgr_SelectableObject_ResetTransformation(self, *args)


    def UpdateTransformation(self, *args):
        """
        UpdateTransformation(Handle_SelectMgr_SelectableObject self)

        Recomputes the location of the selection aSelection.


        """
        return _SelectMgr.Handle_SelectMgr_SelectableObject_UpdateTransformation(self, *args)


    def UpdateTransformations(self, *args):
        """
        UpdateTransformations(Handle_SelectMgr_SelectableObject self, Handle_SelectMgr_Selection aSelection)

        Updates locations in all sensitive entities from <aSelection>
        and in corresponding entity owners.

        :type aSelection: OCC.wrapper.SelectMgr.Handle_SelectMgr_Selection

        """
        return _SelectMgr.Handle_SelectMgr_SelectableObject_UpdateTransformations(self, *args)


    def HilightSelected(self, *args):
        """
        HilightSelected(Handle_SelectMgr_SelectableObject self, Handle_PrsMgr_PresentationManager PM, NCollection_Sequence_Handle_SelectMgr_EntityOwner Seq)

        Method which draws selected owners ( for fast presentation draw )

        :type PM: OCC.wrapper.SelectMgr.Handle_PrsMgr_PresentationManager3d
        :type Seq: OCC.wrapper.SelectMgr.SelectMgr_SequenceOfOwner

        """
        return _SelectMgr.Handle_SelectMgr_SelectableObject_HilightSelected(self, *args)


    def ClearSelected(self, *args):
        """
        ClearSelected(Handle_SelectMgr_SelectableObject self)

        Method which clear all selected owners belonging
        to this selectable object ( for fast presentation draw )


        """
        return _SelectMgr.Handle_SelectMgr_SelectableObject_ClearSelected(self, *args)


    def ClearDynamicHighlight(self, *args):
        """
        ClearDynamicHighlight(Handle_SelectMgr_SelectableObject self, Handle_PrsMgr_PresentationManager theMgr)

        Method that needs to be implemented when the object
        manages selection and dynamic highlighting on its own.
        Clears or invalidates dynamic highlight presentation.
        By default it clears immediate draw of given presentation
        manager.

        :type theMgr: OCC.wrapper.SelectMgr.Handle_PrsMgr_PresentationManager3d

        """
        return _SelectMgr.Handle_SelectMgr_SelectableObject_ClearDynamicHighlight(self, *args)


    def HilightOwnerWithColor(self, *args):
        """
        HilightOwnerWithColor(Handle_SelectMgr_SelectableObject self, Handle_PrsMgr_PresentationManager thePM, Handle_Prs3d_Drawer theStyle, Handle_SelectMgr_EntityOwner theOwner)

        Method which hilight an owner belonging to
        this selectable object  ( for fast presentation draw )

        :type thePM: OCC.wrapper.SelectMgr.Handle_PrsMgr_PresentationManager3d
        :type theStyle: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer
        :type theOwner: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner

        """
        return _SelectMgr.Handle_SelectMgr_SelectableObject_HilightOwnerWithColor(self, *args)


    def IsAutoHilight(self, *args):
        """
        IsAutoHilight(Handle_SelectMgr_SelectableObject self) -> Standard_Boolean

        If returns True, the old mechanism for highlighting
        selected objects is used (HilightSelected Method may be empty).
        If returns False, the HilightSelected method will be
        fully responsible for highlighting selected entity
        owners belonging to this selectable object.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _SelectMgr.Handle_SelectMgr_SelectableObject_IsAutoHilight(self, *args)


    def SetAutoHilight(self, *args):
        """
        SetAutoHilight(Handle_SelectMgr_SelectableObject self, Standard_Boolean const newAutoHilight)

        Set AutoHilight property to true or false
        Sets  up  Transform  Persistence Mode  for  this  object

        :type newAutoHilight: bool

        """
        return _SelectMgr.Handle_SelectMgr_SelectableObject_SetAutoHilight(self, *args)


    def GetHilightPresentation(self, *args):
        """
        GetHilightPresentation(Handle_SelectMgr_SelectableObject self, Handle_PrsMgr_PresentationManager TheMgr) -> Handle_Prs3d_Presentation

        :type TheMgr: OCC.wrapper.SelectMgr.Handle_PrsMgr_PresentationManager3d
        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation

        """
        return _SelectMgr.Handle_SelectMgr_SelectableObject_GetHilightPresentation(self, *args)


    def GetSelectPresentation(self, *args):
        """
        GetSelectPresentation(Handle_SelectMgr_SelectableObject self, Handle_PrsMgr_PresentationManager TheMgr) -> Handle_Prs3d_Presentation

        :type TheMgr: OCC.wrapper.SelectMgr.Handle_PrsMgr_PresentationManager3d
        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation

        """
        return _SelectMgr.Handle_SelectMgr_SelectableObject_GetSelectPresentation(self, *args)


    def ErasePresentations(self, *args):
        """
        ErasePresentations(Handle_SelectMgr_SelectableObject self, Standard_Boolean theToRemove)

        Removes presentations returned by GetHilightPresentation() and GetSelectPresentation().

        :type theToRemove: bool

        """
        return _SelectMgr.Handle_SelectMgr_SelectableObject_ErasePresentations(self, *args)


    def SetZLayer(self, *args):
        """
        SetZLayer(Handle_SelectMgr_SelectableObject self, Graphic3d_ZLayerId const theLayerId)

        Set Z layer ID and update all presentations of the selectable object.
        The layers mechanism allows drawing objects in higher layers in overlay of objects in lower layers.

        :type theLayerId: OCC.wrapper.Graphic3d.Graphic3d_ZLayerId

        """
        return _SelectMgr.Handle_SelectMgr_SelectableObject_SetZLayer(self, *args)


    def UpdateSelection(self, *args):
        """
        UpdateSelection(Handle_SelectMgr_SelectableObject self, Standard_Integer const theMode=-1)

        Sets update status FULL to selections of the object. Must be used as the only method of UpdateSelection
        from outer classes to prevent BVH structures from being outdated.

        :type theMode: int

        """
        return _SelectMgr.Handle_SelectMgr_SelectableObject_UpdateSelection(self, *args)


    def BoundingBox(self, *args):
        """
        BoundingBox(Handle_SelectMgr_SelectableObject self, Bnd_Box theBndBox)

        Returns bounding box of selectable object
        by storing its minimum and maximum 3d coordinates
        to output parameters

        :type theBndBox: OCC.wrapper.Bnd.Bnd_Box

        """
        return _SelectMgr.Handle_SelectMgr_SelectableObject_BoundingBox(self, *args)


    def SetAssemblyOwner(self, *args):
        """
        SetAssemblyOwner(Handle_SelectMgr_SelectableObject self, Handle_SelectMgr_EntityOwner theOwner, Standard_Integer const theMode=-1)

        Sets common entity owner for assembly sensitive object entities

        :type theOwner: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner
        :type theMode: int

        """
        return _SelectMgr.Handle_SelectMgr_SelectableObject_SetAssemblyOwner(self, *args)


    def BndBoxOfSelected(self, *args):
        """
        BndBoxOfSelected(Handle_SelectMgr_SelectableObject self, opencascade::handle< SelectMgr_IndexedMapOfOwner > const & theOwners) -> Bnd_Box

        Returns a bounding box of sensitive entities with the owners given
        if they are a part of activated selection

        :type theOwners: OCC.wrapper.SelectMgr.Handle_SelectMgr_IndexedMapOfOwner
        :rtype: OCC.wrapper.Bnd.Bnd_Box

        """
        return _SelectMgr.Handle_SelectMgr_SelectableObject_BndBoxOfSelected(self, *args)


    def GlobalSelectionMode(self, *args):
        """
        GlobalSelectionMode(Handle_SelectMgr_SelectableObject self) -> Standard_Integer

        Returns the mode for selection of object as a whole

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _SelectMgr.Handle_SelectMgr_SelectableObject_GlobalSelectionMode(self, *args)


    def GlobalSelOwner(self, *args):
        """
        GlobalSelOwner(Handle_SelectMgr_SelectableObject self) -> Handle_SelectMgr_EntityOwner

        Returns the owner of mode for selection of object as a whole

        :rtype: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner

        """
        return _SelectMgr.Handle_SelectMgr_SelectableObject_GlobalSelOwner(self, *args)


    def GetAssemblyOwner(self, *args):
        """
        Returns common entity owner if the object is an assembly

        :rtype: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner

        """
        res = _SelectMgr.Handle_SelectMgr_SelectableObject_GetAssemblyOwner(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Presentations(self, *args):
        """
        Presentations(Handle_SelectMgr_SelectableObject self) -> NCollection_Sequence_PrsMgr_ModedPresentation

        :rtype: OCC.wrapper.PrsMgr.PrsMgr_Presentations

        """
        return _SelectMgr.Handle_SelectMgr_SelectableObject_Presentations(self, *args)


    def TypeOfPresentation3d(self, *args):
        """
        TypeOfPresentation3d(Handle_SelectMgr_SelectableObject self) -> PrsMgr_TypeOfPresentation3d

        Returns information on whether the object accepts display in HLR mode or not.

        :rtype: OCC.wrapper.PrsMgr.PrsMgr_TypeOfPresentation3d

        """
        return _SelectMgr.Handle_SelectMgr_SelectableObject_TypeOfPresentation3d(self, *args)


    def TransformPersistence(self, *args):
        """
        Returns Transformation Persistence defining a special Local Coordinate system where this presentable object is located or NULL handle if not defined.
        Position of the object having Transformation Persistence is mutable and depends on camera position.
        The same applies to a bounding box of the object.
        @sa Graphic3d_TransformPers class description

        :rtype: OCC.wrapper.Graphic3d.Handle_Graphic3d_TransformPers

        """
        res = _SelectMgr.Handle_SelectMgr_SelectableObject_TransformPersistence(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetTransformPersistence(self, *args):
        """
        SetTransformPersistence(Handle_SelectMgr_SelectableObject self, Handle_Graphic3d_TransformPers theTrsfPers)
        SetTransformPersistence(Handle_SelectMgr_SelectableObject self, Graphic3d_TransModeFlags const theMode, gp_Pnt thePoint)

        Sets up Transform Persistence Mode for this object.
        This function used to lock in object position, rotation and / or zooming relative to camera position.
        Object will be drawn in the origin setted by thePoint parameter (except Graphic3d_TMF_TriedronPers flag
        - see description later). theMode should be:
        -   Graphic3d_TMF_None - no persistence attributes (reset);
        -   Graphic3d_TMF_ZoomPers - object doesn't resize;
        -   Graphic3d_TMF_RotatePers - object doesn't rotate;
        -   Graphic3d_TMF_ZoomRotatePers - object doesn't resize and rotate;
        -   Graphic3d_TMF_RotatePers - object doesn't rotate;
        -   Graphic3d_TMF_TriedronPers - object behaves like trihedron.
        If Graphic3d_TMF_TriedronPers or Graphic3d_TMF_2d persistence mode selected thePoint coordinates X and Y means:
        -   X = 0.0, Y = 0.0 - center of view window;
        -   X > 0.0, Y > 0.0 - right upper corner of view window;
        -   X > 0.0, Y < 0.0 - right lower corner of view window;
        -   X < 0.0, Y > 0.0 - left  upper corner of view window;
        -   X < 0.0, Y < 0.0 - left  lower corner of view window.
        And Z coordinate defines the gap from border of view window (except center position).

        :type theMode: OCC.wrapper.Graphic3d.Graphic3d_TransModeFlags
        :type thePoint: OCC.wrapper.gp.gp_Pnt

        """
        return _SelectMgr.Handle_SelectMgr_SelectableObject_SetTransformPersistence(self, *args)


    def GetTransformPersistenceMode(self, *args):
        """
        GetTransformPersistenceMode(Handle_SelectMgr_SelectableObject self) -> Graphic3d_TransModeFlags

        Gets  Transform  Persistence Mode  for  this  object

        :rtype: OCC.wrapper.Graphic3d.Graphic3d_TransModeFlags

        """
        return _SelectMgr.Handle_SelectMgr_SelectableObject_GetTransformPersistenceMode(self, *args)


    def GetTransformPersistencePoint(self, *args):
        """
        GetTransformPersistencePoint(Handle_SelectMgr_SelectableObject self) -> gp_Pnt

        Gets  point  of  transform  persistence for  this  object

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _SelectMgr.Handle_SelectMgr_SelectableObject_GetTransformPersistencePoint(self, *args)


    def SetTypeOfPresentation(self, *args):
        """
        SetTypeOfPresentation(Handle_SelectMgr_SelectableObject self, PrsMgr_TypeOfPresentation3d const aType)

        :type aType: OCC.wrapper.PrsMgr.PrsMgr_TypeOfPresentation3d

        """
        return _SelectMgr.Handle_SelectMgr_SelectableObject_SetTypeOfPresentation(self, *args)


    def SetToUpdate(self, *args):
        """
        SetToUpdate(Handle_SelectMgr_SelectableObject self, Standard_Integer const aMode)
        SetToUpdate(Handle_SelectMgr_SelectableObject self)

        flags all the Presentations to be Updated.


        """
        return _SelectMgr.Handle_SelectMgr_SelectableObject_SetToUpdate(self, *args)


    def ToBeUpdated(self, *args):
        """
        ToBeUpdated(Handle_SelectMgr_SelectableObject self, NCollection_List_Standard_Integer ListOfMode)

        gives the list of modes which are flagged "to be updated".

        :type ListOfMode: OCC.wrapper.TColStd.TColStd_ListOfInteger

        """
        return _SelectMgr.Handle_SelectMgr_SelectableObject_ToBeUpdated(self, *args)


    def LocalTransformationGeom(self, *args):
        """
        Return the local transformation.
        Note that the local transformation of the object having Transformation Persistence
        is applied within Local Coordinate system defined by this Persistence.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Transformation

        """
        res = _SelectMgr.Handle_SelectMgr_SelectableObject_LocalTransformationGeom(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetLocalTransformation(self, *args):
        """
        SetLocalTransformation(Handle_SelectMgr_SelectableObject self, gp_Trsf theTrsf)
        SetLocalTransformation(Handle_SelectMgr_SelectableObject self, Handle_Geom_Transformation theTrsf)

        Sets local transformation to theTransformation.
        Note that the local transformation of the object having Transformation Persistence
        is applied within Local Coordinate system defined by this Persistence.

        :type theTrsf: OCC.wrapper.Geom.Handle_Geom_Transformation

        """
        return _SelectMgr.Handle_SelectMgr_SelectableObject_SetLocalTransformation(self, *args)


    def HasTransformation(self, *args):
        """
        HasTransformation(Handle_SelectMgr_SelectableObject self) -> Standard_Boolean

        Returns true if object has a transformation that is different from the identity.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _SelectMgr.Handle_SelectMgr_SelectableObject_HasTransformation(self, *args)


    def TransformationGeom(self, *args):
        """
        Return the transformation taking into account transformation of parent object(s).
        Note that the local transformation of the object having Transformation Persistence
        is applied within Local Coordinate system defined by this Persistence.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Transformation

        """
        res = _SelectMgr.Handle_SelectMgr_SelectableObject_TransformationGeom(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def LocalTransformation(self, *args):
        """
        Return the local transformation.
        Note that the local transformation of the object having Transformation Persistence
        is applied within Local Coordinate system defined by this Persistence.

        :rtype: OCC.wrapper.gp.gp_Trsf

        """
        res = _SelectMgr.Handle_SelectMgr_SelectableObject_LocalTransformation(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Transformation(self, *args):
        """
        Return the transformation taking into account transformation of parent object(s).
        Note that the local transformation of the object having Transformation Persistence
        is applied within Local Coordinate system defined by this Persistence.

        :rtype: OCC.wrapper.gp.gp_Trsf

        """
        res = _SelectMgr.Handle_SelectMgr_SelectableObject_Transformation(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def InversedTransformation(self, *args):
        """
        :rtype: OCC.wrapper.gp.gp_GTrsf

        """
        res = _SelectMgr.Handle_SelectMgr_SelectableObject_InversedTransformation(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ZLayer(self, *args):
        """
        ZLayer(Handle_SelectMgr_SelectableObject self) -> Graphic3d_ZLayerId

        Get ID of Z layer.

        :rtype: OCC.wrapper.Graphic3d.Graphic3d_ZLayerId

        """
        return _SelectMgr.Handle_SelectMgr_SelectableObject_ZLayer(self, *args)


    def AddClipPlane(self, *args):
        """
        AddClipPlane(Handle_SelectMgr_SelectableObject self, Handle_Graphic3d_ClipPlane thePlane)

        Adds clip plane for graphical clipping for all display mode
        presentations. The composition of clip planes truncates the rendering
        space to convex volume. Please be aware that number of supported
        clip plane is limited. The planes which exceed the limit are ignored.
        Besides of this, some planes can be already set in view where the object
        is shown: the number of these planes should be substracted from limit
        to predict the maximum possible number of object clipping planes.
        @param thePlane [in] the clip plane to be appended to map of clip planes.

        :type thePlane: OCC.wrapper.Graphic3d.Handle_Graphic3d_ClipPlane

        """
        return _SelectMgr.Handle_SelectMgr_SelectableObject_AddClipPlane(self, *args)


    def RemoveClipPlane(self, *args):
        """
        RemoveClipPlane(Handle_SelectMgr_SelectableObject self, Handle_Graphic3d_ClipPlane thePlane)

        Removes previously added clip plane.
        @param thePlane [in] the clip plane to be removed from map of clip planes.

        :type thePlane: OCC.wrapper.Graphic3d.Handle_Graphic3d_ClipPlane

        """
        return _SelectMgr.Handle_SelectMgr_SelectableObject_RemoveClipPlane(self, *args)


    def SetClipPlanes(self, *args):
        """
        SetClipPlanes(Handle_SelectMgr_SelectableObject self, Handle_Graphic3d_SequenceOfHClipPlane thePlanes)
        SetClipPlanes(Handle_SelectMgr_SelectableObject self, Graphic3d_SequenceOfHClipPlane thePlanes)

        :type thePlanes: OCC.wrapper.Graphic3d.Graphic3d_SequenceOfHClipPlane

        """
        return _SelectMgr.Handle_SelectMgr_SelectableObject_SetClipPlanes(self, *args)


    def ClipPlanes(self, *args):
        """
        Get clip planes.
        @return set of previously added clip planes for all display mode presentations.

        :rtype: OCC.wrapper.Graphic3d.Handle_Graphic3d_SequenceOfHClipPlane

        """
        res = _SelectMgr.Handle_SelectMgr_SelectableObject_ClipPlanes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetMutable(self, *args):
        """
        SetMutable(Handle_SelectMgr_SelectableObject self, Standard_Boolean const theIsMutable)

        Sets if the object has mutable nature (content or location will be changed regularly).
        This method should be called before object displaying to take effect.

        :type theIsMutable: bool

        """
        return _SelectMgr.Handle_SelectMgr_SelectableObject_SetMutable(self, *args)


    def IsMutable(self, *args):
        """
        IsMutable(Handle_SelectMgr_SelectableObject self) -> Standard_Boolean

        Returns true if object has mutable nature (content or location are be changed regularly).
        Mutable object will be managed in different way than static onces (another optimizations).

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _SelectMgr.Handle_SelectMgr_SelectableObject_IsMutable(self, *args)


    def AddChild(self, *args):
        """
        AddChild(Handle_SelectMgr_SelectableObject self, Handle_PrsMgr_PresentableObject theObject)

        Makes theObject child of current object in scene hierarchy.

        :type theObject: OCC.wrapper.PrsMgr.Handle_PrsMgr_PresentableObject

        """
        return _SelectMgr.Handle_SelectMgr_SelectableObject_AddChild(self, *args)


    def RemoveChild(self, *args):
        """
        RemoveChild(Handle_SelectMgr_SelectableObject self, Handle_PrsMgr_PresentableObject theObject)

        Removes theObject from children of current object in scene hierarchy.

        :type theObject: OCC.wrapper.PrsMgr.Handle_PrsMgr_PresentableObject

        """
        return _SelectMgr.Handle_SelectMgr_SelectableObject_RemoveChild(self, *args)


    def Children(self, *args):
        """
        Returns children of the current object.

        :rtype: OCC.wrapper.PrsMgr.PrsMgr_ListOfPresentableObjects

        """
        res = _SelectMgr.Handle_SelectMgr_SelectableObject_Children(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def HasOwnPresentations(self, *args):
        """
        HasOwnPresentations(Handle_SelectMgr_SelectableObject self) -> Standard_Boolean

        Returns true if object should have own presentations.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _SelectMgr.Handle_SelectMgr_SelectableObject_HasOwnPresentations(self, *args)


    def Parent(self, *args):
        """
        Parent(Handle_SelectMgr_SelectableObject self) -> PrsMgr_PresentableObject

        Returns parent of current object in scene hierarchy.

        :rtype: OCC.wrapper.PrsMgr.PrsMgr_PresentableObjectPointer

        """
        return _SelectMgr.Handle_SelectMgr_SelectableObject_Parent(self, *args)


    def SetAttributes(self, *args):
        """
        SetAttributes(Handle_SelectMgr_SelectableObject self, Handle_Prs3d_Drawer theDrawer)

        Initializes the drawing tool theDrawer.

        :type theDrawer: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        return _SelectMgr.Handle_SelectMgr_SelectableObject_SetAttributes(self, *args)


    def Attributes(self, *args):
        """
        Returns the attributes settings.

        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        res = _SelectMgr.Handle_SelectMgr_SelectableObject_Attributes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def UnsetAttributes(self, *args):
        """
        UnsetAttributes(Handle_SelectMgr_SelectableObject self)

        Clears settings provided by the drawing tool theDrawer.


        """
        return _SelectMgr.Handle_SelectMgr_SelectableObject_UnsetAttributes(self, *args)


    def HilightAttributes(self, *args):
        """
        Returns the hilight attributes settings.
        When not NULL, overrides both Prs3d_TypeOfHighlight_LocalSelected and Prs3d_TypeOfHighlight_Selected defined within AIS_InteractiveContext.

        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        res = _SelectMgr.Handle_SelectMgr_SelectableObject_HilightAttributes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetHilightAttributes(self, *args):
        """
        SetHilightAttributes(Handle_SelectMgr_SelectableObject self, Handle_Prs3d_Drawer theDrawer)

        Initializes the hilight drawing tool theDrawer.

        :type theDrawer: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        return _SelectMgr.Handle_SelectMgr_SelectableObject_SetHilightAttributes(self, *args)


    def DynamicHilightAttributes(self, *args):
        """
        Returns the hilight attributes settings.
        When not NULL, overrides both Prs3d_TypeOfHighlight_LocalDynamic and Prs3d_TypeOfHighlight_Dynamic defined within AIS_InteractiveContext.

        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        res = _SelectMgr.Handle_SelectMgr_SelectableObject_DynamicHilightAttributes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetDynamicHilightAttributes(self, *args):
        """
        SetDynamicHilightAttributes(Handle_SelectMgr_SelectableObject self, Handle_Prs3d_Drawer theDrawer)

        Initializes the dynamic hilight drawing tool.

        :type theDrawer: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        return _SelectMgr.Handle_SelectMgr_SelectableObject_SetDynamicHilightAttributes(self, *args)


    def UnsetHilightAttributes(self, *args):
        """
        UnsetHilightAttributes(Handle_SelectMgr_SelectableObject self)

        Clears settings provided by the hilight drawing tool theDrawer.


        """
        return _SelectMgr.Handle_SelectMgr_SelectableObject_UnsetHilightAttributes(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_SelectMgr_SelectableObject self)

        Memory deallocator for transient classes


        """
        return _SelectMgr.Handle_SelectMgr_SelectableObject_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_SelectMgr_SelectableObject self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_SelectMgr_SelectableObject self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _SelectMgr.Handle_SelectMgr_SelectableObject_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_SelectMgr_SelectableObject self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_SelectMgr_SelectableObject self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _SelectMgr.Handle_SelectMgr_SelectableObject_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_SelectMgr_SelectableObject self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _SelectMgr.Handle_SelectMgr_SelectableObject_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_SelectMgr_SelectableObject self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _SelectMgr.Handle_SelectMgr_SelectableObject_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_SelectMgr_SelectableObject self)

        Increments the reference counter of this object


        """
        return _SelectMgr.Handle_SelectMgr_SelectableObject_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_SelectMgr_SelectableObject self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _SelectMgr.Handle_SelectMgr_SelectableObject_DecrementRefCounter(self, *args)

Handle_SelectMgr_SelectableObject_swigregister = _SelectMgr.Handle_SelectMgr_SelectableObject_swigregister
Handle_SelectMgr_SelectableObject_swigregister(Handle_SelectMgr_SelectableObject)

def Handle_SelectMgr_SelectableObject_DownCast(thing):
    return _SelectMgr.Handle_SelectMgr_SelectableObject_DownCast(thing)
Handle_SelectMgr_SelectableObject_DownCast = _SelectMgr.Handle_SelectMgr_SelectableObject_DownCast

class SelectMgr_SensitiveEntitySet(object):
    """
    This class is used to store all calculated sensitive entites of one selectable
    object. It provides an interface for building BVH tree which is used to speed-up
    the performance of searching for overlap among sensitives of one selectable object
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _SelectMgr.SelectMgr_SensitiveEntitySet_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _SelectMgr.SelectMgr_SensitiveEntitySet_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _SelectMgr.SelectMgr_SensitiveEntitySet_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __init__(self, *args):
        """
        __init__(SelectMgr_SensitiveEntitySet self, Handle_Select3D_BVHBuilder3d theBuilder) -> SelectMgr_SensitiveEntitySet

        Empty constructor.

        :type theBuilder: OCC.wrapper.SelectMgr.Handle_Select3D_BVHBuilder3d

        """
        this = _SelectMgr.new_SelectMgr_SensitiveEntitySet(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Append(self, *args):
        """
        Append(SelectMgr_SensitiveEntitySet self, Handle_SelectMgr_SensitiveEntity theEntity)
        Append(SelectMgr_SensitiveEntitySet self, Handle_SelectMgr_Selection theSelection)

        Adds every entity of selection theSelection to the set and marks
        BVH tree for rebuild

        :type theSelection: OCC.wrapper.SelectMgr.Handle_SelectMgr_Selection

        """
        return _SelectMgr.SelectMgr_SensitiveEntitySet_Append(self, *args)


    def Remove(self, *args):
        """
        Remove(SelectMgr_SensitiveEntitySet self, Handle_SelectMgr_Selection theSelection)

        Removes every entity of selection theSelection from the set
        and marks BVH tree for rebuild

        :type theSelection: OCC.wrapper.SelectMgr.Handle_SelectMgr_Selection

        """
        return _SelectMgr.SelectMgr_SensitiveEntitySet_Remove(self, *args)


    def Box(self, *args):
        """
        Box(SelectMgr_SensitiveEntitySet self, Standard_Integer const theIndex) -> BVH_Box_Standard_Real_

        Returns bounding box of entity with index theIdx

        :type theIndex: int
        :rtype: OCC.wrapper.Select3D.Select3D_BndBox3d

        """
        return _SelectMgr.SelectMgr_SensitiveEntitySet_Box(self, *args)


    def Center(self, *args):
        """
        Center(SelectMgr_SensitiveEntitySet self, Standard_Integer const theIndex, Standard_Integer const theAxis) -> Standard_Real

        Returns geometry center of sensitive entity index theIdx
        along the given axis theAxis

        :type theIndex: int
        :type theAxis: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _SelectMgr.SelectMgr_SensitiveEntitySet_Center(self, *args)


    def Swap(self, *args):
        """
        Swap(SelectMgr_SensitiveEntitySet self, Standard_Integer const theIndex1, Standard_Integer const theIndex2)

        Swaps items with indexes theIdx1 and theIdx2

        :type theIndex1: int
        :type theIndex2: int

        """
        return _SelectMgr.SelectMgr_SensitiveEntitySet_Swap(self, *args)


    def Size(self, *args):
        """
        Size(SelectMgr_SensitiveEntitySet self) -> Standard_Integer

        Returns the amount of entities

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _SelectMgr.SelectMgr_SensitiveEntitySet_Size(self, *args)


    def GetSensitiveById(self, *args):
        """
        Returns the entity with index theIndex in the set

        :type theIndex: int
        :rtype: OCC.wrapper.SelectMgr.Handle_SelectMgr_SensitiveEntity

        """
        res = _SelectMgr.SelectMgr_SensitiveEntitySet_GetSensitiveById(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Sensitives(self, *args):
        """
        Returns map of entities.

        :rtype: OCC.wrapper.SelectMgr.SelectMgr_IndexedMapOfHSensitive

        """
        res = _SelectMgr.SelectMgr_SensitiveEntitySet_Sensitives(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _SelectMgr.delete_SelectMgr_SensitiveEntitySet
SelectMgr_SensitiveEntitySet_swigregister = _SelectMgr.SelectMgr_SensitiveEntitySet_swigregister
SelectMgr_SensitiveEntitySet_swigregister(SelectMgr_SensitiveEntitySet)

def SelectMgr_SensitiveEntitySet_get_type_name(*args):
    """
    SelectMgr_SensitiveEntitySet_get_type_name() -> char const *

    :rtype: const char *

    """
    return _SelectMgr.SelectMgr_SensitiveEntitySet_get_type_name(*args)

def SelectMgr_SensitiveEntitySet_get_type_descriptor(*args):
    """
    SelectMgr_SensitiveEntitySet_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _SelectMgr.SelectMgr_SensitiveEntitySet_get_type_descriptor(*args)


try:
	SelectMgr_Mat4 = Graphic3d.NCollection_Mat4_Standard_Real
except AttributeError:
	pass # does not exist, probably ignored

class NCollection_Sequence_Handle_SelectMgr_Filter(NCollection.NCollection_BaseSequence):
    """
    Purpose:     Definition of a sequence of elements indexed by
    an Integer in range of 1..n
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Sequence_Handle_SelectMgr_Filter self) -> NCollection_Sequence< opencascade::handle< SelectMgr_Filter > >::iterator

        Returns an iterator pointing to the first element in the sequence.

        :rtype: iterator

        """
        return _SelectMgr.NCollection_Sequence_Handle_SelectMgr_Filter_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Sequence_Handle_SelectMgr_Filter self) -> NCollection_Sequence< opencascade::handle< SelectMgr_Filter > >::iterator

        Returns an iterator referring to the past-the-end element in the sequence.

        :rtype: iterator

        """
        return _SelectMgr.NCollection_Sequence_Handle_SelectMgr_Filter_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Sequence_Handle_SelectMgr_Filter self) -> NCollection_Sequence< opencascade::handle< SelectMgr_Filter > >::const_iterator

        Returns a const iterator pointing to the first element in the sequence.

        :rtype: const_iterator

        """
        return _SelectMgr.NCollection_Sequence_Handle_SelectMgr_Filter_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Sequence_Handle_SelectMgr_Filter self) -> NCollection_Sequence< opencascade::handle< SelectMgr_Filter > >::const_iterator

        Returns a const iterator referring to the past-the-end element in the sequence.

        :rtype: const_iterator

        """
        return _SelectMgr.NCollection_Sequence_Handle_SelectMgr_Filter_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     Definition of a sequence of elements indexed by
        an Integer in range of 1..n
        """
        this = _SelectMgr.new_NCollection_Sequence_Handle_SelectMgr_Filter(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Size(self, *args):
        """
        Size(NCollection_Sequence_Handle_SelectMgr_Filter self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _SelectMgr.NCollection_Sequence_Handle_SelectMgr_Filter_Size(self, *args)


    def Length(self, *args):
        """
        Length(NCollection_Sequence_Handle_SelectMgr_Filter self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _SelectMgr.NCollection_Sequence_Handle_SelectMgr_Filter_Length(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Sequence_Handle_SelectMgr_Filter self) -> Standard_Integer

        Method for consistency with other collections.
        @return Lower bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _SelectMgr.NCollection_Sequence_Handle_SelectMgr_Filter_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Sequence_Handle_SelectMgr_Filter self) -> Standard_Integer

        Method for consistency with other collections.
        @return Upper bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _SelectMgr.NCollection_Sequence_Handle_SelectMgr_Filter_Upper(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Sequence_Handle_SelectMgr_Filter self) -> Standard_Boolean

        Empty query

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _SelectMgr.NCollection_Sequence_Handle_SelectMgr_Filter_IsEmpty(self, *args)


    def Reverse(self, *args):
        """
        Reverse(NCollection_Sequence_Handle_SelectMgr_Filter self)

        Reverse sequence


        """
        return _SelectMgr.NCollection_Sequence_Handle_SelectMgr_Filter_Reverse(self, *args)


    def Exchange(self, *args):
        """
        Exchange(NCollection_Sequence_Handle_SelectMgr_Filter self, Standard_Integer const I, Standard_Integer const J)

        Exchange two members

        :type I: int
        :type J: int

        """
        return _SelectMgr.NCollection_Sequence_Handle_SelectMgr_Filter_Exchange(self, *args)


    def delNode(*args):
        """
        delNode(NCollection_SeqNode theNode, Handle_NCollection_BaseAllocator theAl)

        Static deleter to be passed to BaseSequence

        :type theNode: OCC.wrapper.NCollection.NCollection_SeqNode
        :type theAl: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _SelectMgr.NCollection_Sequence_Handle_SelectMgr_Filter_delNode(*args)

    delNode = staticmethod(delNode)

    def Clear(self, *args):
        """
        Clear(NCollection_Sequence_Handle_SelectMgr_Filter self, Handle_NCollection_BaseAllocator theAllocator=0)

        Clear the items out, take a new allocator if non null

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _SelectMgr.NCollection_Sequence_Handle_SelectMgr_Filter_Clear(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Sequence_Handle_SelectMgr_Filter self, NCollection_Sequence_Handle_SelectMgr_Filter theOther) -> NCollection_Sequence_Handle_SelectMgr_Filter

        Replace this sequence by the items of theOther.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_Sequence
        :rtype: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _SelectMgr.NCollection_Sequence_Handle_SelectMgr_Filter_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Sequence_Handle_SelectMgr_Filter self, NCollection_Sequence_Handle_SelectMgr_Filter theOther) -> NCollection_Sequence_Handle_SelectMgr_Filter

        Replacement operator

        :type theOther: OCC.wrapper.NCollection.NCollection_Sequence
        :rtype: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _SelectMgr.NCollection_Sequence_Handle_SelectMgr_Filter_assign(self, *args)


    def Remove(self, *args):
        """
        Remove(NCollection_Sequence_Handle_SelectMgr_Filter self, NCollection_Sequence< opencascade::handle< SelectMgr_Filter > >::Iterator & thePosition)
        Remove(NCollection_Sequence_Handle_SelectMgr_Filter self, Standard_Integer const theIndex)
        Remove(NCollection_Sequence_Handle_SelectMgr_Filter self, Standard_Integer const theFromIndex, Standard_Integer const theToIndex)

        Remove range of items

        :type theFromIndex: int
        :type theToIndex: int

        """
        return _SelectMgr.NCollection_Sequence_Handle_SelectMgr_Filter_Remove(self, *args)


    def Append(self, *args):
        """
        Append(NCollection_Sequence_Handle_SelectMgr_Filter self, Handle_SelectMgr_Filter theItem)
        Append(NCollection_Sequence_Handle_SelectMgr_Filter self, NCollection_Sequence_Handle_SelectMgr_Filter theSeq)

        Append another sequence (making it empty)

        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _SelectMgr.NCollection_Sequence_Handle_SelectMgr_Filter_Append(self, *args)


    def Prepend(self, *args):
        """
        Prepend(NCollection_Sequence_Handle_SelectMgr_Filter self, Handle_SelectMgr_Filter theItem)
        Prepend(NCollection_Sequence_Handle_SelectMgr_Filter self, NCollection_Sequence_Handle_SelectMgr_Filter theSeq)

        Prepend another sequence (making it empty)

        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _SelectMgr.NCollection_Sequence_Handle_SelectMgr_Filter_Prepend(self, *args)


    def InsertBefore(self, *args):
        """
        InsertBefore(NCollection_Sequence_Handle_SelectMgr_Filter self, Standard_Integer const theIndex, Handle_SelectMgr_Filter theItem)
        InsertBefore(NCollection_Sequence_Handle_SelectMgr_Filter self, Standard_Integer const theIndex, NCollection_Sequence_Handle_SelectMgr_Filter theSeq)

        InsertBefore theIndex another sequence

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _SelectMgr.NCollection_Sequence_Handle_SelectMgr_Filter_InsertBefore(self, *args)


    def InsertAfter(self, *args):
        """
        InsertAfter(NCollection_Sequence_Handle_SelectMgr_Filter self, NCollection_Sequence< opencascade::handle< SelectMgr_Filter > >::Iterator & thePosition, Handle_SelectMgr_Filter theItem)
        InsertAfter(NCollection_Sequence_Handle_SelectMgr_Filter self, Standard_Integer const theIndex, NCollection_Sequence_Handle_SelectMgr_Filter theSeq)
        InsertAfter(NCollection_Sequence_Handle_SelectMgr_Filter self, Standard_Integer const theIndex, Handle_SelectMgr_Filter theItem)

        InsertAfter theIndex another sequence

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _SelectMgr.NCollection_Sequence_Handle_SelectMgr_Filter_InsertAfter(self, *args)


    def Split(self, *args):
        """
        Split(NCollection_Sequence_Handle_SelectMgr_Filter self, Standard_Integer const theIndex, NCollection_Sequence_Handle_SelectMgr_Filter theSeq)

        Split in two sequences

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _SelectMgr.NCollection_Sequence_Handle_SelectMgr_Filter_Split(self, *args)


    def First(self, *args):
        """
        First item access

        :rtype: const TheItemType &

        """
        res = _SelectMgr.NCollection_Sequence_Handle_SelectMgr_Filter_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Sequence_Handle_SelectMgr_Filter self) -> Handle_SelectMgr_Filter

        First item access

        :rtype: TheItemType &

        """
        return _SelectMgr.NCollection_Sequence_Handle_SelectMgr_Filter_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        Last item access

        :rtype: const TheItemType &

        """
        res = _SelectMgr.NCollection_Sequence_Handle_SelectMgr_Filter_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Sequence_Handle_SelectMgr_Filter self) -> Handle_SelectMgr_Filter

        Last item access

        :rtype: TheItemType &

        """
        return _SelectMgr.NCollection_Sequence_Handle_SelectMgr_Filter_ChangeLast(self, *args)


    def Value(self, *args):
        """
        Constant item access by theIndex

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _SelectMgr.NCollection_Sequence_Handle_SelectMgr_Filter_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Sequence_Handle_SelectMgr_Filter self, Standard_Integer const theIndex) -> Handle_SelectMgr_Filter

        Variable item access by theIndex

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _SelectMgr.NCollection_Sequence_Handle_SelectMgr_Filter_ChangeValue(self, *args)


    def __call__(self, *args):
        """
        Constant operator()

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _SelectMgr.NCollection_Sequence_Handle_SelectMgr_Filter___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetValue(self, *args):
        """
        SetValue(NCollection_Sequence_Handle_SelectMgr_Filter self, Standard_Integer const theIndex, Handle_SelectMgr_Filter theItem)

        Set item value by theIndex

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _SelectMgr.NCollection_Sequence_Handle_SelectMgr_Filter_SetValue(self, *args)


    def __iter__(self):
        return _SelectMgr.NCollection_Sequence_Handle_SelectMgr_Filter___iter__(self)
    __swig_destroy__ = _SelectMgr.delete_NCollection_Sequence_Handle_SelectMgr_Filter
NCollection_Sequence_Handle_SelectMgr_Filter_swigregister = _SelectMgr.NCollection_Sequence_Handle_SelectMgr_Filter_swigregister
NCollection_Sequence_Handle_SelectMgr_Filter_swigregister(NCollection_Sequence_Handle_SelectMgr_Filter)

def NCollection_Sequence_Handle_SelectMgr_Filter_delNode(*args):
    """
    NCollection_Sequence_Handle_SelectMgr_Filter_delNode(NCollection_SeqNode theNode, Handle_NCollection_BaseAllocator theAl)

    Static deleter to be passed to BaseSequence

    :type theNode: OCC.wrapper.NCollection.NCollection_SeqNode
    :type theAl: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

    """
    return _SelectMgr.NCollection_Sequence_Handle_SelectMgr_Filter_delNode(*args)

class NCollection_Sequence_Handle_SelectMgr_Filter_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _SelectMgr.new_NCollection_Sequence_Handle_SelectMgr_Filter_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SelectMgr.delete_NCollection_Sequence_Handle_SelectMgr_Filter_IteratorHelper

    def __next__(self):
        return _SelectMgr.NCollection_Sequence_Handle_SelectMgr_Filter_IteratorHelper___next__(self)
NCollection_Sequence_Handle_SelectMgr_Filter_IteratorHelper_swigregister = _SelectMgr.NCollection_Sequence_Handle_SelectMgr_Filter_IteratorHelper_swigregister
NCollection_Sequence_Handle_SelectMgr_Filter_IteratorHelper_swigregister(NCollection_Sequence_Handle_SelectMgr_Filter_IteratorHelper)


try:
	SelectMgr_SequenceOfFilter = NCollection_Sequence_Handle_SelectMgr_Filter
except NameError:
	pass # does not exist, probably ignored

class SelectMgr_ToleranceMap(object):
    """
    An internal class for calculation of current largest tolerance value which will be applied for creation of selecting frustum by default.
    Each time the selection set is deactivated, maximum tolerance value will be recalculated.
    If a user enables custom precision using StdSelect_ViewerSelector3d::SetPixelTolerance, it will be applied to all sensitive entities without any checks.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def Add(self, *args):
        """
        Add(SelectMgr_ToleranceMap self, Standard_Integer const & theTolerance)

        Adds the value given to map, checks if the current tolerance value
        should be replaced by theTolerance

        :type theTolerance: int

        """
        return _SelectMgr.SelectMgr_ToleranceMap_Add(self, *args)


    def Decrement(self, *args):
        """
        Decrement(SelectMgr_ToleranceMap self, Standard_Integer const & theTolerance)

        Decrements a counter of the tolerance given, checks if the current tolerance value
        should be recalculated

        :type theTolerance: int

        """
        return _SelectMgr.SelectMgr_ToleranceMap_Decrement(self, *args)


    def Tolerance(self, *args):
        """
        Tolerance(SelectMgr_ToleranceMap self) -> Standard_Integer

        Returns a current tolerance that must be applied

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _SelectMgr.SelectMgr_ToleranceMap_Tolerance(self, *args)


    def SetCustomTolerance(self, *args):
        """
        SetCustomTolerance(SelectMgr_ToleranceMap self, Standard_Integer const theTolerance)

        Sets tolerance to the given one and disables adaptive checks

        :type theTolerance: int

        """
        return _SelectMgr.SelectMgr_ToleranceMap_SetCustomTolerance(self, *args)


    def ResetDefaults(self, *args):
        """
        ResetDefaults(SelectMgr_ToleranceMap self)

        Unsets a custom tolerance and enables adaptive checks


        """
        return _SelectMgr.SelectMgr_ToleranceMap_ResetDefaults(self, *args)


    def CustomTolerance(self, *args):
        """
        CustomTolerance(SelectMgr_ToleranceMap self) -> Standard_Integer

        Returns the value of custom tolerance regardless of it validity

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _SelectMgr.SelectMgr_ToleranceMap_CustomTolerance(self, *args)


    def IsCustomTolSet(self, *args):
        """
        IsCustomTolSet(SelectMgr_ToleranceMap self) -> Standard_Boolean

        Returns true if custom tolerance value is greater than zero

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _SelectMgr.SelectMgr_ToleranceMap_IsCustomTolSet(self, *args)

    __swig_destroy__ = _SelectMgr.delete_SelectMgr_ToleranceMap
SelectMgr_ToleranceMap_swigregister = _SelectMgr.SelectMgr_ToleranceMap_swigregister
SelectMgr_ToleranceMap_swigregister(SelectMgr_ToleranceMap)

class Handle_SelectMgr_ViewerSelector(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_SelectMgr_ViewerSelector self)

        Nullify the handle


        """
        return _SelectMgr.Handle_SelectMgr_ViewerSelector_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_SelectMgr_ViewerSelector self) -> bool

        Check for being null

        :rtype: bool

        """
        return _SelectMgr.Handle_SelectMgr_ViewerSelector_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_SelectMgr_ViewerSelector self, SelectMgr_ViewerSelector thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _SelectMgr.Handle_SelectMgr_ViewerSelector_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_SelectMgr_ViewerSelector self, Handle_SelectMgr_ViewerSelector theHandle) -> Handle_SelectMgr_ViewerSelector
        assign(Handle_SelectMgr_ViewerSelector self, SelectMgr_ViewerSelector thePtr) -> Handle_SelectMgr_ViewerSelector
        assign(Handle_SelectMgr_ViewerSelector self, Handle_SelectMgr_ViewerSelector theHandle) -> Handle_SelectMgr_ViewerSelector

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _SelectMgr.Handle_SelectMgr_ViewerSelector_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_SelectMgr_ViewerSelector self) -> SelectMgr_ViewerSelector

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _SelectMgr.Handle_SelectMgr_ViewerSelector_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_SelectMgr_ViewerSelector self) -> SelectMgr_ViewerSelector

        Member access operator (note non-const)

        :rtype: T *

        """
        return _SelectMgr.Handle_SelectMgr_ViewerSelector___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_SelectMgr_ViewerSelector self) -> SelectMgr_ViewerSelector

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _SelectMgr.Handle_SelectMgr_ViewerSelector___ref__(self, *args)


    def __hash__(self):
        return _SelectMgr.Handle_SelectMgr_ViewerSelector___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _SelectMgr.Handle_SelectMgr_ViewerSelector___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _SelectMgr.new_Handle_SelectMgr_ViewerSelector(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_SelectMgr.Handle_SelectMgr_ViewerSelector_DownCast)
    __swig_destroy__ = _SelectMgr.delete_Handle_SelectMgr_ViewerSelector

    def get_type_name(self, *args):
        """
        get_type_name(Handle_SelectMgr_ViewerSelector self) -> char const *

        :rtype: const char *

        """
        return _SelectMgr.Handle_SelectMgr_ViewerSelector_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _SelectMgr.Handle_SelectMgr_ViewerSelector_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _SelectMgr.Handle_SelectMgr_ViewerSelector_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Clear(self, *args):
        """
        Clear(Handle_SelectMgr_ViewerSelector self)

        Empties all the tables, removes all selections...


        """
        return _SelectMgr.Handle_SelectMgr_ViewerSelector_Clear(self, *args)


    def Sensitivity(self, *args):
        """
        Sensitivity(Handle_SelectMgr_ViewerSelector self) -> Standard_Real

        returns the Sensitivity of picking

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _SelectMgr.Handle_SelectMgr_ViewerSelector_Sensitivity(self, *args)


    def SortResult(self, *args):
        """
        SortResult(Handle_SelectMgr_ViewerSelector self)

        Sorts the detected entites by priority and distance.
        to be redefined if other criterion are used...


        """
        return _SelectMgr.Handle_SelectMgr_ViewerSelector_SortResult(self, *args)


    def OnePicked(self, *args):
        """
        OnePicked(Handle_SelectMgr_ViewerSelector self) -> Handle_SelectMgr_EntityOwner

        Returns the picked element with the highest priority,
        and which is the closest to the last successful mouse position.

        :rtype: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner

        """
        return _SelectMgr.Handle_SelectMgr_ViewerSelector_OnePicked(self, *args)


    def SetPickClosest(self, *args):
        """
        SetPickClosest(Handle_SelectMgr_ViewerSelector self, Standard_Boolean const theToPreferClosest)

        Set preference of selecting one object for OnePicked() method:
        - If True, objects with less depth (distance fron the view plane) are
        preferred regardless of priority (priority is used then to choose among
        objects with similar depth),
        - If False, objects with higher priority are preferred regardless of the
        depth which is used to choose among objects of the same priority.

        :type theToPreferClosest: bool

        """
        return _SelectMgr.Handle_SelectMgr_ViewerSelector_SetPickClosest(self, *args)


    def NbPicked(self, *args):
        """
        NbPicked(Handle_SelectMgr_ViewerSelector self) -> Standard_Integer

        Returns the number of detected owners.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _SelectMgr.Handle_SelectMgr_ViewerSelector_NbPicked(self, *args)


    def ClearPicked(self, *args):
        """
        ClearPicked(Handle_SelectMgr_ViewerSelector self)

        Clears picking results.


        """
        return _SelectMgr.Handle_SelectMgr_ViewerSelector_ClearPicked(self, *args)


    def Picked(self, *args):
        """
        Picked(Handle_SelectMgr_ViewerSelector self, Standard_Integer const theRank) -> Handle_SelectMgr_EntityOwner
        Picked(Handle_SelectMgr_ViewerSelector self) -> Handle_SelectMgr_EntityOwner

        Returns the current selected entity detected by the selector;

        :rtype: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner

        """
        return _SelectMgr.Handle_SelectMgr_ViewerSelector_Picked(self, *args)


    def PickedData(self, *args):
        """
        Returns the Entity for the object picked at specified position.
        @param theRank rank of detected object within range 1...NbPicked()

        :type theRank: int
        :rtype: OCC.wrapper.SelectMgr.SelectMgr_SortCriterion

        """
        res = _SelectMgr.Handle_SelectMgr_ViewerSelector_PickedData(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def PickedEntity(self, *args):
        """
        Returns the Entity for the object picked at specified position.
        @param theRank rank of detected object within range 1...NbPicked()

        :type theRank: int
        :rtype: OCC.wrapper.SelectBasics.Handle_SelectBasics_SensitiveEntity

        """
        res = _SelectMgr.Handle_SelectMgr_ViewerSelector_PickedEntity(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def PickedPoint(self, *args):
        """
        PickedPoint(Handle_SelectMgr_ViewerSelector self, Standard_Integer const theRank) -> gp_Pnt

        Returns the 3D point (intersection of picking axis with the object nearest to eye)
        for the object picked at specified position.
        @param theRank rank of detected object within range 1...NbPicked()

        :type theRank: int
        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _SelectMgr.Handle_SelectMgr_ViewerSelector_PickedPoint(self, *args)


    def Contains(self, *args):
        """
        Contains(Handle_SelectMgr_ViewerSelector self, Handle_SelectMgr_SelectableObject theObject) -> Standard_Boolean

        :type theObject: OCC.wrapper.SelectMgr.Handle_SelectMgr_SelectableObject
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _SelectMgr.Handle_SelectMgr_ViewerSelector_Contains(self, *args)


    def EntitySetBuilder(self, *args):
        """
        EntitySetBuilder(Handle_SelectMgr_ViewerSelector self) -> Handle_Select3D_BVHBuilder3d

        Returns the default builder used to construct BVH of entity set.

        :rtype: OCC.wrapper.SelectMgr.Handle_Select3D_BVHBuilder3d

        """
        return _SelectMgr.Handle_SelectMgr_ViewerSelector_EntitySetBuilder(self, *args)


    def SetEntitySetBuilder(self, *args):
        """
        SetEntitySetBuilder(Handle_SelectMgr_ViewerSelector self, Handle_Select3D_BVHBuilder3d theBuilder)

        Sets the default builder used to construct BVH of entity set.
        The new builder will be also assigned for already defined objects, but computed BVH trees will not be invalidated.

        :type theBuilder: OCC.wrapper.SelectMgr.Handle_Select3D_BVHBuilder3d

        """
        return _SelectMgr.Handle_SelectMgr_ViewerSelector_SetEntitySetBuilder(self, *args)


    def Modes(self, *args):
        """
        Modes(Handle_SelectMgr_ViewerSelector self, Handle_SelectMgr_SelectableObject theSelectableObject, NCollection_List_Standard_Integer theModeList, SelectMgr_StateOfSelection const theWantedState=SelectMgr_SOS_Any) -> Standard_Boolean

        Returns the list of selection modes ModeList found in
        this selector for the selectable object aSelectableObject.
        Returns true if aSelectableObject is referenced inside
        this selector; returns false if the object is not present
        in this selector.

        :type theSelectableObject: OCC.wrapper.SelectMgr.Handle_SelectMgr_SelectableObject
        :type theModeList: OCC.wrapper.TColStd.TColStd_ListOfInteger
        :type theWantedState: OCC.wrapper.SelectMgr.SelectMgr_StateOfSelection
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _SelectMgr.Handle_SelectMgr_ViewerSelector_Modes(self, *args)


    def IsActive(self, *args):
        """
        IsActive(Handle_SelectMgr_ViewerSelector self, Handle_SelectMgr_SelectableObject theSelectableObject, Standard_Integer const theMode) -> Standard_Boolean

        Returns true if the selectable object
        aSelectableObject having the selection mode aMode
        is active in this selector.

        :type theSelectableObject: OCC.wrapper.SelectMgr.Handle_SelectMgr_SelectableObject
        :type theMode: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _SelectMgr.Handle_SelectMgr_ViewerSelector_IsActive(self, *args)


    def IsInside(self, *args):
        """
        IsInside(Handle_SelectMgr_ViewerSelector self, Handle_SelectMgr_SelectableObject theSelectableObject, Standard_Integer const theMode) -> Standard_Boolean

        Returns true if the selectable object
        aSelectableObject having the selection mode aMode
        is in this selector.

        :type theSelectableObject: OCC.wrapper.SelectMgr.Handle_SelectMgr_SelectableObject
        :type theMode: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _SelectMgr.Handle_SelectMgr_ViewerSelector_IsInside(self, *args)


    def Status(self, *args):
        """
        Status(Handle_SelectMgr_ViewerSelector self, Handle_SelectMgr_Selection theSelection) -> SelectMgr_StateOfSelection
        Status(Handle_SelectMgr_ViewerSelector self, Handle_SelectMgr_SelectableObject theSelectableObject) -> TCollection_AsciiString

        :type theSelectableObject: OCC.wrapper.SelectMgr.Handle_SelectMgr_SelectableObject
        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _SelectMgr.Handle_SelectMgr_ViewerSelector_Status(self, *args)


    def ActiveOwners(self, *args):
        """
        ActiveOwners(Handle_SelectMgr_ViewerSelector self, NCollection_List< opencascade::handle< SelectBasics_EntityOwner > > & theOwners)

        Returns the list of active entity owners

        :type theOwners: OCC.wrapper.SelectMgr.NCollection_List_Handle_SelectBasics_EntityOwner

        """
        return _SelectMgr.Handle_SelectMgr_ViewerSelector_ActiveOwners(self, *args)


    def AddSelectableObject(self, *args):
        """
        AddSelectableObject(Handle_SelectMgr_ViewerSelector self, Handle_SelectMgr_SelectableObject theObject)

        Adds new object to the map of selectable objects

        :type theObject: OCC.wrapper.SelectMgr.Handle_SelectMgr_SelectableObject

        """
        return _SelectMgr.Handle_SelectMgr_ViewerSelector_AddSelectableObject(self, *args)


    def AddSelectionToObject(self, *args):
        """
        AddSelectionToObject(Handle_SelectMgr_ViewerSelector self, Handle_SelectMgr_SelectableObject theObject, Handle_SelectMgr_Selection theSelection)

        Adds new selection to the object and builds its BVH tree

        :type theObject: OCC.wrapper.SelectMgr.Handle_SelectMgr_SelectableObject
        :type theSelection: OCC.wrapper.SelectMgr.Handle_SelectMgr_Selection

        """
        return _SelectMgr.Handle_SelectMgr_ViewerSelector_AddSelectionToObject(self, *args)


    def MoveSelectableObject(self, *args):
        """
        MoveSelectableObject(Handle_SelectMgr_ViewerSelector self, Handle_SelectMgr_SelectableObject theObject)

        Moves existing object from set of not transform persistence objects
        to set of transform persistence objects (or vice versa).

        :type theObject: OCC.wrapper.SelectMgr.Handle_SelectMgr_SelectableObject

        """
        return _SelectMgr.Handle_SelectMgr_ViewerSelector_MoveSelectableObject(self, *args)


    def RemoveSelectableObject(self, *args):
        """
        RemoveSelectableObject(Handle_SelectMgr_ViewerSelector self, Handle_SelectMgr_SelectableObject theObject)

        Removes selectable object from map of selectable ones

        :type theObject: OCC.wrapper.SelectMgr.Handle_SelectMgr_SelectableObject

        """
        return _SelectMgr.Handle_SelectMgr_ViewerSelector_RemoveSelectableObject(self, *args)


    def RemoveSelectionOfObject(self, *args):
        """
        RemoveSelectionOfObject(Handle_SelectMgr_ViewerSelector self, Handle_SelectMgr_SelectableObject theObject, Handle_SelectMgr_Selection theSelection)

        Removes selection of the object and marks its BVH tree for rebuild

        :type theObject: OCC.wrapper.SelectMgr.Handle_SelectMgr_SelectableObject
        :type theSelection: OCC.wrapper.SelectMgr.Handle_SelectMgr_Selection

        """
        return _SelectMgr.Handle_SelectMgr_ViewerSelector_RemoveSelectionOfObject(self, *args)


    def RebuildObjectsTree(self, *args):
        """
        RebuildObjectsTree(Handle_SelectMgr_ViewerSelector self, Standard_Boolean const theIsForce)

        Marks BVH of selectable objects for rebuild. Parameter theIsForce set as true
        guarantees that 1st level BVH for the viewer selector will be rebuilt during this call

        :type theIsForce: bool

        """
        return _SelectMgr.Handle_SelectMgr_ViewerSelector_RebuildObjectsTree(self, *args)


    def RebuildSensitivesTree(self, *args):
        """
        RebuildSensitivesTree(Handle_SelectMgr_ViewerSelector self, Handle_SelectMgr_SelectableObject theObject, Standard_Boolean const theIsForce)

        Marks BVH of sensitive entities of particular selectable object for rebuild. Parameter
        theIsForce set as true guarantees that 2nd level BVH for the object given will be
        rebuilt during this call

        :type theObject: OCC.wrapper.SelectMgr.Handle_SelectMgr_SelectableObject
        :type theIsForce: bool

        """
        return _SelectMgr.Handle_SelectMgr_ViewerSelector_RebuildSensitivesTree(self, *args)


    def GetManager(self, *args):
        """
        GetManager(Handle_SelectMgr_ViewerSelector self) -> SelectMgr_SelectingVolumeManager

        Returns instance of selecting volume manager of the viewer selector

        :rtype: OCC.wrapper.SelectMgr.SelectMgr_SelectingVolumeManager

        """
        return _SelectMgr.Handle_SelectMgr_ViewerSelector_GetManager(self, *args)


    def ResetSelectionActivationStatus(self, *args):
        """
        ResetSelectionActivationStatus(Handle_SelectMgr_ViewerSelector self)

        Marks all added sensitive entities of all objects as non-selectable


        """
        return _SelectMgr.Handle_SelectMgr_ViewerSelector_ResetSelectionActivationStatus(self, *args)


    def AllowOverlapDetection(self, *args):
        """
        AllowOverlapDetection(Handle_SelectMgr_ViewerSelector self, Standard_Boolean const theIsToAllow)

        Is used for rectangular selection only
        If theIsToAllow is false, only fully included sensitives will be detected, otherwise the algorithm will
        mark both included and overlapped entities as matched

        :type theIsToAllow: bool

        """
        return _SelectMgr.Handle_SelectMgr_ViewerSelector_AllowOverlapDetection(self, *args)


    def Init(self, *args):
        """
        Init(Handle_SelectMgr_ViewerSelector self)

        Begins an iteration scanning for the owners detected at a position in the view.


        """
        return _SelectMgr.Handle_SelectMgr_ViewerSelector_Init(self, *args)


    def More(self, *args):
        """
        More(Handle_SelectMgr_ViewerSelector self) -> Standard_Boolean

        Continues the interation scanning for the owners detected at a position in the view,
        or continues the iteration scanning for the owner closest to the position in the view.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _SelectMgr.Handle_SelectMgr_ViewerSelector_More(self, *args)


    def Next(self, *args):
        """
        Next(Handle_SelectMgr_ViewerSelector self)

        Returns the next owner found in the iteration. This is
        a scan for the owners detected at a position in the view.


        """
        return _SelectMgr.Handle_SelectMgr_ViewerSelector_Next(self, *args)


    def InitDetected(self, *args):
        """
        InitDetected(Handle_SelectMgr_ViewerSelector self)

        Initializes internal iterator for stored detected sensitive entities


        """
        return _SelectMgr.Handle_SelectMgr_ViewerSelector_InitDetected(self, *args)


    def NextDetected(self, *args):
        """
        NextDetected(Handle_SelectMgr_ViewerSelector self)

        Makes a step along the map of detected sensitive entities and their owners


        """
        return _SelectMgr.Handle_SelectMgr_ViewerSelector_NextDetected(self, *args)


    def MoreDetected(self, *args):
        """
        MoreDetected(Handle_SelectMgr_ViewerSelector self) -> Standard_Boolean

        Returns true if iterator of map of detected sensitive entities has reached its end

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _SelectMgr.Handle_SelectMgr_ViewerSelector_MoreDetected(self, *args)


    def DetectedEntity(self, *args):
        """
        Returns sensitive entity that was detected during the previous run of selection algorithm

        :rtype: OCC.wrapper.SelectBasics.Handle_SelectBasics_SensitiveEntity

        """
        res = _SelectMgr.Handle_SelectMgr_ViewerSelector_DetectedEntity(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_SelectMgr_ViewerSelector self)

        Memory deallocator for transient classes


        """
        return _SelectMgr.Handle_SelectMgr_ViewerSelector_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_SelectMgr_ViewerSelector self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_SelectMgr_ViewerSelector self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _SelectMgr.Handle_SelectMgr_ViewerSelector_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_SelectMgr_ViewerSelector self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_SelectMgr_ViewerSelector self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _SelectMgr.Handle_SelectMgr_ViewerSelector_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_SelectMgr_ViewerSelector self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _SelectMgr.Handle_SelectMgr_ViewerSelector_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_SelectMgr_ViewerSelector self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _SelectMgr.Handle_SelectMgr_ViewerSelector_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_SelectMgr_ViewerSelector self)

        Increments the reference counter of this object


        """
        return _SelectMgr.Handle_SelectMgr_ViewerSelector_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_SelectMgr_ViewerSelector self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _SelectMgr.Handle_SelectMgr_ViewerSelector_DecrementRefCounter(self, *args)

Handle_SelectMgr_ViewerSelector_swigregister = _SelectMgr.Handle_SelectMgr_ViewerSelector_swigregister
Handle_SelectMgr_ViewerSelector_swigregister(Handle_SelectMgr_ViewerSelector)

def Handle_SelectMgr_ViewerSelector_DownCast(thing):
    return _SelectMgr.Handle_SelectMgr_ViewerSelector_DownCast(thing)
Handle_SelectMgr_ViewerSelector_DownCast = _SelectMgr.Handle_SelectMgr_ViewerSelector_DownCast

class Handle_SelectMgr_SensitiveEntity(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_SelectMgr_SensitiveEntity self)

        Nullify the handle


        """
        return _SelectMgr.Handle_SelectMgr_SensitiveEntity_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_SelectMgr_SensitiveEntity self) -> bool

        Check for being null

        :rtype: bool

        """
        return _SelectMgr.Handle_SelectMgr_SensitiveEntity_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_SelectMgr_SensitiveEntity self, SelectMgr_SensitiveEntity thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _SelectMgr.Handle_SelectMgr_SensitiveEntity_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_SelectMgr_SensitiveEntity self, Handle_SelectMgr_SensitiveEntity theHandle) -> Handle_SelectMgr_SensitiveEntity
        assign(Handle_SelectMgr_SensitiveEntity self, SelectMgr_SensitiveEntity thePtr) -> Handle_SelectMgr_SensitiveEntity
        assign(Handle_SelectMgr_SensitiveEntity self, Handle_SelectMgr_SensitiveEntity theHandle) -> Handle_SelectMgr_SensitiveEntity

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _SelectMgr.Handle_SelectMgr_SensitiveEntity_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_SelectMgr_SensitiveEntity self) -> SelectMgr_SensitiveEntity

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _SelectMgr.Handle_SelectMgr_SensitiveEntity_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_SelectMgr_SensitiveEntity self) -> SelectMgr_SensitiveEntity

        Member access operator (note non-const)

        :rtype: T *

        """
        return _SelectMgr.Handle_SelectMgr_SensitiveEntity___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_SelectMgr_SensitiveEntity self) -> SelectMgr_SensitiveEntity

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _SelectMgr.Handle_SelectMgr_SensitiveEntity___ref__(self, *args)


    def __hash__(self):
        return _SelectMgr.Handle_SelectMgr_SensitiveEntity___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _SelectMgr.Handle_SelectMgr_SensitiveEntity___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _SelectMgr.new_Handle_SelectMgr_SensitiveEntity(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_SelectMgr.Handle_SelectMgr_SensitiveEntity_DownCast)
    __swig_destroy__ = _SelectMgr.delete_Handle_SelectMgr_SensitiveEntity

    def Clear(self, *args):
        """
        Clear(Handle_SelectMgr_SensitiveEntity self)

        Clears up all resources and memory


        """
        return _SelectMgr.Handle_SelectMgr_SensitiveEntity_Clear(self, *args)


    def BaseSensitive(self, *args):
        """
        Returns related instance of SelectBasics class

        :rtype: OCC.wrapper.SelectBasics.Handle_SelectBasics_SensitiveEntity

        """
        res = _SelectMgr.Handle_SelectMgr_SensitiveEntity_BaseSensitive(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def IsActiveForSelection(self, *args):
        """
        IsActiveForSelection(Handle_SelectMgr_SensitiveEntity self) -> Standard_Boolean

        Returns true if this entity belongs to the active selection
        mode of parent object

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _SelectMgr.Handle_SelectMgr_SensitiveEntity_IsActiveForSelection(self, *args)


    def ResetSelectionActiveStatus(self, *args):
        """
        ResetSelectionActiveStatus(Handle_SelectMgr_SensitiveEntity self)

        Marks entity as inactive for selection


        """
        return _SelectMgr.Handle_SelectMgr_SensitiveEntity_ResetSelectionActiveStatus(self, *args)


    def SetActiveForSelection(self, *args):
        """
        SetActiveForSelection(Handle_SelectMgr_SensitiveEntity self)

        Marks entity as active for selection


        """
        return _SelectMgr.Handle_SelectMgr_SensitiveEntity_SetActiveForSelection(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_SelectMgr_SensitiveEntity self) -> char const *

        :rtype: const char *

        """
        return _SelectMgr.Handle_SelectMgr_SensitiveEntity_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _SelectMgr.Handle_SelectMgr_SensitiveEntity_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _SelectMgr.Handle_SelectMgr_SensitiveEntity_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_SelectMgr_SensitiveEntity self)

        Memory deallocator for transient classes


        """
        return _SelectMgr.Handle_SelectMgr_SensitiveEntity_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_SelectMgr_SensitiveEntity self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_SelectMgr_SensitiveEntity self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _SelectMgr.Handle_SelectMgr_SensitiveEntity_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_SelectMgr_SensitiveEntity self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_SelectMgr_SensitiveEntity self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _SelectMgr.Handle_SelectMgr_SensitiveEntity_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_SelectMgr_SensitiveEntity self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _SelectMgr.Handle_SelectMgr_SensitiveEntity_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_SelectMgr_SensitiveEntity self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _SelectMgr.Handle_SelectMgr_SensitiveEntity_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_SelectMgr_SensitiveEntity self)

        Increments the reference counter of this object


        """
        return _SelectMgr.Handle_SelectMgr_SensitiveEntity_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_SelectMgr_SensitiveEntity self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _SelectMgr.Handle_SelectMgr_SensitiveEntity_DecrementRefCounter(self, *args)

Handle_SelectMgr_SensitiveEntity_swigregister = _SelectMgr.Handle_SelectMgr_SensitiveEntity_swigregister
Handle_SelectMgr_SensitiveEntity_swigregister(Handle_SelectMgr_SensitiveEntity)

def Handle_SelectMgr_SensitiveEntity_DownCast(thing):
    return _SelectMgr.Handle_SelectMgr_SensitiveEntity_DownCast(thing)
Handle_SelectMgr_SensitiveEntity_DownCast = _SelectMgr.Handle_SelectMgr_SensitiveEntity_DownCast

class SelectMgr_FrustumBuilder(Standard.Standard_Transient):
    """
    The purpose of this class is to provide unified interface for building
    selecting frustum depending on current camera projection and orientation
    matrices, window size and viewport parameters.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_SelectMgr_FrustumBuilder
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_SelectMgr_FrustumBuilder(self) 
            return h


    def __init__(self, *args):
        """
        __init__(SelectMgr_FrustumBuilder self) -> SelectMgr_FrustumBuilder

        Creates new frustum builder with empty matrices


        """
        this = _SelectMgr.new_SelectMgr_FrustumBuilder(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def SetWorldViewMatrix(self, *args):
        """
        SetWorldViewMatrix(SelectMgr_FrustumBuilder self, NCollection_Mat4_Standard_Real theWorldViewMatrix)

        Stores current world view transformation matrix

        :type theWorldViewMatrix: OCC.wrapper.Graphic3d.Graphic3d_Mat4d

        """
        return _SelectMgr.SelectMgr_FrustumBuilder_SetWorldViewMatrix(self, *args)


    def WorldViewMatrix(self, *args):
        """
        @return current world view transformation matrix

        :rtype: OCC.wrapper.Graphic3d.Graphic3d_Mat4d

        """
        res = _SelectMgr.SelectMgr_FrustumBuilder_WorldViewMatrix(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetProjectionMatrix(self, *args):
        """
        SetProjectionMatrix(SelectMgr_FrustumBuilder self, NCollection_Mat4_Standard_Real theProjection)

        Stores current projection matrix

        :type theProjection: OCC.wrapper.Graphic3d.Graphic3d_Mat4d

        """
        return _SelectMgr.SelectMgr_FrustumBuilder_SetProjectionMatrix(self, *args)


    def ProjectionMatrix(self, *args):
        """
        @return current projection matrix

        :rtype: OCC.wrapper.Graphic3d.Graphic3d_Mat4d

        """
        res = _SelectMgr.SelectMgr_FrustumBuilder_ProjectionMatrix(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetWorldViewProjState(self, *args):
        """
        SetWorldViewProjState(SelectMgr_FrustumBuilder self, Graphic3d_WorldViewProjState theState)

        Stores current world view projection matrix state for the orientation and projection matrices

        :type theState: OCC.wrapper.Graphic3d.Graphic3d_WorldViewProjState

        """
        return _SelectMgr.SelectMgr_FrustumBuilder_SetWorldViewProjState(self, *args)


    def WorldViewProjState(self, *args):
        """
        @return current world view projection state

        :rtype: OCC.wrapper.Graphic3d.Graphic3d_WorldViewProjState

        """
        res = _SelectMgr.SelectMgr_FrustumBuilder_WorldViewProjState(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetWindowSize(self, *args):
        """
        SetWindowSize(SelectMgr_FrustumBuilder self, Standard_Integer const theWidth, Standard_Integer const theHeight)

        Stores current window width and height

        :type theWidth: int
        :type theHeight: int

        """
        return _SelectMgr.SelectMgr_FrustumBuilder_SetWindowSize(self, *args)


    def SetViewport(self, *args):
        """
        SetViewport(SelectMgr_FrustumBuilder self, Standard_Real const theX, Standard_Real const theY, Standard_Real const theWidth, Standard_Real const theHeight)

        Stores current viewport coordinates

        :type theX: float
        :type theY: float
        :type theWidth: float
        :type theHeight: float

        """
        return _SelectMgr.SelectMgr_FrustumBuilder_SetViewport(self, *args)


    def InvalidateViewport(self, *args):
        """InvalidateViewport(SelectMgr_FrustumBuilder self)"""
        return _SelectMgr.SelectMgr_FrustumBuilder_InvalidateViewport(self, *args)


    def WindowSize(self, *args):
        """
        WindowSize(SelectMgr_FrustumBuilder self)

        :type theWidth: int
        :type theHeight: int

        """
        return _SelectMgr.SelectMgr_FrustumBuilder_WindowSize(self, *args)


    def SignedPlanePntDist(self, *args):
        """
        SignedPlanePntDist(SelectMgr_FrustumBuilder self, NCollection_Vec3_Standard_Real theEq, NCollection_Vec3_Standard_Real thePnt) -> Standard_Real

        Calculates signed distance between plane with equation
        theEq and point thePnt

        :type theEq: OCC.wrapper.SelectMgr.SelectMgr_Vec3
        :type thePnt: OCC.wrapper.SelectMgr.SelectMgr_Vec3
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _SelectMgr.SelectMgr_FrustumBuilder_SignedPlanePntDist(self, *args)


    def ProjectPntOnViewPlane(self, *args):
        """
        ProjectPntOnViewPlane(SelectMgr_FrustumBuilder self, Standard_Real const & theX, Standard_Real const & theY, Standard_Real const & theZ) -> gp_Pnt

        Projects 2d screen point onto view frustum plane:
        theZ = 0 - near plane,
        theZ = 1 - far plane

        :type theX: float
        :type theY: float
        :type theZ: float
        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _SelectMgr.SelectMgr_FrustumBuilder_ProjectPntOnViewPlane(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _SelectMgr.SelectMgr_FrustumBuilder_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _SelectMgr.SelectMgr_FrustumBuilder_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _SelectMgr.SelectMgr_FrustumBuilder_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _SelectMgr.delete_SelectMgr_FrustumBuilder
SelectMgr_FrustumBuilder_swigregister = _SelectMgr.SelectMgr_FrustumBuilder_swigregister
SelectMgr_FrustumBuilder_swigregister(SelectMgr_FrustumBuilder)

def SelectMgr_FrustumBuilder_get_type_name(*args):
    """
    SelectMgr_FrustumBuilder_get_type_name() -> char const *

    :rtype: const char *

    """
    return _SelectMgr.SelectMgr_FrustumBuilder_get_type_name(*args)

def SelectMgr_FrustumBuilder_get_type_descriptor(*args):
    """
    SelectMgr_FrustumBuilder_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _SelectMgr.SelectMgr_FrustumBuilder_get_type_descriptor(*args)

class SelectMgr_SortCriterion(object):
    """
    This class provides data and criterion for sorting candidate
    entities in the process of interactive selection by mouse click
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(SelectMgr_SortCriterion self) -> SelectMgr_SortCriterion

        Empty constructor.


        """
        this = _SelectMgr.new_SelectMgr_SortCriterion(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def __gt__(self, *args):
        """
        __gt__(SelectMgr_SortCriterion self, SelectMgr_SortCriterion theOther) -> bool

        Comparison operator.

        :type theOther: OCC.wrapper.SelectMgr.SelectMgr_SortCriterion
        :rtype: bool

        """
        return _SelectMgr.SelectMgr_SortCriterion___gt__(self, *args)


    def __lt__(self, *args):
        """
        __lt__(SelectMgr_SortCriterion self, SelectMgr_SortCriterion theOther) -> bool

        Comparison operator.

        :type theOther: OCC.wrapper.SelectMgr.SelectMgr_SortCriterion
        :rtype: bool

        """
        return _SelectMgr.SelectMgr_SortCriterion___lt__(self, *args)


    def IsGreater(self, *args):
        """
        IsGreater(SelectMgr_SortCriterion self, SelectMgr_SortCriterion theOther) -> bool

        Compare with another item.

        :type theOther: OCC.wrapper.SelectMgr.SelectMgr_SortCriterion
        :rtype: bool

        """
        return _SelectMgr.SelectMgr_SortCriterion_IsGreater(self, *args)


    def IsLower(self, *args):
        """
        IsLower(SelectMgr_SortCriterion self, SelectMgr_SortCriterion theOther) -> bool

        Compare with another item.

        :type theOther: OCC.wrapper.SelectMgr.SelectMgr_SortCriterion
        :rtype: bool

        """
        return _SelectMgr.SelectMgr_SortCriterion_IsLower(self, *args)

    __swig_destroy__ = _SelectMgr.delete_SelectMgr_SortCriterion
SelectMgr_SortCriterion_swigregister = _SelectMgr.SelectMgr_SortCriterion_swigregister
SelectMgr_SortCriterion_swigregister(SelectMgr_SortCriterion)

class NCollection_List_Handle_SelectMgr_TriangularFrustum(NCollection.NCollection_BaseList):
    """
    Purpose:      Simple list to link  items together keeping the first 
    and the last one.
    Inherits BaseList, adding the data item to each node.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_List_Handle_SelectMgr_TriangularFrustum self) -> NCollection_List< opencascade::handle< SelectMgr_TriangularFrustum > >::iterator

        Returns an iterator pointing to the first element in the list.

        :rtype: iterator

        """
        return _SelectMgr.NCollection_List_Handle_SelectMgr_TriangularFrustum_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_List_Handle_SelectMgr_TriangularFrustum self) -> NCollection_List< opencascade::handle< SelectMgr_TriangularFrustum > >::iterator

        Returns an iterator referring to the past-the-end element in the list.

        :rtype: iterator

        """
        return _SelectMgr.NCollection_List_Handle_SelectMgr_TriangularFrustum_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_List_Handle_SelectMgr_TriangularFrustum self) -> NCollection_List< opencascade::handle< SelectMgr_TriangularFrustum > >::const_iterator

        Returns a const iterator pointing to the first element in the list.

        :rtype: const_iterator

        """
        return _SelectMgr.NCollection_List_Handle_SelectMgr_TriangularFrustum_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_List_Handle_SelectMgr_TriangularFrustum self) -> NCollection_List< opencascade::handle< SelectMgr_TriangularFrustum > >::const_iterator

        Returns a const iterator referring to the past-the-end element in the list.

        :rtype: const_iterator

        """
        return _SelectMgr.NCollection_List_Handle_SelectMgr_TriangularFrustum_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:      Simple list to link  items together keeping the first 
        and the last one.
        Inherits BaseList, adding the data item to each node.
        """
        this = _SelectMgr.new_NCollection_List_Handle_SelectMgr_TriangularFrustum(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Size(self, *args):
        """
        Size(NCollection_List_Handle_SelectMgr_TriangularFrustum self) -> Standard_Integer

        Size - Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _SelectMgr.NCollection_List_Handle_SelectMgr_TriangularFrustum_Size(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_List_Handle_SelectMgr_TriangularFrustum self, NCollection_List_Handle_SelectMgr_TriangularFrustum theOther) -> NCollection_List_Handle_SelectMgr_TriangularFrustum

        Replace this list by the items of another list (theOther parameter).
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_List
        :rtype: OCC.wrapper.NCollection.NCollection_List

        """
        return _SelectMgr.NCollection_List_Handle_SelectMgr_TriangularFrustum_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_List_Handle_SelectMgr_TriangularFrustum self, NCollection_List_Handle_SelectMgr_TriangularFrustum theOther) -> NCollection_List_Handle_SelectMgr_TriangularFrustum

        Replacement operator

        :type theOther: OCC.wrapper.NCollection.NCollection_List
        :rtype: OCC.wrapper.NCollection.NCollection_List

        """
        return _SelectMgr.NCollection_List_Handle_SelectMgr_TriangularFrustum_assign(self, *args)


    def Clear(self, *args):
        """
        Clear(NCollection_List_Handle_SelectMgr_TriangularFrustum self, Handle_NCollection_BaseAllocator theAllocator=0)

        Clear this list

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _SelectMgr.NCollection_List_Handle_SelectMgr_TriangularFrustum_Clear(self, *args)


    def First(self, *args):
        """
        First item

        :rtype: const TheItemType &

        """
        res = _SelectMgr.NCollection_List_Handle_SelectMgr_TriangularFrustum_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Last(self, *args):
        """
        Last item

        :rtype: const TheItemType &

        """
        res = _SelectMgr.NCollection_List_Handle_SelectMgr_TriangularFrustum_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Append(self, *args):
        """
        Append(NCollection_List_Handle_SelectMgr_TriangularFrustum self, Handle_SelectMgr_TriangularFrustum theItem) -> Handle_SelectMgr_TriangularFrustum
        Append(NCollection_List_Handle_SelectMgr_TriangularFrustum self, Handle_SelectMgr_TriangularFrustum theItem, NCollection_List< opencascade::handle< SelectMgr_TriangularFrustum > >::Iterator & theIter)
        Append(NCollection_List_Handle_SelectMgr_TriangularFrustum self, NCollection_List_Handle_SelectMgr_TriangularFrustum theOther)

        Append another list at the end

        :type theOther: OCC.wrapper.NCollection.NCollection_List

        """
        return _SelectMgr.NCollection_List_Handle_SelectMgr_TriangularFrustum_Append(self, *args)


    def Prepend(self, *args):
        """
        Prepend(NCollection_List_Handle_SelectMgr_TriangularFrustum self, Handle_SelectMgr_TriangularFrustum theItem) -> Handle_SelectMgr_TriangularFrustum
        Prepend(NCollection_List_Handle_SelectMgr_TriangularFrustum self, NCollection_List_Handle_SelectMgr_TriangularFrustum theOther)

        Prepend another list at the beginning

        :type theOther: OCC.wrapper.NCollection.NCollection_List

        """
        return _SelectMgr.NCollection_List_Handle_SelectMgr_TriangularFrustum_Prepend(self, *args)


    def RemoveFirst(self, *args):
        """
        RemoveFirst(NCollection_List_Handle_SelectMgr_TriangularFrustum self)

        RemoveFirst item


        """
        return _SelectMgr.NCollection_List_Handle_SelectMgr_TriangularFrustum_RemoveFirst(self, *args)


    def Remove(self, *args):
        """
        Remove(NCollection_List_Handle_SelectMgr_TriangularFrustum self, NCollection_List< opencascade::handle< SelectMgr_TriangularFrustum > >::Iterator & theIter)

        Remove item pointed by iterator theIter; 
        theIter is then set to the next item

        :type theIter: Iterator

        """
        return _SelectMgr.NCollection_List_Handle_SelectMgr_TriangularFrustum_Remove(self, *args)


    def InsertBefore(self, *args):
        """
        InsertBefore(NCollection_List_Handle_SelectMgr_TriangularFrustum self, Handle_SelectMgr_TriangularFrustum theItem, NCollection_List< opencascade::handle< SelectMgr_TriangularFrustum > >::Iterator & theIter) -> Handle_SelectMgr_TriangularFrustum
        InsertBefore(NCollection_List_Handle_SelectMgr_TriangularFrustum self, NCollection_List_Handle_SelectMgr_TriangularFrustum theOther, NCollection_List< opencascade::handle< SelectMgr_TriangularFrustum > >::Iterator & theIter)

        InsertBefore

        :type theOther: OCC.wrapper.NCollection.NCollection_List
        :type theIter: Iterator

        """
        return _SelectMgr.NCollection_List_Handle_SelectMgr_TriangularFrustum_InsertBefore(self, *args)


    def InsertAfter(self, *args):
        """
        InsertAfter(NCollection_List_Handle_SelectMgr_TriangularFrustum self, Handle_SelectMgr_TriangularFrustum theItem, NCollection_List< opencascade::handle< SelectMgr_TriangularFrustum > >::Iterator & theIter) -> Handle_SelectMgr_TriangularFrustum
        InsertAfter(NCollection_List_Handle_SelectMgr_TriangularFrustum self, NCollection_List_Handle_SelectMgr_TriangularFrustum theOther, NCollection_List< opencascade::handle< SelectMgr_TriangularFrustum > >::Iterator & theIter)

        InsertAfter

        :type theOther: OCC.wrapper.NCollection.NCollection_List
        :type theIter: Iterator

        """
        return _SelectMgr.NCollection_List_Handle_SelectMgr_TriangularFrustum_InsertAfter(self, *args)


    def Reverse(self, *args):
        """
        Reverse(NCollection_List_Handle_SelectMgr_TriangularFrustum self)

        Reverse the list


        """
        return _SelectMgr.NCollection_List_Handle_SelectMgr_TriangularFrustum_Reverse(self, *args)


    def __iter__(self):
        return _SelectMgr.NCollection_List_Handle_SelectMgr_TriangularFrustum___iter__(self)
    __swig_destroy__ = _SelectMgr.delete_NCollection_List_Handle_SelectMgr_TriangularFrustum
NCollection_List_Handle_SelectMgr_TriangularFrustum_swigregister = _SelectMgr.NCollection_List_Handle_SelectMgr_TriangularFrustum_swigregister
NCollection_List_Handle_SelectMgr_TriangularFrustum_swigregister(NCollection_List_Handle_SelectMgr_TriangularFrustum)

class NCollection_List_Handle_SelectMgr_TriangularFrustum_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _SelectMgr.new_NCollection_List_Handle_SelectMgr_TriangularFrustum_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SelectMgr.delete_NCollection_List_Handle_SelectMgr_TriangularFrustum_IteratorHelper

    def __next__(self):
        return _SelectMgr.NCollection_List_Handle_SelectMgr_TriangularFrustum_IteratorHelper___next__(self)
NCollection_List_Handle_SelectMgr_TriangularFrustum_IteratorHelper_swigregister = _SelectMgr.NCollection_List_Handle_SelectMgr_TriangularFrustum_IteratorHelper_swigregister
NCollection_List_Handle_SelectMgr_TriangularFrustum_IteratorHelper_swigregister(NCollection_List_Handle_SelectMgr_TriangularFrustum_IteratorHelper)


try:
	SelectMgr_TriangFrustums = NCollection_List_Handle_SelectMgr_TriangularFrustum
except NameError:
	pass # does not exist, probably ignored

class Handle_SelectMgr_EntityOwner(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_SelectMgr_EntityOwner self)

        Nullify the handle


        """
        return _SelectMgr.Handle_SelectMgr_EntityOwner_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_SelectMgr_EntityOwner self) -> bool

        Check for being null

        :rtype: bool

        """
        return _SelectMgr.Handle_SelectMgr_EntityOwner_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_SelectMgr_EntityOwner self, SelectMgr_EntityOwner thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _SelectMgr.Handle_SelectMgr_EntityOwner_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_SelectMgr_EntityOwner self, Handle_SelectMgr_EntityOwner theHandle) -> Handle_SelectMgr_EntityOwner
        assign(Handle_SelectMgr_EntityOwner self, SelectMgr_EntityOwner thePtr) -> Handle_SelectMgr_EntityOwner
        assign(Handle_SelectMgr_EntityOwner self, Handle_SelectMgr_EntityOwner theHandle) -> Handle_SelectMgr_EntityOwner

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _SelectMgr.Handle_SelectMgr_EntityOwner_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_SelectMgr_EntityOwner self) -> SelectMgr_EntityOwner

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _SelectMgr.Handle_SelectMgr_EntityOwner_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_SelectMgr_EntityOwner self) -> SelectMgr_EntityOwner

        Member access operator (note non-const)

        :rtype: T *

        """
        return _SelectMgr.Handle_SelectMgr_EntityOwner___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_SelectMgr_EntityOwner self) -> SelectMgr_EntityOwner

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _SelectMgr.Handle_SelectMgr_EntityOwner___ref__(self, *args)


    def __hash__(self):
        return _SelectMgr.Handle_SelectMgr_EntityOwner___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _SelectMgr.Handle_SelectMgr_EntityOwner___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _SelectMgr.new_Handle_SelectMgr_EntityOwner(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_SelectMgr.Handle_SelectMgr_EntityOwner_DownCast)
    __swig_destroy__ = _SelectMgr.delete_Handle_SelectMgr_EntityOwner

    def get_type_name(self, *args):
        """
        get_type_name(Handle_SelectMgr_EntityOwner self) -> char const *

        :rtype: const char *

        """
        return _SelectMgr.Handle_SelectMgr_EntityOwner_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _SelectMgr.Handle_SelectMgr_EntityOwner_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _SelectMgr.Handle_SelectMgr_EntityOwner_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def HasSelectable(self, *args):
        """
        HasSelectable(Handle_SelectMgr_EntityOwner self) -> Standard_Boolean

        Returns true if there is a selectable object to serve as an owner.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _SelectMgr.Handle_SelectMgr_EntityOwner_HasSelectable(self, *args)


    def Selectable(self, *args):
        """
        Selectable(Handle_SelectMgr_EntityOwner self) -> Handle_SelectMgr_SelectableObject

        Returns a selectable object detected in the working context.

        :rtype: OCC.wrapper.SelectMgr.Handle_SelectMgr_SelectableObject

        """
        return _SelectMgr.Handle_SelectMgr_EntityOwner_Selectable(self, *args)


    def SetSelectable(self, *args):
        """
        SetSelectable(Handle_SelectMgr_EntityOwner self, Handle_SelectMgr_SelectableObject theSelObj)

        Sets the selectable object.

        :type theSelObj: OCC.wrapper.SelectMgr.Handle_SelectMgr_SelectableObject

        """
        return _SelectMgr.Handle_SelectMgr_EntityOwner_SetSelectable(self, *args)


    def IsHilighted(self, *args):
        """
        IsHilighted(Handle_SelectMgr_EntityOwner self, Handle_PrsMgr_PresentationManager aPM, Standard_Integer const aMode=0) -> Standard_Boolean

        Returns true if the presentation manager aPM
        highlights selections corresponding to the selection mode aMode.

        :type aPM: OCC.wrapper.PrsMgr.Handle_PrsMgr_PresentationManager
        :type aMode: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _SelectMgr.Handle_SelectMgr_EntityOwner_IsHilighted(self, *args)


    def HilightWithColor(self, *args):
        """
        HilightWithColor(Handle_SelectMgr_EntityOwner self, Handle_PrsMgr_PresentationManager thePM, Handle_Prs3d_Drawer theStyle, Standard_Integer const theMode=0)

        Highlights selectable object's presentation with mode theMode in presentation manager
        with given highlight style. Also a check for auto-highlight is performed - if
        selectable object manages highlighting on its own, execution will be passed to
        SelectMgr_SelectableObject::HilightOwnerWithColor method

        :type thePM: OCC.wrapper.SelectMgr.Handle_PrsMgr_PresentationManager3d
        :type theStyle: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer
        :type theMode: int

        """
        return _SelectMgr.Handle_SelectMgr_EntityOwner_HilightWithColor(self, *args)


    def Unhilight(self, *args):
        """
        Unhilight(Handle_SelectMgr_EntityOwner self, Handle_PrsMgr_PresentationManager thePrsMgr, Standard_Integer const theMode=0)

        Removes highlighting from the owner of a detected selectable object in the presentation manager.
        This object could be the owner of a sensitive primitive.
        @param thePrsMgr presentation manager
        @param theMode   obsolete argument for compatibility, should be ignored by implementations

        :type thePrsMgr: OCC.wrapper.PrsMgr.Handle_PrsMgr_PresentationManager
        :type theMode: int

        """
        return _SelectMgr.Handle_SelectMgr_EntityOwner_Unhilight(self, *args)


    def Clear(self, *args):
        """
        Clear(Handle_SelectMgr_EntityOwner self, Handle_PrsMgr_PresentationManager aPM, Standard_Integer const aMode=0)

        Clears the owners matching the value of the selection
        mode aMode from the presentation manager object aPM.

        :type aPM: OCC.wrapper.PrsMgr.Handle_PrsMgr_PresentationManager
        :type aMode: int

        """
        return _SelectMgr.Handle_SelectMgr_EntityOwner_Clear(self, *args)


    def HasLocation(self, *args):
        """
        HasLocation(Handle_SelectMgr_EntityOwner self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _SelectMgr.Handle_SelectMgr_EntityOwner_HasLocation(self, *args)


    def SetLocation(self, *args):
        """
        SetLocation(Handle_SelectMgr_EntityOwner self, TopLoc_Location aLoc)

        :type aLoc: OCC.wrapper.TopLoc.TopLoc_Location

        """
        return _SelectMgr.Handle_SelectMgr_EntityOwner_SetLocation(self, *args)


    def ResetLocation(self, *args):
        """ResetLocation(Handle_SelectMgr_EntityOwner self)"""
        return _SelectMgr.Handle_SelectMgr_EntityOwner_ResetLocation(self, *args)


    def Location(self, *args):
        """
        Location(Handle_SelectMgr_EntityOwner self) -> TopLoc_Location

        :rtype: OCC.wrapper.TopLoc.TopLoc_Location

        """
        return _SelectMgr.Handle_SelectMgr_EntityOwner_Location(self, *args)


    def SetSelected(self, *args):
        """
        SetSelected(Handle_SelectMgr_EntityOwner self, Standard_Boolean const theIsSelected)

        Set the state of the owner.
        @param theIsSelected [in] shows if owner is selected.

        :type theIsSelected: bool

        """
        return _SelectMgr.Handle_SelectMgr_EntityOwner_SetSelected(self, *args)


    def IsSelected(self, *args):
        """
        IsSelected(Handle_SelectMgr_EntityOwner self) -> Standard_Boolean

        @return Standard_True if the owner is selected.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _SelectMgr.Handle_SelectMgr_EntityOwner_IsSelected(self, *args)


    def State(self, *args):
        """
        State(Handle_SelectMgr_EntityOwner self, Standard_Integer const theStatus)
        State(Handle_SelectMgr_EntityOwner self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _SelectMgr.Handle_SelectMgr_EntityOwner_State(self, *args)


    def IsAutoHilight(self, *args):
        """
        IsAutoHilight(Handle_SelectMgr_EntityOwner self) -> Standard_Boolean

        if owner is not auto hilighted, for group contains many such owners
        will be called one method HilightSelected of SelectableObject

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _SelectMgr.Handle_SelectMgr_EntityOwner_IsAutoHilight(self, *args)


    def IsForcedHilight(self, *args):
        """
        IsForcedHilight(Handle_SelectMgr_EntityOwner self) -> Standard_Boolean

        if this method returns TRUE the owner will allways call method
        Hilight for SelectableObject when the owner is detected. By default
        it always return FALSE.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _SelectMgr.Handle_SelectMgr_EntityOwner_IsForcedHilight(self, *args)


    def SetZLayer(self, *args):
        """
        SetZLayer(Handle_SelectMgr_EntityOwner self, Graphic3d_ZLayerId const theLayerId)

        Set Z layer ID and update all presentations.

        :type theLayerId: OCC.wrapper.Graphic3d.Graphic3d_ZLayerId

        """
        return _SelectMgr.Handle_SelectMgr_EntityOwner_SetZLayer(self, *args)


    def UpdateHighlightTrsf(self, *args):
        """
        UpdateHighlightTrsf(Handle_SelectMgr_EntityOwner self, Handle_V3d_Viewer theViewer, Handle_PrsMgr_PresentationManager theManager, Standard_Integer const theDispMode)

        Implements immediate application of location transformation of parent object to dynamic highlight structure

        :type theViewer: OCC.wrapper.V3d.Handle_V3d_Viewer
        :type theManager: OCC.wrapper.SelectMgr.Handle_PrsMgr_PresentationManager3d
        :type theDispMode: int

        """
        return _SelectMgr.Handle_SelectMgr_EntityOwner_UpdateHighlightTrsf(self, *args)


    def IsSameSelectable(self, *args):
        """
        IsSameSelectable(Handle_SelectMgr_EntityOwner self, Handle_SelectMgr_SelectableObject theOther) -> Standard_Boolean

        Returns true if pointer to selectable object of this owner is equal to the given one

        :type theOther: OCC.wrapper.SelectMgr.Handle_SelectMgr_SelectableObject
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _SelectMgr.Handle_SelectMgr_EntityOwner_IsSameSelectable(self, *args)


    def ComesFromDecomposition(self, *args):
        """
        ComesFromDecomposition(Handle_SelectMgr_EntityOwner self) -> Standard_Boolean

        Returns TRUE if this owner points to a part of object and FALSE for entire object.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _SelectMgr.Handle_SelectMgr_EntityOwner_ComesFromDecomposition(self, *args)


    def SetComesFromDecomposition(self, *args):
        """
        SetComesFromDecomposition(Handle_SelectMgr_EntityOwner self, Standard_Boolean const theIsFromDecomposition)

        Sets flag indicating this owner points to a part of object (TRUE) or to entire object (FALSE).

        :type theIsFromDecomposition: bool

        """
        return _SelectMgr.Handle_SelectMgr_EntityOwner_SetComesFromDecomposition(self, *args)


    def Set(self, *args):
        """
        Set(Handle_SelectMgr_EntityOwner self, Handle_SelectMgr_SelectableObject theSelObj)

        Sets the selectable object.

        :type theSelObj: OCC.wrapper.SelectMgr.Handle_SelectMgr_SelectableObject

        """
        return _SelectMgr.Handle_SelectMgr_EntityOwner_Set(self, *args)


    def SetPriority(self, *args):
        """
        SetPriority(Handle_SelectMgr_EntityOwner self, Standard_Integer const thePriority)

        sets the selectable priority of the owner

        :type thePriority: int

        """
        return _SelectMgr.Handle_SelectMgr_EntityOwner_SetPriority(self, *args)


    def Priority(self, *args):
        """
        Priority(Handle_SelectMgr_EntityOwner self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _SelectMgr.Handle_SelectMgr_EntityOwner_Priority(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_SelectMgr_EntityOwner self)

        Memory deallocator for transient classes


        """
        return _SelectMgr.Handle_SelectMgr_EntityOwner_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_SelectMgr_EntityOwner self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_SelectMgr_EntityOwner self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _SelectMgr.Handle_SelectMgr_EntityOwner_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_SelectMgr_EntityOwner self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_SelectMgr_EntityOwner self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _SelectMgr.Handle_SelectMgr_EntityOwner_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_SelectMgr_EntityOwner self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _SelectMgr.Handle_SelectMgr_EntityOwner_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_SelectMgr_EntityOwner self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _SelectMgr.Handle_SelectMgr_EntityOwner_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_SelectMgr_EntityOwner self)

        Increments the reference counter of this object


        """
        return _SelectMgr.Handle_SelectMgr_EntityOwner_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_SelectMgr_EntityOwner self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _SelectMgr.Handle_SelectMgr_EntityOwner_DecrementRefCounter(self, *args)

Handle_SelectMgr_EntityOwner_swigregister = _SelectMgr.Handle_SelectMgr_EntityOwner_swigregister
Handle_SelectMgr_EntityOwner_swigregister(Handle_SelectMgr_EntityOwner)

def Handle_SelectMgr_EntityOwner_DownCast(thing):
    return _SelectMgr.Handle_SelectMgr_EntityOwner_DownCast(thing)
Handle_SelectMgr_EntityOwner_DownCast = _SelectMgr.Handle_SelectMgr_EntityOwner_DownCast

class Handle_SelectMgr_FrustumBuilder(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_SelectMgr_FrustumBuilder self)

        Nullify the handle


        """
        return _SelectMgr.Handle_SelectMgr_FrustumBuilder_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_SelectMgr_FrustumBuilder self) -> bool

        Check for being null

        :rtype: bool

        """
        return _SelectMgr.Handle_SelectMgr_FrustumBuilder_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_SelectMgr_FrustumBuilder self, SelectMgr_FrustumBuilder thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _SelectMgr.Handle_SelectMgr_FrustumBuilder_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_SelectMgr_FrustumBuilder self, Handle_SelectMgr_FrustumBuilder theHandle) -> Handle_SelectMgr_FrustumBuilder
        assign(Handle_SelectMgr_FrustumBuilder self, SelectMgr_FrustumBuilder thePtr) -> Handle_SelectMgr_FrustumBuilder
        assign(Handle_SelectMgr_FrustumBuilder self, Handle_SelectMgr_FrustumBuilder theHandle) -> Handle_SelectMgr_FrustumBuilder

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _SelectMgr.Handle_SelectMgr_FrustumBuilder_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_SelectMgr_FrustumBuilder self) -> SelectMgr_FrustumBuilder

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _SelectMgr.Handle_SelectMgr_FrustumBuilder_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_SelectMgr_FrustumBuilder self) -> SelectMgr_FrustumBuilder

        Member access operator (note non-const)

        :rtype: T *

        """
        return _SelectMgr.Handle_SelectMgr_FrustumBuilder___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_SelectMgr_FrustumBuilder self) -> SelectMgr_FrustumBuilder

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _SelectMgr.Handle_SelectMgr_FrustumBuilder___ref__(self, *args)


    def __hash__(self):
        return _SelectMgr.Handle_SelectMgr_FrustumBuilder___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _SelectMgr.Handle_SelectMgr_FrustumBuilder___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _SelectMgr.new_Handle_SelectMgr_FrustumBuilder(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_SelectMgr.Handle_SelectMgr_FrustumBuilder_DownCast)
    __swig_destroy__ = _SelectMgr.delete_Handle_SelectMgr_FrustumBuilder

    def SetWorldViewMatrix(self, *args):
        """
        SetWorldViewMatrix(Handle_SelectMgr_FrustumBuilder self, NCollection_Mat4_Standard_Real theWorldViewMatrix)

        Stores current world view transformation matrix

        :type theWorldViewMatrix: OCC.wrapper.Graphic3d.Graphic3d_Mat4d

        """
        return _SelectMgr.Handle_SelectMgr_FrustumBuilder_SetWorldViewMatrix(self, *args)


    def WorldViewMatrix(self, *args):
        """
        @return current world view transformation matrix

        :rtype: OCC.wrapper.Graphic3d.Graphic3d_Mat4d

        """
        res = _SelectMgr.Handle_SelectMgr_FrustumBuilder_WorldViewMatrix(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetProjectionMatrix(self, *args):
        """
        SetProjectionMatrix(Handle_SelectMgr_FrustumBuilder self, NCollection_Mat4_Standard_Real theProjection)

        Stores current projection matrix

        :type theProjection: OCC.wrapper.Graphic3d.Graphic3d_Mat4d

        """
        return _SelectMgr.Handle_SelectMgr_FrustumBuilder_SetProjectionMatrix(self, *args)


    def ProjectionMatrix(self, *args):
        """
        @return current projection matrix

        :rtype: OCC.wrapper.Graphic3d.Graphic3d_Mat4d

        """
        res = _SelectMgr.Handle_SelectMgr_FrustumBuilder_ProjectionMatrix(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetWorldViewProjState(self, *args):
        """
        SetWorldViewProjState(Handle_SelectMgr_FrustumBuilder self, Graphic3d_WorldViewProjState theState)

        Stores current world view projection matrix state for the orientation and projection matrices

        :type theState: OCC.wrapper.Graphic3d.Graphic3d_WorldViewProjState

        """
        return _SelectMgr.Handle_SelectMgr_FrustumBuilder_SetWorldViewProjState(self, *args)


    def WorldViewProjState(self, *args):
        """
        @return current world view projection state

        :rtype: OCC.wrapper.Graphic3d.Graphic3d_WorldViewProjState

        """
        res = _SelectMgr.Handle_SelectMgr_FrustumBuilder_WorldViewProjState(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetWindowSize(self, *args):
        """
        SetWindowSize(Handle_SelectMgr_FrustumBuilder self, Standard_Integer const theWidth, Standard_Integer const theHeight)

        Stores current window width and height

        :type theWidth: int
        :type theHeight: int

        """
        return _SelectMgr.Handle_SelectMgr_FrustumBuilder_SetWindowSize(self, *args)


    def SetViewport(self, *args):
        """
        SetViewport(Handle_SelectMgr_FrustumBuilder self, Standard_Real const theX, Standard_Real const theY, Standard_Real const theWidth, Standard_Real const theHeight)

        Stores current viewport coordinates

        :type theX: float
        :type theY: float
        :type theWidth: float
        :type theHeight: float

        """
        return _SelectMgr.Handle_SelectMgr_FrustumBuilder_SetViewport(self, *args)


    def InvalidateViewport(self, *args):
        """InvalidateViewport(Handle_SelectMgr_FrustumBuilder self)"""
        return _SelectMgr.Handle_SelectMgr_FrustumBuilder_InvalidateViewport(self, *args)


    def WindowSize(self, *args):
        """
        WindowSize(Handle_SelectMgr_FrustumBuilder self)

        :type theWidth: int
        :type theHeight: int

        """
        return _SelectMgr.Handle_SelectMgr_FrustumBuilder_WindowSize(self, *args)


    def SignedPlanePntDist(self, *args):
        """
        SignedPlanePntDist(Handle_SelectMgr_FrustumBuilder self, NCollection_Vec3_Standard_Real theEq, NCollection_Vec3_Standard_Real thePnt) -> Standard_Real

        Calculates signed distance between plane with equation
        theEq and point thePnt

        :type theEq: OCC.wrapper.SelectMgr.SelectMgr_Vec3
        :type thePnt: OCC.wrapper.SelectMgr.SelectMgr_Vec3
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _SelectMgr.Handle_SelectMgr_FrustumBuilder_SignedPlanePntDist(self, *args)


    def ProjectPntOnViewPlane(self, *args):
        """
        ProjectPntOnViewPlane(Handle_SelectMgr_FrustumBuilder self, Standard_Real const & theX, Standard_Real const & theY, Standard_Real const & theZ) -> gp_Pnt

        Projects 2d screen point onto view frustum plane:
        theZ = 0 - near plane,
        theZ = 1 - far plane

        :type theX: float
        :type theY: float
        :type theZ: float
        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _SelectMgr.Handle_SelectMgr_FrustumBuilder_ProjectPntOnViewPlane(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_SelectMgr_FrustumBuilder self) -> char const *

        :rtype: const char *

        """
        return _SelectMgr.Handle_SelectMgr_FrustumBuilder_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _SelectMgr.Handle_SelectMgr_FrustumBuilder_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _SelectMgr.Handle_SelectMgr_FrustumBuilder_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_SelectMgr_FrustumBuilder self)

        Memory deallocator for transient classes


        """
        return _SelectMgr.Handle_SelectMgr_FrustumBuilder_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_SelectMgr_FrustumBuilder self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_SelectMgr_FrustumBuilder self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _SelectMgr.Handle_SelectMgr_FrustumBuilder_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_SelectMgr_FrustumBuilder self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_SelectMgr_FrustumBuilder self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _SelectMgr.Handle_SelectMgr_FrustumBuilder_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_SelectMgr_FrustumBuilder self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _SelectMgr.Handle_SelectMgr_FrustumBuilder_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_SelectMgr_FrustumBuilder self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _SelectMgr.Handle_SelectMgr_FrustumBuilder_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_SelectMgr_FrustumBuilder self)

        Increments the reference counter of this object


        """
        return _SelectMgr.Handle_SelectMgr_FrustumBuilder_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_SelectMgr_FrustumBuilder self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _SelectMgr.Handle_SelectMgr_FrustumBuilder_DecrementRefCounter(self, *args)

Handle_SelectMgr_FrustumBuilder_swigregister = _SelectMgr.Handle_SelectMgr_FrustumBuilder_swigregister
Handle_SelectMgr_FrustumBuilder_swigregister(Handle_SelectMgr_FrustumBuilder)

def Handle_SelectMgr_FrustumBuilder_DownCast(thing):
    return _SelectMgr.Handle_SelectMgr_FrustumBuilder_DownCast(thing)
Handle_SelectMgr_FrustumBuilder_DownCast = _SelectMgr.Handle_SelectMgr_FrustumBuilder_DownCast

class Handle_SelectMgr_SelectionManager(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_SelectMgr_SelectionManager self)

        Nullify the handle


        """
        return _SelectMgr.Handle_SelectMgr_SelectionManager_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_SelectMgr_SelectionManager self) -> bool

        Check for being null

        :rtype: bool

        """
        return _SelectMgr.Handle_SelectMgr_SelectionManager_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_SelectMgr_SelectionManager self, SelectMgr_SelectionManager thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _SelectMgr.Handle_SelectMgr_SelectionManager_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_SelectMgr_SelectionManager self, Handle_SelectMgr_SelectionManager theHandle) -> Handle_SelectMgr_SelectionManager
        assign(Handle_SelectMgr_SelectionManager self, SelectMgr_SelectionManager thePtr) -> Handle_SelectMgr_SelectionManager
        assign(Handle_SelectMgr_SelectionManager self, Handle_SelectMgr_SelectionManager theHandle) -> Handle_SelectMgr_SelectionManager

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _SelectMgr.Handle_SelectMgr_SelectionManager_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_SelectMgr_SelectionManager self) -> SelectMgr_SelectionManager

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _SelectMgr.Handle_SelectMgr_SelectionManager_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_SelectMgr_SelectionManager self) -> SelectMgr_SelectionManager

        Member access operator (note non-const)

        :rtype: T *

        """
        return _SelectMgr.Handle_SelectMgr_SelectionManager___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_SelectMgr_SelectionManager self) -> SelectMgr_SelectionManager

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _SelectMgr.Handle_SelectMgr_SelectionManager___ref__(self, *args)


    def __hash__(self):
        return _SelectMgr.Handle_SelectMgr_SelectionManager___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _SelectMgr.Handle_SelectMgr_SelectionManager___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _SelectMgr.new_Handle_SelectMgr_SelectionManager(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_SelectMgr.Handle_SelectMgr_SelectionManager_DownCast)
    __swig_destroy__ = _SelectMgr.delete_Handle_SelectMgr_SelectionManager

    def get_type_name(self, *args):
        """
        get_type_name(Handle_SelectMgr_SelectionManager self) -> char const *

        :rtype: const char *

        """
        return _SelectMgr.Handle_SelectMgr_SelectionManager_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _SelectMgr.Handle_SelectMgr_SelectionManager_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _SelectMgr.Handle_SelectMgr_SelectionManager_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Add(self, *args):
        """
        Add(Handle_SelectMgr_SelectionManager self, Handle_SelectMgr_ViewerSelector theSelector)

        Adds the viewer selector theSelector to the list of known items.

        :type theSelector: OCC.wrapper.SelectMgr.Handle_SelectMgr_ViewerSelector

        """
        return _SelectMgr.Handle_SelectMgr_SelectionManager_Add(self, *args)


    def Remove(self, *args):
        """
        Remove(Handle_SelectMgr_SelectionManager self, Handle_SelectMgr_ViewerSelector theSelector)
        Remove(Handle_SelectMgr_SelectionManager self, Handle_SelectMgr_SelectableObject theObject)
        Remove(Handle_SelectMgr_SelectionManager self, Handle_SelectMgr_SelectableObject theObject, Handle_SelectMgr_ViewerSelector theSelector)

        Removes theObject from theSelector, does not clear selections and unbind theObject from context maps.

        :type theObject: OCC.wrapper.SelectMgr.Handle_SelectMgr_SelectableObject
        :type theSelector: OCC.wrapper.SelectMgr.Handle_SelectMgr_ViewerSelector

        """
        return _SelectMgr.Handle_SelectMgr_SelectionManager_Remove(self, *args)


    def Contains(self, *args):
        """
        Contains(Handle_SelectMgr_SelectionManager self, Handle_SelectMgr_ViewerSelector theSelector) -> Standard_Boolean
        Contains(Handle_SelectMgr_SelectionManager self, Handle_SelectMgr_SelectableObject theObject) -> Standard_Boolean

        Returns true if the manager contains the selectable object theObject.

        :type theObject: OCC.wrapper.SelectMgr.Handle_SelectMgr_SelectableObject
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _SelectMgr.Handle_SelectMgr_SelectionManager_Contains(self, *args)


    def Load(self, *args):
        """
        Load(Handle_SelectMgr_SelectionManager self, Handle_SelectMgr_SelectableObject theObject, Standard_Integer const theMode=-1)
        Load(Handle_SelectMgr_SelectionManager self, Handle_SelectMgr_SelectableObject theObject, Handle_SelectMgr_ViewerSelector theSelector, Standard_Integer const theMode=-1)

        Loads and computes selection mode theMode (if it is not equal to -1) and adds selectable object to BVH tree.
        Does not perform check of existence of theObject in global context before addition, but adds theSelector to local context.

        :type theObject: OCC.wrapper.SelectMgr.Handle_SelectMgr_SelectableObject
        :type theSelector: OCC.wrapper.SelectMgr.Handle_SelectMgr_ViewerSelector
        :type theMode: int

        """
        return _SelectMgr.Handle_SelectMgr_SelectionManager_Load(self, *args)


    def Activate(self, *args):
        """
        Activate(Handle_SelectMgr_SelectionManager self, Handle_SelectMgr_SelectableObject theObject, Standard_Integer const theMode=0, Handle_SelectMgr_ViewerSelector theSelector)

        Activates the selection mode theMode in the selector theSelector for the selectable object anObject.
        By default, theMode is equal to 0. If theSelector is set to default (NULL), the selection with the mode theMode
        will be activated in all the viewers available.

        :type theObject: OCC.wrapper.SelectMgr.Handle_SelectMgr_SelectableObject
        :type theMode: int
        :type theSelector: OCC.wrapper.SelectMgr.Handle_SelectMgr_ViewerSelector

        """
        return _SelectMgr.Handle_SelectMgr_SelectionManager_Activate(self, *args)


    def Deactivate(self, *args):
        """
        Deactivate(Handle_SelectMgr_SelectionManager self, Handle_SelectMgr_SelectableObject theObject, Standard_Integer const theMode=-1, Handle_SelectMgr_ViewerSelector theSelector)

        Deactivates mode theMode of theObject in theSelector. If theMode value is set to default (-1), all
        active selection modes will be deactivated. Likewise, if theSelector value is set to default (NULL), theMode
        will be deactivated in all viewer selectors.

        :type theObject: OCC.wrapper.SelectMgr.Handle_SelectMgr_SelectableObject
        :type theMode: int
        :type theSelector: OCC.wrapper.SelectMgr.Handle_SelectMgr_ViewerSelector

        """
        return _SelectMgr.Handle_SelectMgr_SelectionManager_Deactivate(self, *args)


    def IsActivated(self, *args):
        """
        IsActivated(Handle_SelectMgr_SelectionManager self, Handle_SelectMgr_SelectableObject theObject, Standard_Integer const theMode=-1, Handle_SelectMgr_ViewerSelector theSelector) -> Standard_Boolean

        Returns true if the selection with theMode is active for the selectable object theObject and selector theSelector.
        If all parameters are set to default values, it returns it there is any active selection in any known viewer selector for
        object theObject.

        :type theObject: OCC.wrapper.SelectMgr.Handle_SelectMgr_SelectableObject
        :type theMode: int
        :type theSelector: OCC.wrapper.SelectMgr.Handle_SelectMgr_ViewerSelector
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _SelectMgr.Handle_SelectMgr_SelectionManager_IsActivated(self, *args)


    def ClearSelectionStructures(self, *args):
        """
        ClearSelectionStructures(Handle_SelectMgr_SelectionManager self, Handle_SelectMgr_SelectableObject theObj, Standard_Integer const theMode=-1, Handle_SelectMgr_ViewerSelector theSelector)

        Removes sensitive entities from all viewer selectors
        after method Clear() was called to the selection they belonged to
        or it was recomputed somehow.

        :type theObj: OCC.wrapper.SelectMgr.Handle_SelectMgr_SelectableObject
        :type theMode: int
        :type theSelector: OCC.wrapper.SelectMgr.Handle_SelectMgr_ViewerSelector

        """
        return _SelectMgr.Handle_SelectMgr_SelectionManager_ClearSelectionStructures(self, *args)


    def RestoreSelectionStructures(self, *args):
        """
        RestoreSelectionStructures(Handle_SelectMgr_SelectionManager self, Handle_SelectMgr_SelectableObject theObj, Standard_Integer const theMode=-1, Handle_SelectMgr_ViewerSelector theSelector)

        Re-adds newly calculated sensitive  entities of recomputed selection
        defined by mode theMode to all viewer selectors contained that selection.

        :type theObj: OCC.wrapper.SelectMgr.Handle_SelectMgr_SelectableObject
        :type theMode: int
        :type theSelector: OCC.wrapper.SelectMgr.Handle_SelectMgr_ViewerSelector

        """
        return _SelectMgr.Handle_SelectMgr_SelectionManager_RestoreSelectionStructures(self, *args)


    def RecomputeSelection(self, *args):
        """
        RecomputeSelection(Handle_SelectMgr_SelectionManager self, Handle_SelectMgr_SelectableObject theObject, Standard_Boolean const theIsForce, Standard_Integer const theMode=-1)

        Recomputes activated selections of theObject for all known viewer selectors according to theMode specified.
        If theMode is set to default (-1), then all activated selections will be recomputed. If theIsForce is set to true,
        then selection mode theMode for object theObject will be recomputed regardless of its activation status.

        :type theObject: OCC.wrapper.SelectMgr.Handle_SelectMgr_SelectableObject
        :type theIsForce: bool
        :type theMode: int

        """
        return _SelectMgr.Handle_SelectMgr_SelectionManager_RecomputeSelection(self, *args)


    def Update(self, *args):
        """
        Update(Handle_SelectMgr_SelectionManager self, Handle_SelectMgr_SelectableObject theObject, Standard_Boolean const theIsForce)
        Update(Handle_SelectMgr_SelectionManager self, Handle_SelectMgr_SelectableObject theObject, Handle_SelectMgr_ViewerSelector theSelector, Standard_Boolean const theIsForce)

        Updates all selections of theObject in specified viewer selector according to its current update status.
        If theIsForce is set to true, the call is equal to recomputation.

        :type theObject: OCC.wrapper.SelectMgr.Handle_SelectMgr_SelectableObject
        :type theSelector: OCC.wrapper.SelectMgr.Handle_SelectMgr_ViewerSelector
        :type theIsForce: bool

        """
        return _SelectMgr.Handle_SelectMgr_SelectionManager_Update(self, *args)


    def SetUpdateMode(self, *args):
        """
        SetUpdateMode(Handle_SelectMgr_SelectionManager self, Handle_SelectMgr_SelectableObject theObject, SelectMgr_TypeOfUpdate const theType)
        SetUpdateMode(Handle_SelectMgr_SelectionManager self, Handle_SelectMgr_SelectableObject theObject, Standard_Integer const theMode, SelectMgr_TypeOfUpdate const theType)

        Sets type of update of selection with theMode of theObject to the given theType.

        :type theObject: OCC.wrapper.SelectMgr.Handle_SelectMgr_SelectableObject
        :type theMode: int
        :type theType: OCC.wrapper.SelectMgr.SelectMgr_TypeOfUpdate

        """
        return _SelectMgr.Handle_SelectMgr_SelectionManager_SetUpdateMode(self, *args)


    def SetSelectionSensitivity(self, *args):
        """
        SetSelectionSensitivity(Handle_SelectMgr_SelectionManager self, Handle_SelectMgr_SelectableObject theObject, Standard_Integer const theMode, Standard_Integer const theNewSens)

        Allows to manage sensitivity of a particular selection of interactive object theObject and
        changes previous sensitivity value of all sensitive entities in selection with theMode
        to the given theNewSensitivity.

        :type theObject: OCC.wrapper.SelectMgr.Handle_SelectMgr_SelectableObject
        :type theMode: int
        :type theNewSens: int

        """
        return _SelectMgr.Handle_SelectMgr_SelectionManager_SetSelectionSensitivity(self, *args)


    def UpdateSelection(self, *args):
        """
        UpdateSelection(Handle_SelectMgr_SelectionManager self, Handle_SelectMgr_SelectableObject theObj)

        Re-adds selectable object in BVHs in all viewer selectors.

        :type theObj: OCC.wrapper.SelectMgr.Handle_SelectMgr_SelectableObject

        """
        return _SelectMgr.Handle_SelectMgr_SelectionManager_UpdateSelection(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_SelectMgr_SelectionManager self)

        Memory deallocator for transient classes


        """
        return _SelectMgr.Handle_SelectMgr_SelectionManager_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_SelectMgr_SelectionManager self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_SelectMgr_SelectionManager self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _SelectMgr.Handle_SelectMgr_SelectionManager_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_SelectMgr_SelectionManager self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_SelectMgr_SelectionManager self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _SelectMgr.Handle_SelectMgr_SelectionManager_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_SelectMgr_SelectionManager self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _SelectMgr.Handle_SelectMgr_SelectionManager_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_SelectMgr_SelectionManager self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _SelectMgr.Handle_SelectMgr_SelectionManager_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_SelectMgr_SelectionManager self)

        Increments the reference counter of this object


        """
        return _SelectMgr.Handle_SelectMgr_SelectionManager_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_SelectMgr_SelectionManager self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _SelectMgr.Handle_SelectMgr_SelectionManager_DecrementRefCounter(self, *args)

Handle_SelectMgr_SelectionManager_swigregister = _SelectMgr.Handle_SelectMgr_SelectionManager_swigregister
Handle_SelectMgr_SelectionManager_swigregister(Handle_SelectMgr_SelectionManager)

def Handle_SelectMgr_SelectionManager_DownCast(thing):
    return _SelectMgr.Handle_SelectMgr_SelectionManager_DownCast(thing)
Handle_SelectMgr_SelectionManager_DownCast = _SelectMgr.Handle_SelectMgr_SelectionManager_DownCast

class Handle_SelectMgr_Filter(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_SelectMgr_Filter self)

        Nullify the handle


        """
        return _SelectMgr.Handle_SelectMgr_Filter_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_SelectMgr_Filter self) -> bool

        Check for being null

        :rtype: bool

        """
        return _SelectMgr.Handle_SelectMgr_Filter_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_SelectMgr_Filter self, SelectMgr_Filter thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _SelectMgr.Handle_SelectMgr_Filter_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_SelectMgr_Filter self, Handle_SelectMgr_Filter theHandle) -> Handle_SelectMgr_Filter
        assign(Handle_SelectMgr_Filter self, SelectMgr_Filter thePtr) -> Handle_SelectMgr_Filter
        assign(Handle_SelectMgr_Filter self, Handle_SelectMgr_Filter theHandle) -> Handle_SelectMgr_Filter

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _SelectMgr.Handle_SelectMgr_Filter_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_SelectMgr_Filter self) -> SelectMgr_Filter

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _SelectMgr.Handle_SelectMgr_Filter_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_SelectMgr_Filter self) -> SelectMgr_Filter

        Member access operator (note non-const)

        :rtype: T *

        """
        return _SelectMgr.Handle_SelectMgr_Filter___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_SelectMgr_Filter self) -> SelectMgr_Filter

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _SelectMgr.Handle_SelectMgr_Filter___ref__(self, *args)


    def __hash__(self):
        return _SelectMgr.Handle_SelectMgr_Filter___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _SelectMgr.Handle_SelectMgr_Filter___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _SelectMgr.new_Handle_SelectMgr_Filter(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_SelectMgr.Handle_SelectMgr_Filter_DownCast)
    __swig_destroy__ = _SelectMgr.delete_Handle_SelectMgr_Filter

    def IsOk(self, *args):
        """
        IsOk(Handle_SelectMgr_Filter self, Handle_SelectMgr_EntityOwner anObj) -> Standard_Boolean

        Indicates that the selected Interactive Object
        passes the filter. The owner, anObj, can be either
        direct or user. A direct owner is the corresponding
        construction element, whereas a user is the
        compound shape of which the entity forms a part.
        When an object is detected by the mouse - in AIS,
        this is done through a context selector - its owner
        is passed to the filter as an argument.
        If the object returns Standard_True, it is kept; if
        not, it is rejected.
        If you are creating a filter class inheriting this
        framework, and the daughter class is to be used in
        an AIS local context, you will need to implement the
        virtual function ActsOn.

        :type anObj: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _SelectMgr.Handle_SelectMgr_Filter_IsOk(self, *args)


    def ActsOn(self, *args):
        """
        ActsOn(Handle_SelectMgr_Filter self, TopAbs_ShapeEnum const aStandardMode) -> Standard_Boolean

        Returns true in an AIS local context, if this filter
        operates on a type of subshape defined in a filter
        class inheriting this framework.
        This function completes IsOk in an AIS local context.

        :type aStandardMode: OCC.wrapper.TopAbs.TopAbs_ShapeEnum
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _SelectMgr.Handle_SelectMgr_Filter_ActsOn(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_SelectMgr_Filter self) -> char const *

        :rtype: const char *

        """
        return _SelectMgr.Handle_SelectMgr_Filter_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _SelectMgr.Handle_SelectMgr_Filter_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _SelectMgr.Handle_SelectMgr_Filter_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_SelectMgr_Filter self)

        Memory deallocator for transient classes


        """
        return _SelectMgr.Handle_SelectMgr_Filter_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_SelectMgr_Filter self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_SelectMgr_Filter self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _SelectMgr.Handle_SelectMgr_Filter_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_SelectMgr_Filter self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_SelectMgr_Filter self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _SelectMgr.Handle_SelectMgr_Filter_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_SelectMgr_Filter self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _SelectMgr.Handle_SelectMgr_Filter_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_SelectMgr_Filter self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _SelectMgr.Handle_SelectMgr_Filter_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_SelectMgr_Filter self)

        Increments the reference counter of this object


        """
        return _SelectMgr.Handle_SelectMgr_Filter_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_SelectMgr_Filter self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _SelectMgr.Handle_SelectMgr_Filter_DecrementRefCounter(self, *args)

Handle_SelectMgr_Filter_swigregister = _SelectMgr.Handle_SelectMgr_Filter_swigregister
Handle_SelectMgr_Filter_swigregister(Handle_SelectMgr_Filter)

def Handle_SelectMgr_Filter_DownCast(thing):
    return _SelectMgr.Handle_SelectMgr_Filter_DownCast(thing)
Handle_SelectMgr_Filter_DownCast = _SelectMgr.Handle_SelectMgr_Filter_DownCast

class NCollection_DataMap_Handle_SelectMgr_SelectableObject_SelectMgr_SequenceOfSelector_TColStd_MapTransientHasher(NCollection.NCollection_BaseMap):
    """
    Purpose:     The DataMap is a Map to store keys with associated
    Items. See Map  from NCollection for  a discussion
    about the number of buckets.

    The DataMap can be seen as an extended array where
    the Keys  are the   indices.  For this reason  the
    operator () is defined on DataMap to fetch an Item
    from a Key. So the following syntax can be used :

    anItem = aMap(aKey);
    aMap(aKey) = anItem;

    This analogy has its  limit.   aMap(aKey) = anItem
    can  be done only  if aKey was previously bound to
    an item in the map.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_DataMap_Handle_SelectMgr_SelectableObject_SelectMgr_SequenceOfSelector_TColStd_MapTransientHasher self) -> NCollection_DataMap< opencascade::handle< SelectMgr_SelectableObject >,SelectMgr_SequenceOfSelector,TColStd_MapTransientHasher >::iterator

        Returns an iterator pointing to the first element in the map.

        :rtype: iterator

        """
        return _SelectMgr.NCollection_DataMap_Handle_SelectMgr_SelectableObject_SelectMgr_SequenceOfSelector_TColStd_MapTransientHasher_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_DataMap_Handle_SelectMgr_SelectableObject_SelectMgr_SequenceOfSelector_TColStd_MapTransientHasher self) -> NCollection_DataMap< opencascade::handle< SelectMgr_SelectableObject >,SelectMgr_SequenceOfSelector,TColStd_MapTransientHasher >::iterator

        Returns an iterator referring to the past-the-end element in the map.

        :rtype: iterator

        """
        return _SelectMgr.NCollection_DataMap_Handle_SelectMgr_SelectableObject_SelectMgr_SequenceOfSelector_TColStd_MapTransientHasher_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_DataMap_Handle_SelectMgr_SelectableObject_SelectMgr_SequenceOfSelector_TColStd_MapTransientHasher self) -> NCollection_DataMap< opencascade::handle< SelectMgr_SelectableObject >,SelectMgr_SequenceOfSelector,TColStd_MapTransientHasher >::const_iterator

        Returns a const iterator pointing to the first element in the map.

        :rtype: const_iterator

        """
        return _SelectMgr.NCollection_DataMap_Handle_SelectMgr_SelectableObject_SelectMgr_SequenceOfSelector_TColStd_MapTransientHasher_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_DataMap_Handle_SelectMgr_SelectableObject_SelectMgr_SequenceOfSelector_TColStd_MapTransientHasher self) -> NCollection_DataMap< opencascade::handle< SelectMgr_SelectableObject >,SelectMgr_SequenceOfSelector,TColStd_MapTransientHasher >::const_iterator

        Returns a const iterator referring to the past-the-end element in the map.

        :rtype: const_iterator

        """
        return _SelectMgr.NCollection_DataMap_Handle_SelectMgr_SelectableObject_SelectMgr_SequenceOfSelector_TColStd_MapTransientHasher_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     The DataMap is a Map to store keys with associated
        Items. See Map  from NCollection for  a discussion
        about the number of buckets.

        The DataMap can be seen as an extended array where
        the Keys  are the   indices.  For this reason  the
        operator () is defined on DataMap to fetch an Item
        from a Key. So the following syntax can be used :

        anItem = aMap(aKey);
        aMap(aKey) = anItem;

        This analogy has its  limit.   aMap(aKey) = anItem
        can  be done only  if aKey was previously bound to
        an item in the map.
        """
        this = _SelectMgr.new_NCollection_DataMap_Handle_SelectMgr_SelectableObject_SelectMgr_SequenceOfSelector_TColStd_MapTransientHasher(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Exchange(self, *args):
        """
        Exchange(NCollection_DataMap_Handle_SelectMgr_SelectableObject_SelectMgr_SequenceOfSelector_TColStd_MapTransientHasher self, NCollection_DataMap_Handle_SelectMgr_SelectableObject_SelectMgr_SequenceOfSelector_TColStd_MapTransientHasher theOther)

        Exchange the content of two maps without re-allocations.
        Notice that allocators will be swapped as well!

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _SelectMgr.NCollection_DataMap_Handle_SelectMgr_SelectableObject_SelectMgr_SequenceOfSelector_TColStd_MapTransientHasher_Exchange(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_DataMap_Handle_SelectMgr_SelectableObject_SelectMgr_SequenceOfSelector_TColStd_MapTransientHasher self, NCollection_DataMap_Handle_SelectMgr_SelectableObject_SelectMgr_SequenceOfSelector_TColStd_MapTransientHasher theOther) -> NCollection_DataMap_Handle_SelectMgr_SelectableObject_SelectMgr_SequenceOfSelector_TColStd_MapTransientHasher

        Assignment.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _SelectMgr.NCollection_DataMap_Handle_SelectMgr_SelectableObject_SelectMgr_SequenceOfSelector_TColStd_MapTransientHasher_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_DataMap_Handle_SelectMgr_SelectableObject_SelectMgr_SequenceOfSelector_TColStd_MapTransientHasher self, NCollection_DataMap_Handle_SelectMgr_SelectableObject_SelectMgr_SequenceOfSelector_TColStd_MapTransientHasher theOther) -> NCollection_DataMap_Handle_SelectMgr_SelectableObject_SelectMgr_SequenceOfSelector_TColStd_MapTransientHasher

        Assignment operator

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _SelectMgr.NCollection_DataMap_Handle_SelectMgr_SelectableObject_SelectMgr_SequenceOfSelector_TColStd_MapTransientHasher_assign(self, *args)


    def ReSize(self, *args):
        """
        ReSize(NCollection_DataMap_Handle_SelectMgr_SelectableObject_SelectMgr_SequenceOfSelector_TColStd_MapTransientHasher self, Standard_Integer const N)

        ReSize

        :type N: int

        """
        return _SelectMgr.NCollection_DataMap_Handle_SelectMgr_SelectableObject_SelectMgr_SequenceOfSelector_TColStd_MapTransientHasher_ReSize(self, *args)


    def Bind(self, *args):
        """
        Bind(NCollection_DataMap_Handle_SelectMgr_SelectableObject_SelectMgr_SequenceOfSelector_TColStd_MapTransientHasher self, Handle_SelectMgr_SelectableObject theKey, NCollection_Sequence_Handle_SelectMgr_ViewerSelector theItem) -> Standard_Boolean

        Bind binds Item to Key in map.
        @param theKey  key to add/update
        @param theItem new item; overrides value previously bound to the key, if any
        @return Standard_True if Key was not bound already

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _SelectMgr.NCollection_DataMap_Handle_SelectMgr_SelectableObject_SelectMgr_SequenceOfSelector_TColStd_MapTransientHasher_Bind(self, *args)


    def Bound(self, *args):
        """
        Bound(NCollection_DataMap_Handle_SelectMgr_SelectableObject_SelectMgr_SequenceOfSelector_TColStd_MapTransientHasher self, Handle_SelectMgr_SelectableObject theKey, NCollection_Sequence_Handle_SelectMgr_ViewerSelector theItem) -> NCollection_Sequence_Handle_SelectMgr_ViewerSelector

        Bound binds Item to Key in map. Returns modifiable Item 

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: TheItemType *

        """
        return _SelectMgr.NCollection_DataMap_Handle_SelectMgr_SelectableObject_SelectMgr_SequenceOfSelector_TColStd_MapTransientHasher_Bound(self, *args)


    def IsBound(self, *args):
        """
        IsBound(NCollection_DataMap_Handle_SelectMgr_SelectableObject_SelectMgr_SequenceOfSelector_TColStd_MapTransientHasher self, Handle_SelectMgr_SelectableObject theKey) -> Standard_Boolean

        IsBound

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _SelectMgr.NCollection_DataMap_Handle_SelectMgr_SelectableObject_SelectMgr_SequenceOfSelector_TColStd_MapTransientHasher_IsBound(self, *args)


    def UnBind(self, *args):
        """
        UnBind(NCollection_DataMap_Handle_SelectMgr_SelectableObject_SelectMgr_SequenceOfSelector_TColStd_MapTransientHasher self, Handle_SelectMgr_SelectableObject theKey) -> Standard_Boolean

        UnBind removes Item Key pair from map

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _SelectMgr.NCollection_DataMap_Handle_SelectMgr_SelectableObject_SelectMgr_SequenceOfSelector_TColStd_MapTransientHasher_UnBind(self, *args)


    def Seek(self, *args):
        """
        Seek(NCollection_DataMap_Handle_SelectMgr_SelectableObject_SelectMgr_SequenceOfSelector_TColStd_MapTransientHasher self, Handle_SelectMgr_SelectableObject theKey) -> NCollection_Sequence_Handle_SelectMgr_ViewerSelector

        Seek returns pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: const TheItemType *

        """
        return _SelectMgr.NCollection_DataMap_Handle_SelectMgr_SelectableObject_SelectMgr_SequenceOfSelector_TColStd_MapTransientHasher_Seek(self, *args)


    def Find(self, *args):
        """
        Find returns the Item for Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _SelectMgr.NCollection_DataMap_Handle_SelectMgr_SelectableObject_SelectMgr_SequenceOfSelector_TColStd_MapTransientHasher_Find(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeSeek(self, *args):
        """
        ChangeSeek(NCollection_DataMap_Handle_SelectMgr_SelectableObject_SelectMgr_SequenceOfSelector_TColStd_MapTransientHasher self, Handle_SelectMgr_SelectableObject theKey) -> NCollection_Sequence_Handle_SelectMgr_ViewerSelector

        ChangeSeek returns modifiable pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: TheItemType *

        """
        return _SelectMgr.NCollection_DataMap_Handle_SelectMgr_SelectableObject_SelectMgr_SequenceOfSelector_TColStd_MapTransientHasher_ChangeSeek(self, *args)


    def ChangeFind(self, *args):
        """
        ChangeFind(NCollection_DataMap_Handle_SelectMgr_SelectableObject_SelectMgr_SequenceOfSelector_TColStd_MapTransientHasher self, Handle_SelectMgr_SelectableObject theKey) -> NCollection_Sequence_Handle_SelectMgr_ViewerSelector

        ChangeFind returns mofifiable Item by Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: TheItemType &

        """
        return _SelectMgr.NCollection_DataMap_Handle_SelectMgr_SelectableObject_SelectMgr_SequenceOfSelector_TColStd_MapTransientHasher_ChangeFind(self, *args)


    def __call__(self, *args):
        """
        operator ()

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _SelectMgr.NCollection_DataMap_Handle_SelectMgr_SelectableObject_SelectMgr_SequenceOfSelector_TColStd_MapTransientHasher___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Clear(self, *args):
        """
        Clear(NCollection_DataMap_Handle_SelectMgr_SelectableObject_SelectMgr_SequenceOfSelector_TColStd_MapTransientHasher self, Standard_Boolean const doReleaseMemory)
        Clear(NCollection_DataMap_Handle_SelectMgr_SelectableObject_SelectMgr_SequenceOfSelector_TColStd_MapTransientHasher self, Handle_NCollection_BaseAllocator theAllocator)

        Clear data and reset allocator

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _SelectMgr.NCollection_DataMap_Handle_SelectMgr_SelectableObject_SelectMgr_SequenceOfSelector_TColStd_MapTransientHasher_Clear(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_DataMap_Handle_SelectMgr_SelectableObject_SelectMgr_SequenceOfSelector_TColStd_MapTransientHasher self) -> Standard_Integer

        Size

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _SelectMgr.NCollection_DataMap_Handle_SelectMgr_SelectableObject_SelectMgr_SequenceOfSelector_TColStd_MapTransientHasher_Size(self, *args)


    def __iter__(self):
        return _SelectMgr.NCollection_DataMap_Handle_SelectMgr_SelectableObject_SelectMgr_SequenceOfSelector_TColStd_MapTransientHasher___iter__(self)
    __swig_destroy__ = _SelectMgr.delete_NCollection_DataMap_Handle_SelectMgr_SelectableObject_SelectMgr_SequenceOfSelector_TColStd_MapTransientHasher
NCollection_DataMap_Handle_SelectMgr_SelectableObject_SelectMgr_SequenceOfSelector_TColStd_MapTransientHasher_swigregister = _SelectMgr.NCollection_DataMap_Handle_SelectMgr_SelectableObject_SelectMgr_SequenceOfSelector_TColStd_MapTransientHasher_swigregister
NCollection_DataMap_Handle_SelectMgr_SelectableObject_SelectMgr_SequenceOfSelector_TColStd_MapTransientHasher_swigregister(NCollection_DataMap_Handle_SelectMgr_SelectableObject_SelectMgr_SequenceOfSelector_TColStd_MapTransientHasher)

class NCollection_DataMap_Handle_SelectMgr_SelectableObject_SelectMgr_SequenceOfSelector_TColStd_MapTransientHasher_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _SelectMgr.new_NCollection_DataMap_Handle_SelectMgr_SelectableObject_SelectMgr_SequenceOfSelector_TColStd_MapTransientHasher_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SelectMgr.delete_NCollection_DataMap_Handle_SelectMgr_SelectableObject_SelectMgr_SequenceOfSelector_TColStd_MapTransientHasher_IteratorHelper

    def __next__(self):
        return _SelectMgr.NCollection_DataMap_Handle_SelectMgr_SelectableObject_SelectMgr_SequenceOfSelector_TColStd_MapTransientHasher_IteratorHelper___next__(self)
NCollection_DataMap_Handle_SelectMgr_SelectableObject_SelectMgr_SequenceOfSelector_TColStd_MapTransientHasher_IteratorHelper_swigregister = _SelectMgr.NCollection_DataMap_Handle_SelectMgr_SelectableObject_SelectMgr_SequenceOfSelector_TColStd_MapTransientHasher_IteratorHelper_swigregister
NCollection_DataMap_Handle_SelectMgr_SelectableObject_SelectMgr_SequenceOfSelector_TColStd_MapTransientHasher_IteratorHelper_swigregister(NCollection_DataMap_Handle_SelectMgr_SelectableObject_SelectMgr_SequenceOfSelector_TColStd_MapTransientHasher_IteratorHelper)


try:
	SelectMgr_DataMapOfObjectSelectors = NCollection_DataMap_Handle_SelectMgr_SelectableObject_SelectMgr_SequenceOfSelector_TColStd_MapTransientHasher
except NameError:
	pass # does not exist, probably ignored


try:
	base_type = SelectMgr_Frustum_
except NameError:
	pass # does not exist, probably ignored

class SelectMgr_SelectingVolumeManager(SelectBasics.SelectBasics_SelectingVolumeManager):
    """
    This class is used to switch between active selecting volumes depending
    on selection type chosen by the user
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(SelectMgr_SelectingVolumeManager self, Standard_Boolean theToAllocateFrustums) -> SelectMgr_SelectingVolumeManager

        Creates instances of all available selecting volume types

        :type theToAllocateFrustums: bool

        """
        this = _SelectMgr.new_SelectMgr_SelectingVolumeManager(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def ScaleAndTransform(self, *args):
        """
        ScaleAndTransform(SelectMgr_SelectingVolumeManager self, Standard_Integer const theScaleFactor, gp_GTrsf theTrsf, Handle_SelectMgr_FrustumBuilder theBuilder=0) -> SelectMgr_SelectingVolumeManager

        IMPORTANT: Scaling makes sense only for frustum built on a single point!
        Note that this method does not perform any checks on type of the frustum.

        Returns a copy of the frustum resized according to the scale factor given
        and transforms it using the matrix given.
        There are no default parameters, but in case if:
        - transformation only is needed: @theScaleFactor must be initialized as any negative value;
        - scale only is needed: @theTrsf must be set to gp_Identity.
        Builder is an optional argument that represents corresponding settings for re-constructing transformed
        frustum from scratch. Can be null if reconstruction is not expected furthermore.

        :type theScaleFactor: int
        :type theTrsf: OCC.wrapper.gp.gp_GTrsf
        :type theBuilder: OCC.wrapper.SelectMgr.Handle_SelectMgr_FrustumBuilder
        :rtype: OCC.wrapper.SelectMgr.SelectMgr_SelectingVolumeManager

        """
        return _SelectMgr.SelectMgr_SelectingVolumeManager_ScaleAndTransform(self, *args)


    def GetActiveSelectionType(self, *args):
        """
        GetActiveSelectionType(SelectMgr_SelectingVolumeManager self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _SelectMgr.SelectMgr_SelectingVolumeManager_GetActiveSelectionType(self, *args)


    def SetActiveSelectionType(self, *args):
        """
        SetActiveSelectionType(SelectMgr_SelectingVolumeManager self, SelectBasics_SelectingVolumeManager::SelectionType const & theType)

        :type theType: SelectionType

        """
        return _SelectMgr.SelectMgr_SelectingVolumeManager_SetActiveSelectionType(self, *args)


    def Camera(self, *args):
        """
        Returns current camera definition.

        :rtype: OCC.wrapper.Graphic3d.Handle_Graphic3d_Camera

        """
        res = _SelectMgr.SelectMgr_SelectingVolumeManager_Camera(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetCamera(self, *args):
        """
        SetCamera(SelectMgr_SelectingVolumeManager self, Handle_Graphic3d_Camera theCamera)
        SetCamera(SelectMgr_SelectingVolumeManager self, NCollection_Mat4_Standard_Real theProjection, NCollection_Mat4_Standard_Real theWorldView, Standard_Boolean const theIsOrthographic, Graphic3d_WorldViewProjState theWVPState)

        Updates camera projection and orientation matrices in all selecting volumes

        :type theProjection: OCC.wrapper.Graphic3d.Graphic3d_Mat4d
        :type theWorldView: OCC.wrapper.Graphic3d.Graphic3d_Mat4d
        :type theIsOrthographic: bool
        :type theWVPState: OCC.wrapper.Graphic3d.Graphic3d_WorldViewProjState

        """
        return _SelectMgr.SelectMgr_SelectingVolumeManager_SetCamera(self, *args)


    def ProjectionMatrix(self, *args):
        """
        @return current projection transformation common for all selecting volumes

        :rtype: OCC.wrapper.Graphic3d.Graphic3d_Mat4d

        """
        res = _SelectMgr.SelectMgr_SelectingVolumeManager_ProjectionMatrix(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def WorldViewMatrix(self, *args):
        """
        @return current world view transformation common for all selecting volumes

        :rtype: OCC.wrapper.Graphic3d.Graphic3d_Mat4d

        """
        res = _SelectMgr.SelectMgr_SelectingVolumeManager_WorldViewMatrix(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def WindowSize(self, *args):
        """
        WindowSize(SelectMgr_SelectingVolumeManager self)

        :type theWidth: int
        :type theHeight: int

        """
        return _SelectMgr.SelectMgr_SelectingVolumeManager_WindowSize(self, *args)


    def WorldViewProjState(self, *args):
        """
        @return current camera world view projection transformation state common for all selecting volumes

        :rtype: OCC.wrapper.Graphic3d.Graphic3d_WorldViewProjState

        """
        res = _SelectMgr.SelectMgr_SelectingVolumeManager_WorldViewProjState(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetViewport(self, *args):
        """
        SetViewport(SelectMgr_SelectingVolumeManager self, Standard_Real const theX, Standard_Real const theY, Standard_Real const theWidth, Standard_Real const theHeight)

        Updates viewport in all selecting volumes

        :type theX: float
        :type theY: float
        :type theWidth: float
        :type theHeight: float

        """
        return _SelectMgr.SelectMgr_SelectingVolumeManager_SetViewport(self, *args)


    def SetPixelTolerance(self, *args):
        """
        SetPixelTolerance(SelectMgr_SelectingVolumeManager self, Standard_Integer const theTolerance)

        Updates pixel tolerance in all selecting volumes

        :type theTolerance: int

        """
        return _SelectMgr.SelectMgr_SelectingVolumeManager_SetPixelTolerance(self, *args)


    def SetWindowSize(self, *args):
        """
        SetWindowSize(SelectMgr_SelectingVolumeManager self, Standard_Integer const theWidth, Standard_Integer const theHeight)

        Updates window size in all selecting volumes

        :type theWidth: int
        :type theHeight: int

        """
        return _SelectMgr.SelectMgr_SelectingVolumeManager_SetWindowSize(self, *args)


    def BuildSelectingVolume(self, *args):
        """
        BuildSelectingVolume(SelectMgr_SelectingVolumeManager self, gp_Pnt2d thePoint)
        BuildSelectingVolume(SelectMgr_SelectingVolumeManager self, gp_Pnt2d theMinPt, gp_Pnt2d theMaxPt)
        BuildSelectingVolume(SelectMgr_SelectingVolumeManager self, NCollection_Array1_gp_Pnt2d thePoints)

        Builds set of triangular selecting frustums for polyline selection

        :type thePoints: OCC.wrapper.TColgp.TColgp_Array1OfPnt2d

        """
        return _SelectMgr.SelectMgr_SelectingVolumeManager_BuildSelectingVolume(self, *args)


    def Overlaps(self, *args):
        """
        Overlaps(SelectMgr_SelectingVolumeManager self, NCollection_Vec3_Standard_Real theBoxMin, NCollection_Vec3_Standard_Real theBoxMax) -> Standard_Boolean
        Overlaps(SelectMgr_SelectingVolumeManager self, NCollection_Vec3_Standard_Real theBoxMin, NCollection_Vec3_Standard_Real theBoxMax, Standard_Boolean * theInside=None) -> Standard_Boolean
        Overlaps(SelectMgr_SelectingVolumeManager self, gp_Pnt thePnt) -> Standard_Boolean
        Overlaps(SelectMgr_SelectingVolumeManager self, gp_Pnt thePnt) -> Standard_Boolean
        Overlaps(SelectMgr_SelectingVolumeManager self, Handle_TColgp_HArray1OfPnt theArrayOfPts, Standard_Integer theSensType) -> Standard_Boolean
        Overlaps(SelectMgr_SelectingVolumeManager self, NCollection_Array1_gp_Pnt theArrayOfPts, Standard_Integer theSensType) -> Standard_Boolean
        Overlaps(SelectMgr_SelectingVolumeManager self, gp_Pnt thePnt1, gp_Pnt thePnt2) -> Standard_Boolean
        Overlaps(SelectMgr_SelectingVolumeManager self, gp_Pnt thePnt1, gp_Pnt thePnt2, gp_Pnt thePnt3, Standard_Integer theSensType) -> Standard_Boolean

        SAT intersection test between defined volume and given triangle. The test may
        be considered of interior part or boundary line defined by triangle vertices
        depending on given sensitivity type

        :type thePnt1: OCC.wrapper.gp.gp_Pnt
        :type thePnt2: OCC.wrapper.gp.gp_Pnt
        :type thePnt3: OCC.wrapper.gp.gp_Pnt
        :type theSensType: int
        :type theDepth: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _SelectMgr.SelectMgr_SelectingVolumeManager_Overlaps(self, *args)


    def DistToGeometryCenter(self, *args):
        """
        DistToGeometryCenter(SelectMgr_SelectingVolumeManager self, gp_Pnt theCOG) -> Standard_Real

        Measures distance between 3d projection of user-picked
        screen point and given point theCOG

        :type theCOG: OCC.wrapper.gp.gp_Pnt
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _SelectMgr.SelectMgr_SelectingVolumeManager_DistToGeometryCenter(self, *args)


    def DetectedPoint(self, *args):
        """
        DetectedPoint(SelectMgr_SelectingVolumeManager self, Standard_Real const theDepth) -> gp_Pnt

        Calculates the point on a view ray that was detected during the run of selection algo by given depth.
        Throws exception if active selection type is not Point.

        :type theDepth: float
        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _SelectMgr.SelectMgr_SelectingVolumeManager_DetectedPoint(self, *args)


    def IsClipped(self, *args):
        """
        IsClipped(SelectMgr_SelectingVolumeManager self, Graphic3d_SequenceOfHClipPlane thePlanes, Standard_Real const & theDepth) -> Standard_Boolean

        Checks if the point of sensitive in which selection was detected belongs
        to the region defined by clipping planes

        :type thePlanes: OCC.wrapper.Graphic3d.Graphic3d_SequenceOfHClipPlane
        :type theDepth: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _SelectMgr.SelectMgr_SelectingVolumeManager_IsClipped(self, *args)


    def AllowOverlapDetection(self, *args):
        """
        AllowOverlapDetection(SelectMgr_SelectingVolumeManager self, Standard_Boolean const theIsToAllow)

        Is used for rectangular selection only
        If theIsToAllow is false, only fully included sensitives will be detected, otherwise the algorithm will
        mark both included and overlapped entities as matched

        :type theIsToAllow: bool

        """
        return _SelectMgr.SelectMgr_SelectingVolumeManager_AllowOverlapDetection(self, *args)


    def IsOverlapAllowed(self, *args):
        """
        IsOverlapAllowed(SelectMgr_SelectingVolumeManager self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _SelectMgr.SelectMgr_SelectingVolumeManager_IsOverlapAllowed(self, *args)


    def ViewClipping(self, *args):
        """
        Return view clipping planes.

        :rtype: OCC.wrapper.Graphic3d.Handle_Graphic3d_SequenceOfHClipPlane

        """
        res = _SelectMgr.SelectMgr_SelectingVolumeManager_ViewClipping(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetViewClipping(self, *args):
        """
        SetViewClipping(SelectMgr_SelectingVolumeManager self, Handle_Graphic3d_SequenceOfHClipPlane thePlanes)

        Valid for point selection only!
        Computes depth range for global (defined for the whole view) clipping planes.

        :type thePlanes: OCC.wrapper.Graphic3d.Handle_Graphic3d_SequenceOfHClipPlane

        """
        return _SelectMgr.SelectMgr_SelectingVolumeManager_SetViewClipping(self, *args)


    def SetViewClippingEnabled(self, *args):
        """
        SetViewClippingEnabled(SelectMgr_SelectingVolumeManager self, Standard_Boolean const theToEnable) -> Standard_Boolean

        Set if view clipping plane is enabled or not.
        @return previous flag value

        :type theToEnable: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _SelectMgr.SelectMgr_SelectingVolumeManager_SetViewClippingEnabled(self, *args)


    def GetVertices(self, *args):
        """
        GetVertices(SelectMgr_SelectingVolumeManager self) -> gp_Pnt

        A set of helper functions that return rectangular selecting frustum data

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _SelectMgr.SelectMgr_SelectingVolumeManager_GetVertices(self, *args)


    def GetNearPickedPnt(self, *args):
        """
        GetNearPickedPnt(SelectMgr_SelectingVolumeManager self) -> gp_Pnt

        Valid only for point and rectangular selection.
        Returns projection of 2d mouse picked point or projection
        of center of 2d rectangle (for point and rectangular selection
        correspondingly) onto near view frustum plane

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _SelectMgr.SelectMgr_SelectingVolumeManager_GetNearPickedPnt(self, *args)


    def GetFarPickedPnt(self, *args):
        """
        GetFarPickedPnt(SelectMgr_SelectingVolumeManager self) -> gp_Pnt

        Valid only for point and rectangular selection.
        Returns projection of 2d mouse picked point or projection
        of center of 2d rectangle (for point and rectangular selection
        correspondingly) onto far view frustum plane

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _SelectMgr.SelectMgr_SelectingVolumeManager_GetFarPickedPnt(self, *args)


    def ActiveVolume(self, *args):
        """
        ActiveVolume(SelectMgr_SelectingVolumeManager self) -> Handle_SelectMgr_BaseFrustum

        Returns active selecting volume that was built during last
        run of OCCT selection mechanism

        :rtype: OCC.wrapper.SelectMgr.Handle_SelectMgr_BaseFrustum

        """
        return _SelectMgr.SelectMgr_SelectingVolumeManager_ActiveVolume(self, *args)


    def GetPlanes(self, *args):
        """
        GetPlanes(SelectMgr_SelectingVolumeManager self, NCollection_Vector< SelectMgr_Vec4 > & thePlaneEquations)

        Stores plane equation coefficients (in the following form:
        Ax + By + Cz + D = 0) to the given vector

        :type thePlaneEquations: OCC.wrapper.SelectMgr.NCollection_Vector_SelectMgr_Vec4

        """
        return _SelectMgr.SelectMgr_SelectingVolumeManager_GetPlanes(self, *args)

    __swig_destroy__ = _SelectMgr.delete_SelectMgr_SelectingVolumeManager
SelectMgr_SelectingVolumeManager_swigregister = _SelectMgr.SelectMgr_SelectingVolumeManager_swigregister
SelectMgr_SelectingVolumeManager_swigregister(SelectMgr_SelectingVolumeManager)

class Handle_SelectMgr_AndFilter(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_SelectMgr_AndFilter self)

        Nullify the handle


        """
        return _SelectMgr.Handle_SelectMgr_AndFilter_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_SelectMgr_AndFilter self) -> bool

        Check for being null

        :rtype: bool

        """
        return _SelectMgr.Handle_SelectMgr_AndFilter_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_SelectMgr_AndFilter self, SelectMgr_AndFilter thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _SelectMgr.Handle_SelectMgr_AndFilter_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_SelectMgr_AndFilter self, Handle_SelectMgr_AndFilter theHandle) -> Handle_SelectMgr_AndFilter
        assign(Handle_SelectMgr_AndFilter self, SelectMgr_AndFilter thePtr) -> Handle_SelectMgr_AndFilter
        assign(Handle_SelectMgr_AndFilter self, Handle_SelectMgr_AndFilter theHandle) -> Handle_SelectMgr_AndFilter

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _SelectMgr.Handle_SelectMgr_AndFilter_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_SelectMgr_AndFilter self) -> SelectMgr_AndFilter

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _SelectMgr.Handle_SelectMgr_AndFilter_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_SelectMgr_AndFilter self) -> SelectMgr_AndFilter

        Member access operator (note non-const)

        :rtype: T *

        """
        return _SelectMgr.Handle_SelectMgr_AndFilter___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_SelectMgr_AndFilter self) -> SelectMgr_AndFilter

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _SelectMgr.Handle_SelectMgr_AndFilter___ref__(self, *args)


    def __hash__(self):
        return _SelectMgr.Handle_SelectMgr_AndFilter___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _SelectMgr.Handle_SelectMgr_AndFilter___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _SelectMgr.new_Handle_SelectMgr_AndFilter(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_SelectMgr.Handle_SelectMgr_AndFilter_DownCast)
    __swig_destroy__ = _SelectMgr.delete_Handle_SelectMgr_AndFilter

    def IsOk(self, *args):
        """
        IsOk(Handle_SelectMgr_AndFilter self, Handle_SelectMgr_EntityOwner anobj) -> Standard_Boolean

        :type anobj: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _SelectMgr.Handle_SelectMgr_AndFilter_IsOk(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_SelectMgr_AndFilter self) -> char const *

        :rtype: const char *

        """
        return _SelectMgr.Handle_SelectMgr_AndFilter_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _SelectMgr.Handle_SelectMgr_AndFilter_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _SelectMgr.Handle_SelectMgr_AndFilter_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Add(self, *args):
        """
        Add(Handle_SelectMgr_AndFilter self, Handle_SelectMgr_Filter afilter)

        Adds the filter afilter to a filter object created by a
        filter class inheriting this framework.

        :type afilter: OCC.wrapper.SelectMgr.Handle_SelectMgr_Filter

        """
        return _SelectMgr.Handle_SelectMgr_AndFilter_Add(self, *args)


    def Remove(self, *args):
        """
        Remove(Handle_SelectMgr_AndFilter self, Handle_SelectMgr_Filter aFilter)

        Removes the filter aFilter from this framework.

        :type aFilter: OCC.wrapper.SelectMgr.Handle_SelectMgr_Filter

        """
        return _SelectMgr.Handle_SelectMgr_AndFilter_Remove(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(Handle_SelectMgr_AndFilter self) -> Standard_Boolean

        Returns true if this framework is empty.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _SelectMgr.Handle_SelectMgr_AndFilter_IsEmpty(self, *args)


    def IsIn(self, *args):
        """
        IsIn(Handle_SelectMgr_AndFilter self, Handle_SelectMgr_Filter aFilter) -> Standard_Boolean

        Returns true if the filter aFilter is in this framework.

        :type aFilter: OCC.wrapper.SelectMgr.Handle_SelectMgr_Filter
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _SelectMgr.Handle_SelectMgr_AndFilter_IsIn(self, *args)


    def StoredFilters(self, *args):
        """
        Returns the list of stored filters from this framework.

        :rtype: OCC.wrapper.SelectMgr.SelectMgr_ListOfFilter

        """
        res = _SelectMgr.Handle_SelectMgr_AndFilter_StoredFilters(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Clear(self, *args):
        """
        Clear(Handle_SelectMgr_AndFilter self)

        Clears the filters used in this framework.


        """
        return _SelectMgr.Handle_SelectMgr_AndFilter_Clear(self, *args)


    def ActsOn(self, *args):
        """
        ActsOn(Handle_SelectMgr_AndFilter self, TopAbs_ShapeEnum const aStandardMode) -> Standard_Boolean

        :type aStandardMode: OCC.wrapper.TopAbs.TopAbs_ShapeEnum
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _SelectMgr.Handle_SelectMgr_AndFilter_ActsOn(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_SelectMgr_AndFilter self)

        Memory deallocator for transient classes


        """
        return _SelectMgr.Handle_SelectMgr_AndFilter_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_SelectMgr_AndFilter self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_SelectMgr_AndFilter self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _SelectMgr.Handle_SelectMgr_AndFilter_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_SelectMgr_AndFilter self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_SelectMgr_AndFilter self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _SelectMgr.Handle_SelectMgr_AndFilter_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_SelectMgr_AndFilter self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _SelectMgr.Handle_SelectMgr_AndFilter_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_SelectMgr_AndFilter self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _SelectMgr.Handle_SelectMgr_AndFilter_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_SelectMgr_AndFilter self)

        Increments the reference counter of this object


        """
        return _SelectMgr.Handle_SelectMgr_AndFilter_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_SelectMgr_AndFilter self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _SelectMgr.Handle_SelectMgr_AndFilter_DecrementRefCounter(self, *args)

Handle_SelectMgr_AndFilter_swigregister = _SelectMgr.Handle_SelectMgr_AndFilter_swigregister
Handle_SelectMgr_AndFilter_swigregister(Handle_SelectMgr_AndFilter)

def Handle_SelectMgr_AndFilter_DownCast(thing):
    return _SelectMgr.Handle_SelectMgr_AndFilter_DownCast(thing)
Handle_SelectMgr_AndFilter_DownCast = _SelectMgr.Handle_SelectMgr_AndFilter_DownCast

class NCollection_Sequence_Handle_SelectMgr_ViewerSelector(NCollection.NCollection_BaseSequence):
    """
    Purpose:     Definition of a sequence of elements indexed by
    an Integer in range of 1..n
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Sequence_Handle_SelectMgr_ViewerSelector self) -> NCollection_Sequence< opencascade::handle< SelectMgr_ViewerSelector > >::iterator

        Returns an iterator pointing to the first element in the sequence.

        :rtype: iterator

        """
        return _SelectMgr.NCollection_Sequence_Handle_SelectMgr_ViewerSelector_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Sequence_Handle_SelectMgr_ViewerSelector self) -> NCollection_Sequence< opencascade::handle< SelectMgr_ViewerSelector > >::iterator

        Returns an iterator referring to the past-the-end element in the sequence.

        :rtype: iterator

        """
        return _SelectMgr.NCollection_Sequence_Handle_SelectMgr_ViewerSelector_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Sequence_Handle_SelectMgr_ViewerSelector self) -> NCollection_Sequence< opencascade::handle< SelectMgr_ViewerSelector > >::const_iterator

        Returns a const iterator pointing to the first element in the sequence.

        :rtype: const_iterator

        """
        return _SelectMgr.NCollection_Sequence_Handle_SelectMgr_ViewerSelector_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Sequence_Handle_SelectMgr_ViewerSelector self) -> NCollection_Sequence< opencascade::handle< SelectMgr_ViewerSelector > >::const_iterator

        Returns a const iterator referring to the past-the-end element in the sequence.

        :rtype: const_iterator

        """
        return _SelectMgr.NCollection_Sequence_Handle_SelectMgr_ViewerSelector_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     Definition of a sequence of elements indexed by
        an Integer in range of 1..n
        """
        this = _SelectMgr.new_NCollection_Sequence_Handle_SelectMgr_ViewerSelector(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Size(self, *args):
        """
        Size(NCollection_Sequence_Handle_SelectMgr_ViewerSelector self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _SelectMgr.NCollection_Sequence_Handle_SelectMgr_ViewerSelector_Size(self, *args)


    def Length(self, *args):
        """
        Length(NCollection_Sequence_Handle_SelectMgr_ViewerSelector self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _SelectMgr.NCollection_Sequence_Handle_SelectMgr_ViewerSelector_Length(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Sequence_Handle_SelectMgr_ViewerSelector self) -> Standard_Integer

        Method for consistency with other collections.
        @return Lower bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _SelectMgr.NCollection_Sequence_Handle_SelectMgr_ViewerSelector_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Sequence_Handle_SelectMgr_ViewerSelector self) -> Standard_Integer

        Method for consistency with other collections.
        @return Upper bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _SelectMgr.NCollection_Sequence_Handle_SelectMgr_ViewerSelector_Upper(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Sequence_Handle_SelectMgr_ViewerSelector self) -> Standard_Boolean

        Empty query

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _SelectMgr.NCollection_Sequence_Handle_SelectMgr_ViewerSelector_IsEmpty(self, *args)


    def Reverse(self, *args):
        """
        Reverse(NCollection_Sequence_Handle_SelectMgr_ViewerSelector self)

        Reverse sequence


        """
        return _SelectMgr.NCollection_Sequence_Handle_SelectMgr_ViewerSelector_Reverse(self, *args)


    def Exchange(self, *args):
        """
        Exchange(NCollection_Sequence_Handle_SelectMgr_ViewerSelector self, Standard_Integer const I, Standard_Integer const J)

        Exchange two members

        :type I: int
        :type J: int

        """
        return _SelectMgr.NCollection_Sequence_Handle_SelectMgr_ViewerSelector_Exchange(self, *args)


    def delNode(*args):
        """
        delNode(NCollection_SeqNode theNode, Handle_NCollection_BaseAllocator theAl)

        Static deleter to be passed to BaseSequence

        :type theNode: OCC.wrapper.NCollection.NCollection_SeqNode
        :type theAl: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _SelectMgr.NCollection_Sequence_Handle_SelectMgr_ViewerSelector_delNode(*args)

    delNode = staticmethod(delNode)

    def Clear(self, *args):
        """
        Clear(NCollection_Sequence_Handle_SelectMgr_ViewerSelector self, Handle_NCollection_BaseAllocator theAllocator=0)

        Clear the items out, take a new allocator if non null

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _SelectMgr.NCollection_Sequence_Handle_SelectMgr_ViewerSelector_Clear(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Sequence_Handle_SelectMgr_ViewerSelector self, NCollection_Sequence_Handle_SelectMgr_ViewerSelector theOther) -> NCollection_Sequence_Handle_SelectMgr_ViewerSelector

        Replace this sequence by the items of theOther.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_Sequence
        :rtype: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _SelectMgr.NCollection_Sequence_Handle_SelectMgr_ViewerSelector_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Sequence_Handle_SelectMgr_ViewerSelector self, NCollection_Sequence_Handle_SelectMgr_ViewerSelector theOther) -> NCollection_Sequence_Handle_SelectMgr_ViewerSelector

        Replacement operator

        :type theOther: OCC.wrapper.NCollection.NCollection_Sequence
        :rtype: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _SelectMgr.NCollection_Sequence_Handle_SelectMgr_ViewerSelector_assign(self, *args)


    def Remove(self, *args):
        """
        Remove(NCollection_Sequence_Handle_SelectMgr_ViewerSelector self, NCollection_Sequence< opencascade::handle< SelectMgr_ViewerSelector > >::Iterator & thePosition)
        Remove(NCollection_Sequence_Handle_SelectMgr_ViewerSelector self, Standard_Integer const theIndex)
        Remove(NCollection_Sequence_Handle_SelectMgr_ViewerSelector self, Standard_Integer const theFromIndex, Standard_Integer const theToIndex)

        Remove range of items

        :type theFromIndex: int
        :type theToIndex: int

        """
        return _SelectMgr.NCollection_Sequence_Handle_SelectMgr_ViewerSelector_Remove(self, *args)


    def Append(self, *args):
        """
        Append(NCollection_Sequence_Handle_SelectMgr_ViewerSelector self, Handle_SelectMgr_ViewerSelector theItem)
        Append(NCollection_Sequence_Handle_SelectMgr_ViewerSelector self, NCollection_Sequence_Handle_SelectMgr_ViewerSelector theSeq)

        Append another sequence (making it empty)

        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _SelectMgr.NCollection_Sequence_Handle_SelectMgr_ViewerSelector_Append(self, *args)


    def Prepend(self, *args):
        """
        Prepend(NCollection_Sequence_Handle_SelectMgr_ViewerSelector self, Handle_SelectMgr_ViewerSelector theItem)
        Prepend(NCollection_Sequence_Handle_SelectMgr_ViewerSelector self, NCollection_Sequence_Handle_SelectMgr_ViewerSelector theSeq)

        Prepend another sequence (making it empty)

        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _SelectMgr.NCollection_Sequence_Handle_SelectMgr_ViewerSelector_Prepend(self, *args)


    def InsertBefore(self, *args):
        """
        InsertBefore(NCollection_Sequence_Handle_SelectMgr_ViewerSelector self, Standard_Integer const theIndex, Handle_SelectMgr_ViewerSelector theItem)
        InsertBefore(NCollection_Sequence_Handle_SelectMgr_ViewerSelector self, Standard_Integer const theIndex, NCollection_Sequence_Handle_SelectMgr_ViewerSelector theSeq)

        InsertBefore theIndex another sequence

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _SelectMgr.NCollection_Sequence_Handle_SelectMgr_ViewerSelector_InsertBefore(self, *args)


    def InsertAfter(self, *args):
        """
        InsertAfter(NCollection_Sequence_Handle_SelectMgr_ViewerSelector self, NCollection_Sequence< opencascade::handle< SelectMgr_ViewerSelector > >::Iterator & thePosition, Handle_SelectMgr_ViewerSelector theItem)
        InsertAfter(NCollection_Sequence_Handle_SelectMgr_ViewerSelector self, Standard_Integer const theIndex, NCollection_Sequence_Handle_SelectMgr_ViewerSelector theSeq)
        InsertAfter(NCollection_Sequence_Handle_SelectMgr_ViewerSelector self, Standard_Integer const theIndex, Handle_SelectMgr_ViewerSelector theItem)

        InsertAfter theIndex another sequence

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _SelectMgr.NCollection_Sequence_Handle_SelectMgr_ViewerSelector_InsertAfter(self, *args)


    def Split(self, *args):
        """
        Split(NCollection_Sequence_Handle_SelectMgr_ViewerSelector self, Standard_Integer const theIndex, NCollection_Sequence_Handle_SelectMgr_ViewerSelector theSeq)

        Split in two sequences

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _SelectMgr.NCollection_Sequence_Handle_SelectMgr_ViewerSelector_Split(self, *args)


    def First(self, *args):
        """
        First item access

        :rtype: const TheItemType &

        """
        res = _SelectMgr.NCollection_Sequence_Handle_SelectMgr_ViewerSelector_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Sequence_Handle_SelectMgr_ViewerSelector self) -> Handle_SelectMgr_ViewerSelector

        First item access

        :rtype: TheItemType &

        """
        return _SelectMgr.NCollection_Sequence_Handle_SelectMgr_ViewerSelector_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        Last item access

        :rtype: const TheItemType &

        """
        res = _SelectMgr.NCollection_Sequence_Handle_SelectMgr_ViewerSelector_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Sequence_Handle_SelectMgr_ViewerSelector self) -> Handle_SelectMgr_ViewerSelector

        Last item access

        :rtype: TheItemType &

        """
        return _SelectMgr.NCollection_Sequence_Handle_SelectMgr_ViewerSelector_ChangeLast(self, *args)


    def Value(self, *args):
        """
        Constant item access by theIndex

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _SelectMgr.NCollection_Sequence_Handle_SelectMgr_ViewerSelector_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Sequence_Handle_SelectMgr_ViewerSelector self, Standard_Integer const theIndex) -> Handle_SelectMgr_ViewerSelector

        Variable item access by theIndex

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _SelectMgr.NCollection_Sequence_Handle_SelectMgr_ViewerSelector_ChangeValue(self, *args)


    def __call__(self, *args):
        """
        Constant operator()

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _SelectMgr.NCollection_Sequence_Handle_SelectMgr_ViewerSelector___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetValue(self, *args):
        """
        SetValue(NCollection_Sequence_Handle_SelectMgr_ViewerSelector self, Standard_Integer const theIndex, Handle_SelectMgr_ViewerSelector theItem)

        Set item value by theIndex

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _SelectMgr.NCollection_Sequence_Handle_SelectMgr_ViewerSelector_SetValue(self, *args)


    def __iter__(self):
        return _SelectMgr.NCollection_Sequence_Handle_SelectMgr_ViewerSelector___iter__(self)
    __swig_destroy__ = _SelectMgr.delete_NCollection_Sequence_Handle_SelectMgr_ViewerSelector
NCollection_Sequence_Handle_SelectMgr_ViewerSelector_swigregister = _SelectMgr.NCollection_Sequence_Handle_SelectMgr_ViewerSelector_swigregister
NCollection_Sequence_Handle_SelectMgr_ViewerSelector_swigregister(NCollection_Sequence_Handle_SelectMgr_ViewerSelector)

def NCollection_Sequence_Handle_SelectMgr_ViewerSelector_delNode(*args):
    """
    NCollection_Sequence_Handle_SelectMgr_ViewerSelector_delNode(NCollection_SeqNode theNode, Handle_NCollection_BaseAllocator theAl)

    Static deleter to be passed to BaseSequence

    :type theNode: OCC.wrapper.NCollection.NCollection_SeqNode
    :type theAl: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

    """
    return _SelectMgr.NCollection_Sequence_Handle_SelectMgr_ViewerSelector_delNode(*args)

class NCollection_Sequence_Handle_SelectMgr_ViewerSelector_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _SelectMgr.new_NCollection_Sequence_Handle_SelectMgr_ViewerSelector_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SelectMgr.delete_NCollection_Sequence_Handle_SelectMgr_ViewerSelector_IteratorHelper

    def __next__(self):
        return _SelectMgr.NCollection_Sequence_Handle_SelectMgr_ViewerSelector_IteratorHelper___next__(self)
NCollection_Sequence_Handle_SelectMgr_ViewerSelector_IteratorHelper_swigregister = _SelectMgr.NCollection_Sequence_Handle_SelectMgr_ViewerSelector_IteratorHelper_swigregister
NCollection_Sequence_Handle_SelectMgr_ViewerSelector_IteratorHelper_swigregister(NCollection_Sequence_Handle_SelectMgr_ViewerSelector_IteratorHelper)


try:
	SelectMgr_SequenceOfSelector = NCollection_Sequence_Handle_SelectMgr_ViewerSelector
except NameError:
	pass # does not exist, probably ignored


try:
	SelectMgr_Vec4 = Graphic3d.NCollection_Vec4_Standard_Real
except AttributeError:
	pass # does not exist, probably ignored

class NCollection_IndexedDataMap_Handle_SelectBasics_EntityOwner_SelectMgr_SortCriterion_TColStd_MapTransientHasher(NCollection.NCollection_BaseMap):
    """
    Purpose:     An indexed map is used  to store keys and to  bind
    an index to them.  Each  new key stored in the map
    gets an index.  Index are  incremented as keys are
    stored in the map. A key can be found by the index
    and an index by the key.  No  key but the last can
    be  removed so the  indices   are in the range 1..
    Extent.  An Item is stored with each key.

    This   class is   similar  to  IndexedMap     from
    NCollection  with the Item as  a new feature. Note
    the important difference on  the operator  ().  In
    the IndexedMap this operator returns  the Key.  In
    the IndexedDataMap this operator returns the Item.

    See  the  class   Map   from NCollection   for   a
    discussion about the number of buckets.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_IndexedDataMap_Handle_SelectBasics_EntityOwner_SelectMgr_SortCriterion_TColStd_MapTransientHasher self) -> NCollection_IndexedDataMap< opencascade::handle< SelectBasics_EntityOwner >,SelectMgr_SortCriterion,TColStd_MapTransientHasher >::iterator

        Returns an iterator pointing to the first element in the map.

        :rtype: iterator

        """
        return _SelectMgr.NCollection_IndexedDataMap_Handle_SelectBasics_EntityOwner_SelectMgr_SortCriterion_TColStd_MapTransientHasher_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_IndexedDataMap_Handle_SelectBasics_EntityOwner_SelectMgr_SortCriterion_TColStd_MapTransientHasher self) -> NCollection_IndexedDataMap< opencascade::handle< SelectBasics_EntityOwner >,SelectMgr_SortCriterion,TColStd_MapTransientHasher >::iterator

        Returns an iterator referring to the past-the-end element in the map.

        :rtype: iterator

        """
        return _SelectMgr.NCollection_IndexedDataMap_Handle_SelectBasics_EntityOwner_SelectMgr_SortCriterion_TColStd_MapTransientHasher_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_IndexedDataMap_Handle_SelectBasics_EntityOwner_SelectMgr_SortCriterion_TColStd_MapTransientHasher self) -> NCollection_IndexedDataMap< opencascade::handle< SelectBasics_EntityOwner >,SelectMgr_SortCriterion,TColStd_MapTransientHasher >::const_iterator

        Returns a const iterator pointing to the first element in the map.

        :rtype: const_iterator

        """
        return _SelectMgr.NCollection_IndexedDataMap_Handle_SelectBasics_EntityOwner_SelectMgr_SortCriterion_TColStd_MapTransientHasher_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_IndexedDataMap_Handle_SelectBasics_EntityOwner_SelectMgr_SortCriterion_TColStd_MapTransientHasher self) -> NCollection_IndexedDataMap< opencascade::handle< SelectBasics_EntityOwner >,SelectMgr_SortCriterion,TColStd_MapTransientHasher >::const_iterator

        Returns a const iterator referring to the past-the-end element in the map.

        :rtype: const_iterator

        """
        return _SelectMgr.NCollection_IndexedDataMap_Handle_SelectBasics_EntityOwner_SelectMgr_SortCriterion_TColStd_MapTransientHasher_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     An indexed map is used  to store keys and to  bind
        an index to them.  Each  new key stored in the map
        gets an index.  Index are  incremented as keys are
        stored in the map. A key can be found by the index
        and an index by the key.  No  key but the last can
        be  removed so the  indices   are in the range 1..
        Extent.  An Item is stored with each key.

        This   class is   similar  to  IndexedMap     from
        NCollection  with the Item as  a new feature. Note
        the important difference on  the operator  ().  In
        the IndexedMap this operator returns  the Key.  In
        the IndexedDataMap this operator returns the Item.

        See  the  class   Map   from NCollection   for   a
        discussion about the number of buckets.
        """
        this = _SelectMgr.new_NCollection_IndexedDataMap_Handle_SelectBasics_EntityOwner_SelectMgr_SortCriterion_TColStd_MapTransientHasher(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Exchange(self, *args):
        """
        Exchange(NCollection_IndexedDataMap_Handle_SelectBasics_EntityOwner_SelectMgr_SortCriterion_TColStd_MapTransientHasher self, NCollection_IndexedDataMap_Handle_SelectBasics_EntityOwner_SelectMgr_SortCriterion_TColStd_MapTransientHasher theOther)

        Exchange the content of two maps without re-allocations.
        Notice that allocators will be swapped as well!

        :type theOther: OCC.wrapper.NCollection.NCollection_IndexedDataMap

        """
        return _SelectMgr.NCollection_IndexedDataMap_Handle_SelectBasics_EntityOwner_SelectMgr_SortCriterion_TColStd_MapTransientHasher_Exchange(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_IndexedDataMap_Handle_SelectBasics_EntityOwner_SelectMgr_SortCriterion_TColStd_MapTransientHasher self, NCollection_IndexedDataMap_Handle_SelectBasics_EntityOwner_SelectMgr_SortCriterion_TColStd_MapTransientHasher theOther) -> NCollection_IndexedDataMap_Handle_SelectBasics_EntityOwner_SelectMgr_SortCriterion_TColStd_MapTransientHasher

        Assignment.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_IndexedDataMap
        :rtype: OCC.wrapper.NCollection.NCollection_IndexedDataMap

        """
        return _SelectMgr.NCollection_IndexedDataMap_Handle_SelectBasics_EntityOwner_SelectMgr_SortCriterion_TColStd_MapTransientHasher_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_IndexedDataMap_Handle_SelectBasics_EntityOwner_SelectMgr_SortCriterion_TColStd_MapTransientHasher self, NCollection_IndexedDataMap_Handle_SelectBasics_EntityOwner_SelectMgr_SortCriterion_TColStd_MapTransientHasher theOther) -> NCollection_IndexedDataMap_Handle_SelectBasics_EntityOwner_SelectMgr_SortCriterion_TColStd_MapTransientHasher

        Assignment operator

        :type theOther: OCC.wrapper.NCollection.NCollection_IndexedDataMap
        :rtype: OCC.wrapper.NCollection.NCollection_IndexedDataMap

        """
        return _SelectMgr.NCollection_IndexedDataMap_Handle_SelectBasics_EntityOwner_SelectMgr_SortCriterion_TColStd_MapTransientHasher_assign(self, *args)


    def ReSize(self, *args):
        """
        ReSize(NCollection_IndexedDataMap_Handle_SelectBasics_EntityOwner_SelectMgr_SortCriterion_TColStd_MapTransientHasher self, Standard_Integer const N)

        ReSize

        :type N: int

        """
        return _SelectMgr.NCollection_IndexedDataMap_Handle_SelectBasics_EntityOwner_SelectMgr_SortCriterion_TColStd_MapTransientHasher_ReSize(self, *args)


    def Add(self, *args):
        """
        Add(NCollection_IndexedDataMap_Handle_SelectBasics_EntityOwner_SelectMgr_SortCriterion_TColStd_MapTransientHasher self, Handle_SelectBasics_EntityOwner theKey1, SelectMgr_SortCriterion theItem) -> Standard_Integer

        Returns the Index of already bound Key or appends new Key with specified Item value.
        @param theKey1 Key to search (and to bind, if it was not bound already)
        @param theItem Item value to set for newly bound Key; ignored if Key was already bound
        @return index of Key

        :type theKey1: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _SelectMgr.NCollection_IndexedDataMap_Handle_SelectBasics_EntityOwner_SelectMgr_SortCriterion_TColStd_MapTransientHasher_Add(self, *args)


    def Contains(self, *args):
        """
        Contains(NCollection_IndexedDataMap_Handle_SelectBasics_EntityOwner_SelectMgr_SortCriterion_TColStd_MapTransientHasher self, Handle_SelectBasics_EntityOwner theKey1) -> Standard_Boolean

        Contains

        :type theKey1: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _SelectMgr.NCollection_IndexedDataMap_Handle_SelectBasics_EntityOwner_SelectMgr_SortCriterion_TColStd_MapTransientHasher_Contains(self, *args)


    def Substitute(self, *args):
        """
        Substitute(NCollection_IndexedDataMap_Handle_SelectBasics_EntityOwner_SelectMgr_SortCriterion_TColStd_MapTransientHasher self, Standard_Integer const theIndex, Handle_SelectBasics_EntityOwner theKey1, SelectMgr_SortCriterion theItem)

        Substitute

        :type theIndex: int
        :type theKey1: const TheKeyType &
        :type theItem: const TheItemType &

        """
        return _SelectMgr.NCollection_IndexedDataMap_Handle_SelectBasics_EntityOwner_SelectMgr_SortCriterion_TColStd_MapTransientHasher_Substitute(self, *args)


    def Swap(self, *args):
        """
        Swap(NCollection_IndexedDataMap_Handle_SelectBasics_EntityOwner_SelectMgr_SortCriterion_TColStd_MapTransientHasher self, Standard_Integer const theIndex1, Standard_Integer const theIndex2)

        Swaps two elements with the given indices.

        :type theIndex1: int
        :type theIndex2: int

        """
        return _SelectMgr.NCollection_IndexedDataMap_Handle_SelectBasics_EntityOwner_SelectMgr_SortCriterion_TColStd_MapTransientHasher_Swap(self, *args)


    def RemoveLast(self, *args):
        """
        RemoveLast(NCollection_IndexedDataMap_Handle_SelectBasics_EntityOwner_SelectMgr_SortCriterion_TColStd_MapTransientHasher self)

        RemoveLast


        """
        return _SelectMgr.NCollection_IndexedDataMap_Handle_SelectBasics_EntityOwner_SelectMgr_SortCriterion_TColStd_MapTransientHasher_RemoveLast(self, *args)


    def RemoveFromIndex(self, *args):
        """
        RemoveFromIndex(NCollection_IndexedDataMap_Handle_SelectBasics_EntityOwner_SelectMgr_SortCriterion_TColStd_MapTransientHasher self, Standard_Integer const theIndex)

        Remove the key of the given index.
        Caution! The index of the last key can be changed.

        :type theIndex: int

        """
        return _SelectMgr.NCollection_IndexedDataMap_Handle_SelectBasics_EntityOwner_SelectMgr_SortCriterion_TColStd_MapTransientHasher_RemoveFromIndex(self, *args)


    def RemoveKey(self, *args):
        """
        RemoveKey(NCollection_IndexedDataMap_Handle_SelectBasics_EntityOwner_SelectMgr_SortCriterion_TColStd_MapTransientHasher self, Handle_SelectBasics_EntityOwner theKey1)

        Remove the given key.
        Caution! The index of the last key can be changed.

        :type theKey1: const TheKeyType &

        """
        return _SelectMgr.NCollection_IndexedDataMap_Handle_SelectBasics_EntityOwner_SelectMgr_SortCriterion_TColStd_MapTransientHasher_RemoveKey(self, *args)


    def FindKey(self, *args):
        """
        FindKey

        :type theIndex: int
        :rtype: const TheKeyType &

        """
        res = _SelectMgr.NCollection_IndexedDataMap_Handle_SelectBasics_EntityOwner_SelectMgr_SortCriterion_TColStd_MapTransientHasher_FindKey(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def FindFromIndex(self, *args):
        """
        FindFromIndex

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _SelectMgr.NCollection_IndexedDataMap_Handle_SelectBasics_EntityOwner_SelectMgr_SortCriterion_TColStd_MapTransientHasher_FindFromIndex(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFromIndex(self, *args):
        """
        ChangeFromIndex(NCollection_IndexedDataMap_Handle_SelectBasics_EntityOwner_SelectMgr_SortCriterion_TColStd_MapTransientHasher self, Standard_Integer const theIndex) -> SelectMgr_SortCriterion

        ChangeFromIndex

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _SelectMgr.NCollection_IndexedDataMap_Handle_SelectBasics_EntityOwner_SelectMgr_SortCriterion_TColStd_MapTransientHasher_ChangeFromIndex(self, *args)


    def __call__(self, *args):
        """
        operator ()

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _SelectMgr.NCollection_IndexedDataMap_Handle_SelectBasics_EntityOwner_SelectMgr_SortCriterion_TColStd_MapTransientHasher___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def FindIndex(self, *args):
        """
        FindIndex(NCollection_IndexedDataMap_Handle_SelectBasics_EntityOwner_SelectMgr_SortCriterion_TColStd_MapTransientHasher self, Handle_SelectBasics_EntityOwner theKey1) -> Standard_Integer

        FindIndex

        :type theKey1: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _SelectMgr.NCollection_IndexedDataMap_Handle_SelectBasics_EntityOwner_SelectMgr_SortCriterion_TColStd_MapTransientHasher_FindIndex(self, *args)


    def ChangeFromKey(self, *args):
        """
        ChangeFromKey(NCollection_IndexedDataMap_Handle_SelectBasics_EntityOwner_SelectMgr_SortCriterion_TColStd_MapTransientHasher self, Handle_SelectBasics_EntityOwner theKey1) -> SelectMgr_SortCriterion

        ChangeFromKey

        :type theKey1: const TheKeyType &
        :rtype: TheItemType &

        """
        return _SelectMgr.NCollection_IndexedDataMap_Handle_SelectBasics_EntityOwner_SelectMgr_SortCriterion_TColStd_MapTransientHasher_ChangeFromKey(self, *args)


    def Seek(self, *args):
        """
        Seek(NCollection_IndexedDataMap_Handle_SelectBasics_EntityOwner_SelectMgr_SortCriterion_TColStd_MapTransientHasher self, Handle_SelectBasics_EntityOwner theKey1) -> SelectMgr_SortCriterion

        Seek returns pointer to Item by Key. Returns
        NULL if Key was not found.

        :type theKey1: const TheKeyType &
        :rtype: const TheItemType *

        """
        return _SelectMgr.NCollection_IndexedDataMap_Handle_SelectBasics_EntityOwner_SelectMgr_SortCriterion_TColStd_MapTransientHasher_Seek(self, *args)


    def ChangeSeek(self, *args):
        """
        ChangeSeek(NCollection_IndexedDataMap_Handle_SelectBasics_EntityOwner_SelectMgr_SortCriterion_TColStd_MapTransientHasher self, Handle_SelectBasics_EntityOwner theKey1) -> SelectMgr_SortCriterion

        ChangeSeek returns modifiable pointer to Item by Key. Returns
        NULL if Key was not found.

        :type theKey1: const TheKeyType &
        :rtype: TheItemType *

        """
        return _SelectMgr.NCollection_IndexedDataMap_Handle_SelectBasics_EntityOwner_SelectMgr_SortCriterion_TColStd_MapTransientHasher_ChangeSeek(self, *args)


    def FindFromKey(self, *args):
        """
        FindFromKey

        :type theKey1: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _SelectMgr.NCollection_IndexedDataMap_Handle_SelectBasics_EntityOwner_SelectMgr_SortCriterion_TColStd_MapTransientHasher_FindFromKey(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Clear(self, *args):
        """
        Clear(NCollection_IndexedDataMap_Handle_SelectBasics_EntityOwner_SelectMgr_SortCriterion_TColStd_MapTransientHasher self, Standard_Boolean const doReleaseMemory)
        Clear(NCollection_IndexedDataMap_Handle_SelectBasics_EntityOwner_SelectMgr_SortCriterion_TColStd_MapTransientHasher self, Handle_NCollection_BaseAllocator theAllocator)

        Clear data and reset allocator

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _SelectMgr.NCollection_IndexedDataMap_Handle_SelectBasics_EntityOwner_SelectMgr_SortCriterion_TColStd_MapTransientHasher_Clear(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_IndexedDataMap_Handle_SelectBasics_EntityOwner_SelectMgr_SortCriterion_TColStd_MapTransientHasher self) -> Standard_Integer

        Size

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _SelectMgr.NCollection_IndexedDataMap_Handle_SelectBasics_EntityOwner_SelectMgr_SortCriterion_TColStd_MapTransientHasher_Size(self, *args)


    def __iter__(self):
        return _SelectMgr.NCollection_IndexedDataMap_Handle_SelectBasics_EntityOwner_SelectMgr_SortCriterion_TColStd_MapTransientHasher___iter__(self)
    __swig_destroy__ = _SelectMgr.delete_NCollection_IndexedDataMap_Handle_SelectBasics_EntityOwner_SelectMgr_SortCriterion_TColStd_MapTransientHasher
NCollection_IndexedDataMap_Handle_SelectBasics_EntityOwner_SelectMgr_SortCriterion_TColStd_MapTransientHasher_swigregister = _SelectMgr.NCollection_IndexedDataMap_Handle_SelectBasics_EntityOwner_SelectMgr_SortCriterion_TColStd_MapTransientHasher_swigregister
NCollection_IndexedDataMap_Handle_SelectBasics_EntityOwner_SelectMgr_SortCriterion_TColStd_MapTransientHasher_swigregister(NCollection_IndexedDataMap_Handle_SelectBasics_EntityOwner_SelectMgr_SortCriterion_TColStd_MapTransientHasher)

class NCollection_IndexedDataMap_Handle_SelectBasics_EntityOwner_SelectMgr_SortCriterion_TColStd_MapTransientHasher_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _SelectMgr.new_NCollection_IndexedDataMap_Handle_SelectBasics_EntityOwner_SelectMgr_SortCriterion_TColStd_MapTransientHasher_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SelectMgr.delete_NCollection_IndexedDataMap_Handle_SelectBasics_EntityOwner_SelectMgr_SortCriterion_TColStd_MapTransientHasher_IteratorHelper

    def __next__(self):
        return _SelectMgr.NCollection_IndexedDataMap_Handle_SelectBasics_EntityOwner_SelectMgr_SortCriterion_TColStd_MapTransientHasher_IteratorHelper___next__(self)
NCollection_IndexedDataMap_Handle_SelectBasics_EntityOwner_SelectMgr_SortCriterion_TColStd_MapTransientHasher_IteratorHelper_swigregister = _SelectMgr.NCollection_IndexedDataMap_Handle_SelectBasics_EntityOwner_SelectMgr_SortCriterion_TColStd_MapTransientHasher_IteratorHelper_swigregister
NCollection_IndexedDataMap_Handle_SelectBasics_EntityOwner_SelectMgr_SortCriterion_TColStd_MapTransientHasher_IteratorHelper_swigregister(NCollection_IndexedDataMap_Handle_SelectBasics_EntityOwner_SelectMgr_SortCriterion_TColStd_MapTransientHasher_IteratorHelper)


try:
	SelectMgr_IndexedDataMapOfOwnerCriterion = NCollection_IndexedDataMap_Handle_SelectBasics_EntityOwner_SelectMgr_SortCriterion_TColStd_MapTransientHasher
except NameError:
	pass # does not exist, probably ignored

class SelectMgr_SelectableObjectSet(object):
    """
    The purpose of this class is to organize all selectable objects into data structure, allowing to build 
    set of BVH trees for each transformation persistence subclass of selectable objects. This allow to minify
    number of updates for BVH trees - for example 2D persistent object subclass depends only on camera's projection
    and the corresponding BVH tree needs to be updated when camera's projection parameters change, while another
    tree for non-persistent objects can be left unchanged in this case.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    BVHSubset_3d = _SelectMgr.SelectMgr_SelectableObjectSet_BVHSubset_3d
    BVHSubset_3dPersistent = _SelectMgr.SelectMgr_SelectableObjectSet_BVHSubset_3dPersistent
    BVHSubset_2dPersistent = _SelectMgr.SelectMgr_SelectableObjectSet_BVHSubset_2dPersistent
    BVHSubsetNb = _SelectMgr.SelectMgr_SelectableObjectSet_BVHSubsetNb

    def __init__(self, *args):
        """
        __init__(SelectMgr_SelectableObjectSet self) -> SelectMgr_SelectableObjectSet

        Creates new empty objects set and initializes BVH tree builders for each subset.


        """
        this = _SelectMgr.new_SelectMgr_SelectableObjectSet(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Append(self, *args):
        """
        Append(SelectMgr_SelectableObjectSet self, Handle_SelectMgr_SelectableObject theObject) -> Standard_Boolean

        Adds the new selectable object to the set. The selectable object is placed into one of the
        predefined subsets depending on its persistence type. After adding an object, this method
        marks the corresponding BVH tree for rebuild.
        @return true if selectable object is added, otherwise returns false (selectable object is already in the set).

        :type theObject: OCC.wrapper.SelectMgr.Handle_SelectMgr_SelectableObject
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _SelectMgr.SelectMgr_SelectableObjectSet_Append(self, *args)


    def Remove(self, *args):
        """
        Remove(SelectMgr_SelectableObjectSet self, Handle_SelectMgr_SelectableObject theObject) -> Standard_Boolean

        Removes the selectable object from the set. The selectable object is removed from the subset
        it has been placed into. After removing an object, this method marks the corresponding
        BVH tree for rebuild.
        @return true if selectable object is removed, otherwise returns false (selectable object is not in the set).

        :type theObject: OCC.wrapper.SelectMgr.Handle_SelectMgr_SelectableObject
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _SelectMgr.SelectMgr_SelectableObjectSet_Remove(self, *args)


    def ChangeSubset(self, *args):
        """
        ChangeSubset(SelectMgr_SelectableObjectSet self, Handle_SelectMgr_SelectableObject theObject)

        Performs necessary updates when object's persistence types changes.
        This method should be called right after changing transformation persistence flags of the
        objects and before updating BVH tree - to provide up-to-date state of the object set.

        :type theObject: OCC.wrapper.SelectMgr.Handle_SelectMgr_SelectableObject

        """
        return _SelectMgr.SelectMgr_SelectableObjectSet_ChangeSubset(self, *args)


    def UpdateBVH(self, *args):
        """
        UpdateBVH(SelectMgr_SelectableObjectSet self, Handle_Graphic3d_Camera theCamera, NCollection_Mat4_Standard_Real theProjectionMat, NCollection_Mat4_Standard_Real theWorldViewMat, Graphic3d_WorldViewProjState theViewState, Standard_Integer const theViewportWidth, Standard_Integer const theViewportHeight)

        Updates outdated BVH trees and remembers the last state of the
        camera view-projection matrices and viewport (window) dimensions.

        :type theCamera: OCC.wrapper.Graphic3d.Handle_Graphic3d_Camera
        :type theProjectionMat: OCC.wrapper.Graphic3d.Graphic3d_Mat4d
        :type theWorldViewMat: OCC.wrapper.Graphic3d.Graphic3d_Mat4d
        :type theViewState: OCC.wrapper.Graphic3d.Graphic3d_WorldViewProjState
        :type theViewportWidth: int
        :type theViewportHeight: int

        """
        return _SelectMgr.SelectMgr_SelectableObjectSet_UpdateBVH(self, *args)


    def MarkDirty(self, *args):
        """
        MarkDirty(SelectMgr_SelectableObjectSet self)

        Marks every BVH subset for update.


        """
        return _SelectMgr.SelectMgr_SelectableObjectSet_MarkDirty(self, *args)


    def Contains(self, *args):
        """
        Contains(SelectMgr_SelectableObjectSet self, Handle_SelectMgr_SelectableObject theObject) -> Standard_Boolean

        Returns true if this objects set contains theObject given.

        :type theObject: OCC.wrapper.SelectMgr.Handle_SelectMgr_SelectableObject
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _SelectMgr.SelectMgr_SelectableObjectSet_Contains(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(SelectMgr_SelectableObjectSet self) -> Standard_Boolean
        IsEmpty(SelectMgr_SelectableObjectSet self, SelectMgr_SelectableObjectSet::BVHSubset const theSubset) -> Standard_Boolean

        Returns true if the specified object subset is empty.

        :type theSubset: BVHSubset
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _SelectMgr.SelectMgr_SelectableObjectSet_IsEmpty(self, *args)


    def GetObjectById(self, *args):
        """
        Returns object from subset theSubset by theIndex given. The method allows to get selectable object
        referred by the index of an element of the subset's BVH tree.

        :type theSubset: BVHSubset
        :type theIndex: int
        :rtype: OCC.wrapper.SelectMgr.Handle_SelectMgr_SelectableObject

        """
        res = _SelectMgr.SelectMgr_SelectableObjectSet_GetObjectById(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def BVH(self, *args):
        """
        Returns computed BVH for the theSubset given.

        :type theSubset: BVHSubset
        :rtype: OCC.wrapper.SelectMgr.Handle_BVH_Tree_Standard_Real

        """
        res = _SelectMgr.SelectMgr_SelectableObjectSet_BVH(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _SelectMgr.delete_SelectMgr_SelectableObjectSet
SelectMgr_SelectableObjectSet_swigregister = _SelectMgr.SelectMgr_SelectableObjectSet_swigregister
SelectMgr_SelectableObjectSet_swigregister(SelectMgr_SelectableObjectSet)

class NCollection_Vector_Handle_SelectMgr_SensitiveEntity(NCollection.NCollection_BaseVector):
    """
    Class NCollection_Vector (dynamic array of objects)

    This class is similar to NCollection_Array1  though the indices always start
    at 0 (in Array1 the first index must be specified)

    The Vector is always created with 0 length. It can be enlarged by two means:
    1. Calling the method Append (val) - then "val" is added to the end of the
    vector (the vector length is incremented)
    2. Calling the method SetValue (i, val)  - if "i" is greater than or equal
    to the current length of the vector,  the vector is enlarged to accomo-
    date this index

    The methods Append and SetValue return  a non-const reference  to the copied
    object  inside  the vector.  This reference  is guaranteed to be valid until
    the vector is destroyed. It can be used to access the vector member directly
    or to pass its address to other data structures.

    The vector iterator remembers the length of the vector  at the moment of the
    creation or initialisation of the iterator.   Therefore the iteration begins
    at index 0  and stops at the index equal to (remembered_length-1).  It is OK
    to enlarge the vector during the iteration.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Vector_Handle_SelectMgr_SensitiveEntity self) -> NCollection_Vector< opencascade::handle< SelectMgr_SensitiveEntity > >::iterator

        Returns an iterator pointing to the first element in the vector.

        :rtype: iterator

        """
        return _SelectMgr.NCollection_Vector_Handle_SelectMgr_SensitiveEntity_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Vector_Handle_SelectMgr_SensitiveEntity self) -> NCollection_Vector< opencascade::handle< SelectMgr_SensitiveEntity > >::iterator

        Returns an iterator referring to the past-the-end element in the vector.

        :rtype: iterator

        """
        return _SelectMgr.NCollection_Vector_Handle_SelectMgr_SensitiveEntity_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Vector_Handle_SelectMgr_SensitiveEntity self) -> NCollection_Vector< opencascade::handle< SelectMgr_SensitiveEntity > >::const_iterator

        Returns a const iterator pointing to the first element in the vector.

        :rtype: const_iterator

        """
        return _SelectMgr.NCollection_Vector_Handle_SelectMgr_SensitiveEntity_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Vector_Handle_SelectMgr_SensitiveEntity self) -> NCollection_Vector< opencascade::handle< SelectMgr_SensitiveEntity > >::const_iterator

        Returns a const iterator referring to the past-the-end element in the vector.

        :rtype: const_iterator

        """
        return _SelectMgr.NCollection_Vector_Handle_SelectMgr_SensitiveEntity_cend(self, *args)


    def __init__(self, *args):
        """
        Class NCollection_Vector (dynamic array of objects)

        This class is similar to NCollection_Array1  though the indices always start
        at 0 (in Array1 the first index must be specified)

        The Vector is always created with 0 length. It can be enlarged by two means:
        1. Calling the method Append (val) - then "val" is added to the end of the
        vector (the vector length is incremented)
        2. Calling the method SetValue (i, val)  - if "i" is greater than or equal
        to the current length of the vector,  the vector is enlarged to accomo-
        date this index

        The methods Append and SetValue return  a non-const reference  to the copied
        object  inside  the vector.  This reference  is guaranteed to be valid until
        the vector is destroyed. It can be used to access the vector member directly
        or to pass its address to other data structures.

        The vector iterator remembers the length of the vector  at the moment of the
        creation or initialisation of the iterator.   Therefore the iteration begins
        at index 0  and stops at the index equal to (remembered_length-1).  It is OK
        to enlarge the vector during the iteration.
        """
        this = _SelectMgr.new_NCollection_Vector_Handle_SelectMgr_SensitiveEntity(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Length(self, *args):
        """
        Length(NCollection_Vector_Handle_SelectMgr_SensitiveEntity self) -> Standard_Integer

        Total number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _SelectMgr.NCollection_Vector_Handle_SelectMgr_SensitiveEntity_Length(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_Vector_Handle_SelectMgr_SensitiveEntity self) -> Standard_Integer

        Total number of items in the vector

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _SelectMgr.NCollection_Vector_Handle_SelectMgr_SensitiveEntity_Size(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Vector_Handle_SelectMgr_SensitiveEntity self) -> Standard_Integer

        Method for consistency with other collections.
        @return Lower bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _SelectMgr.NCollection_Vector_Handle_SelectMgr_SensitiveEntity_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Vector_Handle_SelectMgr_SensitiveEntity self) -> Standard_Integer

        Method for consistency with other collections.
        @return Upper bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _SelectMgr.NCollection_Vector_Handle_SelectMgr_SensitiveEntity_Upper(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Vector_Handle_SelectMgr_SensitiveEntity self) -> Standard_Boolean

        Empty query

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _SelectMgr.NCollection_Vector_Handle_SelectMgr_SensitiveEntity_IsEmpty(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Vector_Handle_SelectMgr_SensitiveEntity self, NCollection_Vector_Handle_SelectMgr_SensitiveEntity theOther, Standard_Boolean const theOwnAllocator)

        Assignment to the collection of the same type

        :type theOther: OCC.wrapper.NCollection.NCollection_Vector
        :type theOwnAllocator: bool

        """
        return _SelectMgr.NCollection_Vector_Handle_SelectMgr_SensitiveEntity_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Vector_Handle_SelectMgr_SensitiveEntity self, NCollection_Vector_Handle_SelectMgr_SensitiveEntity theOther) -> NCollection_Vector_Handle_SelectMgr_SensitiveEntity

        Assignment operator

        :type theOther: OCC.wrapper.NCollection.NCollection_Vector
        :rtype: OCC.wrapper.NCollection.NCollection_Vector

        """
        return _SelectMgr.NCollection_Vector_Handle_SelectMgr_SensitiveEntity_assign(self, *args)


    def Append(self, *args):
        """
        Append(NCollection_Vector_Handle_SelectMgr_SensitiveEntity self, Handle_SelectMgr_SensitiveEntity theValue) -> Handle_SelectMgr_SensitiveEntity

        Append

        :type theValue: const TheItemType &
        :rtype: TheItemType &

        """
        return _SelectMgr.NCollection_Vector_Handle_SelectMgr_SensitiveEntity_Append(self, *args)


    def Appended(self, *args):
        """
        Appended(NCollection_Vector_Handle_SelectMgr_SensitiveEntity self) -> Handle_SelectMgr_SensitiveEntity

        Appends an empty value and returns the reference to it

        :rtype: TheItemType &

        """
        return _SelectMgr.NCollection_Vector_Handle_SelectMgr_SensitiveEntity_Appended(self, *args)


    def Value(self, *args):
        """
        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _SelectMgr.NCollection_Vector_Handle_SelectMgr_SensitiveEntity_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def First(self, *args):
        """
        @return first element

        :rtype: const TheItemType &

        """
        res = _SelectMgr.NCollection_Vector_Handle_SelectMgr_SensitiveEntity_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Vector_Handle_SelectMgr_SensitiveEntity self) -> Handle_SelectMgr_SensitiveEntity

        @return first element

        :rtype: TheItemType &

        """
        return _SelectMgr.NCollection_Vector_Handle_SelectMgr_SensitiveEntity_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        @return last element

        :rtype: const TheItemType &

        """
        res = _SelectMgr.NCollection_Vector_Handle_SelectMgr_SensitiveEntity_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Vector_Handle_SelectMgr_SensitiveEntity self) -> Handle_SelectMgr_SensitiveEntity

        @return last element

        :rtype: TheItemType &

        """
        return _SelectMgr.NCollection_Vector_Handle_SelectMgr_SensitiveEntity_ChangeLast(self, *args)


    def __call__(self, *args):
        """
        Operator() - query the const value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _SelectMgr.NCollection_Vector_Handle_SelectMgr_SensitiveEntity___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __getitem__(self, *args):
        """
        Operator[] - query the const value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _SelectMgr.NCollection_Vector_Handle_SelectMgr_SensitiveEntity_at(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Vector_Handle_SelectMgr_SensitiveEntity self, Standard_Integer const theIndex) -> Handle_SelectMgr_SensitiveEntity

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _SelectMgr.NCollection_Vector_Handle_SelectMgr_SensitiveEntity_ChangeValue(self, *args)


    def SetValue(self, *args):
        """
        SetValue(NCollection_Vector_Handle_SelectMgr_SensitiveEntity self, Standard_Integer const theIndex, Handle_SelectMgr_SensitiveEntity theValue) -> Handle_SelectMgr_SensitiveEntity

        SetValue () - set or append a value

        :type theIndex: int
        :type theValue: const TheItemType &
        :rtype: TheItemType &

        """
        return _SelectMgr.NCollection_Vector_Handle_SelectMgr_SensitiveEntity_SetValue(self, *args)

    __swig_destroy__ = _SelectMgr.delete_NCollection_Vector_Handle_SelectMgr_SensitiveEntity
NCollection_Vector_Handle_SelectMgr_SensitiveEntity_swigregister = _SelectMgr.NCollection_Vector_Handle_SelectMgr_SensitiveEntity_swigregister
NCollection_Vector_Handle_SelectMgr_SensitiveEntity_swigregister(NCollection_Vector_Handle_SelectMgr_SensitiveEntity)

class Handle_SelectMgr_CompositionFilter(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_SelectMgr_CompositionFilter self)

        Nullify the handle


        """
        return _SelectMgr.Handle_SelectMgr_CompositionFilter_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_SelectMgr_CompositionFilter self) -> bool

        Check for being null

        :rtype: bool

        """
        return _SelectMgr.Handle_SelectMgr_CompositionFilter_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_SelectMgr_CompositionFilter self, SelectMgr_CompositionFilter thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _SelectMgr.Handle_SelectMgr_CompositionFilter_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_SelectMgr_CompositionFilter self, Handle_SelectMgr_CompositionFilter theHandle) -> Handle_SelectMgr_CompositionFilter
        assign(Handle_SelectMgr_CompositionFilter self, SelectMgr_CompositionFilter thePtr) -> Handle_SelectMgr_CompositionFilter
        assign(Handle_SelectMgr_CompositionFilter self, Handle_SelectMgr_CompositionFilter theHandle) -> Handle_SelectMgr_CompositionFilter

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _SelectMgr.Handle_SelectMgr_CompositionFilter_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_SelectMgr_CompositionFilter self) -> SelectMgr_CompositionFilter

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _SelectMgr.Handle_SelectMgr_CompositionFilter_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_SelectMgr_CompositionFilter self) -> SelectMgr_CompositionFilter

        Member access operator (note non-const)

        :rtype: T *

        """
        return _SelectMgr.Handle_SelectMgr_CompositionFilter___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_SelectMgr_CompositionFilter self) -> SelectMgr_CompositionFilter

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _SelectMgr.Handle_SelectMgr_CompositionFilter___ref__(self, *args)


    def __hash__(self):
        return _SelectMgr.Handle_SelectMgr_CompositionFilter___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _SelectMgr.Handle_SelectMgr_CompositionFilter___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _SelectMgr.new_Handle_SelectMgr_CompositionFilter(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_SelectMgr.Handle_SelectMgr_CompositionFilter_DownCast)
    __swig_destroy__ = _SelectMgr.delete_Handle_SelectMgr_CompositionFilter

    def Add(self, *args):
        """
        Add(Handle_SelectMgr_CompositionFilter self, Handle_SelectMgr_Filter afilter)

        Adds the filter afilter to a filter object created by a
        filter class inheriting this framework.

        :type afilter: OCC.wrapper.SelectMgr.Handle_SelectMgr_Filter

        """
        return _SelectMgr.Handle_SelectMgr_CompositionFilter_Add(self, *args)


    def Remove(self, *args):
        """
        Remove(Handle_SelectMgr_CompositionFilter self, Handle_SelectMgr_Filter aFilter)

        Removes the filter aFilter from this framework.

        :type aFilter: OCC.wrapper.SelectMgr.Handle_SelectMgr_Filter

        """
        return _SelectMgr.Handle_SelectMgr_CompositionFilter_Remove(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(Handle_SelectMgr_CompositionFilter self) -> Standard_Boolean

        Returns true if this framework is empty.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _SelectMgr.Handle_SelectMgr_CompositionFilter_IsEmpty(self, *args)


    def IsIn(self, *args):
        """
        IsIn(Handle_SelectMgr_CompositionFilter self, Handle_SelectMgr_Filter aFilter) -> Standard_Boolean

        Returns true if the filter aFilter is in this framework.

        :type aFilter: OCC.wrapper.SelectMgr.Handle_SelectMgr_Filter
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _SelectMgr.Handle_SelectMgr_CompositionFilter_IsIn(self, *args)


    def StoredFilters(self, *args):
        """
        Returns the list of stored filters from this framework.

        :rtype: OCC.wrapper.SelectMgr.SelectMgr_ListOfFilter

        """
        res = _SelectMgr.Handle_SelectMgr_CompositionFilter_StoredFilters(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Clear(self, *args):
        """
        Clear(Handle_SelectMgr_CompositionFilter self)

        Clears the filters used in this framework.


        """
        return _SelectMgr.Handle_SelectMgr_CompositionFilter_Clear(self, *args)


    def ActsOn(self, *args):
        """
        ActsOn(Handle_SelectMgr_CompositionFilter self, TopAbs_ShapeEnum const aStandardMode) -> Standard_Boolean

        :type aStandardMode: OCC.wrapper.TopAbs.TopAbs_ShapeEnum
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _SelectMgr.Handle_SelectMgr_CompositionFilter_ActsOn(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_SelectMgr_CompositionFilter self) -> char const *

        :rtype: const char *

        """
        return _SelectMgr.Handle_SelectMgr_CompositionFilter_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _SelectMgr.Handle_SelectMgr_CompositionFilter_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _SelectMgr.Handle_SelectMgr_CompositionFilter_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def IsOk(self, *args):
        """
        IsOk(Handle_SelectMgr_CompositionFilter self, Handle_SelectMgr_EntityOwner anObj) -> Standard_Boolean

        Indicates that the selected Interactive Object
        passes the filter. The owner, anObj, can be either
        direct or user. A direct owner is the corresponding
        construction element, whereas a user is the
        compound shape of which the entity forms a part.
        When an object is detected by the mouse - in AIS,
        this is done through a context selector - its owner
        is passed to the filter as an argument.
        If the object returns Standard_True, it is kept; if
        not, it is rejected.
        If you are creating a filter class inheriting this
        framework, and the daughter class is to be used in
        an AIS local context, you will need to implement the
        virtual function ActsOn.

        :type anObj: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _SelectMgr.Handle_SelectMgr_CompositionFilter_IsOk(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_SelectMgr_CompositionFilter self)

        Memory deallocator for transient classes


        """
        return _SelectMgr.Handle_SelectMgr_CompositionFilter_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_SelectMgr_CompositionFilter self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_SelectMgr_CompositionFilter self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _SelectMgr.Handle_SelectMgr_CompositionFilter_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_SelectMgr_CompositionFilter self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_SelectMgr_CompositionFilter self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _SelectMgr.Handle_SelectMgr_CompositionFilter_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_SelectMgr_CompositionFilter self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _SelectMgr.Handle_SelectMgr_CompositionFilter_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_SelectMgr_CompositionFilter self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _SelectMgr.Handle_SelectMgr_CompositionFilter_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_SelectMgr_CompositionFilter self)

        Increments the reference counter of this object


        """
        return _SelectMgr.Handle_SelectMgr_CompositionFilter_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_SelectMgr_CompositionFilter self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _SelectMgr.Handle_SelectMgr_CompositionFilter_DecrementRefCounter(self, *args)

Handle_SelectMgr_CompositionFilter_swigregister = _SelectMgr.Handle_SelectMgr_CompositionFilter_swigregister
Handle_SelectMgr_CompositionFilter_swigregister(Handle_SelectMgr_CompositionFilter)

def Handle_SelectMgr_CompositionFilter_DownCast(thing):
    return _SelectMgr.Handle_SelectMgr_CompositionFilter_DownCast(thing)
Handle_SelectMgr_CompositionFilter_DownCast = _SelectMgr.Handle_SelectMgr_CompositionFilter_DownCast

class Handle_SelectMgr_OrFilter(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_SelectMgr_OrFilter self)

        Nullify the handle


        """
        return _SelectMgr.Handle_SelectMgr_OrFilter_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_SelectMgr_OrFilter self) -> bool

        Check for being null

        :rtype: bool

        """
        return _SelectMgr.Handle_SelectMgr_OrFilter_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_SelectMgr_OrFilter self, SelectMgr_OrFilter thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _SelectMgr.Handle_SelectMgr_OrFilter_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_SelectMgr_OrFilter self, Handle_SelectMgr_OrFilter theHandle) -> Handle_SelectMgr_OrFilter
        assign(Handle_SelectMgr_OrFilter self, SelectMgr_OrFilter thePtr) -> Handle_SelectMgr_OrFilter
        assign(Handle_SelectMgr_OrFilter self, Handle_SelectMgr_OrFilter theHandle) -> Handle_SelectMgr_OrFilter

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _SelectMgr.Handle_SelectMgr_OrFilter_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_SelectMgr_OrFilter self) -> SelectMgr_OrFilter

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _SelectMgr.Handle_SelectMgr_OrFilter_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_SelectMgr_OrFilter self) -> SelectMgr_OrFilter

        Member access operator (note non-const)

        :rtype: T *

        """
        return _SelectMgr.Handle_SelectMgr_OrFilter___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_SelectMgr_OrFilter self) -> SelectMgr_OrFilter

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _SelectMgr.Handle_SelectMgr_OrFilter___ref__(self, *args)


    def __hash__(self):
        return _SelectMgr.Handle_SelectMgr_OrFilter___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _SelectMgr.Handle_SelectMgr_OrFilter___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _SelectMgr.new_Handle_SelectMgr_OrFilter(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_SelectMgr.Handle_SelectMgr_OrFilter_DownCast)
    __swig_destroy__ = _SelectMgr.delete_Handle_SelectMgr_OrFilter

    def IsOk(self, *args):
        """
        IsOk(Handle_SelectMgr_OrFilter self, Handle_SelectMgr_EntityOwner anobj) -> Standard_Boolean

        :type anobj: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _SelectMgr.Handle_SelectMgr_OrFilter_IsOk(self, *args)


    def SetDisabledObjects(self, *args):
        """
        SetDisabledObjects(Handle_SelectMgr_OrFilter self, Handle_Graphic3d_NMapOfTransient theObjects)

        Disable selection of specified objects.

        :type theObjects: OCC.wrapper.SelectMgr.Handle_Graphic3d_NMapOfTransient

        """
        return _SelectMgr.Handle_SelectMgr_OrFilter_SetDisabledObjects(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_SelectMgr_OrFilter self) -> char const *

        :rtype: const char *

        """
        return _SelectMgr.Handle_SelectMgr_OrFilter_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _SelectMgr.Handle_SelectMgr_OrFilter_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _SelectMgr.Handle_SelectMgr_OrFilter_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Add(self, *args):
        """
        Add(Handle_SelectMgr_OrFilter self, Handle_SelectMgr_Filter afilter)

        Adds the filter afilter to a filter object created by a
        filter class inheriting this framework.

        :type afilter: OCC.wrapper.SelectMgr.Handle_SelectMgr_Filter

        """
        return _SelectMgr.Handle_SelectMgr_OrFilter_Add(self, *args)


    def Remove(self, *args):
        """
        Remove(Handle_SelectMgr_OrFilter self, Handle_SelectMgr_Filter aFilter)

        Removes the filter aFilter from this framework.

        :type aFilter: OCC.wrapper.SelectMgr.Handle_SelectMgr_Filter

        """
        return _SelectMgr.Handle_SelectMgr_OrFilter_Remove(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(Handle_SelectMgr_OrFilter self) -> Standard_Boolean

        Returns true if this framework is empty.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _SelectMgr.Handle_SelectMgr_OrFilter_IsEmpty(self, *args)


    def IsIn(self, *args):
        """
        IsIn(Handle_SelectMgr_OrFilter self, Handle_SelectMgr_Filter aFilter) -> Standard_Boolean

        Returns true if the filter aFilter is in this framework.

        :type aFilter: OCC.wrapper.SelectMgr.Handle_SelectMgr_Filter
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _SelectMgr.Handle_SelectMgr_OrFilter_IsIn(self, *args)


    def StoredFilters(self, *args):
        """
        Returns the list of stored filters from this framework.

        :rtype: OCC.wrapper.SelectMgr.SelectMgr_ListOfFilter

        """
        res = _SelectMgr.Handle_SelectMgr_OrFilter_StoredFilters(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Clear(self, *args):
        """
        Clear(Handle_SelectMgr_OrFilter self)

        Clears the filters used in this framework.


        """
        return _SelectMgr.Handle_SelectMgr_OrFilter_Clear(self, *args)


    def ActsOn(self, *args):
        """
        ActsOn(Handle_SelectMgr_OrFilter self, TopAbs_ShapeEnum const aStandardMode) -> Standard_Boolean

        :type aStandardMode: OCC.wrapper.TopAbs.TopAbs_ShapeEnum
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _SelectMgr.Handle_SelectMgr_OrFilter_ActsOn(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_SelectMgr_OrFilter self)

        Memory deallocator for transient classes


        """
        return _SelectMgr.Handle_SelectMgr_OrFilter_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_SelectMgr_OrFilter self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_SelectMgr_OrFilter self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _SelectMgr.Handle_SelectMgr_OrFilter_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_SelectMgr_OrFilter self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_SelectMgr_OrFilter self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _SelectMgr.Handle_SelectMgr_OrFilter_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_SelectMgr_OrFilter self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _SelectMgr.Handle_SelectMgr_OrFilter_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_SelectMgr_OrFilter self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _SelectMgr.Handle_SelectMgr_OrFilter_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_SelectMgr_OrFilter self)

        Increments the reference counter of this object


        """
        return _SelectMgr.Handle_SelectMgr_OrFilter_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_SelectMgr_OrFilter self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _SelectMgr.Handle_SelectMgr_OrFilter_DecrementRefCounter(self, *args)

Handle_SelectMgr_OrFilter_swigregister = _SelectMgr.Handle_SelectMgr_OrFilter_swigregister
Handle_SelectMgr_OrFilter_swigregister(Handle_SelectMgr_OrFilter)

def Handle_SelectMgr_OrFilter_DownCast(thing):
    return _SelectMgr.Handle_SelectMgr_OrFilter_DownCast(thing)
Handle_SelectMgr_OrFilter_DownCast = _SelectMgr.Handle_SelectMgr_OrFilter_DownCast


try:
	TColStd_MapTransientHasher = TColStd.NCollection_DefaultHasher_Handle_Standard_Transient
except AttributeError:
	pass # does not exist, probably ignored

class SelectMgr_ViewClipRange(object):
    """
    Class for handling depth clipping range.
    It is used to perform checks in case if global (for the whole view)
    clipping planes are defined inside of SelectMgr_RectangularFrustum
    class methods.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(SelectMgr_ViewClipRange self) -> SelectMgr_ViewClipRange

        Creates new empty view clip range


        """
        this = _SelectMgr.new_SelectMgr_ViewClipRange(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Set(self, *args):
        """
        Set(SelectMgr_ViewClipRange self, Standard_Real const theDepthMin, Standard_Real const theDepthMax)

        Sets boundaries and validates view clipping range

        :type theDepthMin: float
        :type theDepthMax: float

        """
        return _SelectMgr.SelectMgr_ViewClipRange_Set(self, *args)


    def IsValid(self, *args):
        """
        IsValid(SelectMgr_ViewClipRange self) -> Standard_Boolean

        Returns true if clip range is set and depth of each matched
        primitive must be tested for satisfying the defined interval

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _SelectMgr.SelectMgr_ViewClipRange_IsValid(self, *args)


    def MaxDepth(self, *args):
        """
        MaxDepth(SelectMgr_ViewClipRange self) -> Standard_Real

        Returns the upper bound of valid depth range

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _SelectMgr.SelectMgr_ViewClipRange_MaxDepth(self, *args)


    def MinDepth(self, *args):
        """
        MinDepth(SelectMgr_ViewClipRange self) -> Standard_Real

        Returns the lower bound of valid depth range

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _SelectMgr.SelectMgr_ViewClipRange_MinDepth(self, *args)


    def Clear(self, *args):
        """
        Clear(SelectMgr_ViewClipRange self)

        Invalidates view clipping range


        """
        return _SelectMgr.SelectMgr_ViewClipRange_Clear(self, *args)

    __swig_destroy__ = _SelectMgr.delete_SelectMgr_ViewClipRange
SelectMgr_ViewClipRange_swigregister = _SelectMgr.SelectMgr_ViewClipRange_swigregister
SelectMgr_ViewClipRange_swigregister(SelectMgr_ViewClipRange)

class Handle_SelectMgr_TriangularFrustum(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_SelectMgr_TriangularFrustum self)

        Nullify the handle


        """
        return _SelectMgr.Handle_SelectMgr_TriangularFrustum_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_SelectMgr_TriangularFrustum self) -> bool

        Check for being null

        :rtype: bool

        """
        return _SelectMgr.Handle_SelectMgr_TriangularFrustum_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_SelectMgr_TriangularFrustum self, SelectMgr_TriangularFrustum * thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _SelectMgr.Handle_SelectMgr_TriangularFrustum_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_SelectMgr_TriangularFrustum self, Handle_SelectMgr_TriangularFrustum theHandle) -> Handle_SelectMgr_TriangularFrustum
        assign(Handle_SelectMgr_TriangularFrustum self, SelectMgr_TriangularFrustum const * thePtr) -> Handle_SelectMgr_TriangularFrustum
        assign(Handle_SelectMgr_TriangularFrustum self, Handle_SelectMgr_TriangularFrustum theHandle) -> Handle_SelectMgr_TriangularFrustum

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _SelectMgr.Handle_SelectMgr_TriangularFrustum_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_SelectMgr_TriangularFrustum self) -> SelectMgr_TriangularFrustum *

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _SelectMgr.Handle_SelectMgr_TriangularFrustum_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_SelectMgr_TriangularFrustum self) -> SelectMgr_TriangularFrustum *

        Member access operator (note non-const)

        :rtype: T *

        """
        return _SelectMgr.Handle_SelectMgr_TriangularFrustum___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_SelectMgr_TriangularFrustum self) -> SelectMgr_TriangularFrustum &

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _SelectMgr.Handle_SelectMgr_TriangularFrustum___ref__(self, *args)


    def __hash__(self):
        return _SelectMgr.Handle_SelectMgr_TriangularFrustum___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _SelectMgr.Handle_SelectMgr_TriangularFrustum___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _SelectMgr.new_Handle_SelectMgr_TriangularFrustum(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_SelectMgr.Handle_SelectMgr_TriangularFrustum_DownCast)
    __swig_destroy__ = _SelectMgr.delete_Handle_SelectMgr_TriangularFrustum

    def Build(self, *args):
        """
        Build(Handle_SelectMgr_TriangularFrustum self, gp_Pnt2d theP1, gp_Pnt2d theP2, gp_Pnt2d theP3)

        Creates new triangular frustum with bases of triangles with vertices theP1, theP2 and theP3
        projections onto near and far view frustum planes (only for triangular frustums)

        :type theP1: OCC.wrapper.gp.gp_Pnt2d
        :type theP2: OCC.wrapper.gp.gp_Pnt2d
        :type theP3: OCC.wrapper.gp.gp_Pnt2d

        """
        return _SelectMgr.Handle_SelectMgr_TriangularFrustum_Build(self, *args)


    def ScaleAndTransform(self, *args):
        """
        ScaleAndTransform(Handle_SelectMgr_TriangularFrustum self, Standard_Integer const theScale, gp_GTrsf theTrsf) -> Handle_SelectMgr_BaseFrustum

        Returns a copy of the frustum transformed according to the matrix given

        :type theScale: int
        :type theTrsf: OCC.wrapper.gp.gp_GTrsf
        :rtype: OCC.wrapper.SelectMgr.Handle_SelectMgr_BaseFrustum

        """
        return _SelectMgr.Handle_SelectMgr_TriangularFrustum_ScaleAndTransform(self, *args)


    def Overlaps(self, *args):
        """
        Overlaps(Handle_SelectMgr_TriangularFrustum self, NCollection_Vec3_Standard_Real theMinPnt, NCollection_Vec3_Standard_Real theMaxPnt) -> Standard_Boolean
        Overlaps(Handle_SelectMgr_TriangularFrustum self, NCollection_Vec3_Standard_Real theMinPt, NCollection_Vec3_Standard_Real theMaxPt, Standard_Boolean * theInside) -> Standard_Boolean
        Overlaps(Handle_SelectMgr_TriangularFrustum self, gp_Pnt thePnt) -> Standard_Boolean
        Overlaps(Handle_SelectMgr_TriangularFrustum self, NCollection_Array1_gp_Pnt theArrayOfPnts, Select3D_TypeOfSensitivity theSensType) -> Standard_Boolean
        Overlaps(Handle_SelectMgr_TriangularFrustum self, gp_Pnt thePnt1, gp_Pnt thePnt2) -> Standard_Boolean
        Overlaps(Handle_SelectMgr_TriangularFrustum self, gp_Pnt thePnt1, gp_Pnt thePnt2, gp_Pnt thePnt3, Select3D_TypeOfSensitivity theSensType) -> Standard_Boolean

        SAT intersection test between defined volume and given triangle. The test may
        be considered of interior part or boundary line defined by triangle vertices
        depending on given sensitivity type

        :type thePnt1: OCC.wrapper.gp.gp_Pnt
        :type thePnt2: OCC.wrapper.gp.gp_Pnt
        :type thePnt3: OCC.wrapper.gp.gp_Pnt
        :type theSensType: OCC.wrapper.Select3D.Select3D_TypeOfSensitivity
        :type theDepth: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _SelectMgr.Handle_SelectMgr_TriangularFrustum_Overlaps(self, *args)


    def Clear(self, *args):
        """
        Clear(Handle_SelectMgr_TriangularFrustum self)

        Nullifies the handle to corresponding builder instance to prevent memory leaks


        """
        return _SelectMgr.Handle_SelectMgr_TriangularFrustum_Clear(self, *args)


    def GetPlanes(self, *args):
        """
        GetPlanes(Handle_SelectMgr_TriangularFrustum self, NCollection_Vector< SelectMgr_Vec4 > & thePlaneEquations)

        Stores plane equation coefficients (in the following form:
        Ax + By + Cz + D = 0) to the given vector

        :type thePlaneEquations: OCC.wrapper.SelectMgr.NCollection_Vector_SelectMgr_Vec4

        """
        return _SelectMgr.Handle_SelectMgr_TriangularFrustum_GetPlanes(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_SelectMgr_TriangularFrustum self) -> char const *

        :rtype: const char *

        """
        return _SelectMgr.Handle_SelectMgr_TriangularFrustum_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _SelectMgr.Handle_SelectMgr_TriangularFrustum_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _SelectMgr.Handle_SelectMgr_TriangularFrustum_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


Handle_SelectMgr_TriangularFrustum_swigregister = _SelectMgr.Handle_SelectMgr_TriangularFrustum_swigregister
Handle_SelectMgr_TriangularFrustum_swigregister(Handle_SelectMgr_TriangularFrustum)

def Handle_SelectMgr_TriangularFrustum_DownCast(thing):
    return _SelectMgr.Handle_SelectMgr_TriangularFrustum_DownCast(thing)
Handle_SelectMgr_TriangularFrustum_DownCast = _SelectMgr.Handle_SelectMgr_TriangularFrustum_DownCast


try:
	SelectMgr_Vec3 = Graphic3d.NCollection_Vec3_Standard_Real
except AttributeError:
	pass # does not exist, probably ignored

class NCollection_Sequence_Handle_SelectMgr_EntityOwner(NCollection.NCollection_BaseSequence):
    """
    Purpose:     Definition of a sequence of elements indexed by
    an Integer in range of 1..n
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Sequence_Handle_SelectMgr_EntityOwner self) -> NCollection_Sequence< opencascade::handle< SelectMgr_EntityOwner > >::iterator

        Returns an iterator pointing to the first element in the sequence.

        :rtype: iterator

        """
        return _SelectMgr.NCollection_Sequence_Handle_SelectMgr_EntityOwner_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Sequence_Handle_SelectMgr_EntityOwner self) -> NCollection_Sequence< opencascade::handle< SelectMgr_EntityOwner > >::iterator

        Returns an iterator referring to the past-the-end element in the sequence.

        :rtype: iterator

        """
        return _SelectMgr.NCollection_Sequence_Handle_SelectMgr_EntityOwner_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Sequence_Handle_SelectMgr_EntityOwner self) -> NCollection_Sequence< opencascade::handle< SelectMgr_EntityOwner > >::const_iterator

        Returns a const iterator pointing to the first element in the sequence.

        :rtype: const_iterator

        """
        return _SelectMgr.NCollection_Sequence_Handle_SelectMgr_EntityOwner_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Sequence_Handle_SelectMgr_EntityOwner self) -> NCollection_Sequence< opencascade::handle< SelectMgr_EntityOwner > >::const_iterator

        Returns a const iterator referring to the past-the-end element in the sequence.

        :rtype: const_iterator

        """
        return _SelectMgr.NCollection_Sequence_Handle_SelectMgr_EntityOwner_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     Definition of a sequence of elements indexed by
        an Integer in range of 1..n
        """
        this = _SelectMgr.new_NCollection_Sequence_Handle_SelectMgr_EntityOwner(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Size(self, *args):
        """
        Size(NCollection_Sequence_Handle_SelectMgr_EntityOwner self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _SelectMgr.NCollection_Sequence_Handle_SelectMgr_EntityOwner_Size(self, *args)


    def Length(self, *args):
        """
        Length(NCollection_Sequence_Handle_SelectMgr_EntityOwner self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _SelectMgr.NCollection_Sequence_Handle_SelectMgr_EntityOwner_Length(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Sequence_Handle_SelectMgr_EntityOwner self) -> Standard_Integer

        Method for consistency with other collections.
        @return Lower bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _SelectMgr.NCollection_Sequence_Handle_SelectMgr_EntityOwner_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Sequence_Handle_SelectMgr_EntityOwner self) -> Standard_Integer

        Method for consistency with other collections.
        @return Upper bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _SelectMgr.NCollection_Sequence_Handle_SelectMgr_EntityOwner_Upper(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Sequence_Handle_SelectMgr_EntityOwner self) -> Standard_Boolean

        Empty query

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _SelectMgr.NCollection_Sequence_Handle_SelectMgr_EntityOwner_IsEmpty(self, *args)


    def Reverse(self, *args):
        """
        Reverse(NCollection_Sequence_Handle_SelectMgr_EntityOwner self)

        Reverse sequence


        """
        return _SelectMgr.NCollection_Sequence_Handle_SelectMgr_EntityOwner_Reverse(self, *args)


    def Exchange(self, *args):
        """
        Exchange(NCollection_Sequence_Handle_SelectMgr_EntityOwner self, Standard_Integer const I, Standard_Integer const J)

        Exchange two members

        :type I: int
        :type J: int

        """
        return _SelectMgr.NCollection_Sequence_Handle_SelectMgr_EntityOwner_Exchange(self, *args)


    def delNode(*args):
        """
        delNode(NCollection_SeqNode theNode, Handle_NCollection_BaseAllocator theAl)

        Static deleter to be passed to BaseSequence

        :type theNode: OCC.wrapper.NCollection.NCollection_SeqNode
        :type theAl: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _SelectMgr.NCollection_Sequence_Handle_SelectMgr_EntityOwner_delNode(*args)

    delNode = staticmethod(delNode)

    def Clear(self, *args):
        """
        Clear(NCollection_Sequence_Handle_SelectMgr_EntityOwner self, Handle_NCollection_BaseAllocator theAllocator=0)

        Clear the items out, take a new allocator if non null

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _SelectMgr.NCollection_Sequence_Handle_SelectMgr_EntityOwner_Clear(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Sequence_Handle_SelectMgr_EntityOwner self, NCollection_Sequence_Handle_SelectMgr_EntityOwner theOther) -> NCollection_Sequence_Handle_SelectMgr_EntityOwner

        Replace this sequence by the items of theOther.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_Sequence
        :rtype: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _SelectMgr.NCollection_Sequence_Handle_SelectMgr_EntityOwner_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Sequence_Handle_SelectMgr_EntityOwner self, NCollection_Sequence_Handle_SelectMgr_EntityOwner theOther) -> NCollection_Sequence_Handle_SelectMgr_EntityOwner

        Replacement operator

        :type theOther: OCC.wrapper.NCollection.NCollection_Sequence
        :rtype: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _SelectMgr.NCollection_Sequence_Handle_SelectMgr_EntityOwner_assign(self, *args)


    def Remove(self, *args):
        """
        Remove(NCollection_Sequence_Handle_SelectMgr_EntityOwner self, NCollection_Sequence< opencascade::handle< SelectMgr_EntityOwner > >::Iterator & thePosition)
        Remove(NCollection_Sequence_Handle_SelectMgr_EntityOwner self, Standard_Integer const theIndex)
        Remove(NCollection_Sequence_Handle_SelectMgr_EntityOwner self, Standard_Integer const theFromIndex, Standard_Integer const theToIndex)

        Remove range of items

        :type theFromIndex: int
        :type theToIndex: int

        """
        return _SelectMgr.NCollection_Sequence_Handle_SelectMgr_EntityOwner_Remove(self, *args)


    def Append(self, *args):
        """
        Append(NCollection_Sequence_Handle_SelectMgr_EntityOwner self, Handle_SelectMgr_EntityOwner theItem)
        Append(NCollection_Sequence_Handle_SelectMgr_EntityOwner self, NCollection_Sequence_Handle_SelectMgr_EntityOwner theSeq)

        Append another sequence (making it empty)

        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _SelectMgr.NCollection_Sequence_Handle_SelectMgr_EntityOwner_Append(self, *args)


    def Prepend(self, *args):
        """
        Prepend(NCollection_Sequence_Handle_SelectMgr_EntityOwner self, Handle_SelectMgr_EntityOwner theItem)
        Prepend(NCollection_Sequence_Handle_SelectMgr_EntityOwner self, NCollection_Sequence_Handle_SelectMgr_EntityOwner theSeq)

        Prepend another sequence (making it empty)

        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _SelectMgr.NCollection_Sequence_Handle_SelectMgr_EntityOwner_Prepend(self, *args)


    def InsertBefore(self, *args):
        """
        InsertBefore(NCollection_Sequence_Handle_SelectMgr_EntityOwner self, Standard_Integer const theIndex, Handle_SelectMgr_EntityOwner theItem)
        InsertBefore(NCollection_Sequence_Handle_SelectMgr_EntityOwner self, Standard_Integer const theIndex, NCollection_Sequence_Handle_SelectMgr_EntityOwner theSeq)

        InsertBefore theIndex another sequence

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _SelectMgr.NCollection_Sequence_Handle_SelectMgr_EntityOwner_InsertBefore(self, *args)


    def InsertAfter(self, *args):
        """
        InsertAfter(NCollection_Sequence_Handle_SelectMgr_EntityOwner self, NCollection_Sequence< opencascade::handle< SelectMgr_EntityOwner > >::Iterator & thePosition, Handle_SelectMgr_EntityOwner theItem)
        InsertAfter(NCollection_Sequence_Handle_SelectMgr_EntityOwner self, Standard_Integer const theIndex, NCollection_Sequence_Handle_SelectMgr_EntityOwner theSeq)
        InsertAfter(NCollection_Sequence_Handle_SelectMgr_EntityOwner self, Standard_Integer const theIndex, Handle_SelectMgr_EntityOwner theItem)

        InsertAfter theIndex another sequence

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _SelectMgr.NCollection_Sequence_Handle_SelectMgr_EntityOwner_InsertAfter(self, *args)


    def Split(self, *args):
        """
        Split(NCollection_Sequence_Handle_SelectMgr_EntityOwner self, Standard_Integer const theIndex, NCollection_Sequence_Handle_SelectMgr_EntityOwner theSeq)

        Split in two sequences

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _SelectMgr.NCollection_Sequence_Handle_SelectMgr_EntityOwner_Split(self, *args)


    def First(self, *args):
        """
        First item access

        :rtype: const TheItemType &

        """
        res = _SelectMgr.NCollection_Sequence_Handle_SelectMgr_EntityOwner_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Sequence_Handle_SelectMgr_EntityOwner self) -> Handle_SelectMgr_EntityOwner

        First item access

        :rtype: TheItemType &

        """
        return _SelectMgr.NCollection_Sequence_Handle_SelectMgr_EntityOwner_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        Last item access

        :rtype: const TheItemType &

        """
        res = _SelectMgr.NCollection_Sequence_Handle_SelectMgr_EntityOwner_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Sequence_Handle_SelectMgr_EntityOwner self) -> Handle_SelectMgr_EntityOwner

        Last item access

        :rtype: TheItemType &

        """
        return _SelectMgr.NCollection_Sequence_Handle_SelectMgr_EntityOwner_ChangeLast(self, *args)


    def Value(self, *args):
        """
        Constant item access by theIndex

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _SelectMgr.NCollection_Sequence_Handle_SelectMgr_EntityOwner_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Sequence_Handle_SelectMgr_EntityOwner self, Standard_Integer const theIndex) -> Handle_SelectMgr_EntityOwner

        Variable item access by theIndex

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _SelectMgr.NCollection_Sequence_Handle_SelectMgr_EntityOwner_ChangeValue(self, *args)


    def __call__(self, *args):
        """
        Constant operator()

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _SelectMgr.NCollection_Sequence_Handle_SelectMgr_EntityOwner___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetValue(self, *args):
        """
        SetValue(NCollection_Sequence_Handle_SelectMgr_EntityOwner self, Standard_Integer const theIndex, Handle_SelectMgr_EntityOwner theItem)

        Set item value by theIndex

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _SelectMgr.NCollection_Sequence_Handle_SelectMgr_EntityOwner_SetValue(self, *args)


    def __iter__(self):
        return _SelectMgr.NCollection_Sequence_Handle_SelectMgr_EntityOwner___iter__(self)
    __swig_destroy__ = _SelectMgr.delete_NCollection_Sequence_Handle_SelectMgr_EntityOwner
NCollection_Sequence_Handle_SelectMgr_EntityOwner_swigregister = _SelectMgr.NCollection_Sequence_Handle_SelectMgr_EntityOwner_swigregister
NCollection_Sequence_Handle_SelectMgr_EntityOwner_swigregister(NCollection_Sequence_Handle_SelectMgr_EntityOwner)

def NCollection_Sequence_Handle_SelectMgr_EntityOwner_delNode(*args):
    """
    NCollection_Sequence_Handle_SelectMgr_EntityOwner_delNode(NCollection_SeqNode theNode, Handle_NCollection_BaseAllocator theAl)

    Static deleter to be passed to BaseSequence

    :type theNode: OCC.wrapper.NCollection.NCollection_SeqNode
    :type theAl: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

    """
    return _SelectMgr.NCollection_Sequence_Handle_SelectMgr_EntityOwner_delNode(*args)

class NCollection_Sequence_Handle_SelectMgr_EntityOwner_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _SelectMgr.new_NCollection_Sequence_Handle_SelectMgr_EntityOwner_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SelectMgr.delete_NCollection_Sequence_Handle_SelectMgr_EntityOwner_IteratorHelper

    def __next__(self):
        return _SelectMgr.NCollection_Sequence_Handle_SelectMgr_EntityOwner_IteratorHelper___next__(self)
NCollection_Sequence_Handle_SelectMgr_EntityOwner_IteratorHelper_swigregister = _SelectMgr.NCollection_Sequence_Handle_SelectMgr_EntityOwner_IteratorHelper_swigregister
NCollection_Sequence_Handle_SelectMgr_EntityOwner_IteratorHelper_swigregister(NCollection_Sequence_Handle_SelectMgr_EntityOwner_IteratorHelper)


try:
	SelectMgr_SequenceOfOwner = NCollection_Sequence_Handle_SelectMgr_EntityOwner
except NameError:
	pass # does not exist, probably ignored

class NCollection_List_Handle_SelectMgr_Filter(NCollection.NCollection_BaseList):
    """
    Purpose:      Simple list to link  items together keeping the first 
    and the last one.
    Inherits BaseList, adding the data item to each node.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_List_Handle_SelectMgr_Filter self) -> NCollection_List< opencascade::handle< SelectMgr_Filter > >::iterator

        Returns an iterator pointing to the first element in the list.

        :rtype: iterator

        """
        return _SelectMgr.NCollection_List_Handle_SelectMgr_Filter_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_List_Handle_SelectMgr_Filter self) -> NCollection_List< opencascade::handle< SelectMgr_Filter > >::iterator

        Returns an iterator referring to the past-the-end element in the list.

        :rtype: iterator

        """
        return _SelectMgr.NCollection_List_Handle_SelectMgr_Filter_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_List_Handle_SelectMgr_Filter self) -> NCollection_List< opencascade::handle< SelectMgr_Filter > >::const_iterator

        Returns a const iterator pointing to the first element in the list.

        :rtype: const_iterator

        """
        return _SelectMgr.NCollection_List_Handle_SelectMgr_Filter_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_List_Handle_SelectMgr_Filter self) -> NCollection_List< opencascade::handle< SelectMgr_Filter > >::const_iterator

        Returns a const iterator referring to the past-the-end element in the list.

        :rtype: const_iterator

        """
        return _SelectMgr.NCollection_List_Handle_SelectMgr_Filter_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:      Simple list to link  items together keeping the first 
        and the last one.
        Inherits BaseList, adding the data item to each node.
        """
        this = _SelectMgr.new_NCollection_List_Handle_SelectMgr_Filter(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Size(self, *args):
        """
        Size(NCollection_List_Handle_SelectMgr_Filter self) -> Standard_Integer

        Size - Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _SelectMgr.NCollection_List_Handle_SelectMgr_Filter_Size(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_List_Handle_SelectMgr_Filter self, NCollection_List_Handle_SelectMgr_Filter theOther) -> NCollection_List_Handle_SelectMgr_Filter

        Replace this list by the items of another list (theOther parameter).
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_List
        :rtype: OCC.wrapper.NCollection.NCollection_List

        """
        return _SelectMgr.NCollection_List_Handle_SelectMgr_Filter_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_List_Handle_SelectMgr_Filter self, NCollection_List_Handle_SelectMgr_Filter theOther) -> NCollection_List_Handle_SelectMgr_Filter

        Replacement operator

        :type theOther: OCC.wrapper.NCollection.NCollection_List
        :rtype: OCC.wrapper.NCollection.NCollection_List

        """
        return _SelectMgr.NCollection_List_Handle_SelectMgr_Filter_assign(self, *args)


    def Clear(self, *args):
        """
        Clear(NCollection_List_Handle_SelectMgr_Filter self, Handle_NCollection_BaseAllocator theAllocator=0)

        Clear this list

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _SelectMgr.NCollection_List_Handle_SelectMgr_Filter_Clear(self, *args)


    def First(self, *args):
        """
        First item

        :rtype: const TheItemType &

        """
        res = _SelectMgr.NCollection_List_Handle_SelectMgr_Filter_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Last(self, *args):
        """
        Last item

        :rtype: const TheItemType &

        """
        res = _SelectMgr.NCollection_List_Handle_SelectMgr_Filter_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Append(self, *args):
        """
        Append(NCollection_List_Handle_SelectMgr_Filter self, Handle_SelectMgr_Filter theItem) -> Handle_SelectMgr_Filter
        Append(NCollection_List_Handle_SelectMgr_Filter self, Handle_SelectMgr_Filter theItem, NCollection_List< opencascade::handle< SelectMgr_Filter > >::Iterator & theIter)
        Append(NCollection_List_Handle_SelectMgr_Filter self, NCollection_List_Handle_SelectMgr_Filter theOther)

        Append another list at the end

        :type theOther: OCC.wrapper.NCollection.NCollection_List

        """
        return _SelectMgr.NCollection_List_Handle_SelectMgr_Filter_Append(self, *args)


    def Prepend(self, *args):
        """
        Prepend(NCollection_List_Handle_SelectMgr_Filter self, Handle_SelectMgr_Filter theItem) -> Handle_SelectMgr_Filter
        Prepend(NCollection_List_Handle_SelectMgr_Filter self, NCollection_List_Handle_SelectMgr_Filter theOther)

        Prepend another list at the beginning

        :type theOther: OCC.wrapper.NCollection.NCollection_List

        """
        return _SelectMgr.NCollection_List_Handle_SelectMgr_Filter_Prepend(self, *args)


    def RemoveFirst(self, *args):
        """
        RemoveFirst(NCollection_List_Handle_SelectMgr_Filter self)

        RemoveFirst item


        """
        return _SelectMgr.NCollection_List_Handle_SelectMgr_Filter_RemoveFirst(self, *args)


    def Remove(self, *args):
        """
        Remove(NCollection_List_Handle_SelectMgr_Filter self, NCollection_List< opencascade::handle< SelectMgr_Filter > >::Iterator & theIter)

        Remove item pointed by iterator theIter; 
        theIter is then set to the next item

        :type theIter: Iterator

        """
        return _SelectMgr.NCollection_List_Handle_SelectMgr_Filter_Remove(self, *args)


    def InsertBefore(self, *args):
        """
        InsertBefore(NCollection_List_Handle_SelectMgr_Filter self, Handle_SelectMgr_Filter theItem, NCollection_List< opencascade::handle< SelectMgr_Filter > >::Iterator & theIter) -> Handle_SelectMgr_Filter
        InsertBefore(NCollection_List_Handle_SelectMgr_Filter self, NCollection_List_Handle_SelectMgr_Filter theOther, NCollection_List< opencascade::handle< SelectMgr_Filter > >::Iterator & theIter)

        InsertBefore

        :type theOther: OCC.wrapper.NCollection.NCollection_List
        :type theIter: Iterator

        """
        return _SelectMgr.NCollection_List_Handle_SelectMgr_Filter_InsertBefore(self, *args)


    def InsertAfter(self, *args):
        """
        InsertAfter(NCollection_List_Handle_SelectMgr_Filter self, Handle_SelectMgr_Filter theItem, NCollection_List< opencascade::handle< SelectMgr_Filter > >::Iterator & theIter) -> Handle_SelectMgr_Filter
        InsertAfter(NCollection_List_Handle_SelectMgr_Filter self, NCollection_List_Handle_SelectMgr_Filter theOther, NCollection_List< opencascade::handle< SelectMgr_Filter > >::Iterator & theIter)

        InsertAfter

        :type theOther: OCC.wrapper.NCollection.NCollection_List
        :type theIter: Iterator

        """
        return _SelectMgr.NCollection_List_Handle_SelectMgr_Filter_InsertAfter(self, *args)


    def Reverse(self, *args):
        """
        Reverse(NCollection_List_Handle_SelectMgr_Filter self)

        Reverse the list


        """
        return _SelectMgr.NCollection_List_Handle_SelectMgr_Filter_Reverse(self, *args)


    def __iter__(self):
        return _SelectMgr.NCollection_List_Handle_SelectMgr_Filter___iter__(self)
    __swig_destroy__ = _SelectMgr.delete_NCollection_List_Handle_SelectMgr_Filter
NCollection_List_Handle_SelectMgr_Filter_swigregister = _SelectMgr.NCollection_List_Handle_SelectMgr_Filter_swigregister
NCollection_List_Handle_SelectMgr_Filter_swigregister(NCollection_List_Handle_SelectMgr_Filter)

class NCollection_List_Handle_SelectMgr_Filter_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _SelectMgr.new_NCollection_List_Handle_SelectMgr_Filter_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SelectMgr.delete_NCollection_List_Handle_SelectMgr_Filter_IteratorHelper

    def __next__(self):
        return _SelectMgr.NCollection_List_Handle_SelectMgr_Filter_IteratorHelper___next__(self)
NCollection_List_Handle_SelectMgr_Filter_IteratorHelper_swigregister = _SelectMgr.NCollection_List_Handle_SelectMgr_Filter_IteratorHelper_swigregister
NCollection_List_Handle_SelectMgr_Filter_IteratorHelper_swigregister(NCollection_List_Handle_SelectMgr_Filter_IteratorHelper)


try:
	SelectMgr_ListOfFilter = NCollection_List_Handle_SelectMgr_Filter
except NameError:
	pass # does not exist, probably ignored




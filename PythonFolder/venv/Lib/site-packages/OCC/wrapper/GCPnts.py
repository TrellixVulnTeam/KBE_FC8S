# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_GCPnts')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_GCPnts')
    _GCPnts = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_GCPnts', [dirname(__file__)])
        except ImportError:
            import _GCPnts
            return _GCPnts
        try:
            _mod = imp.load_module('_GCPnts', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _GCPnts = swig_import_helper()
    del swig_import_helper
else:
    import _GCPnts
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


class SwigPyIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _GCPnts.delete_SwigPyIterator

    def value(self):
        return _GCPnts.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _GCPnts.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _GCPnts.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _GCPnts.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _GCPnts.SwigPyIterator_equal(self, x)

    def copy(self):
        return _GCPnts.SwigPyIterator_copy(self)

    def next(self):
        return _GCPnts.SwigPyIterator_next(self)

    def __next__(self):
        return _GCPnts.SwigPyIterator___next__(self)

    def previous(self):
        return _GCPnts.SwigPyIterator_previous(self)

    def advance(self, n):
        return _GCPnts.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _GCPnts.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _GCPnts.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _GCPnts.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _GCPnts.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _GCPnts.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _GCPnts.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self
SwigPyIterator_swigregister = _GCPnts.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

class NCollection_CellFilter_InspectorXYZ(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _GCPnts.NCollection_CellFilter_InspectorXYZ_Dimension
    Coord = staticmethod(_GCPnts.NCollection_CellFilter_InspectorXYZ_Coord)

    def Shift(self, thePnt, theTol):
        return _GCPnts.NCollection_CellFilter_InspectorXYZ_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _GCPnts.new_NCollection_CellFilter_InspectorXYZ()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _GCPnts.delete_NCollection_CellFilter_InspectorXYZ
NCollection_CellFilter_InspectorXYZ_swigregister = _GCPnts.NCollection_CellFilter_InspectorXYZ_swigregister
NCollection_CellFilter_InspectorXYZ_swigregister(NCollection_CellFilter_InspectorXYZ)

def NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt):
    return _GCPnts.NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt)
NCollection_CellFilter_InspectorXYZ_Coord = _GCPnts.NCollection_CellFilter_InspectorXYZ_Coord

class NCollection_CellFilter_InspectorXY(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _GCPnts.NCollection_CellFilter_InspectorXY_Dimension
    Coord = staticmethod(_GCPnts.NCollection_CellFilter_InspectorXY_Coord)

    def Shift(self, thePnt, theTol):
        return _GCPnts.NCollection_CellFilter_InspectorXY_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _GCPnts.new_NCollection_CellFilter_InspectorXY()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _GCPnts.delete_NCollection_CellFilter_InspectorXY
NCollection_CellFilter_InspectorXY_swigregister = _GCPnts.NCollection_CellFilter_InspectorXY_swigregister
NCollection_CellFilter_InspectorXY_swigregister(NCollection_CellFilter_InspectorXY)

def NCollection_CellFilter_InspectorXY_Coord(i, thePnt):
    return _GCPnts.NCollection_CellFilter_InspectorXY_Coord(i, thePnt)
NCollection_CellFilter_InspectorXY_Coord = _GCPnts.NCollection_CellFilter_InspectorXY_Coord


def ptr_to_number(item):
    return _GCPnts.ptr_to_number(item)
ptr_to_number = _GCPnts.ptr_to_number

def HashCode(*args):
    return _GCPnts.HashCode(*args)
HashCode = _GCPnts.HashCode

def ptr_equal(a, b):
    return _GCPnts.ptr_equal(a, b)
ptr_equal = _GCPnts.ptr_equal
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import GeomAbs
else:
    import GeomAbs
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import gp
else:
    import gp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColStd
else:
    import TColStd
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TCollection
else:
    import TCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Standard
else:
    import Standard
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import NCollection
else:
    import NCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Adaptor2d
else:
    import Adaptor2d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Geom2d
else:
    import Geom2d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColgp
else:
    import TColgp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Adaptor3d
else:
    import Adaptor3d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopAbs
else:
    import TopAbs
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Geom
else:
    import Geom
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import math
else:
    import math
del _swig_python_version_info
GCPnts_LengthParametrized = _GCPnts.GCPnts_LengthParametrized
GCPnts_Parametrized = _GCPnts.GCPnts_Parametrized
GCPnts_AbsComposite = _GCPnts.GCPnts_AbsComposite
GCPnts_Linear = _GCPnts.GCPnts_Linear
GCPnts_Circular = _GCPnts.GCPnts_Circular
GCPnts_Curved = _GCPnts.GCPnts_Curved
GCPnts_DefComposite = _GCPnts.GCPnts_DefComposite
class GCPnts_DistFunction2d(math.math_Function):
    """
    Class to define function, which calculates square distance between point on curve
    C(u), U1 <= u <= U2 and line passing through points C(U1) and C(U2)
    This function is used in any minimisation algorithm to define maximal deviation between curve and line,
    which required one variable function without derivative (for ex. math_BrentMinimum)
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(GCPnts_DistFunction2d self, Adaptor2d_Curve2d theCurve, Standard_Real const U1, Standard_Real const U2) -> GCPnts_DistFunction2d

        :type theCurve: OCC.wrapper.Adaptor2d.Adaptor2d_Curve2d
        :type U1: float
        :type U2: float

        """
        this = _GCPnts.new_GCPnts_DistFunction2d(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Value(self, *args):
        """
        Value(GCPnts_DistFunction2d self, Standard_Real const X) -> Standard_Boolean

        :type X: float
        :type F: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GCPnts.GCPnts_DistFunction2d_Value(self, *args)

    __swig_destroy__ = _GCPnts.delete_GCPnts_DistFunction2d
GCPnts_DistFunction2d_swigregister = _GCPnts.GCPnts_DistFunction2d_swigregister
GCPnts_DistFunction2d_swigregister(GCPnts_DistFunction2d)

class GCPnts_UniformAbscissa(object):
    """
    This class allows to compute a uniform distribution of points
    on a curve (ie the points will all be equally distant).
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(GCPnts_UniformAbscissa self) -> GCPnts_UniformAbscissa
        __init__(GCPnts_UniformAbscissa self, Adaptor3d_Curve C, Standard_Real const Abscissa, Standard_Real const Toler=-1) -> GCPnts_UniformAbscissa
        __init__(GCPnts_UniformAbscissa self, Adaptor3d_Curve C, Standard_Real const Abscissa, Standard_Real const U1, Standard_Real const U2, Standard_Real const Toler=-1) -> GCPnts_UniformAbscissa
        __init__(GCPnts_UniformAbscissa self, Adaptor3d_Curve C, Standard_Integer const NbPoints, Standard_Real const Toler=-1) -> GCPnts_UniformAbscissa
        __init__(GCPnts_UniformAbscissa self, Adaptor3d_Curve C, Standard_Integer const NbPoints, Standard_Real const U1, Standard_Real const U2, Standard_Real const Toler=-1) -> GCPnts_UniformAbscissa
        __init__(GCPnts_UniformAbscissa self, Adaptor2d_Curve2d C, Standard_Real const Abscissa, Standard_Real const Toler=-1) -> GCPnts_UniformAbscissa
        __init__(GCPnts_UniformAbscissa self, Adaptor2d_Curve2d C, Standard_Real const Abscissa, Standard_Real const U1, Standard_Real const U2, Standard_Real const Toler=-1) -> GCPnts_UniformAbscissa
        __init__(GCPnts_UniformAbscissa self, Adaptor2d_Curve2d C, Standard_Integer const NbPoints, Standard_Real const Toler=-1) -> GCPnts_UniformAbscissa
        __init__(GCPnts_UniformAbscissa self, Adaptor2d_Curve2d C, Standard_Integer const NbPoints, Standard_Real const U1, Standard_Real const U2, Standard_Real const Toler=-1) -> GCPnts_UniformAbscissa

        Computes a Uniform abscissa distribution of points
        on a part of the Curve2d <C>.
        Parameter Toler is equal Precision::Confusion by default.
        It Is used for more precise calculation of curve length

        :type C: OCC.wrapper.Adaptor2d.Adaptor2d_Curve2d
        :type NbPoints: int
        :type U1: float
        :type U2: float
        :type Toler: float

        """
        this = _GCPnts.new_GCPnts_UniformAbscissa(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Initialize(self, *args):
        """
        Initialize(GCPnts_UniformAbscissa self, Adaptor3d_Curve C, Standard_Real const Abscissa, Standard_Real const Toler=-1)
        Initialize(GCPnts_UniformAbscissa self, Adaptor3d_Curve C, Standard_Real const Abscissa, Standard_Real const U1, Standard_Real const U2, Standard_Real const Toler=-1)
        Initialize(GCPnts_UniformAbscissa self, Adaptor3d_Curve C, Standard_Integer const NbPoints, Standard_Real const Toler=-1)
        Initialize(GCPnts_UniformAbscissa self, Adaptor3d_Curve C, Standard_Integer const NbPoints, Standard_Real const U1, Standard_Real const U2, Standard_Real const Toler=-1)
        Initialize(GCPnts_UniformAbscissa self, Adaptor2d_Curve2d C, Standard_Real const Abscissa, Standard_Real const Toler=-1)
        Initialize(GCPnts_UniformAbscissa self, Adaptor2d_Curve2d C, Standard_Real const Abscissa, Standard_Real const U1, Standard_Real const U2, Standard_Real const Toler=-1)
        Initialize(GCPnts_UniformAbscissa self, Adaptor2d_Curve2d C, Standard_Integer const NbPoints, Standard_Real const Toler=-1)
        Initialize(GCPnts_UniformAbscissa self, Adaptor2d_Curve2d C, Standard_Integer const NbPoints, Standard_Real const U1, Standard_Real const U2, Standard_Real const Toler=-1)

        Initialize the algoritms with <C>, <Abscissa>, <U1>,
        <U2>, <Toler>.

        :type C: OCC.wrapper.Adaptor2d.Adaptor2d_Curve2d
        :type NbPoints: int
        :type U1: float
        :type U2: float
        :type Toler: float

        """
        return _GCPnts.GCPnts_UniformAbscissa_Initialize(self, *args)


    def IsDone(self, *args):
        """
        IsDone(GCPnts_UniformAbscissa self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GCPnts.GCPnts_UniformAbscissa_IsDone(self, *args)


    def NbPoints(self, *args):
        """
        NbPoints(GCPnts_UniformAbscissa self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GCPnts.GCPnts_UniformAbscissa_NbPoints(self, *args)


    def Parameter(self, *args):
        """
        Parameter(GCPnts_UniformAbscissa self, Standard_Integer const Index) -> Standard_Real

        returns the computed Parameter of index <Index>.

        :type Index: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _GCPnts.GCPnts_UniformAbscissa_Parameter(self, *args)


    def Abscissa(self, *args):
        """
        Abscissa(GCPnts_UniformAbscissa self) -> Standard_Real

        returne the current abscissa
        ie the distance between two consecutive points

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _GCPnts.GCPnts_UniformAbscissa_Abscissa(self, *args)

    __swig_destroy__ = _GCPnts.delete_GCPnts_UniformAbscissa
GCPnts_UniformAbscissa_swigregister = _GCPnts.GCPnts_UniformAbscissa_swigregister
GCPnts_UniformAbscissa_swigregister(GCPnts_UniformAbscissa)

class GCPnts_DistFunctionMV(math.math_MultipleVarFunction):
    """
    The same as class GCPnts_DistFunction, but it can be used in minimization algorithms that
    requires multi variable function
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(GCPnts_DistFunctionMV self, GCPnts_DistFunction theCurvLinDist) -> GCPnts_DistFunctionMV

        :type theCurvLinDist: OCC.wrapper.GCPnts.GCPnts_DistFunction

        """
        this = _GCPnts.new_GCPnts_DistFunctionMV(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Value(self, *args):
        """
        Value(GCPnts_DistFunctionMV self, math_Vector X) -> Standard_Boolean

        :type X: OCC.wrapper.math.math_Vector
        :type F: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GCPnts.GCPnts_DistFunctionMV_Value(self, *args)


    def NbVariables(self, *args):
        """
        NbVariables(GCPnts_DistFunctionMV self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GCPnts.GCPnts_DistFunctionMV_NbVariables(self, *args)

    __swig_destroy__ = _GCPnts.delete_GCPnts_DistFunctionMV
GCPnts_DistFunctionMV_swigregister = _GCPnts.GCPnts_DistFunctionMV_swigregister
GCPnts_DistFunctionMV_swigregister(GCPnts_DistFunctionMV)

class GCPnts_TangentialDeflection(object):
    """
    Computes a set of  points on a curve from package
    Adaptor3d  such  as between  two successive   points
    P1(u1)and P2(u2) :

    . ||P1P3^P3P2||/||P1P3||*||P3P2||<AngularDeflection
    . ||P1P2^P1P3||/||P1P2||<CurvatureDeflection

    where P3 is the point of abscissa ((u1+u2)/2), with
    u1 the abscissa of the point P1 and u2 the abscissa
    of the point P2.

    ^ is the cross product of two vectors, and ||P1P2||
    the magnitude of the vector P1P2.

    The conditions AngularDeflection > gp::Resolution()
    and CurvatureDeflection > gp::Resolution() must be
    satisfied at the construction time.

    A  minimum  number of points  can  be fixed   for a
    linear or circular element.
    Example:
    Handle(Geom_BezierCurve) C = new Geom_BezierCurve (Poles);
    GeomAdaptor_Curve Curve (C);
    Real CDeflect = 0.01;  //Curvature deflection
    Real ADeflect = 0.09; //Angular deflection

    GCPnts_TangentialDeflection PointsOnCurve;
    PointsOnCurve.Initialize (Curve, ADeflect, CDeflect);

    Real U;
    gp_Pnt P;
    for (Integer i=1; i<=PointsOnCurve.NbPoints();i++) {
    U = PointsOnCurve.Parameter (i);
    P = PointsOnCurve.Value (i);
    }
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(GCPnts_TangentialDeflection self) -> GCPnts_TangentialDeflection
        __init__(GCPnts_TangentialDeflection self, Adaptor3d_Curve C, Standard_Real const AngularDeflection, Standard_Real const CurvatureDeflection, Standard_Integer const MinimumOfPoints=2, Standard_Real const UTol=1.0e-9, Standard_Real const theMinLen=1.0e-7) -> GCPnts_TangentialDeflection
        __init__(GCPnts_TangentialDeflection self, Adaptor3d_Curve C, Standard_Real const FirstParameter, Standard_Real const LastParameter, Standard_Real const AngularDeflection, Standard_Real const CurvatureDeflection, Standard_Integer const MinimumOfPoints=2, Standard_Real const UTol=1.0e-9, Standard_Real const theMinLen=1.0e-7) -> GCPnts_TangentialDeflection
        __init__(GCPnts_TangentialDeflection self, Adaptor2d_Curve2d C, Standard_Real const AngularDeflection, Standard_Real const CurvatureDeflection, Standard_Integer const MinimumOfPoints=2, Standard_Real const UTol=1.0e-9, Standard_Real const theMinLen=1.0e-7) -> GCPnts_TangentialDeflection
        __init__(GCPnts_TangentialDeflection self, Adaptor2d_Curve2d C, Standard_Real const FirstParameter, Standard_Real const LastParameter, Standard_Real const AngularDeflection, Standard_Real const CurvatureDeflection, Standard_Integer const MinimumOfPoints=2, Standard_Real const UTol=1.0e-9, Standard_Real const theMinLen=1.0e-7) -> GCPnts_TangentialDeflection

        :type C: OCC.wrapper.Adaptor2d.Adaptor2d_Curve2d
        :type FirstParameter: float
        :type LastParameter: float
        :type AngularDeflection: float
        :type CurvatureDeflection: float
        :type MinimumOfPoints: int
        :type UTol: float
        :type theMinLen: float

        """
        this = _GCPnts.new_GCPnts_TangentialDeflection(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Initialize(self, *args):
        """
        Initialize(GCPnts_TangentialDeflection self, Adaptor3d_Curve C, Standard_Real const AngularDeflection, Standard_Real const CurvatureDeflection, Standard_Integer const MinimumOfPoints=2, Standard_Real const UTol=1.0e-9, Standard_Real const theMinLen=1.0e-7)
        Initialize(GCPnts_TangentialDeflection self, Adaptor3d_Curve C, Standard_Real const FirstParameter, Standard_Real const LastParameter, Standard_Real const AngularDeflection, Standard_Real const CurvatureDeflection, Standard_Integer const MinimumOfPoints=2, Standard_Real const UTol=1.0e-9, Standard_Real const theMinLen=1.0e-7)
        Initialize(GCPnts_TangentialDeflection self, Adaptor2d_Curve2d C, Standard_Real const AngularDeflection, Standard_Real const CurvatureDeflection, Standard_Integer const MinimumOfPoints=2, Standard_Real const UTol=1.0e-9, Standard_Real const theMinLen=1.0e-7)
        Initialize(GCPnts_TangentialDeflection self, Adaptor2d_Curve2d C, Standard_Real const FirstParameter, Standard_Real const LastParameter, Standard_Real const AngularDeflection, Standard_Real const CurvatureDeflection, Standard_Integer const MinimumOfPoints=2, Standard_Real const UTol=1.0e-9, Standard_Real const theMinLen=1.0e-7)

        :type C: OCC.wrapper.Adaptor2d.Adaptor2d_Curve2d
        :type FirstParameter: float
        :type LastParameter: float
        :type AngularDeflection: float
        :type CurvatureDeflection: float
        :type MinimumOfPoints: int
        :type UTol: float
        :type theMinLen: float

        """
        return _GCPnts.GCPnts_TangentialDeflection_Initialize(self, *args)


    def AddPoint(self, *args):
        """
        AddPoint(GCPnts_TangentialDeflection self, gp_Pnt thePnt, Standard_Real const theParam, Standard_Boolean const theIsReplace) -> Standard_Integer

        Add point to already calculated points (or replace existing)
        Returns index of new added point
        or founded with parametric tolerance (replaced if theIsReplace is true)

        :type thePnt: OCC.wrapper.gp.gp_Pnt
        :type theParam: float
        :type theIsReplace: bool
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GCPnts.GCPnts_TangentialDeflection_AddPoint(self, *args)


    def NbPoints(self, *args):
        """
        NbPoints(GCPnts_TangentialDeflection self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GCPnts.GCPnts_TangentialDeflection_NbPoints(self, *args)


    def Parameter(self, *args):
        """
        Parameter(GCPnts_TangentialDeflection self, Standard_Integer const I) -> Standard_Real

        :type I: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _GCPnts.GCPnts_TangentialDeflection_Parameter(self, *args)


    def Value(self, *args):
        """
        Value(GCPnts_TangentialDeflection self, Standard_Integer const I) -> gp_Pnt

        :type I: int
        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _GCPnts.GCPnts_TangentialDeflection_Value(self, *args)


    def ArcAngularStep(*args):
        """
        ArcAngularStep(Standard_Real const theRadius, Standard_Real const theLinearDeflection, Standard_Real const theAngularDeflection, Standard_Real const theMinLength) -> Standard_Real

        Computes angular step for the arc using the given parameters.

        :type theRadius: float
        :type theLinearDeflection: float
        :type theAngularDeflection: float
        :type theMinLength: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _GCPnts.GCPnts_TangentialDeflection_ArcAngularStep(*args)

    ArcAngularStep = staticmethod(ArcAngularStep)
    __swig_destroy__ = _GCPnts.delete_GCPnts_TangentialDeflection
GCPnts_TangentialDeflection_swigregister = _GCPnts.GCPnts_TangentialDeflection_swigregister
GCPnts_TangentialDeflection_swigregister(GCPnts_TangentialDeflection)

def GCPnts_TangentialDeflection_ArcAngularStep(*args):
    """
    GCPnts_TangentialDeflection_ArcAngularStep(Standard_Real const theRadius, Standard_Real const theLinearDeflection, Standard_Real const theAngularDeflection, Standard_Real const theMinLength) -> Standard_Real

    Computes angular step for the arc using the given parameters.

    :type theRadius: float
    :type theLinearDeflection: float
    :type theAngularDeflection: float
    :type theMinLength: float
    :rtype: OCC.wrapper.Standard.Standard_Real

    """
    return _GCPnts.GCPnts_TangentialDeflection_ArcAngularStep(*args)

class GCPnts_QuasiUniformAbscissa(object):
    """
    This class provides an algorithm to compute a uniform abscissa
    distribution of points on a curve, i.e. a sequence of
    equidistant points. The distance between two
    consecutive points is measured along the curve.
    The distribution is defined:
    -   either by the curvilinear distance between two consecutive points
    -   or by a number of points.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(GCPnts_QuasiUniformAbscissa self) -> GCPnts_QuasiUniformAbscissa
        __init__(GCPnts_QuasiUniformAbscissa self, Adaptor3d_Curve C, Standard_Integer const NbPoints) -> GCPnts_QuasiUniformAbscissa
        __init__(GCPnts_QuasiUniformAbscissa self, Adaptor3d_Curve C, Standard_Integer const NbPoints, Standard_Real const U1, Standard_Real const U2) -> GCPnts_QuasiUniformAbscissa
        __init__(GCPnts_QuasiUniformAbscissa self, Adaptor2d_Curve2d C, Standard_Integer const NbPoints) -> GCPnts_QuasiUniformAbscissa
        __init__(GCPnts_QuasiUniformAbscissa self, Adaptor2d_Curve2d C, Standard_Integer const NbPoints, Standard_Real const U1, Standard_Real const U2) -> GCPnts_QuasiUniformAbscissa

        Computes a Uniform abscissa distribution of points
        on a part of the Curve2d <C>.

        :type C: OCC.wrapper.Adaptor2d.Adaptor2d_Curve2d
        :type NbPoints: int
        :type U1: float
        :type U2: float

        """
        this = _GCPnts.new_GCPnts_QuasiUniformAbscissa(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Initialize(self, *args):
        """
        Initialize(GCPnts_QuasiUniformAbscissa self, Adaptor3d_Curve C, Standard_Integer const NbPoints)
        Initialize(GCPnts_QuasiUniformAbscissa self, Adaptor3d_Curve C, Standard_Integer const NbPoints, Standard_Real const U1, Standard_Real const U2)
        Initialize(GCPnts_QuasiUniformAbscissa self, Adaptor2d_Curve2d C, Standard_Integer const NbPoints)
        Initialize(GCPnts_QuasiUniformAbscissa self, Adaptor2d_Curve2d C, Standard_Integer const NbPoints, Standard_Real const U1, Standard_Real const U2)

        Initialize the algoritms with <C>, <Abscissa>, <U1>,
        <U2>.

        :type C: OCC.wrapper.Adaptor2d.Adaptor2d_Curve2d
        :type NbPoints: int
        :type U1: float
        :type U2: float

        """
        return _GCPnts.GCPnts_QuasiUniformAbscissa_Initialize(self, *args)


    def IsDone(self, *args):
        """
        IsDone(GCPnts_QuasiUniformAbscissa self) -> Standard_Boolean

        Returns true if the computation was successful.
        IsDone is a protection against:
        -   non-convergence of the algorithm
        -   querying the results before computation.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GCPnts.GCPnts_QuasiUniformAbscissa_IsDone(self, *args)


    def NbPoints(self, *args):
        """
        NbPoints(GCPnts_QuasiUniformAbscissa self) -> Standard_Integer

        Returns the number of points of the distribution
        computed by this algorithm.
        This value is either:
        -   the one imposed on the algorithm at the time of
        construction (or initialization), or
        -   the one computed by the algorithm when the
        curvilinear distance between two consecutive
        points of the distribution is imposed on the
        algorithm at the time of construction (or initialization).
        Exceptions
        StdFail_NotDone if this algorithm has not been
        initialized, or if the computation was not successful.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GCPnts.GCPnts_QuasiUniformAbscissa_NbPoints(self, *args)


    def Parameter(self, *args):
        """
        Parameter(GCPnts_QuasiUniformAbscissa self, Standard_Integer const Index) -> Standard_Real

        Returns the parameter of the point of index Index in
        the distribution computed by this algorithm.
        Warning
        Index must be greater than or equal to 1, and less
        than or equal to the number of points of the
        distribution. However, pay particular attention as this
        condition is not checked by this function.
        Exceptions
        StdFail_NotDone if this algorithm has not been
        initialized, or if the computation was not successful.

        :type Index: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _GCPnts.GCPnts_QuasiUniformAbscissa_Parameter(self, *args)

    __swig_destroy__ = _GCPnts.delete_GCPnts_QuasiUniformAbscissa
GCPnts_QuasiUniformAbscissa_swigregister = _GCPnts.GCPnts_QuasiUniformAbscissa_swigregister
GCPnts_QuasiUniformAbscissa_swigregister(GCPnts_QuasiUniformAbscissa)

class GCPnts_AbscissaPoint(object):
    """
    Provides an algorithm to compute a point on a curve
    situated at a given distance from another point on the
    curve, the distance being measured along the curve
    (curvilinear abscissa on the curve).
    This algorithm is also used to compute the length of a curve.
    An AbscissaPoint object provides a framework for:
    -   defining the point to compute
    -   implementing the construction algorithm
    -   consulting the result.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Length(*args):
        """
        Length(Adaptor3d_Curve C) -> Standard_Real
        Length(Adaptor2d_Curve2d C) -> Standard_Real
        Length(Adaptor3d_Curve C, Standard_Real const Tol) -> Standard_Real
        Length(Adaptor2d_Curve2d C, Standard_Real const Tol) -> Standard_Real
        Length(Adaptor3d_Curve C, Standard_Real const U1, Standard_Real const U2) -> Standard_Real
        Length(Adaptor2d_Curve2d C, Standard_Real const U1, Standard_Real const U2) -> Standard_Real
        Length(Adaptor3d_Curve C, Standard_Real const U1, Standard_Real const U2, Standard_Real const Tol) -> Standard_Real
        Length(Adaptor2d_Curve2d C, Standard_Real const U1, Standard_Real const U2, Standard_Real const Tol) -> Standard_Real

        Computes the length of the Curve <C> with the given tolerance.
        Constructs an empty algorithm. This function is used
        only for initializing a framework to compute the length
        of a curve (or a series of curves).
        Warning
        The function IsDone will return the value false after the use of this function.

        :type C: OCC.wrapper.Adaptor2d.Adaptor2d_Curve2d
        :type U1: float
        :type U2: float
        :type Tol: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _GCPnts.GCPnts_AbscissaPoint_Length(*args)

    Length = staticmethod(Length)

    def __init__(self, *args):
        """
        __init__(GCPnts_AbscissaPoint self) -> GCPnts_AbscissaPoint
        __init__(GCPnts_AbscissaPoint self, Adaptor3d_Curve C, Standard_Real const Abscissa, Standard_Real const U0) -> GCPnts_AbscissaPoint
        __init__(GCPnts_AbscissaPoint self, Standard_Real const Tol, Adaptor3d_Curve C, Standard_Real const Abscissa, Standard_Real const U0) -> GCPnts_AbscissaPoint
        __init__(GCPnts_AbscissaPoint self, Standard_Real const Tol, Adaptor2d_Curve2d C, Standard_Real const Abscissa, Standard_Real const U0) -> GCPnts_AbscissaPoint
        __init__(GCPnts_AbscissaPoint self, Adaptor2d_Curve2d C, Standard_Real const Abscissa, Standard_Real const U0) -> GCPnts_AbscissaPoint
        __init__(GCPnts_AbscissaPoint self, Adaptor3d_Curve C, Standard_Real const Abscissa, Standard_Real const U0, Standard_Real const Ui) -> GCPnts_AbscissaPoint
        __init__(GCPnts_AbscissaPoint self, Adaptor2d_Curve2d C, Standard_Real const Abscissa, Standard_Real const U0, Standard_Real const Ui) -> GCPnts_AbscissaPoint
        __init__(GCPnts_AbscissaPoint self, Adaptor3d_Curve C, Standard_Real const Abscissa, Standard_Real const U0, Standard_Real const Ui, Standard_Real const Tol) -> GCPnts_AbscissaPoint
        __init__(GCPnts_AbscissaPoint self, Adaptor2d_Curve2d C, Standard_Real const Abscissa, Standard_Real const U0, Standard_Real const Ui, Standard_Real const Tol) -> GCPnts_AbscissaPoint

        the algorithm computes a point on a curve <Curve> at the
        distance <Abscissa> from the point of parameter <U0>.
        <Ui> is the starting value used in the iterative process
        which find the solution, it must be close to the final
        solution

        :type C: OCC.wrapper.Adaptor2d.Adaptor2d_Curve2d
        :type Abscissa: float
        :type U0: float
        :type Ui: float
        :type Tol: float

        """
        this = _GCPnts.new_GCPnts_AbscissaPoint(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def IsDone(self, *args):
        """
        IsDone(GCPnts_AbscissaPoint self) -> Standard_Boolean

        True if the computation was successful, False otherwise.
        IsDone is a protection against:
        -   non-convergence of the algorithm
        -   querying the results before computation.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GCPnts.GCPnts_AbscissaPoint_IsDone(self, *args)


    def Parameter(self, *args):
        """
        Parameter(GCPnts_AbscissaPoint self) -> Standard_Real

        Returns the parameter on the curve of the point
        solution of this algorithm.
        Exceptions
        StdFail_NotDone if the computation was not
        successful, or was not done.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _GCPnts.GCPnts_AbscissaPoint_Parameter(self, *args)

    __swig_destroy__ = _GCPnts.delete_GCPnts_AbscissaPoint
GCPnts_AbscissaPoint_swigregister = _GCPnts.GCPnts_AbscissaPoint_swigregister
GCPnts_AbscissaPoint_swigregister(GCPnts_AbscissaPoint)

def GCPnts_AbscissaPoint_Length(*args):
    """
    Length(Adaptor3d_Curve C) -> Standard_Real
    Length(Adaptor2d_Curve2d C) -> Standard_Real
    Length(Adaptor3d_Curve C, Standard_Real const Tol) -> Standard_Real
    Length(Adaptor2d_Curve2d C, Standard_Real const Tol) -> Standard_Real
    Length(Adaptor3d_Curve C, Standard_Real const U1, Standard_Real const U2) -> Standard_Real
    Length(Adaptor2d_Curve2d C, Standard_Real const U1, Standard_Real const U2) -> Standard_Real
    Length(Adaptor3d_Curve C, Standard_Real const U1, Standard_Real const U2, Standard_Real const Tol) -> Standard_Real
    GCPnts_AbscissaPoint_Length(Adaptor2d_Curve2d C, Standard_Real const U1, Standard_Real const U2, Standard_Real const Tol) -> Standard_Real

    Computes the length of the Curve <C> with the given tolerance.
    Constructs an empty algorithm. This function is used
    only for initializing a framework to compute the length
    of a curve (or a series of curves).
    Warning
    The function IsDone will return the value false after the use of this function.

    :type C: OCC.wrapper.Adaptor2d.Adaptor2d_Curve2d
    :type U1: float
    :type U2: float
    :type Tol: float
    :rtype: OCC.wrapper.Standard.Standard_Real

    """
    return _GCPnts.GCPnts_AbscissaPoint_Length(*args)

class GCPnts_QuasiUniformDeflection(object):
    """
    This  class computes  a  distribution of  points  on a
    curve. The points may respect the deflection. The algorithm
    is not based on the  classical prediction (with second
    derivative of curve), but either  on the evaluation of
    the distance between the   mid point and the  point of
    mid parameter of    the two points,   or  the distance
    between the mid point and  the point at parameter  0.5
    on the cubic interpolation of the two points and their
    tangents.
    Note: this algorithm is faster than a
    GCPnts_UniformDeflection algorithm, and is
    able to work with non-"C2" continuous curves.
    However, it generates more points in the distribution.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(GCPnts_QuasiUniformDeflection self) -> GCPnts_QuasiUniformDeflection
        __init__(GCPnts_QuasiUniformDeflection self, Adaptor3d_Curve C, Standard_Real const Deflection, GeomAbs_Shape const Continuity=GeomAbs_C1) -> GCPnts_QuasiUniformDeflection
        __init__(GCPnts_QuasiUniformDeflection self, Adaptor2d_Curve2d C, Standard_Real const Deflection, GeomAbs_Shape const Continuity=GeomAbs_C1) -> GCPnts_QuasiUniformDeflection
        __init__(GCPnts_QuasiUniformDeflection self, Adaptor3d_Curve C, Standard_Real const Deflection, Standard_Real const U1, Standard_Real const U2, GeomAbs_Shape const Continuity=GeomAbs_C1) -> GCPnts_QuasiUniformDeflection
        __init__(GCPnts_QuasiUniformDeflection self, Adaptor2d_Curve2d C, Standard_Real const Deflection, Standard_Real const U1, Standard_Real const U2, GeomAbs_Shape const Continuity=GeomAbs_C1) -> GCPnts_QuasiUniformDeflection

        Computes  a QuasiUniform Deflection distribution
        of points on a part of the Curve <C>.
        This and the above algorithms compute a distribution of points:
        -   on the curve C, or
        -   on the part of curve C limited by the two
        parameter values U1 and U2,
        where the deflection resulting from the distributed
        points is not greater than Deflection.
        The first point of the distribution is either the origin of
        curve C or the point of parameter U1. The last point
        of the distribution is either the end point of curve C or
        the point of parameter U2.
        Intermediate points of the distribution are built such
        that the deflection is not greater than Deflection.
        Using the following evaluation of the deflection:
        if Pi and Pj are two consecutive points of the
        distribution, respectively of parameter ui and uj on
        the curve, the deflection is the distance between:
        -   the mid-point of Pi and Pj (the center of the
        chord joining these two points)
        -   and the point of mid-parameter of these two
        points (the point of parameter [(ui+uj) / 2 ] on curve C).
        Continuity, defaulted to GeomAbs_C1, gives the
        degree of continuity of the curve C. (Note that C is an
        Adaptor3d_Curve or an Adaptor2d_Curve2d
        object, and does not know the degree of continuity of
        the underlying curve).
        Use the function IsDone to verify that the
        computation was successful, the function NbPoints
        to obtain the number of points of the computed
        distribution, and the function Parameter to read the
        parameter of each point.
        Warning
        -   The roles of U1 and U2 are inverted if U1 > U2.
        -   Derivative functions on the curve are called
        according to Continuity. An error may occur if
        Continuity is greater than the real degree of
        continuity of the curve.
        Warning
        C is an adapted curve, i.e. an object which is an
        interface between:
        -   the services provided by either a 2D curve from
        the package Geom2d (in the case of an
        Adaptor2d_Curve2d curve) or a 3D curve from
        the package Geom (in the case of an
        Adaptor3d_Curve curve),
        -   and those required on the curve by the
        computation algorithm.

        :type C: OCC.wrapper.Adaptor2d.Adaptor2d_Curve2d
        :type Deflection: float
        :type U1: float
        :type U2: float
        :type Continuity: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        this = _GCPnts.new_GCPnts_QuasiUniformDeflection(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Initialize(self, *args):
        """
        Initialize(GCPnts_QuasiUniformDeflection self, Adaptor3d_Curve C, Standard_Real const Deflection, GeomAbs_Shape const Continuity=GeomAbs_C1)
        Initialize(GCPnts_QuasiUniformDeflection self, Adaptor2d_Curve2d C, Standard_Real const Deflection, GeomAbs_Shape const Continuity=GeomAbs_C1)
        Initialize(GCPnts_QuasiUniformDeflection self, Adaptor3d_Curve C, Standard_Real const Deflection, Standard_Real const U1, Standard_Real const U2, GeomAbs_Shape const Continuity=GeomAbs_C1)
        Initialize(GCPnts_QuasiUniformDeflection self, Adaptor2d_Curve2d C, Standard_Real const Deflection, Standard_Real const U1, Standard_Real const U2, GeomAbs_Shape const Continuity=GeomAbs_C1)

        Initialize  the  algoritms with <C>, <Deflection>,
        -- <U1>,<U2>
        This and the above algorithms initialize (or reinitialize)
        this algorithm and compute a distribution of points:
        -   on the curve C, or
        -   on the part of curve C limited by the two
        parameter values U1 and U2,
        where the deflection resulting from the distributed
        points is not greater than Deflection.
        The first point of the distribution is either the origin
        of curve C or the point of parameter U1. The last
        point of the distribution is either the end point of
        curve C or the point of parameter U2.
        Intermediate points of the distribution are built in
        such a way that the deflection is not greater than
        Deflection. Using the following evaluation of the deflection:
        if Pi and Pj are two consecutive points of the
        distribution, respectively of parameter ui and uj
        on the curve, the deflection is the distance between:
        -   the mid-point of Pi and Pj (the center of the
        chord joining these two points)
        -   and the point of mid-parameter of these two
        points (the point of parameter [(ui+uj) / 2 ] on curve C).
        Continuity, defaulted to GeomAbs_C1, gives the
        degree of continuity of the curve C. (Note that C is
        an Adaptor3d_Curve or an
        Adaptor2d_Curve2d object, and does not know
        the degree of continuity of the underlying curve).
        Use the function IsDone to verify that the
        computation was successful, the function NbPoints
        to obtain the number of points of the computed
        distribution, and the function Parameter to read
        the parameter of each point.
        Warning
        -   The roles of U1 and U2 are inverted if U1 > U2.
        -   Derivative functions on the curve are called
        according to Continuity. An error may occur if
        Continuity is greater than the real degree of
        continuity of the curve.
        Warning
        C is an adapted curve, i.e. an object which is an
        interface between:
        -   the services provided by either a 2D curve from
        the package Geom2d (in the case of an
        Adaptor2d_Curve2d curve) or a 3D curve from
        the package Geom (in the case of an Adaptor3d_Curve curve),
        and those required on the curve by the computation algorithm.

        :type C: OCC.wrapper.Adaptor2d.Adaptor2d_Curve2d
        :type Deflection: float
        :type U1: float
        :type U2: float
        :type Continuity: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _GCPnts.GCPnts_QuasiUniformDeflection_Initialize(self, *args)


    def IsDone(self, *args):
        """
        IsDone(GCPnts_QuasiUniformDeflection self) -> Standard_Boolean

        Returns true if the computation was successful.
        IsDone is a protection against:
        -   non-convergence of the algorithm
        -   querying the results before computation.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GCPnts.GCPnts_QuasiUniformDeflection_IsDone(self, *args)


    def NbPoints(self, *args):
        """
        NbPoints(GCPnts_QuasiUniformDeflection self) -> Standard_Integer

        Returns the number of points of the distribution
        computed by this algorithm.
        Exceptions
        StdFail_NotDone if this algorithm has not been
        initialized, or if the computation was not successful.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GCPnts.GCPnts_QuasiUniformDeflection_NbPoints(self, *args)


    def Parameter(self, *args):
        """
        Parameter(GCPnts_QuasiUniformDeflection self, Standard_Integer const Index) -> Standard_Real

        Returns the parameter of the point of index Index in
        the distribution computed by this algorithm.
        Warning
        Index must be greater than or equal to 1, and less
        than or equal to the number of points of the
        distribution. However, pay particular attention as this
        condition is not checked by this function.
        Exceptions
        StdFail_NotDone if this algorithm has not been
        initialized, or if the computation was not successful.

        :type Index: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _GCPnts.GCPnts_QuasiUniformDeflection_Parameter(self, *args)


    def Value(self, *args):
        """
        Value(GCPnts_QuasiUniformDeflection self, Standard_Integer const Index) -> gp_Pnt

        Returns the point of index Index in the distribution
        computed by this algorithm.
        Warning
        Index must be greater than or equal to 1, and less
        than or equal to the number of points of the
        distribution. However, pay particular attention as this
        condition is not checked by this function.
        Exceptions
        StdFail_NotDone if this algorithm has not been
        initialized, or if the computation was not successful.

        :type Index: int
        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _GCPnts.GCPnts_QuasiUniformDeflection_Value(self, *args)


    def Deflection(self, *args):
        """
        Deflection(GCPnts_QuasiUniformDeflection self) -> Standard_Real

        Returns the deflection between the curve and the
        polygon resulting from the points of the distribution
        computed by this algorithm.
        This is the value given to the algorithm at the time
        of construction (or initialization).
        Exceptions
        StdFail_NotDone if this algorithm has not been
        initialized, or if the computation was not successful.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _GCPnts.GCPnts_QuasiUniformDeflection_Deflection(self, *args)

    __swig_destroy__ = _GCPnts.delete_GCPnts_QuasiUniformDeflection
GCPnts_QuasiUniformDeflection_swigregister = _GCPnts.GCPnts_QuasiUniformDeflection_swigregister
GCPnts_QuasiUniformDeflection_swigregister(GCPnts_QuasiUniformDeflection)

class GCPnts_DistFunction(math.math_Function):
    """
    Class to define function, which calculates square distance between point on curve
    C(u), U1 <= u <= U2 and line passing through points C(U1) and C(U2)
    This function is used in any minimisation algorithm to define maximal deviation between curve and line,
    which required one variable function without derivative (for ex. math_BrentMinimum)
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(GCPnts_DistFunction self, Adaptor3d_Curve theCurve, Standard_Real const U1, Standard_Real const U2) -> GCPnts_DistFunction

        :type theCurve: OCC.wrapper.Adaptor3d.Adaptor3d_Curve
        :type U1: float
        :type U2: float

        """
        this = _GCPnts.new_GCPnts_DistFunction(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Value(self, *args):
        """
        Value(GCPnts_DistFunction self, Standard_Real const X) -> Standard_Boolean

        :type X: float
        :type F: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GCPnts.GCPnts_DistFunction_Value(self, *args)

    __swig_destroy__ = _GCPnts.delete_GCPnts_DistFunction
GCPnts_DistFunction_swigregister = _GCPnts.GCPnts_DistFunction_swigregister
GCPnts_DistFunction_swigregister(GCPnts_DistFunction)

class GCPnts_DistFunction2dMV(math.math_MultipleVarFunction):
    """
    The same as class GCPnts_DistFunction2d, 
    but it can be used in minimization algorithms that
    requires multi variable function
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(GCPnts_DistFunction2dMV self, GCPnts_DistFunction2d theCurvLinDist) -> GCPnts_DistFunction2dMV

        :type theCurvLinDist: OCC.wrapper.GCPnts.GCPnts_DistFunction2d

        """
        this = _GCPnts.new_GCPnts_DistFunction2dMV(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Value(self, *args):
        """
        Value(GCPnts_DistFunction2dMV self, math_Vector X) -> Standard_Boolean

        :type X: OCC.wrapper.math.math_Vector
        :type F: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GCPnts.GCPnts_DistFunction2dMV_Value(self, *args)


    def NbVariables(self, *args):
        """
        NbVariables(GCPnts_DistFunction2dMV self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GCPnts.GCPnts_DistFunction2dMV_NbVariables(self, *args)

    __swig_destroy__ = _GCPnts.delete_GCPnts_DistFunction2dMV
GCPnts_DistFunction2dMV_swigregister = _GCPnts.GCPnts_DistFunction2dMV_swigregister
GCPnts_DistFunction2dMV_swigregister(GCPnts_DistFunction2dMV)

class GCPnts_UniformDeflection(object):
    """
    Provides an algorithm to compute a distribution of
    points on a 'C2' continuous curve. The algorithm
    respects a criterion of maximum deflection between
    the curve and the polygon that results from the computed points.
    Note: This algorithm is relatively time consuming. A
    GCPnts_QuasiUniformDeflection algorithm is
    quicker; it can also work with non-'C2' continuous
    curves, but it generates more points in the distribution.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(GCPnts_UniformDeflection self) -> GCPnts_UniformDeflection
        __init__(GCPnts_UniformDeflection self, Adaptor3d_Curve C, Standard_Real const Deflection, Standard_Boolean const WithControl) -> GCPnts_UniformDeflection
        __init__(GCPnts_UniformDeflection self, Adaptor2d_Curve2d C, Standard_Real const Deflection, Standard_Boolean const WithControl) -> GCPnts_UniformDeflection
        __init__(GCPnts_UniformDeflection self, Adaptor3d_Curve C, Standard_Real const Deflection, Standard_Real const U1, Standard_Real const U2, Standard_Boolean const WithControl) -> GCPnts_UniformDeflection
        __init__(GCPnts_UniformDeflection self, Adaptor2d_Curve2d C, Standard_Real const Deflection, Standard_Real const U1, Standard_Real const U2, Standard_Boolean const WithControl) -> GCPnts_UniformDeflection

        Computes a Uniform Deflection distribution of points
        on a part of the Curve <C>.
        if <WithControl> is True,the algorithm controls the estimate
        deflection

        :type C: OCC.wrapper.Adaptor2d.Adaptor2d_Curve2d
        :type Deflection: float
        :type U1: float
        :type U2: float
        :type WithControl: bool

        """
        this = _GCPnts.new_GCPnts_UniformDeflection(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Initialize(self, *args):
        """
        Initialize(GCPnts_UniformDeflection self, Adaptor3d_Curve C, Standard_Real const Deflection, Standard_Boolean const WithControl)
        Initialize(GCPnts_UniformDeflection self, Adaptor2d_Curve2d C, Standard_Real const Deflection, Standard_Boolean const WithControl)
        Initialize(GCPnts_UniformDeflection self, Adaptor3d_Curve C, Standard_Real const Deflection, Standard_Real const U1, Standard_Real const U2, Standard_Boolean const WithControl)
        Initialize(GCPnts_UniformDeflection self, Adaptor2d_Curve2d C, Standard_Real const Deflection, Standard_Real const U1, Standard_Real const U2, Standard_Boolean const WithControl)

        Initialize the algoritms with <C>, <Deflection>,
        <U1>,<U2>
        This and the above methods initialize (or reinitialize) this algorithm and
        compute a distribution of points:
        -   on the curve C, or
        -   on the part of curve C limited by the two
        parameter values U1 and U2,
        where the maximum distance between C and the
        polygon that results from the points of the
        distribution is not greater than Deflection.
        The first point of the distribution is either the origin
        of curve C or the point of parameter U1. The last
        point of the distribution is either the end point of
        curve C or the point of parameter U2. Intermediate
        points of the distribution are built using
        interpolations of segments of the curve limited at
        the 2nd degree. The construction ensures, in a first
        step, that the chordal deviation for this
        interpolation of the curve is less than or equal to
        Deflection. However, it does not ensure that the
        chordal deviation for the curve itself is less than or
        equal to Deflection. To do this a check is
        necessary, which may generate (second step)
        additional intermediate points. This check is time
        consuming, and can be avoided by setting
        WithControl to false. Note that by default
        WithControl is true and check is performed.
        Use the function IsDone to verify that the
        computation was successful, the function NbPoints
        to obtain the number of points of the computed
        distribution, and the function Parameter to read
        the parameter of each point.
        Warning
        -   C is necessary, 'C2' continuous. This property is
        not checked at construction time.
        -   The roles of U1 and U2 are inverted if U1 > U2.
        Warning
        C is an adapted curve, i.e. an object which is an interface between:
        -   the services provided by either a 2D curve from
        the package Geom2d (in the case of an
        Adaptor2d_Curve2d curve) or a 3D curve from
        the package Geom (in the case of an Adaptor3d_Curve curve),
        -   and those required on the curve by the computation algorithm.

        :type C: OCC.wrapper.Adaptor2d.Adaptor2d_Curve2d
        :type Deflection: float
        :type U1: float
        :type U2: float
        :type WithControl: bool

        """
        return _GCPnts.GCPnts_UniformDeflection_Initialize(self, *args)


    def IsDone(self, *args):
        """
        IsDone(GCPnts_UniformDeflection self) -> Standard_Boolean

        Returns true if the computation was successful.
        IsDone is a protection against:
        -   non-convergence of the algorithm
        -   querying the results before computation.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GCPnts.GCPnts_UniformDeflection_IsDone(self, *args)


    def NbPoints(self, *args):
        """
        NbPoints(GCPnts_UniformDeflection self) -> Standard_Integer

        Returns the number of points of the distribution
        computed by this algorithm.
        Exceptions
        StdFail_NotDone if this algorithm has not been
        initialized, or if the computation was not successful.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GCPnts.GCPnts_UniformDeflection_NbPoints(self, *args)


    def Parameter(self, *args):
        """
        Parameter(GCPnts_UniformDeflection self, Standard_Integer const Index) -> Standard_Real

        Returns the parameter of the point of index Index in
        the distribution computed by this algorithm.
        Warning
        Index must be greater than or equal to 1, and less
        than or equal to the number of points of the
        distribution. However, pay particular attention as this
        condition is not checked by this function.
        Exceptions
        StdFail_NotDone if this algorithm has not been
        initialized, or if the computation was not successful.

        :type Index: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _GCPnts.GCPnts_UniformDeflection_Parameter(self, *args)


    def Value(self, *args):
        """
        Value(GCPnts_UniformDeflection self, Standard_Integer const Index) -> gp_Pnt

        Returns the point of index Index in the distribution
        computed by this algorithm.
        Warning
        Index must be greater than or equal to 1, and less
        than or equal to the number of points of the
        distribution. However, pay particular attention as this
        condition is not checked by this function.
        Exceptions
        StdFAil_NotDone if this algorithm has not been
        initialized, or if the computation was not successful.

        :type Index: int
        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _GCPnts.GCPnts_UniformDeflection_Value(self, *args)


    def Deflection(self, *args):
        """
        Deflection(GCPnts_UniformDeflection self) -> Standard_Real

        Returns the deflection between the curve and the
        polygon resulting from the points of the distribution
        computed by this algorithm.
        This value is the one given to the algorithm at the
        time of construction (or initialization).
        Exceptions
        StdFail_NotDone if this algorithm has not been
        initialized, or if the computation was not successful.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _GCPnts.GCPnts_UniformDeflection_Deflection(self, *args)

    __swig_destroy__ = _GCPnts.delete_GCPnts_UniformDeflection
GCPnts_UniformDeflection_swigregister = _GCPnts.GCPnts_UniformDeflection_swigregister
GCPnts_UniformDeflection_swigregister(GCPnts_UniformDeflection)




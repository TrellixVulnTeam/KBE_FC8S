# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_BRep')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_BRep')
    _BRep = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_BRep', [dirname(__file__)])
        except ImportError:
            import _BRep
            return _BRep
        try:
            _mod = imp.load_module('_BRep', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _BRep = swig_import_helper()
    del swig_import_helper
else:
    import _BRep
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


class SwigPyIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _BRep.delete_SwigPyIterator

    def value(self):
        return _BRep.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _BRep.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _BRep.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _BRep.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _BRep.SwigPyIterator_equal(self, x)

    def copy(self):
        return _BRep.SwigPyIterator_copy(self)

    def next(self):
        return _BRep.SwigPyIterator_next(self)

    def __next__(self):
        return _BRep.SwigPyIterator___next__(self)

    def previous(self):
        return _BRep.SwigPyIterator_previous(self)

    def advance(self, n):
        return _BRep.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _BRep.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _BRep.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _BRep.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _BRep.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _BRep.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _BRep.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self
SwigPyIterator_swigregister = _BRep.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

class NCollection_CellFilter_InspectorXYZ(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _BRep.NCollection_CellFilter_InspectorXYZ_Dimension
    Coord = staticmethod(_BRep.NCollection_CellFilter_InspectorXYZ_Coord)

    def Shift(self, thePnt, theTol):
        return _BRep.NCollection_CellFilter_InspectorXYZ_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _BRep.new_NCollection_CellFilter_InspectorXYZ()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _BRep.delete_NCollection_CellFilter_InspectorXYZ
NCollection_CellFilter_InspectorXYZ_swigregister = _BRep.NCollection_CellFilter_InspectorXYZ_swigregister
NCollection_CellFilter_InspectorXYZ_swigregister(NCollection_CellFilter_InspectorXYZ)

def NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt):
    return _BRep.NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt)
NCollection_CellFilter_InspectorXYZ_Coord = _BRep.NCollection_CellFilter_InspectorXYZ_Coord

class NCollection_CellFilter_InspectorXY(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _BRep.NCollection_CellFilter_InspectorXY_Dimension
    Coord = staticmethod(_BRep.NCollection_CellFilter_InspectorXY_Coord)

    def Shift(self, thePnt, theTol):
        return _BRep.NCollection_CellFilter_InspectorXY_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _BRep.new_NCollection_CellFilter_InspectorXY()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _BRep.delete_NCollection_CellFilter_InspectorXY
NCollection_CellFilter_InspectorXY_swigregister = _BRep.NCollection_CellFilter_InspectorXY_swigregister
NCollection_CellFilter_InspectorXY_swigregister(NCollection_CellFilter_InspectorXY)

def NCollection_CellFilter_InspectorXY_Coord(i, thePnt):
    return _BRep.NCollection_CellFilter_InspectorXY_Coord(i, thePnt)
NCollection_CellFilter_InspectorXY_Coord = _BRep.NCollection_CellFilter_InspectorXY_Coord


def ptr_to_number(item):
    return _BRep.ptr_to_number(item)
ptr_to_number = _BRep.ptr_to_number

def HashCode(*args):
    return _BRep.HashCode(*args)
HashCode = _BRep.HashCode

def ptr_equal(a, b):
    return _BRep.ptr_equal(a, b)
ptr_equal = _BRep.ptr_equal
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Geom2d
else:
    import Geom2d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import GeomAbs
else:
    import GeomAbs
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColStd
else:
    import TColStd
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TCollection
else:
    import TCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Standard
else:
    import Standard
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import NCollection
else:
    import NCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import gp
else:
    import gp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColgp
else:
    import TColgp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Poly
else:
    import Poly
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TShort
else:
    import TShort
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopAbs
else:
    import TopAbs
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Geom
else:
    import Geom
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopLoc
else:
    import TopLoc
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopoDS
else:
    import TopoDS
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Message
else:
    import Message
del _swig_python_version_info
class BRep_CurveRepresentation(Standard.Standard_Transient):
    """
    Root class for the curve representations. Contains
    a location.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_BRep_CurveRepresentation
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_BRep_CurveRepresentation(self) 
            return h


    def IsCurve3D(self, *args):
        """
        IsCurve3D(BRep_CurveRepresentation self) -> Standard_Boolean

        A 3D curve representation.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRep.BRep_CurveRepresentation_IsCurve3D(self, *args)


    def IsCurveOnClosedSurface(self, *args):
        """
        IsCurveOnClosedSurface(BRep_CurveRepresentation self) -> Standard_Boolean

        A curve with two parametric   curves  on the  same
        surface.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRep.BRep_CurveRepresentation_IsCurveOnClosedSurface(self, *args)


    def IsCurveOnSurface(self, *args):
        """
        IsCurveOnSurface(BRep_CurveRepresentation self) -> Standard_Boolean
        IsCurveOnSurface(BRep_CurveRepresentation self, Handle_Geom_Surface S, TopLoc_Location L) -> Standard_Boolean

        Is it a curve in the parametric space  of <S> with
        location <L>.

        :type S: OCC.wrapper.Geom.Handle_Geom_Surface
        :type L: OCC.wrapper.TopLoc.TopLoc_Location
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRep.BRep_CurveRepresentation_IsCurveOnSurface(self, *args)


    def IsRegularity(self, *args):
        """
        IsRegularity(BRep_CurveRepresentation self) -> Standard_Boolean
        IsRegularity(BRep_CurveRepresentation self, Handle_Geom_Surface S1, Handle_Geom_Surface S2, TopLoc_Location L1, TopLoc_Location L2) -> Standard_Boolean

        Is it  a  regularity between  <S1> and   <S2> with
        location <L1> and <L2>.

        :type S1: OCC.wrapper.Geom.Handle_Geom_Surface
        :type S2: OCC.wrapper.Geom.Handle_Geom_Surface
        :type L1: OCC.wrapper.TopLoc.TopLoc_Location
        :type L2: OCC.wrapper.TopLoc.TopLoc_Location
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRep.BRep_CurveRepresentation_IsRegularity(self, *args)


    def IsPolygon3D(self, *args):
        """
        IsPolygon3D(BRep_CurveRepresentation self) -> Standard_Boolean

        A 3D polygon representation.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRep.BRep_CurveRepresentation_IsPolygon3D(self, *args)


    def IsPolygonOnTriangulation(self, *args):
        """
        IsPolygonOnTriangulation(BRep_CurveRepresentation self) -> Standard_Boolean
        IsPolygonOnTriangulation(BRep_CurveRepresentation self, Handle_Poly_Triangulation T, TopLoc_Location L) -> Standard_Boolean

        Is it a polygon in the definition of <T> with
        location <L>.

        :type T: OCC.wrapper.Poly.Handle_Poly_Triangulation
        :type L: OCC.wrapper.TopLoc.TopLoc_Location
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRep.BRep_CurveRepresentation_IsPolygonOnTriangulation(self, *args)


    def IsPolygonOnClosedTriangulation(self, *args):
        """
        IsPolygonOnClosedTriangulation(BRep_CurveRepresentation self) -> Standard_Boolean

        A representation by two arrays of nodes on a
        triangulation.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRep.BRep_CurveRepresentation_IsPolygonOnClosedTriangulation(self, *args)


    def IsPolygonOnSurface(self, *args):
        """
        IsPolygonOnSurface(BRep_CurveRepresentation self) -> Standard_Boolean
        IsPolygonOnSurface(BRep_CurveRepresentation self, Handle_Geom_Surface S, TopLoc_Location L) -> Standard_Boolean

        Is it a polygon in the parametric space  of <S> with
        location <L>.

        :type S: OCC.wrapper.Geom.Handle_Geom_Surface
        :type L: OCC.wrapper.TopLoc.TopLoc_Location
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRep.BRep_CurveRepresentation_IsPolygonOnSurface(self, *args)


    def IsPolygonOnClosedSurface(self, *args):
        """
        IsPolygonOnClosedSurface(BRep_CurveRepresentation self) -> Standard_Boolean

        Two   2D polygon  representations  in the  parametric
        space of a surface.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRep.BRep_CurveRepresentation_IsPolygonOnClosedSurface(self, *args)


    def Location(self, *args):
        """
        :rtype: OCC.wrapper.TopLoc.TopLoc_Location

        """
        res = _BRep.BRep_CurveRepresentation_Location(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Curve3D(self, *args):
        """
        :rtype: OCC.wrapper.Geom.Handle_Geom_Curve

        """
        res = _BRep.BRep_CurveRepresentation_Curve3D(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Surface(self, *args):
        """
        :rtype: OCC.wrapper.Geom.Handle_Geom_Surface

        """
        res = _BRep.BRep_CurveRepresentation_Surface(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def PCurve(self, *args):
        """
        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Curve

        """
        res = _BRep.BRep_CurveRepresentation_PCurve(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def PCurve2(self, *args):
        """
        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Curve

        """
        res = _BRep.BRep_CurveRepresentation_PCurve2(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Polygon3D(self, *args):
        """
        :rtype: OCC.wrapper.Poly.Handle_Poly_Polygon3D

        """
        res = _BRep.BRep_CurveRepresentation_Polygon3D(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Polygon(self, *args):
        """
        :rtype: OCC.wrapper.Poly.Handle_Poly_Polygon2D

        """
        res = _BRep.BRep_CurveRepresentation_Polygon(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Polygon2(self, *args):
        """
        :rtype: OCC.wrapper.Poly.Handle_Poly_Polygon2D

        """
        res = _BRep.BRep_CurveRepresentation_Polygon2(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Triangulation(self, *args):
        """
        :rtype: OCC.wrapper.Poly.Handle_Poly_Triangulation

        """
        res = _BRep.BRep_CurveRepresentation_Triangulation(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def PolygonOnTriangulation(self, *args):
        """
        :rtype: OCC.wrapper.Poly.Handle_Poly_PolygonOnTriangulation

        """
        res = _BRep.BRep_CurveRepresentation_PolygonOnTriangulation(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def PolygonOnTriangulation2(self, *args):
        """
        :rtype: OCC.wrapper.Poly.Handle_Poly_PolygonOnTriangulation

        """
        res = _BRep.BRep_CurveRepresentation_PolygonOnTriangulation2(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Surface2(self, *args):
        """
        :rtype: OCC.wrapper.Geom.Handle_Geom_Surface

        """
        res = _BRep.BRep_CurveRepresentation_Surface2(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Location2(self, *args):
        """
        :rtype: OCC.wrapper.TopLoc.TopLoc_Location

        """
        res = _BRep.BRep_CurveRepresentation_Location2(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Continuity(self, *args):
        """
        :rtype: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        res = _BRep.BRep_CurveRepresentation_Continuity(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Copy(self, *args):
        """
        Copy(BRep_CurveRepresentation self) -> Handle_BRep_CurveRepresentation

        Return a copy of this representation.

        :rtype: OCC.wrapper.BRep.Handle_BRep_CurveRepresentation

        """
        return _BRep.BRep_CurveRepresentation_Copy(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _BRep.BRep_CurveRepresentation_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _BRep.BRep_CurveRepresentation_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _BRep.BRep_CurveRepresentation_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _BRep.delete_BRep_CurveRepresentation
BRep_CurveRepresentation_swigregister = _BRep.BRep_CurveRepresentation_swigregister
BRep_CurveRepresentation_swigregister(BRep_CurveRepresentation)

def BRep_CurveRepresentation_get_type_name(*args):
    """
    BRep_CurveRepresentation_get_type_name() -> char const *

    :rtype: const char *

    """
    return _BRep.BRep_CurveRepresentation_get_type_name(*args)

def BRep_CurveRepresentation_get_type_descriptor(*args):
    """
    BRep_CurveRepresentation_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _BRep.BRep_CurveRepresentation_get_type_descriptor(*args)

class BRep_PointRepresentation(Standard.Standard_Transient):
    """
    Root  class     for   the points  representations.
    Contains a location and a parameter.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_BRep_PointRepresentation
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_BRep_PointRepresentation(self) 
            return h


    def IsPointOnCurve(self, *args):
        """
        IsPointOnCurve(BRep_PointRepresentation self) -> Standard_Boolean
        IsPointOnCurve(BRep_PointRepresentation self, Handle_Geom_Curve C, TopLoc_Location L) -> Standard_Boolean

        A point on the curve <C>.

        :type C: OCC.wrapper.Geom.Handle_Geom_Curve
        :type L: OCC.wrapper.TopLoc.TopLoc_Location
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRep.BRep_PointRepresentation_IsPointOnCurve(self, *args)


    def IsPointOnCurveOnSurface(self, *args):
        """
        IsPointOnCurveOnSurface(BRep_PointRepresentation self) -> Standard_Boolean
        IsPointOnCurveOnSurface(BRep_PointRepresentation self, Handle_Geom2d_Curve PC, Handle_Geom_Surface S, TopLoc_Location L) -> Standard_Boolean

        A point on the 2d curve <PC> on the surface <S>.

        :type PC: OCC.wrapper.Geom2d.Handle_Geom2d_Curve
        :type S: OCC.wrapper.Geom.Handle_Geom_Surface
        :type L: OCC.wrapper.TopLoc.TopLoc_Location
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRep.BRep_PointRepresentation_IsPointOnCurveOnSurface(self, *args)


    def IsPointOnSurface(self, *args):
        """
        IsPointOnSurface(BRep_PointRepresentation self) -> Standard_Boolean
        IsPointOnSurface(BRep_PointRepresentation self, Handle_Geom_Surface S, TopLoc_Location L) -> Standard_Boolean

        A point on the surface <S>.

        :type S: OCC.wrapper.Geom.Handle_Geom_Surface
        :type L: OCC.wrapper.TopLoc.TopLoc_Location
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRep.BRep_PointRepresentation_IsPointOnSurface(self, *args)


    def Location(self, *args):
        """
        :rtype: OCC.wrapper.TopLoc.TopLoc_Location

        """
        res = _BRep.BRep_PointRepresentation_Location(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Parameter(self, *args):
        """
        Parameter(BRep_PointRepresentation self) -> Standard_Real
        Parameter(BRep_PointRepresentation self, Standard_Real const P)

        :type P: float

        """
        return _BRep.BRep_PointRepresentation_Parameter(self, *args)


    def Parameter2(self, *args):
        """
        Parameter2(BRep_PointRepresentation self) -> Standard_Real
        Parameter2(BRep_PointRepresentation self, Standard_Real const P)

        :type P: float

        """
        return _BRep.BRep_PointRepresentation_Parameter2(self, *args)


    def Curve(self, *args):
        """
        :rtype: OCC.wrapper.Geom.Handle_Geom_Curve

        """
        res = _BRep.BRep_PointRepresentation_Curve(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def PCurve(self, *args):
        """
        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Curve

        """
        res = _BRep.BRep_PointRepresentation_PCurve(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Surface(self, *args):
        """
        :rtype: OCC.wrapper.Geom.Handle_Geom_Surface

        """
        res = _BRep.BRep_PointRepresentation_Surface(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _BRep.BRep_PointRepresentation_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _BRep.BRep_PointRepresentation_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _BRep.BRep_PointRepresentation_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _BRep.delete_BRep_PointRepresentation
BRep_PointRepresentation_swigregister = _BRep.BRep_PointRepresentation_swigregister
BRep_PointRepresentation_swigregister(BRep_PointRepresentation)

def BRep_PointRepresentation_get_type_name(*args):
    """
    BRep_PointRepresentation_get_type_name() -> char const *

    :rtype: const char *

    """
    return _BRep.BRep_PointRepresentation_get_type_name(*args)

def BRep_PointRepresentation_get_type_descriptor(*args):
    """
    BRep_PointRepresentation_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _BRep.BRep_PointRepresentation_get_type_descriptor(*args)

class BRep_GCurve(BRep_CurveRepresentation):
    """
    Root   class    for    the    geometric     curves
    representation. Contains a range.
    Contains a first and a last parameter.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_BRep_GCurve
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_BRep_GCurve(self) 
            return h


    def SetRange(self, *args):
        """
        SetRange(BRep_GCurve self, Standard_Real const First, Standard_Real const Last)

        :type First: float
        :type Last: float

        """
        return _BRep.BRep_GCurve_SetRange(self, *args)


    def Range(self, *args):
        """
        Range(BRep_GCurve self)

        :type First: float
        :type Last: float

        """
        return _BRep.BRep_GCurve_Range(self, *args)


    def First(self, *args):
        """
        First(BRep_GCurve self) -> Standard_Real
        First(BRep_GCurve self, Standard_Real const F)

        :type F: float

        """
        return _BRep.BRep_GCurve_First(self, *args)


    def Last(self, *args):
        """
        Last(BRep_GCurve self) -> Standard_Real
        Last(BRep_GCurve self, Standard_Real const L)

        :type L: float

        """
        return _BRep.BRep_GCurve_Last(self, *args)


    def D0(self, *args):
        """
        D0(BRep_GCurve self, Standard_Real const U, gp_Pnt P)

        Computes the point at parameter U.

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt

        """
        return _BRep.BRep_GCurve_D0(self, *args)


    def Update(self, *args):
        """
        Update(BRep_GCurve self)

        Recomputes any derived data after a modification.
        This is called when the range is modified.


        """
        return _BRep.BRep_GCurve_Update(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _BRep.BRep_GCurve_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _BRep.BRep_GCurve_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _BRep.BRep_GCurve_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _BRep.delete_BRep_GCurve
BRep_GCurve_swigregister = _BRep.BRep_GCurve_swigregister
BRep_GCurve_swigregister(BRep_GCurve)

def BRep_GCurve_get_type_name(*args):
    """
    BRep_GCurve_get_type_name() -> char const *

    :rtype: const char *

    """
    return _BRep.BRep_GCurve_get_type_name(*args)

def BRep_GCurve_get_type_descriptor(*args):
    """
    BRep_GCurve_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _BRep.BRep_GCurve_get_type_descriptor(*args)

class BRep_PointsOnSurface(BRep_PointRepresentation):
    """Root for points on surface."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_BRep_PointsOnSurface
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_BRep_PointsOnSurface(self) 
            return h


    def Surface(self, *args):
        """
        :rtype: OCC.wrapper.Geom.Handle_Geom_Surface

        """
        res = _BRep.BRep_PointsOnSurface_Surface(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _BRep.BRep_PointsOnSurface_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _BRep.BRep_PointsOnSurface_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _BRep.BRep_PointsOnSurface_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _BRep.delete_BRep_PointsOnSurface
BRep_PointsOnSurface_swigregister = _BRep.BRep_PointsOnSurface_swigregister
BRep_PointsOnSurface_swigregister(BRep_PointsOnSurface)

def BRep_PointsOnSurface_get_type_name(*args):
    """
    BRep_PointsOnSurface_get_type_name() -> char const *

    :rtype: const char *

    """
    return _BRep.BRep_PointsOnSurface_get_type_name(*args)

def BRep_PointsOnSurface_get_type_descriptor(*args):
    """
    BRep_PointsOnSurface_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _BRep.BRep_PointsOnSurface_get_type_descriptor(*args)

class BRep_CurveOnSurface(BRep_GCurve):
    """
    Representation  of a  curve   by a   curve  in the
    parametric space of a surface.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_BRep_CurveOnSurface
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_BRep_CurveOnSurface(self) 
            return h


    def __init__(self, *args):
        """
        __init__(BRep_CurveOnSurface self, Handle_Geom2d_Curve PC, Handle_Geom_Surface S, TopLoc_Location L) -> BRep_CurveOnSurface

        :type PC: OCC.wrapper.Geom2d.Handle_Geom2d_Curve
        :type S: OCC.wrapper.Geom.Handle_Geom_Surface
        :type L: OCC.wrapper.TopLoc.TopLoc_Location

        """
        this = _BRep.new_BRep_CurveOnSurface(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def SetUVPoints(self, *args):
        """
        SetUVPoints(BRep_CurveOnSurface self, gp_Pnt2d P1, gp_Pnt2d P2)

        :type P1: OCC.wrapper.gp.gp_Pnt2d
        :type P2: OCC.wrapper.gp.gp_Pnt2d

        """
        return _BRep.BRep_CurveOnSurface_SetUVPoints(self, *args)


    def UVPoints(self, *args):
        """
        UVPoints(BRep_CurveOnSurface self, gp_Pnt2d P1, gp_Pnt2d P2)

        :type P1: OCC.wrapper.gp.gp_Pnt2d
        :type P2: OCC.wrapper.gp.gp_Pnt2d

        """
        return _BRep.BRep_CurveOnSurface_UVPoints(self, *args)


    def D0(self, *args):
        """
        D0(BRep_CurveOnSurface self, Standard_Real const U, gp_Pnt P)

        Computes the point at parameter U.

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt

        """
        return _BRep.BRep_CurveOnSurface_D0(self, *args)


    def IsCurveOnSurface(self, *args):
        """
        IsCurveOnSurface(BRep_CurveOnSurface self) -> Standard_Boolean
        IsCurveOnSurface(BRep_CurveOnSurface self, Handle_Geom_Surface S, TopLoc_Location L) -> Standard_Boolean

        A curve in the parametric space of a surface.

        :type S: OCC.wrapper.Geom.Handle_Geom_Surface
        :type L: OCC.wrapper.TopLoc.TopLoc_Location
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRep.BRep_CurveOnSurface_IsCurveOnSurface(self, *args)


    def Surface(self, *args):
        """
        :rtype: OCC.wrapper.Geom.Handle_Geom_Surface

        """
        res = _BRep.BRep_CurveOnSurface_Surface(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def PCurve(self, *args):
        """
        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Curve

        """
        res = _BRep.BRep_CurveOnSurface_PCurve(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Copy(self, *args):
        """
        Copy(BRep_CurveOnSurface self) -> Handle_BRep_CurveRepresentation

        Return a copy of this representation.

        :rtype: OCC.wrapper.BRep.Handle_BRep_CurveRepresentation

        """
        return _BRep.BRep_CurveOnSurface_Copy(self, *args)


    def Update(self, *args):
        """
        Update(BRep_CurveOnSurface self)

        Recomputes any derived data after a modification.
        This is called when the range is modified.


        """
        return _BRep.BRep_CurveOnSurface_Update(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _BRep.BRep_CurveOnSurface_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _BRep.BRep_CurveOnSurface_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _BRep.BRep_CurveOnSurface_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _BRep.delete_BRep_CurveOnSurface
BRep_CurveOnSurface_swigregister = _BRep.BRep_CurveOnSurface_swigregister
BRep_CurveOnSurface_swigregister(BRep_CurveOnSurface)

def BRep_CurveOnSurface_get_type_name(*args):
    """
    BRep_CurveOnSurface_get_type_name() -> char const *

    :rtype: const char *

    """
    return _BRep.BRep_CurveOnSurface_get_type_name(*args)

def BRep_CurveOnSurface_get_type_descriptor(*args):
    """
    BRep_CurveOnSurface_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _BRep.BRep_CurveOnSurface_get_type_descriptor(*args)

class BRep_PolygonOnTriangulation(BRep_CurveRepresentation):
    """
    A representation by an array of nodes on a
    triangulation.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_BRep_PolygonOnTriangulation
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_BRep_PolygonOnTriangulation(self) 
            return h


    def __init__(self, *args):
        """
        __init__(BRep_PolygonOnTriangulation self, Handle_Poly_PolygonOnTriangulation P, Handle_Poly_Triangulation T, TopLoc_Location L) -> BRep_PolygonOnTriangulation

        :type P: OCC.wrapper.Poly.Handle_Poly_PolygonOnTriangulation
        :type T: OCC.wrapper.Poly.Handle_Poly_Triangulation
        :type L: OCC.wrapper.TopLoc.TopLoc_Location

        """
        this = _BRep.new_BRep_PolygonOnTriangulation(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def IsPolygonOnTriangulation(self, *args):
        """
        IsPolygonOnTriangulation(BRep_PolygonOnTriangulation self) -> Standard_Boolean
        IsPolygonOnTriangulation(BRep_PolygonOnTriangulation self, Handle_Poly_Triangulation T, TopLoc_Location L) -> Standard_Boolean

        Is it a polygon in the definition of <T> with
        location <L>.

        :type T: OCC.wrapper.Poly.Handle_Poly_Triangulation
        :type L: OCC.wrapper.TopLoc.TopLoc_Location
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRep.BRep_PolygonOnTriangulation_IsPolygonOnTriangulation(self, *args)


    def Triangulation(self, *args):
        """
        :rtype: OCC.wrapper.Poly.Handle_Poly_Triangulation

        """
        res = _BRep.BRep_PolygonOnTriangulation_Triangulation(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def PolygonOnTriangulation(self, *args):
        """
        :rtype: OCC.wrapper.Poly.Handle_Poly_PolygonOnTriangulation

        """
        res = _BRep.BRep_PolygonOnTriangulation_PolygonOnTriangulation(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Copy(self, *args):
        """
        Copy(BRep_PolygonOnTriangulation self) -> Handle_BRep_CurveRepresentation

        Return a copy of this representation.

        :rtype: OCC.wrapper.BRep.Handle_BRep_CurveRepresentation

        """
        return _BRep.BRep_PolygonOnTriangulation_Copy(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _BRep.BRep_PolygonOnTriangulation_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _BRep.BRep_PolygonOnTriangulation_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _BRep.BRep_PolygonOnTriangulation_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _BRep.delete_BRep_PolygonOnTriangulation
BRep_PolygonOnTriangulation_swigregister = _BRep.BRep_PolygonOnTriangulation_swigregister
BRep_PolygonOnTriangulation_swigregister(BRep_PolygonOnTriangulation)

def BRep_PolygonOnTriangulation_get_type_name(*args):
    """
    BRep_PolygonOnTriangulation_get_type_name() -> char const *

    :rtype: const char *

    """
    return _BRep.BRep_PolygonOnTriangulation_get_type_name(*args)

def BRep_PolygonOnTriangulation_get_type_descriptor(*args):
    """
    BRep_PolygonOnTriangulation_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _BRep.BRep_PolygonOnTriangulation_get_type_descriptor(*args)

class BRep_PolygonOnClosedTriangulation(BRep_PolygonOnTriangulation):
    """
    A representation by two arrays of nodes on a
    triangulation.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_BRep_PolygonOnClosedTriangulation
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_BRep_PolygonOnClosedTriangulation(self) 
            return h


    def __init__(self, *args):
        """
        __init__(BRep_PolygonOnClosedTriangulation self, Handle_Poly_PolygonOnTriangulation P1, Handle_Poly_PolygonOnTriangulation P2, Handle_Poly_Triangulation Tr, TopLoc_Location L) -> BRep_PolygonOnClosedTriangulation

        :type P1: OCC.wrapper.Poly.Handle_Poly_PolygonOnTriangulation
        :type P2: OCC.wrapper.Poly.Handle_Poly_PolygonOnTriangulation
        :type Tr: OCC.wrapper.Poly.Handle_Poly_Triangulation
        :type L: OCC.wrapper.TopLoc.TopLoc_Location

        """
        this = _BRep.new_BRep_PolygonOnClosedTriangulation(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def IsPolygonOnClosedTriangulation(self, *args):
        """
        IsPolygonOnClosedTriangulation(BRep_PolygonOnClosedTriangulation self) -> Standard_Boolean

        Returns True.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRep.BRep_PolygonOnClosedTriangulation_IsPolygonOnClosedTriangulation(self, *args)


    def PolygonOnTriangulation2(self, *args):
        """
        :rtype: OCC.wrapper.Poly.Handle_Poly_PolygonOnTriangulation

        """
        res = _BRep.BRep_PolygonOnClosedTriangulation_PolygonOnTriangulation2(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Copy(self, *args):
        """
        Copy(BRep_PolygonOnClosedTriangulation self) -> Handle_BRep_CurveRepresentation

        Return a copy of this representation.

        :rtype: OCC.wrapper.BRep.Handle_BRep_CurveRepresentation

        """
        return _BRep.BRep_PolygonOnClosedTriangulation_Copy(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _BRep.BRep_PolygonOnClosedTriangulation_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _BRep.BRep_PolygonOnClosedTriangulation_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _BRep.BRep_PolygonOnClosedTriangulation_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _BRep.delete_BRep_PolygonOnClosedTriangulation
BRep_PolygonOnClosedTriangulation_swigregister = _BRep.BRep_PolygonOnClosedTriangulation_swigregister
BRep_PolygonOnClosedTriangulation_swigregister(BRep_PolygonOnClosedTriangulation)

def BRep_PolygonOnClosedTriangulation_get_type_name(*args):
    """
    BRep_PolygonOnClosedTriangulation_get_type_name() -> char const *

    :rtype: const char *

    """
    return _BRep.BRep_PolygonOnClosedTriangulation_get_type_name(*args)

def BRep_PolygonOnClosedTriangulation_get_type_descriptor(*args):
    """
    BRep_PolygonOnClosedTriangulation_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _BRep.BRep_PolygonOnClosedTriangulation_get_type_descriptor(*args)

class BRep_TFace(TopoDS.TopoDS_TFace):
    """
    The Tface from BRep  is  based  on the TFace  from
    TopoDS. The TFace contains :

    * A suface, a tolerance and a Location.

    * A NaturalRestriction flag,   when this  flag  is
    True the  boundary of the  face is known to be the
    parametric space (Umin, UMax, VMin, VMax).

    *  An    optional Triangulation.   If  there  is a
    triangulation the surface can be absent.

    The  Location is  used   for the Surface.

    The triangulation  is in the same reference system
    than the TFace.     A point on mySurface must   be
    transformed with myLocation,  but  not a point  on
    the triangulation.

    The Surface may  be shared by different TFaces but
    not the  Triangulation, because the  Triangulation
    may be modified by  the edges.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_BRep_TFace
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_BRep_TFace(self) 
            return h


    def __init__(self, *args):
        """
        __init__(BRep_TFace self) -> BRep_TFace

        Creates an empty TFace.


        """
        this = _BRep.new_BRep_TFace(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Surface(self, *args):
        """
        :rtype: OCC.wrapper.Geom.Handle_Geom_Surface

        """
        res = _BRep.BRep_TFace_Surface(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Triangulation(self, *args):
        """
        :rtype: OCC.wrapper.Poly.Handle_Poly_Triangulation

        """
        res = _BRep.BRep_TFace_Triangulation(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Location(self, *args):
        """
        :rtype: OCC.wrapper.TopLoc.TopLoc_Location

        """
        res = _BRep.BRep_TFace_Location(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Tolerance(self, *args):
        """
        Tolerance(BRep_TFace self) -> Standard_Real
        Tolerance(BRep_TFace self, Standard_Real const T)

        :type T: float

        """
        return _BRep.BRep_TFace_Tolerance(self, *args)


    def NaturalRestriction(self, *args):
        """
        NaturalRestriction(BRep_TFace self) -> Standard_Boolean
        NaturalRestriction(BRep_TFace self, Standard_Boolean const N)

        :type N: bool

        """
        return _BRep.BRep_TFace_NaturalRestriction(self, *args)


    def EmptyCopy(self, *args):
        """
        EmptyCopy(BRep_TFace self) -> Handle_TopoDS_TShape

        Returns a copy  of the  TShape  with no sub-shapes.
        The new Face has no triangulation.

        :rtype: OCC.wrapper.TopoDS.Handle_TopoDS_TShape

        """
        return _BRep.BRep_TFace_EmptyCopy(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _BRep.BRep_TFace_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _BRep.BRep_TFace_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _BRep.BRep_TFace_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _BRep.delete_BRep_TFace
BRep_TFace_swigregister = _BRep.BRep_TFace_swigregister
BRep_TFace_swigregister(BRep_TFace)

def BRep_TFace_get_type_name(*args):
    """
    BRep_TFace_get_type_name() -> char const *

    :rtype: const char *

    """
    return _BRep.BRep_TFace_get_type_name(*args)

def BRep_TFace_get_type_descriptor(*args):
    """
    BRep_TFace_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _BRep.BRep_TFace_get_type_descriptor(*args)

class BRep_PointOnCurve(BRep_PointRepresentation):
    """Representation by a parameter on a 3D curve."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_BRep_PointOnCurve
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_BRep_PointOnCurve(self) 
            return h


    def __init__(self, *args):
        """
        __init__(BRep_PointOnCurve self, Standard_Real const P, Handle_Geom_Curve C, TopLoc_Location L) -> BRep_PointOnCurve

        :type P: float
        :type C: OCC.wrapper.Geom.Handle_Geom_Curve
        :type L: OCC.wrapper.TopLoc.TopLoc_Location

        """
        this = _BRep.new_BRep_PointOnCurve(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def IsPointOnCurve(self, *args):
        """
        IsPointOnCurve(BRep_PointOnCurve self) -> Standard_Boolean
        IsPointOnCurve(BRep_PointOnCurve self, Handle_Geom_Curve C, TopLoc_Location L) -> Standard_Boolean

        :type C: OCC.wrapper.Geom.Handle_Geom_Curve
        :type L: OCC.wrapper.TopLoc.TopLoc_Location
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRep.BRep_PointOnCurve_IsPointOnCurve(self, *args)


    def Curve(self, *args):
        """
        :rtype: OCC.wrapper.Geom.Handle_Geom_Curve

        """
        res = _BRep.BRep_PointOnCurve_Curve(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _BRep.BRep_PointOnCurve_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _BRep.BRep_PointOnCurve_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _BRep.BRep_PointOnCurve_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _BRep.delete_BRep_PointOnCurve
BRep_PointOnCurve_swigregister = _BRep.BRep_PointOnCurve_swigregister
BRep_PointOnCurve_swigregister(BRep_PointOnCurve)

def BRep_PointOnCurve_get_type_name(*args):
    """
    BRep_PointOnCurve_get_type_name() -> char const *

    :rtype: const char *

    """
    return _BRep.BRep_PointOnCurve_get_type_name(*args)

def BRep_PointOnCurve_get_type_descriptor(*args):
    """
    BRep_PointOnCurve_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _BRep.BRep_PointOnCurve_get_type_descriptor(*args)

class BRep_PointOnSurface(BRep_PointsOnSurface):
    """Representation by two parameters on a surface."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_BRep_PointOnSurface
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_BRep_PointOnSurface(self) 
            return h


    def __init__(self, *args):
        """
        __init__(BRep_PointOnSurface self, Standard_Real const P1, Standard_Real const P2, Handle_Geom_Surface S, TopLoc_Location L) -> BRep_PointOnSurface

        :type P1: float
        :type P2: float
        :type S: OCC.wrapper.Geom.Handle_Geom_Surface
        :type L: OCC.wrapper.TopLoc.TopLoc_Location

        """
        this = _BRep.new_BRep_PointOnSurface(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def IsPointOnSurface(self, *args):
        """
        IsPointOnSurface(BRep_PointOnSurface self) -> Standard_Boolean
        IsPointOnSurface(BRep_PointOnSurface self, Handle_Geom_Surface S, TopLoc_Location L) -> Standard_Boolean

        :type S: OCC.wrapper.Geom.Handle_Geom_Surface
        :type L: OCC.wrapper.TopLoc.TopLoc_Location
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRep.BRep_PointOnSurface_IsPointOnSurface(self, *args)


    def Parameter2(self, *args):
        """
        Parameter2(BRep_PointOnSurface self) -> Standard_Real
        Parameter2(BRep_PointOnSurface self, Standard_Real const P)

        :type P: float

        """
        return _BRep.BRep_PointOnSurface_Parameter2(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _BRep.BRep_PointOnSurface_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _BRep.BRep_PointOnSurface_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _BRep.BRep_PointOnSurface_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _BRep.delete_BRep_PointOnSurface
BRep_PointOnSurface_swigregister = _BRep.BRep_PointOnSurface_swigregister
BRep_PointOnSurface_swigregister(BRep_PointOnSurface)

def BRep_PointOnSurface_get_type_name(*args):
    """
    BRep_PointOnSurface_get_type_name() -> char const *

    :rtype: const char *

    """
    return _BRep.BRep_PointOnSurface_get_type_name(*args)

def BRep_PointOnSurface_get_type_descriptor(*args):
    """
    BRep_PointOnSurface_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _BRep.BRep_PointOnSurface_get_type_descriptor(*args)

class BRep_CurveOnClosedSurface(BRep_CurveOnSurface):
    """
    Representation  of a    curve by two  pcurves   on
    a closed surface.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_BRep_CurveOnClosedSurface
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_BRep_CurveOnClosedSurface(self) 
            return h


    def __init__(self, *args):
        """
        __init__(BRep_CurveOnClosedSurface self, Handle_Geom2d_Curve PC1, Handle_Geom2d_Curve PC2, Handle_Geom_Surface S, TopLoc_Location L, GeomAbs_Shape const C) -> BRep_CurveOnClosedSurface

        :type PC1: OCC.wrapper.Geom2d.Handle_Geom2d_Curve
        :type PC2: OCC.wrapper.Geom2d.Handle_Geom2d_Curve
        :type S: OCC.wrapper.Geom.Handle_Geom_Surface
        :type L: OCC.wrapper.TopLoc.TopLoc_Location
        :type C: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        this = _BRep.new_BRep_CurveOnClosedSurface(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def SetUVPoints2(self, *args):
        """
        SetUVPoints2(BRep_CurveOnClosedSurface self, gp_Pnt2d P1, gp_Pnt2d P2)

        :type P1: OCC.wrapper.gp.gp_Pnt2d
        :type P2: OCC.wrapper.gp.gp_Pnt2d

        """
        return _BRep.BRep_CurveOnClosedSurface_SetUVPoints2(self, *args)


    def UVPoints2(self, *args):
        """
        UVPoints2(BRep_CurveOnClosedSurface self, gp_Pnt2d P1, gp_Pnt2d P2)

        :type P1: OCC.wrapper.gp.gp_Pnt2d
        :type P2: OCC.wrapper.gp.gp_Pnt2d

        """
        return _BRep.BRep_CurveOnClosedSurface_UVPoints2(self, *args)


    def IsCurveOnClosedSurface(self, *args):
        """
        IsCurveOnClosedSurface(BRep_CurveOnClosedSurface self) -> Standard_Boolean

        Returns True.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRep.BRep_CurveOnClosedSurface_IsCurveOnClosedSurface(self, *args)


    def IsRegularity(self, *args):
        """
        IsRegularity(BRep_CurveOnClosedSurface self) -> Standard_Boolean
        IsRegularity(BRep_CurveOnClosedSurface self, Handle_Geom_Surface S1, Handle_Geom_Surface S2, TopLoc_Location L1, TopLoc_Location L2) -> Standard_Boolean

        A curve on two surfaces (continuity).

        :type S1: OCC.wrapper.Geom.Handle_Geom_Surface
        :type S2: OCC.wrapper.Geom.Handle_Geom_Surface
        :type L1: OCC.wrapper.TopLoc.TopLoc_Location
        :type L2: OCC.wrapper.TopLoc.TopLoc_Location
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRep.BRep_CurveOnClosedSurface_IsRegularity(self, *args)


    def Surface2(self, *args):
        """
        Returns Surface()

        :rtype: OCC.wrapper.Geom.Handle_Geom_Surface

        """
        res = _BRep.BRep_CurveOnClosedSurface_Surface2(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Location2(self, *args):
        """
        Returns Location()

        :rtype: OCC.wrapper.TopLoc.TopLoc_Location

        """
        res = _BRep.BRep_CurveOnClosedSurface_Location2(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Continuity(self, *args):
        """
        :rtype: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        res = _BRep.BRep_CurveOnClosedSurface_Continuity(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def PCurve2(self, *args):
        """
        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Curve

        """
        res = _BRep.BRep_CurveOnClosedSurface_PCurve2(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Copy(self, *args):
        """
        Copy(BRep_CurveOnClosedSurface self) -> Handle_BRep_CurveRepresentation

        Return a copy of this representation.

        :rtype: OCC.wrapper.BRep.Handle_BRep_CurveRepresentation

        """
        return _BRep.BRep_CurveOnClosedSurface_Copy(self, *args)


    def Update(self, *args):
        """
        Update(BRep_CurveOnClosedSurface self)

        Recomputes any derived data after a modification.
        This is called when the range is modified.


        """
        return _BRep.BRep_CurveOnClosedSurface_Update(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _BRep.BRep_CurveOnClosedSurface_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _BRep.BRep_CurveOnClosedSurface_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _BRep.BRep_CurveOnClosedSurface_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _BRep.delete_BRep_CurveOnClosedSurface
BRep_CurveOnClosedSurface_swigregister = _BRep.BRep_CurveOnClosedSurface_swigregister
BRep_CurveOnClosedSurface_swigregister(BRep_CurveOnClosedSurface)

def BRep_CurveOnClosedSurface_get_type_name(*args):
    """
    BRep_CurveOnClosedSurface_get_type_name() -> char const *

    :rtype: const char *

    """
    return _BRep.BRep_CurveOnClosedSurface_get_type_name(*args)

def BRep_CurveOnClosedSurface_get_type_descriptor(*args):
    """
    BRep_CurveOnClosedSurface_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _BRep.BRep_CurveOnClosedSurface_get_type_descriptor(*args)

class BRep_CurveOn2Surfaces(BRep_CurveRepresentation):
    """Defines a continuity between two surfaces."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_BRep_CurveOn2Surfaces
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_BRep_CurveOn2Surfaces(self) 
            return h


    def __init__(self, *args):
        """
        __init__(BRep_CurveOn2Surfaces self, Handle_Geom_Surface S1, Handle_Geom_Surface S2, TopLoc_Location L1, TopLoc_Location L2, GeomAbs_Shape const C) -> BRep_CurveOn2Surfaces

        :type S1: OCC.wrapper.Geom.Handle_Geom_Surface
        :type S2: OCC.wrapper.Geom.Handle_Geom_Surface
        :type L1: OCC.wrapper.TopLoc.TopLoc_Location
        :type L2: OCC.wrapper.TopLoc.TopLoc_Location
        :type C: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        this = _BRep.new_BRep_CurveOn2Surfaces(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def IsRegularity(self, *args):
        """
        IsRegularity(BRep_CurveOn2Surfaces self) -> Standard_Boolean
        IsRegularity(BRep_CurveOn2Surfaces self, Handle_Geom_Surface S1, Handle_Geom_Surface S2, TopLoc_Location L1, TopLoc_Location L2) -> Standard_Boolean

        A curve on two surfaces (continuity).

        :type S1: OCC.wrapper.Geom.Handle_Geom_Surface
        :type S2: OCC.wrapper.Geom.Handle_Geom_Surface
        :type L1: OCC.wrapper.TopLoc.TopLoc_Location
        :type L2: OCC.wrapper.TopLoc.TopLoc_Location
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRep.BRep_CurveOn2Surfaces_IsRegularity(self, *args)


    def D0(self, *args):
        """
        D0(BRep_CurveOn2Surfaces self, Standard_Real const U, gp_Pnt P)

        Raises an error.

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt

        """
        return _BRep.BRep_CurveOn2Surfaces_D0(self, *args)


    def Surface(self, *args):
        """
        :rtype: OCC.wrapper.Geom.Handle_Geom_Surface

        """
        res = _BRep.BRep_CurveOn2Surfaces_Surface(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Surface2(self, *args):
        """
        :rtype: OCC.wrapper.Geom.Handle_Geom_Surface

        """
        res = _BRep.BRep_CurveOn2Surfaces_Surface2(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Location2(self, *args):
        """
        :rtype: OCC.wrapper.TopLoc.TopLoc_Location

        """
        res = _BRep.BRep_CurveOn2Surfaces_Location2(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Continuity(self, *args):
        """
        :rtype: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        res = _BRep.BRep_CurveOn2Surfaces_Continuity(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Copy(self, *args):
        """
        Copy(BRep_CurveOn2Surfaces self) -> Handle_BRep_CurveRepresentation

        Return a copy of this representation.

        :rtype: OCC.wrapper.BRep.Handle_BRep_CurveRepresentation

        """
        return _BRep.BRep_CurveOn2Surfaces_Copy(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _BRep.BRep_CurveOn2Surfaces_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _BRep.BRep_CurveOn2Surfaces_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _BRep.BRep_CurveOn2Surfaces_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _BRep.delete_BRep_CurveOn2Surfaces
BRep_CurveOn2Surfaces_swigregister = _BRep.BRep_CurveOn2Surfaces_swigregister
BRep_CurveOn2Surfaces_swigregister(BRep_CurveOn2Surfaces)

def BRep_CurveOn2Surfaces_get_type_name(*args):
    """
    BRep_CurveOn2Surfaces_get_type_name() -> char const *

    :rtype: const char *

    """
    return _BRep.BRep_CurveOn2Surfaces_get_type_name(*args)

def BRep_CurveOn2Surfaces_get_type_descriptor(*args):
    """
    BRep_CurveOn2Surfaces_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _BRep.BRep_CurveOn2Surfaces_get_type_descriptor(*args)

class BRep_PolygonOnSurface(BRep_CurveRepresentation):
    """
    Representation of a 2D polygon in the parametric
    space of a surface.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_BRep_PolygonOnSurface
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_BRep_PolygonOnSurface(self) 
            return h


    def __init__(self, *args):
        """
        __init__(BRep_PolygonOnSurface self, Handle_Poly_Polygon2D P, Handle_Geom_Surface S, TopLoc_Location L) -> BRep_PolygonOnSurface

        :type P: OCC.wrapper.Poly.Handle_Poly_Polygon2D
        :type S: OCC.wrapper.Geom.Handle_Geom_Surface
        :type L: OCC.wrapper.TopLoc.TopLoc_Location

        """
        this = _BRep.new_BRep_PolygonOnSurface(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def IsPolygonOnSurface(self, *args):
        """
        IsPolygonOnSurface(BRep_PolygonOnSurface self) -> Standard_Boolean
        IsPolygonOnSurface(BRep_PolygonOnSurface self, Handle_Geom_Surface S, TopLoc_Location L) -> Standard_Boolean

        A   2D polygon  representation  in the  parametric
        space of a surface.

        :type S: OCC.wrapper.Geom.Handle_Geom_Surface
        :type L: OCC.wrapper.TopLoc.TopLoc_Location
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRep.BRep_PolygonOnSurface_IsPolygonOnSurface(self, *args)


    def Surface(self, *args):
        """
        :rtype: OCC.wrapper.Geom.Handle_Geom_Surface

        """
        res = _BRep.BRep_PolygonOnSurface_Surface(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Polygon(self, *args):
        """
        :rtype: OCC.wrapper.Poly.Handle_Poly_Polygon2D

        """
        res = _BRep.BRep_PolygonOnSurface_Polygon(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Copy(self, *args):
        """
        Copy(BRep_PolygonOnSurface self) -> Handle_BRep_CurveRepresentation

        Return a copy of this representation.

        :rtype: OCC.wrapper.BRep.Handle_BRep_CurveRepresentation

        """
        return _BRep.BRep_PolygonOnSurface_Copy(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _BRep.BRep_PolygonOnSurface_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _BRep.BRep_PolygonOnSurface_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _BRep.BRep_PolygonOnSurface_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _BRep.delete_BRep_PolygonOnSurface
BRep_PolygonOnSurface_swigregister = _BRep.BRep_PolygonOnSurface_swigregister
BRep_PolygonOnSurface_swigregister(BRep_PolygonOnSurface)

def BRep_PolygonOnSurface_get_type_name(*args):
    """
    BRep_PolygonOnSurface_get_type_name() -> char const *

    :rtype: const char *

    """
    return _BRep.BRep_PolygonOnSurface_get_type_name(*args)

def BRep_PolygonOnSurface_get_type_descriptor(*args):
    """
    BRep_PolygonOnSurface_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _BRep.BRep_PolygonOnSurface_get_type_descriptor(*args)

class Handle_BRep_PolygonOnSurface(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_BRep_PolygonOnSurface self)

        Nullify the handle


        """
        return _BRep.Handle_BRep_PolygonOnSurface_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_BRep_PolygonOnSurface self) -> bool

        Check for being null

        :rtype: bool

        """
        return _BRep.Handle_BRep_PolygonOnSurface_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_BRep_PolygonOnSurface self, BRep_PolygonOnSurface thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _BRep.Handle_BRep_PolygonOnSurface_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_BRep_PolygonOnSurface self, Handle_BRep_PolygonOnSurface theHandle) -> Handle_BRep_PolygonOnSurface
        assign(Handle_BRep_PolygonOnSurface self, BRep_PolygonOnSurface thePtr) -> Handle_BRep_PolygonOnSurface
        assign(Handle_BRep_PolygonOnSurface self, Handle_BRep_PolygonOnSurface theHandle) -> Handle_BRep_PolygonOnSurface

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _BRep.Handle_BRep_PolygonOnSurface_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_BRep_PolygonOnSurface self) -> BRep_PolygonOnSurface

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _BRep.Handle_BRep_PolygonOnSurface_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_BRep_PolygonOnSurface self) -> BRep_PolygonOnSurface

        Member access operator (note non-const)

        :rtype: T *

        """
        return _BRep.Handle_BRep_PolygonOnSurface___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_BRep_PolygonOnSurface self) -> BRep_PolygonOnSurface

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _BRep.Handle_BRep_PolygonOnSurface___ref__(self, *args)


    def __hash__(self):
        return _BRep.Handle_BRep_PolygonOnSurface___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _BRep.Handle_BRep_PolygonOnSurface___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _BRep.new_Handle_BRep_PolygonOnSurface(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_BRep.Handle_BRep_PolygonOnSurface_DownCast)
    __swig_destroy__ = _BRep.delete_Handle_BRep_PolygonOnSurface

    def IsPolygonOnSurface(self, *args):
        """
        IsPolygonOnSurface(Handle_BRep_PolygonOnSurface self) -> Standard_Boolean
        IsPolygonOnSurface(Handle_BRep_PolygonOnSurface self, Handle_Geom_Surface S, TopLoc_Location L) -> Standard_Boolean

        A   2D polygon  representation  in the  parametric
        space of a surface.

        :type S: OCC.wrapper.Geom.Handle_Geom_Surface
        :type L: OCC.wrapper.TopLoc.TopLoc_Location
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRep.Handle_BRep_PolygonOnSurface_IsPolygonOnSurface(self, *args)


    def Surface(self, *args):
        """
        :rtype: OCC.wrapper.Geom.Handle_Geom_Surface

        """
        res = _BRep.Handle_BRep_PolygonOnSurface_Surface(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Polygon(self, *args):
        """
        :rtype: OCC.wrapper.Poly.Handle_Poly_Polygon2D

        """
        res = _BRep.Handle_BRep_PolygonOnSurface_Polygon(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Copy(self, *args):
        """
        Copy(Handle_BRep_PolygonOnSurface self) -> Handle_BRep_CurveRepresentation

        Return a copy of this representation.

        :rtype: OCC.wrapper.BRep.Handle_BRep_CurveRepresentation

        """
        return _BRep.Handle_BRep_PolygonOnSurface_Copy(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_BRep_PolygonOnSurface self) -> char const *

        :rtype: const char *

        """
        return _BRep.Handle_BRep_PolygonOnSurface_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _BRep.Handle_BRep_PolygonOnSurface_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _BRep.Handle_BRep_PolygonOnSurface_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def IsCurve3D(self, *args):
        """
        IsCurve3D(Handle_BRep_PolygonOnSurface self) -> Standard_Boolean

        A 3D curve representation.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRep.Handle_BRep_PolygonOnSurface_IsCurve3D(self, *args)


    def IsCurveOnSurface(self, *args):
        """
        IsCurveOnSurface(Handle_BRep_PolygonOnSurface self) -> Standard_Boolean
        IsCurveOnSurface(Handle_BRep_PolygonOnSurface self, Handle_Geom_Surface S, TopLoc_Location L) -> Standard_Boolean

        Is it a curve in the parametric space  of <S> with
        location <L>.

        :type S: OCC.wrapper.Geom.Handle_Geom_Surface
        :type L: OCC.wrapper.TopLoc.TopLoc_Location
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRep.Handle_BRep_PolygonOnSurface_IsCurveOnSurface(self, *args)


    def IsRegularity(self, *args):
        """
        IsRegularity(Handle_BRep_PolygonOnSurface self) -> Standard_Boolean
        IsRegularity(Handle_BRep_PolygonOnSurface self, Handle_Geom_Surface S1, Handle_Geom_Surface S2, TopLoc_Location L1, TopLoc_Location L2) -> Standard_Boolean

        Is it  a  regularity between  <S1> and   <S2> with
        location <L1> and <L2>.

        :type S1: OCC.wrapper.Geom.Handle_Geom_Surface
        :type S2: OCC.wrapper.Geom.Handle_Geom_Surface
        :type L1: OCC.wrapper.TopLoc.TopLoc_Location
        :type L2: OCC.wrapper.TopLoc.TopLoc_Location
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRep.Handle_BRep_PolygonOnSurface_IsRegularity(self, *args)


    def IsCurveOnClosedSurface(self, *args):
        """
        IsCurveOnClosedSurface(Handle_BRep_PolygonOnSurface self) -> Standard_Boolean

        A curve with two parametric   curves  on the  same
        surface.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRep.Handle_BRep_PolygonOnSurface_IsCurveOnClosedSurface(self, *args)


    def IsPolygon3D(self, *args):
        """
        IsPolygon3D(Handle_BRep_PolygonOnSurface self) -> Standard_Boolean

        A 3D polygon representation.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRep.Handle_BRep_PolygonOnSurface_IsPolygon3D(self, *args)


    def IsPolygonOnTriangulation(self, *args):
        """
        IsPolygonOnTriangulation(Handle_BRep_PolygonOnSurface self) -> Standard_Boolean
        IsPolygonOnTriangulation(Handle_BRep_PolygonOnSurface self, Handle_Poly_Triangulation T, TopLoc_Location L) -> Standard_Boolean

        Is it a polygon in the definition of <T> with
        location <L>.

        :type T: OCC.wrapper.Poly.Handle_Poly_Triangulation
        :type L: OCC.wrapper.TopLoc.TopLoc_Location
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRep.Handle_BRep_PolygonOnSurface_IsPolygonOnTriangulation(self, *args)


    def IsPolygonOnClosedTriangulation(self, *args):
        """
        IsPolygonOnClosedTriangulation(Handle_BRep_PolygonOnSurface self) -> Standard_Boolean

        A representation by two arrays of nodes on a
        triangulation.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRep.Handle_BRep_PolygonOnSurface_IsPolygonOnClosedTriangulation(self, *args)


    def IsPolygonOnClosedSurface(self, *args):
        """
        IsPolygonOnClosedSurface(Handle_BRep_PolygonOnSurface self) -> Standard_Boolean

        Two   2D polygon  representations  in the  parametric
        space of a surface.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRep.Handle_BRep_PolygonOnSurface_IsPolygonOnClosedSurface(self, *args)


    def Location(self, *args):
        """
        :rtype: OCC.wrapper.TopLoc.TopLoc_Location

        """
        res = _BRep.Handle_BRep_PolygonOnSurface_Location(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Curve3D(self, *args):
        """
        :rtype: OCC.wrapper.Geom.Handle_Geom_Curve

        """
        res = _BRep.Handle_BRep_PolygonOnSurface_Curve3D(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def PCurve(self, *args):
        """
        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Curve

        """
        res = _BRep.Handle_BRep_PolygonOnSurface_PCurve(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def PCurve2(self, *args):
        """
        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Curve

        """
        res = _BRep.Handle_BRep_PolygonOnSurface_PCurve2(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Polygon3D(self, *args):
        """
        :rtype: OCC.wrapper.Poly.Handle_Poly_Polygon3D

        """
        res = _BRep.Handle_BRep_PolygonOnSurface_Polygon3D(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Polygon2(self, *args):
        """
        :rtype: OCC.wrapper.Poly.Handle_Poly_Polygon2D

        """
        res = _BRep.Handle_BRep_PolygonOnSurface_Polygon2(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Triangulation(self, *args):
        """
        :rtype: OCC.wrapper.Poly.Handle_Poly_Triangulation

        """
        res = _BRep.Handle_BRep_PolygonOnSurface_Triangulation(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def PolygonOnTriangulation(self, *args):
        """
        :rtype: OCC.wrapper.Poly.Handle_Poly_PolygonOnTriangulation

        """
        res = _BRep.Handle_BRep_PolygonOnSurface_PolygonOnTriangulation(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def PolygonOnTriangulation2(self, *args):
        """
        :rtype: OCC.wrapper.Poly.Handle_Poly_PolygonOnTriangulation

        """
        res = _BRep.Handle_BRep_PolygonOnSurface_PolygonOnTriangulation2(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Surface2(self, *args):
        """
        :rtype: OCC.wrapper.Geom.Handle_Geom_Surface

        """
        res = _BRep.Handle_BRep_PolygonOnSurface_Surface2(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Location2(self, *args):
        """
        :rtype: OCC.wrapper.TopLoc.TopLoc_Location

        """
        res = _BRep.Handle_BRep_PolygonOnSurface_Location2(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Continuity(self, *args):
        """
        :rtype: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        res = _BRep.Handle_BRep_PolygonOnSurface_Continuity(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_BRep_PolygonOnSurface self)

        Memory deallocator for transient classes


        """
        return _BRep.Handle_BRep_PolygonOnSurface_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_BRep_PolygonOnSurface self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_BRep_PolygonOnSurface self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRep.Handle_BRep_PolygonOnSurface_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_BRep_PolygonOnSurface self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_BRep_PolygonOnSurface self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRep.Handle_BRep_PolygonOnSurface_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_BRep_PolygonOnSurface self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _BRep.Handle_BRep_PolygonOnSurface_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_BRep_PolygonOnSurface self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRep.Handle_BRep_PolygonOnSurface_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_BRep_PolygonOnSurface self)

        Increments the reference counter of this object


        """
        return _BRep.Handle_BRep_PolygonOnSurface_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_BRep_PolygonOnSurface self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRep.Handle_BRep_PolygonOnSurface_DecrementRefCounter(self, *args)

Handle_BRep_PolygonOnSurface_swigregister = _BRep.Handle_BRep_PolygonOnSurface_swigregister
Handle_BRep_PolygonOnSurface_swigregister(Handle_BRep_PolygonOnSurface)

def Handle_BRep_PolygonOnSurface_DownCast(thing):
    return _BRep.Handle_BRep_PolygonOnSurface_DownCast(thing)
Handle_BRep_PolygonOnSurface_DownCast = _BRep.Handle_BRep_PolygonOnSurface_DownCast

class BRep_Curve3D(BRep_GCurve):
    """Representation of a curve by a 3D curve."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_BRep_Curve3D
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_BRep_Curve3D(self) 
            return h


    def __init__(self, *args):
        """
        __init__(BRep_Curve3D self, Handle_Geom_Curve C, TopLoc_Location L) -> BRep_Curve3D

        :type C: OCC.wrapper.Geom.Handle_Geom_Curve
        :type L: OCC.wrapper.TopLoc.TopLoc_Location

        """
        this = _BRep.new_BRep_Curve3D(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def D0(self, *args):
        """
        D0(BRep_Curve3D self, Standard_Real const U, gp_Pnt P)

        Computes the point at parameter U.

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt

        """
        return _BRep.BRep_Curve3D_D0(self, *args)


    def IsCurve3D(self, *args):
        """
        IsCurve3D(BRep_Curve3D self) -> Standard_Boolean

        Returns True.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRep.BRep_Curve3D_IsCurve3D(self, *args)


    def Curve3D(self, *args):
        """
        :rtype: OCC.wrapper.Geom.Handle_Geom_Curve

        """
        res = _BRep.BRep_Curve3D_Curve3D(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Copy(self, *args):
        """
        Copy(BRep_Curve3D self) -> Handle_BRep_CurveRepresentation

        Return a copy of this representation.

        :rtype: OCC.wrapper.BRep.Handle_BRep_CurveRepresentation

        """
        return _BRep.BRep_Curve3D_Copy(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _BRep.BRep_Curve3D_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _BRep.BRep_Curve3D_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _BRep.BRep_Curve3D_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _BRep.delete_BRep_Curve3D
BRep_Curve3D_swigregister = _BRep.BRep_Curve3D_swigregister
BRep_Curve3D_swigregister(BRep_Curve3D)

def BRep_Curve3D_get_type_name(*args):
    """
    BRep_Curve3D_get_type_name() -> char const *

    :rtype: const char *

    """
    return _BRep.BRep_Curve3D_get_type_name(*args)

def BRep_Curve3D_get_type_descriptor(*args):
    """
    BRep_Curve3D_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _BRep.BRep_Curve3D_get_type_descriptor(*args)

class BRep_Polygon3D(BRep_CurveRepresentation):
    """Representation by a 3D polygon."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_BRep_Polygon3D
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_BRep_Polygon3D(self) 
            return h


    def __init__(self, *args):
        """
        __init__(BRep_Polygon3D self, Handle_Poly_Polygon3D P, TopLoc_Location L) -> BRep_Polygon3D

        :type P: OCC.wrapper.Poly.Handle_Poly_Polygon3D
        :type L: OCC.wrapper.TopLoc.TopLoc_Location

        """
        this = _BRep.new_BRep_Polygon3D(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def IsPolygon3D(self, *args):
        """
        IsPolygon3D(BRep_Polygon3D self) -> Standard_Boolean

        Returns True.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRep.BRep_Polygon3D_IsPolygon3D(self, *args)


    def Polygon3D(self, *args):
        """
        :rtype: OCC.wrapper.Poly.Handle_Poly_Polygon3D

        """
        res = _BRep.BRep_Polygon3D_Polygon3D(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Copy(self, *args):
        """
        Copy(BRep_Polygon3D self) -> Handle_BRep_CurveRepresentation

        Return a copy of this representation.

        :rtype: OCC.wrapper.BRep.Handle_BRep_CurveRepresentation

        """
        return _BRep.BRep_Polygon3D_Copy(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _BRep.BRep_Polygon3D_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _BRep.BRep_Polygon3D_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _BRep.BRep_Polygon3D_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _BRep.delete_BRep_Polygon3D
BRep_Polygon3D_swigregister = _BRep.BRep_Polygon3D_swigregister
BRep_Polygon3D_swigregister(BRep_Polygon3D)

def BRep_Polygon3D_get_type_name(*args):
    """
    BRep_Polygon3D_get_type_name() -> char const *

    :rtype: const char *

    """
    return _BRep.BRep_Polygon3D_get_type_name(*args)

def BRep_Polygon3D_get_type_descriptor(*args):
    """
    BRep_Polygon3D_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _BRep.BRep_Polygon3D_get_type_descriptor(*args)

class BRep_PolygonOnClosedSurface(BRep_PolygonOnSurface):
    """
    Representation by two 2d polygons in the parametric
    space of a surface.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_BRep_PolygonOnClosedSurface
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_BRep_PolygonOnClosedSurface(self) 
            return h


    def __init__(self, *args):
        """
        __init__(BRep_PolygonOnClosedSurface self, Handle_Poly_Polygon2D P1, Handle_Poly_Polygon2D P2, Handle_Geom_Surface S, TopLoc_Location L) -> BRep_PolygonOnClosedSurface

        :type P1: OCC.wrapper.Poly.Handle_Poly_Polygon2D
        :type P2: OCC.wrapper.Poly.Handle_Poly_Polygon2D
        :type S: OCC.wrapper.Geom.Handle_Geom_Surface
        :type L: OCC.wrapper.TopLoc.TopLoc_Location

        """
        this = _BRep.new_BRep_PolygonOnClosedSurface(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def IsPolygonOnClosedSurface(self, *args):
        """
        IsPolygonOnClosedSurface(BRep_PolygonOnClosedSurface self) -> Standard_Boolean

        returns True.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRep.BRep_PolygonOnClosedSurface_IsPolygonOnClosedSurface(self, *args)


    def Polygon2(self, *args):
        """
        :rtype: OCC.wrapper.Poly.Handle_Poly_Polygon2D

        """
        res = _BRep.BRep_PolygonOnClosedSurface_Polygon2(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Copy(self, *args):
        """
        Copy(BRep_PolygonOnClosedSurface self) -> Handle_BRep_CurveRepresentation

        Return a copy of this representation.

        :rtype: OCC.wrapper.BRep.Handle_BRep_CurveRepresentation

        """
        return _BRep.BRep_PolygonOnClosedSurface_Copy(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _BRep.BRep_PolygonOnClosedSurface_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _BRep.BRep_PolygonOnClosedSurface_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _BRep.BRep_PolygonOnClosedSurface_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _BRep.delete_BRep_PolygonOnClosedSurface
BRep_PolygonOnClosedSurface_swigregister = _BRep.BRep_PolygonOnClosedSurface_swigregister
BRep_PolygonOnClosedSurface_swigregister(BRep_PolygonOnClosedSurface)

def BRep_PolygonOnClosedSurface_get_type_name(*args):
    """
    BRep_PolygonOnClosedSurface_get_type_name() -> char const *

    :rtype: const char *

    """
    return _BRep.BRep_PolygonOnClosedSurface_get_type_name(*args)

def BRep_PolygonOnClosedSurface_get_type_descriptor(*args):
    """
    BRep_PolygonOnClosedSurface_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _BRep.BRep_PolygonOnClosedSurface_get_type_descriptor(*args)

class Handle_BRep_PolygonOnClosedTriangulation(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_BRep_PolygonOnClosedTriangulation self)

        Nullify the handle


        """
        return _BRep.Handle_BRep_PolygonOnClosedTriangulation_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_BRep_PolygonOnClosedTriangulation self) -> bool

        Check for being null

        :rtype: bool

        """
        return _BRep.Handle_BRep_PolygonOnClosedTriangulation_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_BRep_PolygonOnClosedTriangulation self, BRep_PolygonOnClosedTriangulation thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _BRep.Handle_BRep_PolygonOnClosedTriangulation_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_BRep_PolygonOnClosedTriangulation self, Handle_BRep_PolygonOnClosedTriangulation theHandle) -> Handle_BRep_PolygonOnClosedTriangulation
        assign(Handle_BRep_PolygonOnClosedTriangulation self, BRep_PolygonOnClosedTriangulation thePtr) -> Handle_BRep_PolygonOnClosedTriangulation
        assign(Handle_BRep_PolygonOnClosedTriangulation self, Handle_BRep_PolygonOnClosedTriangulation theHandle) -> Handle_BRep_PolygonOnClosedTriangulation

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _BRep.Handle_BRep_PolygonOnClosedTriangulation_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_BRep_PolygonOnClosedTriangulation self) -> BRep_PolygonOnClosedTriangulation

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _BRep.Handle_BRep_PolygonOnClosedTriangulation_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_BRep_PolygonOnClosedTriangulation self) -> BRep_PolygonOnClosedTriangulation

        Member access operator (note non-const)

        :rtype: T *

        """
        return _BRep.Handle_BRep_PolygonOnClosedTriangulation___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_BRep_PolygonOnClosedTriangulation self) -> BRep_PolygonOnClosedTriangulation

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _BRep.Handle_BRep_PolygonOnClosedTriangulation___ref__(self, *args)


    def __hash__(self):
        return _BRep.Handle_BRep_PolygonOnClosedTriangulation___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _BRep.Handle_BRep_PolygonOnClosedTriangulation___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _BRep.new_Handle_BRep_PolygonOnClosedTriangulation(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_BRep.Handle_BRep_PolygonOnClosedTriangulation_DownCast)
    __swig_destroy__ = _BRep.delete_Handle_BRep_PolygonOnClosedTriangulation

    def IsPolygonOnClosedTriangulation(self, *args):
        """
        IsPolygonOnClosedTriangulation(Handle_BRep_PolygonOnClosedTriangulation self) -> Standard_Boolean

        Returns True.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRep.Handle_BRep_PolygonOnClosedTriangulation_IsPolygonOnClosedTriangulation(self, *args)


    def PolygonOnTriangulation2(self, *args):
        """
        :rtype: OCC.wrapper.Poly.Handle_Poly_PolygonOnTriangulation

        """
        res = _BRep.Handle_BRep_PolygonOnClosedTriangulation_PolygonOnTriangulation2(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Copy(self, *args):
        """
        Copy(Handle_BRep_PolygonOnClosedTriangulation self) -> Handle_BRep_CurveRepresentation

        Return a copy of this representation.

        :rtype: OCC.wrapper.BRep.Handle_BRep_CurveRepresentation

        """
        return _BRep.Handle_BRep_PolygonOnClosedTriangulation_Copy(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_BRep_PolygonOnClosedTriangulation self) -> char const *

        :rtype: const char *

        """
        return _BRep.Handle_BRep_PolygonOnClosedTriangulation_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _BRep.Handle_BRep_PolygonOnClosedTriangulation_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _BRep.Handle_BRep_PolygonOnClosedTriangulation_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def IsPolygonOnTriangulation(self, *args):
        """
        IsPolygonOnTriangulation(Handle_BRep_PolygonOnClosedTriangulation self) -> Standard_Boolean
        IsPolygonOnTriangulation(Handle_BRep_PolygonOnClosedTriangulation self, Handle_Poly_Triangulation T, TopLoc_Location L) -> Standard_Boolean

        Is it a polygon in the definition of <T> with
        location <L>.

        :type T: OCC.wrapper.Poly.Handle_Poly_Triangulation
        :type L: OCC.wrapper.TopLoc.TopLoc_Location
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRep.Handle_BRep_PolygonOnClosedTriangulation_IsPolygonOnTriangulation(self, *args)


    def PolygonOnTriangulation(self, *args):
        """
        :rtype: OCC.wrapper.Poly.Handle_Poly_PolygonOnTriangulation

        """
        res = _BRep.Handle_BRep_PolygonOnClosedTriangulation_PolygonOnTriangulation(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Triangulation(self, *args):
        """
        :rtype: OCC.wrapper.Poly.Handle_Poly_Triangulation

        """
        res = _BRep.Handle_BRep_PolygonOnClosedTriangulation_Triangulation(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def IsCurve3D(self, *args):
        """
        IsCurve3D(Handle_BRep_PolygonOnClosedTriangulation self) -> Standard_Boolean

        A 3D curve representation.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRep.Handle_BRep_PolygonOnClosedTriangulation_IsCurve3D(self, *args)


    def IsCurveOnSurface(self, *args):
        """
        IsCurveOnSurface(Handle_BRep_PolygonOnClosedTriangulation self) -> Standard_Boolean
        IsCurveOnSurface(Handle_BRep_PolygonOnClosedTriangulation self, Handle_Geom_Surface S, TopLoc_Location L) -> Standard_Boolean

        Is it a curve in the parametric space  of <S> with
        location <L>.

        :type S: OCC.wrapper.Geom.Handle_Geom_Surface
        :type L: OCC.wrapper.TopLoc.TopLoc_Location
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRep.Handle_BRep_PolygonOnClosedTriangulation_IsCurveOnSurface(self, *args)


    def IsRegularity(self, *args):
        """
        IsRegularity(Handle_BRep_PolygonOnClosedTriangulation self) -> Standard_Boolean
        IsRegularity(Handle_BRep_PolygonOnClosedTriangulation self, Handle_Geom_Surface S1, Handle_Geom_Surface S2, TopLoc_Location L1, TopLoc_Location L2) -> Standard_Boolean

        Is it  a  regularity between  <S1> and   <S2> with
        location <L1> and <L2>.

        :type S1: OCC.wrapper.Geom.Handle_Geom_Surface
        :type S2: OCC.wrapper.Geom.Handle_Geom_Surface
        :type L1: OCC.wrapper.TopLoc.TopLoc_Location
        :type L2: OCC.wrapper.TopLoc.TopLoc_Location
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRep.Handle_BRep_PolygonOnClosedTriangulation_IsRegularity(self, *args)


    def IsCurveOnClosedSurface(self, *args):
        """
        IsCurveOnClosedSurface(Handle_BRep_PolygonOnClosedTriangulation self) -> Standard_Boolean

        A curve with two parametric   curves  on the  same
        surface.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRep.Handle_BRep_PolygonOnClosedTriangulation_IsCurveOnClosedSurface(self, *args)


    def IsPolygon3D(self, *args):
        """
        IsPolygon3D(Handle_BRep_PolygonOnClosedTriangulation self) -> Standard_Boolean

        A 3D polygon representation.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRep.Handle_BRep_PolygonOnClosedTriangulation_IsPolygon3D(self, *args)


    def IsPolygonOnSurface(self, *args):
        """
        IsPolygonOnSurface(Handle_BRep_PolygonOnClosedTriangulation self) -> Standard_Boolean
        IsPolygonOnSurface(Handle_BRep_PolygonOnClosedTriangulation self, Handle_Geom_Surface S, TopLoc_Location L) -> Standard_Boolean

        Is it a polygon in the parametric space  of <S> with
        location <L>.

        :type S: OCC.wrapper.Geom.Handle_Geom_Surface
        :type L: OCC.wrapper.TopLoc.TopLoc_Location
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRep.Handle_BRep_PolygonOnClosedTriangulation_IsPolygonOnSurface(self, *args)


    def IsPolygonOnClosedSurface(self, *args):
        """
        IsPolygonOnClosedSurface(Handle_BRep_PolygonOnClosedTriangulation self) -> Standard_Boolean

        Two   2D polygon  representations  in the  parametric
        space of a surface.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRep.Handle_BRep_PolygonOnClosedTriangulation_IsPolygonOnClosedSurface(self, *args)


    def Location(self, *args):
        """
        :rtype: OCC.wrapper.TopLoc.TopLoc_Location

        """
        res = _BRep.Handle_BRep_PolygonOnClosedTriangulation_Location(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Curve3D(self, *args):
        """
        :rtype: OCC.wrapper.Geom.Handle_Geom_Curve

        """
        res = _BRep.Handle_BRep_PolygonOnClosedTriangulation_Curve3D(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Surface(self, *args):
        """
        :rtype: OCC.wrapper.Geom.Handle_Geom_Surface

        """
        res = _BRep.Handle_BRep_PolygonOnClosedTriangulation_Surface(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def PCurve(self, *args):
        """
        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Curve

        """
        res = _BRep.Handle_BRep_PolygonOnClosedTriangulation_PCurve(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def PCurve2(self, *args):
        """
        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Curve

        """
        res = _BRep.Handle_BRep_PolygonOnClosedTriangulation_PCurve2(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Polygon3D(self, *args):
        """
        :rtype: OCC.wrapper.Poly.Handle_Poly_Polygon3D

        """
        res = _BRep.Handle_BRep_PolygonOnClosedTriangulation_Polygon3D(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Polygon(self, *args):
        """
        :rtype: OCC.wrapper.Poly.Handle_Poly_Polygon2D

        """
        res = _BRep.Handle_BRep_PolygonOnClosedTriangulation_Polygon(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Polygon2(self, *args):
        """
        :rtype: OCC.wrapper.Poly.Handle_Poly_Polygon2D

        """
        res = _BRep.Handle_BRep_PolygonOnClosedTriangulation_Polygon2(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Surface2(self, *args):
        """
        :rtype: OCC.wrapper.Geom.Handle_Geom_Surface

        """
        res = _BRep.Handle_BRep_PolygonOnClosedTriangulation_Surface2(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Location2(self, *args):
        """
        :rtype: OCC.wrapper.TopLoc.TopLoc_Location

        """
        res = _BRep.Handle_BRep_PolygonOnClosedTriangulation_Location2(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Continuity(self, *args):
        """
        :rtype: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        res = _BRep.Handle_BRep_PolygonOnClosedTriangulation_Continuity(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_BRep_PolygonOnClosedTriangulation self)

        Memory deallocator for transient classes


        """
        return _BRep.Handle_BRep_PolygonOnClosedTriangulation_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_BRep_PolygonOnClosedTriangulation self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_BRep_PolygonOnClosedTriangulation self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRep.Handle_BRep_PolygonOnClosedTriangulation_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_BRep_PolygonOnClosedTriangulation self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_BRep_PolygonOnClosedTriangulation self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRep.Handle_BRep_PolygonOnClosedTriangulation_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_BRep_PolygonOnClosedTriangulation self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _BRep.Handle_BRep_PolygonOnClosedTriangulation_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_BRep_PolygonOnClosedTriangulation self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRep.Handle_BRep_PolygonOnClosedTriangulation_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_BRep_PolygonOnClosedTriangulation self)

        Increments the reference counter of this object


        """
        return _BRep.Handle_BRep_PolygonOnClosedTriangulation_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_BRep_PolygonOnClosedTriangulation self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRep.Handle_BRep_PolygonOnClosedTriangulation_DecrementRefCounter(self, *args)

Handle_BRep_PolygonOnClosedTriangulation_swigregister = _BRep.Handle_BRep_PolygonOnClosedTriangulation_swigregister
Handle_BRep_PolygonOnClosedTriangulation_swigregister(Handle_BRep_PolygonOnClosedTriangulation)

def Handle_BRep_PolygonOnClosedTriangulation_DownCast(thing):
    return _BRep.Handle_BRep_PolygonOnClosedTriangulation_DownCast(thing)
Handle_BRep_PolygonOnClosedTriangulation_DownCast = _BRep.Handle_BRep_PolygonOnClosedTriangulation_DownCast

class Handle_BRep_PolygonOnClosedSurface(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_BRep_PolygonOnClosedSurface self)

        Nullify the handle


        """
        return _BRep.Handle_BRep_PolygonOnClosedSurface_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_BRep_PolygonOnClosedSurface self) -> bool

        Check for being null

        :rtype: bool

        """
        return _BRep.Handle_BRep_PolygonOnClosedSurface_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_BRep_PolygonOnClosedSurface self, BRep_PolygonOnClosedSurface thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _BRep.Handle_BRep_PolygonOnClosedSurface_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_BRep_PolygonOnClosedSurface self, Handle_BRep_PolygonOnClosedSurface theHandle) -> Handle_BRep_PolygonOnClosedSurface
        assign(Handle_BRep_PolygonOnClosedSurface self, BRep_PolygonOnClosedSurface thePtr) -> Handle_BRep_PolygonOnClosedSurface
        assign(Handle_BRep_PolygonOnClosedSurface self, Handle_BRep_PolygonOnClosedSurface theHandle) -> Handle_BRep_PolygonOnClosedSurface

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _BRep.Handle_BRep_PolygonOnClosedSurface_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_BRep_PolygonOnClosedSurface self) -> BRep_PolygonOnClosedSurface

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _BRep.Handle_BRep_PolygonOnClosedSurface_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_BRep_PolygonOnClosedSurface self) -> BRep_PolygonOnClosedSurface

        Member access operator (note non-const)

        :rtype: T *

        """
        return _BRep.Handle_BRep_PolygonOnClosedSurface___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_BRep_PolygonOnClosedSurface self) -> BRep_PolygonOnClosedSurface

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _BRep.Handle_BRep_PolygonOnClosedSurface___ref__(self, *args)


    def __hash__(self):
        return _BRep.Handle_BRep_PolygonOnClosedSurface___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _BRep.Handle_BRep_PolygonOnClosedSurface___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _BRep.new_Handle_BRep_PolygonOnClosedSurface(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_BRep.Handle_BRep_PolygonOnClosedSurface_DownCast)
    __swig_destroy__ = _BRep.delete_Handle_BRep_PolygonOnClosedSurface

    def IsPolygonOnClosedSurface(self, *args):
        """
        IsPolygonOnClosedSurface(Handle_BRep_PolygonOnClosedSurface self) -> Standard_Boolean

        returns True.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRep.Handle_BRep_PolygonOnClosedSurface_IsPolygonOnClosedSurface(self, *args)


    def Polygon2(self, *args):
        """
        :rtype: OCC.wrapper.Poly.Handle_Poly_Polygon2D

        """
        res = _BRep.Handle_BRep_PolygonOnClosedSurface_Polygon2(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Copy(self, *args):
        """
        Copy(Handle_BRep_PolygonOnClosedSurface self) -> Handle_BRep_CurveRepresentation

        Return a copy of this representation.

        :rtype: OCC.wrapper.BRep.Handle_BRep_CurveRepresentation

        """
        return _BRep.Handle_BRep_PolygonOnClosedSurface_Copy(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_BRep_PolygonOnClosedSurface self) -> char const *

        :rtype: const char *

        """
        return _BRep.Handle_BRep_PolygonOnClosedSurface_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _BRep.Handle_BRep_PolygonOnClosedSurface_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _BRep.Handle_BRep_PolygonOnClosedSurface_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def IsPolygonOnSurface(self, *args):
        """
        IsPolygonOnSurface(Handle_BRep_PolygonOnClosedSurface self) -> Standard_Boolean
        IsPolygonOnSurface(Handle_BRep_PolygonOnClosedSurface self, Handle_Geom_Surface S, TopLoc_Location L) -> Standard_Boolean

        A   2D polygon  representation  in the  parametric
        space of a surface.

        :type S: OCC.wrapper.Geom.Handle_Geom_Surface
        :type L: OCC.wrapper.TopLoc.TopLoc_Location
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRep.Handle_BRep_PolygonOnClosedSurface_IsPolygonOnSurface(self, *args)


    def Surface(self, *args):
        """
        :rtype: OCC.wrapper.Geom.Handle_Geom_Surface

        """
        res = _BRep.Handle_BRep_PolygonOnClosedSurface_Surface(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Polygon(self, *args):
        """
        :rtype: OCC.wrapper.Poly.Handle_Poly_Polygon2D

        """
        res = _BRep.Handle_BRep_PolygonOnClosedSurface_Polygon(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def IsCurve3D(self, *args):
        """
        IsCurve3D(Handle_BRep_PolygonOnClosedSurface self) -> Standard_Boolean

        A 3D curve representation.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRep.Handle_BRep_PolygonOnClosedSurface_IsCurve3D(self, *args)


    def IsCurveOnSurface(self, *args):
        """
        IsCurveOnSurface(Handle_BRep_PolygonOnClosedSurface self) -> Standard_Boolean
        IsCurveOnSurface(Handle_BRep_PolygonOnClosedSurface self, Handle_Geom_Surface S, TopLoc_Location L) -> Standard_Boolean

        Is it a curve in the parametric space  of <S> with
        location <L>.

        :type S: OCC.wrapper.Geom.Handle_Geom_Surface
        :type L: OCC.wrapper.TopLoc.TopLoc_Location
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRep.Handle_BRep_PolygonOnClosedSurface_IsCurveOnSurface(self, *args)


    def IsRegularity(self, *args):
        """
        IsRegularity(Handle_BRep_PolygonOnClosedSurface self) -> Standard_Boolean
        IsRegularity(Handle_BRep_PolygonOnClosedSurface self, Handle_Geom_Surface S1, Handle_Geom_Surface S2, TopLoc_Location L1, TopLoc_Location L2) -> Standard_Boolean

        Is it  a  regularity between  <S1> and   <S2> with
        location <L1> and <L2>.

        :type S1: OCC.wrapper.Geom.Handle_Geom_Surface
        :type S2: OCC.wrapper.Geom.Handle_Geom_Surface
        :type L1: OCC.wrapper.TopLoc.TopLoc_Location
        :type L2: OCC.wrapper.TopLoc.TopLoc_Location
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRep.Handle_BRep_PolygonOnClosedSurface_IsRegularity(self, *args)


    def IsCurveOnClosedSurface(self, *args):
        """
        IsCurveOnClosedSurface(Handle_BRep_PolygonOnClosedSurface self) -> Standard_Boolean

        A curve with two parametric   curves  on the  same
        surface.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRep.Handle_BRep_PolygonOnClosedSurface_IsCurveOnClosedSurface(self, *args)


    def IsPolygon3D(self, *args):
        """
        IsPolygon3D(Handle_BRep_PolygonOnClosedSurface self) -> Standard_Boolean

        A 3D polygon representation.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRep.Handle_BRep_PolygonOnClosedSurface_IsPolygon3D(self, *args)


    def IsPolygonOnTriangulation(self, *args):
        """
        IsPolygonOnTriangulation(Handle_BRep_PolygonOnClosedSurface self) -> Standard_Boolean
        IsPolygonOnTriangulation(Handle_BRep_PolygonOnClosedSurface self, Handle_Poly_Triangulation T, TopLoc_Location L) -> Standard_Boolean

        Is it a polygon in the definition of <T> with
        location <L>.

        :type T: OCC.wrapper.Poly.Handle_Poly_Triangulation
        :type L: OCC.wrapper.TopLoc.TopLoc_Location
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRep.Handle_BRep_PolygonOnClosedSurface_IsPolygonOnTriangulation(self, *args)


    def IsPolygonOnClosedTriangulation(self, *args):
        """
        IsPolygonOnClosedTriangulation(Handle_BRep_PolygonOnClosedSurface self) -> Standard_Boolean

        A representation by two arrays of nodes on a
        triangulation.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRep.Handle_BRep_PolygonOnClosedSurface_IsPolygonOnClosedTriangulation(self, *args)


    def Location(self, *args):
        """
        :rtype: OCC.wrapper.TopLoc.TopLoc_Location

        """
        res = _BRep.Handle_BRep_PolygonOnClosedSurface_Location(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Curve3D(self, *args):
        """
        :rtype: OCC.wrapper.Geom.Handle_Geom_Curve

        """
        res = _BRep.Handle_BRep_PolygonOnClosedSurface_Curve3D(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def PCurve(self, *args):
        """
        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Curve

        """
        res = _BRep.Handle_BRep_PolygonOnClosedSurface_PCurve(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def PCurve2(self, *args):
        """
        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Curve

        """
        res = _BRep.Handle_BRep_PolygonOnClosedSurface_PCurve2(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Polygon3D(self, *args):
        """
        :rtype: OCC.wrapper.Poly.Handle_Poly_Polygon3D

        """
        res = _BRep.Handle_BRep_PolygonOnClosedSurface_Polygon3D(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Triangulation(self, *args):
        """
        :rtype: OCC.wrapper.Poly.Handle_Poly_Triangulation

        """
        res = _BRep.Handle_BRep_PolygonOnClosedSurface_Triangulation(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def PolygonOnTriangulation(self, *args):
        """
        :rtype: OCC.wrapper.Poly.Handle_Poly_PolygonOnTriangulation

        """
        res = _BRep.Handle_BRep_PolygonOnClosedSurface_PolygonOnTriangulation(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def PolygonOnTriangulation2(self, *args):
        """
        :rtype: OCC.wrapper.Poly.Handle_Poly_PolygonOnTriangulation

        """
        res = _BRep.Handle_BRep_PolygonOnClosedSurface_PolygonOnTriangulation2(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Surface2(self, *args):
        """
        :rtype: OCC.wrapper.Geom.Handle_Geom_Surface

        """
        res = _BRep.Handle_BRep_PolygonOnClosedSurface_Surface2(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Location2(self, *args):
        """
        :rtype: OCC.wrapper.TopLoc.TopLoc_Location

        """
        res = _BRep.Handle_BRep_PolygonOnClosedSurface_Location2(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Continuity(self, *args):
        """
        :rtype: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        res = _BRep.Handle_BRep_PolygonOnClosedSurface_Continuity(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_BRep_PolygonOnClosedSurface self)

        Memory deallocator for transient classes


        """
        return _BRep.Handle_BRep_PolygonOnClosedSurface_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_BRep_PolygonOnClosedSurface self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_BRep_PolygonOnClosedSurface self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRep.Handle_BRep_PolygonOnClosedSurface_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_BRep_PolygonOnClosedSurface self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_BRep_PolygonOnClosedSurface self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRep.Handle_BRep_PolygonOnClosedSurface_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_BRep_PolygonOnClosedSurface self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _BRep.Handle_BRep_PolygonOnClosedSurface_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_BRep_PolygonOnClosedSurface self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRep.Handle_BRep_PolygonOnClosedSurface_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_BRep_PolygonOnClosedSurface self)

        Increments the reference counter of this object


        """
        return _BRep.Handle_BRep_PolygonOnClosedSurface_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_BRep_PolygonOnClosedSurface self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRep.Handle_BRep_PolygonOnClosedSurface_DecrementRefCounter(self, *args)

Handle_BRep_PolygonOnClosedSurface_swigregister = _BRep.Handle_BRep_PolygonOnClosedSurface_swigregister
Handle_BRep_PolygonOnClosedSurface_swigregister(Handle_BRep_PolygonOnClosedSurface)

def Handle_BRep_PolygonOnClosedSurface_DownCast(thing):
    return _BRep.Handle_BRep_PolygonOnClosedSurface_DownCast(thing)
Handle_BRep_PolygonOnClosedSurface_DownCast = _BRep.Handle_BRep_PolygonOnClosedSurface_DownCast

class BRep_TEdge(TopoDS.TopoDS_TEdge):
    """
    The TEdge from BRep is  inherited from  the  TEdge
    from TopoDS. It contains the geometric data.

    The TEdge contains :

    * A tolerance.

    * A same parameter flag.

    * A same range flag.

    * A Degenerated flag.

    *  A  list   of curve representation.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_BRep_TEdge
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_BRep_TEdge(self) 
            return h


    def __init__(self, *args):
        """
        __init__(BRep_TEdge self) -> BRep_TEdge

        Creates an empty TEdge.


        """
        this = _BRep.new_BRep_TEdge(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Tolerance(self, *args):
        """
        Tolerance(BRep_TEdge self) -> Standard_Real
        Tolerance(BRep_TEdge self, Standard_Real const T)

        :type T: float

        """
        return _BRep.BRep_TEdge_Tolerance(self, *args)


    def UpdateTolerance(self, *args):
        """
        UpdateTolerance(BRep_TEdge self, Standard_Real const T)

        Sets the tolerance  to the   max  of <T>  and  the
        current  tolerance.

        :type T: float

        """
        return _BRep.BRep_TEdge_UpdateTolerance(self, *args)


    def SameParameter(self, *args):
        """
        SameParameter(BRep_TEdge self) -> Standard_Boolean
        SameParameter(BRep_TEdge self, Standard_Boolean const S)

        :type S: bool

        """
        return _BRep.BRep_TEdge_SameParameter(self, *args)


    def SameRange(self, *args):
        """
        SameRange(BRep_TEdge self) -> Standard_Boolean
        SameRange(BRep_TEdge self, Standard_Boolean const S)

        :type S: bool

        """
        return _BRep.BRep_TEdge_SameRange(self, *args)


    def Degenerated(self, *args):
        """
        Degenerated(BRep_TEdge self) -> Standard_Boolean
        Degenerated(BRep_TEdge self, Standard_Boolean const S)

        :type S: bool

        """
        return _BRep.BRep_TEdge_Degenerated(self, *args)


    def Curves(self, *args):
        """
        :rtype: OCC.wrapper.BRep.BRep_ListOfCurveRepresentation

        """
        res = _BRep.BRep_TEdge_Curves(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeCurves(self, *args):
        """
        ChangeCurves(BRep_TEdge self) -> NCollection_List_Handle_BRep_CurveRepresentation

        :rtype: OCC.wrapper.BRep.BRep_ListOfCurveRepresentation

        """
        return _BRep.BRep_TEdge_ChangeCurves(self, *args)


    def EmptyCopy(self, *args):
        """
        EmptyCopy(BRep_TEdge self) -> Handle_TopoDS_TShape

        Returns a copy  of the  TShape  with no sub-shapes.

        :rtype: OCC.wrapper.TopoDS.Handle_TopoDS_TShape

        """
        return _BRep.BRep_TEdge_EmptyCopy(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _BRep.BRep_TEdge_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _BRep.BRep_TEdge_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _BRep.BRep_TEdge_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _BRep.delete_BRep_TEdge
BRep_TEdge_swigregister = _BRep.BRep_TEdge_swigregister
BRep_TEdge_swigregister(BRep_TEdge)

def BRep_TEdge_get_type_name(*args):
    """
    BRep_TEdge_get_type_name() -> char const *

    :rtype: const char *

    """
    return _BRep.BRep_TEdge_get_type_name(*args)

def BRep_TEdge_get_type_descriptor(*args):
    """
    BRep_TEdge_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _BRep.BRep_TEdge_get_type_descriptor(*args)

class Handle_BRep_PointRepresentation(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_BRep_PointRepresentation self)

        Nullify the handle


        """
        return _BRep.Handle_BRep_PointRepresentation_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_BRep_PointRepresentation self) -> bool

        Check for being null

        :rtype: bool

        """
        return _BRep.Handle_BRep_PointRepresentation_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_BRep_PointRepresentation self, BRep_PointRepresentation thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _BRep.Handle_BRep_PointRepresentation_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_BRep_PointRepresentation self, Handle_BRep_PointRepresentation theHandle) -> Handle_BRep_PointRepresentation
        assign(Handle_BRep_PointRepresentation self, BRep_PointRepresentation thePtr) -> Handle_BRep_PointRepresentation
        assign(Handle_BRep_PointRepresentation self, Handle_BRep_PointRepresentation theHandle) -> Handle_BRep_PointRepresentation

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _BRep.Handle_BRep_PointRepresentation_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_BRep_PointRepresentation self) -> BRep_PointRepresentation

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _BRep.Handle_BRep_PointRepresentation_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_BRep_PointRepresentation self) -> BRep_PointRepresentation

        Member access operator (note non-const)

        :rtype: T *

        """
        return _BRep.Handle_BRep_PointRepresentation___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_BRep_PointRepresentation self) -> BRep_PointRepresentation

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _BRep.Handle_BRep_PointRepresentation___ref__(self, *args)


    def __hash__(self):
        return _BRep.Handle_BRep_PointRepresentation___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _BRep.Handle_BRep_PointRepresentation___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _BRep.new_Handle_BRep_PointRepresentation(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_BRep.Handle_BRep_PointRepresentation_DownCast)
    __swig_destroy__ = _BRep.delete_Handle_BRep_PointRepresentation

    def IsPointOnCurve(self, *args):
        """
        IsPointOnCurve(Handle_BRep_PointRepresentation self) -> Standard_Boolean
        IsPointOnCurve(Handle_BRep_PointRepresentation self, Handle_Geom_Curve C, TopLoc_Location L) -> Standard_Boolean

        A point on the curve <C>.

        :type C: OCC.wrapper.Geom.Handle_Geom_Curve
        :type L: OCC.wrapper.TopLoc.TopLoc_Location
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRep.Handle_BRep_PointRepresentation_IsPointOnCurve(self, *args)


    def IsPointOnCurveOnSurface(self, *args):
        """
        IsPointOnCurveOnSurface(Handle_BRep_PointRepresentation self) -> Standard_Boolean
        IsPointOnCurveOnSurface(Handle_BRep_PointRepresentation self, Handle_Geom2d_Curve PC, Handle_Geom_Surface S, TopLoc_Location L) -> Standard_Boolean

        A point on the 2d curve <PC> on the surface <S>.

        :type PC: OCC.wrapper.Geom2d.Handle_Geom2d_Curve
        :type S: OCC.wrapper.Geom.Handle_Geom_Surface
        :type L: OCC.wrapper.TopLoc.TopLoc_Location
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRep.Handle_BRep_PointRepresentation_IsPointOnCurveOnSurface(self, *args)


    def IsPointOnSurface(self, *args):
        """
        IsPointOnSurface(Handle_BRep_PointRepresentation self) -> Standard_Boolean
        IsPointOnSurface(Handle_BRep_PointRepresentation self, Handle_Geom_Surface S, TopLoc_Location L) -> Standard_Boolean

        A point on the surface <S>.

        :type S: OCC.wrapper.Geom.Handle_Geom_Surface
        :type L: OCC.wrapper.TopLoc.TopLoc_Location
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRep.Handle_BRep_PointRepresentation_IsPointOnSurface(self, *args)


    def Location(self, *args):
        """
        :rtype: OCC.wrapper.TopLoc.TopLoc_Location

        """
        res = _BRep.Handle_BRep_PointRepresentation_Location(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Parameter(self, *args):
        """
        Parameter(Handle_BRep_PointRepresentation self) -> Standard_Real
        Parameter(Handle_BRep_PointRepresentation self, Standard_Real const P)

        :type P: float

        """
        return _BRep.Handle_BRep_PointRepresentation_Parameter(self, *args)


    def Parameter2(self, *args):
        """
        Parameter2(Handle_BRep_PointRepresentation self) -> Standard_Real
        Parameter2(Handle_BRep_PointRepresentation self, Standard_Real const P)

        :type P: float

        """
        return _BRep.Handle_BRep_PointRepresentation_Parameter2(self, *args)


    def Curve(self, *args):
        """
        :rtype: OCC.wrapper.Geom.Handle_Geom_Curve

        """
        res = _BRep.Handle_BRep_PointRepresentation_Curve(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def PCurve(self, *args):
        """
        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Curve

        """
        res = _BRep.Handle_BRep_PointRepresentation_PCurve(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Surface(self, *args):
        """
        :rtype: OCC.wrapper.Geom.Handle_Geom_Surface

        """
        res = _BRep.Handle_BRep_PointRepresentation_Surface(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def get_type_name(self, *args):
        """
        get_type_name(Handle_BRep_PointRepresentation self) -> char const *

        :rtype: const char *

        """
        return _BRep.Handle_BRep_PointRepresentation_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _BRep.Handle_BRep_PointRepresentation_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _BRep.Handle_BRep_PointRepresentation_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_BRep_PointRepresentation self)

        Memory deallocator for transient classes


        """
        return _BRep.Handle_BRep_PointRepresentation_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_BRep_PointRepresentation self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_BRep_PointRepresentation self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRep.Handle_BRep_PointRepresentation_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_BRep_PointRepresentation self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_BRep_PointRepresentation self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRep.Handle_BRep_PointRepresentation_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_BRep_PointRepresentation self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _BRep.Handle_BRep_PointRepresentation_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_BRep_PointRepresentation self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRep.Handle_BRep_PointRepresentation_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_BRep_PointRepresentation self)

        Increments the reference counter of this object


        """
        return _BRep.Handle_BRep_PointRepresentation_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_BRep_PointRepresentation self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRep.Handle_BRep_PointRepresentation_DecrementRefCounter(self, *args)

Handle_BRep_PointRepresentation_swigregister = _BRep.Handle_BRep_PointRepresentation_swigregister
Handle_BRep_PointRepresentation_swigregister(Handle_BRep_PointRepresentation)

def Handle_BRep_PointRepresentation_DownCast(thing):
    return _BRep.Handle_BRep_PointRepresentation_DownCast(thing)
Handle_BRep_PointRepresentation_DownCast = _BRep.Handle_BRep_PointRepresentation_DownCast

class Handle_BRep_CurveOnClosedSurface(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_BRep_CurveOnClosedSurface self)

        Nullify the handle


        """
        return _BRep.Handle_BRep_CurveOnClosedSurface_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_BRep_CurveOnClosedSurface self) -> bool

        Check for being null

        :rtype: bool

        """
        return _BRep.Handle_BRep_CurveOnClosedSurface_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_BRep_CurveOnClosedSurface self, BRep_CurveOnClosedSurface thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _BRep.Handle_BRep_CurveOnClosedSurface_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_BRep_CurveOnClosedSurface self, Handle_BRep_CurveOnClosedSurface theHandle) -> Handle_BRep_CurveOnClosedSurface
        assign(Handle_BRep_CurveOnClosedSurface self, BRep_CurveOnClosedSurface thePtr) -> Handle_BRep_CurveOnClosedSurface
        assign(Handle_BRep_CurveOnClosedSurface self, Handle_BRep_CurveOnClosedSurface theHandle) -> Handle_BRep_CurveOnClosedSurface

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _BRep.Handle_BRep_CurveOnClosedSurface_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_BRep_CurveOnClosedSurface self) -> BRep_CurveOnClosedSurface

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _BRep.Handle_BRep_CurveOnClosedSurface_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_BRep_CurveOnClosedSurface self) -> BRep_CurveOnClosedSurface

        Member access operator (note non-const)

        :rtype: T *

        """
        return _BRep.Handle_BRep_CurveOnClosedSurface___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_BRep_CurveOnClosedSurface self) -> BRep_CurveOnClosedSurface

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _BRep.Handle_BRep_CurveOnClosedSurface___ref__(self, *args)


    def __hash__(self):
        return _BRep.Handle_BRep_CurveOnClosedSurface___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _BRep.Handle_BRep_CurveOnClosedSurface___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _BRep.new_Handle_BRep_CurveOnClosedSurface(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_BRep.Handle_BRep_CurveOnClosedSurface_DownCast)
    __swig_destroy__ = _BRep.delete_Handle_BRep_CurveOnClosedSurface

    def SetUVPoints2(self, *args):
        """
        SetUVPoints2(Handle_BRep_CurveOnClosedSurface self, gp_Pnt2d P1, gp_Pnt2d P2)

        :type P1: OCC.wrapper.gp.gp_Pnt2d
        :type P2: OCC.wrapper.gp.gp_Pnt2d

        """
        return _BRep.Handle_BRep_CurveOnClosedSurface_SetUVPoints2(self, *args)


    def UVPoints2(self, *args):
        """
        UVPoints2(Handle_BRep_CurveOnClosedSurface self, gp_Pnt2d P1, gp_Pnt2d P2)

        :type P1: OCC.wrapper.gp.gp_Pnt2d
        :type P2: OCC.wrapper.gp.gp_Pnt2d

        """
        return _BRep.Handle_BRep_CurveOnClosedSurface_UVPoints2(self, *args)


    def IsCurveOnClosedSurface(self, *args):
        """
        IsCurveOnClosedSurface(Handle_BRep_CurveOnClosedSurface self) -> Standard_Boolean

        Returns True.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRep.Handle_BRep_CurveOnClosedSurface_IsCurveOnClosedSurface(self, *args)


    def IsRegularity(self, *args):
        """
        IsRegularity(Handle_BRep_CurveOnClosedSurface self) -> Standard_Boolean
        IsRegularity(Handle_BRep_CurveOnClosedSurface self, Handle_Geom_Surface S1, Handle_Geom_Surface S2, TopLoc_Location L1, TopLoc_Location L2) -> Standard_Boolean

        A curve on two surfaces (continuity).

        :type S1: OCC.wrapper.Geom.Handle_Geom_Surface
        :type S2: OCC.wrapper.Geom.Handle_Geom_Surface
        :type L1: OCC.wrapper.TopLoc.TopLoc_Location
        :type L2: OCC.wrapper.TopLoc.TopLoc_Location
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRep.Handle_BRep_CurveOnClosedSurface_IsRegularity(self, *args)


    def PCurve2(self, *args):
        """
        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Curve

        """
        res = _BRep.Handle_BRep_CurveOnClosedSurface_PCurve2(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Surface2(self, *args):
        """
        Returns Surface()

        :rtype: OCC.wrapper.Geom.Handle_Geom_Surface

        """
        res = _BRep.Handle_BRep_CurveOnClosedSurface_Surface2(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Location2(self, *args):
        """
        Returns Location()

        :rtype: OCC.wrapper.TopLoc.TopLoc_Location

        """
        res = _BRep.Handle_BRep_CurveOnClosedSurface_Location2(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Continuity(self, *args):
        """
        :rtype: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        res = _BRep.Handle_BRep_CurveOnClosedSurface_Continuity(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Copy(self, *args):
        """
        Copy(Handle_BRep_CurveOnClosedSurface self) -> Handle_BRep_CurveRepresentation

        Return a copy of this representation.

        :rtype: OCC.wrapper.BRep.Handle_BRep_CurveRepresentation

        """
        return _BRep.Handle_BRep_CurveOnClosedSurface_Copy(self, *args)


    def Update(self, *args):
        """
        Update(Handle_BRep_CurveOnClosedSurface self)

        Recomputes any derived data after a modification.
        This is called when the range is modified.


        """
        return _BRep.Handle_BRep_CurveOnClosedSurface_Update(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_BRep_CurveOnClosedSurface self) -> char const *

        :rtype: const char *

        """
        return _BRep.Handle_BRep_CurveOnClosedSurface_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _BRep.Handle_BRep_CurveOnClosedSurface_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _BRep.Handle_BRep_CurveOnClosedSurface_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetUVPoints(self, *args):
        """
        SetUVPoints(Handle_BRep_CurveOnClosedSurface self, gp_Pnt2d P1, gp_Pnt2d P2)

        :type P1: OCC.wrapper.gp.gp_Pnt2d
        :type P2: OCC.wrapper.gp.gp_Pnt2d

        """
        return _BRep.Handle_BRep_CurveOnClosedSurface_SetUVPoints(self, *args)


    def UVPoints(self, *args):
        """
        UVPoints(Handle_BRep_CurveOnClosedSurface self, gp_Pnt2d P1, gp_Pnt2d P2)

        :type P1: OCC.wrapper.gp.gp_Pnt2d
        :type P2: OCC.wrapper.gp.gp_Pnt2d

        """
        return _BRep.Handle_BRep_CurveOnClosedSurface_UVPoints(self, *args)


    def D0(self, *args):
        """
        D0(Handle_BRep_CurveOnClosedSurface self, Standard_Real const U, gp_Pnt P)

        Computes the point at parameter U.

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt

        """
        return _BRep.Handle_BRep_CurveOnClosedSurface_D0(self, *args)


    def IsCurveOnSurface(self, *args):
        """
        IsCurveOnSurface(Handle_BRep_CurveOnClosedSurface self) -> Standard_Boolean
        IsCurveOnSurface(Handle_BRep_CurveOnClosedSurface self, Handle_Geom_Surface S, TopLoc_Location L) -> Standard_Boolean

        A curve in the parametric space of a surface.

        :type S: OCC.wrapper.Geom.Handle_Geom_Surface
        :type L: OCC.wrapper.TopLoc.TopLoc_Location
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRep.Handle_BRep_CurveOnClosedSurface_IsCurveOnSurface(self, *args)


    def Surface(self, *args):
        """
        :rtype: OCC.wrapper.Geom.Handle_Geom_Surface

        """
        res = _BRep.Handle_BRep_CurveOnClosedSurface_Surface(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def PCurve(self, *args):
        """
        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Curve

        """
        res = _BRep.Handle_BRep_CurveOnClosedSurface_PCurve(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetRange(self, *args):
        """
        SetRange(Handle_BRep_CurveOnClosedSurface self, Standard_Real const First, Standard_Real const Last)

        :type First: float
        :type Last: float

        """
        return _BRep.Handle_BRep_CurveOnClosedSurface_SetRange(self, *args)


    def Range(self, *args):
        """
        Range(Handle_BRep_CurveOnClosedSurface self)

        :type First: float
        :type Last: float

        """
        return _BRep.Handle_BRep_CurveOnClosedSurface_Range(self, *args)


    def First(self, *args):
        """
        First(Handle_BRep_CurveOnClosedSurface self) -> Standard_Real
        First(Handle_BRep_CurveOnClosedSurface self, Standard_Real const F)

        :type F: float

        """
        return _BRep.Handle_BRep_CurveOnClosedSurface_First(self, *args)


    def Last(self, *args):
        """
        Last(Handle_BRep_CurveOnClosedSurface self) -> Standard_Real
        Last(Handle_BRep_CurveOnClosedSurface self, Standard_Real const L)

        :type L: float

        """
        return _BRep.Handle_BRep_CurveOnClosedSurface_Last(self, *args)


    def IsCurve3D(self, *args):
        """
        IsCurve3D(Handle_BRep_CurveOnClosedSurface self) -> Standard_Boolean

        A 3D curve representation.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRep.Handle_BRep_CurveOnClosedSurface_IsCurve3D(self, *args)


    def IsPolygon3D(self, *args):
        """
        IsPolygon3D(Handle_BRep_CurveOnClosedSurface self) -> Standard_Boolean

        A 3D polygon representation.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRep.Handle_BRep_CurveOnClosedSurface_IsPolygon3D(self, *args)


    def IsPolygonOnTriangulation(self, *args):
        """
        IsPolygonOnTriangulation(Handle_BRep_CurveOnClosedSurface self) -> Standard_Boolean
        IsPolygonOnTriangulation(Handle_BRep_CurveOnClosedSurface self, Handle_Poly_Triangulation T, TopLoc_Location L) -> Standard_Boolean

        Is it a polygon in the definition of <T> with
        location <L>.

        :type T: OCC.wrapper.Poly.Handle_Poly_Triangulation
        :type L: OCC.wrapper.TopLoc.TopLoc_Location
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRep.Handle_BRep_CurveOnClosedSurface_IsPolygonOnTriangulation(self, *args)


    def IsPolygonOnClosedTriangulation(self, *args):
        """
        IsPolygonOnClosedTriangulation(Handle_BRep_CurveOnClosedSurface self) -> Standard_Boolean

        A representation by two arrays of nodes on a
        triangulation.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRep.Handle_BRep_CurveOnClosedSurface_IsPolygonOnClosedTriangulation(self, *args)


    def IsPolygonOnSurface(self, *args):
        """
        IsPolygonOnSurface(Handle_BRep_CurveOnClosedSurface self) -> Standard_Boolean
        IsPolygonOnSurface(Handle_BRep_CurveOnClosedSurface self, Handle_Geom_Surface S, TopLoc_Location L) -> Standard_Boolean

        Is it a polygon in the parametric space  of <S> with
        location <L>.

        :type S: OCC.wrapper.Geom.Handle_Geom_Surface
        :type L: OCC.wrapper.TopLoc.TopLoc_Location
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRep.Handle_BRep_CurveOnClosedSurface_IsPolygonOnSurface(self, *args)


    def IsPolygonOnClosedSurface(self, *args):
        """
        IsPolygonOnClosedSurface(Handle_BRep_CurveOnClosedSurface self) -> Standard_Boolean

        Two   2D polygon  representations  in the  parametric
        space of a surface.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRep.Handle_BRep_CurveOnClosedSurface_IsPolygonOnClosedSurface(self, *args)


    def Location(self, *args):
        """
        :rtype: OCC.wrapper.TopLoc.TopLoc_Location

        """
        res = _BRep.Handle_BRep_CurveOnClosedSurface_Location(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Curve3D(self, *args):
        """
        :rtype: OCC.wrapper.Geom.Handle_Geom_Curve

        """
        res = _BRep.Handle_BRep_CurveOnClosedSurface_Curve3D(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Polygon3D(self, *args):
        """
        :rtype: OCC.wrapper.Poly.Handle_Poly_Polygon3D

        """
        res = _BRep.Handle_BRep_CurveOnClosedSurface_Polygon3D(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Polygon(self, *args):
        """
        :rtype: OCC.wrapper.Poly.Handle_Poly_Polygon2D

        """
        res = _BRep.Handle_BRep_CurveOnClosedSurface_Polygon(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Polygon2(self, *args):
        """
        :rtype: OCC.wrapper.Poly.Handle_Poly_Polygon2D

        """
        res = _BRep.Handle_BRep_CurveOnClosedSurface_Polygon2(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Triangulation(self, *args):
        """
        :rtype: OCC.wrapper.Poly.Handle_Poly_Triangulation

        """
        res = _BRep.Handle_BRep_CurveOnClosedSurface_Triangulation(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def PolygonOnTriangulation(self, *args):
        """
        :rtype: OCC.wrapper.Poly.Handle_Poly_PolygonOnTriangulation

        """
        res = _BRep.Handle_BRep_CurveOnClosedSurface_PolygonOnTriangulation(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def PolygonOnTriangulation2(self, *args):
        """
        :rtype: OCC.wrapper.Poly.Handle_Poly_PolygonOnTriangulation

        """
        res = _BRep.Handle_BRep_CurveOnClosedSurface_PolygonOnTriangulation2(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_BRep_CurveOnClosedSurface self)

        Memory deallocator for transient classes


        """
        return _BRep.Handle_BRep_CurveOnClosedSurface_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_BRep_CurveOnClosedSurface self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_BRep_CurveOnClosedSurface self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRep.Handle_BRep_CurveOnClosedSurface_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_BRep_CurveOnClosedSurface self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_BRep_CurveOnClosedSurface self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRep.Handle_BRep_CurveOnClosedSurface_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_BRep_CurveOnClosedSurface self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _BRep.Handle_BRep_CurveOnClosedSurface_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_BRep_CurveOnClosedSurface self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRep.Handle_BRep_CurveOnClosedSurface_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_BRep_CurveOnClosedSurface self)

        Increments the reference counter of this object


        """
        return _BRep.Handle_BRep_CurveOnClosedSurface_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_BRep_CurveOnClosedSurface self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRep.Handle_BRep_CurveOnClosedSurface_DecrementRefCounter(self, *args)

Handle_BRep_CurveOnClosedSurface_swigregister = _BRep.Handle_BRep_CurveOnClosedSurface_swigregister
Handle_BRep_CurveOnClosedSurface_swigregister(Handle_BRep_CurveOnClosedSurface)

def Handle_BRep_CurveOnClosedSurface_DownCast(thing):
    return _BRep.Handle_BRep_CurveOnClosedSurface_DownCast(thing)
Handle_BRep_CurveOnClosedSurface_DownCast = _BRep.Handle_BRep_CurveOnClosedSurface_DownCast

class Handle_BRep_TFace(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_BRep_TFace self)

        Nullify the handle


        """
        return _BRep.Handle_BRep_TFace_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_BRep_TFace self) -> bool

        Check for being null

        :rtype: bool

        """
        return _BRep.Handle_BRep_TFace_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_BRep_TFace self, BRep_TFace thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _BRep.Handle_BRep_TFace_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_BRep_TFace self, Handle_BRep_TFace theHandle) -> Handle_BRep_TFace
        assign(Handle_BRep_TFace self, BRep_TFace thePtr) -> Handle_BRep_TFace
        assign(Handle_BRep_TFace self, Handle_BRep_TFace theHandle) -> Handle_BRep_TFace

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _BRep.Handle_BRep_TFace_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_BRep_TFace self) -> BRep_TFace

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _BRep.Handle_BRep_TFace_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_BRep_TFace self) -> BRep_TFace

        Member access operator (note non-const)

        :rtype: T *

        """
        return _BRep.Handle_BRep_TFace___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_BRep_TFace self) -> BRep_TFace

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _BRep.Handle_BRep_TFace___ref__(self, *args)


    def __hash__(self):
        return _BRep.Handle_BRep_TFace___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _BRep.Handle_BRep_TFace___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _BRep.new_Handle_BRep_TFace(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_BRep.Handle_BRep_TFace_DownCast)
    __swig_destroy__ = _BRep.delete_Handle_BRep_TFace

    def Surface(self, *args):
        """
        :rtype: OCC.wrapper.Geom.Handle_Geom_Surface

        """
        res = _BRep.Handle_BRep_TFace_Surface(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Triangulation(self, *args):
        """
        :rtype: OCC.wrapper.Poly.Handle_Poly_Triangulation

        """
        res = _BRep.Handle_BRep_TFace_Triangulation(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Location(self, *args):
        """
        :rtype: OCC.wrapper.TopLoc.TopLoc_Location

        """
        res = _BRep.Handle_BRep_TFace_Location(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Tolerance(self, *args):
        """
        Tolerance(Handle_BRep_TFace self) -> Standard_Real
        Tolerance(Handle_BRep_TFace self, Standard_Real const T)

        :type T: float

        """
        return _BRep.Handle_BRep_TFace_Tolerance(self, *args)


    def NaturalRestriction(self, *args):
        """
        NaturalRestriction(Handle_BRep_TFace self) -> Standard_Boolean
        NaturalRestriction(Handle_BRep_TFace self, Standard_Boolean const N)

        :type N: bool

        """
        return _BRep.Handle_BRep_TFace_NaturalRestriction(self, *args)


    def EmptyCopy(self, *args):
        """
        EmptyCopy(Handle_BRep_TFace self) -> Handle_TopoDS_TShape

        Returns a copy  of the  TShape  with no sub-shapes.
        The new Face has no triangulation.

        :rtype: OCC.wrapper.TopoDS.Handle_TopoDS_TShape

        """
        return _BRep.Handle_BRep_TFace_EmptyCopy(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_BRep_TFace self) -> char const *

        :rtype: const char *

        """
        return _BRep.Handle_BRep_TFace_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _BRep.Handle_BRep_TFace_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _BRep.Handle_BRep_TFace_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ShapeType(self, *args):
        """
        ShapeType(Handle_BRep_TFace self) -> TopAbs_ShapeEnum

        returns FACE.

        :rtype: OCC.wrapper.TopAbs.TopAbs_ShapeEnum

        """
        return _BRep.Handle_BRep_TFace_ShapeType(self, *args)


    def Free(self, *args):
        """
        Free(Handle_BRep_TFace self) -> Standard_Boolean
        Free(Handle_BRep_TFace self, Standard_Boolean const F)

        Sets the free flag.

        :type F: bool

        """
        return _BRep.Handle_BRep_TFace_Free(self, *args)


    def Locked(self, *args):
        """
        Locked(Handle_BRep_TFace self) -> Standard_Boolean
        Locked(Handle_BRep_TFace self, Standard_Boolean const F)

        Sets the locked flag.

        :type F: bool

        """
        return _BRep.Handle_BRep_TFace_Locked(self, *args)


    def Modified(self, *args):
        """
        Modified(Handle_BRep_TFace self) -> Standard_Boolean
        Modified(Handle_BRep_TFace self, Standard_Boolean const M)

        Sets the modification flag.

        :type M: bool

        """
        return _BRep.Handle_BRep_TFace_Modified(self, *args)


    def Checked(self, *args):
        """
        Checked(Handle_BRep_TFace self) -> Standard_Boolean
        Checked(Handle_BRep_TFace self, Standard_Boolean const C)

        Sets the checked flag.

        :type C: bool

        """
        return _BRep.Handle_BRep_TFace_Checked(self, *args)


    def Orientable(self, *args):
        """
        Orientable(Handle_BRep_TFace self) -> Standard_Boolean
        Orientable(Handle_BRep_TFace self, Standard_Boolean const C)

        Sets the orientability flag.

        :type C: bool

        """
        return _BRep.Handle_BRep_TFace_Orientable(self, *args)


    def Closed(self, *args):
        """
        Closed(Handle_BRep_TFace self) -> Standard_Boolean
        Closed(Handle_BRep_TFace self, Standard_Boolean const C)

        Sets the closedness flag.

        :type C: bool

        """
        return _BRep.Handle_BRep_TFace_Closed(self, *args)


    def Infinite(self, *args):
        """
        Infinite(Handle_BRep_TFace self) -> Standard_Boolean
        Infinite(Handle_BRep_TFace self, Standard_Boolean const C)

        Sets the infinity flag.

        :type C: bool

        """
        return _BRep.Handle_BRep_TFace_Infinite(self, *args)


    def Convex(self, *args):
        """
        Convex(Handle_BRep_TFace self) -> Standard_Boolean
        Convex(Handle_BRep_TFace self, Standard_Boolean const C)

        Sets the convexness flag.

        :type C: bool

        """
        return _BRep.Handle_BRep_TFace_Convex(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_BRep_TFace self)

        Memory deallocator for transient classes


        """
        return _BRep.Handle_BRep_TFace_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_BRep_TFace self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_BRep_TFace self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRep.Handle_BRep_TFace_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_BRep_TFace self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_BRep_TFace self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRep.Handle_BRep_TFace_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_BRep_TFace self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _BRep.Handle_BRep_TFace_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_BRep_TFace self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRep.Handle_BRep_TFace_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_BRep_TFace self)

        Increments the reference counter of this object


        """
        return _BRep.Handle_BRep_TFace_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_BRep_TFace self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRep.Handle_BRep_TFace_DecrementRefCounter(self, *args)

Handle_BRep_TFace_swigregister = _BRep.Handle_BRep_TFace_swigregister
Handle_BRep_TFace_swigregister(Handle_BRep_TFace)

def Handle_BRep_TFace_DownCast(thing):
    return _BRep.Handle_BRep_TFace_DownCast(thing)
Handle_BRep_TFace_DownCast = _BRep.Handle_BRep_TFace_DownCast

class Handle_BRep_PointOnCurve(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_BRep_PointOnCurve self)

        Nullify the handle


        """
        return _BRep.Handle_BRep_PointOnCurve_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_BRep_PointOnCurve self) -> bool

        Check for being null

        :rtype: bool

        """
        return _BRep.Handle_BRep_PointOnCurve_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_BRep_PointOnCurve self, BRep_PointOnCurve thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _BRep.Handle_BRep_PointOnCurve_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_BRep_PointOnCurve self, Handle_BRep_PointOnCurve theHandle) -> Handle_BRep_PointOnCurve
        assign(Handle_BRep_PointOnCurve self, BRep_PointOnCurve thePtr) -> Handle_BRep_PointOnCurve
        assign(Handle_BRep_PointOnCurve self, Handle_BRep_PointOnCurve theHandle) -> Handle_BRep_PointOnCurve

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _BRep.Handle_BRep_PointOnCurve_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_BRep_PointOnCurve self) -> BRep_PointOnCurve

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _BRep.Handle_BRep_PointOnCurve_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_BRep_PointOnCurve self) -> BRep_PointOnCurve

        Member access operator (note non-const)

        :rtype: T *

        """
        return _BRep.Handle_BRep_PointOnCurve___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_BRep_PointOnCurve self) -> BRep_PointOnCurve

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _BRep.Handle_BRep_PointOnCurve___ref__(self, *args)


    def __hash__(self):
        return _BRep.Handle_BRep_PointOnCurve___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _BRep.Handle_BRep_PointOnCurve___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _BRep.new_Handle_BRep_PointOnCurve(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_BRep.Handle_BRep_PointOnCurve_DownCast)
    __swig_destroy__ = _BRep.delete_Handle_BRep_PointOnCurve

    def IsPointOnCurve(self, *args):
        """
        IsPointOnCurve(Handle_BRep_PointOnCurve self) -> Standard_Boolean
        IsPointOnCurve(Handle_BRep_PointOnCurve self, Handle_Geom_Curve C, TopLoc_Location L) -> Standard_Boolean

        :type C: OCC.wrapper.Geom.Handle_Geom_Curve
        :type L: OCC.wrapper.TopLoc.TopLoc_Location
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRep.Handle_BRep_PointOnCurve_IsPointOnCurve(self, *args)


    def Curve(self, *args):
        """
        :rtype: OCC.wrapper.Geom.Handle_Geom_Curve

        """
        res = _BRep.Handle_BRep_PointOnCurve_Curve(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def get_type_name(self, *args):
        """
        get_type_name(Handle_BRep_PointOnCurve self) -> char const *

        :rtype: const char *

        """
        return _BRep.Handle_BRep_PointOnCurve_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _BRep.Handle_BRep_PointOnCurve_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _BRep.Handle_BRep_PointOnCurve_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def IsPointOnCurveOnSurface(self, *args):
        """
        IsPointOnCurveOnSurface(Handle_BRep_PointOnCurve self) -> Standard_Boolean
        IsPointOnCurveOnSurface(Handle_BRep_PointOnCurve self, Handle_Geom2d_Curve PC, Handle_Geom_Surface S, TopLoc_Location L) -> Standard_Boolean

        A point on the 2d curve <PC> on the surface <S>.

        :type PC: OCC.wrapper.Geom2d.Handle_Geom2d_Curve
        :type S: OCC.wrapper.Geom.Handle_Geom_Surface
        :type L: OCC.wrapper.TopLoc.TopLoc_Location
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRep.Handle_BRep_PointOnCurve_IsPointOnCurveOnSurface(self, *args)


    def IsPointOnSurface(self, *args):
        """
        IsPointOnSurface(Handle_BRep_PointOnCurve self) -> Standard_Boolean
        IsPointOnSurface(Handle_BRep_PointOnCurve self, Handle_Geom_Surface S, TopLoc_Location L) -> Standard_Boolean

        A point on the surface <S>.

        :type S: OCC.wrapper.Geom.Handle_Geom_Surface
        :type L: OCC.wrapper.TopLoc.TopLoc_Location
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRep.Handle_BRep_PointOnCurve_IsPointOnSurface(self, *args)


    def Location(self, *args):
        """
        :rtype: OCC.wrapper.TopLoc.TopLoc_Location

        """
        res = _BRep.Handle_BRep_PointOnCurve_Location(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Parameter(self, *args):
        """
        Parameter(Handle_BRep_PointOnCurve self) -> Standard_Real
        Parameter(Handle_BRep_PointOnCurve self, Standard_Real const P)

        :type P: float

        """
        return _BRep.Handle_BRep_PointOnCurve_Parameter(self, *args)


    def Parameter2(self, *args):
        """
        Parameter2(Handle_BRep_PointOnCurve self) -> Standard_Real
        Parameter2(Handle_BRep_PointOnCurve self, Standard_Real const P)

        :type P: float

        """
        return _BRep.Handle_BRep_PointOnCurve_Parameter2(self, *args)


    def PCurve(self, *args):
        """
        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Curve

        """
        res = _BRep.Handle_BRep_PointOnCurve_PCurve(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Surface(self, *args):
        """
        :rtype: OCC.wrapper.Geom.Handle_Geom_Surface

        """
        res = _BRep.Handle_BRep_PointOnCurve_Surface(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_BRep_PointOnCurve self)

        Memory deallocator for transient classes


        """
        return _BRep.Handle_BRep_PointOnCurve_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_BRep_PointOnCurve self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_BRep_PointOnCurve self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRep.Handle_BRep_PointOnCurve_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_BRep_PointOnCurve self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_BRep_PointOnCurve self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRep.Handle_BRep_PointOnCurve_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_BRep_PointOnCurve self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _BRep.Handle_BRep_PointOnCurve_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_BRep_PointOnCurve self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRep.Handle_BRep_PointOnCurve_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_BRep_PointOnCurve self)

        Increments the reference counter of this object


        """
        return _BRep.Handle_BRep_PointOnCurve_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_BRep_PointOnCurve self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRep.Handle_BRep_PointOnCurve_DecrementRefCounter(self, *args)

Handle_BRep_PointOnCurve_swigregister = _BRep.Handle_BRep_PointOnCurve_swigregister
Handle_BRep_PointOnCurve_swigregister(Handle_BRep_PointOnCurve)

def Handle_BRep_PointOnCurve_DownCast(thing):
    return _BRep.Handle_BRep_PointOnCurve_DownCast(thing)
Handle_BRep_PointOnCurve_DownCast = _BRep.Handle_BRep_PointOnCurve_DownCast

class Handle_BRep_PointOnSurface(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_BRep_PointOnSurface self)

        Nullify the handle


        """
        return _BRep.Handle_BRep_PointOnSurface_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_BRep_PointOnSurface self) -> bool

        Check for being null

        :rtype: bool

        """
        return _BRep.Handle_BRep_PointOnSurface_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_BRep_PointOnSurface self, BRep_PointOnSurface thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _BRep.Handle_BRep_PointOnSurface_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_BRep_PointOnSurface self, Handle_BRep_PointOnSurface theHandle) -> Handle_BRep_PointOnSurface
        assign(Handle_BRep_PointOnSurface self, BRep_PointOnSurface thePtr) -> Handle_BRep_PointOnSurface
        assign(Handle_BRep_PointOnSurface self, Handle_BRep_PointOnSurface theHandle) -> Handle_BRep_PointOnSurface

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _BRep.Handle_BRep_PointOnSurface_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_BRep_PointOnSurface self) -> BRep_PointOnSurface

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _BRep.Handle_BRep_PointOnSurface_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_BRep_PointOnSurface self) -> BRep_PointOnSurface

        Member access operator (note non-const)

        :rtype: T *

        """
        return _BRep.Handle_BRep_PointOnSurface___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_BRep_PointOnSurface self) -> BRep_PointOnSurface

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _BRep.Handle_BRep_PointOnSurface___ref__(self, *args)


    def __hash__(self):
        return _BRep.Handle_BRep_PointOnSurface___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _BRep.Handle_BRep_PointOnSurface___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _BRep.new_Handle_BRep_PointOnSurface(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_BRep.Handle_BRep_PointOnSurface_DownCast)
    __swig_destroy__ = _BRep.delete_Handle_BRep_PointOnSurface

    def IsPointOnSurface(self, *args):
        """
        IsPointOnSurface(Handle_BRep_PointOnSurface self) -> Standard_Boolean
        IsPointOnSurface(Handle_BRep_PointOnSurface self, Handle_Geom_Surface S, TopLoc_Location L) -> Standard_Boolean

        :type S: OCC.wrapper.Geom.Handle_Geom_Surface
        :type L: OCC.wrapper.TopLoc.TopLoc_Location
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRep.Handle_BRep_PointOnSurface_IsPointOnSurface(self, *args)


    def Parameter2(self, *args):
        """
        Parameter2(Handle_BRep_PointOnSurface self) -> Standard_Real
        Parameter2(Handle_BRep_PointOnSurface self, Standard_Real const P)

        :type P: float

        """
        return _BRep.Handle_BRep_PointOnSurface_Parameter2(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_BRep_PointOnSurface self) -> char const *

        :rtype: const char *

        """
        return _BRep.Handle_BRep_PointOnSurface_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _BRep.Handle_BRep_PointOnSurface_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _BRep.Handle_BRep_PointOnSurface_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Surface(self, *args):
        """
        :rtype: OCC.wrapper.Geom.Handle_Geom_Surface

        """
        res = _BRep.Handle_BRep_PointOnSurface_Surface(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def IsPointOnCurve(self, *args):
        """
        IsPointOnCurve(Handle_BRep_PointOnSurface self) -> Standard_Boolean
        IsPointOnCurve(Handle_BRep_PointOnSurface self, Handle_Geom_Curve C, TopLoc_Location L) -> Standard_Boolean

        A point on the curve <C>.

        :type C: OCC.wrapper.Geom.Handle_Geom_Curve
        :type L: OCC.wrapper.TopLoc.TopLoc_Location
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRep.Handle_BRep_PointOnSurface_IsPointOnCurve(self, *args)


    def IsPointOnCurveOnSurface(self, *args):
        """
        IsPointOnCurveOnSurface(Handle_BRep_PointOnSurface self) -> Standard_Boolean
        IsPointOnCurveOnSurface(Handle_BRep_PointOnSurface self, Handle_Geom2d_Curve PC, Handle_Geom_Surface S, TopLoc_Location L) -> Standard_Boolean

        A point on the 2d curve <PC> on the surface <S>.

        :type PC: OCC.wrapper.Geom2d.Handle_Geom2d_Curve
        :type S: OCC.wrapper.Geom.Handle_Geom_Surface
        :type L: OCC.wrapper.TopLoc.TopLoc_Location
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRep.Handle_BRep_PointOnSurface_IsPointOnCurveOnSurface(self, *args)


    def Location(self, *args):
        """
        :rtype: OCC.wrapper.TopLoc.TopLoc_Location

        """
        res = _BRep.Handle_BRep_PointOnSurface_Location(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Parameter(self, *args):
        """
        Parameter(Handle_BRep_PointOnSurface self) -> Standard_Real
        Parameter(Handle_BRep_PointOnSurface self, Standard_Real const P)

        :type P: float

        """
        return _BRep.Handle_BRep_PointOnSurface_Parameter(self, *args)


    def Curve(self, *args):
        """
        :rtype: OCC.wrapper.Geom.Handle_Geom_Curve

        """
        res = _BRep.Handle_BRep_PointOnSurface_Curve(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def PCurve(self, *args):
        """
        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Curve

        """
        res = _BRep.Handle_BRep_PointOnSurface_PCurve(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_BRep_PointOnSurface self)

        Memory deallocator for transient classes


        """
        return _BRep.Handle_BRep_PointOnSurface_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_BRep_PointOnSurface self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_BRep_PointOnSurface self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRep.Handle_BRep_PointOnSurface_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_BRep_PointOnSurface self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_BRep_PointOnSurface self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRep.Handle_BRep_PointOnSurface_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_BRep_PointOnSurface self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _BRep.Handle_BRep_PointOnSurface_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_BRep_PointOnSurface self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRep.Handle_BRep_PointOnSurface_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_BRep_PointOnSurface self)

        Increments the reference counter of this object


        """
        return _BRep.Handle_BRep_PointOnSurface_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_BRep_PointOnSurface self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRep.Handle_BRep_PointOnSurface_DecrementRefCounter(self, *args)

Handle_BRep_PointOnSurface_swigregister = _BRep.Handle_BRep_PointOnSurface_swigregister
Handle_BRep_PointOnSurface_swigregister(Handle_BRep_PointOnSurface)

def Handle_BRep_PointOnSurface_DownCast(thing):
    return _BRep.Handle_BRep_PointOnSurface_DownCast(thing)
Handle_BRep_PointOnSurface_DownCast = _BRep.Handle_BRep_PointOnSurface_DownCast

class Handle_BRep_PointsOnSurface(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_BRep_PointsOnSurface self)

        Nullify the handle


        """
        return _BRep.Handle_BRep_PointsOnSurface_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_BRep_PointsOnSurface self) -> bool

        Check for being null

        :rtype: bool

        """
        return _BRep.Handle_BRep_PointsOnSurface_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_BRep_PointsOnSurface self, BRep_PointsOnSurface thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _BRep.Handle_BRep_PointsOnSurface_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_BRep_PointsOnSurface self, Handle_BRep_PointsOnSurface theHandle) -> Handle_BRep_PointsOnSurface
        assign(Handle_BRep_PointsOnSurface self, BRep_PointsOnSurface thePtr) -> Handle_BRep_PointsOnSurface
        assign(Handle_BRep_PointsOnSurface self, Handle_BRep_PointsOnSurface theHandle) -> Handle_BRep_PointsOnSurface

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _BRep.Handle_BRep_PointsOnSurface_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_BRep_PointsOnSurface self) -> BRep_PointsOnSurface

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _BRep.Handle_BRep_PointsOnSurface_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_BRep_PointsOnSurface self) -> BRep_PointsOnSurface

        Member access operator (note non-const)

        :rtype: T *

        """
        return _BRep.Handle_BRep_PointsOnSurface___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_BRep_PointsOnSurface self) -> BRep_PointsOnSurface

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _BRep.Handle_BRep_PointsOnSurface___ref__(self, *args)


    def __hash__(self):
        return _BRep.Handle_BRep_PointsOnSurface___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _BRep.Handle_BRep_PointsOnSurface___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _BRep.new_Handle_BRep_PointsOnSurface(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_BRep.Handle_BRep_PointsOnSurface_DownCast)
    __swig_destroy__ = _BRep.delete_Handle_BRep_PointsOnSurface

    def Surface(self, *args):
        """
        :rtype: OCC.wrapper.Geom.Handle_Geom_Surface

        """
        res = _BRep.Handle_BRep_PointsOnSurface_Surface(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def get_type_name(self, *args):
        """
        get_type_name(Handle_BRep_PointsOnSurface self) -> char const *

        :rtype: const char *

        """
        return _BRep.Handle_BRep_PointsOnSurface_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _BRep.Handle_BRep_PointsOnSurface_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _BRep.Handle_BRep_PointsOnSurface_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def IsPointOnCurve(self, *args):
        """
        IsPointOnCurve(Handle_BRep_PointsOnSurface self) -> Standard_Boolean
        IsPointOnCurve(Handle_BRep_PointsOnSurface self, Handle_Geom_Curve C, TopLoc_Location L) -> Standard_Boolean

        A point on the curve <C>.

        :type C: OCC.wrapper.Geom.Handle_Geom_Curve
        :type L: OCC.wrapper.TopLoc.TopLoc_Location
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRep.Handle_BRep_PointsOnSurface_IsPointOnCurve(self, *args)


    def IsPointOnCurveOnSurface(self, *args):
        """
        IsPointOnCurveOnSurface(Handle_BRep_PointsOnSurface self) -> Standard_Boolean
        IsPointOnCurveOnSurface(Handle_BRep_PointsOnSurface self, Handle_Geom2d_Curve PC, Handle_Geom_Surface S, TopLoc_Location L) -> Standard_Boolean

        A point on the 2d curve <PC> on the surface <S>.

        :type PC: OCC.wrapper.Geom2d.Handle_Geom2d_Curve
        :type S: OCC.wrapper.Geom.Handle_Geom_Surface
        :type L: OCC.wrapper.TopLoc.TopLoc_Location
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRep.Handle_BRep_PointsOnSurface_IsPointOnCurveOnSurface(self, *args)


    def IsPointOnSurface(self, *args):
        """
        IsPointOnSurface(Handle_BRep_PointsOnSurface self) -> Standard_Boolean
        IsPointOnSurface(Handle_BRep_PointsOnSurface self, Handle_Geom_Surface S, TopLoc_Location L) -> Standard_Boolean

        A point on the surface <S>.

        :type S: OCC.wrapper.Geom.Handle_Geom_Surface
        :type L: OCC.wrapper.TopLoc.TopLoc_Location
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRep.Handle_BRep_PointsOnSurface_IsPointOnSurface(self, *args)


    def Location(self, *args):
        """
        :rtype: OCC.wrapper.TopLoc.TopLoc_Location

        """
        res = _BRep.Handle_BRep_PointsOnSurface_Location(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Parameter(self, *args):
        """
        Parameter(Handle_BRep_PointsOnSurface self) -> Standard_Real
        Parameter(Handle_BRep_PointsOnSurface self, Standard_Real const P)

        :type P: float

        """
        return _BRep.Handle_BRep_PointsOnSurface_Parameter(self, *args)


    def Parameter2(self, *args):
        """
        Parameter2(Handle_BRep_PointsOnSurface self) -> Standard_Real
        Parameter2(Handle_BRep_PointsOnSurface self, Standard_Real const P)

        :type P: float

        """
        return _BRep.Handle_BRep_PointsOnSurface_Parameter2(self, *args)


    def Curve(self, *args):
        """
        :rtype: OCC.wrapper.Geom.Handle_Geom_Curve

        """
        res = _BRep.Handle_BRep_PointsOnSurface_Curve(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def PCurve(self, *args):
        """
        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Curve

        """
        res = _BRep.Handle_BRep_PointsOnSurface_PCurve(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_BRep_PointsOnSurface self)

        Memory deallocator for transient classes


        """
        return _BRep.Handle_BRep_PointsOnSurface_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_BRep_PointsOnSurface self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_BRep_PointsOnSurface self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRep.Handle_BRep_PointsOnSurface_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_BRep_PointsOnSurface self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_BRep_PointsOnSurface self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRep.Handle_BRep_PointsOnSurface_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_BRep_PointsOnSurface self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _BRep.Handle_BRep_PointsOnSurface_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_BRep_PointsOnSurface self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRep.Handle_BRep_PointsOnSurface_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_BRep_PointsOnSurface self)

        Increments the reference counter of this object


        """
        return _BRep.Handle_BRep_PointsOnSurface_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_BRep_PointsOnSurface self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRep.Handle_BRep_PointsOnSurface_DecrementRefCounter(self, *args)

Handle_BRep_PointsOnSurface_swigregister = _BRep.Handle_BRep_PointsOnSurface_swigregister
Handle_BRep_PointsOnSurface_swigregister(Handle_BRep_PointsOnSurface)

def Handle_BRep_PointsOnSurface_DownCast(thing):
    return _BRep.Handle_BRep_PointsOnSurface_DownCast(thing)
Handle_BRep_PointsOnSurface_DownCast = _BRep.Handle_BRep_PointsOnSurface_DownCast

class Handle_BRep_TEdge(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_BRep_TEdge self)

        Nullify the handle


        """
        return _BRep.Handle_BRep_TEdge_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_BRep_TEdge self) -> bool

        Check for being null

        :rtype: bool

        """
        return _BRep.Handle_BRep_TEdge_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_BRep_TEdge self, BRep_TEdge thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _BRep.Handle_BRep_TEdge_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_BRep_TEdge self, Handle_BRep_TEdge theHandle) -> Handle_BRep_TEdge
        assign(Handle_BRep_TEdge self, BRep_TEdge thePtr) -> Handle_BRep_TEdge
        assign(Handle_BRep_TEdge self, Handle_BRep_TEdge theHandle) -> Handle_BRep_TEdge

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _BRep.Handle_BRep_TEdge_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_BRep_TEdge self) -> BRep_TEdge

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _BRep.Handle_BRep_TEdge_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_BRep_TEdge self) -> BRep_TEdge

        Member access operator (note non-const)

        :rtype: T *

        """
        return _BRep.Handle_BRep_TEdge___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_BRep_TEdge self) -> BRep_TEdge

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _BRep.Handle_BRep_TEdge___ref__(self, *args)


    def __hash__(self):
        return _BRep.Handle_BRep_TEdge___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _BRep.Handle_BRep_TEdge___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _BRep.new_Handle_BRep_TEdge(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_BRep.Handle_BRep_TEdge_DownCast)
    __swig_destroy__ = _BRep.delete_Handle_BRep_TEdge

    def Tolerance(self, *args):
        """
        Tolerance(Handle_BRep_TEdge self) -> Standard_Real
        Tolerance(Handle_BRep_TEdge self, Standard_Real const T)

        :type T: float

        """
        return _BRep.Handle_BRep_TEdge_Tolerance(self, *args)


    def UpdateTolerance(self, *args):
        """
        UpdateTolerance(Handle_BRep_TEdge self, Standard_Real const T)

        Sets the tolerance  to the   max  of <T>  and  the
        current  tolerance.

        :type T: float

        """
        return _BRep.Handle_BRep_TEdge_UpdateTolerance(self, *args)


    def SameParameter(self, *args):
        """
        SameParameter(Handle_BRep_TEdge self) -> Standard_Boolean
        SameParameter(Handle_BRep_TEdge self, Standard_Boolean const S)

        :type S: bool

        """
        return _BRep.Handle_BRep_TEdge_SameParameter(self, *args)


    def SameRange(self, *args):
        """
        SameRange(Handle_BRep_TEdge self) -> Standard_Boolean
        SameRange(Handle_BRep_TEdge self, Standard_Boolean const S)

        :type S: bool

        """
        return _BRep.Handle_BRep_TEdge_SameRange(self, *args)


    def Degenerated(self, *args):
        """
        Degenerated(Handle_BRep_TEdge self) -> Standard_Boolean
        Degenerated(Handle_BRep_TEdge self, Standard_Boolean const S)

        :type S: bool

        """
        return _BRep.Handle_BRep_TEdge_Degenerated(self, *args)


    def Curves(self, *args):
        """
        :rtype: OCC.wrapper.BRep.BRep_ListOfCurveRepresentation

        """
        res = _BRep.Handle_BRep_TEdge_Curves(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeCurves(self, *args):
        """
        ChangeCurves(Handle_BRep_TEdge self) -> NCollection_List_Handle_BRep_CurveRepresentation

        :rtype: OCC.wrapper.BRep.BRep_ListOfCurveRepresentation

        """
        return _BRep.Handle_BRep_TEdge_ChangeCurves(self, *args)


    def EmptyCopy(self, *args):
        """
        EmptyCopy(Handle_BRep_TEdge self) -> Handle_TopoDS_TShape

        Returns a copy  of the  TShape  with no sub-shapes.

        :rtype: OCC.wrapper.TopoDS.Handle_TopoDS_TShape

        """
        return _BRep.Handle_BRep_TEdge_EmptyCopy(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_BRep_TEdge self) -> char const *

        :rtype: const char *

        """
        return _BRep.Handle_BRep_TEdge_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _BRep.Handle_BRep_TEdge_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _BRep.Handle_BRep_TEdge_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ShapeType(self, *args):
        """
        ShapeType(Handle_BRep_TEdge self) -> TopAbs_ShapeEnum

        Returns  EDGE.

        :rtype: OCC.wrapper.TopAbs.TopAbs_ShapeEnum

        """
        return _BRep.Handle_BRep_TEdge_ShapeType(self, *args)


    def Free(self, *args):
        """
        Free(Handle_BRep_TEdge self) -> Standard_Boolean
        Free(Handle_BRep_TEdge self, Standard_Boolean const F)

        Sets the free flag.

        :type F: bool

        """
        return _BRep.Handle_BRep_TEdge_Free(self, *args)


    def Locked(self, *args):
        """
        Locked(Handle_BRep_TEdge self) -> Standard_Boolean
        Locked(Handle_BRep_TEdge self, Standard_Boolean const F)

        Sets the locked flag.

        :type F: bool

        """
        return _BRep.Handle_BRep_TEdge_Locked(self, *args)


    def Modified(self, *args):
        """
        Modified(Handle_BRep_TEdge self) -> Standard_Boolean
        Modified(Handle_BRep_TEdge self, Standard_Boolean const M)

        Sets the modification flag.

        :type M: bool

        """
        return _BRep.Handle_BRep_TEdge_Modified(self, *args)


    def Checked(self, *args):
        """
        Checked(Handle_BRep_TEdge self) -> Standard_Boolean
        Checked(Handle_BRep_TEdge self, Standard_Boolean const C)

        Sets the checked flag.

        :type C: bool

        """
        return _BRep.Handle_BRep_TEdge_Checked(self, *args)


    def Orientable(self, *args):
        """
        Orientable(Handle_BRep_TEdge self) -> Standard_Boolean
        Orientable(Handle_BRep_TEdge self, Standard_Boolean const C)

        Sets the orientability flag.

        :type C: bool

        """
        return _BRep.Handle_BRep_TEdge_Orientable(self, *args)


    def Closed(self, *args):
        """
        Closed(Handle_BRep_TEdge self) -> Standard_Boolean
        Closed(Handle_BRep_TEdge self, Standard_Boolean const C)

        Sets the closedness flag.

        :type C: bool

        """
        return _BRep.Handle_BRep_TEdge_Closed(self, *args)


    def Infinite(self, *args):
        """
        Infinite(Handle_BRep_TEdge self) -> Standard_Boolean
        Infinite(Handle_BRep_TEdge self, Standard_Boolean const C)

        Sets the infinity flag.

        :type C: bool

        """
        return _BRep.Handle_BRep_TEdge_Infinite(self, *args)


    def Convex(self, *args):
        """
        Convex(Handle_BRep_TEdge self) -> Standard_Boolean
        Convex(Handle_BRep_TEdge self, Standard_Boolean const C)

        Sets the convexness flag.

        :type C: bool

        """
        return _BRep.Handle_BRep_TEdge_Convex(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_BRep_TEdge self)

        Memory deallocator for transient classes


        """
        return _BRep.Handle_BRep_TEdge_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_BRep_TEdge self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_BRep_TEdge self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRep.Handle_BRep_TEdge_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_BRep_TEdge self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_BRep_TEdge self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRep.Handle_BRep_TEdge_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_BRep_TEdge self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _BRep.Handle_BRep_TEdge_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_BRep_TEdge self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRep.Handle_BRep_TEdge_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_BRep_TEdge self)

        Increments the reference counter of this object


        """
        return _BRep.Handle_BRep_TEdge_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_BRep_TEdge self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRep.Handle_BRep_TEdge_DecrementRefCounter(self, *args)

Handle_BRep_TEdge_swigregister = _BRep.Handle_BRep_TEdge_swigregister
Handle_BRep_TEdge_swigregister(Handle_BRep_TEdge)

def Handle_BRep_TEdge_DownCast(thing):
    return _BRep.Handle_BRep_TEdge_DownCast(thing)
Handle_BRep_TEdge_DownCast = _BRep.Handle_BRep_TEdge_DownCast

class BRep_TVertex(TopoDS.TopoDS_TVertex):
    """
    The TVertex from  BRep inherits  from  the TVertex
    from TopoDS. It contains the geometric data.

    The  TVertex contains a 3d point, location and a tolerance.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_BRep_TVertex
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_BRep_TVertex(self) 
            return h


    def __init__(self, *args):
        """
        __init__(BRep_TVertex self) -> BRep_TVertex

        The TVertex from  BRep inherits  from  the TVertex
        from TopoDS. It contains the geometric data.

        The  TVertex contains a 3d point, location and a tolerance.
        """
        this = _BRep.new_BRep_TVertex(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Tolerance(self, *args):
        """
        Tolerance(BRep_TVertex self) -> Standard_Real
        Tolerance(BRep_TVertex self, Standard_Real const T)

        :type T: float

        """
        return _BRep.BRep_TVertex_Tolerance(self, *args)


    def UpdateTolerance(self, *args):
        """
        UpdateTolerance(BRep_TVertex self, Standard_Real const T)

        Sets the tolerance  to the   max  of <T>  and  the
        current  tolerance.

        :type T: float

        """
        return _BRep.BRep_TVertex_UpdateTolerance(self, *args)


    def Pnt(self, *args):
        """
        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        res = _BRep.BRep_TVertex_Pnt(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Points(self, *args):
        """
        :rtype: OCC.wrapper.BRep.BRep_ListOfPointRepresentation

        """
        res = _BRep.BRep_TVertex_Points(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangePoints(self, *args):
        """
        ChangePoints(BRep_TVertex self) -> NCollection_List_Handle_BRep_PointRepresentation

        :rtype: OCC.wrapper.BRep.BRep_ListOfPointRepresentation

        """
        return _BRep.BRep_TVertex_ChangePoints(self, *args)


    def EmptyCopy(self, *args):
        """
        EmptyCopy(BRep_TVertex self) -> Handle_TopoDS_TShape

        Returns a copy  of the  TShape  with no sub-shapes.

        :rtype: OCC.wrapper.TopoDS.Handle_TopoDS_TShape

        """
        return _BRep.BRep_TVertex_EmptyCopy(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _BRep.BRep_TVertex_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _BRep.BRep_TVertex_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _BRep.BRep_TVertex_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _BRep.delete_BRep_TVertex
BRep_TVertex_swigregister = _BRep.BRep_TVertex_swigregister
BRep_TVertex_swigregister(BRep_TVertex)

def BRep_TVertex_get_type_name(*args):
    """
    BRep_TVertex_get_type_name() -> char const *

    :rtype: const char *

    """
    return _BRep.BRep_TVertex_get_type_name(*args)

def BRep_TVertex_get_type_descriptor(*args):
    """
    BRep_TVertex_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _BRep.BRep_TVertex_get_type_descriptor(*args)

class Handle_BRep_CurveOn2Surfaces(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_BRep_CurveOn2Surfaces self)

        Nullify the handle


        """
        return _BRep.Handle_BRep_CurveOn2Surfaces_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_BRep_CurveOn2Surfaces self) -> bool

        Check for being null

        :rtype: bool

        """
        return _BRep.Handle_BRep_CurveOn2Surfaces_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_BRep_CurveOn2Surfaces self, BRep_CurveOn2Surfaces thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _BRep.Handle_BRep_CurveOn2Surfaces_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_BRep_CurveOn2Surfaces self, Handle_BRep_CurveOn2Surfaces theHandle) -> Handle_BRep_CurveOn2Surfaces
        assign(Handle_BRep_CurveOn2Surfaces self, BRep_CurveOn2Surfaces thePtr) -> Handle_BRep_CurveOn2Surfaces
        assign(Handle_BRep_CurveOn2Surfaces self, Handle_BRep_CurveOn2Surfaces theHandle) -> Handle_BRep_CurveOn2Surfaces

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _BRep.Handle_BRep_CurveOn2Surfaces_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_BRep_CurveOn2Surfaces self) -> BRep_CurveOn2Surfaces

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _BRep.Handle_BRep_CurveOn2Surfaces_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_BRep_CurveOn2Surfaces self) -> BRep_CurveOn2Surfaces

        Member access operator (note non-const)

        :rtype: T *

        """
        return _BRep.Handle_BRep_CurveOn2Surfaces___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_BRep_CurveOn2Surfaces self) -> BRep_CurveOn2Surfaces

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _BRep.Handle_BRep_CurveOn2Surfaces___ref__(self, *args)


    def __hash__(self):
        return _BRep.Handle_BRep_CurveOn2Surfaces___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _BRep.Handle_BRep_CurveOn2Surfaces___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _BRep.new_Handle_BRep_CurveOn2Surfaces(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_BRep.Handle_BRep_CurveOn2Surfaces_DownCast)
    __swig_destroy__ = _BRep.delete_Handle_BRep_CurveOn2Surfaces

    def IsRegularity(self, *args):
        """
        IsRegularity(Handle_BRep_CurveOn2Surfaces self) -> Standard_Boolean
        IsRegularity(Handle_BRep_CurveOn2Surfaces self, Handle_Geom_Surface S1, Handle_Geom_Surface S2, TopLoc_Location L1, TopLoc_Location L2) -> Standard_Boolean

        A curve on two surfaces (continuity).

        :type S1: OCC.wrapper.Geom.Handle_Geom_Surface
        :type S2: OCC.wrapper.Geom.Handle_Geom_Surface
        :type L1: OCC.wrapper.TopLoc.TopLoc_Location
        :type L2: OCC.wrapper.TopLoc.TopLoc_Location
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRep.Handle_BRep_CurveOn2Surfaces_IsRegularity(self, *args)


    def D0(self, *args):
        """
        D0(Handle_BRep_CurveOn2Surfaces self, Standard_Real const U, gp_Pnt P)

        Raises an error.

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt

        """
        return _BRep.Handle_BRep_CurveOn2Surfaces_D0(self, *args)


    def Surface(self, *args):
        """
        :rtype: OCC.wrapper.Geom.Handle_Geom_Surface

        """
        res = _BRep.Handle_BRep_CurveOn2Surfaces_Surface(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Surface2(self, *args):
        """
        :rtype: OCC.wrapper.Geom.Handle_Geom_Surface

        """
        res = _BRep.Handle_BRep_CurveOn2Surfaces_Surface2(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Location2(self, *args):
        """
        :rtype: OCC.wrapper.TopLoc.TopLoc_Location

        """
        res = _BRep.Handle_BRep_CurveOn2Surfaces_Location2(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Continuity(self, *args):
        """
        :rtype: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        res = _BRep.Handle_BRep_CurveOn2Surfaces_Continuity(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Copy(self, *args):
        """
        Copy(Handle_BRep_CurveOn2Surfaces self) -> Handle_BRep_CurveRepresentation

        Return a copy of this representation.

        :rtype: OCC.wrapper.BRep.Handle_BRep_CurveRepresentation

        """
        return _BRep.Handle_BRep_CurveOn2Surfaces_Copy(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_BRep_CurveOn2Surfaces self) -> char const *

        :rtype: const char *

        """
        return _BRep.Handle_BRep_CurveOn2Surfaces_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _BRep.Handle_BRep_CurveOn2Surfaces_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _BRep.Handle_BRep_CurveOn2Surfaces_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def IsCurve3D(self, *args):
        """
        IsCurve3D(Handle_BRep_CurveOn2Surfaces self) -> Standard_Boolean

        A 3D curve representation.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRep.Handle_BRep_CurveOn2Surfaces_IsCurve3D(self, *args)


    def IsCurveOnSurface(self, *args):
        """
        IsCurveOnSurface(Handle_BRep_CurveOn2Surfaces self) -> Standard_Boolean
        IsCurveOnSurface(Handle_BRep_CurveOn2Surfaces self, Handle_Geom_Surface S, TopLoc_Location L) -> Standard_Boolean

        Is it a curve in the parametric space  of <S> with
        location <L>.

        :type S: OCC.wrapper.Geom.Handle_Geom_Surface
        :type L: OCC.wrapper.TopLoc.TopLoc_Location
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRep.Handle_BRep_CurveOn2Surfaces_IsCurveOnSurface(self, *args)


    def IsCurveOnClosedSurface(self, *args):
        """
        IsCurveOnClosedSurface(Handle_BRep_CurveOn2Surfaces self) -> Standard_Boolean

        A curve with two parametric   curves  on the  same
        surface.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRep.Handle_BRep_CurveOn2Surfaces_IsCurveOnClosedSurface(self, *args)


    def IsPolygon3D(self, *args):
        """
        IsPolygon3D(Handle_BRep_CurveOn2Surfaces self) -> Standard_Boolean

        A 3D polygon representation.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRep.Handle_BRep_CurveOn2Surfaces_IsPolygon3D(self, *args)


    def IsPolygonOnTriangulation(self, *args):
        """
        IsPolygonOnTriangulation(Handle_BRep_CurveOn2Surfaces self) -> Standard_Boolean
        IsPolygonOnTriangulation(Handle_BRep_CurveOn2Surfaces self, Handle_Poly_Triangulation T, TopLoc_Location L) -> Standard_Boolean

        Is it a polygon in the definition of <T> with
        location <L>.

        :type T: OCC.wrapper.Poly.Handle_Poly_Triangulation
        :type L: OCC.wrapper.TopLoc.TopLoc_Location
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRep.Handle_BRep_CurveOn2Surfaces_IsPolygonOnTriangulation(self, *args)


    def IsPolygonOnClosedTriangulation(self, *args):
        """
        IsPolygonOnClosedTriangulation(Handle_BRep_CurveOn2Surfaces self) -> Standard_Boolean

        A representation by two arrays of nodes on a
        triangulation.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRep.Handle_BRep_CurveOn2Surfaces_IsPolygonOnClosedTriangulation(self, *args)


    def IsPolygonOnSurface(self, *args):
        """
        IsPolygonOnSurface(Handle_BRep_CurveOn2Surfaces self) -> Standard_Boolean
        IsPolygonOnSurface(Handle_BRep_CurveOn2Surfaces self, Handle_Geom_Surface S, TopLoc_Location L) -> Standard_Boolean

        Is it a polygon in the parametric space  of <S> with
        location <L>.

        :type S: OCC.wrapper.Geom.Handle_Geom_Surface
        :type L: OCC.wrapper.TopLoc.TopLoc_Location
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRep.Handle_BRep_CurveOn2Surfaces_IsPolygonOnSurface(self, *args)


    def IsPolygonOnClosedSurface(self, *args):
        """
        IsPolygonOnClosedSurface(Handle_BRep_CurveOn2Surfaces self) -> Standard_Boolean

        Two   2D polygon  representations  in the  parametric
        space of a surface.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRep.Handle_BRep_CurveOn2Surfaces_IsPolygonOnClosedSurface(self, *args)


    def Location(self, *args):
        """
        :rtype: OCC.wrapper.TopLoc.TopLoc_Location

        """
        res = _BRep.Handle_BRep_CurveOn2Surfaces_Location(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Curve3D(self, *args):
        """
        :rtype: OCC.wrapper.Geom.Handle_Geom_Curve

        """
        res = _BRep.Handle_BRep_CurveOn2Surfaces_Curve3D(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def PCurve(self, *args):
        """
        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Curve

        """
        res = _BRep.Handle_BRep_CurveOn2Surfaces_PCurve(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def PCurve2(self, *args):
        """
        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Curve

        """
        res = _BRep.Handle_BRep_CurveOn2Surfaces_PCurve2(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Polygon3D(self, *args):
        """
        :rtype: OCC.wrapper.Poly.Handle_Poly_Polygon3D

        """
        res = _BRep.Handle_BRep_CurveOn2Surfaces_Polygon3D(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Polygon(self, *args):
        """
        :rtype: OCC.wrapper.Poly.Handle_Poly_Polygon2D

        """
        res = _BRep.Handle_BRep_CurveOn2Surfaces_Polygon(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Polygon2(self, *args):
        """
        :rtype: OCC.wrapper.Poly.Handle_Poly_Polygon2D

        """
        res = _BRep.Handle_BRep_CurveOn2Surfaces_Polygon2(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Triangulation(self, *args):
        """
        :rtype: OCC.wrapper.Poly.Handle_Poly_Triangulation

        """
        res = _BRep.Handle_BRep_CurveOn2Surfaces_Triangulation(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def PolygonOnTriangulation(self, *args):
        """
        :rtype: OCC.wrapper.Poly.Handle_Poly_PolygonOnTriangulation

        """
        res = _BRep.Handle_BRep_CurveOn2Surfaces_PolygonOnTriangulation(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def PolygonOnTriangulation2(self, *args):
        """
        :rtype: OCC.wrapper.Poly.Handle_Poly_PolygonOnTriangulation

        """
        res = _BRep.Handle_BRep_CurveOn2Surfaces_PolygonOnTriangulation2(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_BRep_CurveOn2Surfaces self)

        Memory deallocator for transient classes


        """
        return _BRep.Handle_BRep_CurveOn2Surfaces_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_BRep_CurveOn2Surfaces self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_BRep_CurveOn2Surfaces self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRep.Handle_BRep_CurveOn2Surfaces_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_BRep_CurveOn2Surfaces self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_BRep_CurveOn2Surfaces self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRep.Handle_BRep_CurveOn2Surfaces_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_BRep_CurveOn2Surfaces self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _BRep.Handle_BRep_CurveOn2Surfaces_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_BRep_CurveOn2Surfaces self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRep.Handle_BRep_CurveOn2Surfaces_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_BRep_CurveOn2Surfaces self)

        Increments the reference counter of this object


        """
        return _BRep.Handle_BRep_CurveOn2Surfaces_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_BRep_CurveOn2Surfaces self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRep.Handle_BRep_CurveOn2Surfaces_DecrementRefCounter(self, *args)

Handle_BRep_CurveOn2Surfaces_swigregister = _BRep.Handle_BRep_CurveOn2Surfaces_swigregister
Handle_BRep_CurveOn2Surfaces_swigregister(Handle_BRep_CurveOn2Surfaces)

def Handle_BRep_CurveOn2Surfaces_DownCast(thing):
    return _BRep.Handle_BRep_CurveOn2Surfaces_DownCast(thing)
Handle_BRep_CurveOn2Surfaces_DownCast = _BRep.Handle_BRep_CurveOn2Surfaces_DownCast

class Handle_BRep_Curve3D(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_BRep_Curve3D self)

        Nullify the handle


        """
        return _BRep.Handle_BRep_Curve3D_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_BRep_Curve3D self) -> bool

        Check for being null

        :rtype: bool

        """
        return _BRep.Handle_BRep_Curve3D_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_BRep_Curve3D self, BRep_Curve3D thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _BRep.Handle_BRep_Curve3D_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_BRep_Curve3D self, Handle_BRep_Curve3D theHandle) -> Handle_BRep_Curve3D
        assign(Handle_BRep_Curve3D self, BRep_Curve3D thePtr) -> Handle_BRep_Curve3D
        assign(Handle_BRep_Curve3D self, Handle_BRep_Curve3D theHandle) -> Handle_BRep_Curve3D

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _BRep.Handle_BRep_Curve3D_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_BRep_Curve3D self) -> BRep_Curve3D

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _BRep.Handle_BRep_Curve3D_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_BRep_Curve3D self) -> BRep_Curve3D

        Member access operator (note non-const)

        :rtype: T *

        """
        return _BRep.Handle_BRep_Curve3D___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_BRep_Curve3D self) -> BRep_Curve3D

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _BRep.Handle_BRep_Curve3D___ref__(self, *args)


    def __hash__(self):
        return _BRep.Handle_BRep_Curve3D___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _BRep.Handle_BRep_Curve3D___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _BRep.new_Handle_BRep_Curve3D(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_BRep.Handle_BRep_Curve3D_DownCast)
    __swig_destroy__ = _BRep.delete_Handle_BRep_Curve3D

    def D0(self, *args):
        """
        D0(Handle_BRep_Curve3D self, Standard_Real const U, gp_Pnt P)

        Computes the point at parameter U.

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt

        """
        return _BRep.Handle_BRep_Curve3D_D0(self, *args)


    def IsCurve3D(self, *args):
        """
        IsCurve3D(Handle_BRep_Curve3D self) -> Standard_Boolean

        Returns True.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRep.Handle_BRep_Curve3D_IsCurve3D(self, *args)


    def Curve3D(self, *args):
        """
        :rtype: OCC.wrapper.Geom.Handle_Geom_Curve

        """
        res = _BRep.Handle_BRep_Curve3D_Curve3D(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Copy(self, *args):
        """
        Copy(Handle_BRep_Curve3D self) -> Handle_BRep_CurveRepresentation

        Return a copy of this representation.

        :rtype: OCC.wrapper.BRep.Handle_BRep_CurveRepresentation

        """
        return _BRep.Handle_BRep_Curve3D_Copy(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_BRep_Curve3D self) -> char const *

        :rtype: const char *

        """
        return _BRep.Handle_BRep_Curve3D_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _BRep.Handle_BRep_Curve3D_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _BRep.Handle_BRep_Curve3D_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetRange(self, *args):
        """
        SetRange(Handle_BRep_Curve3D self, Standard_Real const First, Standard_Real const Last)

        :type First: float
        :type Last: float

        """
        return _BRep.Handle_BRep_Curve3D_SetRange(self, *args)


    def Range(self, *args):
        """
        Range(Handle_BRep_Curve3D self)

        :type First: float
        :type Last: float

        """
        return _BRep.Handle_BRep_Curve3D_Range(self, *args)


    def First(self, *args):
        """
        First(Handle_BRep_Curve3D self) -> Standard_Real
        First(Handle_BRep_Curve3D self, Standard_Real const F)

        :type F: float

        """
        return _BRep.Handle_BRep_Curve3D_First(self, *args)


    def Last(self, *args):
        """
        Last(Handle_BRep_Curve3D self) -> Standard_Real
        Last(Handle_BRep_Curve3D self, Standard_Real const L)

        :type L: float

        """
        return _BRep.Handle_BRep_Curve3D_Last(self, *args)


    def Update(self, *args):
        """
        Update(Handle_BRep_Curve3D self)

        Recomputes any derived data after a modification.
        This is called when the range is modified.


        """
        return _BRep.Handle_BRep_Curve3D_Update(self, *args)


    def IsCurveOnSurface(self, *args):
        """
        IsCurveOnSurface(Handle_BRep_Curve3D self) -> Standard_Boolean
        IsCurveOnSurface(Handle_BRep_Curve3D self, Handle_Geom_Surface S, TopLoc_Location L) -> Standard_Boolean

        Is it a curve in the parametric space  of <S> with
        location <L>.

        :type S: OCC.wrapper.Geom.Handle_Geom_Surface
        :type L: OCC.wrapper.TopLoc.TopLoc_Location
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRep.Handle_BRep_Curve3D_IsCurveOnSurface(self, *args)


    def IsRegularity(self, *args):
        """
        IsRegularity(Handle_BRep_Curve3D self) -> Standard_Boolean
        IsRegularity(Handle_BRep_Curve3D self, Handle_Geom_Surface S1, Handle_Geom_Surface S2, TopLoc_Location L1, TopLoc_Location L2) -> Standard_Boolean

        Is it  a  regularity between  <S1> and   <S2> with
        location <L1> and <L2>.

        :type S1: OCC.wrapper.Geom.Handle_Geom_Surface
        :type S2: OCC.wrapper.Geom.Handle_Geom_Surface
        :type L1: OCC.wrapper.TopLoc.TopLoc_Location
        :type L2: OCC.wrapper.TopLoc.TopLoc_Location
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRep.Handle_BRep_Curve3D_IsRegularity(self, *args)


    def IsCurveOnClosedSurface(self, *args):
        """
        IsCurveOnClosedSurface(Handle_BRep_Curve3D self) -> Standard_Boolean

        A curve with two parametric   curves  on the  same
        surface.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRep.Handle_BRep_Curve3D_IsCurveOnClosedSurface(self, *args)


    def IsPolygon3D(self, *args):
        """
        IsPolygon3D(Handle_BRep_Curve3D self) -> Standard_Boolean

        A 3D polygon representation.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRep.Handle_BRep_Curve3D_IsPolygon3D(self, *args)


    def IsPolygonOnTriangulation(self, *args):
        """
        IsPolygonOnTriangulation(Handle_BRep_Curve3D self) -> Standard_Boolean
        IsPolygonOnTriangulation(Handle_BRep_Curve3D self, Handle_Poly_Triangulation T, TopLoc_Location L) -> Standard_Boolean

        Is it a polygon in the definition of <T> with
        location <L>.

        :type T: OCC.wrapper.Poly.Handle_Poly_Triangulation
        :type L: OCC.wrapper.TopLoc.TopLoc_Location
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRep.Handle_BRep_Curve3D_IsPolygonOnTriangulation(self, *args)


    def IsPolygonOnClosedTriangulation(self, *args):
        """
        IsPolygonOnClosedTriangulation(Handle_BRep_Curve3D self) -> Standard_Boolean

        A representation by two arrays of nodes on a
        triangulation.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRep.Handle_BRep_Curve3D_IsPolygonOnClosedTriangulation(self, *args)


    def IsPolygonOnSurface(self, *args):
        """
        IsPolygonOnSurface(Handle_BRep_Curve3D self) -> Standard_Boolean
        IsPolygonOnSurface(Handle_BRep_Curve3D self, Handle_Geom_Surface S, TopLoc_Location L) -> Standard_Boolean

        Is it a polygon in the parametric space  of <S> with
        location <L>.

        :type S: OCC.wrapper.Geom.Handle_Geom_Surface
        :type L: OCC.wrapper.TopLoc.TopLoc_Location
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRep.Handle_BRep_Curve3D_IsPolygonOnSurface(self, *args)


    def IsPolygonOnClosedSurface(self, *args):
        """
        IsPolygonOnClosedSurface(Handle_BRep_Curve3D self) -> Standard_Boolean

        Two   2D polygon  representations  in the  parametric
        space of a surface.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRep.Handle_BRep_Curve3D_IsPolygonOnClosedSurface(self, *args)


    def Location(self, *args):
        """
        :rtype: OCC.wrapper.TopLoc.TopLoc_Location

        """
        res = _BRep.Handle_BRep_Curve3D_Location(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Surface(self, *args):
        """
        :rtype: OCC.wrapper.Geom.Handle_Geom_Surface

        """
        res = _BRep.Handle_BRep_Curve3D_Surface(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def PCurve(self, *args):
        """
        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Curve

        """
        res = _BRep.Handle_BRep_Curve3D_PCurve(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def PCurve2(self, *args):
        """
        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Curve

        """
        res = _BRep.Handle_BRep_Curve3D_PCurve2(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Polygon3D(self, *args):
        """
        :rtype: OCC.wrapper.Poly.Handle_Poly_Polygon3D

        """
        res = _BRep.Handle_BRep_Curve3D_Polygon3D(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Polygon(self, *args):
        """
        :rtype: OCC.wrapper.Poly.Handle_Poly_Polygon2D

        """
        res = _BRep.Handle_BRep_Curve3D_Polygon(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Polygon2(self, *args):
        """
        :rtype: OCC.wrapper.Poly.Handle_Poly_Polygon2D

        """
        res = _BRep.Handle_BRep_Curve3D_Polygon2(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Triangulation(self, *args):
        """
        :rtype: OCC.wrapper.Poly.Handle_Poly_Triangulation

        """
        res = _BRep.Handle_BRep_Curve3D_Triangulation(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def PolygonOnTriangulation(self, *args):
        """
        :rtype: OCC.wrapper.Poly.Handle_Poly_PolygonOnTriangulation

        """
        res = _BRep.Handle_BRep_Curve3D_PolygonOnTriangulation(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def PolygonOnTriangulation2(self, *args):
        """
        :rtype: OCC.wrapper.Poly.Handle_Poly_PolygonOnTriangulation

        """
        res = _BRep.Handle_BRep_Curve3D_PolygonOnTriangulation2(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Surface2(self, *args):
        """
        :rtype: OCC.wrapper.Geom.Handle_Geom_Surface

        """
        res = _BRep.Handle_BRep_Curve3D_Surface2(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Location2(self, *args):
        """
        :rtype: OCC.wrapper.TopLoc.TopLoc_Location

        """
        res = _BRep.Handle_BRep_Curve3D_Location2(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Continuity(self, *args):
        """
        :rtype: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        res = _BRep.Handle_BRep_Curve3D_Continuity(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_BRep_Curve3D self)

        Memory deallocator for transient classes


        """
        return _BRep.Handle_BRep_Curve3D_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_BRep_Curve3D self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_BRep_Curve3D self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRep.Handle_BRep_Curve3D_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_BRep_Curve3D self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_BRep_Curve3D self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRep.Handle_BRep_Curve3D_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_BRep_Curve3D self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _BRep.Handle_BRep_Curve3D_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_BRep_Curve3D self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRep.Handle_BRep_Curve3D_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_BRep_Curve3D self)

        Increments the reference counter of this object


        """
        return _BRep.Handle_BRep_Curve3D_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_BRep_Curve3D self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRep.Handle_BRep_Curve3D_DecrementRefCounter(self, *args)

Handle_BRep_Curve3D_swigregister = _BRep.Handle_BRep_Curve3D_swigregister
Handle_BRep_Curve3D_swigregister(Handle_BRep_Curve3D)

def Handle_BRep_Curve3D_DownCast(thing):
    return _BRep.Handle_BRep_Curve3D_DownCast(thing)
Handle_BRep_Curve3D_DownCast = _BRep.Handle_BRep_Curve3D_DownCast

class Handle_BRep_TVertex(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_BRep_TVertex self)

        Nullify the handle


        """
        return _BRep.Handle_BRep_TVertex_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_BRep_TVertex self) -> bool

        Check for being null

        :rtype: bool

        """
        return _BRep.Handle_BRep_TVertex_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_BRep_TVertex self, BRep_TVertex thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _BRep.Handle_BRep_TVertex_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_BRep_TVertex self, Handle_BRep_TVertex theHandle) -> Handle_BRep_TVertex
        assign(Handle_BRep_TVertex self, BRep_TVertex thePtr) -> Handle_BRep_TVertex
        assign(Handle_BRep_TVertex self, Handle_BRep_TVertex theHandle) -> Handle_BRep_TVertex

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _BRep.Handle_BRep_TVertex_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_BRep_TVertex self) -> BRep_TVertex

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _BRep.Handle_BRep_TVertex_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_BRep_TVertex self) -> BRep_TVertex

        Member access operator (note non-const)

        :rtype: T *

        """
        return _BRep.Handle_BRep_TVertex___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_BRep_TVertex self) -> BRep_TVertex

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _BRep.Handle_BRep_TVertex___ref__(self, *args)


    def __hash__(self):
        return _BRep.Handle_BRep_TVertex___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _BRep.Handle_BRep_TVertex___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _BRep.new_Handle_BRep_TVertex(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_BRep.Handle_BRep_TVertex_DownCast)
    __swig_destroy__ = _BRep.delete_Handle_BRep_TVertex

    def Tolerance(self, *args):
        """
        Tolerance(Handle_BRep_TVertex self) -> Standard_Real
        Tolerance(Handle_BRep_TVertex self, Standard_Real const T)

        :type T: float

        """
        return _BRep.Handle_BRep_TVertex_Tolerance(self, *args)


    def UpdateTolerance(self, *args):
        """
        UpdateTolerance(Handle_BRep_TVertex self, Standard_Real const T)

        Sets the tolerance  to the   max  of <T>  and  the
        current  tolerance.

        :type T: float

        """
        return _BRep.Handle_BRep_TVertex_UpdateTolerance(self, *args)


    def Pnt(self, *args):
        """
        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        res = _BRep.Handle_BRep_TVertex_Pnt(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Points(self, *args):
        """
        :rtype: OCC.wrapper.BRep.BRep_ListOfPointRepresentation

        """
        res = _BRep.Handle_BRep_TVertex_Points(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangePoints(self, *args):
        """
        ChangePoints(Handle_BRep_TVertex self) -> NCollection_List_Handle_BRep_PointRepresentation

        :rtype: OCC.wrapper.BRep.BRep_ListOfPointRepresentation

        """
        return _BRep.Handle_BRep_TVertex_ChangePoints(self, *args)


    def EmptyCopy(self, *args):
        """
        EmptyCopy(Handle_BRep_TVertex self) -> Handle_TopoDS_TShape

        Returns a copy  of the  TShape  with no sub-shapes.

        :rtype: OCC.wrapper.TopoDS.Handle_TopoDS_TShape

        """
        return _BRep.Handle_BRep_TVertex_EmptyCopy(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_BRep_TVertex self) -> char const *

        :rtype: const char *

        """
        return _BRep.Handle_BRep_TVertex_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _BRep.Handle_BRep_TVertex_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _BRep.Handle_BRep_TVertex_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ShapeType(self, *args):
        """
        ShapeType(Handle_BRep_TVertex self) -> TopAbs_ShapeEnum

        Returns VERTEX.

        :rtype: OCC.wrapper.TopAbs.TopAbs_ShapeEnum

        """
        return _BRep.Handle_BRep_TVertex_ShapeType(self, *args)


    def Free(self, *args):
        """
        Free(Handle_BRep_TVertex self) -> Standard_Boolean
        Free(Handle_BRep_TVertex self, Standard_Boolean const F)

        Sets the free flag.

        :type F: bool

        """
        return _BRep.Handle_BRep_TVertex_Free(self, *args)


    def Locked(self, *args):
        """
        Locked(Handle_BRep_TVertex self) -> Standard_Boolean
        Locked(Handle_BRep_TVertex self, Standard_Boolean const F)

        Sets the locked flag.

        :type F: bool

        """
        return _BRep.Handle_BRep_TVertex_Locked(self, *args)


    def Modified(self, *args):
        """
        Modified(Handle_BRep_TVertex self) -> Standard_Boolean
        Modified(Handle_BRep_TVertex self, Standard_Boolean const M)

        Sets the modification flag.

        :type M: bool

        """
        return _BRep.Handle_BRep_TVertex_Modified(self, *args)


    def Checked(self, *args):
        """
        Checked(Handle_BRep_TVertex self) -> Standard_Boolean
        Checked(Handle_BRep_TVertex self, Standard_Boolean const C)

        Sets the checked flag.

        :type C: bool

        """
        return _BRep.Handle_BRep_TVertex_Checked(self, *args)


    def Orientable(self, *args):
        """
        Orientable(Handle_BRep_TVertex self) -> Standard_Boolean
        Orientable(Handle_BRep_TVertex self, Standard_Boolean const C)

        Sets the orientability flag.

        :type C: bool

        """
        return _BRep.Handle_BRep_TVertex_Orientable(self, *args)


    def Closed(self, *args):
        """
        Closed(Handle_BRep_TVertex self) -> Standard_Boolean
        Closed(Handle_BRep_TVertex self, Standard_Boolean const C)

        Sets the closedness flag.

        :type C: bool

        """
        return _BRep.Handle_BRep_TVertex_Closed(self, *args)


    def Infinite(self, *args):
        """
        Infinite(Handle_BRep_TVertex self) -> Standard_Boolean
        Infinite(Handle_BRep_TVertex self, Standard_Boolean const C)

        Sets the infinity flag.

        :type C: bool

        """
        return _BRep.Handle_BRep_TVertex_Infinite(self, *args)


    def Convex(self, *args):
        """
        Convex(Handle_BRep_TVertex self) -> Standard_Boolean
        Convex(Handle_BRep_TVertex self, Standard_Boolean const C)

        Sets the convexness flag.

        :type C: bool

        """
        return _BRep.Handle_BRep_TVertex_Convex(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_BRep_TVertex self)

        Memory deallocator for transient classes


        """
        return _BRep.Handle_BRep_TVertex_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_BRep_TVertex self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_BRep_TVertex self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRep.Handle_BRep_TVertex_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_BRep_TVertex self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_BRep_TVertex self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRep.Handle_BRep_TVertex_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_BRep_TVertex self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _BRep.Handle_BRep_TVertex_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_BRep_TVertex self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRep.Handle_BRep_TVertex_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_BRep_TVertex self)

        Increments the reference counter of this object


        """
        return _BRep.Handle_BRep_TVertex_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_BRep_TVertex self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRep.Handle_BRep_TVertex_DecrementRefCounter(self, *args)

Handle_BRep_TVertex_swigregister = _BRep.Handle_BRep_TVertex_swigregister
Handle_BRep_TVertex_swigregister(Handle_BRep_TVertex)

def Handle_BRep_TVertex_DownCast(thing):
    return _BRep.Handle_BRep_TVertex_DownCast(thing)
Handle_BRep_TVertex_DownCast = _BRep.Handle_BRep_TVertex_DownCast

class Handle_BRep_PolygonOnTriangulation(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_BRep_PolygonOnTriangulation self)

        Nullify the handle


        """
        return _BRep.Handle_BRep_PolygonOnTriangulation_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_BRep_PolygonOnTriangulation self) -> bool

        Check for being null

        :rtype: bool

        """
        return _BRep.Handle_BRep_PolygonOnTriangulation_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_BRep_PolygonOnTriangulation self, BRep_PolygonOnTriangulation thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _BRep.Handle_BRep_PolygonOnTriangulation_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_BRep_PolygonOnTriangulation self, Handle_BRep_PolygonOnTriangulation theHandle) -> Handle_BRep_PolygonOnTriangulation
        assign(Handle_BRep_PolygonOnTriangulation self, BRep_PolygonOnTriangulation thePtr) -> Handle_BRep_PolygonOnTriangulation
        assign(Handle_BRep_PolygonOnTriangulation self, Handle_BRep_PolygonOnTriangulation theHandle) -> Handle_BRep_PolygonOnTriangulation

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _BRep.Handle_BRep_PolygonOnTriangulation_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_BRep_PolygonOnTriangulation self) -> BRep_PolygonOnTriangulation

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _BRep.Handle_BRep_PolygonOnTriangulation_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_BRep_PolygonOnTriangulation self) -> BRep_PolygonOnTriangulation

        Member access operator (note non-const)

        :rtype: T *

        """
        return _BRep.Handle_BRep_PolygonOnTriangulation___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_BRep_PolygonOnTriangulation self) -> BRep_PolygonOnTriangulation

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _BRep.Handle_BRep_PolygonOnTriangulation___ref__(self, *args)


    def __hash__(self):
        return _BRep.Handle_BRep_PolygonOnTriangulation___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _BRep.Handle_BRep_PolygonOnTriangulation___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _BRep.new_Handle_BRep_PolygonOnTriangulation(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_BRep.Handle_BRep_PolygonOnTriangulation_DownCast)
    __swig_destroy__ = _BRep.delete_Handle_BRep_PolygonOnTriangulation

    def IsPolygonOnTriangulation(self, *args):
        """
        IsPolygonOnTriangulation(Handle_BRep_PolygonOnTriangulation self) -> Standard_Boolean
        IsPolygonOnTriangulation(Handle_BRep_PolygonOnTriangulation self, Handle_Poly_Triangulation T, TopLoc_Location L) -> Standard_Boolean

        Is it a polygon in the definition of <T> with
        location <L>.

        :type T: OCC.wrapper.Poly.Handle_Poly_Triangulation
        :type L: OCC.wrapper.TopLoc.TopLoc_Location
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRep.Handle_BRep_PolygonOnTriangulation_IsPolygonOnTriangulation(self, *args)


    def PolygonOnTriangulation(self, *args):
        """
        :rtype: OCC.wrapper.Poly.Handle_Poly_PolygonOnTriangulation

        """
        res = _BRep.Handle_BRep_PolygonOnTriangulation_PolygonOnTriangulation(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Triangulation(self, *args):
        """
        :rtype: OCC.wrapper.Poly.Handle_Poly_Triangulation

        """
        res = _BRep.Handle_BRep_PolygonOnTriangulation_Triangulation(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Copy(self, *args):
        """
        Copy(Handle_BRep_PolygonOnTriangulation self) -> Handle_BRep_CurveRepresentation

        Return a copy of this representation.

        :rtype: OCC.wrapper.BRep.Handle_BRep_CurveRepresentation

        """
        return _BRep.Handle_BRep_PolygonOnTriangulation_Copy(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_BRep_PolygonOnTriangulation self) -> char const *

        :rtype: const char *

        """
        return _BRep.Handle_BRep_PolygonOnTriangulation_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _BRep.Handle_BRep_PolygonOnTriangulation_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _BRep.Handle_BRep_PolygonOnTriangulation_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def IsCurve3D(self, *args):
        """
        IsCurve3D(Handle_BRep_PolygonOnTriangulation self) -> Standard_Boolean

        A 3D curve representation.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRep.Handle_BRep_PolygonOnTriangulation_IsCurve3D(self, *args)


    def IsCurveOnSurface(self, *args):
        """
        IsCurveOnSurface(Handle_BRep_PolygonOnTriangulation self) -> Standard_Boolean
        IsCurveOnSurface(Handle_BRep_PolygonOnTriangulation self, Handle_Geom_Surface S, TopLoc_Location L) -> Standard_Boolean

        Is it a curve in the parametric space  of <S> with
        location <L>.

        :type S: OCC.wrapper.Geom.Handle_Geom_Surface
        :type L: OCC.wrapper.TopLoc.TopLoc_Location
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRep.Handle_BRep_PolygonOnTriangulation_IsCurveOnSurface(self, *args)


    def IsRegularity(self, *args):
        """
        IsRegularity(Handle_BRep_PolygonOnTriangulation self) -> Standard_Boolean
        IsRegularity(Handle_BRep_PolygonOnTriangulation self, Handle_Geom_Surface S1, Handle_Geom_Surface S2, TopLoc_Location L1, TopLoc_Location L2) -> Standard_Boolean

        Is it  a  regularity between  <S1> and   <S2> with
        location <L1> and <L2>.

        :type S1: OCC.wrapper.Geom.Handle_Geom_Surface
        :type S2: OCC.wrapper.Geom.Handle_Geom_Surface
        :type L1: OCC.wrapper.TopLoc.TopLoc_Location
        :type L2: OCC.wrapper.TopLoc.TopLoc_Location
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRep.Handle_BRep_PolygonOnTriangulation_IsRegularity(self, *args)


    def IsCurveOnClosedSurface(self, *args):
        """
        IsCurveOnClosedSurface(Handle_BRep_PolygonOnTriangulation self) -> Standard_Boolean

        A curve with two parametric   curves  on the  same
        surface.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRep.Handle_BRep_PolygonOnTriangulation_IsCurveOnClosedSurface(self, *args)


    def IsPolygon3D(self, *args):
        """
        IsPolygon3D(Handle_BRep_PolygonOnTriangulation self) -> Standard_Boolean

        A 3D polygon representation.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRep.Handle_BRep_PolygonOnTriangulation_IsPolygon3D(self, *args)


    def IsPolygonOnClosedTriangulation(self, *args):
        """
        IsPolygonOnClosedTriangulation(Handle_BRep_PolygonOnTriangulation self) -> Standard_Boolean

        A representation by two arrays of nodes on a
        triangulation.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRep.Handle_BRep_PolygonOnTriangulation_IsPolygonOnClosedTriangulation(self, *args)


    def IsPolygonOnSurface(self, *args):
        """
        IsPolygonOnSurface(Handle_BRep_PolygonOnTriangulation self) -> Standard_Boolean
        IsPolygonOnSurface(Handle_BRep_PolygonOnTriangulation self, Handle_Geom_Surface S, TopLoc_Location L) -> Standard_Boolean

        Is it a polygon in the parametric space  of <S> with
        location <L>.

        :type S: OCC.wrapper.Geom.Handle_Geom_Surface
        :type L: OCC.wrapper.TopLoc.TopLoc_Location
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRep.Handle_BRep_PolygonOnTriangulation_IsPolygonOnSurface(self, *args)


    def IsPolygonOnClosedSurface(self, *args):
        """
        IsPolygonOnClosedSurface(Handle_BRep_PolygonOnTriangulation self) -> Standard_Boolean

        Two   2D polygon  representations  in the  parametric
        space of a surface.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRep.Handle_BRep_PolygonOnTriangulation_IsPolygonOnClosedSurface(self, *args)


    def Location(self, *args):
        """
        :rtype: OCC.wrapper.TopLoc.TopLoc_Location

        """
        res = _BRep.Handle_BRep_PolygonOnTriangulation_Location(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Curve3D(self, *args):
        """
        :rtype: OCC.wrapper.Geom.Handle_Geom_Curve

        """
        res = _BRep.Handle_BRep_PolygonOnTriangulation_Curve3D(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Surface(self, *args):
        """
        :rtype: OCC.wrapper.Geom.Handle_Geom_Surface

        """
        res = _BRep.Handle_BRep_PolygonOnTriangulation_Surface(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def PCurve(self, *args):
        """
        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Curve

        """
        res = _BRep.Handle_BRep_PolygonOnTriangulation_PCurve(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def PCurve2(self, *args):
        """
        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Curve

        """
        res = _BRep.Handle_BRep_PolygonOnTriangulation_PCurve2(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Polygon3D(self, *args):
        """
        :rtype: OCC.wrapper.Poly.Handle_Poly_Polygon3D

        """
        res = _BRep.Handle_BRep_PolygonOnTriangulation_Polygon3D(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Polygon(self, *args):
        """
        :rtype: OCC.wrapper.Poly.Handle_Poly_Polygon2D

        """
        res = _BRep.Handle_BRep_PolygonOnTriangulation_Polygon(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Polygon2(self, *args):
        """
        :rtype: OCC.wrapper.Poly.Handle_Poly_Polygon2D

        """
        res = _BRep.Handle_BRep_PolygonOnTriangulation_Polygon2(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def PolygonOnTriangulation2(self, *args):
        """
        :rtype: OCC.wrapper.Poly.Handle_Poly_PolygonOnTriangulation

        """
        res = _BRep.Handle_BRep_PolygonOnTriangulation_PolygonOnTriangulation2(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Surface2(self, *args):
        """
        :rtype: OCC.wrapper.Geom.Handle_Geom_Surface

        """
        res = _BRep.Handle_BRep_PolygonOnTriangulation_Surface2(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Location2(self, *args):
        """
        :rtype: OCC.wrapper.TopLoc.TopLoc_Location

        """
        res = _BRep.Handle_BRep_PolygonOnTriangulation_Location2(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Continuity(self, *args):
        """
        :rtype: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        res = _BRep.Handle_BRep_PolygonOnTriangulation_Continuity(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_BRep_PolygonOnTriangulation self)

        Memory deallocator for transient classes


        """
        return _BRep.Handle_BRep_PolygonOnTriangulation_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_BRep_PolygonOnTriangulation self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_BRep_PolygonOnTriangulation self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRep.Handle_BRep_PolygonOnTriangulation_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_BRep_PolygonOnTriangulation self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_BRep_PolygonOnTriangulation self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRep.Handle_BRep_PolygonOnTriangulation_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_BRep_PolygonOnTriangulation self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _BRep.Handle_BRep_PolygonOnTriangulation_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_BRep_PolygonOnTriangulation self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRep.Handle_BRep_PolygonOnTriangulation_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_BRep_PolygonOnTriangulation self)

        Increments the reference counter of this object


        """
        return _BRep.Handle_BRep_PolygonOnTriangulation_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_BRep_PolygonOnTriangulation self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRep.Handle_BRep_PolygonOnTriangulation_DecrementRefCounter(self, *args)

Handle_BRep_PolygonOnTriangulation_swigregister = _BRep.Handle_BRep_PolygonOnTriangulation_swigregister
Handle_BRep_PolygonOnTriangulation_swigregister(Handle_BRep_PolygonOnTriangulation)

def Handle_BRep_PolygonOnTriangulation_DownCast(thing):
    return _BRep.Handle_BRep_PolygonOnTriangulation_DownCast(thing)
Handle_BRep_PolygonOnTriangulation_DownCast = _BRep.Handle_BRep_PolygonOnTriangulation_DownCast

class NCollection_List_Handle_BRep_CurveRepresentation(NCollection.NCollection_BaseList):
    """
    Purpose:      Simple list to link  items together keeping the first 
    and the last one.
    Inherits BaseList, adding the data item to each node.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_List_Handle_BRep_CurveRepresentation self) -> NCollection_List< opencascade::handle< BRep_CurveRepresentation > >::iterator

        Returns an iterator pointing to the first element in the list.

        :rtype: iterator

        """
        return _BRep.NCollection_List_Handle_BRep_CurveRepresentation_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_List_Handle_BRep_CurveRepresentation self) -> NCollection_List< opencascade::handle< BRep_CurveRepresentation > >::iterator

        Returns an iterator referring to the past-the-end element in the list.

        :rtype: iterator

        """
        return _BRep.NCollection_List_Handle_BRep_CurveRepresentation_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_List_Handle_BRep_CurveRepresentation self) -> NCollection_List< opencascade::handle< BRep_CurveRepresentation > >::const_iterator

        Returns a const iterator pointing to the first element in the list.

        :rtype: const_iterator

        """
        return _BRep.NCollection_List_Handle_BRep_CurveRepresentation_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_List_Handle_BRep_CurveRepresentation self) -> NCollection_List< opencascade::handle< BRep_CurveRepresentation > >::const_iterator

        Returns a const iterator referring to the past-the-end element in the list.

        :rtype: const_iterator

        """
        return _BRep.NCollection_List_Handle_BRep_CurveRepresentation_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:      Simple list to link  items together keeping the first 
        and the last one.
        Inherits BaseList, adding the data item to each node.
        """
        this = _BRep.new_NCollection_List_Handle_BRep_CurveRepresentation(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Size(self, *args):
        """
        Size(NCollection_List_Handle_BRep_CurveRepresentation self) -> Standard_Integer

        Size - Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRep.NCollection_List_Handle_BRep_CurveRepresentation_Size(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_List_Handle_BRep_CurveRepresentation self, NCollection_List_Handle_BRep_CurveRepresentation theOther) -> NCollection_List_Handle_BRep_CurveRepresentation

        Replace this list by the items of another list (theOther parameter).
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_List
        :rtype: OCC.wrapper.NCollection.NCollection_List

        """
        return _BRep.NCollection_List_Handle_BRep_CurveRepresentation_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_List_Handle_BRep_CurveRepresentation self, NCollection_List_Handle_BRep_CurveRepresentation theOther) -> NCollection_List_Handle_BRep_CurveRepresentation

        Replacement operator

        :type theOther: OCC.wrapper.NCollection.NCollection_List
        :rtype: OCC.wrapper.NCollection.NCollection_List

        """
        return _BRep.NCollection_List_Handle_BRep_CurveRepresentation_assign(self, *args)


    def Clear(self, *args):
        """
        Clear(NCollection_List_Handle_BRep_CurveRepresentation self, Handle_NCollection_BaseAllocator theAllocator=0)

        Clear this list

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _BRep.NCollection_List_Handle_BRep_CurveRepresentation_Clear(self, *args)


    def First(self, *args):
        """
        First item

        :rtype: const TheItemType &

        """
        res = _BRep.NCollection_List_Handle_BRep_CurveRepresentation_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Last(self, *args):
        """
        Last item

        :rtype: const TheItemType &

        """
        res = _BRep.NCollection_List_Handle_BRep_CurveRepresentation_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Append(self, *args):
        """
        Append(NCollection_List_Handle_BRep_CurveRepresentation self, Handle_BRep_CurveRepresentation theItem) -> Handle_BRep_CurveRepresentation
        Append(NCollection_List_Handle_BRep_CurveRepresentation self, Handle_BRep_CurveRepresentation theItem, NCollection_List< opencascade::handle< BRep_CurveRepresentation > >::Iterator & theIter)
        Append(NCollection_List_Handle_BRep_CurveRepresentation self, NCollection_List_Handle_BRep_CurveRepresentation theOther)

        Append another list at the end

        :type theOther: OCC.wrapper.NCollection.NCollection_List

        """
        return _BRep.NCollection_List_Handle_BRep_CurveRepresentation_Append(self, *args)


    def Prepend(self, *args):
        """
        Prepend(NCollection_List_Handle_BRep_CurveRepresentation self, Handle_BRep_CurveRepresentation theItem) -> Handle_BRep_CurveRepresentation
        Prepend(NCollection_List_Handle_BRep_CurveRepresentation self, NCollection_List_Handle_BRep_CurveRepresentation theOther)

        Prepend another list at the beginning

        :type theOther: OCC.wrapper.NCollection.NCollection_List

        """
        return _BRep.NCollection_List_Handle_BRep_CurveRepresentation_Prepend(self, *args)


    def RemoveFirst(self, *args):
        """
        RemoveFirst(NCollection_List_Handle_BRep_CurveRepresentation self)

        RemoveFirst item


        """
        return _BRep.NCollection_List_Handle_BRep_CurveRepresentation_RemoveFirst(self, *args)


    def Remove(self, *args):
        """
        Remove(NCollection_List_Handle_BRep_CurveRepresentation self, NCollection_List< opencascade::handle< BRep_CurveRepresentation > >::Iterator & theIter)

        Remove item pointed by iterator theIter; 
        theIter is then set to the next item

        :type theIter: Iterator

        """
        return _BRep.NCollection_List_Handle_BRep_CurveRepresentation_Remove(self, *args)


    def InsertBefore(self, *args):
        """
        InsertBefore(NCollection_List_Handle_BRep_CurveRepresentation self, Handle_BRep_CurveRepresentation theItem, NCollection_List< opencascade::handle< BRep_CurveRepresentation > >::Iterator & theIter) -> Handle_BRep_CurveRepresentation
        InsertBefore(NCollection_List_Handle_BRep_CurveRepresentation self, NCollection_List_Handle_BRep_CurveRepresentation theOther, NCollection_List< opencascade::handle< BRep_CurveRepresentation > >::Iterator & theIter)

        InsertBefore

        :type theOther: OCC.wrapper.NCollection.NCollection_List
        :type theIter: Iterator

        """
        return _BRep.NCollection_List_Handle_BRep_CurveRepresentation_InsertBefore(self, *args)


    def InsertAfter(self, *args):
        """
        InsertAfter(NCollection_List_Handle_BRep_CurveRepresentation self, Handle_BRep_CurveRepresentation theItem, NCollection_List< opencascade::handle< BRep_CurveRepresentation > >::Iterator & theIter) -> Handle_BRep_CurveRepresentation
        InsertAfter(NCollection_List_Handle_BRep_CurveRepresentation self, NCollection_List_Handle_BRep_CurveRepresentation theOther, NCollection_List< opencascade::handle< BRep_CurveRepresentation > >::Iterator & theIter)

        InsertAfter

        :type theOther: OCC.wrapper.NCollection.NCollection_List
        :type theIter: Iterator

        """
        return _BRep.NCollection_List_Handle_BRep_CurveRepresentation_InsertAfter(self, *args)


    def Reverse(self, *args):
        """
        Reverse(NCollection_List_Handle_BRep_CurveRepresentation self)

        Reverse the list


        """
        return _BRep.NCollection_List_Handle_BRep_CurveRepresentation_Reverse(self, *args)


    def __iter__(self):
        return _BRep.NCollection_List_Handle_BRep_CurveRepresentation___iter__(self)
    __swig_destroy__ = _BRep.delete_NCollection_List_Handle_BRep_CurveRepresentation
NCollection_List_Handle_BRep_CurveRepresentation_swigregister = _BRep.NCollection_List_Handle_BRep_CurveRepresentation_swigregister
NCollection_List_Handle_BRep_CurveRepresentation_swigregister(NCollection_List_Handle_BRep_CurveRepresentation)

class NCollection_List_Handle_BRep_CurveRepresentation_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _BRep.new_NCollection_List_Handle_BRep_CurveRepresentation_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _BRep.delete_NCollection_List_Handle_BRep_CurveRepresentation_IteratorHelper

    def __next__(self):
        return _BRep.NCollection_List_Handle_BRep_CurveRepresentation_IteratorHelper___next__(self)
NCollection_List_Handle_BRep_CurveRepresentation_IteratorHelper_swigregister = _BRep.NCollection_List_Handle_BRep_CurveRepresentation_IteratorHelper_swigregister
NCollection_List_Handle_BRep_CurveRepresentation_IteratorHelper_swigregister(NCollection_List_Handle_BRep_CurveRepresentation_IteratorHelper)


try:
	BRep_ListOfCurveRepresentation = NCollection_List_Handle_BRep_CurveRepresentation
except NameError:
	pass # does not exist, probably ignored

class NCollection_List_Handle_BRep_PointRepresentation(NCollection.NCollection_BaseList):
    """
    Purpose:      Simple list to link  items together keeping the first 
    and the last one.
    Inherits BaseList, adding the data item to each node.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_List_Handle_BRep_PointRepresentation self) -> NCollection_List< opencascade::handle< BRep_PointRepresentation > >::iterator

        Returns an iterator pointing to the first element in the list.

        :rtype: iterator

        """
        return _BRep.NCollection_List_Handle_BRep_PointRepresentation_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_List_Handle_BRep_PointRepresentation self) -> NCollection_List< opencascade::handle< BRep_PointRepresentation > >::iterator

        Returns an iterator referring to the past-the-end element in the list.

        :rtype: iterator

        """
        return _BRep.NCollection_List_Handle_BRep_PointRepresentation_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_List_Handle_BRep_PointRepresentation self) -> NCollection_List< opencascade::handle< BRep_PointRepresentation > >::const_iterator

        Returns a const iterator pointing to the first element in the list.

        :rtype: const_iterator

        """
        return _BRep.NCollection_List_Handle_BRep_PointRepresentation_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_List_Handle_BRep_PointRepresentation self) -> NCollection_List< opencascade::handle< BRep_PointRepresentation > >::const_iterator

        Returns a const iterator referring to the past-the-end element in the list.

        :rtype: const_iterator

        """
        return _BRep.NCollection_List_Handle_BRep_PointRepresentation_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:      Simple list to link  items together keeping the first 
        and the last one.
        Inherits BaseList, adding the data item to each node.
        """
        this = _BRep.new_NCollection_List_Handle_BRep_PointRepresentation(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Size(self, *args):
        """
        Size(NCollection_List_Handle_BRep_PointRepresentation self) -> Standard_Integer

        Size - Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRep.NCollection_List_Handle_BRep_PointRepresentation_Size(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_List_Handle_BRep_PointRepresentation self, NCollection_List_Handle_BRep_PointRepresentation theOther) -> NCollection_List_Handle_BRep_PointRepresentation

        Replace this list by the items of another list (theOther parameter).
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_List
        :rtype: OCC.wrapper.NCollection.NCollection_List

        """
        return _BRep.NCollection_List_Handle_BRep_PointRepresentation_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_List_Handle_BRep_PointRepresentation self, NCollection_List_Handle_BRep_PointRepresentation theOther) -> NCollection_List_Handle_BRep_PointRepresentation

        Replacement operator

        :type theOther: OCC.wrapper.NCollection.NCollection_List
        :rtype: OCC.wrapper.NCollection.NCollection_List

        """
        return _BRep.NCollection_List_Handle_BRep_PointRepresentation_assign(self, *args)


    def Clear(self, *args):
        """
        Clear(NCollection_List_Handle_BRep_PointRepresentation self, Handle_NCollection_BaseAllocator theAllocator=0)

        Clear this list

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _BRep.NCollection_List_Handle_BRep_PointRepresentation_Clear(self, *args)


    def First(self, *args):
        """
        First item

        :rtype: const TheItemType &

        """
        res = _BRep.NCollection_List_Handle_BRep_PointRepresentation_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Last(self, *args):
        """
        Last item

        :rtype: const TheItemType &

        """
        res = _BRep.NCollection_List_Handle_BRep_PointRepresentation_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Append(self, *args):
        """
        Append(NCollection_List_Handle_BRep_PointRepresentation self, Handle_BRep_PointRepresentation theItem) -> Handle_BRep_PointRepresentation
        Append(NCollection_List_Handle_BRep_PointRepresentation self, Handle_BRep_PointRepresentation theItem, NCollection_List< opencascade::handle< BRep_PointRepresentation > >::Iterator & theIter)
        Append(NCollection_List_Handle_BRep_PointRepresentation self, NCollection_List_Handle_BRep_PointRepresentation theOther)

        Append another list at the end

        :type theOther: OCC.wrapper.NCollection.NCollection_List

        """
        return _BRep.NCollection_List_Handle_BRep_PointRepresentation_Append(self, *args)


    def Prepend(self, *args):
        """
        Prepend(NCollection_List_Handle_BRep_PointRepresentation self, Handle_BRep_PointRepresentation theItem) -> Handle_BRep_PointRepresentation
        Prepend(NCollection_List_Handle_BRep_PointRepresentation self, NCollection_List_Handle_BRep_PointRepresentation theOther)

        Prepend another list at the beginning

        :type theOther: OCC.wrapper.NCollection.NCollection_List

        """
        return _BRep.NCollection_List_Handle_BRep_PointRepresentation_Prepend(self, *args)


    def RemoveFirst(self, *args):
        """
        RemoveFirst(NCollection_List_Handle_BRep_PointRepresentation self)

        RemoveFirst item


        """
        return _BRep.NCollection_List_Handle_BRep_PointRepresentation_RemoveFirst(self, *args)


    def Remove(self, *args):
        """
        Remove(NCollection_List_Handle_BRep_PointRepresentation self, NCollection_List< opencascade::handle< BRep_PointRepresentation > >::Iterator & theIter)

        Remove item pointed by iterator theIter; 
        theIter is then set to the next item

        :type theIter: Iterator

        """
        return _BRep.NCollection_List_Handle_BRep_PointRepresentation_Remove(self, *args)


    def InsertBefore(self, *args):
        """
        InsertBefore(NCollection_List_Handle_BRep_PointRepresentation self, Handle_BRep_PointRepresentation theItem, NCollection_List< opencascade::handle< BRep_PointRepresentation > >::Iterator & theIter) -> Handle_BRep_PointRepresentation
        InsertBefore(NCollection_List_Handle_BRep_PointRepresentation self, NCollection_List_Handle_BRep_PointRepresentation theOther, NCollection_List< opencascade::handle< BRep_PointRepresentation > >::Iterator & theIter)

        InsertBefore

        :type theOther: OCC.wrapper.NCollection.NCollection_List
        :type theIter: Iterator

        """
        return _BRep.NCollection_List_Handle_BRep_PointRepresentation_InsertBefore(self, *args)


    def InsertAfter(self, *args):
        """
        InsertAfter(NCollection_List_Handle_BRep_PointRepresentation self, Handle_BRep_PointRepresentation theItem, NCollection_List< opencascade::handle< BRep_PointRepresentation > >::Iterator & theIter) -> Handle_BRep_PointRepresentation
        InsertAfter(NCollection_List_Handle_BRep_PointRepresentation self, NCollection_List_Handle_BRep_PointRepresentation theOther, NCollection_List< opencascade::handle< BRep_PointRepresentation > >::Iterator & theIter)

        InsertAfter

        :type theOther: OCC.wrapper.NCollection.NCollection_List
        :type theIter: Iterator

        """
        return _BRep.NCollection_List_Handle_BRep_PointRepresentation_InsertAfter(self, *args)


    def Reverse(self, *args):
        """
        Reverse(NCollection_List_Handle_BRep_PointRepresentation self)

        Reverse the list


        """
        return _BRep.NCollection_List_Handle_BRep_PointRepresentation_Reverse(self, *args)


    def __iter__(self):
        return _BRep.NCollection_List_Handle_BRep_PointRepresentation___iter__(self)
    __swig_destroy__ = _BRep.delete_NCollection_List_Handle_BRep_PointRepresentation
NCollection_List_Handle_BRep_PointRepresentation_swigregister = _BRep.NCollection_List_Handle_BRep_PointRepresentation_swigregister
NCollection_List_Handle_BRep_PointRepresentation_swigregister(NCollection_List_Handle_BRep_PointRepresentation)

class NCollection_List_Handle_BRep_PointRepresentation_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _BRep.new_NCollection_List_Handle_BRep_PointRepresentation_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _BRep.delete_NCollection_List_Handle_BRep_PointRepresentation_IteratorHelper

    def __next__(self):
        return _BRep.NCollection_List_Handle_BRep_PointRepresentation_IteratorHelper___next__(self)
NCollection_List_Handle_BRep_PointRepresentation_IteratorHelper_swigregister = _BRep.NCollection_List_Handle_BRep_PointRepresentation_IteratorHelper_swigregister
NCollection_List_Handle_BRep_PointRepresentation_IteratorHelper_swigregister(NCollection_List_Handle_BRep_PointRepresentation_IteratorHelper)


try:
	BRep_ListOfPointRepresentation = NCollection_List_Handle_BRep_PointRepresentation
except NameError:
	pass # does not exist, probably ignored

class Handle_BRep_GCurve(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_BRep_GCurve self)

        Nullify the handle


        """
        return _BRep.Handle_BRep_GCurve_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_BRep_GCurve self) -> bool

        Check for being null

        :rtype: bool

        """
        return _BRep.Handle_BRep_GCurve_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_BRep_GCurve self, BRep_GCurve thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _BRep.Handle_BRep_GCurve_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_BRep_GCurve self, Handle_BRep_GCurve theHandle) -> Handle_BRep_GCurve
        assign(Handle_BRep_GCurve self, BRep_GCurve thePtr) -> Handle_BRep_GCurve
        assign(Handle_BRep_GCurve self, Handle_BRep_GCurve theHandle) -> Handle_BRep_GCurve

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _BRep.Handle_BRep_GCurve_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_BRep_GCurve self) -> BRep_GCurve

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _BRep.Handle_BRep_GCurve_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_BRep_GCurve self) -> BRep_GCurve

        Member access operator (note non-const)

        :rtype: T *

        """
        return _BRep.Handle_BRep_GCurve___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_BRep_GCurve self) -> BRep_GCurve

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _BRep.Handle_BRep_GCurve___ref__(self, *args)


    def __hash__(self):
        return _BRep.Handle_BRep_GCurve___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _BRep.Handle_BRep_GCurve___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _BRep.new_Handle_BRep_GCurve(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_BRep.Handle_BRep_GCurve_DownCast)
    __swig_destroy__ = _BRep.delete_Handle_BRep_GCurve

    def SetRange(self, *args):
        """
        SetRange(Handle_BRep_GCurve self, Standard_Real const First, Standard_Real const Last)

        :type First: float
        :type Last: float

        """
        return _BRep.Handle_BRep_GCurve_SetRange(self, *args)


    def Range(self, *args):
        """
        Range(Handle_BRep_GCurve self)

        :type First: float
        :type Last: float

        """
        return _BRep.Handle_BRep_GCurve_Range(self, *args)


    def First(self, *args):
        """
        First(Handle_BRep_GCurve self) -> Standard_Real
        First(Handle_BRep_GCurve self, Standard_Real const F)

        :type F: float

        """
        return _BRep.Handle_BRep_GCurve_First(self, *args)


    def Last(self, *args):
        """
        Last(Handle_BRep_GCurve self) -> Standard_Real
        Last(Handle_BRep_GCurve self, Standard_Real const L)

        :type L: float

        """
        return _BRep.Handle_BRep_GCurve_Last(self, *args)


    def D0(self, *args):
        """
        D0(Handle_BRep_GCurve self, Standard_Real const U, gp_Pnt P)

        Computes the point at parameter U.

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt

        """
        return _BRep.Handle_BRep_GCurve_D0(self, *args)


    def Update(self, *args):
        """
        Update(Handle_BRep_GCurve self)

        Recomputes any derived data after a modification.
        This is called when the range is modified.


        """
        return _BRep.Handle_BRep_GCurve_Update(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_BRep_GCurve self) -> char const *

        :rtype: const char *

        """
        return _BRep.Handle_BRep_GCurve_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _BRep.Handle_BRep_GCurve_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _BRep.Handle_BRep_GCurve_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def IsCurve3D(self, *args):
        """
        IsCurve3D(Handle_BRep_GCurve self) -> Standard_Boolean

        A 3D curve representation.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRep.Handle_BRep_GCurve_IsCurve3D(self, *args)


    def IsCurveOnSurface(self, *args):
        """
        IsCurveOnSurface(Handle_BRep_GCurve self) -> Standard_Boolean
        IsCurveOnSurface(Handle_BRep_GCurve self, Handle_Geom_Surface S, TopLoc_Location L) -> Standard_Boolean

        Is it a curve in the parametric space  of <S> with
        location <L>.

        :type S: OCC.wrapper.Geom.Handle_Geom_Surface
        :type L: OCC.wrapper.TopLoc.TopLoc_Location
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRep.Handle_BRep_GCurve_IsCurveOnSurface(self, *args)


    def IsRegularity(self, *args):
        """
        IsRegularity(Handle_BRep_GCurve self) -> Standard_Boolean
        IsRegularity(Handle_BRep_GCurve self, Handle_Geom_Surface S1, Handle_Geom_Surface S2, TopLoc_Location L1, TopLoc_Location L2) -> Standard_Boolean

        Is it  a  regularity between  <S1> and   <S2> with
        location <L1> and <L2>.

        :type S1: OCC.wrapper.Geom.Handle_Geom_Surface
        :type S2: OCC.wrapper.Geom.Handle_Geom_Surface
        :type L1: OCC.wrapper.TopLoc.TopLoc_Location
        :type L2: OCC.wrapper.TopLoc.TopLoc_Location
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRep.Handle_BRep_GCurve_IsRegularity(self, *args)


    def IsCurveOnClosedSurface(self, *args):
        """
        IsCurveOnClosedSurface(Handle_BRep_GCurve self) -> Standard_Boolean

        A curve with two parametric   curves  on the  same
        surface.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRep.Handle_BRep_GCurve_IsCurveOnClosedSurface(self, *args)


    def IsPolygon3D(self, *args):
        """
        IsPolygon3D(Handle_BRep_GCurve self) -> Standard_Boolean

        A 3D polygon representation.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRep.Handle_BRep_GCurve_IsPolygon3D(self, *args)


    def IsPolygonOnTriangulation(self, *args):
        """
        IsPolygonOnTriangulation(Handle_BRep_GCurve self) -> Standard_Boolean
        IsPolygonOnTriangulation(Handle_BRep_GCurve self, Handle_Poly_Triangulation T, TopLoc_Location L) -> Standard_Boolean

        Is it a polygon in the definition of <T> with
        location <L>.

        :type T: OCC.wrapper.Poly.Handle_Poly_Triangulation
        :type L: OCC.wrapper.TopLoc.TopLoc_Location
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRep.Handle_BRep_GCurve_IsPolygonOnTriangulation(self, *args)


    def IsPolygonOnClosedTriangulation(self, *args):
        """
        IsPolygonOnClosedTriangulation(Handle_BRep_GCurve self) -> Standard_Boolean

        A representation by two arrays of nodes on a
        triangulation.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRep.Handle_BRep_GCurve_IsPolygonOnClosedTriangulation(self, *args)


    def IsPolygonOnSurface(self, *args):
        """
        IsPolygonOnSurface(Handle_BRep_GCurve self) -> Standard_Boolean
        IsPolygonOnSurface(Handle_BRep_GCurve self, Handle_Geom_Surface S, TopLoc_Location L) -> Standard_Boolean

        Is it a polygon in the parametric space  of <S> with
        location <L>.

        :type S: OCC.wrapper.Geom.Handle_Geom_Surface
        :type L: OCC.wrapper.TopLoc.TopLoc_Location
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRep.Handle_BRep_GCurve_IsPolygonOnSurface(self, *args)


    def IsPolygonOnClosedSurface(self, *args):
        """
        IsPolygonOnClosedSurface(Handle_BRep_GCurve self) -> Standard_Boolean

        Two   2D polygon  representations  in the  parametric
        space of a surface.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRep.Handle_BRep_GCurve_IsPolygonOnClosedSurface(self, *args)


    def Location(self, *args):
        """
        :rtype: OCC.wrapper.TopLoc.TopLoc_Location

        """
        res = _BRep.Handle_BRep_GCurve_Location(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Curve3D(self, *args):
        """
        :rtype: OCC.wrapper.Geom.Handle_Geom_Curve

        """
        res = _BRep.Handle_BRep_GCurve_Curve3D(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Surface(self, *args):
        """
        :rtype: OCC.wrapper.Geom.Handle_Geom_Surface

        """
        res = _BRep.Handle_BRep_GCurve_Surface(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def PCurve(self, *args):
        """
        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Curve

        """
        res = _BRep.Handle_BRep_GCurve_PCurve(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def PCurve2(self, *args):
        """
        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Curve

        """
        res = _BRep.Handle_BRep_GCurve_PCurve2(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Polygon3D(self, *args):
        """
        :rtype: OCC.wrapper.Poly.Handle_Poly_Polygon3D

        """
        res = _BRep.Handle_BRep_GCurve_Polygon3D(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Polygon(self, *args):
        """
        :rtype: OCC.wrapper.Poly.Handle_Poly_Polygon2D

        """
        res = _BRep.Handle_BRep_GCurve_Polygon(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Polygon2(self, *args):
        """
        :rtype: OCC.wrapper.Poly.Handle_Poly_Polygon2D

        """
        res = _BRep.Handle_BRep_GCurve_Polygon2(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Triangulation(self, *args):
        """
        :rtype: OCC.wrapper.Poly.Handle_Poly_Triangulation

        """
        res = _BRep.Handle_BRep_GCurve_Triangulation(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def PolygonOnTriangulation(self, *args):
        """
        :rtype: OCC.wrapper.Poly.Handle_Poly_PolygonOnTriangulation

        """
        res = _BRep.Handle_BRep_GCurve_PolygonOnTriangulation(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def PolygonOnTriangulation2(self, *args):
        """
        :rtype: OCC.wrapper.Poly.Handle_Poly_PolygonOnTriangulation

        """
        res = _BRep.Handle_BRep_GCurve_PolygonOnTriangulation2(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Surface2(self, *args):
        """
        :rtype: OCC.wrapper.Geom.Handle_Geom_Surface

        """
        res = _BRep.Handle_BRep_GCurve_Surface2(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Location2(self, *args):
        """
        :rtype: OCC.wrapper.TopLoc.TopLoc_Location

        """
        res = _BRep.Handle_BRep_GCurve_Location2(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Continuity(self, *args):
        """
        :rtype: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        res = _BRep.Handle_BRep_GCurve_Continuity(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Copy(self, *args):
        """
        Copy(Handle_BRep_GCurve self) -> Handle_BRep_CurveRepresentation

        Return a copy of this representation.

        :rtype: OCC.wrapper.BRep.Handle_BRep_CurveRepresentation

        """
        return _BRep.Handle_BRep_GCurve_Copy(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_BRep_GCurve self)

        Memory deallocator for transient classes


        """
        return _BRep.Handle_BRep_GCurve_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_BRep_GCurve self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_BRep_GCurve self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRep.Handle_BRep_GCurve_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_BRep_GCurve self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_BRep_GCurve self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRep.Handle_BRep_GCurve_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_BRep_GCurve self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _BRep.Handle_BRep_GCurve_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_BRep_GCurve self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRep.Handle_BRep_GCurve_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_BRep_GCurve self)

        Increments the reference counter of this object


        """
        return _BRep.Handle_BRep_GCurve_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_BRep_GCurve self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRep.Handle_BRep_GCurve_DecrementRefCounter(self, *args)

Handle_BRep_GCurve_swigregister = _BRep.Handle_BRep_GCurve_swigregister
Handle_BRep_GCurve_swigregister(Handle_BRep_GCurve)

def Handle_BRep_GCurve_DownCast(thing):
    return _BRep.Handle_BRep_GCurve_DownCast(thing)
Handle_BRep_GCurve_DownCast = _BRep.Handle_BRep_GCurve_DownCast

class BRep_Tool(object):
    """
    Provides class methods  to  access to the geometry
    of BRep shapes.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Surface(*args):
        """
        Surface(TopoDS_Face F, TopLoc_Location L) -> Handle_Geom_Surface
        Surface(TopoDS_Face F) -> Handle_Geom_Surface

        Returns the geometric  surface of the face. It can
        be a copy if there is a Location.

        :type F: OCC.wrapper.TopoDS.TopoDS_Face
        :rtype: OCC.wrapper.Geom.Handle_Geom_Surface

        """
        return _BRep.BRep_Tool_Surface(*args)

    Surface = staticmethod(Surface)

    def Triangulation(*args):
        """
        Triangulation(TopoDS_Face F, TopLoc_Location L) -> Handle_Poly_Triangulation

        Returns  the Triangulation of  the  face. It  is a
        null handle if there is no triangulation.

        :type F: OCC.wrapper.TopoDS.TopoDS_Face
        :type L: OCC.wrapper.TopLoc.TopLoc_Location
        :rtype: OCC.wrapper.Poly.Handle_Poly_Triangulation

        """
        return _BRep.BRep_Tool_Triangulation(*args)

    Triangulation = staticmethod(Triangulation)

    def NaturalRestriction(*args):
        """
        NaturalRestriction(TopoDS_Face F) -> Standard_Boolean

        Returns the  NaturalRestriction  flag of the  face.

        :type F: OCC.wrapper.TopoDS.TopoDS_Face
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRep.BRep_Tool_NaturalRestriction(*args)

    NaturalRestriction = staticmethod(NaturalRestriction)

    def IsGeometric(*args):
        """
        IsGeometric(TopoDS_Edge E) -> Standard_Boolean

        Returns True if <E> is a 3d curve or a curve on
        surface.

        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRep.BRep_Tool_IsGeometric(*args)

    IsGeometric = staticmethod(IsGeometric)

    def Curve(*args):
        """
        Curve(TopoDS_Edge E, TopLoc_Location L) -> Handle_Geom_Curve
        Curve(TopoDS_Edge E) -> Handle_Geom_Curve

        Returns the 3D curve  of the edge. May be a Null handle.
        In <First> and <Last> the parameter range.
        It can be a copy if there is a Location.

        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :type First: float
        :type Last: float
        :rtype: OCC.wrapper.Geom.Handle_Geom_Curve

        """
        return _BRep.BRep_Tool_Curve(*args)

    Curve = staticmethod(Curve)

    def Polygon3D(*args):
        """
        Polygon3D(TopoDS_Edge E, TopLoc_Location L) -> Handle_Poly_Polygon3D

        Returns the 3D polygon of the edge. May be   a Null
        handle. Returns in <L> the location for the polygon.

        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :type L: OCC.wrapper.TopLoc.TopLoc_Location
        :rtype: OCC.wrapper.Poly.Handle_Poly_Polygon3D

        """
        return _BRep.BRep_Tool_Polygon3D(*args)

    Polygon3D = staticmethod(Polygon3D)

    def CurveOnPlane(*args):
        """
        CurveOnPlane(TopoDS_Edge E, Handle_Geom_Surface S, TopLoc_Location L) -> Handle_Geom2d_Curve

        For the planar surface builds the 2d curve for the edge
        by projection of the edge on plane.
        Returns a NULL handle if the surface is not planar or
        the projection failed.

        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :type S: OCC.wrapper.Geom.Handle_Geom_Surface
        :type L: OCC.wrapper.TopLoc.TopLoc_Location
        :type First: float
        :type Last: float
        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Curve

        """
        return _BRep.BRep_Tool_CurveOnPlane(*args)

    CurveOnPlane = staticmethod(CurveOnPlane)

    def CurveOnSurface(*args):
        """
        CurveOnSurface(TopoDS_Edge E, TopoDS_Face F, Standard_Boolean * theIsStored=None) -> Handle_Geom2d_Curve
        CurveOnSurface(TopoDS_Edge E, Handle_Geom_Surface S, TopLoc_Location L, Standard_Boolean * theIsStored=None) -> Handle_Geom2d_Curve
        CurveOnSurface(TopoDS_Edge E, Handle_Geom2d_Curve C, Handle_Geom_Surface S, TopLoc_Location L)
        CurveOnSurface(TopoDS_Edge E, Handle_Geom2d_Curve C, Handle_Geom_Surface S, TopLoc_Location L, Standard_Integer const Index)

        Returns in <C>, <S>, <L> the 2d curve, the surface
        and the location for the edge <E> of rank <Index>.
        <C> and <S> are null if the index is out of range.
        Returns in <First> and <Last> the parameter range.

        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :type C: OCC.wrapper.Geom2d.Handle_Geom2d_Curve
        :type S: OCC.wrapper.Geom.Handle_Geom_Surface
        :type L: OCC.wrapper.TopLoc.TopLoc_Location
        :type First: float
        :type Last: float
        :type Index: int

        """
        return _BRep.BRep_Tool_CurveOnSurface(*args)

    CurveOnSurface = staticmethod(CurveOnSurface)

    def PolygonOnSurface(*args):
        """
        PolygonOnSurface(TopoDS_Edge E, TopoDS_Face F) -> Handle_Poly_Polygon2D
        PolygonOnSurface(TopoDS_Edge E, Handle_Geom_Surface S, TopLoc_Location L) -> Handle_Poly_Polygon2D
        PolygonOnSurface(TopoDS_Edge E, Handle_Poly_Polygon2D C, Handle_Geom_Surface S, TopLoc_Location L)
        PolygonOnSurface(TopoDS_Edge E, Handle_Poly_Polygon2D C, Handle_Geom_Surface S, TopLoc_Location L, Standard_Integer const Index)

        Returns in <C>, <S>, <L> the 2d curve, the surface
        and the location for the edge <E> of rank <Index>.
        <C> and <S> are null if the index is out of range.

        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :type C: OCC.wrapper.Poly.Handle_Poly_Polygon2D
        :type S: OCC.wrapper.Geom.Handle_Geom_Surface
        :type L: OCC.wrapper.TopLoc.TopLoc_Location
        :type Index: int

        """
        return _BRep.BRep_Tool_PolygonOnSurface(*args)

    PolygonOnSurface = staticmethod(PolygonOnSurface)

    def PolygonOnTriangulation(*args):
        """
        PolygonOnTriangulation(TopoDS_Edge E, Handle_Poly_Triangulation T, TopLoc_Location L) -> Handle_Poly_PolygonOnTriangulation
        PolygonOnTriangulation(TopoDS_Edge E, Handle_Poly_PolygonOnTriangulation P, Handle_Poly_Triangulation T, TopLoc_Location L)
        PolygonOnTriangulation(TopoDS_Edge E, Handle_Poly_PolygonOnTriangulation P, Handle_Poly_Triangulation T, TopLoc_Location L, Standard_Integer const Index)

        Returns   in   <P>,  <T>,    <L> a     polygon  on
        triangulation,   a triangulation  and a  location for
        the edge <E> for the range index.  <C> and <S> are
        null if the edge has no polygon on triangulation.

        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :type P: OCC.wrapper.Poly.Handle_Poly_PolygonOnTriangulation
        :type T: OCC.wrapper.Poly.Handle_Poly_Triangulation
        :type L: OCC.wrapper.TopLoc.TopLoc_Location
        :type Index: int

        """
        return _BRep.BRep_Tool_PolygonOnTriangulation(*args)

    PolygonOnTriangulation = staticmethod(PolygonOnTriangulation)

    def IsClosed(*args):
        """
        IsClosed(TopoDS_Shape S) -> Standard_Boolean
        IsClosed(TopoDS_Edge E, TopoDS_Face F) -> Standard_Boolean
        IsClosed(TopoDS_Edge E, Handle_Geom_Surface S, TopLoc_Location L) -> Standard_Boolean
        IsClosed(TopoDS_Edge E, Handle_Poly_Triangulation T, TopLoc_Location L) -> Standard_Boolean

        Returns  True  if <E> has two arrays of indices in
        the triangulation <T>.

        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :type T: OCC.wrapper.Poly.Handle_Poly_Triangulation
        :type L: OCC.wrapper.TopLoc.TopLoc_Location
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRep.BRep_Tool_IsClosed(*args)

    IsClosed = staticmethod(IsClosed)

    def SameParameter(*args):
        """
        SameParameter(TopoDS_Edge E) -> Standard_Boolean

        Returns the SameParameter flag for the edge.

        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRep.BRep_Tool_SameParameter(*args)

    SameParameter = staticmethod(SameParameter)

    def SameRange(*args):
        """
        SameRange(TopoDS_Edge E) -> Standard_Boolean

        Returns the SameRange flag for the edge.

        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRep.BRep_Tool_SameRange(*args)

    SameRange = staticmethod(SameRange)

    def Degenerated(*args):
        """
        Degenerated(TopoDS_Edge E) -> Standard_Boolean

        Returns True  if the edge is degenerated.

        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRep.BRep_Tool_Degenerated(*args)

    Degenerated = staticmethod(Degenerated)

    def Range(*args):
        """
        Range(TopoDS_Edge E)
        Range(TopoDS_Edge E, Handle_Geom_Surface S, TopLoc_Location L)
        Range(TopoDS_Edge E, TopoDS_Face F)

        Gets the range of the edge on the pcurve on the face.

        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :type F: OCC.wrapper.TopoDS.TopoDS_Face
        :type First: float
        :type Last: float

        """
        return _BRep.BRep_Tool_Range(*args)

    Range = staticmethod(Range)

    def UVPoints(*args):
        """
        UVPoints(TopoDS_Edge E, Handle_Geom_Surface S, TopLoc_Location L, gp_Pnt2d PFirst, gp_Pnt2d PLast)
        UVPoints(TopoDS_Edge E, TopoDS_Face F, gp_Pnt2d PFirst, gp_Pnt2d PLast)

        Gets the UV locations of the extremities of the edge.

        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :type F: OCC.wrapper.TopoDS.TopoDS_Face
        :type PFirst: OCC.wrapper.gp.gp_Pnt2d
        :type PLast: OCC.wrapper.gp.gp_Pnt2d

        """
        return _BRep.BRep_Tool_UVPoints(*args)

    UVPoints = staticmethod(UVPoints)

    def SetUVPoints(*args):
        """
        SetUVPoints(TopoDS_Edge E, Handle_Geom_Surface S, TopLoc_Location L, gp_Pnt2d PFirst, gp_Pnt2d PLast)
        SetUVPoints(TopoDS_Edge E, TopoDS_Face F, gp_Pnt2d PFirst, gp_Pnt2d PLast)

        Sets the UV locations of the extremities of the edge.

        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :type F: OCC.wrapper.TopoDS.TopoDS_Face
        :type PFirst: OCC.wrapper.gp.gp_Pnt2d
        :type PLast: OCC.wrapper.gp.gp_Pnt2d

        """
        return _BRep.BRep_Tool_SetUVPoints(*args)

    SetUVPoints = staticmethod(SetUVPoints)

    def Continuity(*args):
        """
        Continuity(TopoDS_Edge E, TopoDS_Face F1, TopoDS_Face F2) -> GeomAbs_Shape
        Continuity(TopoDS_Edge E, Handle_Geom_Surface S1, Handle_Geom_Surface S2, TopLoc_Location L1, TopLoc_Location L2) -> GeomAbs_Shape

        Returns the continuity.

        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :type S1: OCC.wrapper.Geom.Handle_Geom_Surface
        :type S2: OCC.wrapper.Geom.Handle_Geom_Surface
        :type L1: OCC.wrapper.TopLoc.TopLoc_Location
        :type L2: OCC.wrapper.TopLoc.TopLoc_Location
        :rtype: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _BRep.BRep_Tool_Continuity(*args)

    Continuity = staticmethod(Continuity)

    def HasContinuity(*args):
        """
        HasContinuity(TopoDS_Edge E, TopoDS_Face F1, TopoDS_Face F2) -> Standard_Boolean
        HasContinuity(TopoDS_Edge E, Handle_Geom_Surface S1, Handle_Geom_Surface S2, TopLoc_Location L1, TopLoc_Location L2) -> Standard_Boolean
        HasContinuity(TopoDS_Edge E) -> Standard_Boolean

        Returns True if the edge has regularity on some
        two surfaces

        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRep.BRep_Tool_HasContinuity(*args)

    HasContinuity = staticmethod(HasContinuity)

    def Pnt(*args):
        """
        Pnt(TopoDS_Vertex V) -> gp_Pnt

        Returns the 3d point.

        :type V: OCC.wrapper.TopoDS.TopoDS_Vertex
        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _BRep.BRep_Tool_Pnt(*args)

    Pnt = staticmethod(Pnt)

    def Tolerance(*args):
        """
        Tolerance(TopoDS_Face F) -> Standard_Real
        Tolerance(TopoDS_Edge E) -> Standard_Real
        Tolerance(TopoDS_Vertex V) -> Standard_Real

        Returns the tolerance.

        :type V: OCC.wrapper.TopoDS.TopoDS_Vertex
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _BRep.BRep_Tool_Tolerance(*args)

    Tolerance = staticmethod(Tolerance)

    def Parameter(*args):
        """
        Parameter(TopoDS_Vertex V, TopoDS_Edge E) -> Standard_Real
        Parameter(TopoDS_Vertex V, TopoDS_Edge E, TopoDS_Face F) -> Standard_Real
        Parameter(TopoDS_Vertex V, TopoDS_Edge E, Handle_Geom_Surface S, TopLoc_Location L) -> Standard_Real

        Returns the  parameters  of   the  vertex   on the
        pcurve of the edge on the surface.

        :type V: OCC.wrapper.TopoDS.TopoDS_Vertex
        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :type S: OCC.wrapper.Geom.Handle_Geom_Surface
        :type L: OCC.wrapper.TopLoc.TopLoc_Location
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _BRep.BRep_Tool_Parameter(*args)

    Parameter = staticmethod(Parameter)

    def Parameters(*args):
        """
        Parameters(TopoDS_Vertex V, TopoDS_Face F) -> gp_Pnt2d

        Returns the parameters of the vertex on the face.

        :type V: OCC.wrapper.TopoDS.TopoDS_Vertex
        :type F: OCC.wrapper.TopoDS.TopoDS_Face
        :rtype: OCC.wrapper.gp.gp_Pnt2d

        """
        return _BRep.BRep_Tool_Parameters(*args)

    Parameters = staticmethod(Parameters)

    def MaxTolerance(*args):
        """
        MaxTolerance(TopoDS_Shape theShape, TopAbs_ShapeEnum const theSubShape) -> Standard_Real

        :type theShape: OCC.wrapper.TopoDS.TopoDS_Shape
        :type theSubShape: OCC.wrapper.TopAbs.TopAbs_ShapeEnum
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _BRep.BRep_Tool_MaxTolerance(*args)

    MaxTolerance = staticmethod(MaxTolerance)

    def __init__(self):
        """
        Provides class methods  to  access to the geometry
        of BRep shapes.
        """
        this = _BRep.new_BRep_Tool()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _BRep.delete_BRep_Tool
BRep_Tool_swigregister = _BRep.BRep_Tool_swigregister
BRep_Tool_swigregister(BRep_Tool)

def BRep_Tool_Surface(*args):
    """
    Surface(TopoDS_Face F, TopLoc_Location L) -> Handle_Geom_Surface
    BRep_Tool_Surface(TopoDS_Face F) -> Handle_Geom_Surface

    Returns the geometric  surface of the face. It can
    be a copy if there is a Location.

    :type F: OCC.wrapper.TopoDS.TopoDS_Face
    :rtype: OCC.wrapper.Geom.Handle_Geom_Surface

    """
    return _BRep.BRep_Tool_Surface(*args)

def BRep_Tool_Triangulation(*args):
    """
    BRep_Tool_Triangulation(TopoDS_Face F, TopLoc_Location L) -> Handle_Poly_Triangulation

    Returns  the Triangulation of  the  face. It  is a
    null handle if there is no triangulation.

    :type F: OCC.wrapper.TopoDS.TopoDS_Face
    :type L: OCC.wrapper.TopLoc.TopLoc_Location
    :rtype: OCC.wrapper.Poly.Handle_Poly_Triangulation

    """
    return _BRep.BRep_Tool_Triangulation(*args)

def BRep_Tool_NaturalRestriction(*args):
    """
    BRep_Tool_NaturalRestriction(TopoDS_Face F) -> Standard_Boolean

    Returns the  NaturalRestriction  flag of the  face.

    :type F: OCC.wrapper.TopoDS.TopoDS_Face
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _BRep.BRep_Tool_NaturalRestriction(*args)

def BRep_Tool_IsGeometric(*args):
    """
    BRep_Tool_IsGeometric(TopoDS_Edge E) -> Standard_Boolean

    Returns True if <E> is a 3d curve or a curve on
    surface.

    :type E: OCC.wrapper.TopoDS.TopoDS_Edge
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _BRep.BRep_Tool_IsGeometric(*args)

def BRep_Tool_Curve(*args):
    """
    Curve(TopoDS_Edge E, TopLoc_Location L) -> Handle_Geom_Curve
    BRep_Tool_Curve(TopoDS_Edge E) -> Handle_Geom_Curve

    Returns the 3D curve  of the edge. May be a Null handle.
    In <First> and <Last> the parameter range.
    It can be a copy if there is a Location.

    :type E: OCC.wrapper.TopoDS.TopoDS_Edge
    :type First: float
    :type Last: float
    :rtype: OCC.wrapper.Geom.Handle_Geom_Curve

    """
    return _BRep.BRep_Tool_Curve(*args)

def BRep_Tool_Polygon3D(*args):
    """
    BRep_Tool_Polygon3D(TopoDS_Edge E, TopLoc_Location L) -> Handle_Poly_Polygon3D

    Returns the 3D polygon of the edge. May be   a Null
    handle. Returns in <L> the location for the polygon.

    :type E: OCC.wrapper.TopoDS.TopoDS_Edge
    :type L: OCC.wrapper.TopLoc.TopLoc_Location
    :rtype: OCC.wrapper.Poly.Handle_Poly_Polygon3D

    """
    return _BRep.BRep_Tool_Polygon3D(*args)

def BRep_Tool_CurveOnPlane(*args):
    """
    BRep_Tool_CurveOnPlane(TopoDS_Edge E, Handle_Geom_Surface S, TopLoc_Location L) -> Handle_Geom2d_Curve

    For the planar surface builds the 2d curve for the edge
    by projection of the edge on plane.
    Returns a NULL handle if the surface is not planar or
    the projection failed.

    :type E: OCC.wrapper.TopoDS.TopoDS_Edge
    :type S: OCC.wrapper.Geom.Handle_Geom_Surface
    :type L: OCC.wrapper.TopLoc.TopLoc_Location
    :type First: float
    :type Last: float
    :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Curve

    """
    return _BRep.BRep_Tool_CurveOnPlane(*args)

def BRep_Tool_CurveOnSurface(*args):
    """
    CurveOnSurface(TopoDS_Edge E, TopoDS_Face F, Standard_Boolean * theIsStored=None) -> Handle_Geom2d_Curve
    CurveOnSurface(TopoDS_Edge E, Handle_Geom_Surface S, TopLoc_Location L, Standard_Boolean * theIsStored=None) -> Handle_Geom2d_Curve
    CurveOnSurface(TopoDS_Edge E, Handle_Geom2d_Curve C, Handle_Geom_Surface S, TopLoc_Location L)
    BRep_Tool_CurveOnSurface(TopoDS_Edge E, Handle_Geom2d_Curve C, Handle_Geom_Surface S, TopLoc_Location L, Standard_Integer const Index)

    Returns in <C>, <S>, <L> the 2d curve, the surface
    and the location for the edge <E> of rank <Index>.
    <C> and <S> are null if the index is out of range.
    Returns in <First> and <Last> the parameter range.

    :type E: OCC.wrapper.TopoDS.TopoDS_Edge
    :type C: OCC.wrapper.Geom2d.Handle_Geom2d_Curve
    :type S: OCC.wrapper.Geom.Handle_Geom_Surface
    :type L: OCC.wrapper.TopLoc.TopLoc_Location
    :type First: float
    :type Last: float
    :type Index: int

    """
    return _BRep.BRep_Tool_CurveOnSurface(*args)

def BRep_Tool_PolygonOnSurface(*args):
    """
    PolygonOnSurface(TopoDS_Edge E, TopoDS_Face F) -> Handle_Poly_Polygon2D
    PolygonOnSurface(TopoDS_Edge E, Handle_Geom_Surface S, TopLoc_Location L) -> Handle_Poly_Polygon2D
    PolygonOnSurface(TopoDS_Edge E, Handle_Poly_Polygon2D C, Handle_Geom_Surface S, TopLoc_Location L)
    BRep_Tool_PolygonOnSurface(TopoDS_Edge E, Handle_Poly_Polygon2D C, Handle_Geom_Surface S, TopLoc_Location L, Standard_Integer const Index)

    Returns in <C>, <S>, <L> the 2d curve, the surface
    and the location for the edge <E> of rank <Index>.
    <C> and <S> are null if the index is out of range.

    :type E: OCC.wrapper.TopoDS.TopoDS_Edge
    :type C: OCC.wrapper.Poly.Handle_Poly_Polygon2D
    :type S: OCC.wrapper.Geom.Handle_Geom_Surface
    :type L: OCC.wrapper.TopLoc.TopLoc_Location
    :type Index: int

    """
    return _BRep.BRep_Tool_PolygonOnSurface(*args)

def BRep_Tool_PolygonOnTriangulation(*args):
    """
    PolygonOnTriangulation(TopoDS_Edge E, Handle_Poly_Triangulation T, TopLoc_Location L) -> Handle_Poly_PolygonOnTriangulation
    PolygonOnTriangulation(TopoDS_Edge E, Handle_Poly_PolygonOnTriangulation P, Handle_Poly_Triangulation T, TopLoc_Location L)
    BRep_Tool_PolygonOnTriangulation(TopoDS_Edge E, Handle_Poly_PolygonOnTriangulation P, Handle_Poly_Triangulation T, TopLoc_Location L, Standard_Integer const Index)

    Returns   in   <P>,  <T>,    <L> a     polygon  on
    triangulation,   a triangulation  and a  location for
    the edge <E> for the range index.  <C> and <S> are
    null if the edge has no polygon on triangulation.

    :type E: OCC.wrapper.TopoDS.TopoDS_Edge
    :type P: OCC.wrapper.Poly.Handle_Poly_PolygonOnTriangulation
    :type T: OCC.wrapper.Poly.Handle_Poly_Triangulation
    :type L: OCC.wrapper.TopLoc.TopLoc_Location
    :type Index: int

    """
    return _BRep.BRep_Tool_PolygonOnTriangulation(*args)

def BRep_Tool_IsClosed(*args):
    """
    IsClosed(TopoDS_Shape S) -> Standard_Boolean
    IsClosed(TopoDS_Edge E, TopoDS_Face F) -> Standard_Boolean
    IsClosed(TopoDS_Edge E, Handle_Geom_Surface S, TopLoc_Location L) -> Standard_Boolean
    BRep_Tool_IsClosed(TopoDS_Edge E, Handle_Poly_Triangulation T, TopLoc_Location L) -> Standard_Boolean

    Returns  True  if <E> has two arrays of indices in
    the triangulation <T>.

    :type E: OCC.wrapper.TopoDS.TopoDS_Edge
    :type T: OCC.wrapper.Poly.Handle_Poly_Triangulation
    :type L: OCC.wrapper.TopLoc.TopLoc_Location
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _BRep.BRep_Tool_IsClosed(*args)

def BRep_Tool_SameParameter(*args):
    """
    BRep_Tool_SameParameter(TopoDS_Edge E) -> Standard_Boolean

    Returns the SameParameter flag for the edge.

    :type E: OCC.wrapper.TopoDS.TopoDS_Edge
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _BRep.BRep_Tool_SameParameter(*args)

def BRep_Tool_SameRange(*args):
    """
    BRep_Tool_SameRange(TopoDS_Edge E) -> Standard_Boolean

    Returns the SameRange flag for the edge.

    :type E: OCC.wrapper.TopoDS.TopoDS_Edge
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _BRep.BRep_Tool_SameRange(*args)

def BRep_Tool_Degenerated(*args):
    """
    BRep_Tool_Degenerated(TopoDS_Edge E) -> Standard_Boolean

    Returns True  if the edge is degenerated.

    :type E: OCC.wrapper.TopoDS.TopoDS_Edge
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _BRep.BRep_Tool_Degenerated(*args)

def BRep_Tool_Range(*args):
    """
    Range(TopoDS_Edge E)
    Range(TopoDS_Edge E, Handle_Geom_Surface S, TopLoc_Location L)
    BRep_Tool_Range(TopoDS_Edge E, TopoDS_Face F)

    Gets the range of the edge on the pcurve on the face.

    :type E: OCC.wrapper.TopoDS.TopoDS_Edge
    :type F: OCC.wrapper.TopoDS.TopoDS_Face
    :type First: float
    :type Last: float

    """
    return _BRep.BRep_Tool_Range(*args)

def BRep_Tool_UVPoints(*args):
    """
    UVPoints(TopoDS_Edge E, Handle_Geom_Surface S, TopLoc_Location L, gp_Pnt2d PFirst, gp_Pnt2d PLast)
    BRep_Tool_UVPoints(TopoDS_Edge E, TopoDS_Face F, gp_Pnt2d PFirst, gp_Pnt2d PLast)

    Gets the UV locations of the extremities of the edge.

    :type E: OCC.wrapper.TopoDS.TopoDS_Edge
    :type F: OCC.wrapper.TopoDS.TopoDS_Face
    :type PFirst: OCC.wrapper.gp.gp_Pnt2d
    :type PLast: OCC.wrapper.gp.gp_Pnt2d

    """
    return _BRep.BRep_Tool_UVPoints(*args)

def BRep_Tool_SetUVPoints(*args):
    """
    SetUVPoints(TopoDS_Edge E, Handle_Geom_Surface S, TopLoc_Location L, gp_Pnt2d PFirst, gp_Pnt2d PLast)
    BRep_Tool_SetUVPoints(TopoDS_Edge E, TopoDS_Face F, gp_Pnt2d PFirst, gp_Pnt2d PLast)

    Sets the UV locations of the extremities of the edge.

    :type E: OCC.wrapper.TopoDS.TopoDS_Edge
    :type F: OCC.wrapper.TopoDS.TopoDS_Face
    :type PFirst: OCC.wrapper.gp.gp_Pnt2d
    :type PLast: OCC.wrapper.gp.gp_Pnt2d

    """
    return _BRep.BRep_Tool_SetUVPoints(*args)

def BRep_Tool_Continuity(*args):
    """
    Continuity(TopoDS_Edge E, TopoDS_Face F1, TopoDS_Face F2) -> GeomAbs_Shape
    BRep_Tool_Continuity(TopoDS_Edge E, Handle_Geom_Surface S1, Handle_Geom_Surface S2, TopLoc_Location L1, TopLoc_Location L2) -> GeomAbs_Shape

    Returns the continuity.

    :type E: OCC.wrapper.TopoDS.TopoDS_Edge
    :type S1: OCC.wrapper.Geom.Handle_Geom_Surface
    :type S2: OCC.wrapper.Geom.Handle_Geom_Surface
    :type L1: OCC.wrapper.TopLoc.TopLoc_Location
    :type L2: OCC.wrapper.TopLoc.TopLoc_Location
    :rtype: OCC.wrapper.GeomAbs.GeomAbs_Shape

    """
    return _BRep.BRep_Tool_Continuity(*args)

def BRep_Tool_HasContinuity(*args):
    """
    HasContinuity(TopoDS_Edge E, TopoDS_Face F1, TopoDS_Face F2) -> Standard_Boolean
    HasContinuity(TopoDS_Edge E, Handle_Geom_Surface S1, Handle_Geom_Surface S2, TopLoc_Location L1, TopLoc_Location L2) -> Standard_Boolean
    BRep_Tool_HasContinuity(TopoDS_Edge E) -> Standard_Boolean

    Returns True if the edge has regularity on some
    two surfaces

    :type E: OCC.wrapper.TopoDS.TopoDS_Edge
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _BRep.BRep_Tool_HasContinuity(*args)

def BRep_Tool_Pnt(*args):
    """
    BRep_Tool_Pnt(TopoDS_Vertex V) -> gp_Pnt

    Returns the 3d point.

    :type V: OCC.wrapper.TopoDS.TopoDS_Vertex
    :rtype: OCC.wrapper.gp.gp_Pnt

    """
    return _BRep.BRep_Tool_Pnt(*args)

def BRep_Tool_Tolerance(*args):
    """
    Tolerance(TopoDS_Face F) -> Standard_Real
    Tolerance(TopoDS_Edge E) -> Standard_Real
    BRep_Tool_Tolerance(TopoDS_Vertex V) -> Standard_Real

    Returns the tolerance.

    :type V: OCC.wrapper.TopoDS.TopoDS_Vertex
    :rtype: OCC.wrapper.Standard.Standard_Real

    """
    return _BRep.BRep_Tool_Tolerance(*args)

def BRep_Tool_Parameter(*args):
    """
    Parameter(TopoDS_Vertex V, TopoDS_Edge E) -> Standard_Real
    Parameter(TopoDS_Vertex V, TopoDS_Edge E, TopoDS_Face F) -> Standard_Real
    BRep_Tool_Parameter(TopoDS_Vertex V, TopoDS_Edge E, Handle_Geom_Surface S, TopLoc_Location L) -> Standard_Real

    Returns the  parameters  of   the  vertex   on the
    pcurve of the edge on the surface.

    :type V: OCC.wrapper.TopoDS.TopoDS_Vertex
    :type E: OCC.wrapper.TopoDS.TopoDS_Edge
    :type S: OCC.wrapper.Geom.Handle_Geom_Surface
    :type L: OCC.wrapper.TopLoc.TopLoc_Location
    :rtype: OCC.wrapper.Standard.Standard_Real

    """
    return _BRep.BRep_Tool_Parameter(*args)

def BRep_Tool_Parameters(*args):
    """
    BRep_Tool_Parameters(TopoDS_Vertex V, TopoDS_Face F) -> gp_Pnt2d

    Returns the parameters of the vertex on the face.

    :type V: OCC.wrapper.TopoDS.TopoDS_Vertex
    :type F: OCC.wrapper.TopoDS.TopoDS_Face
    :rtype: OCC.wrapper.gp.gp_Pnt2d

    """
    return _BRep.BRep_Tool_Parameters(*args)

def BRep_Tool_MaxTolerance(*args):
    """
    BRep_Tool_MaxTolerance(TopoDS_Shape theShape, TopAbs_ShapeEnum const theSubShape) -> Standard_Real

    :type theShape: OCC.wrapper.TopoDS.TopoDS_Shape
    :type theSubShape: OCC.wrapper.TopAbs.TopAbs_ShapeEnum
    :rtype: OCC.wrapper.Standard.Standard_Real

    """
    return _BRep.BRep_Tool_MaxTolerance(*args)

class BRep_PointOnCurveOnSurface(BRep_PointsOnSurface):
    """
    Representation by   a parameter on  a curve   on a
    surface.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_BRep_PointOnCurveOnSurface
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_BRep_PointOnCurveOnSurface(self) 
            return h


    def __init__(self, *args):
        """
        __init__(BRep_PointOnCurveOnSurface self, Standard_Real const P, Handle_Geom2d_Curve C, Handle_Geom_Surface S, TopLoc_Location L) -> BRep_PointOnCurveOnSurface

        :type P: float
        :type C: OCC.wrapper.Geom2d.Handle_Geom2d_Curve
        :type S: OCC.wrapper.Geom.Handle_Geom_Surface
        :type L: OCC.wrapper.TopLoc.TopLoc_Location

        """
        this = _BRep.new_BRep_PointOnCurveOnSurface(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def IsPointOnCurveOnSurface(self, *args):
        """
        IsPointOnCurveOnSurface(BRep_PointOnCurveOnSurface self) -> Standard_Boolean
        IsPointOnCurveOnSurface(BRep_PointOnCurveOnSurface self, Handle_Geom2d_Curve PC, Handle_Geom_Surface S, TopLoc_Location L) -> Standard_Boolean

        :type PC: OCC.wrapper.Geom2d.Handle_Geom2d_Curve
        :type S: OCC.wrapper.Geom.Handle_Geom_Surface
        :type L: OCC.wrapper.TopLoc.TopLoc_Location
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRep.BRep_PointOnCurveOnSurface_IsPointOnCurveOnSurface(self, *args)


    def PCurve(self, *args):
        """
        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Curve

        """
        res = _BRep.BRep_PointOnCurveOnSurface_PCurve(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _BRep.BRep_PointOnCurveOnSurface_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _BRep.BRep_PointOnCurveOnSurface_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _BRep.BRep_PointOnCurveOnSurface_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _BRep.delete_BRep_PointOnCurveOnSurface
BRep_PointOnCurveOnSurface_swigregister = _BRep.BRep_PointOnCurveOnSurface_swigregister
BRep_PointOnCurveOnSurface_swigregister(BRep_PointOnCurveOnSurface)

def BRep_PointOnCurveOnSurface_get_type_name(*args):
    """
    BRep_PointOnCurveOnSurface_get_type_name() -> char const *

    :rtype: const char *

    """
    return _BRep.BRep_PointOnCurveOnSurface_get_type_name(*args)

def BRep_PointOnCurveOnSurface_get_type_descriptor(*args):
    """
    BRep_PointOnCurveOnSurface_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _BRep.BRep_PointOnCurveOnSurface_get_type_descriptor(*args)

class Handle_BRep_PointOnCurveOnSurface(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_BRep_PointOnCurveOnSurface self)

        Nullify the handle


        """
        return _BRep.Handle_BRep_PointOnCurveOnSurface_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_BRep_PointOnCurveOnSurface self) -> bool

        Check for being null

        :rtype: bool

        """
        return _BRep.Handle_BRep_PointOnCurveOnSurface_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_BRep_PointOnCurveOnSurface self, BRep_PointOnCurveOnSurface thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _BRep.Handle_BRep_PointOnCurveOnSurface_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_BRep_PointOnCurveOnSurface self, Handle_BRep_PointOnCurveOnSurface theHandle) -> Handle_BRep_PointOnCurveOnSurface
        assign(Handle_BRep_PointOnCurveOnSurface self, BRep_PointOnCurveOnSurface thePtr) -> Handle_BRep_PointOnCurveOnSurface
        assign(Handle_BRep_PointOnCurveOnSurface self, Handle_BRep_PointOnCurveOnSurface theHandle) -> Handle_BRep_PointOnCurveOnSurface

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _BRep.Handle_BRep_PointOnCurveOnSurface_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_BRep_PointOnCurveOnSurface self) -> BRep_PointOnCurveOnSurface

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _BRep.Handle_BRep_PointOnCurveOnSurface_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_BRep_PointOnCurveOnSurface self) -> BRep_PointOnCurveOnSurface

        Member access operator (note non-const)

        :rtype: T *

        """
        return _BRep.Handle_BRep_PointOnCurveOnSurface___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_BRep_PointOnCurveOnSurface self) -> BRep_PointOnCurveOnSurface

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _BRep.Handle_BRep_PointOnCurveOnSurface___ref__(self, *args)


    def __hash__(self):
        return _BRep.Handle_BRep_PointOnCurveOnSurface___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _BRep.Handle_BRep_PointOnCurveOnSurface___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _BRep.new_Handle_BRep_PointOnCurveOnSurface(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_BRep.Handle_BRep_PointOnCurveOnSurface_DownCast)
    __swig_destroy__ = _BRep.delete_Handle_BRep_PointOnCurveOnSurface

    def IsPointOnCurveOnSurface(self, *args):
        """
        IsPointOnCurveOnSurface(Handle_BRep_PointOnCurveOnSurface self) -> Standard_Boolean
        IsPointOnCurveOnSurface(Handle_BRep_PointOnCurveOnSurface self, Handle_Geom2d_Curve PC, Handle_Geom_Surface S, TopLoc_Location L) -> Standard_Boolean

        :type PC: OCC.wrapper.Geom2d.Handle_Geom2d_Curve
        :type S: OCC.wrapper.Geom.Handle_Geom_Surface
        :type L: OCC.wrapper.TopLoc.TopLoc_Location
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRep.Handle_BRep_PointOnCurveOnSurface_IsPointOnCurveOnSurface(self, *args)


    def PCurve(self, *args):
        """
        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Curve

        """
        res = _BRep.Handle_BRep_PointOnCurveOnSurface_PCurve(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def get_type_name(self, *args):
        """
        get_type_name(Handle_BRep_PointOnCurveOnSurface self) -> char const *

        :rtype: const char *

        """
        return _BRep.Handle_BRep_PointOnCurveOnSurface_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _BRep.Handle_BRep_PointOnCurveOnSurface_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _BRep.Handle_BRep_PointOnCurveOnSurface_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Surface(self, *args):
        """
        :rtype: OCC.wrapper.Geom.Handle_Geom_Surface

        """
        res = _BRep.Handle_BRep_PointOnCurveOnSurface_Surface(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def IsPointOnCurve(self, *args):
        """
        IsPointOnCurve(Handle_BRep_PointOnCurveOnSurface self) -> Standard_Boolean
        IsPointOnCurve(Handle_BRep_PointOnCurveOnSurface self, Handle_Geom_Curve C, TopLoc_Location L) -> Standard_Boolean

        A point on the curve <C>.

        :type C: OCC.wrapper.Geom.Handle_Geom_Curve
        :type L: OCC.wrapper.TopLoc.TopLoc_Location
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRep.Handle_BRep_PointOnCurveOnSurface_IsPointOnCurve(self, *args)


    def IsPointOnSurface(self, *args):
        """
        IsPointOnSurface(Handle_BRep_PointOnCurveOnSurface self) -> Standard_Boolean
        IsPointOnSurface(Handle_BRep_PointOnCurveOnSurface self, Handle_Geom_Surface S, TopLoc_Location L) -> Standard_Boolean

        A point on the surface <S>.

        :type S: OCC.wrapper.Geom.Handle_Geom_Surface
        :type L: OCC.wrapper.TopLoc.TopLoc_Location
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRep.Handle_BRep_PointOnCurveOnSurface_IsPointOnSurface(self, *args)


    def Location(self, *args):
        """
        :rtype: OCC.wrapper.TopLoc.TopLoc_Location

        """
        res = _BRep.Handle_BRep_PointOnCurveOnSurface_Location(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Parameter(self, *args):
        """
        Parameter(Handle_BRep_PointOnCurveOnSurface self) -> Standard_Real
        Parameter(Handle_BRep_PointOnCurveOnSurface self, Standard_Real const P)

        :type P: float

        """
        return _BRep.Handle_BRep_PointOnCurveOnSurface_Parameter(self, *args)


    def Parameter2(self, *args):
        """
        Parameter2(Handle_BRep_PointOnCurveOnSurface self) -> Standard_Real
        Parameter2(Handle_BRep_PointOnCurveOnSurface self, Standard_Real const P)

        :type P: float

        """
        return _BRep.Handle_BRep_PointOnCurveOnSurface_Parameter2(self, *args)


    def Curve(self, *args):
        """
        :rtype: OCC.wrapper.Geom.Handle_Geom_Curve

        """
        res = _BRep.Handle_BRep_PointOnCurveOnSurface_Curve(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_BRep_PointOnCurveOnSurface self)

        Memory deallocator for transient classes


        """
        return _BRep.Handle_BRep_PointOnCurveOnSurface_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_BRep_PointOnCurveOnSurface self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_BRep_PointOnCurveOnSurface self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRep.Handle_BRep_PointOnCurveOnSurface_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_BRep_PointOnCurveOnSurface self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_BRep_PointOnCurveOnSurface self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRep.Handle_BRep_PointOnCurveOnSurface_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_BRep_PointOnCurveOnSurface self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _BRep.Handle_BRep_PointOnCurveOnSurface_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_BRep_PointOnCurveOnSurface self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRep.Handle_BRep_PointOnCurveOnSurface_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_BRep_PointOnCurveOnSurface self)

        Increments the reference counter of this object


        """
        return _BRep.Handle_BRep_PointOnCurveOnSurface_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_BRep_PointOnCurveOnSurface self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRep.Handle_BRep_PointOnCurveOnSurface_DecrementRefCounter(self, *args)

Handle_BRep_PointOnCurveOnSurface_swigregister = _BRep.Handle_BRep_PointOnCurveOnSurface_swigregister
Handle_BRep_PointOnCurveOnSurface_swigregister(Handle_BRep_PointOnCurveOnSurface)

def Handle_BRep_PointOnCurveOnSurface_DownCast(thing):
    return _BRep.Handle_BRep_PointOnCurveOnSurface_DownCast(thing)
Handle_BRep_PointOnCurveOnSurface_DownCast = _BRep.Handle_BRep_PointOnCurveOnSurface_DownCast

class BRep_Builder(TopoDS.TopoDS_Builder):
    """
    A framework providing advanced tolerance control.
    It is used to build Shapes.
    If tolerance control is required, you are advised to:
    1. build a default precision for topology, using the
    classes provided in the BRepAPI package
    2. update the tolerance of the resulting shape.
    Note that only vertices, edges and faces have
    meaningful tolerance control. The tolerance value
    must always comply with the condition that face
    tolerances are more restrictive than edge tolerances
    which are more restrictive than vertex tolerances. In
    other words: Tol(Vertex) >= Tol(Edge) >= Tol(Face).
    Other rules in setting tolerance include:
    - you can open up tolerance but should never restrict it
    - an edge cannot be included within the fusion of the
    tolerance spheres of two vertices
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def MakeFace(self, *args):
        """
        MakeFace(BRep_Builder self, TopoDS_Face F)
        MakeFace(BRep_Builder self, TopoDS_Face F, Handle_Geom_Surface S, Standard_Real const Tol)
        MakeFace(BRep_Builder self, TopoDS_Face F, Handle_Geom_Surface S, TopLoc_Location L, Standard_Real const Tol)
        MakeFace(BRep_Builder self, TopoDS_Face F, Handle_Poly_Triangulation T)

        Makes a Face with a triangulation. The triangulation
        is in the same reference system than the TFace.

        :type F: OCC.wrapper.TopoDS.TopoDS_Face
        :type T: OCC.wrapper.Poly.Handle_Poly_Triangulation

        """
        return _BRep.BRep_Builder_MakeFace(self, *args)


    def UpdateFace(self, *args):
        """
        UpdateFace(BRep_Builder self, TopoDS_Face F, Handle_Geom_Surface S, TopLoc_Location L, Standard_Real const Tol)
        UpdateFace(BRep_Builder self, TopoDS_Face F, Handle_Poly_Triangulation T)
        UpdateFace(BRep_Builder self, TopoDS_Face F, Standard_Real const Tol)

        Updates the face Tolerance.

        :type F: OCC.wrapper.TopoDS.TopoDS_Face
        :type Tol: float

        """
        return _BRep.BRep_Builder_UpdateFace(self, *args)


    def NaturalRestriction(self, *args):
        """
        NaturalRestriction(BRep_Builder self, TopoDS_Face F, Standard_Boolean const N)

        Sets the  NaturalRestriction flag of  the face.

        :type F: OCC.wrapper.TopoDS.TopoDS_Face
        :type N: bool

        """
        return _BRep.BRep_Builder_NaturalRestriction(self, *args)


    def MakeEdge(self, *args):
        """
        MakeEdge(BRep_Builder self, TopoDS_Edge E)
        MakeEdge(BRep_Builder self, TopoDS_Edge E, Handle_Geom_Curve C, Standard_Real const Tol)
        MakeEdge(BRep_Builder self, TopoDS_Edge E, Handle_Geom_Curve C, TopLoc_Location L, Standard_Real const Tol)
        MakeEdge(BRep_Builder self, TopoDS_Edge E, Handle_Poly_Polygon3D P)
        MakeEdge(BRep_Builder self, TopoDS_Edge E, Handle_Poly_PolygonOnTriangulation N, Handle_Poly_Triangulation T)
        MakeEdge(BRep_Builder self, TopoDS_Edge E, Handle_Poly_PolygonOnTriangulation N, Handle_Poly_Triangulation T, TopLoc_Location L)

        makes an Edge polygon on Triangulation.

        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :type N: OCC.wrapper.Poly.Handle_Poly_PolygonOnTriangulation
        :type T: OCC.wrapper.Poly.Handle_Poly_Triangulation
        :type L: OCC.wrapper.TopLoc.TopLoc_Location

        """
        return _BRep.BRep_Builder_MakeEdge(self, *args)


    def UpdateEdge(self, *args):
        """
        UpdateEdge(BRep_Builder self, TopoDS_Edge E, Handle_Geom_Curve C, Standard_Real const Tol)
        UpdateEdge(BRep_Builder self, TopoDS_Edge E, Handle_Geom_Curve C, TopLoc_Location L, Standard_Real const Tol)
        UpdateEdge(BRep_Builder self, TopoDS_Edge E, Handle_Geom2d_Curve C, TopoDS_Face F, Standard_Real const Tol)
        UpdateEdge(BRep_Builder self, TopoDS_Edge E, Handle_Geom2d_Curve C1, Handle_Geom2d_Curve C2, TopoDS_Face F, Standard_Real const Tol)
        UpdateEdge(BRep_Builder self, TopoDS_Edge E, Handle_Geom2d_Curve C, Handle_Geom_Surface S, TopLoc_Location L, Standard_Real const Tol)
        UpdateEdge(BRep_Builder self, TopoDS_Edge E, Handle_Geom2d_Curve C, Handle_Geom_Surface S, TopLoc_Location L, Standard_Real const Tol, gp_Pnt2d Pf, gp_Pnt2d Pl)
        UpdateEdge(BRep_Builder self, TopoDS_Edge E, Handle_Geom2d_Curve C1, Handle_Geom2d_Curve C2, Handle_Geom_Surface S, TopLoc_Location L, Standard_Real const Tol)
        UpdateEdge(BRep_Builder self, TopoDS_Edge E, Handle_Geom2d_Curve C1, Handle_Geom2d_Curve C2, Handle_Geom_Surface S, TopLoc_Location L, Standard_Real const Tol, gp_Pnt2d Pf, gp_Pnt2d Pl)
        UpdateEdge(BRep_Builder self, TopoDS_Edge E, Handle_Poly_Polygon3D P)
        UpdateEdge(BRep_Builder self, TopoDS_Edge E, Handle_Poly_Polygon3D P, TopLoc_Location L)
        UpdateEdge(BRep_Builder self, TopoDS_Edge E, Handle_Poly_PolygonOnTriangulation N, Handle_Poly_Triangulation T)
        UpdateEdge(BRep_Builder self, TopoDS_Edge E, Handle_Poly_PolygonOnTriangulation N, Handle_Poly_Triangulation T, TopLoc_Location L)
        UpdateEdge(BRep_Builder self, TopoDS_Edge E, Handle_Poly_PolygonOnTriangulation N1, Handle_Poly_PolygonOnTriangulation N2, Handle_Poly_Triangulation T)
        UpdateEdge(BRep_Builder self, TopoDS_Edge E, Handle_Poly_PolygonOnTriangulation N1, Handle_Poly_PolygonOnTriangulation N2, Handle_Poly_Triangulation T, TopLoc_Location L)
        UpdateEdge(BRep_Builder self, TopoDS_Edge E, Handle_Poly_Polygon2D P, TopoDS_Face S)
        UpdateEdge(BRep_Builder self, TopoDS_Edge E, Handle_Poly_Polygon2D P, Handle_Geom_Surface S, TopLoc_Location T)
        UpdateEdge(BRep_Builder self, TopoDS_Edge E, Handle_Poly_Polygon2D P1, Handle_Poly_Polygon2D P2, TopoDS_Face S)
        UpdateEdge(BRep_Builder self, TopoDS_Edge E, Handle_Poly_Polygon2D P1, Handle_Poly_Polygon2D P2, Handle_Geom_Surface S, TopLoc_Location L)
        UpdateEdge(BRep_Builder self, TopoDS_Edge E, Standard_Real const Tol)

        Updates the edge tolerance.

        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :type Tol: float

        """
        return _BRep.BRep_Builder_UpdateEdge(self, *args)


    def Continuity(self, *args):
        """
        Continuity(BRep_Builder self, TopoDS_Edge E, TopoDS_Face F1, TopoDS_Face F2, GeomAbs_Shape const C)
        Continuity(BRep_Builder self, TopoDS_Edge E, Handle_Geom_Surface S1, Handle_Geom_Surface S2, TopLoc_Location L1, TopLoc_Location L2, GeomAbs_Shape const C)

        Sets the geometric continuity on the edge.

        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :type S1: OCC.wrapper.Geom.Handle_Geom_Surface
        :type S2: OCC.wrapper.Geom.Handle_Geom_Surface
        :type L1: OCC.wrapper.TopLoc.TopLoc_Location
        :type L2: OCC.wrapper.TopLoc.TopLoc_Location
        :type C: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _BRep.BRep_Builder_Continuity(self, *args)


    def SameParameter(self, *args):
        """
        SameParameter(BRep_Builder self, TopoDS_Edge E, Standard_Boolean const S)

        Sets the same parameter flag for the edge <E>.

        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :type S: bool

        """
        return _BRep.BRep_Builder_SameParameter(self, *args)


    def SameRange(self, *args):
        """
        SameRange(BRep_Builder self, TopoDS_Edge E, Standard_Boolean const S)

        Sets the same range flag for the edge <E>.

        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :type S: bool

        """
        return _BRep.BRep_Builder_SameRange(self, *args)


    def Degenerated(self, *args):
        """
        Degenerated(BRep_Builder self, TopoDS_Edge E, Standard_Boolean const D)

        Sets the degenerated flag for the edge <E>.

        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :type D: bool

        """
        return _BRep.BRep_Builder_Degenerated(self, *args)


    def Range(self, *args):
        """
        Range(BRep_Builder self, TopoDS_Edge E, Standard_Real const First, Standard_Real const Last, Standard_Boolean const Only3d)
        Range(BRep_Builder self, TopoDS_Edge E, Handle_Geom_Surface S, TopLoc_Location L, Standard_Real const First, Standard_Real const Last)
        Range(BRep_Builder self, TopoDS_Edge E, TopoDS_Face F, Standard_Real const First, Standard_Real const Last)

        Sets the range of the edge on the pcurve on the face.

        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :type F: OCC.wrapper.TopoDS.TopoDS_Face
        :type First: float
        :type Last: float

        """
        return _BRep.BRep_Builder_Range(self, *args)


    def MakeVertex(self, *args):
        """
        MakeVertex(BRep_Builder self, TopoDS_Vertex V)
        MakeVertex(BRep_Builder self, TopoDS_Vertex V, gp_Pnt P, Standard_Real const Tol)

        Makes a vertex from a 3D point.

        :type V: OCC.wrapper.TopoDS.TopoDS_Vertex
        :type P: OCC.wrapper.gp.gp_Pnt
        :type Tol: float

        """
        return _BRep.BRep_Builder_MakeVertex(self, *args)


    def UpdateVertex(self, *args):
        """
        UpdateVertex(BRep_Builder self, TopoDS_Vertex V, gp_Pnt P, Standard_Real const Tol)
        UpdateVertex(BRep_Builder self, TopoDS_Vertex V, Standard_Real const P, TopoDS_Edge E, Standard_Real const Tol)
        UpdateVertex(BRep_Builder self, TopoDS_Vertex V, Standard_Real const P, TopoDS_Edge E, TopoDS_Face F, Standard_Real const Tol)
        UpdateVertex(BRep_Builder self, TopoDS_Vertex V, Standard_Real const P, TopoDS_Edge E, Handle_Geom_Surface S, TopLoc_Location L, Standard_Real const Tol)
        UpdateVertex(BRep_Builder self, TopoDS_Vertex Ve, Standard_Real const U, Standard_Real const V, TopoDS_Face F, Standard_Real const Tol)
        UpdateVertex(BRep_Builder self, TopoDS_Vertex V, Standard_Real const Tol)

        Updates the vertex tolerance.

        :type V: OCC.wrapper.TopoDS.TopoDS_Vertex
        :type Tol: float

        """
        return _BRep.BRep_Builder_UpdateVertex(self, *args)


    def Transfert(self, *args):
        """
        Transfert(BRep_Builder self, TopoDS_Edge Ein, TopoDS_Edge Eout)
        Transfert(BRep_Builder self, TopoDS_Edge Ein, TopoDS_Edge Eout, TopoDS_Vertex Vin, TopoDS_Vertex Vout)

        Transfert the parameters  of   Vin on  Ein as  the
        parameter of Vout on Eout.

        :type Ein: OCC.wrapper.TopoDS.TopoDS_Edge
        :type Eout: OCC.wrapper.TopoDS.TopoDS_Edge
        :type Vin: OCC.wrapper.TopoDS.TopoDS_Vertex
        :type Vout: OCC.wrapper.TopoDS.TopoDS_Vertex

        """
        return _BRep.BRep_Builder_Transfert(self, *args)


    def __init__(self):
        """
        A framework providing advanced tolerance control.
        It is used to build Shapes.
        If tolerance control is required, you are advised to:
        1. build a default precision for topology, using the
        classes provided in the BRepAPI package
        2. update the tolerance of the resulting shape.
        Note that only vertices, edges and faces have
        meaningful tolerance control. The tolerance value
        must always comply with the condition that face
        tolerances are more restrictive than edge tolerances
        which are more restrictive than vertex tolerances. In
        other words: Tol(Vertex) >= Tol(Edge) >= Tol(Face).
        Other rules in setting tolerance include:
        - you can open up tolerance but should never restrict it
        - an edge cannot be included within the fusion of the
        tolerance spheres of two vertices
        """
        this = _BRep.new_BRep_Builder()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _BRep.delete_BRep_Builder
BRep_Builder_swigregister = _BRep.BRep_Builder_swigregister
BRep_Builder_swigregister(BRep_Builder)

class Handle_BRep_CurveRepresentation(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_BRep_CurveRepresentation self)

        Nullify the handle


        """
        return _BRep.Handle_BRep_CurveRepresentation_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_BRep_CurveRepresentation self) -> bool

        Check for being null

        :rtype: bool

        """
        return _BRep.Handle_BRep_CurveRepresentation_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_BRep_CurveRepresentation self, BRep_CurveRepresentation thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _BRep.Handle_BRep_CurveRepresentation_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_BRep_CurveRepresentation self, Handle_BRep_CurveRepresentation theHandle) -> Handle_BRep_CurveRepresentation
        assign(Handle_BRep_CurveRepresentation self, BRep_CurveRepresentation thePtr) -> Handle_BRep_CurveRepresentation
        assign(Handle_BRep_CurveRepresentation self, Handle_BRep_CurveRepresentation theHandle) -> Handle_BRep_CurveRepresentation

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _BRep.Handle_BRep_CurveRepresentation_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_BRep_CurveRepresentation self) -> BRep_CurveRepresentation

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _BRep.Handle_BRep_CurveRepresentation_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_BRep_CurveRepresentation self) -> BRep_CurveRepresentation

        Member access operator (note non-const)

        :rtype: T *

        """
        return _BRep.Handle_BRep_CurveRepresentation___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_BRep_CurveRepresentation self) -> BRep_CurveRepresentation

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _BRep.Handle_BRep_CurveRepresentation___ref__(self, *args)


    def __hash__(self):
        return _BRep.Handle_BRep_CurveRepresentation___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _BRep.Handle_BRep_CurveRepresentation___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _BRep.new_Handle_BRep_CurveRepresentation(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_BRep.Handle_BRep_CurveRepresentation_DownCast)
    __swig_destroy__ = _BRep.delete_Handle_BRep_CurveRepresentation

    def IsCurve3D(self, *args):
        """
        IsCurve3D(Handle_BRep_CurveRepresentation self) -> Standard_Boolean

        A 3D curve representation.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRep.Handle_BRep_CurveRepresentation_IsCurve3D(self, *args)


    def IsCurveOnSurface(self, *args):
        """
        IsCurveOnSurface(Handle_BRep_CurveRepresentation self) -> Standard_Boolean
        IsCurveOnSurface(Handle_BRep_CurveRepresentation self, Handle_Geom_Surface S, TopLoc_Location L) -> Standard_Boolean

        Is it a curve in the parametric space  of <S> with
        location <L>.

        :type S: OCC.wrapper.Geom.Handle_Geom_Surface
        :type L: OCC.wrapper.TopLoc.TopLoc_Location
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRep.Handle_BRep_CurveRepresentation_IsCurveOnSurface(self, *args)


    def IsRegularity(self, *args):
        """
        IsRegularity(Handle_BRep_CurveRepresentation self) -> Standard_Boolean
        IsRegularity(Handle_BRep_CurveRepresentation self, Handle_Geom_Surface S1, Handle_Geom_Surface S2, TopLoc_Location L1, TopLoc_Location L2) -> Standard_Boolean

        Is it  a  regularity between  <S1> and   <S2> with
        location <L1> and <L2>.

        :type S1: OCC.wrapper.Geom.Handle_Geom_Surface
        :type S2: OCC.wrapper.Geom.Handle_Geom_Surface
        :type L1: OCC.wrapper.TopLoc.TopLoc_Location
        :type L2: OCC.wrapper.TopLoc.TopLoc_Location
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRep.Handle_BRep_CurveRepresentation_IsRegularity(self, *args)


    def IsCurveOnClosedSurface(self, *args):
        """
        IsCurveOnClosedSurface(Handle_BRep_CurveRepresentation self) -> Standard_Boolean

        A curve with two parametric   curves  on the  same
        surface.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRep.Handle_BRep_CurveRepresentation_IsCurveOnClosedSurface(self, *args)


    def IsPolygon3D(self, *args):
        """
        IsPolygon3D(Handle_BRep_CurveRepresentation self) -> Standard_Boolean

        A 3D polygon representation.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRep.Handle_BRep_CurveRepresentation_IsPolygon3D(self, *args)


    def IsPolygonOnTriangulation(self, *args):
        """
        IsPolygonOnTriangulation(Handle_BRep_CurveRepresentation self) -> Standard_Boolean
        IsPolygonOnTriangulation(Handle_BRep_CurveRepresentation self, Handle_Poly_Triangulation T, TopLoc_Location L) -> Standard_Boolean

        Is it a polygon in the definition of <T> with
        location <L>.

        :type T: OCC.wrapper.Poly.Handle_Poly_Triangulation
        :type L: OCC.wrapper.TopLoc.TopLoc_Location
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRep.Handle_BRep_CurveRepresentation_IsPolygonOnTriangulation(self, *args)


    def IsPolygonOnClosedTriangulation(self, *args):
        """
        IsPolygonOnClosedTriangulation(Handle_BRep_CurveRepresentation self) -> Standard_Boolean

        A representation by two arrays of nodes on a
        triangulation.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRep.Handle_BRep_CurveRepresentation_IsPolygonOnClosedTriangulation(self, *args)


    def IsPolygonOnSurface(self, *args):
        """
        IsPolygonOnSurface(Handle_BRep_CurveRepresentation self) -> Standard_Boolean
        IsPolygonOnSurface(Handle_BRep_CurveRepresentation self, Handle_Geom_Surface S, TopLoc_Location L) -> Standard_Boolean

        Is it a polygon in the parametric space  of <S> with
        location <L>.

        :type S: OCC.wrapper.Geom.Handle_Geom_Surface
        :type L: OCC.wrapper.TopLoc.TopLoc_Location
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRep.Handle_BRep_CurveRepresentation_IsPolygonOnSurface(self, *args)


    def IsPolygonOnClosedSurface(self, *args):
        """
        IsPolygonOnClosedSurface(Handle_BRep_CurveRepresentation self) -> Standard_Boolean

        Two   2D polygon  representations  in the  parametric
        space of a surface.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRep.Handle_BRep_CurveRepresentation_IsPolygonOnClosedSurface(self, *args)


    def Location(self, *args):
        """
        :rtype: OCC.wrapper.TopLoc.TopLoc_Location

        """
        res = _BRep.Handle_BRep_CurveRepresentation_Location(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Curve3D(self, *args):
        """
        :rtype: OCC.wrapper.Geom.Handle_Geom_Curve

        """
        res = _BRep.Handle_BRep_CurveRepresentation_Curve3D(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Surface(self, *args):
        """
        :rtype: OCC.wrapper.Geom.Handle_Geom_Surface

        """
        res = _BRep.Handle_BRep_CurveRepresentation_Surface(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def PCurve(self, *args):
        """
        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Curve

        """
        res = _BRep.Handle_BRep_CurveRepresentation_PCurve(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def PCurve2(self, *args):
        """
        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Curve

        """
        res = _BRep.Handle_BRep_CurveRepresentation_PCurve2(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Polygon3D(self, *args):
        """
        :rtype: OCC.wrapper.Poly.Handle_Poly_Polygon3D

        """
        res = _BRep.Handle_BRep_CurveRepresentation_Polygon3D(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Polygon(self, *args):
        """
        :rtype: OCC.wrapper.Poly.Handle_Poly_Polygon2D

        """
        res = _BRep.Handle_BRep_CurveRepresentation_Polygon(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Polygon2(self, *args):
        """
        :rtype: OCC.wrapper.Poly.Handle_Poly_Polygon2D

        """
        res = _BRep.Handle_BRep_CurveRepresentation_Polygon2(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Triangulation(self, *args):
        """
        :rtype: OCC.wrapper.Poly.Handle_Poly_Triangulation

        """
        res = _BRep.Handle_BRep_CurveRepresentation_Triangulation(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def PolygonOnTriangulation(self, *args):
        """
        :rtype: OCC.wrapper.Poly.Handle_Poly_PolygonOnTriangulation

        """
        res = _BRep.Handle_BRep_CurveRepresentation_PolygonOnTriangulation(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def PolygonOnTriangulation2(self, *args):
        """
        :rtype: OCC.wrapper.Poly.Handle_Poly_PolygonOnTriangulation

        """
        res = _BRep.Handle_BRep_CurveRepresentation_PolygonOnTriangulation2(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Surface2(self, *args):
        """
        :rtype: OCC.wrapper.Geom.Handle_Geom_Surface

        """
        res = _BRep.Handle_BRep_CurveRepresentation_Surface2(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Location2(self, *args):
        """
        :rtype: OCC.wrapper.TopLoc.TopLoc_Location

        """
        res = _BRep.Handle_BRep_CurveRepresentation_Location2(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Continuity(self, *args):
        """
        :rtype: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        res = _BRep.Handle_BRep_CurveRepresentation_Continuity(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Copy(self, *args):
        """
        Copy(Handle_BRep_CurveRepresentation self) -> Handle_BRep_CurveRepresentation

        Return a copy of this representation.

        :rtype: OCC.wrapper.BRep.Handle_BRep_CurveRepresentation

        """
        return _BRep.Handle_BRep_CurveRepresentation_Copy(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_BRep_CurveRepresentation self) -> char const *

        :rtype: const char *

        """
        return _BRep.Handle_BRep_CurveRepresentation_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _BRep.Handle_BRep_CurveRepresentation_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _BRep.Handle_BRep_CurveRepresentation_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_BRep_CurveRepresentation self)

        Memory deallocator for transient classes


        """
        return _BRep.Handle_BRep_CurveRepresentation_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_BRep_CurveRepresentation self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_BRep_CurveRepresentation self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRep.Handle_BRep_CurveRepresentation_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_BRep_CurveRepresentation self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_BRep_CurveRepresentation self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRep.Handle_BRep_CurveRepresentation_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_BRep_CurveRepresentation self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _BRep.Handle_BRep_CurveRepresentation_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_BRep_CurveRepresentation self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRep.Handle_BRep_CurveRepresentation_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_BRep_CurveRepresentation self)

        Increments the reference counter of this object


        """
        return _BRep.Handle_BRep_CurveRepresentation_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_BRep_CurveRepresentation self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRep.Handle_BRep_CurveRepresentation_DecrementRefCounter(self, *args)

Handle_BRep_CurveRepresentation_swigregister = _BRep.Handle_BRep_CurveRepresentation_swigregister
Handle_BRep_CurveRepresentation_swigregister(Handle_BRep_CurveRepresentation)

def Handle_BRep_CurveRepresentation_DownCast(thing):
    return _BRep.Handle_BRep_CurveRepresentation_DownCast(thing)
Handle_BRep_CurveRepresentation_DownCast = _BRep.Handle_BRep_CurveRepresentation_DownCast

class Handle_BRep_CurveOnSurface(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_BRep_CurveOnSurface self)

        Nullify the handle


        """
        return _BRep.Handle_BRep_CurveOnSurface_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_BRep_CurveOnSurface self) -> bool

        Check for being null

        :rtype: bool

        """
        return _BRep.Handle_BRep_CurveOnSurface_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_BRep_CurveOnSurface self, BRep_CurveOnSurface thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _BRep.Handle_BRep_CurveOnSurface_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_BRep_CurveOnSurface self, Handle_BRep_CurveOnSurface theHandle) -> Handle_BRep_CurveOnSurface
        assign(Handle_BRep_CurveOnSurface self, BRep_CurveOnSurface thePtr) -> Handle_BRep_CurveOnSurface
        assign(Handle_BRep_CurveOnSurface self, Handle_BRep_CurveOnSurface theHandle) -> Handle_BRep_CurveOnSurface

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _BRep.Handle_BRep_CurveOnSurface_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_BRep_CurveOnSurface self) -> BRep_CurveOnSurface

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _BRep.Handle_BRep_CurveOnSurface_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_BRep_CurveOnSurface self) -> BRep_CurveOnSurface

        Member access operator (note non-const)

        :rtype: T *

        """
        return _BRep.Handle_BRep_CurveOnSurface___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_BRep_CurveOnSurface self) -> BRep_CurveOnSurface

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _BRep.Handle_BRep_CurveOnSurface___ref__(self, *args)


    def __hash__(self):
        return _BRep.Handle_BRep_CurveOnSurface___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _BRep.Handle_BRep_CurveOnSurface___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _BRep.new_Handle_BRep_CurveOnSurface(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_BRep.Handle_BRep_CurveOnSurface_DownCast)
    __swig_destroy__ = _BRep.delete_Handle_BRep_CurveOnSurface

    def SetUVPoints(self, *args):
        """
        SetUVPoints(Handle_BRep_CurveOnSurface self, gp_Pnt2d P1, gp_Pnt2d P2)

        :type P1: OCC.wrapper.gp.gp_Pnt2d
        :type P2: OCC.wrapper.gp.gp_Pnt2d

        """
        return _BRep.Handle_BRep_CurveOnSurface_SetUVPoints(self, *args)


    def UVPoints(self, *args):
        """
        UVPoints(Handle_BRep_CurveOnSurface self, gp_Pnt2d P1, gp_Pnt2d P2)

        :type P1: OCC.wrapper.gp.gp_Pnt2d
        :type P2: OCC.wrapper.gp.gp_Pnt2d

        """
        return _BRep.Handle_BRep_CurveOnSurface_UVPoints(self, *args)


    def D0(self, *args):
        """
        D0(Handle_BRep_CurveOnSurface self, Standard_Real const U, gp_Pnt P)

        Computes the point at parameter U.

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt

        """
        return _BRep.Handle_BRep_CurveOnSurface_D0(self, *args)


    def IsCurveOnSurface(self, *args):
        """
        IsCurveOnSurface(Handle_BRep_CurveOnSurface self) -> Standard_Boolean
        IsCurveOnSurface(Handle_BRep_CurveOnSurface self, Handle_Geom_Surface S, TopLoc_Location L) -> Standard_Boolean

        A curve in the parametric space of a surface.

        :type S: OCC.wrapper.Geom.Handle_Geom_Surface
        :type L: OCC.wrapper.TopLoc.TopLoc_Location
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRep.Handle_BRep_CurveOnSurface_IsCurveOnSurface(self, *args)


    def Surface(self, *args):
        """
        :rtype: OCC.wrapper.Geom.Handle_Geom_Surface

        """
        res = _BRep.Handle_BRep_CurveOnSurface_Surface(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def PCurve(self, *args):
        """
        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Curve

        """
        res = _BRep.Handle_BRep_CurveOnSurface_PCurve(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Copy(self, *args):
        """
        Copy(Handle_BRep_CurveOnSurface self) -> Handle_BRep_CurveRepresentation

        Return a copy of this representation.

        :rtype: OCC.wrapper.BRep.Handle_BRep_CurveRepresentation

        """
        return _BRep.Handle_BRep_CurveOnSurface_Copy(self, *args)


    def Update(self, *args):
        """
        Update(Handle_BRep_CurveOnSurface self)

        Recomputes any derived data after a modification.
        This is called when the range is modified.


        """
        return _BRep.Handle_BRep_CurveOnSurface_Update(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_BRep_CurveOnSurface self) -> char const *

        :rtype: const char *

        """
        return _BRep.Handle_BRep_CurveOnSurface_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _BRep.Handle_BRep_CurveOnSurface_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _BRep.Handle_BRep_CurveOnSurface_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetRange(self, *args):
        """
        SetRange(Handle_BRep_CurveOnSurface self, Standard_Real const First, Standard_Real const Last)

        :type First: float
        :type Last: float

        """
        return _BRep.Handle_BRep_CurveOnSurface_SetRange(self, *args)


    def Range(self, *args):
        """
        Range(Handle_BRep_CurveOnSurface self)

        :type First: float
        :type Last: float

        """
        return _BRep.Handle_BRep_CurveOnSurface_Range(self, *args)


    def First(self, *args):
        """
        First(Handle_BRep_CurveOnSurface self) -> Standard_Real
        First(Handle_BRep_CurveOnSurface self, Standard_Real const F)

        :type F: float

        """
        return _BRep.Handle_BRep_CurveOnSurface_First(self, *args)


    def Last(self, *args):
        """
        Last(Handle_BRep_CurveOnSurface self) -> Standard_Real
        Last(Handle_BRep_CurveOnSurface self, Standard_Real const L)

        :type L: float

        """
        return _BRep.Handle_BRep_CurveOnSurface_Last(self, *args)


    def IsCurve3D(self, *args):
        """
        IsCurve3D(Handle_BRep_CurveOnSurface self) -> Standard_Boolean

        A 3D curve representation.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRep.Handle_BRep_CurveOnSurface_IsCurve3D(self, *args)


    def IsRegularity(self, *args):
        """
        IsRegularity(Handle_BRep_CurveOnSurface self) -> Standard_Boolean
        IsRegularity(Handle_BRep_CurveOnSurface self, Handle_Geom_Surface S1, Handle_Geom_Surface S2, TopLoc_Location L1, TopLoc_Location L2) -> Standard_Boolean

        Is it  a  regularity between  <S1> and   <S2> with
        location <L1> and <L2>.

        :type S1: OCC.wrapper.Geom.Handle_Geom_Surface
        :type S2: OCC.wrapper.Geom.Handle_Geom_Surface
        :type L1: OCC.wrapper.TopLoc.TopLoc_Location
        :type L2: OCC.wrapper.TopLoc.TopLoc_Location
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRep.Handle_BRep_CurveOnSurface_IsRegularity(self, *args)


    def IsCurveOnClosedSurface(self, *args):
        """
        IsCurveOnClosedSurface(Handle_BRep_CurveOnSurface self) -> Standard_Boolean

        A curve with two parametric   curves  on the  same
        surface.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRep.Handle_BRep_CurveOnSurface_IsCurveOnClosedSurface(self, *args)


    def IsPolygon3D(self, *args):
        """
        IsPolygon3D(Handle_BRep_CurveOnSurface self) -> Standard_Boolean

        A 3D polygon representation.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRep.Handle_BRep_CurveOnSurface_IsPolygon3D(self, *args)


    def IsPolygonOnTriangulation(self, *args):
        """
        IsPolygonOnTriangulation(Handle_BRep_CurveOnSurface self) -> Standard_Boolean
        IsPolygonOnTriangulation(Handle_BRep_CurveOnSurface self, Handle_Poly_Triangulation T, TopLoc_Location L) -> Standard_Boolean

        Is it a polygon in the definition of <T> with
        location <L>.

        :type T: OCC.wrapper.Poly.Handle_Poly_Triangulation
        :type L: OCC.wrapper.TopLoc.TopLoc_Location
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRep.Handle_BRep_CurveOnSurface_IsPolygonOnTriangulation(self, *args)


    def IsPolygonOnClosedTriangulation(self, *args):
        """
        IsPolygonOnClosedTriangulation(Handle_BRep_CurveOnSurface self) -> Standard_Boolean

        A representation by two arrays of nodes on a
        triangulation.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRep.Handle_BRep_CurveOnSurface_IsPolygonOnClosedTriangulation(self, *args)


    def IsPolygonOnSurface(self, *args):
        """
        IsPolygonOnSurface(Handle_BRep_CurveOnSurface self) -> Standard_Boolean
        IsPolygonOnSurface(Handle_BRep_CurveOnSurface self, Handle_Geom_Surface S, TopLoc_Location L) -> Standard_Boolean

        Is it a polygon in the parametric space  of <S> with
        location <L>.

        :type S: OCC.wrapper.Geom.Handle_Geom_Surface
        :type L: OCC.wrapper.TopLoc.TopLoc_Location
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRep.Handle_BRep_CurveOnSurface_IsPolygonOnSurface(self, *args)


    def IsPolygonOnClosedSurface(self, *args):
        """
        IsPolygonOnClosedSurface(Handle_BRep_CurveOnSurface self) -> Standard_Boolean

        Two   2D polygon  representations  in the  parametric
        space of a surface.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRep.Handle_BRep_CurveOnSurface_IsPolygonOnClosedSurface(self, *args)


    def Location(self, *args):
        """
        :rtype: OCC.wrapper.TopLoc.TopLoc_Location

        """
        res = _BRep.Handle_BRep_CurveOnSurface_Location(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Curve3D(self, *args):
        """
        :rtype: OCC.wrapper.Geom.Handle_Geom_Curve

        """
        res = _BRep.Handle_BRep_CurveOnSurface_Curve3D(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def PCurve2(self, *args):
        """
        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Curve

        """
        res = _BRep.Handle_BRep_CurveOnSurface_PCurve2(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Polygon3D(self, *args):
        """
        :rtype: OCC.wrapper.Poly.Handle_Poly_Polygon3D

        """
        res = _BRep.Handle_BRep_CurveOnSurface_Polygon3D(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Polygon(self, *args):
        """
        :rtype: OCC.wrapper.Poly.Handle_Poly_Polygon2D

        """
        res = _BRep.Handle_BRep_CurveOnSurface_Polygon(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Polygon2(self, *args):
        """
        :rtype: OCC.wrapper.Poly.Handle_Poly_Polygon2D

        """
        res = _BRep.Handle_BRep_CurveOnSurface_Polygon2(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Triangulation(self, *args):
        """
        :rtype: OCC.wrapper.Poly.Handle_Poly_Triangulation

        """
        res = _BRep.Handle_BRep_CurveOnSurface_Triangulation(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def PolygonOnTriangulation(self, *args):
        """
        :rtype: OCC.wrapper.Poly.Handle_Poly_PolygonOnTriangulation

        """
        res = _BRep.Handle_BRep_CurveOnSurface_PolygonOnTriangulation(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def PolygonOnTriangulation2(self, *args):
        """
        :rtype: OCC.wrapper.Poly.Handle_Poly_PolygonOnTriangulation

        """
        res = _BRep.Handle_BRep_CurveOnSurface_PolygonOnTriangulation2(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Surface2(self, *args):
        """
        :rtype: OCC.wrapper.Geom.Handle_Geom_Surface

        """
        res = _BRep.Handle_BRep_CurveOnSurface_Surface2(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Location2(self, *args):
        """
        :rtype: OCC.wrapper.TopLoc.TopLoc_Location

        """
        res = _BRep.Handle_BRep_CurveOnSurface_Location2(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Continuity(self, *args):
        """
        :rtype: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        res = _BRep.Handle_BRep_CurveOnSurface_Continuity(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_BRep_CurveOnSurface self)

        Memory deallocator for transient classes


        """
        return _BRep.Handle_BRep_CurveOnSurface_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_BRep_CurveOnSurface self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_BRep_CurveOnSurface self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRep.Handle_BRep_CurveOnSurface_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_BRep_CurveOnSurface self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_BRep_CurveOnSurface self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRep.Handle_BRep_CurveOnSurface_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_BRep_CurveOnSurface self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _BRep.Handle_BRep_CurveOnSurface_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_BRep_CurveOnSurface self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRep.Handle_BRep_CurveOnSurface_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_BRep_CurveOnSurface self)

        Increments the reference counter of this object


        """
        return _BRep.Handle_BRep_CurveOnSurface_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_BRep_CurveOnSurface self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRep.Handle_BRep_CurveOnSurface_DecrementRefCounter(self, *args)

Handle_BRep_CurveOnSurface_swigregister = _BRep.Handle_BRep_CurveOnSurface_swigregister
Handle_BRep_CurveOnSurface_swigregister(Handle_BRep_CurveOnSurface)

def Handle_BRep_CurveOnSurface_DownCast(thing):
    return _BRep.Handle_BRep_CurveOnSurface_DownCast(thing)
Handle_BRep_CurveOnSurface_DownCast = _BRep.Handle_BRep_CurveOnSurface_DownCast

class Handle_BRep_Polygon3D(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_BRep_Polygon3D self)

        Nullify the handle


        """
        return _BRep.Handle_BRep_Polygon3D_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_BRep_Polygon3D self) -> bool

        Check for being null

        :rtype: bool

        """
        return _BRep.Handle_BRep_Polygon3D_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_BRep_Polygon3D self, BRep_Polygon3D thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _BRep.Handle_BRep_Polygon3D_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_BRep_Polygon3D self, Handle_BRep_Polygon3D theHandle) -> Handle_BRep_Polygon3D
        assign(Handle_BRep_Polygon3D self, BRep_Polygon3D thePtr) -> Handle_BRep_Polygon3D
        assign(Handle_BRep_Polygon3D self, Handle_BRep_Polygon3D theHandle) -> Handle_BRep_Polygon3D

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _BRep.Handle_BRep_Polygon3D_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_BRep_Polygon3D self) -> BRep_Polygon3D

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _BRep.Handle_BRep_Polygon3D_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_BRep_Polygon3D self) -> BRep_Polygon3D

        Member access operator (note non-const)

        :rtype: T *

        """
        return _BRep.Handle_BRep_Polygon3D___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_BRep_Polygon3D self) -> BRep_Polygon3D

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _BRep.Handle_BRep_Polygon3D___ref__(self, *args)


    def __hash__(self):
        return _BRep.Handle_BRep_Polygon3D___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _BRep.Handle_BRep_Polygon3D___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _BRep.new_Handle_BRep_Polygon3D(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_BRep.Handle_BRep_Polygon3D_DownCast)
    __swig_destroy__ = _BRep.delete_Handle_BRep_Polygon3D

    def IsPolygon3D(self, *args):
        """
        IsPolygon3D(Handle_BRep_Polygon3D self) -> Standard_Boolean

        Returns True.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRep.Handle_BRep_Polygon3D_IsPolygon3D(self, *args)


    def Polygon3D(self, *args):
        """
        :rtype: OCC.wrapper.Poly.Handle_Poly_Polygon3D

        """
        res = _BRep.Handle_BRep_Polygon3D_Polygon3D(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Copy(self, *args):
        """
        Copy(Handle_BRep_Polygon3D self) -> Handle_BRep_CurveRepresentation

        Return a copy of this representation.

        :rtype: OCC.wrapper.BRep.Handle_BRep_CurveRepresentation

        """
        return _BRep.Handle_BRep_Polygon3D_Copy(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_BRep_Polygon3D self) -> char const *

        :rtype: const char *

        """
        return _BRep.Handle_BRep_Polygon3D_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _BRep.Handle_BRep_Polygon3D_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _BRep.Handle_BRep_Polygon3D_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def IsCurve3D(self, *args):
        """
        IsCurve3D(Handle_BRep_Polygon3D self) -> Standard_Boolean

        A 3D curve representation.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRep.Handle_BRep_Polygon3D_IsCurve3D(self, *args)


    def IsCurveOnSurface(self, *args):
        """
        IsCurveOnSurface(Handle_BRep_Polygon3D self) -> Standard_Boolean
        IsCurveOnSurface(Handle_BRep_Polygon3D self, Handle_Geom_Surface S, TopLoc_Location L) -> Standard_Boolean

        Is it a curve in the parametric space  of <S> with
        location <L>.

        :type S: OCC.wrapper.Geom.Handle_Geom_Surface
        :type L: OCC.wrapper.TopLoc.TopLoc_Location
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRep.Handle_BRep_Polygon3D_IsCurveOnSurface(self, *args)


    def IsRegularity(self, *args):
        """
        IsRegularity(Handle_BRep_Polygon3D self) -> Standard_Boolean
        IsRegularity(Handle_BRep_Polygon3D self, Handle_Geom_Surface S1, Handle_Geom_Surface S2, TopLoc_Location L1, TopLoc_Location L2) -> Standard_Boolean

        Is it  a  regularity between  <S1> and   <S2> with
        location <L1> and <L2>.

        :type S1: OCC.wrapper.Geom.Handle_Geom_Surface
        :type S2: OCC.wrapper.Geom.Handle_Geom_Surface
        :type L1: OCC.wrapper.TopLoc.TopLoc_Location
        :type L2: OCC.wrapper.TopLoc.TopLoc_Location
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRep.Handle_BRep_Polygon3D_IsRegularity(self, *args)


    def IsCurveOnClosedSurface(self, *args):
        """
        IsCurveOnClosedSurface(Handle_BRep_Polygon3D self) -> Standard_Boolean

        A curve with two parametric   curves  on the  same
        surface.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRep.Handle_BRep_Polygon3D_IsCurveOnClosedSurface(self, *args)


    def IsPolygonOnTriangulation(self, *args):
        """
        IsPolygonOnTriangulation(Handle_BRep_Polygon3D self) -> Standard_Boolean
        IsPolygonOnTriangulation(Handle_BRep_Polygon3D self, Handle_Poly_Triangulation T, TopLoc_Location L) -> Standard_Boolean

        Is it a polygon in the definition of <T> with
        location <L>.

        :type T: OCC.wrapper.Poly.Handle_Poly_Triangulation
        :type L: OCC.wrapper.TopLoc.TopLoc_Location
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRep.Handle_BRep_Polygon3D_IsPolygonOnTriangulation(self, *args)


    def IsPolygonOnClosedTriangulation(self, *args):
        """
        IsPolygonOnClosedTriangulation(Handle_BRep_Polygon3D self) -> Standard_Boolean

        A representation by two arrays of nodes on a
        triangulation.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRep.Handle_BRep_Polygon3D_IsPolygonOnClosedTriangulation(self, *args)


    def IsPolygonOnSurface(self, *args):
        """
        IsPolygonOnSurface(Handle_BRep_Polygon3D self) -> Standard_Boolean
        IsPolygonOnSurface(Handle_BRep_Polygon3D self, Handle_Geom_Surface S, TopLoc_Location L) -> Standard_Boolean

        Is it a polygon in the parametric space  of <S> with
        location <L>.

        :type S: OCC.wrapper.Geom.Handle_Geom_Surface
        :type L: OCC.wrapper.TopLoc.TopLoc_Location
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRep.Handle_BRep_Polygon3D_IsPolygonOnSurface(self, *args)


    def IsPolygonOnClosedSurface(self, *args):
        """
        IsPolygonOnClosedSurface(Handle_BRep_Polygon3D self) -> Standard_Boolean

        Two   2D polygon  representations  in the  parametric
        space of a surface.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRep.Handle_BRep_Polygon3D_IsPolygonOnClosedSurface(self, *args)


    def Location(self, *args):
        """
        :rtype: OCC.wrapper.TopLoc.TopLoc_Location

        """
        res = _BRep.Handle_BRep_Polygon3D_Location(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Curve3D(self, *args):
        """
        :rtype: OCC.wrapper.Geom.Handle_Geom_Curve

        """
        res = _BRep.Handle_BRep_Polygon3D_Curve3D(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Surface(self, *args):
        """
        :rtype: OCC.wrapper.Geom.Handle_Geom_Surface

        """
        res = _BRep.Handle_BRep_Polygon3D_Surface(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def PCurve(self, *args):
        """
        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Curve

        """
        res = _BRep.Handle_BRep_Polygon3D_PCurve(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def PCurve2(self, *args):
        """
        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Curve

        """
        res = _BRep.Handle_BRep_Polygon3D_PCurve2(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Polygon(self, *args):
        """
        :rtype: OCC.wrapper.Poly.Handle_Poly_Polygon2D

        """
        res = _BRep.Handle_BRep_Polygon3D_Polygon(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Polygon2(self, *args):
        """
        :rtype: OCC.wrapper.Poly.Handle_Poly_Polygon2D

        """
        res = _BRep.Handle_BRep_Polygon3D_Polygon2(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Triangulation(self, *args):
        """
        :rtype: OCC.wrapper.Poly.Handle_Poly_Triangulation

        """
        res = _BRep.Handle_BRep_Polygon3D_Triangulation(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def PolygonOnTriangulation(self, *args):
        """
        :rtype: OCC.wrapper.Poly.Handle_Poly_PolygonOnTriangulation

        """
        res = _BRep.Handle_BRep_Polygon3D_PolygonOnTriangulation(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def PolygonOnTriangulation2(self, *args):
        """
        :rtype: OCC.wrapper.Poly.Handle_Poly_PolygonOnTriangulation

        """
        res = _BRep.Handle_BRep_Polygon3D_PolygonOnTriangulation2(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Surface2(self, *args):
        """
        :rtype: OCC.wrapper.Geom.Handle_Geom_Surface

        """
        res = _BRep.Handle_BRep_Polygon3D_Surface2(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Location2(self, *args):
        """
        :rtype: OCC.wrapper.TopLoc.TopLoc_Location

        """
        res = _BRep.Handle_BRep_Polygon3D_Location2(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Continuity(self, *args):
        """
        :rtype: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        res = _BRep.Handle_BRep_Polygon3D_Continuity(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_BRep_Polygon3D self)

        Memory deallocator for transient classes


        """
        return _BRep.Handle_BRep_Polygon3D_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_BRep_Polygon3D self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_BRep_Polygon3D self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRep.Handle_BRep_Polygon3D_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_BRep_Polygon3D self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_BRep_Polygon3D self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRep.Handle_BRep_Polygon3D_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_BRep_Polygon3D self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _BRep.Handle_BRep_Polygon3D_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_BRep_Polygon3D self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRep.Handle_BRep_Polygon3D_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_BRep_Polygon3D self)

        Increments the reference counter of this object


        """
        return _BRep.Handle_BRep_Polygon3D_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_BRep_Polygon3D self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRep.Handle_BRep_Polygon3D_DecrementRefCounter(self, *args)

Handle_BRep_Polygon3D_swigregister = _BRep.Handle_BRep_Polygon3D_swigregister
Handle_BRep_Polygon3D_swigregister(Handle_BRep_Polygon3D)

def Handle_BRep_Polygon3D_DownCast(thing):
    return _BRep.Handle_BRep_Polygon3D_DownCast(thing)
Handle_BRep_Polygon3D_DownCast = _BRep.Handle_BRep_Polygon3D_DownCast




# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_BRepPrim')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_BRepPrim')
    _BRepPrim = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_BRepPrim', [dirname(__file__)])
        except ImportError:
            import _BRepPrim
            return _BRepPrim
        try:
            _mod = imp.load_module('_BRepPrim', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _BRepPrim = swig_import_helper()
    del swig_import_helper
else:
    import _BRepPrim
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


class SwigPyIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _BRepPrim.delete_SwigPyIterator

    def value(self):
        return _BRepPrim.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _BRepPrim.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _BRepPrim.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _BRepPrim.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _BRepPrim.SwigPyIterator_equal(self, x)

    def copy(self):
        return _BRepPrim.SwigPyIterator_copy(self)

    def next(self):
        return _BRepPrim.SwigPyIterator_next(self)

    def __next__(self):
        return _BRepPrim.SwigPyIterator___next__(self)

    def previous(self):
        return _BRepPrim.SwigPyIterator_previous(self)

    def advance(self, n):
        return _BRepPrim.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _BRepPrim.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _BRepPrim.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _BRepPrim.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _BRepPrim.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _BRepPrim.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _BRepPrim.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self
SwigPyIterator_swigregister = _BRepPrim.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

class NCollection_CellFilter_InspectorXYZ(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _BRepPrim.NCollection_CellFilter_InspectorXYZ_Dimension
    Coord = staticmethod(_BRepPrim.NCollection_CellFilter_InspectorXYZ_Coord)

    def Shift(self, thePnt, theTol):
        return _BRepPrim.NCollection_CellFilter_InspectorXYZ_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _BRepPrim.new_NCollection_CellFilter_InspectorXYZ()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _BRepPrim.delete_NCollection_CellFilter_InspectorXYZ
NCollection_CellFilter_InspectorXYZ_swigregister = _BRepPrim.NCollection_CellFilter_InspectorXYZ_swigregister
NCollection_CellFilter_InspectorXYZ_swigregister(NCollection_CellFilter_InspectorXYZ)

def NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt):
    return _BRepPrim.NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt)
NCollection_CellFilter_InspectorXYZ_Coord = _BRepPrim.NCollection_CellFilter_InspectorXYZ_Coord

class NCollection_CellFilter_InspectorXY(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _BRepPrim.NCollection_CellFilter_InspectorXY_Dimension
    Coord = staticmethod(_BRepPrim.NCollection_CellFilter_InspectorXY_Coord)

    def Shift(self, thePnt, theTol):
        return _BRepPrim.NCollection_CellFilter_InspectorXY_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _BRepPrim.new_NCollection_CellFilter_InspectorXY()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _BRepPrim.delete_NCollection_CellFilter_InspectorXY
NCollection_CellFilter_InspectorXY_swigregister = _BRepPrim.NCollection_CellFilter_InspectorXY_swigregister
NCollection_CellFilter_InspectorXY_swigregister(NCollection_CellFilter_InspectorXY)

def NCollection_CellFilter_InspectorXY_Coord(i, thePnt):
    return _BRepPrim.NCollection_CellFilter_InspectorXY_Coord(i, thePnt)
NCollection_CellFilter_InspectorXY_Coord = _BRepPrim.NCollection_CellFilter_InspectorXY_Coord


def ptr_to_number(item):
    return _BRepPrim.ptr_to_number(item)
ptr_to_number = _BRepPrim.ptr_to_number

def HashCode(*args):
    return _BRepPrim.HashCode(*args)
HashCode = _BRepPrim.HashCode

def ptr_equal(a, b):
    return _BRepPrim.ptr_equal(a, b)
ptr_equal = _BRepPrim.ptr_equal
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Geom2d
else:
    import Geom2d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import GeomAbs
else:
    import GeomAbs
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColStd
else:
    import TColStd
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TCollection
else:
    import TCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Standard
else:
    import Standard
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import NCollection
else:
    import NCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import gp
else:
    import gp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColgp
else:
    import TColgp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Geom
else:
    import Geom
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopoDS
else:
    import TopoDS
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopAbs
else:
    import TopAbs
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Message
else:
    import Message
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopLoc
else:
    import TopLoc
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import BRep
else:
    import BRep
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Poly
else:
    import Poly
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TShort
else:
    import TShort
del _swig_python_version_info
BRepPrim_XMin = _BRepPrim.BRepPrim_XMin
BRepPrim_XMax = _BRepPrim.BRepPrim_XMax
BRepPrim_YMin = _BRepPrim.BRepPrim_YMin
BRepPrim_YMax = _BRepPrim.BRepPrim_YMax
BRepPrim_ZMin = _BRepPrim.BRepPrim_ZMin
BRepPrim_ZMax = _BRepPrim.BRepPrim_ZMax
class BRepPrim_OneAxis(object):
    """
    Algorithm to  build  primitives with  one  axis of
    revolution.

    The revolution  body is described by :

    A coordinate  system (Ax2 from  gp). The Z axis is
    the rotational axis.

    An Angle around the Axis, When  the Angle  is 2*PI
    the primitive is not limited  by planar faces. The
    U parameter range from 0 to Angle.

    A parameter range VMin, VMax on the meridian.

    A meridian : The  meridian is a curve described by
    a set of deferred methods.

    The  topology consists of  A shell,  Faces,  Wires,
    Edges and Vertices.  Methods  are provided to build
    all the elements.  Building an element  implies the
    automatic building  of  all its  sub-elements.

    So building the shell builds everything.

    There are at most 5 faces :

    - The LateralFace.

    - The TopFace and the BottomFace.

    - The StartFace and the EndFace.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def SetMeridianOffset(self, *args):
        """
        SetMeridianOffset(BRepPrim_OneAxis self, Standard_Real const MeridianOffset=0)

        The MeridianOffset is added  to the  parameters on
        the meridian curve and  to  the  V values  of  the
        pcurves. This is  used for the sphere for example,
        to give a range on the meridian  edge which is not
        VMin, VMax.

        :type MeridianOffset: float

        """
        return _BRepPrim.BRepPrim_OneAxis_SetMeridianOffset(self, *args)


    def Axes(self, *args):
        """
        Returns the Ax2 from <me>.

        :rtype: OCC.wrapper.gp.gp_Ax2

        """
        res = _BRepPrim.BRepPrim_OneAxis_Axes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Angle(self, *args):
        """
        Angle(BRepPrim_OneAxis self) -> Standard_Real
        Angle(BRepPrim_OneAxis self, Standard_Real const A)

        :type A: float

        """
        return _BRepPrim.BRepPrim_OneAxis_Angle(self, *args)


    def VMin(self, *args):
        """
        VMin(BRepPrim_OneAxis self) -> Standard_Real
        VMin(BRepPrim_OneAxis self, Standard_Real const V)

        :type V: float

        """
        return _BRepPrim.BRepPrim_OneAxis_VMin(self, *args)


    def VMax(self, *args):
        """
        VMax(BRepPrim_OneAxis self) -> Standard_Real
        VMax(BRepPrim_OneAxis self, Standard_Real const V)

        :type V: float

        """
        return _BRepPrim.BRepPrim_OneAxis_VMax(self, *args)


    def MakeEmptyLateralFace(self, *args):
        """
        MakeEmptyLateralFace(BRepPrim_OneAxis self) -> TopoDS_Face

        Returns a face with  no edges.  The surface is the
        lateral surface with normals pointing outward. The
        U parameter is the angle with the  origin on the X
        axis. The  V parameter is   the  parameter of  the
        meridian.

        :rtype: OCC.wrapper.TopoDS.TopoDS_Face

        """
        return _BRepPrim.BRepPrim_OneAxis_MakeEmptyLateralFace(self, *args)


    def MakeEmptyMeridianEdge(self, *args):
        """
        MakeEmptyMeridianEdge(BRepPrim_OneAxis self, Standard_Real const Ang) -> TopoDS_Edge

        Returns  an  edge with  a 3D curve   made from the
        meridian  in the XZ  plane rotated by <Ang> around
        the Z-axis. Ang may be 0 or myAngle.

        :type Ang: float
        :rtype: OCC.wrapper.TopoDS.TopoDS_Edge

        """
        return _BRepPrim.BRepPrim_OneAxis_MakeEmptyMeridianEdge(self, *args)


    def SetMeridianPCurve(self, *args):
        """
        SetMeridianPCurve(BRepPrim_OneAxis self, TopoDS_Edge E, TopoDS_Face F)

        Sets the  parametric curve of the  edge <E> in the
        face  <F> to be  the   2d representation  of   the
        meridian.

        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :type F: OCC.wrapper.TopoDS.TopoDS_Face

        """
        return _BRepPrim.BRepPrim_OneAxis_SetMeridianPCurve(self, *args)


    def MeridianValue(self, *args):
        """
        MeridianValue(BRepPrim_OneAxis self, Standard_Real const V) -> gp_Pnt2d

        Returns the meridian point at parameter <V> in the
        plane XZ.

        :type V: float
        :rtype: OCC.wrapper.gp.gp_Pnt2d

        """
        return _BRepPrim.BRepPrim_OneAxis_MeridianValue(self, *args)


    def MeridianOnAxis(self, *args):
        """
        MeridianOnAxis(BRepPrim_OneAxis self, Standard_Real const V) -> Standard_Boolean

        Returns True if the point of  parameter <V> on the
        meridian is on the Axis. Default implementation is
        Abs(MeridianValue(V).X()) < Precision::Confusion()

        :type V: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepPrim.BRepPrim_OneAxis_MeridianOnAxis(self, *args)


    def MeridianClosed(self, *args):
        """
        MeridianClosed(BRepPrim_OneAxis self) -> Standard_Boolean

        Returns True  if the  meridian is  closed. Default
        implementation                                  is
        MeridianValue(VMin).IsEqual(MeridianValue(VMax),
        Precision::Confusion())

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepPrim.BRepPrim_OneAxis_MeridianClosed(self, *args)


    def VMaxInfinite(self, *args):
        """
        VMaxInfinite(BRepPrim_OneAxis self) -> Standard_Boolean

        Returns  True   if  VMax    is  infinite.  Default
        Precision::IsPositiveInfinite(VMax);

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepPrim.BRepPrim_OneAxis_VMaxInfinite(self, *args)


    def VMinInfinite(self, *args):
        """
        VMinInfinite(BRepPrim_OneAxis self) -> Standard_Boolean

        Returns  True   if  VMin    is  infinite.  Default
        Precision::IsNegativeInfinite(VMax);

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepPrim.BRepPrim_OneAxis_VMinInfinite(self, *args)


    def HasTop(self, *args):
        """
        HasTop(BRepPrim_OneAxis self) -> Standard_Boolean

        Returns True if  there is  a top  face.

        That is neither : VMaxInfinite()
        MeridianClosed()
        MeridianOnAxis(VMax)

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepPrim.BRepPrim_OneAxis_HasTop(self, *args)


    def HasBottom(self, *args):
        """
        HasBottom(BRepPrim_OneAxis self) -> Standard_Boolean

        Returns   True if there is   a bottom  face.

        That is neither : VMinInfinite()
        MeridianClosed()
        MeridianOnAxis(VMin)

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepPrim.BRepPrim_OneAxis_HasBottom(self, *args)


    def HasSides(self, *args):
        """
        HasSides(BRepPrim_OneAxis self) -> Standard_Boolean

        Returns True if  there are Start   and  End faces.

        That is : 2*PI  - Angle > Precision::Angular()

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepPrim.BRepPrim_OneAxis_HasSides(self, *args)


    def Shell(self, *args):
        """
        Returns the Shell containing all the  Faces of the
        primitive.

        :rtype: OCC.wrapper.TopoDS.TopoDS_Shell

        """
        res = _BRepPrim.BRepPrim_OneAxis_Shell(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def LateralFace(self, *args):
        """
        Returns  the lateral Face.   It is oriented toward
        the outside of the primitive.

        :rtype: OCC.wrapper.TopoDS.TopoDS_Face

        """
        res = _BRepPrim.BRepPrim_OneAxis_LateralFace(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def TopFace(self, *args):
        """
        Returns the   top planar  Face.    It  is Oriented
        toward the +Z axis (outside).

        :rtype: OCC.wrapper.TopoDS.TopoDS_Face

        """
        res = _BRepPrim.BRepPrim_OneAxis_TopFace(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def BottomFace(self, *args):
        """
        Returns  the Bottom planar Face.   It is  Oriented
        toward the -Z axis (outside).

        :rtype: OCC.wrapper.TopoDS.TopoDS_Face

        """
        res = _BRepPrim.BRepPrim_OneAxis_BottomFace(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def StartFace(self, *args):
        """
        Returns  the  Face   starting   the slice, it   is
        oriented toward the exterior of the primitive.

        :rtype: OCC.wrapper.TopoDS.TopoDS_Face

        """
        res = _BRepPrim.BRepPrim_OneAxis_StartFace(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def EndFace(self, *args):
        """
        Returns the Face ending the slice, it  is oriented
        toward the exterior of the primitive.

        :rtype: OCC.wrapper.TopoDS.TopoDS_Face

        """
        res = _BRepPrim.BRepPrim_OneAxis_EndFace(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def LateralWire(self, *args):
        """
        Returns  the wire in the lateral face.

        :rtype: OCC.wrapper.TopoDS.TopoDS_Wire

        """
        res = _BRepPrim.BRepPrim_OneAxis_LateralWire(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def LateralStartWire(self, *args):
        """
        Returns the   wire in the   lateral  face with the
        start edge.

        :rtype: OCC.wrapper.TopoDS.TopoDS_Wire

        """
        res = _BRepPrim.BRepPrim_OneAxis_LateralStartWire(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def LateralEndWire(self, *args):
        """
        Returns the wire with in lateral face with the end
        edge.

        :rtype: OCC.wrapper.TopoDS.TopoDS_Wire

        """
        res = _BRepPrim.BRepPrim_OneAxis_LateralEndWire(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def TopWire(self, *args):
        """
        Returns the wire in the top face.

        :rtype: OCC.wrapper.TopoDS.TopoDS_Wire

        """
        res = _BRepPrim.BRepPrim_OneAxis_TopWire(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def BottomWire(self, *args):
        """
        Returns the wire in the bottom face.

        :rtype: OCC.wrapper.TopoDS.TopoDS_Wire

        """
        res = _BRepPrim.BRepPrim_OneAxis_BottomWire(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def StartWire(self, *args):
        """
        Returns the wire  in the  start face.

        :rtype: OCC.wrapper.TopoDS.TopoDS_Wire

        """
        res = _BRepPrim.BRepPrim_OneAxis_StartWire(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def AxisStartWire(self, *args):
        """
        Returns  the wire   in the  start   face  with the
        AxisEdge.

        :rtype: OCC.wrapper.TopoDS.TopoDS_Wire

        """
        res = _BRepPrim.BRepPrim_OneAxis_AxisStartWire(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def EndWire(self, *args):
        """
        Returns the Wire in   the end face.

        :rtype: OCC.wrapper.TopoDS.TopoDS_Wire

        """
        res = _BRepPrim.BRepPrim_OneAxis_EndWire(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def AxisEndWire(self, *args):
        """
        Returns  the Wire  in  the   end   face  with  the
        AxisEdge.

        :rtype: OCC.wrapper.TopoDS.TopoDS_Wire

        """
        res = _BRepPrim.BRepPrim_OneAxis_AxisEndWire(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def AxisEdge(self, *args):
        """
        Returns the Edge built along the Axis and oriented
        on +Z of the Axis.

        :rtype: OCC.wrapper.TopoDS.TopoDS_Edge

        """
        res = _BRepPrim.BRepPrim_OneAxis_AxisEdge(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def StartEdge(self, *args):
        """
        Returns the   Edge at angle 0.

        :rtype: OCC.wrapper.TopoDS.TopoDS_Edge

        """
        res = _BRepPrim.BRepPrim_OneAxis_StartEdge(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def EndEdge(self, *args):
        """
        Returns the  Edge at  angle Angle.  If !HasSides()
        the StartEdge and the EndEdge are the same edge.

        :rtype: OCC.wrapper.TopoDS.TopoDS_Edge

        """
        res = _BRepPrim.BRepPrim_OneAxis_EndEdge(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def StartTopEdge(self, *args):
        """
        Returns the linear Edge between start Face and top
        Face.

        :rtype: OCC.wrapper.TopoDS.TopoDS_Edge

        """
        res = _BRepPrim.BRepPrim_OneAxis_StartTopEdge(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def StartBottomEdge(self, *args):
        """
        Returns the linear  Edge between  start  Face  and
        bottom Face.

        :rtype: OCC.wrapper.TopoDS.TopoDS_Edge

        """
        res = _BRepPrim.BRepPrim_OneAxis_StartBottomEdge(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def EndTopEdge(self, *args):
        """
        Returns the linear Edge  between end Face and  top
        Face.

        :rtype: OCC.wrapper.TopoDS.TopoDS_Edge

        """
        res = _BRepPrim.BRepPrim_OneAxis_EndTopEdge(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def EndBottomEdge(self, *args):
        """
        Returns  the  linear  Edge  between end  Face  and
        bottom Face.

        :rtype: OCC.wrapper.TopoDS.TopoDS_Edge

        """
        res = _BRepPrim.BRepPrim_OneAxis_EndBottomEdge(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def TopEdge(self, *args):
        """
        Returns the edge at VMax. If  MeridianClosed() the
        TopEdge and the BottomEdge are the same edge.

        :rtype: OCC.wrapper.TopoDS.TopoDS_Edge

        """
        res = _BRepPrim.BRepPrim_OneAxis_TopEdge(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def BottomEdge(self, *args):
        """
        Returns the edge  at VMin. If MeridianClosed() the
        TopEdge and the BottomEdge are the same edge.

        :rtype: OCC.wrapper.TopoDS.TopoDS_Edge

        """
        res = _BRepPrim.BRepPrim_OneAxis_BottomEdge(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def AxisTopVertex(self, *args):
        """
        Returns the Vertex at the Top altitude on the axis.

        :rtype: OCC.wrapper.TopoDS.TopoDS_Vertex

        """
        res = _BRepPrim.BRepPrim_OneAxis_AxisTopVertex(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def AxisBottomVertex(self, *args):
        """
        Returns the Vertex  at the Bottom  altitude on the
        axis.

        :rtype: OCC.wrapper.TopoDS.TopoDS_Vertex

        """
        res = _BRepPrim.BRepPrim_OneAxis_AxisBottomVertex(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def TopStartVertex(self, *args):
        """
        Returns the vertex (0,VMax)

        :rtype: OCC.wrapper.TopoDS.TopoDS_Vertex

        """
        res = _BRepPrim.BRepPrim_OneAxis_TopStartVertex(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def TopEndVertex(self, *args):
        """
        Returns the vertex (angle,VMax)

        :rtype: OCC.wrapper.TopoDS.TopoDS_Vertex

        """
        res = _BRepPrim.BRepPrim_OneAxis_TopEndVertex(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def BottomStartVertex(self, *args):
        """
        Returns the vertex (0,VMin)

        :rtype: OCC.wrapper.TopoDS.TopoDS_Vertex

        """
        res = _BRepPrim.BRepPrim_OneAxis_BottomStartVertex(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def BottomEndVertex(self, *args):
        """
        Returns the vertex (angle,VMax)

        :rtype: OCC.wrapper.TopoDS.TopoDS_Vertex

        """
        res = _BRepPrim.BRepPrim_OneAxis_BottomEndVertex(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _BRepPrim.delete_BRepPrim_OneAxis
BRepPrim_OneAxis_swigregister = _BRepPrim.BRepPrim_OneAxis_swigregister
BRepPrim_OneAxis_swigregister(BRepPrim_OneAxis)

class BRepPrim_Revolution(BRepPrim_OneAxis):
    """
    Implement  the OneAxis algoritm   for a revolution
    surface.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BRepPrim_Revolution self, gp_Ax2 A, Standard_Real const VMin, Standard_Real const VMax, Handle_Geom_Curve M, Handle_Geom2d_Curve PM) -> BRepPrim_Revolution

        Create a  revolution body <M>  is the  meridian nd
        must   be in the XZ  plane   of <A>. <PM>  is  the
        meridian in the XZ plane.

        :type A: OCC.wrapper.gp.gp_Ax2
        :type VMin: float
        :type VMax: float
        :type M: OCC.wrapper.Geom.Handle_Geom_Curve
        :type PM: OCC.wrapper.Geom2d.Handle_Geom2d_Curve

        """
        this = _BRepPrim.new_BRepPrim_Revolution(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def MakeEmptyLateralFace(self, *args):
        """
        MakeEmptyLateralFace(BRepPrim_Revolution self) -> TopoDS_Face

        The surface normal should be directed  towards the
        outside.

        :rtype: OCC.wrapper.TopoDS.TopoDS_Face

        """
        return _BRepPrim.BRepPrim_Revolution_MakeEmptyLateralFace(self, *args)


    def MakeEmptyMeridianEdge(self, *args):
        """
        MakeEmptyMeridianEdge(BRepPrim_Revolution self, Standard_Real const Ang) -> TopoDS_Edge

        Returns  an  edge with  a 3D curve   made from the
        meridian  in the XZ  plane rotated by <Ang> around
        the Z-axis. Ang may be 0 or myAngle.

        :type Ang: float
        :rtype: OCC.wrapper.TopoDS.TopoDS_Edge

        """
        return _BRepPrim.BRepPrim_Revolution_MakeEmptyMeridianEdge(self, *args)


    def MeridianValue(self, *args):
        """
        MeridianValue(BRepPrim_Revolution self, Standard_Real const V) -> gp_Pnt2d

        Returns the meridian point at parameter <V> in the
        plane XZ.

        :type V: float
        :rtype: OCC.wrapper.gp.gp_Pnt2d

        """
        return _BRepPrim.BRepPrim_Revolution_MeridianValue(self, *args)


    def SetMeridianPCurve(self, *args):
        """
        SetMeridianPCurve(BRepPrim_Revolution self, TopoDS_Edge E, TopoDS_Face F)

        Sets the  parametric urve of  the edge <E>  in the
        face <F>   to be  the  2d  representation  of  the
        meridian.

        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :type F: OCC.wrapper.TopoDS.TopoDS_Face

        """
        return _BRepPrim.BRepPrim_Revolution_SetMeridianPCurve(self, *args)

    __swig_destroy__ = _BRepPrim.delete_BRepPrim_Revolution
BRepPrim_Revolution_swigregister = _BRepPrim.BRepPrim_Revolution_swigregister
BRepPrim_Revolution_swigregister(BRepPrim_Revolution)

class BRepPrim_Cylinder(BRepPrim_Revolution):
    """Cylinder primitive."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BRepPrim_Cylinder self, gp_Ax2 Position, Standard_Real const Radius, Standard_Real const Height) -> BRepPrim_Cylinder
        __init__(BRepPrim_Cylinder self, Standard_Real const Radius) -> BRepPrim_Cylinder
        __init__(BRepPrim_Cylinder self, gp_Pnt Center, Standard_Real const Radius) -> BRepPrim_Cylinder
        __init__(BRepPrim_Cylinder self, gp_Ax2 Axes, Standard_Real const Radius) -> BRepPrim_Cylinder
        __init__(BRepPrim_Cylinder self, Standard_Real const R, Standard_Real const H) -> BRepPrim_Cylinder
        __init__(BRepPrim_Cylinder self, gp_Pnt Center, Standard_Real const R, Standard_Real const H) -> BRepPrim_Cylinder

        same as above but at a given point

        :type Center: OCC.wrapper.gp.gp_Pnt
        :type R: float
        :type H: float

        """
        this = _BRepPrim.new_BRepPrim_Cylinder(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def MakeEmptyLateralFace(self, *args):
        """
        MakeEmptyLateralFace(BRepPrim_Cylinder self) -> TopoDS_Face

        The surface normal should be directed  towards the
        outside.

        :rtype: OCC.wrapper.TopoDS.TopoDS_Face

        """
        return _BRepPrim.BRepPrim_Cylinder_MakeEmptyLateralFace(self, *args)

    __swig_destroy__ = _BRepPrim.delete_BRepPrim_Cylinder
BRepPrim_Cylinder_swigregister = _BRepPrim.BRepPrim_Cylinder_swigregister
BRepPrim_Cylinder_swigregister(BRepPrim_Cylinder)

class BRepPrim_Cone(BRepPrim_Revolution):
    """Implement the cone primitive."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BRepPrim_Cone self, Standard_Real const Angle, gp_Ax2 Position, Standard_Real const Height, Standard_Real const Radius=0) -> BRepPrim_Cone
        __init__(BRepPrim_Cone self, Standard_Real const Angle) -> BRepPrim_Cone
        __init__(BRepPrim_Cone self, Standard_Real const Angle, gp_Pnt Apex) -> BRepPrim_Cone
        __init__(BRepPrim_Cone self, Standard_Real const Angle, gp_Ax2 Axes) -> BRepPrim_Cone
        __init__(BRepPrim_Cone self, Standard_Real const R1, Standard_Real const R2, Standard_Real const H) -> BRepPrim_Cone
        __init__(BRepPrim_Cone self, gp_Pnt Center, Standard_Real const R1, Standard_Real const R2, Standard_Real const H) -> BRepPrim_Cone
        __init__(BRepPrim_Cone self, gp_Ax2 Axes, Standard_Real const R1, Standard_Real const R2, Standard_Real const H) -> BRepPrim_Cone

        same as above with given axes system.

        :type Axes: OCC.wrapper.gp.gp_Ax2
        :type R1: float
        :type R2: float
        :type H: float

        """
        this = _BRepPrim.new_BRepPrim_Cone(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def MakeEmptyLateralFace(self, *args):
        """
        MakeEmptyLateralFace(BRepPrim_Cone self) -> TopoDS_Face

        The surface normal should be directed  towards the
        outside.

        :rtype: OCC.wrapper.TopoDS.TopoDS_Face

        """
        return _BRepPrim.BRepPrim_Cone_MakeEmptyLateralFace(self, *args)

    __swig_destroy__ = _BRepPrim.delete_BRepPrim_Cone
BRepPrim_Cone_swigregister = _BRepPrim.BRepPrim_Cone_swigregister
BRepPrim_Cone_swigregister(BRepPrim_Cone)

class BRepPrim_Builder(object):
    """implements the abstract Builder with the BRep Builder"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BRepPrim_Builder self) -> BRepPrim_Builder
        __init__(BRepPrim_Builder self, BRep_Builder B) -> BRepPrim_Builder

        Creates from a Builder.

        :type B: OCC.wrapper.BRep.BRep_Builder

        """
        this = _BRepPrim.new_BRepPrim_Builder(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Builder(self, *args):
        """
        :rtype: OCC.wrapper.BRep.BRep_Builder

        """
        res = _BRepPrim.BRepPrim_Builder_Builder(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def MakeShell(self, *args):
        """
        MakeShell(BRepPrim_Builder self, TopoDS_Shell S)

        Make a empty Shell.

        :type S: OCC.wrapper.TopoDS.TopoDS_Shell

        """
        return _BRepPrim.BRepPrim_Builder_MakeShell(self, *args)


    def MakeFace(self, *args):
        """
        MakeFace(BRepPrim_Builder self, TopoDS_Face F, gp_Pln P)

        Returns in   <F> a  Face  built  with   the  plane
        equation <P>. Used by all primitives.

        :type F: OCC.wrapper.TopoDS.TopoDS_Face
        :type P: OCC.wrapper.gp.gp_Pln

        """
        return _BRepPrim.BRepPrim_Builder_MakeFace(self, *args)


    def MakeWire(self, *args):
        """
        MakeWire(BRepPrim_Builder self, TopoDS_Wire W)

        Returns in <W> an empty Wire.

        :type W: OCC.wrapper.TopoDS.TopoDS_Wire

        """
        return _BRepPrim.BRepPrim_Builder_MakeWire(self, *args)


    def MakeDegeneratedEdge(self, *args):
        """
        MakeDegeneratedEdge(BRepPrim_Builder self, TopoDS_Edge E)

        Returns in <E> a degenerated edge.

        :type E: OCC.wrapper.TopoDS.TopoDS_Edge

        """
        return _BRepPrim.BRepPrim_Builder_MakeDegeneratedEdge(self, *args)


    def MakeEdge(self, *args):
        """
        MakeEdge(BRepPrim_Builder self, TopoDS_Edge E, gp_Lin L)
        MakeEdge(BRepPrim_Builder self, TopoDS_Edge E, gp_Circ C)

        Returns  in <E>   an  Edge  built  with the circle
        equation  <C>.

        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :type C: OCC.wrapper.gp.gp_Circ

        """
        return _BRepPrim.BRepPrim_Builder_MakeEdge(self, *args)


    def SetPCurve(self, *args):
        """
        SetPCurve(BRepPrim_Builder self, TopoDS_Edge E, TopoDS_Face F, gp_Lin2d L)
        SetPCurve(BRepPrim_Builder self, TopoDS_Edge E, TopoDS_Face F, gp_Lin2d L1, gp_Lin2d L2)
        SetPCurve(BRepPrim_Builder self, TopoDS_Edge E, TopoDS_Face F, gp_Circ2d C)

        Sets the  circle <C> to  be the curve representing
        the  edge <E>  in   the  parametric  space of  the
        surface of <F>.

        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :type F: OCC.wrapper.TopoDS.TopoDS_Face
        :type C: OCC.wrapper.gp.gp_Circ2d

        """
        return _BRepPrim.BRepPrim_Builder_SetPCurve(self, *args)


    def MakeVertex(self, *args):
        """
        MakeVertex(BRepPrim_Builder self, TopoDS_Vertex V, gp_Pnt P)

        Returns in <V> a Vertex built with the point <P>.

        :type V: OCC.wrapper.TopoDS.TopoDS_Vertex
        :type P: OCC.wrapper.gp.gp_Pnt

        """
        return _BRepPrim.BRepPrim_Builder_MakeVertex(self, *args)


    def ReverseFace(self, *args):
        """
        ReverseFace(BRepPrim_Builder self, TopoDS_Face F)

        Reverses the Face <F>.

        :type F: OCC.wrapper.TopoDS.TopoDS_Face

        """
        return _BRepPrim.BRepPrim_Builder_ReverseFace(self, *args)


    def AddEdgeVertex(self, *args):
        """
        AddEdgeVertex(BRepPrim_Builder self, TopoDS_Edge E, TopoDS_Vertex V, Standard_Real const P, Standard_Boolean const direct)
        AddEdgeVertex(BRepPrim_Builder self, TopoDS_Edge E, TopoDS_Vertex V, Standard_Real const P1, Standard_Real const P2)

        Adds  the Vertex <V>  in the Edge <E>.   <P1,P2>
        are the  parameters of the  vertex on the closed
        edge.

        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :type V: OCC.wrapper.TopoDS.TopoDS_Vertex
        :type P1: float
        :type P2: float

        """
        return _BRepPrim.BRepPrim_Builder_AddEdgeVertex(self, *args)


    def SetParameters(self, *args):
        """
        SetParameters(BRepPrim_Builder self, TopoDS_Edge E, TopoDS_Vertex V, Standard_Real const P1, Standard_Real const P2)

        <P1,P2> are the parameters of the  vertex on the
        edge.  The edge is a closed curve.

        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :type V: OCC.wrapper.TopoDS.TopoDS_Vertex
        :type P1: float
        :type P2: float

        """
        return _BRepPrim.BRepPrim_Builder_SetParameters(self, *args)


    def AddWireEdge(self, *args):
        """
        AddWireEdge(BRepPrim_Builder self, TopoDS_Wire W, TopoDS_Edge E, Standard_Boolean const direct)

        Adds the Edge <E> in the  Wire <W>, if direct is
        False the Edge is reversed.

        :type W: OCC.wrapper.TopoDS.TopoDS_Wire
        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :type direct: bool

        """
        return _BRepPrim.BRepPrim_Builder_AddWireEdge(self, *args)


    def AddFaceWire(self, *args):
        """
        AddFaceWire(BRepPrim_Builder self, TopoDS_Face F, TopoDS_Wire W)

        Adds the Wire <W> in  the Face <F>.

        :type F: OCC.wrapper.TopoDS.TopoDS_Face
        :type W: OCC.wrapper.TopoDS.TopoDS_Wire

        """
        return _BRepPrim.BRepPrim_Builder_AddFaceWire(self, *args)


    def AddShellFace(self, *args):
        """
        AddShellFace(BRepPrim_Builder self, TopoDS_Shell Sh, TopoDS_Face F)

        Adds the Face <F>  in the Shell <Sh>.

        :type Sh: OCC.wrapper.TopoDS.TopoDS_Shell
        :type F: OCC.wrapper.TopoDS.TopoDS_Face

        """
        return _BRepPrim.BRepPrim_Builder_AddShellFace(self, *args)


    def CompleteEdge(self, *args):
        """
        CompleteEdge(BRepPrim_Builder self, TopoDS_Edge E)

        This is called once an edge is completed. It gives
        the opportunity to perform any post treatment.

        :type E: OCC.wrapper.TopoDS.TopoDS_Edge

        """
        return _BRepPrim.BRepPrim_Builder_CompleteEdge(self, *args)


    def CompleteWire(self, *args):
        """
        CompleteWire(BRepPrim_Builder self, TopoDS_Wire W)

        This is called once a wire is  completed. It gives
        the opportunity to perform any post treatment.

        :type W: OCC.wrapper.TopoDS.TopoDS_Wire

        """
        return _BRepPrim.BRepPrim_Builder_CompleteWire(self, *args)


    def CompleteFace(self, *args):
        """
        CompleteFace(BRepPrim_Builder self, TopoDS_Face F)

        This is called once a face is  completed. It gives
        the opportunity to perform any post treatment.

        :type F: OCC.wrapper.TopoDS.TopoDS_Face

        """
        return _BRepPrim.BRepPrim_Builder_CompleteFace(self, *args)


    def CompleteShell(self, *args):
        """
        CompleteShell(BRepPrim_Builder self, TopoDS_Shell S)

        This is called once a shell is  completed. It gives
        the opportunity to perform any post treatment.

        :type S: OCC.wrapper.TopoDS.TopoDS_Shell

        """
        return _BRepPrim.BRepPrim_Builder_CompleteShell(self, *args)

    __swig_destroy__ = _BRepPrim.delete_BRepPrim_Builder
BRepPrim_Builder_swigregister = _BRepPrim.BRepPrim_Builder_swigregister
BRepPrim_Builder_swigregister(BRepPrim_Builder)

class BRepPrim_FaceBuilder(object):
    """
    The  FaceBuilder is an algorithm   to build a BRep
    Face from a Geom Surface.

    The  face covers  the  whole surface or  the  area
    delimited by UMin, UMax, VMin, VMax
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BRepPrim_FaceBuilder self) -> BRepPrim_FaceBuilder
        __init__(BRepPrim_FaceBuilder self, BRep_Builder B, Handle_Geom_Surface S) -> BRepPrim_FaceBuilder
        __init__(BRepPrim_FaceBuilder self, BRep_Builder B, Handle_Geom_Surface S, Standard_Real const UMin, Standard_Real const UMax, Standard_Real const VMin, Standard_Real const VMax) -> BRepPrim_FaceBuilder

        :type B: OCC.wrapper.BRep.BRep_Builder
        :type S: OCC.wrapper.Geom.Handle_Geom_Surface
        :type UMin: float
        :type UMax: float
        :type VMin: float
        :type VMax: float

        """
        this = _BRepPrim.new_BRepPrim_FaceBuilder(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(BRepPrim_FaceBuilder self, BRep_Builder B, Handle_Geom_Surface S)
        Init(BRepPrim_FaceBuilder self, BRep_Builder B, Handle_Geom_Surface S, Standard_Real const UMin, Standard_Real const UMax, Standard_Real const VMin, Standard_Real const VMax)

        :type B: OCC.wrapper.BRep.BRep_Builder
        :type S: OCC.wrapper.Geom.Handle_Geom_Surface
        :type UMin: float
        :type UMax: float
        :type VMin: float
        :type VMax: float

        """
        return _BRepPrim.BRepPrim_FaceBuilder_Init(self, *args)


    def Face(self, *args):
        """
        :rtype: OCC.wrapper.TopoDS.TopoDS_Face

        """
        res = _BRepPrim.BRepPrim_FaceBuilder_Face(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Edge(self, *args):
        """
        Returns the edge of index <I>
        1 - Edge VMin
        2 - Edge UMax
        3 - Edge VMax
        4 - Edge UMin

        :type I: int
        :rtype: OCC.wrapper.TopoDS.TopoDS_Edge

        """
        res = _BRepPrim.BRepPrim_FaceBuilder_Edge(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Vertex(self, *args):
        """
        Returns the vertex of index <I>
        1 - Vertex UMin,VMin
        2 - Vertex UMax,VMin
        3 - Vertex UMax,VMax
        4 - Vertex UMin,VMax

        :type I: int
        :rtype: OCC.wrapper.TopoDS.TopoDS_Vertex

        """
        res = _BRepPrim.BRepPrim_FaceBuilder_Vertex(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _BRepPrim.delete_BRepPrim_FaceBuilder
BRepPrim_FaceBuilder_swigregister = _BRepPrim.BRepPrim_FaceBuilder_swigregister
BRepPrim_FaceBuilder_swigregister(BRepPrim_FaceBuilder)

class BRepPrim_Sphere(BRepPrim_Revolution):
    """Implements the sphere primitive"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BRepPrim_Sphere self, Standard_Real const Radius) -> BRepPrim_Sphere
        __init__(BRepPrim_Sphere self, gp_Pnt Center, Standard_Real const Radius) -> BRepPrim_Sphere
        __init__(BRepPrim_Sphere self, gp_Ax2 Axes, Standard_Real const Radius) -> BRepPrim_Sphere

        Creates a sphere with given axes system.

        :type Axes: OCC.wrapper.gp.gp_Ax2
        :type Radius: float

        """
        this = _BRepPrim.new_BRepPrim_Sphere(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def MakeEmptyLateralFace(self, *args):
        """
        MakeEmptyLateralFace(BRepPrim_Sphere self) -> TopoDS_Face

        The surface normal should be directed  towards the
        outside.

        :rtype: OCC.wrapper.TopoDS.TopoDS_Face

        """
        return _BRepPrim.BRepPrim_Sphere_MakeEmptyLateralFace(self, *args)

    __swig_destroy__ = _BRepPrim.delete_BRepPrim_Sphere
BRepPrim_Sphere_swigregister = _BRepPrim.BRepPrim_Sphere_swigregister
BRepPrim_Sphere_swigregister(BRepPrim_Sphere)

class BRepPrim_GWedge(object):
    """
    A wedge is defined by  :

    Axes : an Axis2 (coordinate system)

    YMin, YMax the  coordinates of the  ymin and ymax
    rectangular faces parallel to the ZX plane (of the
    coordinate systems)

    ZMin,ZMax,XMin,XMax the rectangular
    left (YMin) face parallel to the Z and X axes.

    Z2Min,Z2Max,X2Min,X2Max the rectangular
    right (YMax) face parallel to the Z and X axes.

    For a box Z2Min = ZMin, Z2Max = ZMax,
    X2Min = XMin, X2Max = XMax

    The wedge can be open in the corresponding direction
    of its Boolean myInfinite
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BRepPrim_GWedge self, BRepPrim_Builder B, gp_Ax2 Axes, Standard_Real const dx, Standard_Real const dy, Standard_Real const dz) -> BRepPrim_GWedge
        __init__(BRepPrim_GWedge self, BRepPrim_Builder B, gp_Ax2 Axes, Standard_Real const dx, Standard_Real const dy, Standard_Real const dz, Standard_Real const ltx) -> BRepPrim_GWedge
        __init__(BRepPrim_GWedge self, BRepPrim_Builder B, gp_Ax2 Axes, Standard_Real const xmin, Standard_Real const ymin, Standard_Real const zmin, Standard_Real const z2min, Standard_Real const x2min, Standard_Real const xmax, Standard_Real const ymax, Standard_Real const zmax, Standard_Real const z2max, Standard_Real const x2max) -> BRepPrim_GWedge

        Create  a GWedge primitive.   <Axes>  is  the  axis
        system for the primitive.

        all the fields are set to the corresponding value
        XYZMax - XYZMin should be positive
        ZX2Max - ZX2Min should not be negative

        :type B: OCC.wrapper.BRepPrim.BRepPrim_Builder
        :type Axes: OCC.wrapper.gp.gp_Ax2
        :type xmin: float
        :type ymin: float
        :type zmin: float
        :type z2min: float
        :type x2min: float
        :type xmax: float
        :type ymax: float
        :type zmax: float
        :type z2max: float
        :type x2max: float

        """
        this = _BRepPrim.new_BRepPrim_GWedge(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Axes(self, *args):
        """
        Axes(BRepPrim_GWedge self) -> gp_Ax2

        Returns the coordinates system from <me>.

        :rtype: OCC.wrapper.gp.gp_Ax2

        """
        return _BRepPrim.BRepPrim_GWedge_Axes(self, *args)


    def GetXMin(self, *args):
        """
        GetXMin(BRepPrim_GWedge self) -> Standard_Real

        Returns Xmin value from <me>.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _BRepPrim.BRepPrim_GWedge_GetXMin(self, *args)


    def GetYMin(self, *args):
        """
        GetYMin(BRepPrim_GWedge self) -> Standard_Real

        Returns YMin value from <me>.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _BRepPrim.BRepPrim_GWedge_GetYMin(self, *args)


    def GetZMin(self, *args):
        """
        GetZMin(BRepPrim_GWedge self) -> Standard_Real

        Returns ZMin value from <me>.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _BRepPrim.BRepPrim_GWedge_GetZMin(self, *args)


    def GetZ2Min(self, *args):
        """
        GetZ2Min(BRepPrim_GWedge self) -> Standard_Real

        Returns Z2Min value from <me>.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _BRepPrim.BRepPrim_GWedge_GetZ2Min(self, *args)


    def GetX2Min(self, *args):
        """
        GetX2Min(BRepPrim_GWedge self) -> Standard_Real

        Returns X2Min value from <me>.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _BRepPrim.BRepPrim_GWedge_GetX2Min(self, *args)


    def GetXMax(self, *args):
        """
        GetXMax(BRepPrim_GWedge self) -> Standard_Real

        Returns XMax value from <me>.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _BRepPrim.BRepPrim_GWedge_GetXMax(self, *args)


    def GetYMax(self, *args):
        """
        GetYMax(BRepPrim_GWedge self) -> Standard_Real

        Returns YMax value from <me>.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _BRepPrim.BRepPrim_GWedge_GetYMax(self, *args)


    def GetZMax(self, *args):
        """
        GetZMax(BRepPrim_GWedge self) -> Standard_Real

        Returns ZMax value from <me>.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _BRepPrim.BRepPrim_GWedge_GetZMax(self, *args)


    def GetZ2Max(self, *args):
        """
        GetZ2Max(BRepPrim_GWedge self) -> Standard_Real

        Returns Z2Max value from <me>.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _BRepPrim.BRepPrim_GWedge_GetZ2Max(self, *args)


    def GetX2Max(self, *args):
        """
        GetX2Max(BRepPrim_GWedge self) -> Standard_Real

        Returns X2Max value from <me>.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _BRepPrim.BRepPrim_GWedge_GetX2Max(self, *args)


    def Open(self, *args):
        """
        Open(BRepPrim_GWedge self, BRepPrim_Direction const d1)

        Opens <me> in <d1> direction. A face and its edges
        or vertices are said nonexistant.

        :type d1: OCC.wrapper.BRepPrim.BRepPrim_Direction

        """
        return _BRepPrim.BRepPrim_GWedge_Open(self, *args)


    def Close(self, *args):
        """
        Close(BRepPrim_GWedge self, BRepPrim_Direction const d1)

        Closes   <me>  in <d1>  direction.  A face and its
        edges or vertices are said existant.

        :type d1: OCC.wrapper.BRepPrim.BRepPrim_Direction

        """
        return _BRepPrim.BRepPrim_GWedge_Close(self, *args)


    def IsInfinite(self, *args):
        """
        IsInfinite(BRepPrim_GWedge self, BRepPrim_Direction const d1) -> Standard_Boolean

        Returns True if <me> is open in <d1> direction.

        :type d1: OCC.wrapper.BRepPrim.BRepPrim_Direction
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepPrim.BRepPrim_GWedge_IsInfinite(self, *args)


    def Shell(self, *args):
        """
        Returns the Shell containing the Faces of <me>.

        :rtype: OCC.wrapper.TopoDS.TopoDS_Shell

        """
        res = _BRepPrim.BRepPrim_GWedge_Shell(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def HasFace(self, *args):
        """
        HasFace(BRepPrim_GWedge self, BRepPrim_Direction const d1) -> Standard_Boolean

        Returns True if <me> has a Face in <d1> direction.

        :type d1: OCC.wrapper.BRepPrim.BRepPrim_Direction
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepPrim.BRepPrim_GWedge_HasFace(self, *args)


    def Face(self, *args):
        """
        Returns the Face of <me> located in <d1> direction.

        :type d1: OCC.wrapper.BRepPrim.BRepPrim_Direction
        :rtype: OCC.wrapper.TopoDS.TopoDS_Face

        """
        res = _BRepPrim.BRepPrim_GWedge_Face(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Plane(self, *args):
        """
        Plane(BRepPrim_GWedge self, BRepPrim_Direction const d1) -> gp_Pln

        Returns the plane  of the Face  of <me> located in
        <d1> direction.

        :type d1: OCC.wrapper.BRepPrim.BRepPrim_Direction
        :rtype: OCC.wrapper.gp.gp_Pln

        """
        return _BRepPrim.BRepPrim_GWedge_Plane(self, *args)


    def HasWire(self, *args):
        """
        HasWire(BRepPrim_GWedge self, BRepPrim_Direction const d1) -> Standard_Boolean

        Returns True if <me> has a Wire in <d1> direction.

        :type d1: OCC.wrapper.BRepPrim.BRepPrim_Direction
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepPrim.BRepPrim_GWedge_HasWire(self, *args)


    def Wire(self, *args):
        """
        Returns the Wire of <me> located in <d1> direction.

        :type d1: OCC.wrapper.BRepPrim.BRepPrim_Direction
        :rtype: OCC.wrapper.TopoDS.TopoDS_Wire

        """
        res = _BRepPrim.BRepPrim_GWedge_Wire(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def HasEdge(self, *args):
        """
        HasEdge(BRepPrim_GWedge self, BRepPrim_Direction const d1, BRepPrim_Direction const d2) -> Standard_Boolean

        Returns True if <me> has an Edge in <d1><d2> direction.

        :type d1: OCC.wrapper.BRepPrim.BRepPrim_Direction
        :type d2: OCC.wrapper.BRepPrim.BRepPrim_Direction
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepPrim.BRepPrim_GWedge_HasEdge(self, *args)


    def Edge(self, *args):
        """
        Returns the Edge of <me> located in <d1><d2> direction.

        :type d1: OCC.wrapper.BRepPrim.BRepPrim_Direction
        :type d2: OCC.wrapper.BRepPrim.BRepPrim_Direction
        :rtype: OCC.wrapper.TopoDS.TopoDS_Edge

        """
        res = _BRepPrim.BRepPrim_GWedge_Edge(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Line(self, *args):
        """
        Line(BRepPrim_GWedge self, BRepPrim_Direction const d1, BRepPrim_Direction const d2) -> gp_Lin

        Returns the line of  the Edge of <me>  located  in
        <d1><d2> direction.

        :type d1: OCC.wrapper.BRepPrim.BRepPrim_Direction
        :type d2: OCC.wrapper.BRepPrim.BRepPrim_Direction
        :rtype: OCC.wrapper.gp.gp_Lin

        """
        return _BRepPrim.BRepPrim_GWedge_Line(self, *args)


    def HasVertex(self, *args):
        """
        HasVertex(BRepPrim_GWedge self, BRepPrim_Direction const d1, BRepPrim_Direction const d2, BRepPrim_Direction const d3) -> Standard_Boolean

        Returns True if <me> has a  Vertex in <d1><d2><d3>
        direction.

        :type d1: OCC.wrapper.BRepPrim.BRepPrim_Direction
        :type d2: OCC.wrapper.BRepPrim.BRepPrim_Direction
        :type d3: OCC.wrapper.BRepPrim.BRepPrim_Direction
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepPrim.BRepPrim_GWedge_HasVertex(self, *args)


    def Vertex(self, *args):
        """
        Returns the Vertex of <me> located in <d1><d2><d3>
        direction.

        :type d1: OCC.wrapper.BRepPrim.BRepPrim_Direction
        :type d2: OCC.wrapper.BRepPrim.BRepPrim_Direction
        :type d3: OCC.wrapper.BRepPrim.BRepPrim_Direction
        :rtype: OCC.wrapper.TopoDS.TopoDS_Vertex

        """
        res = _BRepPrim.BRepPrim_GWedge_Vertex(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Point(self, *args):
        """
        Point(BRepPrim_GWedge self, BRepPrim_Direction const d1, BRepPrim_Direction const d2, BRepPrim_Direction const d3) -> gp_Pnt

        Returns the point of the Vertex of <me> located in
        <d1><d2><d3> direction.

        :type d1: OCC.wrapper.BRepPrim.BRepPrim_Direction
        :type d2: OCC.wrapper.BRepPrim.BRepPrim_Direction
        :type d3: OCC.wrapper.BRepPrim.BRepPrim_Direction
        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _BRepPrim.BRepPrim_GWedge_Point(self, *args)

    __swig_destroy__ = _BRepPrim.delete_BRepPrim_GWedge
BRepPrim_GWedge_swigregister = _BRepPrim.BRepPrim_GWedge_swigregister
BRepPrim_GWedge_swigregister(BRepPrim_GWedge)

class BRepPrim_Wedge(BRepPrim_GWedge):
    """Provides constructors without Builders."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BRepPrim_Wedge self, gp_Ax2 Axes, Standard_Real const dx, Standard_Real const dy, Standard_Real const dz) -> BRepPrim_Wedge
        __init__(BRepPrim_Wedge self, gp_Ax2 Axes, Standard_Real const dx, Standard_Real const dy, Standard_Real const dz, Standard_Real const ltx) -> BRepPrim_Wedge
        __init__(BRepPrim_Wedge self, gp_Ax2 Axes, Standard_Real const xmin, Standard_Real const ymin, Standard_Real const zmin, Standard_Real const z2min, Standard_Real const x2min, Standard_Real const xmax, Standard_Real const ymax, Standard_Real const zmax, Standard_Real const z2max, Standard_Real const x2max) -> BRepPrim_Wedge

        Create  a Wedge primitive.   <Axes>  is  the  axis
        system for the primitive.

        all the fields are set to the corresponding value
        XYZMax - XYZMin should be positive
        ZX2Max - ZX2Min should not be negative

        :type Axes: OCC.wrapper.gp.gp_Ax2
        :type xmin: float
        :type ymin: float
        :type zmin: float
        :type z2min: float
        :type x2min: float
        :type xmax: float
        :type ymax: float
        :type zmax: float
        :type z2max: float
        :type x2max: float

        """
        this = _BRepPrim.new_BRepPrim_Wedge(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _BRepPrim.delete_BRepPrim_Wedge
BRepPrim_Wedge_swigregister = _BRepPrim.BRepPrim_Wedge_swigregister
BRepPrim_Wedge_swigregister(BRepPrim_Wedge)

class BRepPrim_Torus(BRepPrim_Revolution):
    """Implements the torus primitive"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BRepPrim_Torus self, gp_Ax2 Position, Standard_Real const Major, Standard_Real const Minor) -> BRepPrim_Torus
        __init__(BRepPrim_Torus self, Standard_Real const Major, Standard_Real const Minor) -> BRepPrim_Torus
        __init__(BRepPrim_Torus self, gp_Pnt Center, Standard_Real const Major, Standard_Real const Minor) -> BRepPrim_Torus

        Torus at Center

        :type Center: OCC.wrapper.gp.gp_Pnt
        :type Major: float
        :type Minor: float

        """
        this = _BRepPrim.new_BRepPrim_Torus(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def MakeEmptyLateralFace(self, *args):
        """
        MakeEmptyLateralFace(BRepPrim_Torus self) -> TopoDS_Face

        The surface normal should be directed  towards the
        outside.

        :rtype: OCC.wrapper.TopoDS.TopoDS_Face

        """
        return _BRepPrim.BRepPrim_Torus_MakeEmptyLateralFace(self, *args)

    __swig_destroy__ = _BRepPrim.delete_BRepPrim_Torus
BRepPrim_Torus_swigregister = _BRepPrim.BRepPrim_Torus_swigregister
BRepPrim_Torus_swigregister(BRepPrim_Torus)




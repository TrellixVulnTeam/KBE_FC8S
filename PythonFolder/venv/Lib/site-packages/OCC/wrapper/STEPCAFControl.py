# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_STEPCAFControl')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_STEPCAFControl')
    _STEPCAFControl = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_STEPCAFControl', [dirname(__file__)])
        except ImportError:
            import _STEPCAFControl
            return _STEPCAFControl
        try:
            _mod = imp.load_module('_STEPCAFControl', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _STEPCAFControl = swig_import_helper()
    del swig_import_helper
else:
    import _STEPCAFControl
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


class SwigPyIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _STEPCAFControl.delete_SwigPyIterator

    def value(self):
        return _STEPCAFControl.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _STEPCAFControl.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _STEPCAFControl.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _STEPCAFControl.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _STEPCAFControl.SwigPyIterator_equal(self, x)

    def copy(self):
        return _STEPCAFControl.SwigPyIterator_copy(self)

    def next(self):
        return _STEPCAFControl.SwigPyIterator_next(self)

    def __next__(self):
        return _STEPCAFControl.SwigPyIterator___next__(self)

    def previous(self):
        return _STEPCAFControl.SwigPyIterator_previous(self)

    def advance(self, n):
        return _STEPCAFControl.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _STEPCAFControl.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _STEPCAFControl.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _STEPCAFControl.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _STEPCAFControl.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _STEPCAFControl.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _STEPCAFControl.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self
SwigPyIterator_swigregister = _STEPCAFControl.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

class NCollection_CellFilter_InspectorXYZ(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _STEPCAFControl.NCollection_CellFilter_InspectorXYZ_Dimension
    Coord = staticmethod(_STEPCAFControl.NCollection_CellFilter_InspectorXYZ_Coord)

    def Shift(self, thePnt, theTol):
        return _STEPCAFControl.NCollection_CellFilter_InspectorXYZ_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _STEPCAFControl.new_NCollection_CellFilter_InspectorXYZ()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _STEPCAFControl.delete_NCollection_CellFilter_InspectorXYZ
NCollection_CellFilter_InspectorXYZ_swigregister = _STEPCAFControl.NCollection_CellFilter_InspectorXYZ_swigregister
NCollection_CellFilter_InspectorXYZ_swigregister(NCollection_CellFilter_InspectorXYZ)

def NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt):
    return _STEPCAFControl.NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt)
NCollection_CellFilter_InspectorXYZ_Coord = _STEPCAFControl.NCollection_CellFilter_InspectorXYZ_Coord

class NCollection_CellFilter_InspectorXY(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _STEPCAFControl.NCollection_CellFilter_InspectorXY_Dimension
    Coord = staticmethod(_STEPCAFControl.NCollection_CellFilter_InspectorXY_Coord)

    def Shift(self, thePnt, theTol):
        return _STEPCAFControl.NCollection_CellFilter_InspectorXY_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _STEPCAFControl.new_NCollection_CellFilter_InspectorXY()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _STEPCAFControl.delete_NCollection_CellFilter_InspectorXY
NCollection_CellFilter_InspectorXY_swigregister = _STEPCAFControl.NCollection_CellFilter_InspectorXY_swigregister
NCollection_CellFilter_InspectorXY_swigregister(NCollection_CellFilter_InspectorXY)

def NCollection_CellFilter_InspectorXY_Coord(i, thePnt):
    return _STEPCAFControl.NCollection_CellFilter_InspectorXY_Coord(i, thePnt)
NCollection_CellFilter_InspectorXY_Coord = _STEPCAFControl.NCollection_CellFilter_InspectorXY_Coord


def ptr_to_number(item):
    return _STEPCAFControl.ptr_to_number(item)
ptr_to_number = _STEPCAFControl.ptr_to_number

def HashCode(*args):
    return _STEPCAFControl.HashCode(*args)
HashCode = _STEPCAFControl.HashCode

def ptr_equal(a, b):
    return _STEPCAFControl.ptr_equal(a, b)
ptr_equal = _STEPCAFControl.ptr_equal
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import StepBasic
else:
    import StepBasic
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import NCollection
else:
    import NCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Standard
else:
    import Standard
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColStd
else:
    import TColStd
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TCollection
else:
    import TCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import StepData
else:
    import StepData
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Interface
else:
    import Interface
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import MoniTool
else:
    import MoniTool
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopoDS
else:
    import TopoDS
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopAbs
else:
    import TopAbs
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Message
else:
    import Message
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopLoc
else:
    import TopLoc
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import gp
else:
    import gp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import OSD
else:
    import OSD
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Quantity
else:
    import Quantity
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopTools
else:
    import TopTools
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Bnd
else:
    import Bnd
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColgp
else:
    import TColgp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import XCAFDoc
else:
    import XCAFDoc
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import XCAFView
else:
    import XCAFView
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TDF
else:
    import TDF
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import XCAFNoteObjects
else:
    import XCAFNoteObjects
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TDocStd
else:
    import TDocStd
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import CDF
else:
    import CDF
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import CDM
else:
    import CDM
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Resource
else:
    import Resource
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import PCDM
else:
    import PCDM
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import LDOM
else:
    import LDOM
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Storage
else:
    import Storage
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import XCAFDimTolObjects
else:
    import XCAFDimTolObjects
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TDataStd
else:
    import TDataStd
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import StepAP242
else:
    import StepAP242
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import StepDimTol
else:
    import StepDimTol
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import StepShape
else:
    import StepShape
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import StepGeom
else:
    import StepGeom
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import StepRepr
else:
    import StepRepr
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import StepAP214
else:
    import StepAP214
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import StepVisual
else:
    import StepVisual
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Transfer
else:
    import Transfer
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import XSControl
else:
    import XSControl
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Geom2d
else:
    import Geom2d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import GeomAbs
else:
    import GeomAbs
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Geom
else:
    import Geom
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import IFSelect
else:
    import IFSelect
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import IFGraph
else:
    import IFGraph
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import STEPConstruct
else:
    import STEPConstruct
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import StepAP203
else:
    import StepAP203
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import STEPControl
else:
    import STEPControl
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TransferBRep
else:
    import TransferBRep
del _swig_python_version_info
class STEPCAFControl_ActorWrite(STEPControl.STEPControl_ActorWrite):
    """
    Extends ActorWrite from STEPControl by analysis of
    whether shape is assembly (based on information from DECAF)
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_STEPCAFControl_ActorWrite
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_STEPCAFControl_ActorWrite(self) 
            return h


    def __init__(self, *args):
        """
        __init__(STEPCAFControl_ActorWrite self) -> STEPCAFControl_ActorWrite

        Extends ActorWrite from STEPControl by analysis of
        whether shape is assembly (based on information from DECAF)
        """
        this = _STEPCAFControl.new_STEPCAFControl_ActorWrite(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def IsAssembly(self, *args):
        """
        IsAssembly(STEPCAFControl_ActorWrite self, TopoDS_Shape S) -> Standard_Boolean

        Check whether shape S is assembly
        Returns True if shape is registered in assemblies map

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _STEPCAFControl.STEPCAFControl_ActorWrite_IsAssembly(self, *args)


    def SetStdMode(self, *args):
        """
        SetStdMode(STEPCAFControl_ActorWrite self, Standard_Boolean const stdmode)

        Set standard mode of work
        In standard mode Actor (default) behaves exactly as its
        ancestor, also map is cleared

        :type stdmode: bool

        """
        return _STEPCAFControl.STEPCAFControl_ActorWrite_SetStdMode(self, *args)


    def ClearMap(self, *args):
        """
        ClearMap(STEPCAFControl_ActorWrite self)

        Clears map of shapes registered as assemblies


        """
        return _STEPCAFControl.STEPCAFControl_ActorWrite_ClearMap(self, *args)


    def RegisterAssembly(self, *args):
        """
        RegisterAssembly(STEPCAFControl_ActorWrite self, TopoDS_Shape S)

        Registers shape to be written as assembly
        The shape should be TopoDS_Compound (else does nothing)

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _STEPCAFControl.STEPCAFControl_ActorWrite_RegisterAssembly(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _STEPCAFControl.STEPCAFControl_ActorWrite_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _STEPCAFControl.STEPCAFControl_ActorWrite_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _STEPCAFControl.STEPCAFControl_ActorWrite_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _STEPCAFControl.delete_STEPCAFControl_ActorWrite
STEPCAFControl_ActorWrite_swigregister = _STEPCAFControl.STEPCAFControl_ActorWrite_swigregister
STEPCAFControl_ActorWrite_swigregister(STEPCAFControl_ActorWrite)

def STEPCAFControl_ActorWrite_get_type_name(*args):
    """
    STEPCAFControl_ActorWrite_get_type_name() -> char const *

    :rtype: const char *

    """
    return _STEPCAFControl.STEPCAFControl_ActorWrite_get_type_name(*args)

def STEPCAFControl_ActorWrite_get_type_descriptor(*args):
    """
    STEPCAFControl_ActorWrite_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _STEPCAFControl.STEPCAFControl_ActorWrite_get_type_descriptor(*args)

class STEPCAFControl_ExternFile(Standard.Standard_Transient):
    """
    Auxiliary class serving as container for data resulting
    from translation of external file
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_STEPCAFControl_ExternFile
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_STEPCAFControl_ExternFile(self) 
            return h


    def __init__(self, *args):
        """
        __init__(STEPCAFControl_ExternFile self) -> STEPCAFControl_ExternFile

        Creates an empty structure


        """
        this = _STEPCAFControl.new_STEPCAFControl_ExternFile(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def SetWS(self, *args):
        """
        SetWS(STEPCAFControl_ExternFile self, Handle_XSControl_WorkSession WS)

        :type WS: OCC.wrapper.XSControl.Handle_XSControl_WorkSession

        """
        return _STEPCAFControl.STEPCAFControl_ExternFile_SetWS(self, *args)


    def GetWS(self, *args):
        """
        GetWS(STEPCAFControl_ExternFile self) -> Handle_XSControl_WorkSession

        :rtype: OCC.wrapper.XSControl.Handle_XSControl_WorkSession

        """
        return _STEPCAFControl.STEPCAFControl_ExternFile_GetWS(self, *args)


    def SetLoadStatus(self, *args):
        """
        SetLoadStatus(STEPCAFControl_ExternFile self, IFSelect_ReturnStatus const stat)

        :type stat: OCC.wrapper.IFSelect.IFSelect_ReturnStatus

        """
        return _STEPCAFControl.STEPCAFControl_ExternFile_SetLoadStatus(self, *args)


    def GetLoadStatus(self, *args):
        """
        GetLoadStatus(STEPCAFControl_ExternFile self) -> IFSelect_ReturnStatus

        :rtype: OCC.wrapper.IFSelect.IFSelect_ReturnStatus

        """
        return _STEPCAFControl.STEPCAFControl_ExternFile_GetLoadStatus(self, *args)


    def SetTransferStatus(self, *args):
        """
        SetTransferStatus(STEPCAFControl_ExternFile self, Standard_Boolean const isok)

        :type isok: bool

        """
        return _STEPCAFControl.STEPCAFControl_ExternFile_SetTransferStatus(self, *args)


    def GetTransferStatus(self, *args):
        """
        GetTransferStatus(STEPCAFControl_ExternFile self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _STEPCAFControl.STEPCAFControl_ExternFile_GetTransferStatus(self, *args)


    def SetWriteStatus(self, *args):
        """
        SetWriteStatus(STEPCAFControl_ExternFile self, IFSelect_ReturnStatus const stat)

        :type stat: OCC.wrapper.IFSelect.IFSelect_ReturnStatus

        """
        return _STEPCAFControl.STEPCAFControl_ExternFile_SetWriteStatus(self, *args)


    def GetWriteStatus(self, *args):
        """
        GetWriteStatus(STEPCAFControl_ExternFile self) -> IFSelect_ReturnStatus

        :rtype: OCC.wrapper.IFSelect.IFSelect_ReturnStatus

        """
        return _STEPCAFControl.STEPCAFControl_ExternFile_GetWriteStatus(self, *args)


    def SetName(self, *args):
        """
        SetName(STEPCAFControl_ExternFile self, Handle_TCollection_HAsciiString name)

        :type name: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _STEPCAFControl.STEPCAFControl_ExternFile_SetName(self, *args)


    def GetName(self, *args):
        """
        GetName(STEPCAFControl_ExternFile self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _STEPCAFControl.STEPCAFControl_ExternFile_GetName(self, *args)


    def SetLabel(self, *args):
        """
        SetLabel(STEPCAFControl_ExternFile self, TDF_Label L)

        :type L: OCC.wrapper.TDF.TDF_Label

        """
        return _STEPCAFControl.STEPCAFControl_ExternFile_SetLabel(self, *args)


    def GetLabel(self, *args):
        """
        GetLabel(STEPCAFControl_ExternFile self) -> TDF_Label

        :rtype: OCC.wrapper.TDF.TDF_Label

        """
        return _STEPCAFControl.STEPCAFControl_ExternFile_GetLabel(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _STEPCAFControl.STEPCAFControl_ExternFile_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _STEPCAFControl.STEPCAFControl_ExternFile_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _STEPCAFControl.STEPCAFControl_ExternFile_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _STEPCAFControl.delete_STEPCAFControl_ExternFile
STEPCAFControl_ExternFile_swigregister = _STEPCAFControl.STEPCAFControl_ExternFile_swigregister
STEPCAFControl_ExternFile_swigregister(STEPCAFControl_ExternFile)

def STEPCAFControl_ExternFile_get_type_name(*args):
    """
    STEPCAFControl_ExternFile_get_type_name() -> char const *

    :rtype: const char *

    """
    return _STEPCAFControl.STEPCAFControl_ExternFile_get_type_name(*args)

def STEPCAFControl_ExternFile_get_type_descriptor(*args):
    """
    STEPCAFControl_ExternFile_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _STEPCAFControl.STEPCAFControl_ExternFile_get_type_descriptor(*args)

class STEPCAFControl_Controller(STEPControl.STEPControl_Controller):
    """
    Extends Controller from STEPControl in order to provide
    ActorWrite adapted for writing assemblies from DECAF
    Note that ActorRead from STEPControl is used for reading
    (inherited automatically)
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_STEPCAFControl_Controller
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_STEPCAFControl_Controller(self) 
            return h


    def __init__(self, *args):
        """
        __init__(STEPCAFControl_Controller self) -> STEPCAFControl_Controller

        Initializes the use of STEP Norm (the first time)


        """
        this = _STEPCAFControl.new_STEPCAFControl_Controller(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(*args):
        """
        Init() -> Standard_Boolean

        Standard Initialisation. It creates a Controller for STEP-XCAF
        and records it to various names, available to select it later
        Returns True when done, False if could not be done

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _STEPCAFControl.STEPCAFControl_Controller_Init(*args)

    Init = staticmethod(Init)

    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _STEPCAFControl.STEPCAFControl_Controller_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _STEPCAFControl.STEPCAFControl_Controller_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _STEPCAFControl.STEPCAFControl_Controller_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _STEPCAFControl.delete_STEPCAFControl_Controller
STEPCAFControl_Controller_swigregister = _STEPCAFControl.STEPCAFControl_Controller_swigregister
STEPCAFControl_Controller_swigregister(STEPCAFControl_Controller)

def STEPCAFControl_Controller_Init(*args):
    """
    STEPCAFControl_Controller_Init() -> Standard_Boolean

    Standard Initialisation. It creates a Controller for STEP-XCAF
    and records it to various names, available to select it later
    Returns True when done, False if could not be done

    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _STEPCAFControl.STEPCAFControl_Controller_Init(*args)

def STEPCAFControl_Controller_get_type_name(*args):
    """
    STEPCAFControl_Controller_get_type_name() -> char const *

    :rtype: const char *

    """
    return _STEPCAFControl.STEPCAFControl_Controller_get_type_name(*args)

def STEPCAFControl_Controller_get_type_descriptor(*args):
    """
    STEPCAFControl_Controller_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _STEPCAFControl.STEPCAFControl_Controller_get_type_descriptor(*args)

class Handle_STEPCAFControl_ExternFile(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_STEPCAFControl_ExternFile self)

        Nullify the handle


        """
        return _STEPCAFControl.Handle_STEPCAFControl_ExternFile_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_STEPCAFControl_ExternFile self) -> bool

        Check for being null

        :rtype: bool

        """
        return _STEPCAFControl.Handle_STEPCAFControl_ExternFile_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_STEPCAFControl_ExternFile self, STEPCAFControl_ExternFile thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _STEPCAFControl.Handle_STEPCAFControl_ExternFile_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_STEPCAFControl_ExternFile self, Handle_STEPCAFControl_ExternFile theHandle) -> Handle_STEPCAFControl_ExternFile
        assign(Handle_STEPCAFControl_ExternFile self, STEPCAFControl_ExternFile thePtr) -> Handle_STEPCAFControl_ExternFile
        assign(Handle_STEPCAFControl_ExternFile self, Handle_STEPCAFControl_ExternFile theHandle) -> Handle_STEPCAFControl_ExternFile

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _STEPCAFControl.Handle_STEPCAFControl_ExternFile_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_STEPCAFControl_ExternFile self) -> STEPCAFControl_ExternFile

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _STEPCAFControl.Handle_STEPCAFControl_ExternFile_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_STEPCAFControl_ExternFile self) -> STEPCAFControl_ExternFile

        Member access operator (note non-const)

        :rtype: T *

        """
        return _STEPCAFControl.Handle_STEPCAFControl_ExternFile___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_STEPCAFControl_ExternFile self) -> STEPCAFControl_ExternFile

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _STEPCAFControl.Handle_STEPCAFControl_ExternFile___ref__(self, *args)


    def __hash__(self):
        return _STEPCAFControl.Handle_STEPCAFControl_ExternFile___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _STEPCAFControl.Handle_STEPCAFControl_ExternFile___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _STEPCAFControl.new_Handle_STEPCAFControl_ExternFile(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_STEPCAFControl.Handle_STEPCAFControl_ExternFile_DownCast)
    __swig_destroy__ = _STEPCAFControl.delete_Handle_STEPCAFControl_ExternFile

    def SetWS(self, *args):
        """
        SetWS(Handle_STEPCAFControl_ExternFile self, Handle_XSControl_WorkSession WS)

        :type WS: OCC.wrapper.XSControl.Handle_XSControl_WorkSession

        """
        return _STEPCAFControl.Handle_STEPCAFControl_ExternFile_SetWS(self, *args)


    def GetWS(self, *args):
        """
        GetWS(Handle_STEPCAFControl_ExternFile self) -> Handle_XSControl_WorkSession

        :rtype: OCC.wrapper.XSControl.Handle_XSControl_WorkSession

        """
        return _STEPCAFControl.Handle_STEPCAFControl_ExternFile_GetWS(self, *args)


    def SetLoadStatus(self, *args):
        """
        SetLoadStatus(Handle_STEPCAFControl_ExternFile self, IFSelect_ReturnStatus const stat)

        :type stat: OCC.wrapper.IFSelect.IFSelect_ReturnStatus

        """
        return _STEPCAFControl.Handle_STEPCAFControl_ExternFile_SetLoadStatus(self, *args)


    def GetLoadStatus(self, *args):
        """
        GetLoadStatus(Handle_STEPCAFControl_ExternFile self) -> IFSelect_ReturnStatus

        :rtype: OCC.wrapper.IFSelect.IFSelect_ReturnStatus

        """
        return _STEPCAFControl.Handle_STEPCAFControl_ExternFile_GetLoadStatus(self, *args)


    def SetTransferStatus(self, *args):
        """
        SetTransferStatus(Handle_STEPCAFControl_ExternFile self, Standard_Boolean const isok)

        :type isok: bool

        """
        return _STEPCAFControl.Handle_STEPCAFControl_ExternFile_SetTransferStatus(self, *args)


    def GetTransferStatus(self, *args):
        """
        GetTransferStatus(Handle_STEPCAFControl_ExternFile self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _STEPCAFControl.Handle_STEPCAFControl_ExternFile_GetTransferStatus(self, *args)


    def SetWriteStatus(self, *args):
        """
        SetWriteStatus(Handle_STEPCAFControl_ExternFile self, IFSelect_ReturnStatus const stat)

        :type stat: OCC.wrapper.IFSelect.IFSelect_ReturnStatus

        """
        return _STEPCAFControl.Handle_STEPCAFControl_ExternFile_SetWriteStatus(self, *args)


    def GetWriteStatus(self, *args):
        """
        GetWriteStatus(Handle_STEPCAFControl_ExternFile self) -> IFSelect_ReturnStatus

        :rtype: OCC.wrapper.IFSelect.IFSelect_ReturnStatus

        """
        return _STEPCAFControl.Handle_STEPCAFControl_ExternFile_GetWriteStatus(self, *args)


    def SetName(self, *args):
        """
        SetName(Handle_STEPCAFControl_ExternFile self, Handle_TCollection_HAsciiString name)

        :type name: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _STEPCAFControl.Handle_STEPCAFControl_ExternFile_SetName(self, *args)


    def GetName(self, *args):
        """
        GetName(Handle_STEPCAFControl_ExternFile self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _STEPCAFControl.Handle_STEPCAFControl_ExternFile_GetName(self, *args)


    def SetLabel(self, *args):
        """
        SetLabel(Handle_STEPCAFControl_ExternFile self, TDF_Label L)

        :type L: OCC.wrapper.TDF.TDF_Label

        """
        return _STEPCAFControl.Handle_STEPCAFControl_ExternFile_SetLabel(self, *args)


    def GetLabel(self, *args):
        """
        GetLabel(Handle_STEPCAFControl_ExternFile self) -> TDF_Label

        :rtype: OCC.wrapper.TDF.TDF_Label

        """
        return _STEPCAFControl.Handle_STEPCAFControl_ExternFile_GetLabel(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_STEPCAFControl_ExternFile self) -> char const *

        :rtype: const char *

        """
        return _STEPCAFControl.Handle_STEPCAFControl_ExternFile_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _STEPCAFControl.Handle_STEPCAFControl_ExternFile_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _STEPCAFControl.Handle_STEPCAFControl_ExternFile_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_STEPCAFControl_ExternFile self)

        Memory deallocator for transient classes


        """
        return _STEPCAFControl.Handle_STEPCAFControl_ExternFile_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_STEPCAFControl_ExternFile self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_STEPCAFControl_ExternFile self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _STEPCAFControl.Handle_STEPCAFControl_ExternFile_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_STEPCAFControl_ExternFile self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_STEPCAFControl_ExternFile self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _STEPCAFControl.Handle_STEPCAFControl_ExternFile_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_STEPCAFControl_ExternFile self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _STEPCAFControl.Handle_STEPCAFControl_ExternFile_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_STEPCAFControl_ExternFile self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _STEPCAFControl.Handle_STEPCAFControl_ExternFile_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_STEPCAFControl_ExternFile self)

        Increments the reference counter of this object


        """
        return _STEPCAFControl.Handle_STEPCAFControl_ExternFile_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_STEPCAFControl_ExternFile self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _STEPCAFControl.Handle_STEPCAFControl_ExternFile_DecrementRefCounter(self, *args)

Handle_STEPCAFControl_ExternFile_swigregister = _STEPCAFControl.Handle_STEPCAFControl_ExternFile_swigregister
Handle_STEPCAFControl_ExternFile_swigregister(Handle_STEPCAFControl_ExternFile)

def Handle_STEPCAFControl_ExternFile_DownCast(thing):
    return _STEPCAFControl.Handle_STEPCAFControl_ExternFile_DownCast(thing)
Handle_STEPCAFControl_ExternFile_DownCast = _STEPCAFControl.Handle_STEPCAFControl_ExternFile_DownCast

class NCollection_DataMap_TDF_Label_TopoDS_Shape_TDF_LabelMapHasher(NCollection.NCollection_BaseMap):
    """
    Purpose:     The DataMap is a Map to store keys with associated
    Items. See Map  from NCollection for  a discussion
    about the number of buckets.

    The DataMap can be seen as an extended array where
    the Keys  are the   indices.  For this reason  the
    operator () is defined on DataMap to fetch an Item
    from a Key. So the following syntax can be used :

    anItem = aMap(aKey);
    aMap(aKey) = anItem;

    This analogy has its  limit.   aMap(aKey) = anItem
    can  be done only  if aKey was previously bound to
    an item in the map.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_DataMap_TDF_Label_TopoDS_Shape_TDF_LabelMapHasher self) -> NCollection_DataMap< TDF_Label,TopoDS_Shape,TDF_LabelMapHasher >::iterator

        Returns an iterator pointing to the first element in the map.

        :rtype: iterator

        """
        return _STEPCAFControl.NCollection_DataMap_TDF_Label_TopoDS_Shape_TDF_LabelMapHasher_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_DataMap_TDF_Label_TopoDS_Shape_TDF_LabelMapHasher self) -> NCollection_DataMap< TDF_Label,TopoDS_Shape,TDF_LabelMapHasher >::iterator

        Returns an iterator referring to the past-the-end element in the map.

        :rtype: iterator

        """
        return _STEPCAFControl.NCollection_DataMap_TDF_Label_TopoDS_Shape_TDF_LabelMapHasher_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_DataMap_TDF_Label_TopoDS_Shape_TDF_LabelMapHasher self) -> NCollection_DataMap< TDF_Label,TopoDS_Shape,TDF_LabelMapHasher >::const_iterator

        Returns a const iterator pointing to the first element in the map.

        :rtype: const_iterator

        """
        return _STEPCAFControl.NCollection_DataMap_TDF_Label_TopoDS_Shape_TDF_LabelMapHasher_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_DataMap_TDF_Label_TopoDS_Shape_TDF_LabelMapHasher self) -> NCollection_DataMap< TDF_Label,TopoDS_Shape,TDF_LabelMapHasher >::const_iterator

        Returns a const iterator referring to the past-the-end element in the map.

        :rtype: const_iterator

        """
        return _STEPCAFControl.NCollection_DataMap_TDF_Label_TopoDS_Shape_TDF_LabelMapHasher_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     The DataMap is a Map to store keys with associated
        Items. See Map  from NCollection for  a discussion
        about the number of buckets.

        The DataMap can be seen as an extended array where
        the Keys  are the   indices.  For this reason  the
        operator () is defined on DataMap to fetch an Item
        from a Key. So the following syntax can be used :

        anItem = aMap(aKey);
        aMap(aKey) = anItem;

        This analogy has its  limit.   aMap(aKey) = anItem
        can  be done only  if aKey was previously bound to
        an item in the map.
        """
        this = _STEPCAFControl.new_NCollection_DataMap_TDF_Label_TopoDS_Shape_TDF_LabelMapHasher(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Exchange(self, *args):
        """
        Exchange(NCollection_DataMap_TDF_Label_TopoDS_Shape_TDF_LabelMapHasher self, NCollection_DataMap_TDF_Label_TopoDS_Shape_TDF_LabelMapHasher theOther)

        Exchange the content of two maps without re-allocations.
        Notice that allocators will be swapped as well!

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _STEPCAFControl.NCollection_DataMap_TDF_Label_TopoDS_Shape_TDF_LabelMapHasher_Exchange(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_DataMap_TDF_Label_TopoDS_Shape_TDF_LabelMapHasher self, NCollection_DataMap_TDF_Label_TopoDS_Shape_TDF_LabelMapHasher theOther) -> NCollection_DataMap_TDF_Label_TopoDS_Shape_TDF_LabelMapHasher

        Assignment.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _STEPCAFControl.NCollection_DataMap_TDF_Label_TopoDS_Shape_TDF_LabelMapHasher_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_DataMap_TDF_Label_TopoDS_Shape_TDF_LabelMapHasher self, NCollection_DataMap_TDF_Label_TopoDS_Shape_TDF_LabelMapHasher theOther) -> NCollection_DataMap_TDF_Label_TopoDS_Shape_TDF_LabelMapHasher

        Assignment operator

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _STEPCAFControl.NCollection_DataMap_TDF_Label_TopoDS_Shape_TDF_LabelMapHasher_assign(self, *args)


    def ReSize(self, *args):
        """
        ReSize(NCollection_DataMap_TDF_Label_TopoDS_Shape_TDF_LabelMapHasher self, Standard_Integer const N)

        ReSize

        :type N: int

        """
        return _STEPCAFControl.NCollection_DataMap_TDF_Label_TopoDS_Shape_TDF_LabelMapHasher_ReSize(self, *args)


    def Bind(self, *args):
        """
        Bind(NCollection_DataMap_TDF_Label_TopoDS_Shape_TDF_LabelMapHasher self, TDF_Label theKey, TopoDS_Shape theItem) -> Standard_Boolean

        Bind binds Item to Key in map.
        @param theKey  key to add/update
        @param theItem new item; overrides value previously bound to the key, if any
        @return Standard_True if Key was not bound already

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _STEPCAFControl.NCollection_DataMap_TDF_Label_TopoDS_Shape_TDF_LabelMapHasher_Bind(self, *args)


    def Bound(self, *args):
        """
        Bound(NCollection_DataMap_TDF_Label_TopoDS_Shape_TDF_LabelMapHasher self, TDF_Label theKey, TopoDS_Shape theItem) -> TopoDS_Shape

        Bound binds Item to Key in map. Returns modifiable Item 

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: TheItemType *

        """
        return _STEPCAFControl.NCollection_DataMap_TDF_Label_TopoDS_Shape_TDF_LabelMapHasher_Bound(self, *args)


    def IsBound(self, *args):
        """
        IsBound(NCollection_DataMap_TDF_Label_TopoDS_Shape_TDF_LabelMapHasher self, TDF_Label theKey) -> Standard_Boolean

        IsBound

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _STEPCAFControl.NCollection_DataMap_TDF_Label_TopoDS_Shape_TDF_LabelMapHasher_IsBound(self, *args)


    def UnBind(self, *args):
        """
        UnBind(NCollection_DataMap_TDF_Label_TopoDS_Shape_TDF_LabelMapHasher self, TDF_Label theKey) -> Standard_Boolean

        UnBind removes Item Key pair from map

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _STEPCAFControl.NCollection_DataMap_TDF_Label_TopoDS_Shape_TDF_LabelMapHasher_UnBind(self, *args)


    def Seek(self, *args):
        """
        Seek(NCollection_DataMap_TDF_Label_TopoDS_Shape_TDF_LabelMapHasher self, TDF_Label theKey) -> TopoDS_Shape

        Seek returns pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: const TheItemType *

        """
        return _STEPCAFControl.NCollection_DataMap_TDF_Label_TopoDS_Shape_TDF_LabelMapHasher_Seek(self, *args)


    def Find(self, *args):
        """
        Find returns the Item for Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _STEPCAFControl.NCollection_DataMap_TDF_Label_TopoDS_Shape_TDF_LabelMapHasher_Find(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeSeek(self, *args):
        """
        ChangeSeek(NCollection_DataMap_TDF_Label_TopoDS_Shape_TDF_LabelMapHasher self, TDF_Label theKey) -> TopoDS_Shape

        ChangeSeek returns modifiable pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: TheItemType *

        """
        return _STEPCAFControl.NCollection_DataMap_TDF_Label_TopoDS_Shape_TDF_LabelMapHasher_ChangeSeek(self, *args)


    def ChangeFind(self, *args):
        """
        ChangeFind(NCollection_DataMap_TDF_Label_TopoDS_Shape_TDF_LabelMapHasher self, TDF_Label theKey) -> TopoDS_Shape

        ChangeFind returns mofifiable Item by Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: TheItemType &

        """
        return _STEPCAFControl.NCollection_DataMap_TDF_Label_TopoDS_Shape_TDF_LabelMapHasher_ChangeFind(self, *args)


    def __call__(self, *args):
        """
        operator ()

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _STEPCAFControl.NCollection_DataMap_TDF_Label_TopoDS_Shape_TDF_LabelMapHasher___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Clear(self, *args):
        """
        Clear(NCollection_DataMap_TDF_Label_TopoDS_Shape_TDF_LabelMapHasher self, Standard_Boolean const doReleaseMemory)
        Clear(NCollection_DataMap_TDF_Label_TopoDS_Shape_TDF_LabelMapHasher self, Handle_NCollection_BaseAllocator theAllocator)

        Clear data and reset allocator

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _STEPCAFControl.NCollection_DataMap_TDF_Label_TopoDS_Shape_TDF_LabelMapHasher_Clear(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_DataMap_TDF_Label_TopoDS_Shape_TDF_LabelMapHasher self) -> Standard_Integer

        Size

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _STEPCAFControl.NCollection_DataMap_TDF_Label_TopoDS_Shape_TDF_LabelMapHasher_Size(self, *args)


    def __iter__(self):
        return _STEPCAFControl.NCollection_DataMap_TDF_Label_TopoDS_Shape_TDF_LabelMapHasher___iter__(self)
    __swig_destroy__ = _STEPCAFControl.delete_NCollection_DataMap_TDF_Label_TopoDS_Shape_TDF_LabelMapHasher
NCollection_DataMap_TDF_Label_TopoDS_Shape_TDF_LabelMapHasher_swigregister = _STEPCAFControl.NCollection_DataMap_TDF_Label_TopoDS_Shape_TDF_LabelMapHasher_swigregister
NCollection_DataMap_TDF_Label_TopoDS_Shape_TDF_LabelMapHasher_swigregister(NCollection_DataMap_TDF_Label_TopoDS_Shape_TDF_LabelMapHasher)

class NCollection_DataMap_TDF_Label_TopoDS_Shape_TDF_LabelMapHasher_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _STEPCAFControl.new_NCollection_DataMap_TDF_Label_TopoDS_Shape_TDF_LabelMapHasher_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _STEPCAFControl.delete_NCollection_DataMap_TDF_Label_TopoDS_Shape_TDF_LabelMapHasher_IteratorHelper

    def __next__(self):
        return _STEPCAFControl.NCollection_DataMap_TDF_Label_TopoDS_Shape_TDF_LabelMapHasher_IteratorHelper___next__(self)
NCollection_DataMap_TDF_Label_TopoDS_Shape_TDF_LabelMapHasher_IteratorHelper_swigregister = _STEPCAFControl.NCollection_DataMap_TDF_Label_TopoDS_Shape_TDF_LabelMapHasher_IteratorHelper_swigregister
NCollection_DataMap_TDF_Label_TopoDS_Shape_TDF_LabelMapHasher_IteratorHelper_swigregister(NCollection_DataMap_TDF_Label_TopoDS_Shape_TDF_LabelMapHasher_IteratorHelper)


try:
	STEPCAFControl_DataMapOfLabelShape = NCollection_DataMap_TDF_Label_TopoDS_Shape_TDF_LabelMapHasher
except NameError:
	pass # does not exist, probably ignored

class Handle_STEPCAFControl_ActorWrite(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_STEPCAFControl_ActorWrite self)

        Nullify the handle


        """
        return _STEPCAFControl.Handle_STEPCAFControl_ActorWrite_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_STEPCAFControl_ActorWrite self) -> bool

        Check for being null

        :rtype: bool

        """
        return _STEPCAFControl.Handle_STEPCAFControl_ActorWrite_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_STEPCAFControl_ActorWrite self, STEPCAFControl_ActorWrite thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _STEPCAFControl.Handle_STEPCAFControl_ActorWrite_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_STEPCAFControl_ActorWrite self, Handle_STEPCAFControl_ActorWrite theHandle) -> Handle_STEPCAFControl_ActorWrite
        assign(Handle_STEPCAFControl_ActorWrite self, STEPCAFControl_ActorWrite thePtr) -> Handle_STEPCAFControl_ActorWrite
        assign(Handle_STEPCAFControl_ActorWrite self, Handle_STEPCAFControl_ActorWrite theHandle) -> Handle_STEPCAFControl_ActorWrite

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _STEPCAFControl.Handle_STEPCAFControl_ActorWrite_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_STEPCAFControl_ActorWrite self) -> STEPCAFControl_ActorWrite

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _STEPCAFControl.Handle_STEPCAFControl_ActorWrite_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_STEPCAFControl_ActorWrite self) -> STEPCAFControl_ActorWrite

        Member access operator (note non-const)

        :rtype: T *

        """
        return _STEPCAFControl.Handle_STEPCAFControl_ActorWrite___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_STEPCAFControl_ActorWrite self) -> STEPCAFControl_ActorWrite

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _STEPCAFControl.Handle_STEPCAFControl_ActorWrite___ref__(self, *args)


    def __hash__(self):
        return _STEPCAFControl.Handle_STEPCAFControl_ActorWrite___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _STEPCAFControl.Handle_STEPCAFControl_ActorWrite___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _STEPCAFControl.new_Handle_STEPCAFControl_ActorWrite(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_STEPCAFControl.Handle_STEPCAFControl_ActorWrite_DownCast)
    __swig_destroy__ = _STEPCAFControl.delete_Handle_STEPCAFControl_ActorWrite

    def IsAssembly(self, *args):
        """
        IsAssembly(Handle_STEPCAFControl_ActorWrite self, TopoDS_Shape S) -> Standard_Boolean

        Check whether shape S is assembly
        Returns True if shape is registered in assemblies map

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _STEPCAFControl.Handle_STEPCAFControl_ActorWrite_IsAssembly(self, *args)


    def SetStdMode(self, *args):
        """
        SetStdMode(Handle_STEPCAFControl_ActorWrite self, Standard_Boolean const stdmode)

        Set standard mode of work
        In standard mode Actor (default) behaves exactly as its
        ancestor, also map is cleared

        :type stdmode: bool

        """
        return _STEPCAFControl.Handle_STEPCAFControl_ActorWrite_SetStdMode(self, *args)


    def ClearMap(self, *args):
        """
        ClearMap(Handle_STEPCAFControl_ActorWrite self)

        Clears map of shapes registered as assemblies


        """
        return _STEPCAFControl.Handle_STEPCAFControl_ActorWrite_ClearMap(self, *args)


    def RegisterAssembly(self, *args):
        """
        RegisterAssembly(Handle_STEPCAFControl_ActorWrite self, TopoDS_Shape S)

        Registers shape to be written as assembly
        The shape should be TopoDS_Compound (else does nothing)

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _STEPCAFControl.Handle_STEPCAFControl_ActorWrite_RegisterAssembly(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_STEPCAFControl_ActorWrite self) -> char const *

        :rtype: const char *

        """
        return _STEPCAFControl.Handle_STEPCAFControl_ActorWrite_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _STEPCAFControl.Handle_STEPCAFControl_ActorWrite_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _STEPCAFControl.Handle_STEPCAFControl_ActorWrite_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Recognize(self, *args):
        """
        Recognize(Handle_STEPCAFControl_ActorWrite self, Handle_Transfer_Finder start) -> Standard_Boolean

        :type start: OCC.wrapper.Transfer.Handle_Transfer_Finder
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _STEPCAFControl.Handle_STEPCAFControl_ActorWrite_Recognize(self, *args)


    def Transfer(self, *args):
        """
        Transfer(Handle_STEPCAFControl_ActorWrite self, Handle_Transfer_Finder start, Handle_Transfer_FinderProcess FP)

        :type start: OCC.wrapper.Transfer.Handle_Transfer_Finder
        :type FP: OCC.wrapper.Transfer.Handle_Transfer_FinderProcess
        :rtype: OCC.wrapper.Transfer.Handle_Transfer_Binder

        """
        return _STEPCAFControl.Handle_STEPCAFControl_ActorWrite_Transfer(self, *args)


    def TransferSubShape(self, *args):
        """
        TransferSubShape(Handle_STEPCAFControl_ActorWrite self, Handle_Transfer_Finder start, Handle_StepShape_ShapeDefinitionRepresentation SDR, Handle_StepGeom_Axis2Placement3d AX1, Handle_Transfer_FinderProcess FP, Handle_TopTools_HSequenceOfShape shapeGroup=0, Standard_Boolean const isManifold)

        :type start: OCC.wrapper.Transfer.Handle_Transfer_Finder
        :type SDR: OCC.wrapper.StepShape.Handle_StepShape_ShapeDefinitionRepresentation
        :type AX1: OCC.wrapper.STEPControl.Handle_StepGeom_Axis2Placement3d
        :type FP: OCC.wrapper.Transfer.Handle_Transfer_FinderProcess
        :type shapeGroup: OCC.wrapper.TopTools.Handle_TopTools_HSequenceOfShape
        :type isManifold: bool
        :rtype: OCC.wrapper.Transfer.Handle_Transfer_Binder

        """
        return _STEPCAFControl.Handle_STEPCAFControl_ActorWrite_TransferSubShape(self, *args)


    def TransferShape(self, *args):
        """
        TransferShape(Handle_STEPCAFControl_ActorWrite self, Handle_Transfer_Finder start, Handle_StepShape_ShapeDefinitionRepresentation SDR, Handle_Transfer_FinderProcess FP, Handle_TopTools_HSequenceOfShape shapeGroup=0, Standard_Boolean const isManifold)

        :type start: OCC.wrapper.Transfer.Handle_Transfer_Finder
        :type SDR: OCC.wrapper.StepShape.Handle_StepShape_ShapeDefinitionRepresentation
        :type FP: OCC.wrapper.Transfer.Handle_Transfer_FinderProcess
        :type shapeGroup: OCC.wrapper.TopTools.Handle_TopTools_HSequenceOfShape
        :type isManifold: bool
        :rtype: OCC.wrapper.Transfer.Handle_Transfer_Binder

        """
        return _STEPCAFControl.Handle_STEPCAFControl_ActorWrite_TransferShape(self, *args)


    def TransferCompound(self, *args):
        """
        TransferCompound(Handle_STEPCAFControl_ActorWrite self, Handle_Transfer_Finder start, Handle_StepShape_ShapeDefinitionRepresentation SDR, Handle_Transfer_FinderProcess FP)

        :type start: OCC.wrapper.Transfer.Handle_Transfer_Finder
        :type SDR: OCC.wrapper.StepShape.Handle_StepShape_ShapeDefinitionRepresentation
        :type FP: OCC.wrapper.Transfer.Handle_Transfer_FinderProcess
        :rtype: OCC.wrapper.Transfer.Handle_Transfer_Binder

        """
        return _STEPCAFControl.Handle_STEPCAFControl_ActorWrite_TransferCompound(self, *args)


    def SetMode(self, *args):
        """
        SetMode(Handle_STEPCAFControl_ActorWrite self, STEPControl_StepModelType const M)

        :type M: OCC.wrapper.STEPControl.STEPControl_StepModelType

        """
        return _STEPCAFControl.Handle_STEPCAFControl_ActorWrite_SetMode(self, *args)


    def Mode(self, *args):
        """
        Mode(Handle_STEPCAFControl_ActorWrite self) -> STEPControl_StepModelType

        :rtype: OCC.wrapper.STEPControl.STEPControl_StepModelType

        """
        return _STEPCAFControl.Handle_STEPCAFControl_ActorWrite_Mode(self, *args)


    def SetGroupMode(self, *args):
        """
        SetGroupMode(Handle_STEPCAFControl_ActorWrite self, Standard_Integer const mode)

        :type mode: int

        """
        return _STEPCAFControl.Handle_STEPCAFControl_ActorWrite_SetGroupMode(self, *args)


    def GroupMode(self, *args):
        """
        GroupMode(Handle_STEPCAFControl_ActorWrite self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _STEPCAFControl.Handle_STEPCAFControl_ActorWrite_GroupMode(self, *args)


    def SetTolerance(self, *args):
        """
        SetTolerance(Handle_STEPCAFControl_ActorWrite self, Standard_Real const Tol)

        :type Tol: float

        """
        return _STEPCAFControl.Handle_STEPCAFControl_ActorWrite_SetTolerance(self, *args)


    def ModeTrans(self, *args):
        """
        ModeTrans(Handle_STEPCAFControl_ActorWrite self) -> Standard_Integer &

        Returns the Transfer Mode, modifiable

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _STEPCAFControl.Handle_STEPCAFControl_ActorWrite_ModeTrans(self, *args)


    def Transferring(self, *args):
        """
        Transferring(Handle_STEPCAFControl_ActorWrite self, Handle_Transfer_Finder start, Handle_Transfer_ProcessForFinder TP)

        :type start: OCC.wrapper.Transfer.Handle_Transfer_Finder
        :type TP: OCC.wrapper.Transfer.Handle_Transfer_ProcessForFinder
        :rtype: OCC.wrapper.Transfer.Handle_Transfer_Binder

        """
        return _STEPCAFControl.Handle_STEPCAFControl_ActorWrite_Transferring(self, *args)


    def TransferTransient(self, *args):
        """
        TransferTransient(Handle_STEPCAFControl_ActorWrite self, Handle_Standard_Transient start, Handle_Transfer_FinderProcess TP) -> Handle_Standard_Transient

        :type start: OCC.wrapper.Standard.Handle_Standard_Transient
        :type TP: OCC.wrapper.Transfer.Handle_Transfer_FinderProcess
        :rtype: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _STEPCAFControl.Handle_STEPCAFControl_ActorWrite_TransferTransient(self, *args)


    def TransientResult(self, *args):
        """
        TransientResult(Handle_STEPCAFControl_ActorWrite self, Handle_Standard_Transient res) -> Handle_Transfer_SimpleBinderOfTransient

        Prepares and Returns a Binder for a Transient Result
        Returns a Null Handle if <res> is itself Null

        :type res: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Transfer.Handle_Transfer_SimpleBinderOfTransient

        """
        return _STEPCAFControl.Handle_STEPCAFControl_ActorWrite_TransientResult(self, *args)


    def NullResult(self, *args):
        """
        NullResult(Handle_STEPCAFControl_ActorWrite self)

        Returns a Binder for No Result, i.e. a Null Handle

        :rtype: OCC.wrapper.Transfer.Handle_Transfer_Binder

        """
        return _STEPCAFControl.Handle_STEPCAFControl_ActorWrite_NullResult(self, *args)


    def SetLast(self, *args):
        """
        SetLast(Handle_STEPCAFControl_ActorWrite self, Standard_Boolean const mode)

        If <mode> is True, commands an Actor to be set at the
        end of the list of Actors (see SetNext)
        If it is False (creation default), each add Actor is
        set at the beginning of the list
        This allows to define default Actors (which are Last)

        :type mode: bool

        """
        return _STEPCAFControl.Handle_STEPCAFControl_ActorWrite_SetLast(self, *args)


    def IsLast(self, *args):
        """
        IsLast(Handle_STEPCAFControl_ActorWrite self) -> Standard_Boolean

        Returns the Last status (see SetLast).

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _STEPCAFControl.Handle_STEPCAFControl_ActorWrite_IsLast(self, *args)


    def SetNext(self, *args):
        """
        SetNext(Handle_STEPCAFControl_ActorWrite self, Handle_Transfer_ActorOfProcessForFinder next)

        Defines a Next Actor : it can then be asked to work if
        <me> produces no result for a given type of Object.
        If Next is already set and is not "Last", calls
        SetNext on it. If Next defined and "Last", the new
        actor is added before it in the list

        :type next: OCC.wrapper.Transfer.Handle_Transfer_ActorOfProcessForFinder

        """
        return _STEPCAFControl.Handle_STEPCAFControl_ActorWrite_SetNext(self, *args)


    def Next(self, *args):
        """
        Next(Handle_STEPCAFControl_ActorWrite self) -> Handle_Transfer_ActorOfProcessForFinder

        Returns the Actor defined as Next, or a Null Handle

        :rtype: OCC.wrapper.Transfer.Handle_Transfer_ActorOfProcessForFinder

        """
        return _STEPCAFControl.Handle_STEPCAFControl_ActorWrite_Next(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_STEPCAFControl_ActorWrite self)

        Memory deallocator for transient classes


        """
        return _STEPCAFControl.Handle_STEPCAFControl_ActorWrite_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_STEPCAFControl_ActorWrite self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_STEPCAFControl_ActorWrite self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _STEPCAFControl.Handle_STEPCAFControl_ActorWrite_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_STEPCAFControl_ActorWrite self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_STEPCAFControl_ActorWrite self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _STEPCAFControl.Handle_STEPCAFControl_ActorWrite_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_STEPCAFControl_ActorWrite self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _STEPCAFControl.Handle_STEPCAFControl_ActorWrite_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_STEPCAFControl_ActorWrite self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _STEPCAFControl.Handle_STEPCAFControl_ActorWrite_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_STEPCAFControl_ActorWrite self)

        Increments the reference counter of this object


        """
        return _STEPCAFControl.Handle_STEPCAFControl_ActorWrite_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_STEPCAFControl_ActorWrite self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _STEPCAFControl.Handle_STEPCAFControl_ActorWrite_DecrementRefCounter(self, *args)

Handle_STEPCAFControl_ActorWrite_swigregister = _STEPCAFControl.Handle_STEPCAFControl_ActorWrite_swigregister
Handle_STEPCAFControl_ActorWrite_swigregister(Handle_STEPCAFControl_ActorWrite)

def Handle_STEPCAFControl_ActorWrite_DownCast(thing):
    return _STEPCAFControl.Handle_STEPCAFControl_ActorWrite_DownCast(thing)
Handle_STEPCAFControl_ActorWrite_DownCast = _STEPCAFControl.Handle_STEPCAFControl_ActorWrite_DownCast


try:
	TColStd_MapTransientHasher = TColStd.NCollection_DefaultHasher_Handle_Standard_Transient
except AttributeError:
	pass # does not exist, probably ignored

class STEPCAFControl_Reader(object):
    """
    Provides a tool to read STEP file and put it into
    DECAF document. Besides transfer of shapes (including
    assemblies) provided by STEPControl, supports also
    colors and part names

    This reader supports reading files with external references
    i.e. multifile reading
    It behaves as usual Reader (from STEPControl) for the main
    file (e.g. if it is single file)
    Results of reading other files can be accessed by name of the
    file or by iterating on a readers
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(STEPCAFControl_Reader self) -> STEPCAFControl_Reader
        __init__(STEPCAFControl_Reader self, Handle_XSControl_WorkSession WS, Standard_Boolean const scratch) -> STEPCAFControl_Reader

        Creates a reader tool and attaches it to an already existing Session
        Clears the session if it was not yet set for STEP

        :type WS: OCC.wrapper.XSControl.Handle_XSControl_WorkSession
        :type scratch: bool

        """
        this = _STEPCAFControl.new_STEPCAFControl_Reader(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(STEPCAFControl_Reader self, Handle_XSControl_WorkSession WS, Standard_Boolean const scratch)

        Clears the internal data structures and attaches to a new session
        Clears the session if it was not yet set for STEP

        :type WS: OCC.wrapper.XSControl.Handle_XSControl_WorkSession
        :type scratch: bool

        """
        return _STEPCAFControl.STEPCAFControl_Reader_Init(self, *args)


    def ReadFile(self, *args):
        """
        ReadFile(STEPCAFControl_Reader self, Standard_CString const filename) -> IFSelect_ReturnStatus

        Loads a file and returns the read status
        Provided for use like single-file reader

        :type filename: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.IFSelect.IFSelect_ReturnStatus

        """
        return _STEPCAFControl.STEPCAFControl_Reader_ReadFile(self, *args)


    def NbRootsForTransfer(self, *args):
        """
        NbRootsForTransfer(STEPCAFControl_Reader self) -> Standard_Integer

        Returns number of roots recognized for transfer
        Shortcut for Reader().NbRootsForTransfer()

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _STEPCAFControl.STEPCAFControl_Reader_NbRootsForTransfer(self, *args)


    def TransferOneRoot(self, *args):
        """
        TransferOneRoot(STEPCAFControl_Reader self, Standard_Integer const num, Handle_TDocStd_Document doc) -> Standard_Boolean

        Translates currently loaded STEP file into the document
        Returns True if succeeded, and False in case of fail
        Provided for use like single-file reader

        :type num: int
        :type doc: OCC.wrapper.TDocStd.Handle_TDocStd_Document
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _STEPCAFControl.STEPCAFControl_Reader_TransferOneRoot(self, *args)


    def Transfer(self, *args):
        """
        Transfer(STEPCAFControl_Reader self, Handle_TDocStd_Document doc) -> Standard_Boolean

        Translates currently loaded STEP file into the document
        Returns True if succeeded, and False in case of fail
        Provided for use like single-file reader

        :type doc: OCC.wrapper.TDocStd.Handle_TDocStd_Document
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _STEPCAFControl.STEPCAFControl_Reader_Transfer(self, *args)


    def Perform(self, *args):
        """
        Perform(STEPCAFControl_Reader self, TCollection_AsciiString filename, Handle_TDocStd_Document doc) -> Standard_Boolean
        Perform(STEPCAFControl_Reader self, Standard_CString const filename, Handle_TDocStd_Document doc) -> Standard_Boolean

        Translate STEP file given by filename into the document
        Return True if succeeded, and False in case of fail

        :type filename: OCC.wrapper.Standard.Standard_CString
        :type doc: OCC.wrapper.TDocStd.Handle_TDocStd_Document
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _STEPCAFControl.STEPCAFControl_Reader_Perform(self, *args)


    def ExternFiles(self, *args):
        """
        Returns data on external files
        Returns Null handle if no external files are read

        :rtype: OCC.wrapper.STEPCAFControl.NCollection_DataMap_TCollection_AsciiString_Handle_STEPCAFControl_ExternFile

        """
        res = _STEPCAFControl.STEPCAFControl_Reader_ExternFiles(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ExternFile(self, *args):
        """
        ExternFile(STEPCAFControl_Reader self, Standard_CString const name, Handle_STEPCAFControl_ExternFile ef) -> Standard_Boolean

        Returns data on external file by its name
        Returns False if no external file with given name is read

        :type name: OCC.wrapper.Standard.Standard_CString
        :type ef: OCC.wrapper.STEPCAFControl.Handle_STEPCAFControl_ExternFile
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _STEPCAFControl.STEPCAFControl_Reader_ExternFile(self, *args)


    def ChangeReader(self, *args):
        """
        ChangeReader(STEPCAFControl_Reader self) -> STEPControl_Reader

        Returns basic reader

        :rtype: OCC.wrapper.STEPControl.STEPControl_Reader

        """
        return _STEPCAFControl.STEPCAFControl_Reader_ChangeReader(self, *args)


    def Reader(self, *args):
        """
        Returns basic reader as const

        :rtype: OCC.wrapper.STEPControl.STEPControl_Reader

        """
        res = _STEPCAFControl.STEPCAFControl_Reader_Reader(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def FindInstance(*args):
        """
        FindInstance(Handle_StepRepr_NextAssemblyUsageOccurrence NAUO, Handle_XCAFDoc_ShapeTool STool, STEPConstruct_Tool Tool, NCollection_DataMap_Handle_StepBasic_ProductDefinition_Handle_STEPCAFControl_ExternFile_TColStd_MapTransientHasher PDRFileMap, NCollection_DataMap_TopoDS_Shape_TDF_Label_TopTools_ShapeMapHasher ShapeLabelMap) -> TDF_Label

        Returns label of instance of an assembly component
        corresponding to a given NAUO

        :type NAUO: OCC.wrapper.StepRepr.Handle_StepRepr_NextAssemblyUsageOccurrence
        :type STool: OCC.wrapper.XCAFDoc.Handle_XCAFDoc_ShapeTool
        :type Tool: OCC.wrapper.STEPConstruct.STEPConstruct_Tool
        :type PDRFileMap: OCC.wrapper.STEPCAFControl.STEPCAFControl_DataMapOfPDExternFile
        :type ShapeLabelMap: OCC.wrapper.XCAFDoc.XCAFDoc_DataMapOfShapeLabel
        :rtype: OCC.wrapper.TDF.TDF_Label

        """
        return _STEPCAFControl.STEPCAFControl_Reader_FindInstance(*args)

    FindInstance = staticmethod(FindInstance)

    def SetColorMode(self, *args):
        """
        SetColorMode(STEPCAFControl_Reader self, Standard_Boolean const colormode)

        Set ColorMode for indicate read Colors or not.

        :type colormode: bool

        """
        return _STEPCAFControl.STEPCAFControl_Reader_SetColorMode(self, *args)


    def GetColorMode(self, *args):
        """
        GetColorMode(STEPCAFControl_Reader self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _STEPCAFControl.STEPCAFControl_Reader_GetColorMode(self, *args)


    def SetNameMode(self, *args):
        """
        SetNameMode(STEPCAFControl_Reader self, Standard_Boolean const namemode)

        Set NameMode for indicate read Name or not.

        :type namemode: bool

        """
        return _STEPCAFControl.STEPCAFControl_Reader_SetNameMode(self, *args)


    def GetNameMode(self, *args):
        """
        GetNameMode(STEPCAFControl_Reader self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _STEPCAFControl.STEPCAFControl_Reader_GetNameMode(self, *args)


    def SetLayerMode(self, *args):
        """
        SetLayerMode(STEPCAFControl_Reader self, Standard_Boolean const layermode)

        Set LayerMode for indicate read Layers or not.

        :type layermode: bool

        """
        return _STEPCAFControl.STEPCAFControl_Reader_SetLayerMode(self, *args)


    def GetLayerMode(self, *args):
        """
        GetLayerMode(STEPCAFControl_Reader self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _STEPCAFControl.STEPCAFControl_Reader_GetLayerMode(self, *args)


    def SetPropsMode(self, *args):
        """
        SetPropsMode(STEPCAFControl_Reader self, Standard_Boolean const propsmode)

        PropsMode for indicate read Validation properties or not.

        :type propsmode: bool

        """
        return _STEPCAFControl.STEPCAFControl_Reader_SetPropsMode(self, *args)


    def GetPropsMode(self, *args):
        """
        GetPropsMode(STEPCAFControl_Reader self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _STEPCAFControl.STEPCAFControl_Reader_GetPropsMode(self, *args)


    def SetSHUOMode(self, *args):
        """
        SetSHUOMode(STEPCAFControl_Reader self, Standard_Boolean const shuomode)

        Set SHUO mode for indicate write SHUO or not.

        :type shuomode: bool

        """
        return _STEPCAFControl.STEPCAFControl_Reader_SetSHUOMode(self, *args)


    def GetSHUOMode(self, *args):
        """
        GetSHUOMode(STEPCAFControl_Reader self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _STEPCAFControl.STEPCAFControl_Reader_GetSHUOMode(self, *args)


    def SetGDTMode(self, *args):
        """
        SetGDTMode(STEPCAFControl_Reader self, Standard_Boolean const gdtmode)

        Set GDT mode for indicate write GDT or not.

        :type gdtmode: bool

        """
        return _STEPCAFControl.STEPCAFControl_Reader_SetGDTMode(self, *args)


    def GetGDTMode(self, *args):
        """
        GetGDTMode(STEPCAFControl_Reader self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _STEPCAFControl.STEPCAFControl_Reader_GetGDTMode(self, *args)


    def SetMatMode(self, *args):
        """
        SetMatMode(STEPCAFControl_Reader self, Standard_Boolean const matmode)

        Set Material mode

        :type matmode: bool

        """
        return _STEPCAFControl.STEPCAFControl_Reader_SetMatMode(self, *args)


    def GetMatMode(self, *args):
        """
        GetMatMode(STEPCAFControl_Reader self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _STEPCAFControl.STEPCAFControl_Reader_GetMatMode(self, *args)


    def SetViewMode(self, *args):
        """
        SetViewMode(STEPCAFControl_Reader self, Standard_Boolean const viewmode)

        Set View mode

        :type viewmode: bool

        """
        return _STEPCAFControl.STEPCAFControl_Reader_SetViewMode(self, *args)


    def GetViewMode(self, *args):
        """
        GetViewMode(STEPCAFControl_Reader self) -> Standard_Boolean

        Get View mode

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _STEPCAFControl.STEPCAFControl_Reader_GetViewMode(self, *args)

    __swig_destroy__ = _STEPCAFControl.delete_STEPCAFControl_Reader
STEPCAFControl_Reader_swigregister = _STEPCAFControl.STEPCAFControl_Reader_swigregister
STEPCAFControl_Reader_swigregister(STEPCAFControl_Reader)

def STEPCAFControl_Reader_FindInstance(*args):
    """
    STEPCAFControl_Reader_FindInstance(Handle_StepRepr_NextAssemblyUsageOccurrence NAUO, Handle_XCAFDoc_ShapeTool STool, STEPConstruct_Tool Tool, NCollection_DataMap_Handle_StepBasic_ProductDefinition_Handle_STEPCAFControl_ExternFile_TColStd_MapTransientHasher PDRFileMap, NCollection_DataMap_TopoDS_Shape_TDF_Label_TopTools_ShapeMapHasher ShapeLabelMap) -> TDF_Label

    Returns label of instance of an assembly component
    corresponding to a given NAUO

    :type NAUO: OCC.wrapper.StepRepr.Handle_StepRepr_NextAssemblyUsageOccurrence
    :type STool: OCC.wrapper.XCAFDoc.Handle_XCAFDoc_ShapeTool
    :type Tool: OCC.wrapper.STEPConstruct.STEPConstruct_Tool
    :type PDRFileMap: OCC.wrapper.STEPCAFControl.STEPCAFControl_DataMapOfPDExternFile
    :type ShapeLabelMap: OCC.wrapper.XCAFDoc.XCAFDoc_DataMapOfShapeLabel
    :rtype: OCC.wrapper.TDF.TDF_Label

    """
    return _STEPCAFControl.STEPCAFControl_Reader_FindInstance(*args)

class NCollection_DataMap_TopoDS_Shape_Handle_StepShape_ShapeDefinitionRepresentation_TopTools_ShapeMapHasher(NCollection.NCollection_BaseMap):
    """
    Purpose:     The DataMap is a Map to store keys with associated
    Items. See Map  from NCollection for  a discussion
    about the number of buckets.

    The DataMap can be seen as an extended array where
    the Keys  are the   indices.  For this reason  the
    operator () is defined on DataMap to fetch an Item
    from a Key. So the following syntax can be used :

    anItem = aMap(aKey);
    aMap(aKey) = anItem;

    This analogy has its  limit.   aMap(aKey) = anItem
    can  be done only  if aKey was previously bound to
    an item in the map.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_DataMap_TopoDS_Shape_Handle_StepShape_ShapeDefinitionRepresentation_TopTools_ShapeMapHasher self) -> NCollection_DataMap< TopoDS_Shape,opencascade::handle< StepShape_ShapeDefinitionRepresentation >,TopTools_ShapeMapHasher >::iterator

        Returns an iterator pointing to the first element in the map.

        :rtype: iterator

        """
        return _STEPCAFControl.NCollection_DataMap_TopoDS_Shape_Handle_StepShape_ShapeDefinitionRepresentation_TopTools_ShapeMapHasher_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_DataMap_TopoDS_Shape_Handle_StepShape_ShapeDefinitionRepresentation_TopTools_ShapeMapHasher self) -> NCollection_DataMap< TopoDS_Shape,opencascade::handle< StepShape_ShapeDefinitionRepresentation >,TopTools_ShapeMapHasher >::iterator

        Returns an iterator referring to the past-the-end element in the map.

        :rtype: iterator

        """
        return _STEPCAFControl.NCollection_DataMap_TopoDS_Shape_Handle_StepShape_ShapeDefinitionRepresentation_TopTools_ShapeMapHasher_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_DataMap_TopoDS_Shape_Handle_StepShape_ShapeDefinitionRepresentation_TopTools_ShapeMapHasher self) -> NCollection_DataMap< TopoDS_Shape,opencascade::handle< StepShape_ShapeDefinitionRepresentation >,TopTools_ShapeMapHasher >::const_iterator

        Returns a const iterator pointing to the first element in the map.

        :rtype: const_iterator

        """
        return _STEPCAFControl.NCollection_DataMap_TopoDS_Shape_Handle_StepShape_ShapeDefinitionRepresentation_TopTools_ShapeMapHasher_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_DataMap_TopoDS_Shape_Handle_StepShape_ShapeDefinitionRepresentation_TopTools_ShapeMapHasher self) -> NCollection_DataMap< TopoDS_Shape,opencascade::handle< StepShape_ShapeDefinitionRepresentation >,TopTools_ShapeMapHasher >::const_iterator

        Returns a const iterator referring to the past-the-end element in the map.

        :rtype: const_iterator

        """
        return _STEPCAFControl.NCollection_DataMap_TopoDS_Shape_Handle_StepShape_ShapeDefinitionRepresentation_TopTools_ShapeMapHasher_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     The DataMap is a Map to store keys with associated
        Items. See Map  from NCollection for  a discussion
        about the number of buckets.

        The DataMap can be seen as an extended array where
        the Keys  are the   indices.  For this reason  the
        operator () is defined on DataMap to fetch an Item
        from a Key. So the following syntax can be used :

        anItem = aMap(aKey);
        aMap(aKey) = anItem;

        This analogy has its  limit.   aMap(aKey) = anItem
        can  be done only  if aKey was previously bound to
        an item in the map.
        """
        this = _STEPCAFControl.new_NCollection_DataMap_TopoDS_Shape_Handle_StepShape_ShapeDefinitionRepresentation_TopTools_ShapeMapHasher(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Exchange(self, *args):
        """
        Exchange(NCollection_DataMap_TopoDS_Shape_Handle_StepShape_ShapeDefinitionRepresentation_TopTools_ShapeMapHasher self, NCollection_DataMap_TopoDS_Shape_Handle_StepShape_ShapeDefinitionRepresentation_TopTools_ShapeMapHasher theOther)

        Exchange the content of two maps without re-allocations.
        Notice that allocators will be swapped as well!

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _STEPCAFControl.NCollection_DataMap_TopoDS_Shape_Handle_StepShape_ShapeDefinitionRepresentation_TopTools_ShapeMapHasher_Exchange(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_DataMap_TopoDS_Shape_Handle_StepShape_ShapeDefinitionRepresentation_TopTools_ShapeMapHasher self, NCollection_DataMap_TopoDS_Shape_Handle_StepShape_ShapeDefinitionRepresentation_TopTools_ShapeMapHasher theOther) -> NCollection_DataMap_TopoDS_Shape_Handle_StepShape_ShapeDefinitionRepresentation_TopTools_ShapeMapHasher

        Assignment.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _STEPCAFControl.NCollection_DataMap_TopoDS_Shape_Handle_StepShape_ShapeDefinitionRepresentation_TopTools_ShapeMapHasher_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_DataMap_TopoDS_Shape_Handle_StepShape_ShapeDefinitionRepresentation_TopTools_ShapeMapHasher self, NCollection_DataMap_TopoDS_Shape_Handle_StepShape_ShapeDefinitionRepresentation_TopTools_ShapeMapHasher theOther) -> NCollection_DataMap_TopoDS_Shape_Handle_StepShape_ShapeDefinitionRepresentation_TopTools_ShapeMapHasher

        Assignment operator

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _STEPCAFControl.NCollection_DataMap_TopoDS_Shape_Handle_StepShape_ShapeDefinitionRepresentation_TopTools_ShapeMapHasher_assign(self, *args)


    def ReSize(self, *args):
        """
        ReSize(NCollection_DataMap_TopoDS_Shape_Handle_StepShape_ShapeDefinitionRepresentation_TopTools_ShapeMapHasher self, Standard_Integer const N)

        ReSize

        :type N: int

        """
        return _STEPCAFControl.NCollection_DataMap_TopoDS_Shape_Handle_StepShape_ShapeDefinitionRepresentation_TopTools_ShapeMapHasher_ReSize(self, *args)


    def Bind(self, *args):
        """
        Bind(NCollection_DataMap_TopoDS_Shape_Handle_StepShape_ShapeDefinitionRepresentation_TopTools_ShapeMapHasher self, TopoDS_Shape theKey, Handle_StepShape_ShapeDefinitionRepresentation theItem) -> Standard_Boolean

        Bind binds Item to Key in map.
        @param theKey  key to add/update
        @param theItem new item; overrides value previously bound to the key, if any
        @return Standard_True if Key was not bound already

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _STEPCAFControl.NCollection_DataMap_TopoDS_Shape_Handle_StepShape_ShapeDefinitionRepresentation_TopTools_ShapeMapHasher_Bind(self, *args)


    def Bound(self, *args):
        """
        Bound(NCollection_DataMap_TopoDS_Shape_Handle_StepShape_ShapeDefinitionRepresentation_TopTools_ShapeMapHasher self, TopoDS_Shape theKey, Handle_StepShape_ShapeDefinitionRepresentation theItem) -> Handle_StepShape_ShapeDefinitionRepresentation

        Bound binds Item to Key in map. Returns modifiable Item 

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: TheItemType *

        """
        return _STEPCAFControl.NCollection_DataMap_TopoDS_Shape_Handle_StepShape_ShapeDefinitionRepresentation_TopTools_ShapeMapHasher_Bound(self, *args)


    def IsBound(self, *args):
        """
        IsBound(NCollection_DataMap_TopoDS_Shape_Handle_StepShape_ShapeDefinitionRepresentation_TopTools_ShapeMapHasher self, TopoDS_Shape theKey) -> Standard_Boolean

        IsBound

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _STEPCAFControl.NCollection_DataMap_TopoDS_Shape_Handle_StepShape_ShapeDefinitionRepresentation_TopTools_ShapeMapHasher_IsBound(self, *args)


    def UnBind(self, *args):
        """
        UnBind(NCollection_DataMap_TopoDS_Shape_Handle_StepShape_ShapeDefinitionRepresentation_TopTools_ShapeMapHasher self, TopoDS_Shape theKey) -> Standard_Boolean

        UnBind removes Item Key pair from map

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _STEPCAFControl.NCollection_DataMap_TopoDS_Shape_Handle_StepShape_ShapeDefinitionRepresentation_TopTools_ShapeMapHasher_UnBind(self, *args)


    def Seek(self, *args):
        """
        Seek(NCollection_DataMap_TopoDS_Shape_Handle_StepShape_ShapeDefinitionRepresentation_TopTools_ShapeMapHasher self, TopoDS_Shape theKey) -> Handle_StepShape_ShapeDefinitionRepresentation

        Seek returns pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: const TheItemType *

        """
        return _STEPCAFControl.NCollection_DataMap_TopoDS_Shape_Handle_StepShape_ShapeDefinitionRepresentation_TopTools_ShapeMapHasher_Seek(self, *args)


    def Find(self, *args):
        """
        Find returns the Item for Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _STEPCAFControl.NCollection_DataMap_TopoDS_Shape_Handle_StepShape_ShapeDefinitionRepresentation_TopTools_ShapeMapHasher_Find(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeSeek(self, *args):
        """
        ChangeSeek(NCollection_DataMap_TopoDS_Shape_Handle_StepShape_ShapeDefinitionRepresentation_TopTools_ShapeMapHasher self, TopoDS_Shape theKey) -> Handle_StepShape_ShapeDefinitionRepresentation

        ChangeSeek returns modifiable pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: TheItemType *

        """
        return _STEPCAFControl.NCollection_DataMap_TopoDS_Shape_Handle_StepShape_ShapeDefinitionRepresentation_TopTools_ShapeMapHasher_ChangeSeek(self, *args)


    def ChangeFind(self, *args):
        """
        ChangeFind(NCollection_DataMap_TopoDS_Shape_Handle_StepShape_ShapeDefinitionRepresentation_TopTools_ShapeMapHasher self, TopoDS_Shape theKey) -> Handle_StepShape_ShapeDefinitionRepresentation

        ChangeFind returns mofifiable Item by Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: TheItemType &

        """
        return _STEPCAFControl.NCollection_DataMap_TopoDS_Shape_Handle_StepShape_ShapeDefinitionRepresentation_TopTools_ShapeMapHasher_ChangeFind(self, *args)


    def __call__(self, *args):
        """
        operator ()

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _STEPCAFControl.NCollection_DataMap_TopoDS_Shape_Handle_StepShape_ShapeDefinitionRepresentation_TopTools_ShapeMapHasher___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Clear(self, *args):
        """
        Clear(NCollection_DataMap_TopoDS_Shape_Handle_StepShape_ShapeDefinitionRepresentation_TopTools_ShapeMapHasher self, Standard_Boolean const doReleaseMemory)
        Clear(NCollection_DataMap_TopoDS_Shape_Handle_StepShape_ShapeDefinitionRepresentation_TopTools_ShapeMapHasher self, Handle_NCollection_BaseAllocator theAllocator)

        Clear data and reset allocator

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _STEPCAFControl.NCollection_DataMap_TopoDS_Shape_Handle_StepShape_ShapeDefinitionRepresentation_TopTools_ShapeMapHasher_Clear(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_DataMap_TopoDS_Shape_Handle_StepShape_ShapeDefinitionRepresentation_TopTools_ShapeMapHasher self) -> Standard_Integer

        Size

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _STEPCAFControl.NCollection_DataMap_TopoDS_Shape_Handle_StepShape_ShapeDefinitionRepresentation_TopTools_ShapeMapHasher_Size(self, *args)


    def __iter__(self):
        return _STEPCAFControl.NCollection_DataMap_TopoDS_Shape_Handle_StepShape_ShapeDefinitionRepresentation_TopTools_ShapeMapHasher___iter__(self)
    __swig_destroy__ = _STEPCAFControl.delete_NCollection_DataMap_TopoDS_Shape_Handle_StepShape_ShapeDefinitionRepresentation_TopTools_ShapeMapHasher
NCollection_DataMap_TopoDS_Shape_Handle_StepShape_ShapeDefinitionRepresentation_TopTools_ShapeMapHasher_swigregister = _STEPCAFControl.NCollection_DataMap_TopoDS_Shape_Handle_StepShape_ShapeDefinitionRepresentation_TopTools_ShapeMapHasher_swigregister
NCollection_DataMap_TopoDS_Shape_Handle_StepShape_ShapeDefinitionRepresentation_TopTools_ShapeMapHasher_swigregister(NCollection_DataMap_TopoDS_Shape_Handle_StepShape_ShapeDefinitionRepresentation_TopTools_ShapeMapHasher)

class NCollection_DataMap_TopoDS_Shape_Handle_StepShape_ShapeDefinitionRepresentation_TopTools_ShapeMapHasher_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _STEPCAFControl.new_NCollection_DataMap_TopoDS_Shape_Handle_StepShape_ShapeDefinitionRepresentation_TopTools_ShapeMapHasher_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _STEPCAFControl.delete_NCollection_DataMap_TopoDS_Shape_Handle_StepShape_ShapeDefinitionRepresentation_TopTools_ShapeMapHasher_IteratorHelper

    def __next__(self):
        return _STEPCAFControl.NCollection_DataMap_TopoDS_Shape_Handle_StepShape_ShapeDefinitionRepresentation_TopTools_ShapeMapHasher_IteratorHelper___next__(self)
NCollection_DataMap_TopoDS_Shape_Handle_StepShape_ShapeDefinitionRepresentation_TopTools_ShapeMapHasher_IteratorHelper_swigregister = _STEPCAFControl.NCollection_DataMap_TopoDS_Shape_Handle_StepShape_ShapeDefinitionRepresentation_TopTools_ShapeMapHasher_IteratorHelper_swigregister
NCollection_DataMap_TopoDS_Shape_Handle_StepShape_ShapeDefinitionRepresentation_TopTools_ShapeMapHasher_IteratorHelper_swigregister(NCollection_DataMap_TopoDS_Shape_Handle_StepShape_ShapeDefinitionRepresentation_TopTools_ShapeMapHasher_IteratorHelper)


try:
	STEPCAFControl_DataMapOfShapeSDR = NCollection_DataMap_TopoDS_Shape_Handle_StepShape_ShapeDefinitionRepresentation_TopTools_ShapeMapHasher
except NameError:
	pass # does not exist, probably ignored

class NCollection_DataMap_Handle_StepBasic_ProductDefinition_Handle_STEPCAFControl_ExternFile_TColStd_MapTransientHasher(NCollection.NCollection_BaseMap):
    """
    Purpose:     The DataMap is a Map to store keys with associated
    Items. See Map  from NCollection for  a discussion
    about the number of buckets.

    The DataMap can be seen as an extended array where
    the Keys  are the   indices.  For this reason  the
    operator () is defined on DataMap to fetch an Item
    from a Key. So the following syntax can be used :

    anItem = aMap(aKey);
    aMap(aKey) = anItem;

    This analogy has its  limit.   aMap(aKey) = anItem
    can  be done only  if aKey was previously bound to
    an item in the map.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_DataMap_Handle_StepBasic_ProductDefinition_Handle_STEPCAFControl_ExternFile_TColStd_MapTransientHasher self) -> NCollection_DataMap< opencascade::handle< StepBasic_ProductDefinition >,opencascade::handle< STEPCAFControl_ExternFile >,TColStd_MapTransientHasher >::iterator

        Returns an iterator pointing to the first element in the map.

        :rtype: iterator

        """
        return _STEPCAFControl.NCollection_DataMap_Handle_StepBasic_ProductDefinition_Handle_STEPCAFControl_ExternFile_TColStd_MapTransientHasher_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_DataMap_Handle_StepBasic_ProductDefinition_Handle_STEPCAFControl_ExternFile_TColStd_MapTransientHasher self) -> NCollection_DataMap< opencascade::handle< StepBasic_ProductDefinition >,opencascade::handle< STEPCAFControl_ExternFile >,TColStd_MapTransientHasher >::iterator

        Returns an iterator referring to the past-the-end element in the map.

        :rtype: iterator

        """
        return _STEPCAFControl.NCollection_DataMap_Handle_StepBasic_ProductDefinition_Handle_STEPCAFControl_ExternFile_TColStd_MapTransientHasher_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_DataMap_Handle_StepBasic_ProductDefinition_Handle_STEPCAFControl_ExternFile_TColStd_MapTransientHasher self) -> NCollection_DataMap< opencascade::handle< StepBasic_ProductDefinition >,opencascade::handle< STEPCAFControl_ExternFile >,TColStd_MapTransientHasher >::const_iterator

        Returns a const iterator pointing to the first element in the map.

        :rtype: const_iterator

        """
        return _STEPCAFControl.NCollection_DataMap_Handle_StepBasic_ProductDefinition_Handle_STEPCAFControl_ExternFile_TColStd_MapTransientHasher_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_DataMap_Handle_StepBasic_ProductDefinition_Handle_STEPCAFControl_ExternFile_TColStd_MapTransientHasher self) -> NCollection_DataMap< opencascade::handle< StepBasic_ProductDefinition >,opencascade::handle< STEPCAFControl_ExternFile >,TColStd_MapTransientHasher >::const_iterator

        Returns a const iterator referring to the past-the-end element in the map.

        :rtype: const_iterator

        """
        return _STEPCAFControl.NCollection_DataMap_Handle_StepBasic_ProductDefinition_Handle_STEPCAFControl_ExternFile_TColStd_MapTransientHasher_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     The DataMap is a Map to store keys with associated
        Items. See Map  from NCollection for  a discussion
        about the number of buckets.

        The DataMap can be seen as an extended array where
        the Keys  are the   indices.  For this reason  the
        operator () is defined on DataMap to fetch an Item
        from a Key. So the following syntax can be used :

        anItem = aMap(aKey);
        aMap(aKey) = anItem;

        This analogy has its  limit.   aMap(aKey) = anItem
        can  be done only  if aKey was previously bound to
        an item in the map.
        """
        this = _STEPCAFControl.new_NCollection_DataMap_Handle_StepBasic_ProductDefinition_Handle_STEPCAFControl_ExternFile_TColStd_MapTransientHasher(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Exchange(self, *args):
        """
        Exchange(NCollection_DataMap_Handle_StepBasic_ProductDefinition_Handle_STEPCAFControl_ExternFile_TColStd_MapTransientHasher self, NCollection_DataMap_Handle_StepBasic_ProductDefinition_Handle_STEPCAFControl_ExternFile_TColStd_MapTransientHasher theOther)

        Exchange the content of two maps without re-allocations.
        Notice that allocators will be swapped as well!

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _STEPCAFControl.NCollection_DataMap_Handle_StepBasic_ProductDefinition_Handle_STEPCAFControl_ExternFile_TColStd_MapTransientHasher_Exchange(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_DataMap_Handle_StepBasic_ProductDefinition_Handle_STEPCAFControl_ExternFile_TColStd_MapTransientHasher self, NCollection_DataMap_Handle_StepBasic_ProductDefinition_Handle_STEPCAFControl_ExternFile_TColStd_MapTransientHasher theOther) -> NCollection_DataMap_Handle_StepBasic_ProductDefinition_Handle_STEPCAFControl_ExternFile_TColStd_MapTransientHasher

        Assignment.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _STEPCAFControl.NCollection_DataMap_Handle_StepBasic_ProductDefinition_Handle_STEPCAFControl_ExternFile_TColStd_MapTransientHasher_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_DataMap_Handle_StepBasic_ProductDefinition_Handle_STEPCAFControl_ExternFile_TColStd_MapTransientHasher self, NCollection_DataMap_Handle_StepBasic_ProductDefinition_Handle_STEPCAFControl_ExternFile_TColStd_MapTransientHasher theOther) -> NCollection_DataMap_Handle_StepBasic_ProductDefinition_Handle_STEPCAFControl_ExternFile_TColStd_MapTransientHasher

        Assignment operator

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _STEPCAFControl.NCollection_DataMap_Handle_StepBasic_ProductDefinition_Handle_STEPCAFControl_ExternFile_TColStd_MapTransientHasher_assign(self, *args)


    def ReSize(self, *args):
        """
        ReSize(NCollection_DataMap_Handle_StepBasic_ProductDefinition_Handle_STEPCAFControl_ExternFile_TColStd_MapTransientHasher self, Standard_Integer const N)

        ReSize

        :type N: int

        """
        return _STEPCAFControl.NCollection_DataMap_Handle_StepBasic_ProductDefinition_Handle_STEPCAFControl_ExternFile_TColStd_MapTransientHasher_ReSize(self, *args)


    def Bind(self, *args):
        """
        Bind(NCollection_DataMap_Handle_StepBasic_ProductDefinition_Handle_STEPCAFControl_ExternFile_TColStd_MapTransientHasher self, Handle_StepBasic_ProductDefinition theKey, Handle_STEPCAFControl_ExternFile theItem) -> Standard_Boolean

        Bind binds Item to Key in map.
        @param theKey  key to add/update
        @param theItem new item; overrides value previously bound to the key, if any
        @return Standard_True if Key was not bound already

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _STEPCAFControl.NCollection_DataMap_Handle_StepBasic_ProductDefinition_Handle_STEPCAFControl_ExternFile_TColStd_MapTransientHasher_Bind(self, *args)


    def Bound(self, *args):
        """
        Bound(NCollection_DataMap_Handle_StepBasic_ProductDefinition_Handle_STEPCAFControl_ExternFile_TColStd_MapTransientHasher self, Handle_StepBasic_ProductDefinition theKey, Handle_STEPCAFControl_ExternFile theItem) -> Handle_STEPCAFControl_ExternFile

        Bound binds Item to Key in map. Returns modifiable Item 

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: TheItemType *

        """
        return _STEPCAFControl.NCollection_DataMap_Handle_StepBasic_ProductDefinition_Handle_STEPCAFControl_ExternFile_TColStd_MapTransientHasher_Bound(self, *args)


    def IsBound(self, *args):
        """
        IsBound(NCollection_DataMap_Handle_StepBasic_ProductDefinition_Handle_STEPCAFControl_ExternFile_TColStd_MapTransientHasher self, Handle_StepBasic_ProductDefinition theKey) -> Standard_Boolean

        IsBound

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _STEPCAFControl.NCollection_DataMap_Handle_StepBasic_ProductDefinition_Handle_STEPCAFControl_ExternFile_TColStd_MapTransientHasher_IsBound(self, *args)


    def UnBind(self, *args):
        """
        UnBind(NCollection_DataMap_Handle_StepBasic_ProductDefinition_Handle_STEPCAFControl_ExternFile_TColStd_MapTransientHasher self, Handle_StepBasic_ProductDefinition theKey) -> Standard_Boolean

        UnBind removes Item Key pair from map

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _STEPCAFControl.NCollection_DataMap_Handle_StepBasic_ProductDefinition_Handle_STEPCAFControl_ExternFile_TColStd_MapTransientHasher_UnBind(self, *args)


    def Seek(self, *args):
        """
        Seek(NCollection_DataMap_Handle_StepBasic_ProductDefinition_Handle_STEPCAFControl_ExternFile_TColStd_MapTransientHasher self, Handle_StepBasic_ProductDefinition theKey) -> Handle_STEPCAFControl_ExternFile

        Seek returns pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: const TheItemType *

        """
        return _STEPCAFControl.NCollection_DataMap_Handle_StepBasic_ProductDefinition_Handle_STEPCAFControl_ExternFile_TColStd_MapTransientHasher_Seek(self, *args)


    def Find(self, *args):
        """
        Find returns the Item for Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _STEPCAFControl.NCollection_DataMap_Handle_StepBasic_ProductDefinition_Handle_STEPCAFControl_ExternFile_TColStd_MapTransientHasher_Find(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeSeek(self, *args):
        """
        ChangeSeek(NCollection_DataMap_Handle_StepBasic_ProductDefinition_Handle_STEPCAFControl_ExternFile_TColStd_MapTransientHasher self, Handle_StepBasic_ProductDefinition theKey) -> Handle_STEPCAFControl_ExternFile

        ChangeSeek returns modifiable pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: TheItemType *

        """
        return _STEPCAFControl.NCollection_DataMap_Handle_StepBasic_ProductDefinition_Handle_STEPCAFControl_ExternFile_TColStd_MapTransientHasher_ChangeSeek(self, *args)


    def ChangeFind(self, *args):
        """
        ChangeFind(NCollection_DataMap_Handle_StepBasic_ProductDefinition_Handle_STEPCAFControl_ExternFile_TColStd_MapTransientHasher self, Handle_StepBasic_ProductDefinition theKey) -> Handle_STEPCAFControl_ExternFile

        ChangeFind returns mofifiable Item by Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: TheItemType &

        """
        return _STEPCAFControl.NCollection_DataMap_Handle_StepBasic_ProductDefinition_Handle_STEPCAFControl_ExternFile_TColStd_MapTransientHasher_ChangeFind(self, *args)


    def __call__(self, *args):
        """
        operator ()

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _STEPCAFControl.NCollection_DataMap_Handle_StepBasic_ProductDefinition_Handle_STEPCAFControl_ExternFile_TColStd_MapTransientHasher___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Clear(self, *args):
        """
        Clear(NCollection_DataMap_Handle_StepBasic_ProductDefinition_Handle_STEPCAFControl_ExternFile_TColStd_MapTransientHasher self, Standard_Boolean const doReleaseMemory)
        Clear(NCollection_DataMap_Handle_StepBasic_ProductDefinition_Handle_STEPCAFControl_ExternFile_TColStd_MapTransientHasher self, Handle_NCollection_BaseAllocator theAllocator)

        Clear data and reset allocator

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _STEPCAFControl.NCollection_DataMap_Handle_StepBasic_ProductDefinition_Handle_STEPCAFControl_ExternFile_TColStd_MapTransientHasher_Clear(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_DataMap_Handle_StepBasic_ProductDefinition_Handle_STEPCAFControl_ExternFile_TColStd_MapTransientHasher self) -> Standard_Integer

        Size

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _STEPCAFControl.NCollection_DataMap_Handle_StepBasic_ProductDefinition_Handle_STEPCAFControl_ExternFile_TColStd_MapTransientHasher_Size(self, *args)


    def __iter__(self):
        return _STEPCAFControl.NCollection_DataMap_Handle_StepBasic_ProductDefinition_Handle_STEPCAFControl_ExternFile_TColStd_MapTransientHasher___iter__(self)
    __swig_destroy__ = _STEPCAFControl.delete_NCollection_DataMap_Handle_StepBasic_ProductDefinition_Handle_STEPCAFControl_ExternFile_TColStd_MapTransientHasher
NCollection_DataMap_Handle_StepBasic_ProductDefinition_Handle_STEPCAFControl_ExternFile_TColStd_MapTransientHasher_swigregister = _STEPCAFControl.NCollection_DataMap_Handle_StepBasic_ProductDefinition_Handle_STEPCAFControl_ExternFile_TColStd_MapTransientHasher_swigregister
NCollection_DataMap_Handle_StepBasic_ProductDefinition_Handle_STEPCAFControl_ExternFile_TColStd_MapTransientHasher_swigregister(NCollection_DataMap_Handle_StepBasic_ProductDefinition_Handle_STEPCAFControl_ExternFile_TColStd_MapTransientHasher)

class NCollection_DataMap_Handle_StepBasic_ProductDefinition_Handle_STEPCAFControl_ExternFile_TColStd_MapTransientHasher_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _STEPCAFControl.new_NCollection_DataMap_Handle_StepBasic_ProductDefinition_Handle_STEPCAFControl_ExternFile_TColStd_MapTransientHasher_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _STEPCAFControl.delete_NCollection_DataMap_Handle_StepBasic_ProductDefinition_Handle_STEPCAFControl_ExternFile_TColStd_MapTransientHasher_IteratorHelper

    def __next__(self):
        return _STEPCAFControl.NCollection_DataMap_Handle_StepBasic_ProductDefinition_Handle_STEPCAFControl_ExternFile_TColStd_MapTransientHasher_IteratorHelper___next__(self)
NCollection_DataMap_Handle_StepBasic_ProductDefinition_Handle_STEPCAFControl_ExternFile_TColStd_MapTransientHasher_IteratorHelper_swigregister = _STEPCAFControl.NCollection_DataMap_Handle_StepBasic_ProductDefinition_Handle_STEPCAFControl_ExternFile_TColStd_MapTransientHasher_IteratorHelper_swigregister
NCollection_DataMap_Handle_StepBasic_ProductDefinition_Handle_STEPCAFControl_ExternFile_TColStd_MapTransientHasher_IteratorHelper_swigregister(NCollection_DataMap_Handle_StepBasic_ProductDefinition_Handle_STEPCAFControl_ExternFile_TColStd_MapTransientHasher_IteratorHelper)


try:
	STEPCAFControl_DataMapOfPDExternFile = NCollection_DataMap_Handle_StepBasic_ProductDefinition_Handle_STEPCAFControl_ExternFile_TColStd_MapTransientHasher
except NameError:
	pass # does not exist, probably ignored

class STEPCAFControl_GDTProperty(object):
    """
    This class provides tools for access (read)
    the GDT properties.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(STEPCAFControl_GDTProperty self) -> STEPCAFControl_GDTProperty

        This class provides tools for access (read)
        the GDT properties.
        """
        this = _STEPCAFControl.new_STEPCAFControl_GDTProperty(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def GetDimModifiers(*args):
        """
        GetDimModifiers(Handle_StepRepr_CompoundRepresentationItem theCRI, NCollection_Sequence_XCAFDimTolObjects_DimensionModif theModifiers)

        :type theCRI: OCC.wrapper.STEPCAFControl.Handle_StepRepr_CompoundRepresentationItem
        :type theModifiers: OCC.wrapper.XCAFDimTolObjects.XCAFDimTolObjects_DimensionModifiersSequence

        """
        return _STEPCAFControl.STEPCAFControl_GDTProperty_GetDimModifiers(*args)

    GetDimModifiers = staticmethod(GetDimModifiers)

    def GetDimClassOfTolerance(*args):
        """
        GetDimClassOfTolerance(Handle_StepShape_LimitsAndFits theLAF)

        :type theLAF: OCC.wrapper.StepShape.Handle_StepShape_LimitsAndFits
        :type theHolle: bool
        :type theFV: OCC.wrapper.XCAFDimTolObjects.XCAFDimTolObjects_DimensionFormVariance
        :type theG: OCC.wrapper.XCAFDimTolObjects.XCAFDimTolObjects_DimensionGrade

        """
        return _STEPCAFControl.STEPCAFControl_GDTProperty_GetDimClassOfTolerance(*args)

    GetDimClassOfTolerance = staticmethod(GetDimClassOfTolerance)

    def GetDimType(*args):
        """
        GetDimType(Handle_TCollection_HAsciiString theName) -> Standard_Boolean

        :type theName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type theType: OCC.wrapper.XCAFDimTolObjects.XCAFDimTolObjects_DimensionType
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _STEPCAFControl.STEPCAFControl_GDTProperty_GetDimType(*args)

    GetDimType = staticmethod(GetDimType)

    def GetDatumTargetType(*args):
        """
        GetDatumTargetType(Handle_TCollection_HAsciiString theDescription) -> Standard_Boolean

        :type theDescription: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type theType: OCC.wrapper.XCAFDimTolObjects.XCAFDimTolObjects_DatumTargetType
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _STEPCAFControl.STEPCAFControl_GDTProperty_GetDatumTargetType(*args)

    GetDatumTargetType = staticmethod(GetDatumTargetType)

    def GetDimQualifierType(*args):
        """
        GetDimQualifierType(Handle_TCollection_HAsciiString theDescription) -> Standard_Boolean

        :type theDescription: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type theType: OCC.wrapper.XCAFDimTolObjects.XCAFDimTolObjects_DimensionQualifier
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _STEPCAFControl.STEPCAFControl_GDTProperty_GetDimQualifierType(*args)

    GetDimQualifierType = staticmethod(GetDimQualifierType)

    def GetTolValueType(*args):
        """
        GetTolValueType(Handle_TCollection_HAsciiString theDescription) -> Standard_Boolean
        GetTolValueType(XCAFDimTolObjects_GeomToleranceTypeValue const & theType) -> Handle_TCollection_HAsciiString

        :type theType: OCC.wrapper.XCAFDimTolObjects.XCAFDimTolObjects_GeomToleranceTypeValue
        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _STEPCAFControl.STEPCAFControl_GDTProperty_GetTolValueType(*args)

    GetTolValueType = staticmethod(GetTolValueType)

    def GetDimTypeName(*args):
        """
        GetDimTypeName(XCAFDimTolObjects_DimensionType const theType) -> Handle_TCollection_HAsciiString

        :type theType: OCC.wrapper.XCAFDimTolObjects.XCAFDimTolObjects_DimensionType
        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _STEPCAFControl.STEPCAFControl_GDTProperty_GetDimTypeName(*args)

    GetDimTypeName = staticmethod(GetDimTypeName)

    def GetDimQualifierName(*args):
        """
        GetDimQualifierName(XCAFDimTolObjects_DimensionQualifier const theQualifier) -> Handle_TCollection_HAsciiString

        :type theQualifier: OCC.wrapper.XCAFDimTolObjects.XCAFDimTolObjects_DimensionQualifier
        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _STEPCAFControl.STEPCAFControl_GDTProperty_GetDimQualifierName(*args)

    GetDimQualifierName = staticmethod(GetDimQualifierName)

    def GetDimModifierName(*args):
        """
        GetDimModifierName(XCAFDimTolObjects_DimensionModif const theModifier) -> Handle_TCollection_HAsciiString

        :type theModifier: OCC.wrapper.XCAFDimTolObjects.XCAFDimTolObjects_DimensionModif
        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _STEPCAFControl.STEPCAFControl_GDTProperty_GetDimModifierName(*args)

    GetDimModifierName = staticmethod(GetDimModifierName)

    def GetLimitsAndFits(*args):
        """
        GetLimitsAndFits(Standard_Boolean theHole, XCAFDimTolObjects_DimensionFormVariance theFormVariance, XCAFDimTolObjects_DimensionGrade theGrade) -> Handle_StepShape_LimitsAndFits

        :type theHole: bool
        :type theFormVariance: OCC.wrapper.XCAFDimTolObjects.XCAFDimTolObjects_DimensionFormVariance
        :type theGrade: OCC.wrapper.XCAFDimTolObjects.XCAFDimTolObjects_DimensionGrade
        :rtype: OCC.wrapper.StepShape.Handle_StepShape_LimitsAndFits

        """
        return _STEPCAFControl.STEPCAFControl_GDTProperty_GetLimitsAndFits(*args)

    GetLimitsAndFits = staticmethod(GetLimitsAndFits)

    def GetDatumTargetName(*args):
        """
        GetDatumTargetName(XCAFDimTolObjects_DatumTargetType const theDatumType) -> Handle_TCollection_HAsciiString

        :type theDatumType: OCC.wrapper.XCAFDimTolObjects.XCAFDimTolObjects_DatumTargetType
        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _STEPCAFControl.STEPCAFControl_GDTProperty_GetDatumTargetName(*args)

    GetDatumTargetName = staticmethod(GetDatumTargetName)

    def IsDimensionalLocation(*args):
        """
        IsDimensionalLocation(XCAFDimTolObjects_DimensionType const theType) -> Standard_Boolean

        :type theType: OCC.wrapper.XCAFDimTolObjects.XCAFDimTolObjects_DimensionType
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _STEPCAFControl.STEPCAFControl_GDTProperty_IsDimensionalLocation(*args)

    IsDimensionalLocation = staticmethod(IsDimensionalLocation)

    def IsDimensionalSize(*args):
        """
        IsDimensionalSize(XCAFDimTolObjects_DimensionType const theType) -> Standard_Boolean

        :type theType: OCC.wrapper.XCAFDimTolObjects.XCAFDimTolObjects_DimensionType
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _STEPCAFControl.STEPCAFControl_GDTProperty_IsDimensionalSize(*args)

    IsDimensionalSize = staticmethod(IsDimensionalSize)

    def GetGeomToleranceType(*args):
        """
        GetGeomToleranceType(XCAFDimTolObjects_GeomToleranceType const theType) -> StepDimTol_GeometricToleranceType
        GetGeomToleranceType(StepDimTol_GeometricToleranceType const theType) -> XCAFDimTolObjects_GeomToleranceType

        :type theType: OCC.wrapper.StepDimTol.StepDimTol_GeometricToleranceType
        :rtype: OCC.wrapper.XCAFDimTolObjects.XCAFDimTolObjects_GeomToleranceType

        """
        return _STEPCAFControl.STEPCAFControl_GDTProperty_GetGeomToleranceType(*args)

    GetGeomToleranceType = staticmethod(GetGeomToleranceType)

    def GetGeomTolerance(*args):
        """
        GetGeomTolerance(XCAFDimTolObjects_GeomToleranceType const theType) -> Handle_StepDimTol_GeometricTolerance

        :type theType: OCC.wrapper.XCAFDimTolObjects.XCAFDimTolObjects_GeomToleranceType
        :rtype: OCC.wrapper.StepDimTol.Handle_StepDimTol_GeometricTolerance

        """
        return _STEPCAFControl.STEPCAFControl_GDTProperty_GetGeomTolerance(*args)

    GetGeomTolerance = staticmethod(GetGeomTolerance)

    def GetGeomToleranceModifier(*args):
        """
        GetGeomToleranceModifier(XCAFDimTolObjects_GeomToleranceModif const theModifier) -> StepDimTol_GeometricToleranceModifier

        :type theModifier: OCC.wrapper.XCAFDimTolObjects.XCAFDimTolObjects_GeomToleranceModif
        :rtype: OCC.wrapper.StepDimTol.StepDimTol_GeometricToleranceModifier

        """
        return _STEPCAFControl.STEPCAFControl_GDTProperty_GetGeomToleranceModifier(*args)

    GetGeomToleranceModifier = staticmethod(GetGeomToleranceModifier)

    def GetDatumRefModifiers(*args):
        """
        GetDatumRefModifiers(NCollection_Sequence_XCAFDimTolObjects_DatumSingleModif theModifiers, XCAFDimTolObjects_DatumModifWithValue const theModifWithVal, Standard_Real const theValue, StepBasic_Unit theUnit) -> Handle_StepDimTol_HArray1OfDatumReferenceModifier

        :type theModifiers: OCC.wrapper.XCAFDimTolObjects.XCAFDimTolObjects_DatumModifiersSequence
        :type theModifWithVal: OCC.wrapper.XCAFDimTolObjects.XCAFDimTolObjects_DatumModifWithValue
        :type theValue: float
        :type theUnit: OCC.wrapper.StepBasic.StepBasic_Unit
        :rtype: OCC.wrapper.StepDimTol.Handle_StepDimTol_HArray1OfDatumReferenceModifier

        """
        return _STEPCAFControl.STEPCAFControl_GDTProperty_GetDatumRefModifiers(*args)

    GetDatumRefModifiers = staticmethod(GetDatumRefModifiers)

    def GetTessellation(*args):
        """
        GetTessellation(TopoDS_Shape theShape) -> Handle_StepVisual_TessellatedGeometricSet

        :type theShape: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.StepVisual.Handle_StepVisual_TessellatedGeometricSet

        """
        return _STEPCAFControl.STEPCAFControl_GDTProperty_GetTessellation(*args)

    GetTessellation = staticmethod(GetTessellation)
    __swig_destroy__ = _STEPCAFControl.delete_STEPCAFControl_GDTProperty
STEPCAFControl_GDTProperty_swigregister = _STEPCAFControl.STEPCAFControl_GDTProperty_swigregister
STEPCAFControl_GDTProperty_swigregister(STEPCAFControl_GDTProperty)

def STEPCAFControl_GDTProperty_GetDimModifiers(*args):
    """
    STEPCAFControl_GDTProperty_GetDimModifiers(Handle_StepRepr_CompoundRepresentationItem theCRI, NCollection_Sequence_XCAFDimTolObjects_DimensionModif theModifiers)

    :type theCRI: OCC.wrapper.STEPCAFControl.Handle_StepRepr_CompoundRepresentationItem
    :type theModifiers: OCC.wrapper.XCAFDimTolObjects.XCAFDimTolObjects_DimensionModifiersSequence

    """
    return _STEPCAFControl.STEPCAFControl_GDTProperty_GetDimModifiers(*args)

def STEPCAFControl_GDTProperty_GetDimClassOfTolerance(*args):
    """
    STEPCAFControl_GDTProperty_GetDimClassOfTolerance(Handle_StepShape_LimitsAndFits theLAF)

    :type theLAF: OCC.wrapper.StepShape.Handle_StepShape_LimitsAndFits
    :type theHolle: bool
    :type theFV: OCC.wrapper.XCAFDimTolObjects.XCAFDimTolObjects_DimensionFormVariance
    :type theG: OCC.wrapper.XCAFDimTolObjects.XCAFDimTolObjects_DimensionGrade

    """
    return _STEPCAFControl.STEPCAFControl_GDTProperty_GetDimClassOfTolerance(*args)

def STEPCAFControl_GDTProperty_GetDimType(*args):
    """
    STEPCAFControl_GDTProperty_GetDimType(Handle_TCollection_HAsciiString theName) -> Standard_Boolean

    :type theName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
    :type theType: OCC.wrapper.XCAFDimTolObjects.XCAFDimTolObjects_DimensionType
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _STEPCAFControl.STEPCAFControl_GDTProperty_GetDimType(*args)

def STEPCAFControl_GDTProperty_GetDatumTargetType(*args):
    """
    STEPCAFControl_GDTProperty_GetDatumTargetType(Handle_TCollection_HAsciiString theDescription) -> Standard_Boolean

    :type theDescription: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
    :type theType: OCC.wrapper.XCAFDimTolObjects.XCAFDimTolObjects_DatumTargetType
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _STEPCAFControl.STEPCAFControl_GDTProperty_GetDatumTargetType(*args)

def STEPCAFControl_GDTProperty_GetDimQualifierType(*args):
    """
    STEPCAFControl_GDTProperty_GetDimQualifierType(Handle_TCollection_HAsciiString theDescription) -> Standard_Boolean

    :type theDescription: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
    :type theType: OCC.wrapper.XCAFDimTolObjects.XCAFDimTolObjects_DimensionQualifier
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _STEPCAFControl.STEPCAFControl_GDTProperty_GetDimQualifierType(*args)

def STEPCAFControl_GDTProperty_GetTolValueType(*args):
    """
    GetTolValueType(Handle_TCollection_HAsciiString theDescription) -> Standard_Boolean
    STEPCAFControl_GDTProperty_GetTolValueType(XCAFDimTolObjects_GeomToleranceTypeValue const & theType) -> Handle_TCollection_HAsciiString

    :type theType: OCC.wrapper.XCAFDimTolObjects.XCAFDimTolObjects_GeomToleranceTypeValue
    :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

    """
    return _STEPCAFControl.STEPCAFControl_GDTProperty_GetTolValueType(*args)

def STEPCAFControl_GDTProperty_GetDimTypeName(*args):
    """
    STEPCAFControl_GDTProperty_GetDimTypeName(XCAFDimTolObjects_DimensionType const theType) -> Handle_TCollection_HAsciiString

    :type theType: OCC.wrapper.XCAFDimTolObjects.XCAFDimTolObjects_DimensionType
    :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

    """
    return _STEPCAFControl.STEPCAFControl_GDTProperty_GetDimTypeName(*args)

def STEPCAFControl_GDTProperty_GetDimQualifierName(*args):
    """
    STEPCAFControl_GDTProperty_GetDimQualifierName(XCAFDimTolObjects_DimensionQualifier const theQualifier) -> Handle_TCollection_HAsciiString

    :type theQualifier: OCC.wrapper.XCAFDimTolObjects.XCAFDimTolObjects_DimensionQualifier
    :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

    """
    return _STEPCAFControl.STEPCAFControl_GDTProperty_GetDimQualifierName(*args)

def STEPCAFControl_GDTProperty_GetDimModifierName(*args):
    """
    STEPCAFControl_GDTProperty_GetDimModifierName(XCAFDimTolObjects_DimensionModif const theModifier) -> Handle_TCollection_HAsciiString

    :type theModifier: OCC.wrapper.XCAFDimTolObjects.XCAFDimTolObjects_DimensionModif
    :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

    """
    return _STEPCAFControl.STEPCAFControl_GDTProperty_GetDimModifierName(*args)

def STEPCAFControl_GDTProperty_GetLimitsAndFits(*args):
    """
    STEPCAFControl_GDTProperty_GetLimitsAndFits(Standard_Boolean theHole, XCAFDimTolObjects_DimensionFormVariance theFormVariance, XCAFDimTolObjects_DimensionGrade theGrade) -> Handle_StepShape_LimitsAndFits

    :type theHole: bool
    :type theFormVariance: OCC.wrapper.XCAFDimTolObjects.XCAFDimTolObjects_DimensionFormVariance
    :type theGrade: OCC.wrapper.XCAFDimTolObjects.XCAFDimTolObjects_DimensionGrade
    :rtype: OCC.wrapper.StepShape.Handle_StepShape_LimitsAndFits

    """
    return _STEPCAFControl.STEPCAFControl_GDTProperty_GetLimitsAndFits(*args)

def STEPCAFControl_GDTProperty_GetDatumTargetName(*args):
    """
    STEPCAFControl_GDTProperty_GetDatumTargetName(XCAFDimTolObjects_DatumTargetType const theDatumType) -> Handle_TCollection_HAsciiString

    :type theDatumType: OCC.wrapper.XCAFDimTolObjects.XCAFDimTolObjects_DatumTargetType
    :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

    """
    return _STEPCAFControl.STEPCAFControl_GDTProperty_GetDatumTargetName(*args)

def STEPCAFControl_GDTProperty_IsDimensionalLocation(*args):
    """
    STEPCAFControl_GDTProperty_IsDimensionalLocation(XCAFDimTolObjects_DimensionType const theType) -> Standard_Boolean

    :type theType: OCC.wrapper.XCAFDimTolObjects.XCAFDimTolObjects_DimensionType
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _STEPCAFControl.STEPCAFControl_GDTProperty_IsDimensionalLocation(*args)

def STEPCAFControl_GDTProperty_IsDimensionalSize(*args):
    """
    STEPCAFControl_GDTProperty_IsDimensionalSize(XCAFDimTolObjects_DimensionType const theType) -> Standard_Boolean

    :type theType: OCC.wrapper.XCAFDimTolObjects.XCAFDimTolObjects_DimensionType
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _STEPCAFControl.STEPCAFControl_GDTProperty_IsDimensionalSize(*args)

def STEPCAFControl_GDTProperty_GetGeomToleranceType(*args):
    """
    GetGeomToleranceType(XCAFDimTolObjects_GeomToleranceType const theType) -> StepDimTol_GeometricToleranceType
    STEPCAFControl_GDTProperty_GetGeomToleranceType(StepDimTol_GeometricToleranceType const theType) -> XCAFDimTolObjects_GeomToleranceType

    :type theType: OCC.wrapper.StepDimTol.StepDimTol_GeometricToleranceType
    :rtype: OCC.wrapper.XCAFDimTolObjects.XCAFDimTolObjects_GeomToleranceType

    """
    return _STEPCAFControl.STEPCAFControl_GDTProperty_GetGeomToleranceType(*args)

def STEPCAFControl_GDTProperty_GetGeomTolerance(*args):
    """
    STEPCAFControl_GDTProperty_GetGeomTolerance(XCAFDimTolObjects_GeomToleranceType const theType) -> Handle_StepDimTol_GeometricTolerance

    :type theType: OCC.wrapper.XCAFDimTolObjects.XCAFDimTolObjects_GeomToleranceType
    :rtype: OCC.wrapper.StepDimTol.Handle_StepDimTol_GeometricTolerance

    """
    return _STEPCAFControl.STEPCAFControl_GDTProperty_GetGeomTolerance(*args)

def STEPCAFControl_GDTProperty_GetGeomToleranceModifier(*args):
    """
    STEPCAFControl_GDTProperty_GetGeomToleranceModifier(XCAFDimTolObjects_GeomToleranceModif const theModifier) -> StepDimTol_GeometricToleranceModifier

    :type theModifier: OCC.wrapper.XCAFDimTolObjects.XCAFDimTolObjects_GeomToleranceModif
    :rtype: OCC.wrapper.StepDimTol.StepDimTol_GeometricToleranceModifier

    """
    return _STEPCAFControl.STEPCAFControl_GDTProperty_GetGeomToleranceModifier(*args)

def STEPCAFControl_GDTProperty_GetDatumRefModifiers(*args):
    """
    STEPCAFControl_GDTProperty_GetDatumRefModifiers(NCollection_Sequence_XCAFDimTolObjects_DatumSingleModif theModifiers, XCAFDimTolObjects_DatumModifWithValue const theModifWithVal, Standard_Real const theValue, StepBasic_Unit theUnit) -> Handle_StepDimTol_HArray1OfDatumReferenceModifier

    :type theModifiers: OCC.wrapper.XCAFDimTolObjects.XCAFDimTolObjects_DatumModifiersSequence
    :type theModifWithVal: OCC.wrapper.XCAFDimTolObjects.XCAFDimTolObjects_DatumModifWithValue
    :type theValue: float
    :type theUnit: OCC.wrapper.StepBasic.StepBasic_Unit
    :rtype: OCC.wrapper.StepDimTol.Handle_StepDimTol_HArray1OfDatumReferenceModifier

    """
    return _STEPCAFControl.STEPCAFControl_GDTProperty_GetDatumRefModifiers(*args)

def STEPCAFControl_GDTProperty_GetTessellation(*args):
    """
    STEPCAFControl_GDTProperty_GetTessellation(TopoDS_Shape theShape) -> Handle_StepVisual_TessellatedGeometricSet

    :type theShape: OCC.wrapper.TopoDS.TopoDS_Shape
    :rtype: OCC.wrapper.StepVisual.Handle_StepVisual_TessellatedGeometricSet

    """
    return _STEPCAFControl.STEPCAFControl_GDTProperty_GetTessellation(*args)

class Handle_STEPCAFControl_Controller(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_STEPCAFControl_Controller self)

        Nullify the handle


        """
        return _STEPCAFControl.Handle_STEPCAFControl_Controller_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_STEPCAFControl_Controller self) -> bool

        Check for being null

        :rtype: bool

        """
        return _STEPCAFControl.Handle_STEPCAFControl_Controller_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_STEPCAFControl_Controller self, STEPCAFControl_Controller thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _STEPCAFControl.Handle_STEPCAFControl_Controller_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_STEPCAFControl_Controller self, Handle_STEPCAFControl_Controller theHandle) -> Handle_STEPCAFControl_Controller
        assign(Handle_STEPCAFControl_Controller self, STEPCAFControl_Controller thePtr) -> Handle_STEPCAFControl_Controller
        assign(Handle_STEPCAFControl_Controller self, Handle_STEPCAFControl_Controller theHandle) -> Handle_STEPCAFControl_Controller

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _STEPCAFControl.Handle_STEPCAFControl_Controller_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_STEPCAFControl_Controller self) -> STEPCAFControl_Controller

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _STEPCAFControl.Handle_STEPCAFControl_Controller_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_STEPCAFControl_Controller self) -> STEPCAFControl_Controller

        Member access operator (note non-const)

        :rtype: T *

        """
        return _STEPCAFControl.Handle_STEPCAFControl_Controller___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_STEPCAFControl_Controller self) -> STEPCAFControl_Controller

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _STEPCAFControl.Handle_STEPCAFControl_Controller___ref__(self, *args)


    def __hash__(self):
        return _STEPCAFControl.Handle_STEPCAFControl_Controller___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _STEPCAFControl.Handle_STEPCAFControl_Controller___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _STEPCAFControl.new_Handle_STEPCAFControl_Controller(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_STEPCAFControl.Handle_STEPCAFControl_Controller_DownCast)
    __swig_destroy__ = _STEPCAFControl.delete_Handle_STEPCAFControl_Controller

    def Init(self, *args):
        """
        Init(Handle_STEPCAFControl_Controller self) -> Standard_Boolean

        Standard Initialisation. It creates a Controller for STEP-XCAF
        and records it to various names, available to select it later
        Returns True when done, False if could not be done

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _STEPCAFControl.Handle_STEPCAFControl_Controller_Init(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_STEPCAFControl_Controller self) -> char const *

        :rtype: const char *

        """
        return _STEPCAFControl.Handle_STEPCAFControl_Controller_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _STEPCAFControl.Handle_STEPCAFControl_Controller_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _STEPCAFControl.Handle_STEPCAFControl_Controller_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def NewModel(self, *args):
        """
        NewModel(Handle_STEPCAFControl_Controller self) -> Handle_Interface_InterfaceModel

        Creates a new empty Model ready to receive data of the Norm.
        It is taken from STEP Template Model

        :rtype: OCC.wrapper.Interface.Handle_Interface_InterfaceModel

        """
        return _STEPCAFControl.Handle_STEPCAFControl_Controller_NewModel(self, *args)


    def Customise(self, *args):
        """
        Customise(Handle_STEPCAFControl_Controller self, Handle_XSControl_WorkSession WS)

        :type WS: OCC.wrapper.XSControl.Handle_XSControl_WorkSession

        """
        return _STEPCAFControl.Handle_STEPCAFControl_Controller_Customise(self, *args)


    def TransferWriteShape(self, *args):
        """
        TransferWriteShape(Handle_STEPCAFControl_Controller self, TopoDS_Shape shape, Handle_Transfer_FinderProcess FP, Handle_Interface_InterfaceModel model, Standard_Integer const modetrans=0) -> IFSelect_ReturnStatus

        Takes one Shape and transfers it to the InterfaceModel
        (already created by NewModel for instance)
        <modeshape> is to be interpreted by each kind of XstepAdaptor
        Returns a status : 0 OK  1 No result  2 Fail  -1 bad modeshape
        -2 bad model (requires a StepModel)
        modeshape : 1 Facetted BRep, 2 Shell, 3 Manifold Solid

        :type shape: OCC.wrapper.TopoDS.TopoDS_Shape
        :type FP: OCC.wrapper.Transfer.Handle_Transfer_FinderProcess
        :type model: OCC.wrapper.Interface.Handle_Interface_InterfaceModel
        :type modetrans: int
        :rtype: OCC.wrapper.IFSelect.IFSelect_ReturnStatus

        """
        return _STEPCAFControl.Handle_STEPCAFControl_Controller_TransferWriteShape(self, *args)


    def SetNames(self, *args):
        """
        SetNames(Handle_STEPCAFControl_Controller self, Standard_CString const theLongName, Standard_CString const theShortName)

        Changes names
        if a name is empty, the formerly set one remains
        Remark : Does not call Record or AutoRecord

        :type theLongName: OCC.wrapper.Standard.Standard_CString
        :type theShortName: OCC.wrapper.Standard.Standard_CString

        """
        return _STEPCAFControl.Handle_STEPCAFControl_Controller_SetNames(self, *args)


    def AutoRecord(self, *args):
        """
        AutoRecord(Handle_STEPCAFControl_Controller self)

        Records <me> is a general dictionary under Short and Long
        Names (see method Name)


        """
        return _STEPCAFControl.Handle_STEPCAFControl_Controller_AutoRecord(self, *args)


    def Record(self, *args):
        """
        Record(Handle_STEPCAFControl_Controller self, Standard_CString const name)

        Records <me> in a general dictionary under a name
        Error if <name> already used for another one

        :type name: OCC.wrapper.Standard.Standard_CString

        """
        return _STEPCAFControl.Handle_STEPCAFControl_Controller_Record(self, *args)


    def Recorded(self, *args):
        """
        Recorded(Handle_STEPCAFControl_Controller self, Standard_CString const name) -> Handle_XSControl_Controller

        Returns the Controller attached to a given name
        Returns a Null Handle if <name> is unknown

        :type name: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.XSControl.Handle_XSControl_Controller

        """
        return _STEPCAFControl.Handle_STEPCAFControl_Controller_Recorded(self, *args)


    def Name(self, *args):
        """
        Name(Handle_STEPCAFControl_Controller self, Standard_Boolean const rsc) -> Standard_CString

        Returns a name, as given when initializing :
        rsc = False (D) : True Name attached to the Norm (long name)
        rsc = True : Name of the ressource set (i.e. short name)

        :type rsc: bool
        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _STEPCAFControl.Handle_STEPCAFControl_Controller_Name(self, *args)


    def Protocol(self, *args):
        """
        Returns the Protocol attached to the Norm (from field)

        :rtype: OCC.wrapper.Interface.Handle_Interface_Protocol

        """
        res = _STEPCAFControl.Handle_STEPCAFControl_Controller_Protocol(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def WorkLibrary(self, *args):
        """
        Returns the WorkLibrary attached to the Norm. Remark that it
        has to be in phase with the Protocol  (read from field)

        :rtype: OCC.wrapper.IFSelect.Handle_IFSelect_WorkLibrary

        """
        res = _STEPCAFControl.Handle_STEPCAFControl_Controller_WorkLibrary(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ActorRead(self, *args):
        """
        ActorRead(Handle_STEPCAFControl_Controller self, Handle_Interface_InterfaceModel model) -> Handle_Transfer_ActorOfTransientProcess

        Returns the Actor for Read attached to the pair (norm,appli)
        It can be adapted for data of the input Model, as required
        Can be read from field then adapted with Model as required

        :type model: OCC.wrapper.Interface.Handle_Interface_InterfaceModel
        :rtype: OCC.wrapper.Transfer.Handle_Transfer_ActorOfTransientProcess

        """
        return _STEPCAFControl.Handle_STEPCAFControl_Controller_ActorRead(self, *args)


    def ActorWrite(self, *args):
        """
        ActorWrite(Handle_STEPCAFControl_Controller self) -> Handle_Transfer_ActorOfFinderProcess

        Returns the Actor for Write attached to the pair (norm,appli)
        Read from field. Can be redefined

        :rtype: OCC.wrapper.Transfer.Handle_Transfer_ActorOfFinderProcess

        """
        return _STEPCAFControl.Handle_STEPCAFControl_Controller_ActorWrite(self, *args)


    def SetModeWrite(self, *args):
        """
        SetModeWrite(Handle_STEPCAFControl_Controller self, Standard_Integer const modemin, Standard_Integer const modemax, Standard_Boolean const shape)

        Sets mininum and maximum values for modetrans (write)
        Erases formerly recorded bounds and values
        Actually only for shape
        Then, for each value a little help can be attached

        :type modemin: int
        :type modemax: int
        :type shape: bool

        """
        return _STEPCAFControl.Handle_STEPCAFControl_Controller_SetModeWrite(self, *args)


    def SetModeWriteHelp(self, *args):
        """
        SetModeWriteHelp(Handle_STEPCAFControl_Controller self, Standard_Integer const modetrans, Standard_CString const help, Standard_Boolean const shape)

        Attaches a short line of help to a value of modetrans (write)

        :type modetrans: int
        :type help: OCC.wrapper.Standard.Standard_CString
        :type shape: bool

        """
        return _STEPCAFControl.Handle_STEPCAFControl_Controller_SetModeWriteHelp(self, *args)


    def ModeWriteBounds(self, *args):
        """
        ModeWriteBounds(Handle_STEPCAFControl_Controller self, Standard_Boolean const shape) -> Standard_Boolean

        Returns recorded min and max values for modetrans (write)
        Actually only for shapes
        Returns True if bounds are set, False else (then, free value)

        :type modemin: int
        :type modemax: int
        :type shape: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _STEPCAFControl.Handle_STEPCAFControl_Controller_ModeWriteBounds(self, *args)


    def IsModeWrite(self, *args):
        """
        IsModeWrite(Handle_STEPCAFControl_Controller self, Standard_Integer const modetrans, Standard_Boolean const shape) -> Standard_Boolean

        Tells if a value of <modetrans> is a good value(within bounds)
        Actually only for shapes

        :type modetrans: int
        :type shape: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _STEPCAFControl.Handle_STEPCAFControl_Controller_IsModeWrite(self, *args)


    def ModeWriteHelp(self, *args):
        """
        ModeWriteHelp(Handle_STEPCAFControl_Controller self, Standard_Integer const modetrans, Standard_Boolean const shape) -> Standard_CString

        Returns the help line recorded for a value of modetrans
        empty if help not defined or not within bounds or if values are free

        :type modetrans: int
        :type shape: bool
        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _STEPCAFControl.Handle_STEPCAFControl_Controller_ModeWriteHelp(self, *args)


    def RecognizeWriteTransient(self, *args):
        """
        RecognizeWriteTransient(Handle_STEPCAFControl_Controller self, Handle_Standard_Transient obj, Standard_Integer const modetrans=0) -> Standard_Boolean

        Tells if <obj> (an application object) is a valid candidate
        for a transfer to a Model.
        By default, asks the ActorWrite if known (through a
        TransientMapper). Can be redefined

        :type obj: OCC.wrapper.Standard.Handle_Standard_Transient
        :type modetrans: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _STEPCAFControl.Handle_STEPCAFControl_Controller_RecognizeWriteTransient(self, *args)


    def TransferWriteTransient(self, *args):
        """
        TransferWriteTransient(Handle_STEPCAFControl_Controller self, Handle_Standard_Transient obj, Handle_Transfer_FinderProcess FP, Handle_Interface_InterfaceModel model, Standard_Integer const modetrans=0) -> IFSelect_ReturnStatus

        Takes one Transient Object and transfers it to an
        InterfaceModel (already created, e.g. by NewModel)
        (result is recorded in the model by AddWithRefs)
        FP records produced results and checks

        Default uses ActorWrite; can be redefined as necessary
        Returned value is a status, as follows :
        0  OK ,  1 No Result ,  2 Fail (e.g. exception raised)
        -1 bad conditions ,  -2 bad model or null model
        For type of object not recognized : should return 1

        :type obj: OCC.wrapper.Standard.Handle_Standard_Transient
        :type FP: OCC.wrapper.Transfer.Handle_Transfer_FinderProcess
        :type model: OCC.wrapper.Interface.Handle_Interface_InterfaceModel
        :type modetrans: int
        :rtype: OCC.wrapper.IFSelect.IFSelect_ReturnStatus

        """
        return _STEPCAFControl.Handle_STEPCAFControl_Controller_TransferWriteTransient(self, *args)


    def RecognizeWriteShape(self, *args):
        """
        RecognizeWriteShape(Handle_STEPCAFControl_Controller self, TopoDS_Shape shape, Standard_Integer const modetrans=0) -> Standard_Boolean

        Tells if a shape is valid for a transfer to a model
        Asks the ActorWrite (through a ShapeMapper)

        :type shape: OCC.wrapper.TopoDS.TopoDS_Shape
        :type modetrans: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _STEPCAFControl.Handle_STEPCAFControl_Controller_RecognizeWriteShape(self, *args)


    def AddSessionItem(self, *args):
        """
        AddSessionItem(Handle_STEPCAFControl_Controller self, Handle_Standard_Transient theItem, Standard_CString const theName, Standard_Boolean const toApply)

        Records a Session Item, to be added for customisation of the Work Session.
        It must have a specific name.
        <setapplied> is used if <item> is a GeneralModifier, to decide
        If set to true, <item> will be applied to the hook list "send".
        Else, it is not applied to any hook list.
        Remark : this method is to be called at Create time,
        the recorded items will be used by Customise
        Warning : if <name> conflicts, the last recorded item is kept

        :type theItem: OCC.wrapper.Standard.Handle_Standard_Transient
        :type theName: OCC.wrapper.Standard.Standard_CString
        :type toApply: bool

        """
        return _STEPCAFControl.Handle_STEPCAFControl_Controller_AddSessionItem(self, *args)


    def SessionItem(self, *args):
        """
        SessionItem(Handle_STEPCAFControl_Controller self, Standard_CString const theName) -> Handle_Standard_Transient

        Returns an item given its name to record in a Session
        If <name> is unknown, returns a Null Handle

        :type theName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _STEPCAFControl.Handle_STEPCAFControl_Controller_SessionItem(self, *args)


    def AdaptorSession(self, *args):
        """
        :rtype: OCC.wrapper.XSControl.NCollection_DataMap_TCollection_AsciiString_Handle_Standard_Transient

        """
        res = _STEPCAFControl.Handle_STEPCAFControl_Controller_AdaptorSession(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_STEPCAFControl_Controller self)

        Memory deallocator for transient classes


        """
        return _STEPCAFControl.Handle_STEPCAFControl_Controller_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_STEPCAFControl_Controller self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_STEPCAFControl_Controller self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _STEPCAFControl.Handle_STEPCAFControl_Controller_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_STEPCAFControl_Controller self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_STEPCAFControl_Controller self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _STEPCAFControl.Handle_STEPCAFControl_Controller_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_STEPCAFControl_Controller self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _STEPCAFControl.Handle_STEPCAFControl_Controller_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_STEPCAFControl_Controller self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _STEPCAFControl.Handle_STEPCAFControl_Controller_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_STEPCAFControl_Controller self)

        Increments the reference counter of this object


        """
        return _STEPCAFControl.Handle_STEPCAFControl_Controller_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_STEPCAFControl_Controller self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _STEPCAFControl.Handle_STEPCAFControl_Controller_DecrementRefCounter(self, *args)

Handle_STEPCAFControl_Controller_swigregister = _STEPCAFControl.Handle_STEPCAFControl_Controller_swigregister
Handle_STEPCAFControl_Controller_swigregister(Handle_STEPCAFControl_Controller)

def Handle_STEPCAFControl_Controller_DownCast(thing):
    return _STEPCAFControl.Handle_STEPCAFControl_Controller_DownCast(thing)
Handle_STEPCAFControl_Controller_DownCast = _STEPCAFControl.Handle_STEPCAFControl_Controller_DownCast

class STEPCAFControl_Writer(object):
    """
    Provides a tool to write DECAF document to the
    STEP file. Besides transfer of shapes (including
    assemblies) provided by STEPControl, supports also
    colors and part names

    Also supports multifile writing
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(STEPCAFControl_Writer self) -> STEPCAFControl_Writer
        __init__(STEPCAFControl_Writer self, Handle_XSControl_WorkSession WS, Standard_Boolean const scratch) -> STEPCAFControl_Writer

        Creates a reader tool and attaches it to an already existing Session
        Clears the session if it was not yet set for STEP
        Clears the internal data structures

        :type WS: OCC.wrapper.XSControl.Handle_XSControl_WorkSession
        :type scratch: bool

        """
        this = _STEPCAFControl.new_STEPCAFControl_Writer(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(STEPCAFControl_Writer self, Handle_XSControl_WorkSession WS, Standard_Boolean const scratch)

        Clears the internal data structures and attaches to a new session
        Clears the session if it was not yet set for STEP

        :type WS: OCC.wrapper.XSControl.Handle_XSControl_WorkSession
        :type scratch: bool

        """
        return _STEPCAFControl.STEPCAFControl_Writer_Init(self, *args)


    def Write(self, *args):
        """
        Write(STEPCAFControl_Writer self, Standard_CString const filename) -> IFSelect_ReturnStatus

        Writes all the produced models into file
        In case of multimodel with extern references,
        filename will be a name of root file, all other files
        have names of corresponding parts
        Provided for use like single-file writer

        :type filename: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.IFSelect.IFSelect_ReturnStatus

        """
        return _STEPCAFControl.STEPCAFControl_Writer_Write(self, *args)


    def Transfer(self, *args):
        """
        Transfer(STEPCAFControl_Writer self, Handle_TDocStd_Document doc, STEPControl_StepModelType const mode=STEPControl_AsIs, Standard_CString const multi=None) -> Standard_Boolean
        Transfer(STEPCAFControl_Writer self, TDF_Label L, STEPControl_StepModelType const mode=STEPControl_AsIs, Standard_CString const multi=None) -> Standard_Boolean

        Method to transfer part of the document specified by label

        :type L: OCC.wrapper.TDF.TDF_Label
        :type mode: OCC.wrapper.STEPControl.STEPControl_StepModelType
        :type multi: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _STEPCAFControl.STEPCAFControl_Writer_Transfer(self, *args)


    def Perform(self, *args):
        """
        Perform(STEPCAFControl_Writer self, Handle_TDocStd_Document doc, TCollection_AsciiString filename) -> Standard_Boolean
        Perform(STEPCAFControl_Writer self, Handle_TDocStd_Document doc, Standard_CString const filename) -> Standard_Boolean

        Transfers a document and writes it to a STEP file
        Returns True if translation is OK

        :type doc: OCC.wrapper.TDocStd.Handle_TDocStd_Document
        :type filename: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _STEPCAFControl.STEPCAFControl_Writer_Perform(self, *args)


    def ExternFiles(self, *args):
        """
        Returns data on external files
        Returns Null handle if no external files are read

        :rtype: OCC.wrapper.STEPCAFControl.NCollection_DataMap_TCollection_AsciiString_Handle_STEPCAFControl_ExternFile

        """
        res = _STEPCAFControl.STEPCAFControl_Writer_ExternFiles(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ExternFile(self, *args):
        """
        ExternFile(STEPCAFControl_Writer self, TDF_Label L, Handle_STEPCAFControl_ExternFile ef) -> Standard_Boolean
        ExternFile(STEPCAFControl_Writer self, Standard_CString const name, Handle_STEPCAFControl_ExternFile ef) -> Standard_Boolean

        Returns data on external file by its name
        Returns False if no external file with given name is read

        :type name: OCC.wrapper.Standard.Standard_CString
        :type ef: OCC.wrapper.STEPCAFControl.Handle_STEPCAFControl_ExternFile
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _STEPCAFControl.STEPCAFControl_Writer_ExternFile(self, *args)


    def ChangeWriter(self, *args):
        """
        ChangeWriter(STEPCAFControl_Writer self) -> STEPControl_Writer

        Returns basic reader for root file

        :rtype: OCC.wrapper.STEPControl.STEPControl_Writer

        """
        return _STEPCAFControl.STEPCAFControl_Writer_ChangeWriter(self, *args)


    def Writer(self, *args):
        """
        Returns basic reader as const

        :rtype: OCC.wrapper.STEPControl.STEPControl_Writer

        """
        res = _STEPCAFControl.STEPCAFControl_Writer_Writer(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetColorMode(self, *args):
        """
        SetColorMode(STEPCAFControl_Writer self, Standard_Boolean const colormode)

        Set ColorMode for indicate write Colors or not.

        :type colormode: bool

        """
        return _STEPCAFControl.STEPCAFControl_Writer_SetColorMode(self, *args)


    def GetColorMode(self, *args):
        """
        GetColorMode(STEPCAFControl_Writer self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _STEPCAFControl.STEPCAFControl_Writer_GetColorMode(self, *args)


    def SetNameMode(self, *args):
        """
        SetNameMode(STEPCAFControl_Writer self, Standard_Boolean const namemode)

        Set NameMode for indicate write Name or not.

        :type namemode: bool

        """
        return _STEPCAFControl.STEPCAFControl_Writer_SetNameMode(self, *args)


    def GetNameMode(self, *args):
        """
        GetNameMode(STEPCAFControl_Writer self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _STEPCAFControl.STEPCAFControl_Writer_GetNameMode(self, *args)


    def SetLayerMode(self, *args):
        """
        SetLayerMode(STEPCAFControl_Writer self, Standard_Boolean const layermode)

        Set LayerMode for indicate write Layers or not.

        :type layermode: bool

        """
        return _STEPCAFControl.STEPCAFControl_Writer_SetLayerMode(self, *args)


    def GetLayerMode(self, *args):
        """
        GetLayerMode(STEPCAFControl_Writer self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _STEPCAFControl.STEPCAFControl_Writer_GetLayerMode(self, *args)


    def SetPropsMode(self, *args):
        """
        SetPropsMode(STEPCAFControl_Writer self, Standard_Boolean const propsmode)

        PropsMode for indicate write Validation properties or not.

        :type propsmode: bool

        """
        return _STEPCAFControl.STEPCAFControl_Writer_SetPropsMode(self, *args)


    def GetPropsMode(self, *args):
        """
        GetPropsMode(STEPCAFControl_Writer self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _STEPCAFControl.STEPCAFControl_Writer_GetPropsMode(self, *args)


    def SetSHUOMode(self, *args):
        """
        SetSHUOMode(STEPCAFControl_Writer self, Standard_Boolean const shuomode)

        Set SHUO mode for indicate write SHUO or not.

        :type shuomode: bool

        """
        return _STEPCAFControl.STEPCAFControl_Writer_SetSHUOMode(self, *args)


    def GetSHUOMode(self, *args):
        """
        GetSHUOMode(STEPCAFControl_Writer self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _STEPCAFControl.STEPCAFControl_Writer_GetSHUOMode(self, *args)


    def SetDimTolMode(self, *args):
        """
        SetDimTolMode(STEPCAFControl_Writer self, Standard_Boolean const dimtolmode)

        Set dimtolmode for indicate write D&GTs or not.

        :type dimtolmode: bool

        """
        return _STEPCAFControl.STEPCAFControl_Writer_SetDimTolMode(self, *args)


    def GetDimTolMode(self, *args):
        """
        GetDimTolMode(STEPCAFControl_Writer self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _STEPCAFControl.STEPCAFControl_Writer_GetDimTolMode(self, *args)


    def SetMaterialMode(self, *args):
        """
        SetMaterialMode(STEPCAFControl_Writer self, Standard_Boolean const matmode)

        Set dimtolmode for indicate write D&GTs or not.

        :type matmode: bool

        """
        return _STEPCAFControl.STEPCAFControl_Writer_SetMaterialMode(self, *args)


    def GetMaterialMode(self, *args):
        """
        GetMaterialMode(STEPCAFControl_Writer self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _STEPCAFControl.STEPCAFControl_Writer_GetMaterialMode(self, *args)

    __swig_destroy__ = _STEPCAFControl.delete_STEPCAFControl_Writer
STEPCAFControl_Writer_swigregister = _STEPCAFControl.STEPCAFControl_Writer_swigregister
STEPCAFControl_Writer_swigregister(STEPCAFControl_Writer)

class NCollection_DataMap_TopoDS_Shape_Handle_StepBasic_ProductDefinition_TopTools_ShapeMapHasher(NCollection.NCollection_BaseMap):
    """
    Purpose:     The DataMap is a Map to store keys with associated
    Items. See Map  from NCollection for  a discussion
    about the number of buckets.

    The DataMap can be seen as an extended array where
    the Keys  are the   indices.  For this reason  the
    operator () is defined on DataMap to fetch an Item
    from a Key. So the following syntax can be used :

    anItem = aMap(aKey);
    aMap(aKey) = anItem;

    This analogy has its  limit.   aMap(aKey) = anItem
    can  be done only  if aKey was previously bound to
    an item in the map.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_DataMap_TopoDS_Shape_Handle_StepBasic_ProductDefinition_TopTools_ShapeMapHasher self) -> NCollection_DataMap< TopoDS_Shape,opencascade::handle< StepBasic_ProductDefinition >,TopTools_ShapeMapHasher >::iterator

        Returns an iterator pointing to the first element in the map.

        :rtype: iterator

        """
        return _STEPCAFControl.NCollection_DataMap_TopoDS_Shape_Handle_StepBasic_ProductDefinition_TopTools_ShapeMapHasher_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_DataMap_TopoDS_Shape_Handle_StepBasic_ProductDefinition_TopTools_ShapeMapHasher self) -> NCollection_DataMap< TopoDS_Shape,opencascade::handle< StepBasic_ProductDefinition >,TopTools_ShapeMapHasher >::iterator

        Returns an iterator referring to the past-the-end element in the map.

        :rtype: iterator

        """
        return _STEPCAFControl.NCollection_DataMap_TopoDS_Shape_Handle_StepBasic_ProductDefinition_TopTools_ShapeMapHasher_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_DataMap_TopoDS_Shape_Handle_StepBasic_ProductDefinition_TopTools_ShapeMapHasher self) -> NCollection_DataMap< TopoDS_Shape,opencascade::handle< StepBasic_ProductDefinition >,TopTools_ShapeMapHasher >::const_iterator

        Returns a const iterator pointing to the first element in the map.

        :rtype: const_iterator

        """
        return _STEPCAFControl.NCollection_DataMap_TopoDS_Shape_Handle_StepBasic_ProductDefinition_TopTools_ShapeMapHasher_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_DataMap_TopoDS_Shape_Handle_StepBasic_ProductDefinition_TopTools_ShapeMapHasher self) -> NCollection_DataMap< TopoDS_Shape,opencascade::handle< StepBasic_ProductDefinition >,TopTools_ShapeMapHasher >::const_iterator

        Returns a const iterator referring to the past-the-end element in the map.

        :rtype: const_iterator

        """
        return _STEPCAFControl.NCollection_DataMap_TopoDS_Shape_Handle_StepBasic_ProductDefinition_TopTools_ShapeMapHasher_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     The DataMap is a Map to store keys with associated
        Items. See Map  from NCollection for  a discussion
        about the number of buckets.

        The DataMap can be seen as an extended array where
        the Keys  are the   indices.  For this reason  the
        operator () is defined on DataMap to fetch an Item
        from a Key. So the following syntax can be used :

        anItem = aMap(aKey);
        aMap(aKey) = anItem;

        This analogy has its  limit.   aMap(aKey) = anItem
        can  be done only  if aKey was previously bound to
        an item in the map.
        """
        this = _STEPCAFControl.new_NCollection_DataMap_TopoDS_Shape_Handle_StepBasic_ProductDefinition_TopTools_ShapeMapHasher(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Exchange(self, *args):
        """
        Exchange(NCollection_DataMap_TopoDS_Shape_Handle_StepBasic_ProductDefinition_TopTools_ShapeMapHasher self, NCollection_DataMap_TopoDS_Shape_Handle_StepBasic_ProductDefinition_TopTools_ShapeMapHasher theOther)

        Exchange the content of two maps without re-allocations.
        Notice that allocators will be swapped as well!

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _STEPCAFControl.NCollection_DataMap_TopoDS_Shape_Handle_StepBasic_ProductDefinition_TopTools_ShapeMapHasher_Exchange(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_DataMap_TopoDS_Shape_Handle_StepBasic_ProductDefinition_TopTools_ShapeMapHasher self, NCollection_DataMap_TopoDS_Shape_Handle_StepBasic_ProductDefinition_TopTools_ShapeMapHasher theOther) -> NCollection_DataMap_TopoDS_Shape_Handle_StepBasic_ProductDefinition_TopTools_ShapeMapHasher

        Assignment.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _STEPCAFControl.NCollection_DataMap_TopoDS_Shape_Handle_StepBasic_ProductDefinition_TopTools_ShapeMapHasher_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_DataMap_TopoDS_Shape_Handle_StepBasic_ProductDefinition_TopTools_ShapeMapHasher self, NCollection_DataMap_TopoDS_Shape_Handle_StepBasic_ProductDefinition_TopTools_ShapeMapHasher theOther) -> NCollection_DataMap_TopoDS_Shape_Handle_StepBasic_ProductDefinition_TopTools_ShapeMapHasher

        Assignment operator

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _STEPCAFControl.NCollection_DataMap_TopoDS_Shape_Handle_StepBasic_ProductDefinition_TopTools_ShapeMapHasher_assign(self, *args)


    def ReSize(self, *args):
        """
        ReSize(NCollection_DataMap_TopoDS_Shape_Handle_StepBasic_ProductDefinition_TopTools_ShapeMapHasher self, Standard_Integer const N)

        ReSize

        :type N: int

        """
        return _STEPCAFControl.NCollection_DataMap_TopoDS_Shape_Handle_StepBasic_ProductDefinition_TopTools_ShapeMapHasher_ReSize(self, *args)


    def Bind(self, *args):
        """
        Bind(NCollection_DataMap_TopoDS_Shape_Handle_StepBasic_ProductDefinition_TopTools_ShapeMapHasher self, TopoDS_Shape theKey, Handle_StepBasic_ProductDefinition theItem) -> Standard_Boolean

        Bind binds Item to Key in map.
        @param theKey  key to add/update
        @param theItem new item; overrides value previously bound to the key, if any
        @return Standard_True if Key was not bound already

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _STEPCAFControl.NCollection_DataMap_TopoDS_Shape_Handle_StepBasic_ProductDefinition_TopTools_ShapeMapHasher_Bind(self, *args)


    def Bound(self, *args):
        """
        Bound(NCollection_DataMap_TopoDS_Shape_Handle_StepBasic_ProductDefinition_TopTools_ShapeMapHasher self, TopoDS_Shape theKey, Handle_StepBasic_ProductDefinition theItem) -> Handle_StepBasic_ProductDefinition

        Bound binds Item to Key in map. Returns modifiable Item 

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: TheItemType *

        """
        return _STEPCAFControl.NCollection_DataMap_TopoDS_Shape_Handle_StepBasic_ProductDefinition_TopTools_ShapeMapHasher_Bound(self, *args)


    def IsBound(self, *args):
        """
        IsBound(NCollection_DataMap_TopoDS_Shape_Handle_StepBasic_ProductDefinition_TopTools_ShapeMapHasher self, TopoDS_Shape theKey) -> Standard_Boolean

        IsBound

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _STEPCAFControl.NCollection_DataMap_TopoDS_Shape_Handle_StepBasic_ProductDefinition_TopTools_ShapeMapHasher_IsBound(self, *args)


    def UnBind(self, *args):
        """
        UnBind(NCollection_DataMap_TopoDS_Shape_Handle_StepBasic_ProductDefinition_TopTools_ShapeMapHasher self, TopoDS_Shape theKey) -> Standard_Boolean

        UnBind removes Item Key pair from map

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _STEPCAFControl.NCollection_DataMap_TopoDS_Shape_Handle_StepBasic_ProductDefinition_TopTools_ShapeMapHasher_UnBind(self, *args)


    def Seek(self, *args):
        """
        Seek(NCollection_DataMap_TopoDS_Shape_Handle_StepBasic_ProductDefinition_TopTools_ShapeMapHasher self, TopoDS_Shape theKey) -> Handle_StepBasic_ProductDefinition

        Seek returns pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: const TheItemType *

        """
        return _STEPCAFControl.NCollection_DataMap_TopoDS_Shape_Handle_StepBasic_ProductDefinition_TopTools_ShapeMapHasher_Seek(self, *args)


    def Find(self, *args):
        """
        Find returns the Item for Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _STEPCAFControl.NCollection_DataMap_TopoDS_Shape_Handle_StepBasic_ProductDefinition_TopTools_ShapeMapHasher_Find(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeSeek(self, *args):
        """
        ChangeSeek(NCollection_DataMap_TopoDS_Shape_Handle_StepBasic_ProductDefinition_TopTools_ShapeMapHasher self, TopoDS_Shape theKey) -> Handle_StepBasic_ProductDefinition

        ChangeSeek returns modifiable pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: TheItemType *

        """
        return _STEPCAFControl.NCollection_DataMap_TopoDS_Shape_Handle_StepBasic_ProductDefinition_TopTools_ShapeMapHasher_ChangeSeek(self, *args)


    def ChangeFind(self, *args):
        """
        ChangeFind(NCollection_DataMap_TopoDS_Shape_Handle_StepBasic_ProductDefinition_TopTools_ShapeMapHasher self, TopoDS_Shape theKey) -> Handle_StepBasic_ProductDefinition

        ChangeFind returns mofifiable Item by Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: TheItemType &

        """
        return _STEPCAFControl.NCollection_DataMap_TopoDS_Shape_Handle_StepBasic_ProductDefinition_TopTools_ShapeMapHasher_ChangeFind(self, *args)


    def __call__(self, *args):
        """
        operator ()

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _STEPCAFControl.NCollection_DataMap_TopoDS_Shape_Handle_StepBasic_ProductDefinition_TopTools_ShapeMapHasher___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Clear(self, *args):
        """
        Clear(NCollection_DataMap_TopoDS_Shape_Handle_StepBasic_ProductDefinition_TopTools_ShapeMapHasher self, Standard_Boolean const doReleaseMemory)
        Clear(NCollection_DataMap_TopoDS_Shape_Handle_StepBasic_ProductDefinition_TopTools_ShapeMapHasher self, Handle_NCollection_BaseAllocator theAllocator)

        Clear data and reset allocator

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _STEPCAFControl.NCollection_DataMap_TopoDS_Shape_Handle_StepBasic_ProductDefinition_TopTools_ShapeMapHasher_Clear(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_DataMap_TopoDS_Shape_Handle_StepBasic_ProductDefinition_TopTools_ShapeMapHasher self) -> Standard_Integer

        Size

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _STEPCAFControl.NCollection_DataMap_TopoDS_Shape_Handle_StepBasic_ProductDefinition_TopTools_ShapeMapHasher_Size(self, *args)


    def __iter__(self):
        return _STEPCAFControl.NCollection_DataMap_TopoDS_Shape_Handle_StepBasic_ProductDefinition_TopTools_ShapeMapHasher___iter__(self)
    __swig_destroy__ = _STEPCAFControl.delete_NCollection_DataMap_TopoDS_Shape_Handle_StepBasic_ProductDefinition_TopTools_ShapeMapHasher
NCollection_DataMap_TopoDS_Shape_Handle_StepBasic_ProductDefinition_TopTools_ShapeMapHasher_swigregister = _STEPCAFControl.NCollection_DataMap_TopoDS_Shape_Handle_StepBasic_ProductDefinition_TopTools_ShapeMapHasher_swigregister
NCollection_DataMap_TopoDS_Shape_Handle_StepBasic_ProductDefinition_TopTools_ShapeMapHasher_swigregister(NCollection_DataMap_TopoDS_Shape_Handle_StepBasic_ProductDefinition_TopTools_ShapeMapHasher)

class NCollection_DataMap_TopoDS_Shape_Handle_StepBasic_ProductDefinition_TopTools_ShapeMapHasher_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _STEPCAFControl.new_NCollection_DataMap_TopoDS_Shape_Handle_StepBasic_ProductDefinition_TopTools_ShapeMapHasher_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _STEPCAFControl.delete_NCollection_DataMap_TopoDS_Shape_Handle_StepBasic_ProductDefinition_TopTools_ShapeMapHasher_IteratorHelper

    def __next__(self):
        return _STEPCAFControl.NCollection_DataMap_TopoDS_Shape_Handle_StepBasic_ProductDefinition_TopTools_ShapeMapHasher_IteratorHelper___next__(self)
NCollection_DataMap_TopoDS_Shape_Handle_StepBasic_ProductDefinition_TopTools_ShapeMapHasher_IteratorHelper_swigregister = _STEPCAFControl.NCollection_DataMap_TopoDS_Shape_Handle_StepBasic_ProductDefinition_TopTools_ShapeMapHasher_IteratorHelper_swigregister
NCollection_DataMap_TopoDS_Shape_Handle_StepBasic_ProductDefinition_TopTools_ShapeMapHasher_IteratorHelper_swigregister(NCollection_DataMap_TopoDS_Shape_Handle_StepBasic_ProductDefinition_TopTools_ShapeMapHasher_IteratorHelper)


try:
	STEPCAFControl_DataMapOfShapePD = NCollection_DataMap_TopoDS_Shape_Handle_StepBasic_ProductDefinition_TopTools_ShapeMapHasher
except NameError:
	pass # does not exist, probably ignored

class NCollection_DataMap_Handle_StepShape_ShapeDefinitionRepresentation_Handle_STEPCAFControl_ExternFile_TColStd_MapTransientHasher(NCollection.NCollection_BaseMap):
    """
    Purpose:     The DataMap is a Map to store keys with associated
    Items. See Map  from NCollection for  a discussion
    about the number of buckets.

    The DataMap can be seen as an extended array where
    the Keys  are the   indices.  For this reason  the
    operator () is defined on DataMap to fetch an Item
    from a Key. So the following syntax can be used :

    anItem = aMap(aKey);
    aMap(aKey) = anItem;

    This analogy has its  limit.   aMap(aKey) = anItem
    can  be done only  if aKey was previously bound to
    an item in the map.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_DataMap_Handle_StepShape_ShapeDefinitionRepresentation_Handle_STEPCAFControl_ExternFile_TColStd_MapTransientHasher self) -> NCollection_DataMap< opencascade::handle< StepShape_ShapeDefinitionRepresentation >,opencascade::handle< STEPCAFControl_ExternFile >,TColStd_MapTransientHasher >::iterator

        Returns an iterator pointing to the first element in the map.

        :rtype: iterator

        """
        return _STEPCAFControl.NCollection_DataMap_Handle_StepShape_ShapeDefinitionRepresentation_Handle_STEPCAFControl_ExternFile_TColStd_MapTransientHasher_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_DataMap_Handle_StepShape_ShapeDefinitionRepresentation_Handle_STEPCAFControl_ExternFile_TColStd_MapTransientHasher self) -> NCollection_DataMap< opencascade::handle< StepShape_ShapeDefinitionRepresentation >,opencascade::handle< STEPCAFControl_ExternFile >,TColStd_MapTransientHasher >::iterator

        Returns an iterator referring to the past-the-end element in the map.

        :rtype: iterator

        """
        return _STEPCAFControl.NCollection_DataMap_Handle_StepShape_ShapeDefinitionRepresentation_Handle_STEPCAFControl_ExternFile_TColStd_MapTransientHasher_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_DataMap_Handle_StepShape_ShapeDefinitionRepresentation_Handle_STEPCAFControl_ExternFile_TColStd_MapTransientHasher self) -> NCollection_DataMap< opencascade::handle< StepShape_ShapeDefinitionRepresentation >,opencascade::handle< STEPCAFControl_ExternFile >,TColStd_MapTransientHasher >::const_iterator

        Returns a const iterator pointing to the first element in the map.

        :rtype: const_iterator

        """
        return _STEPCAFControl.NCollection_DataMap_Handle_StepShape_ShapeDefinitionRepresentation_Handle_STEPCAFControl_ExternFile_TColStd_MapTransientHasher_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_DataMap_Handle_StepShape_ShapeDefinitionRepresentation_Handle_STEPCAFControl_ExternFile_TColStd_MapTransientHasher self) -> NCollection_DataMap< opencascade::handle< StepShape_ShapeDefinitionRepresentation >,opencascade::handle< STEPCAFControl_ExternFile >,TColStd_MapTransientHasher >::const_iterator

        Returns a const iterator referring to the past-the-end element in the map.

        :rtype: const_iterator

        """
        return _STEPCAFControl.NCollection_DataMap_Handle_StepShape_ShapeDefinitionRepresentation_Handle_STEPCAFControl_ExternFile_TColStd_MapTransientHasher_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     The DataMap is a Map to store keys with associated
        Items. See Map  from NCollection for  a discussion
        about the number of buckets.

        The DataMap can be seen as an extended array where
        the Keys  are the   indices.  For this reason  the
        operator () is defined on DataMap to fetch an Item
        from a Key. So the following syntax can be used :

        anItem = aMap(aKey);
        aMap(aKey) = anItem;

        This analogy has its  limit.   aMap(aKey) = anItem
        can  be done only  if aKey was previously bound to
        an item in the map.
        """
        this = _STEPCAFControl.new_NCollection_DataMap_Handle_StepShape_ShapeDefinitionRepresentation_Handle_STEPCAFControl_ExternFile_TColStd_MapTransientHasher(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Exchange(self, *args):
        """
        Exchange(NCollection_DataMap_Handle_StepShape_ShapeDefinitionRepresentation_Handle_STEPCAFControl_ExternFile_TColStd_MapTransientHasher self, NCollection_DataMap_Handle_StepShape_ShapeDefinitionRepresentation_Handle_STEPCAFControl_ExternFile_TColStd_MapTransientHasher theOther)

        Exchange the content of two maps without re-allocations.
        Notice that allocators will be swapped as well!

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _STEPCAFControl.NCollection_DataMap_Handle_StepShape_ShapeDefinitionRepresentation_Handle_STEPCAFControl_ExternFile_TColStd_MapTransientHasher_Exchange(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_DataMap_Handle_StepShape_ShapeDefinitionRepresentation_Handle_STEPCAFControl_ExternFile_TColStd_MapTransientHasher self, NCollection_DataMap_Handle_StepShape_ShapeDefinitionRepresentation_Handle_STEPCAFControl_ExternFile_TColStd_MapTransientHasher theOther) -> NCollection_DataMap_Handle_StepShape_ShapeDefinitionRepresentation_Handle_STEPCAFControl_ExternFile_TColStd_MapTransientHasher

        Assignment.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _STEPCAFControl.NCollection_DataMap_Handle_StepShape_ShapeDefinitionRepresentation_Handle_STEPCAFControl_ExternFile_TColStd_MapTransientHasher_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_DataMap_Handle_StepShape_ShapeDefinitionRepresentation_Handle_STEPCAFControl_ExternFile_TColStd_MapTransientHasher self, NCollection_DataMap_Handle_StepShape_ShapeDefinitionRepresentation_Handle_STEPCAFControl_ExternFile_TColStd_MapTransientHasher theOther) -> NCollection_DataMap_Handle_StepShape_ShapeDefinitionRepresentation_Handle_STEPCAFControl_ExternFile_TColStd_MapTransientHasher

        Assignment operator

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _STEPCAFControl.NCollection_DataMap_Handle_StepShape_ShapeDefinitionRepresentation_Handle_STEPCAFControl_ExternFile_TColStd_MapTransientHasher_assign(self, *args)


    def ReSize(self, *args):
        """
        ReSize(NCollection_DataMap_Handle_StepShape_ShapeDefinitionRepresentation_Handle_STEPCAFControl_ExternFile_TColStd_MapTransientHasher self, Standard_Integer const N)

        ReSize

        :type N: int

        """
        return _STEPCAFControl.NCollection_DataMap_Handle_StepShape_ShapeDefinitionRepresentation_Handle_STEPCAFControl_ExternFile_TColStd_MapTransientHasher_ReSize(self, *args)


    def Bind(self, *args):
        """
        Bind(NCollection_DataMap_Handle_StepShape_ShapeDefinitionRepresentation_Handle_STEPCAFControl_ExternFile_TColStd_MapTransientHasher self, Handle_StepShape_ShapeDefinitionRepresentation theKey, Handle_STEPCAFControl_ExternFile theItem) -> Standard_Boolean

        Bind binds Item to Key in map.
        @param theKey  key to add/update
        @param theItem new item; overrides value previously bound to the key, if any
        @return Standard_True if Key was not bound already

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _STEPCAFControl.NCollection_DataMap_Handle_StepShape_ShapeDefinitionRepresentation_Handle_STEPCAFControl_ExternFile_TColStd_MapTransientHasher_Bind(self, *args)


    def Bound(self, *args):
        """
        Bound(NCollection_DataMap_Handle_StepShape_ShapeDefinitionRepresentation_Handle_STEPCAFControl_ExternFile_TColStd_MapTransientHasher self, Handle_StepShape_ShapeDefinitionRepresentation theKey, Handle_STEPCAFControl_ExternFile theItem) -> Handle_STEPCAFControl_ExternFile

        Bound binds Item to Key in map. Returns modifiable Item 

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: TheItemType *

        """
        return _STEPCAFControl.NCollection_DataMap_Handle_StepShape_ShapeDefinitionRepresentation_Handle_STEPCAFControl_ExternFile_TColStd_MapTransientHasher_Bound(self, *args)


    def IsBound(self, *args):
        """
        IsBound(NCollection_DataMap_Handle_StepShape_ShapeDefinitionRepresentation_Handle_STEPCAFControl_ExternFile_TColStd_MapTransientHasher self, Handle_StepShape_ShapeDefinitionRepresentation theKey) -> Standard_Boolean

        IsBound

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _STEPCAFControl.NCollection_DataMap_Handle_StepShape_ShapeDefinitionRepresentation_Handle_STEPCAFControl_ExternFile_TColStd_MapTransientHasher_IsBound(self, *args)


    def UnBind(self, *args):
        """
        UnBind(NCollection_DataMap_Handle_StepShape_ShapeDefinitionRepresentation_Handle_STEPCAFControl_ExternFile_TColStd_MapTransientHasher self, Handle_StepShape_ShapeDefinitionRepresentation theKey) -> Standard_Boolean

        UnBind removes Item Key pair from map

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _STEPCAFControl.NCollection_DataMap_Handle_StepShape_ShapeDefinitionRepresentation_Handle_STEPCAFControl_ExternFile_TColStd_MapTransientHasher_UnBind(self, *args)


    def Seek(self, *args):
        """
        Seek(NCollection_DataMap_Handle_StepShape_ShapeDefinitionRepresentation_Handle_STEPCAFControl_ExternFile_TColStd_MapTransientHasher self, Handle_StepShape_ShapeDefinitionRepresentation theKey) -> Handle_STEPCAFControl_ExternFile

        Seek returns pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: const TheItemType *

        """
        return _STEPCAFControl.NCollection_DataMap_Handle_StepShape_ShapeDefinitionRepresentation_Handle_STEPCAFControl_ExternFile_TColStd_MapTransientHasher_Seek(self, *args)


    def Find(self, *args):
        """
        Find returns the Item for Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _STEPCAFControl.NCollection_DataMap_Handle_StepShape_ShapeDefinitionRepresentation_Handle_STEPCAFControl_ExternFile_TColStd_MapTransientHasher_Find(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeSeek(self, *args):
        """
        ChangeSeek(NCollection_DataMap_Handle_StepShape_ShapeDefinitionRepresentation_Handle_STEPCAFControl_ExternFile_TColStd_MapTransientHasher self, Handle_StepShape_ShapeDefinitionRepresentation theKey) -> Handle_STEPCAFControl_ExternFile

        ChangeSeek returns modifiable pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: TheItemType *

        """
        return _STEPCAFControl.NCollection_DataMap_Handle_StepShape_ShapeDefinitionRepresentation_Handle_STEPCAFControl_ExternFile_TColStd_MapTransientHasher_ChangeSeek(self, *args)


    def ChangeFind(self, *args):
        """
        ChangeFind(NCollection_DataMap_Handle_StepShape_ShapeDefinitionRepresentation_Handle_STEPCAFControl_ExternFile_TColStd_MapTransientHasher self, Handle_StepShape_ShapeDefinitionRepresentation theKey) -> Handle_STEPCAFControl_ExternFile

        ChangeFind returns mofifiable Item by Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: TheItemType &

        """
        return _STEPCAFControl.NCollection_DataMap_Handle_StepShape_ShapeDefinitionRepresentation_Handle_STEPCAFControl_ExternFile_TColStd_MapTransientHasher_ChangeFind(self, *args)


    def __call__(self, *args):
        """
        operator ()

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _STEPCAFControl.NCollection_DataMap_Handle_StepShape_ShapeDefinitionRepresentation_Handle_STEPCAFControl_ExternFile_TColStd_MapTransientHasher___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Clear(self, *args):
        """
        Clear(NCollection_DataMap_Handle_StepShape_ShapeDefinitionRepresentation_Handle_STEPCAFControl_ExternFile_TColStd_MapTransientHasher self, Standard_Boolean const doReleaseMemory)
        Clear(NCollection_DataMap_Handle_StepShape_ShapeDefinitionRepresentation_Handle_STEPCAFControl_ExternFile_TColStd_MapTransientHasher self, Handle_NCollection_BaseAllocator theAllocator)

        Clear data and reset allocator

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _STEPCAFControl.NCollection_DataMap_Handle_StepShape_ShapeDefinitionRepresentation_Handle_STEPCAFControl_ExternFile_TColStd_MapTransientHasher_Clear(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_DataMap_Handle_StepShape_ShapeDefinitionRepresentation_Handle_STEPCAFControl_ExternFile_TColStd_MapTransientHasher self) -> Standard_Integer

        Size

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _STEPCAFControl.NCollection_DataMap_Handle_StepShape_ShapeDefinitionRepresentation_Handle_STEPCAFControl_ExternFile_TColStd_MapTransientHasher_Size(self, *args)


    def __iter__(self):
        return _STEPCAFControl.NCollection_DataMap_Handle_StepShape_ShapeDefinitionRepresentation_Handle_STEPCAFControl_ExternFile_TColStd_MapTransientHasher___iter__(self)
    __swig_destroy__ = _STEPCAFControl.delete_NCollection_DataMap_Handle_StepShape_ShapeDefinitionRepresentation_Handle_STEPCAFControl_ExternFile_TColStd_MapTransientHasher
NCollection_DataMap_Handle_StepShape_ShapeDefinitionRepresentation_Handle_STEPCAFControl_ExternFile_TColStd_MapTransientHasher_swigregister = _STEPCAFControl.NCollection_DataMap_Handle_StepShape_ShapeDefinitionRepresentation_Handle_STEPCAFControl_ExternFile_TColStd_MapTransientHasher_swigregister
NCollection_DataMap_Handle_StepShape_ShapeDefinitionRepresentation_Handle_STEPCAFControl_ExternFile_TColStd_MapTransientHasher_swigregister(NCollection_DataMap_Handle_StepShape_ShapeDefinitionRepresentation_Handle_STEPCAFControl_ExternFile_TColStd_MapTransientHasher)

class NCollection_DataMap_Handle_StepShape_ShapeDefinitionRepresentation_Handle_STEPCAFControl_ExternFile_TColStd_MapTransientHasher_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _STEPCAFControl.new_NCollection_DataMap_Handle_StepShape_ShapeDefinitionRepresentation_Handle_STEPCAFControl_ExternFile_TColStd_MapTransientHasher_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _STEPCAFControl.delete_NCollection_DataMap_Handle_StepShape_ShapeDefinitionRepresentation_Handle_STEPCAFControl_ExternFile_TColStd_MapTransientHasher_IteratorHelper

    def __next__(self):
        return _STEPCAFControl.NCollection_DataMap_Handle_StepShape_ShapeDefinitionRepresentation_Handle_STEPCAFControl_ExternFile_TColStd_MapTransientHasher_IteratorHelper___next__(self)
NCollection_DataMap_Handle_StepShape_ShapeDefinitionRepresentation_Handle_STEPCAFControl_ExternFile_TColStd_MapTransientHasher_IteratorHelper_swigregister = _STEPCAFControl.NCollection_DataMap_Handle_StepShape_ShapeDefinitionRepresentation_Handle_STEPCAFControl_ExternFile_TColStd_MapTransientHasher_IteratorHelper_swigregister
NCollection_DataMap_Handle_StepShape_ShapeDefinitionRepresentation_Handle_STEPCAFControl_ExternFile_TColStd_MapTransientHasher_IteratorHelper_swigregister(NCollection_DataMap_Handle_StepShape_ShapeDefinitionRepresentation_Handle_STEPCAFControl_ExternFile_TColStd_MapTransientHasher_IteratorHelper)


try:
	STEPCAFControl_DataMapOfSDRExternFile = NCollection_DataMap_Handle_StepShape_ShapeDefinitionRepresentation_Handle_STEPCAFControl_ExternFile_TColStd_MapTransientHasher
except NameError:
	pass # does not exist, probably ignored

class NCollection_DataMap_TDF_Label_Handle_STEPCAFControl_ExternFile_TDF_LabelMapHasher(NCollection.NCollection_BaseMap):
    """
    Purpose:     The DataMap is a Map to store keys with associated
    Items. See Map  from NCollection for  a discussion
    about the number of buckets.

    The DataMap can be seen as an extended array where
    the Keys  are the   indices.  For this reason  the
    operator () is defined on DataMap to fetch an Item
    from a Key. So the following syntax can be used :

    anItem = aMap(aKey);
    aMap(aKey) = anItem;

    This analogy has its  limit.   aMap(aKey) = anItem
    can  be done only  if aKey was previously bound to
    an item in the map.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_DataMap_TDF_Label_Handle_STEPCAFControl_ExternFile_TDF_LabelMapHasher self) -> NCollection_DataMap< TDF_Label,opencascade::handle< STEPCAFControl_ExternFile >,TDF_LabelMapHasher >::iterator

        Returns an iterator pointing to the first element in the map.

        :rtype: iterator

        """
        return _STEPCAFControl.NCollection_DataMap_TDF_Label_Handle_STEPCAFControl_ExternFile_TDF_LabelMapHasher_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_DataMap_TDF_Label_Handle_STEPCAFControl_ExternFile_TDF_LabelMapHasher self) -> NCollection_DataMap< TDF_Label,opencascade::handle< STEPCAFControl_ExternFile >,TDF_LabelMapHasher >::iterator

        Returns an iterator referring to the past-the-end element in the map.

        :rtype: iterator

        """
        return _STEPCAFControl.NCollection_DataMap_TDF_Label_Handle_STEPCAFControl_ExternFile_TDF_LabelMapHasher_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_DataMap_TDF_Label_Handle_STEPCAFControl_ExternFile_TDF_LabelMapHasher self) -> NCollection_DataMap< TDF_Label,opencascade::handle< STEPCAFControl_ExternFile >,TDF_LabelMapHasher >::const_iterator

        Returns a const iterator pointing to the first element in the map.

        :rtype: const_iterator

        """
        return _STEPCAFControl.NCollection_DataMap_TDF_Label_Handle_STEPCAFControl_ExternFile_TDF_LabelMapHasher_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_DataMap_TDF_Label_Handle_STEPCAFControl_ExternFile_TDF_LabelMapHasher self) -> NCollection_DataMap< TDF_Label,opencascade::handle< STEPCAFControl_ExternFile >,TDF_LabelMapHasher >::const_iterator

        Returns a const iterator referring to the past-the-end element in the map.

        :rtype: const_iterator

        """
        return _STEPCAFControl.NCollection_DataMap_TDF_Label_Handle_STEPCAFControl_ExternFile_TDF_LabelMapHasher_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     The DataMap is a Map to store keys with associated
        Items. See Map  from NCollection for  a discussion
        about the number of buckets.

        The DataMap can be seen as an extended array where
        the Keys  are the   indices.  For this reason  the
        operator () is defined on DataMap to fetch an Item
        from a Key. So the following syntax can be used :

        anItem = aMap(aKey);
        aMap(aKey) = anItem;

        This analogy has its  limit.   aMap(aKey) = anItem
        can  be done only  if aKey was previously bound to
        an item in the map.
        """
        this = _STEPCAFControl.new_NCollection_DataMap_TDF_Label_Handle_STEPCAFControl_ExternFile_TDF_LabelMapHasher(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Exchange(self, *args):
        """
        Exchange(NCollection_DataMap_TDF_Label_Handle_STEPCAFControl_ExternFile_TDF_LabelMapHasher self, NCollection_DataMap_TDF_Label_Handle_STEPCAFControl_ExternFile_TDF_LabelMapHasher theOther)

        Exchange the content of two maps without re-allocations.
        Notice that allocators will be swapped as well!

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _STEPCAFControl.NCollection_DataMap_TDF_Label_Handle_STEPCAFControl_ExternFile_TDF_LabelMapHasher_Exchange(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_DataMap_TDF_Label_Handle_STEPCAFControl_ExternFile_TDF_LabelMapHasher self, NCollection_DataMap_TDF_Label_Handle_STEPCAFControl_ExternFile_TDF_LabelMapHasher theOther) -> NCollection_DataMap_TDF_Label_Handle_STEPCAFControl_ExternFile_TDF_LabelMapHasher

        Assignment.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _STEPCAFControl.NCollection_DataMap_TDF_Label_Handle_STEPCAFControl_ExternFile_TDF_LabelMapHasher_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_DataMap_TDF_Label_Handle_STEPCAFControl_ExternFile_TDF_LabelMapHasher self, NCollection_DataMap_TDF_Label_Handle_STEPCAFControl_ExternFile_TDF_LabelMapHasher theOther) -> NCollection_DataMap_TDF_Label_Handle_STEPCAFControl_ExternFile_TDF_LabelMapHasher

        Assignment operator

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _STEPCAFControl.NCollection_DataMap_TDF_Label_Handle_STEPCAFControl_ExternFile_TDF_LabelMapHasher_assign(self, *args)


    def ReSize(self, *args):
        """
        ReSize(NCollection_DataMap_TDF_Label_Handle_STEPCAFControl_ExternFile_TDF_LabelMapHasher self, Standard_Integer const N)

        ReSize

        :type N: int

        """
        return _STEPCAFControl.NCollection_DataMap_TDF_Label_Handle_STEPCAFControl_ExternFile_TDF_LabelMapHasher_ReSize(self, *args)


    def Bind(self, *args):
        """
        Bind(NCollection_DataMap_TDF_Label_Handle_STEPCAFControl_ExternFile_TDF_LabelMapHasher self, TDF_Label theKey, Handle_STEPCAFControl_ExternFile theItem) -> Standard_Boolean

        Bind binds Item to Key in map.
        @param theKey  key to add/update
        @param theItem new item; overrides value previously bound to the key, if any
        @return Standard_True if Key was not bound already

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _STEPCAFControl.NCollection_DataMap_TDF_Label_Handle_STEPCAFControl_ExternFile_TDF_LabelMapHasher_Bind(self, *args)


    def Bound(self, *args):
        """
        Bound(NCollection_DataMap_TDF_Label_Handle_STEPCAFControl_ExternFile_TDF_LabelMapHasher self, TDF_Label theKey, Handle_STEPCAFControl_ExternFile theItem) -> Handle_STEPCAFControl_ExternFile

        Bound binds Item to Key in map. Returns modifiable Item 

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: TheItemType *

        """
        return _STEPCAFControl.NCollection_DataMap_TDF_Label_Handle_STEPCAFControl_ExternFile_TDF_LabelMapHasher_Bound(self, *args)


    def IsBound(self, *args):
        """
        IsBound(NCollection_DataMap_TDF_Label_Handle_STEPCAFControl_ExternFile_TDF_LabelMapHasher self, TDF_Label theKey) -> Standard_Boolean

        IsBound

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _STEPCAFControl.NCollection_DataMap_TDF_Label_Handle_STEPCAFControl_ExternFile_TDF_LabelMapHasher_IsBound(self, *args)


    def UnBind(self, *args):
        """
        UnBind(NCollection_DataMap_TDF_Label_Handle_STEPCAFControl_ExternFile_TDF_LabelMapHasher self, TDF_Label theKey) -> Standard_Boolean

        UnBind removes Item Key pair from map

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _STEPCAFControl.NCollection_DataMap_TDF_Label_Handle_STEPCAFControl_ExternFile_TDF_LabelMapHasher_UnBind(self, *args)


    def Seek(self, *args):
        """
        Seek(NCollection_DataMap_TDF_Label_Handle_STEPCAFControl_ExternFile_TDF_LabelMapHasher self, TDF_Label theKey) -> Handle_STEPCAFControl_ExternFile

        Seek returns pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: const TheItemType *

        """
        return _STEPCAFControl.NCollection_DataMap_TDF_Label_Handle_STEPCAFControl_ExternFile_TDF_LabelMapHasher_Seek(self, *args)


    def Find(self, *args):
        """
        Find returns the Item for Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _STEPCAFControl.NCollection_DataMap_TDF_Label_Handle_STEPCAFControl_ExternFile_TDF_LabelMapHasher_Find(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeSeek(self, *args):
        """
        ChangeSeek(NCollection_DataMap_TDF_Label_Handle_STEPCAFControl_ExternFile_TDF_LabelMapHasher self, TDF_Label theKey) -> Handle_STEPCAFControl_ExternFile

        ChangeSeek returns modifiable pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: TheItemType *

        """
        return _STEPCAFControl.NCollection_DataMap_TDF_Label_Handle_STEPCAFControl_ExternFile_TDF_LabelMapHasher_ChangeSeek(self, *args)


    def ChangeFind(self, *args):
        """
        ChangeFind(NCollection_DataMap_TDF_Label_Handle_STEPCAFControl_ExternFile_TDF_LabelMapHasher self, TDF_Label theKey) -> Handle_STEPCAFControl_ExternFile

        ChangeFind returns mofifiable Item by Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: TheItemType &

        """
        return _STEPCAFControl.NCollection_DataMap_TDF_Label_Handle_STEPCAFControl_ExternFile_TDF_LabelMapHasher_ChangeFind(self, *args)


    def __call__(self, *args):
        """
        operator ()

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _STEPCAFControl.NCollection_DataMap_TDF_Label_Handle_STEPCAFControl_ExternFile_TDF_LabelMapHasher___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Clear(self, *args):
        """
        Clear(NCollection_DataMap_TDF_Label_Handle_STEPCAFControl_ExternFile_TDF_LabelMapHasher self, Standard_Boolean const doReleaseMemory)
        Clear(NCollection_DataMap_TDF_Label_Handle_STEPCAFControl_ExternFile_TDF_LabelMapHasher self, Handle_NCollection_BaseAllocator theAllocator)

        Clear data and reset allocator

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _STEPCAFControl.NCollection_DataMap_TDF_Label_Handle_STEPCAFControl_ExternFile_TDF_LabelMapHasher_Clear(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_DataMap_TDF_Label_Handle_STEPCAFControl_ExternFile_TDF_LabelMapHasher self) -> Standard_Integer

        Size

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _STEPCAFControl.NCollection_DataMap_TDF_Label_Handle_STEPCAFControl_ExternFile_TDF_LabelMapHasher_Size(self, *args)


    def __iter__(self):
        return _STEPCAFControl.NCollection_DataMap_TDF_Label_Handle_STEPCAFControl_ExternFile_TDF_LabelMapHasher___iter__(self)
    __swig_destroy__ = _STEPCAFControl.delete_NCollection_DataMap_TDF_Label_Handle_STEPCAFControl_ExternFile_TDF_LabelMapHasher
NCollection_DataMap_TDF_Label_Handle_STEPCAFControl_ExternFile_TDF_LabelMapHasher_swigregister = _STEPCAFControl.NCollection_DataMap_TDF_Label_Handle_STEPCAFControl_ExternFile_TDF_LabelMapHasher_swigregister
NCollection_DataMap_TDF_Label_Handle_STEPCAFControl_ExternFile_TDF_LabelMapHasher_swigregister(NCollection_DataMap_TDF_Label_Handle_STEPCAFControl_ExternFile_TDF_LabelMapHasher)

class NCollection_DataMap_TDF_Label_Handle_STEPCAFControl_ExternFile_TDF_LabelMapHasher_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _STEPCAFControl.new_NCollection_DataMap_TDF_Label_Handle_STEPCAFControl_ExternFile_TDF_LabelMapHasher_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _STEPCAFControl.delete_NCollection_DataMap_TDF_Label_Handle_STEPCAFControl_ExternFile_TDF_LabelMapHasher_IteratorHelper

    def __next__(self):
        return _STEPCAFControl.NCollection_DataMap_TDF_Label_Handle_STEPCAFControl_ExternFile_TDF_LabelMapHasher_IteratorHelper___next__(self)
NCollection_DataMap_TDF_Label_Handle_STEPCAFControl_ExternFile_TDF_LabelMapHasher_IteratorHelper_swigregister = _STEPCAFControl.NCollection_DataMap_TDF_Label_Handle_STEPCAFControl_ExternFile_TDF_LabelMapHasher_IteratorHelper_swigregister
NCollection_DataMap_TDF_Label_Handle_STEPCAFControl_ExternFile_TDF_LabelMapHasher_IteratorHelper_swigregister(NCollection_DataMap_TDF_Label_Handle_STEPCAFControl_ExternFile_TDF_LabelMapHasher_IteratorHelper)


try:
	STEPCAFControl_DataMapOfLabelExternFile = NCollection_DataMap_TDF_Label_Handle_STEPCAFControl_ExternFile_TDF_LabelMapHasher
except NameError:
	pass # does not exist, probably ignored




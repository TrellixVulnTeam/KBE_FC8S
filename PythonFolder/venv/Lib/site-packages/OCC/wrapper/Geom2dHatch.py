# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_Geom2dHatch')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_Geom2dHatch')
    _Geom2dHatch = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_Geom2dHatch', [dirname(__file__)])
        except ImportError:
            import _Geom2dHatch
            return _Geom2dHatch
        try:
            _mod = imp.load_module('_Geom2dHatch', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _Geom2dHatch = swig_import_helper()
    del swig_import_helper
else:
    import _Geom2dHatch
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


class SwigPyIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _Geom2dHatch.delete_SwigPyIterator

    def value(self):
        return _Geom2dHatch.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _Geom2dHatch.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _Geom2dHatch.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _Geom2dHatch.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _Geom2dHatch.SwigPyIterator_equal(self, x)

    def copy(self):
        return _Geom2dHatch.SwigPyIterator_copy(self)

    def next(self):
        return _Geom2dHatch.SwigPyIterator_next(self)

    def __next__(self):
        return _Geom2dHatch.SwigPyIterator___next__(self)

    def previous(self):
        return _Geom2dHatch.SwigPyIterator_previous(self)

    def advance(self, n):
        return _Geom2dHatch.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _Geom2dHatch.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _Geom2dHatch.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _Geom2dHatch.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _Geom2dHatch.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _Geom2dHatch.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _Geom2dHatch.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self
SwigPyIterator_swigregister = _Geom2dHatch.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

class NCollection_CellFilter_InspectorXYZ(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _Geom2dHatch.NCollection_CellFilter_InspectorXYZ_Dimension
    Coord = staticmethod(_Geom2dHatch.NCollection_CellFilter_InspectorXYZ_Coord)

    def Shift(self, thePnt, theTol):
        return _Geom2dHatch.NCollection_CellFilter_InspectorXYZ_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _Geom2dHatch.new_NCollection_CellFilter_InspectorXYZ()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _Geom2dHatch.delete_NCollection_CellFilter_InspectorXYZ
NCollection_CellFilter_InspectorXYZ_swigregister = _Geom2dHatch.NCollection_CellFilter_InspectorXYZ_swigregister
NCollection_CellFilter_InspectorXYZ_swigregister(NCollection_CellFilter_InspectorXYZ)

def NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt):
    return _Geom2dHatch.NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt)
NCollection_CellFilter_InspectorXYZ_Coord = _Geom2dHatch.NCollection_CellFilter_InspectorXYZ_Coord

class NCollection_CellFilter_InspectorXY(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _Geom2dHatch.NCollection_CellFilter_InspectorXY_Dimension
    Coord = staticmethod(_Geom2dHatch.NCollection_CellFilter_InspectorXY_Coord)

    def Shift(self, thePnt, theTol):
        return _Geom2dHatch.NCollection_CellFilter_InspectorXY_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _Geom2dHatch.new_NCollection_CellFilter_InspectorXY()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _Geom2dHatch.delete_NCollection_CellFilter_InspectorXY
NCollection_CellFilter_InspectorXY_swigregister = _Geom2dHatch.NCollection_CellFilter_InspectorXY_swigregister
NCollection_CellFilter_InspectorXY_swigregister(NCollection_CellFilter_InspectorXY)

def NCollection_CellFilter_InspectorXY_Coord(i, thePnt):
    return _Geom2dHatch.NCollection_CellFilter_InspectorXY_Coord(i, thePnt)
NCollection_CellFilter_InspectorXY_Coord = _Geom2dHatch.NCollection_CellFilter_InspectorXY_Coord


def ptr_to_number(item):
    return _Geom2dHatch.ptr_to_number(item)
ptr_to_number = _Geom2dHatch.ptr_to_number

def HashCode(*args):
    return _Geom2dHatch.HashCode(*args)
HashCode = _Geom2dHatch.HashCode

def ptr_equal(a, b):
    return _Geom2dHatch.ptr_equal(a, b)
ptr_equal = _Geom2dHatch.ptr_equal
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Geom2d
else:
    import Geom2d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import GeomAbs
else:
    import GeomAbs
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColStd
else:
    import TColStd
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TCollection
else:
    import TCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Standard
else:
    import Standard
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import NCollection
else:
    import NCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import gp
else:
    import gp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColgp
else:
    import TColgp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import HatchGen
else:
    import HatchGen
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopAbs
else:
    import TopAbs
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import IntRes2d
else:
    import IntRes2d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Geom2dAdaptor
else:
    import Geom2dAdaptor
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Adaptor2d
else:
    import Adaptor2d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Geom2dInt
else:
    import Geom2dInt
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Intf
else:
    import Intf
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Bnd
else:
    import Bnd
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import IntCurve
else:
    import IntCurve
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import math
else:
    import math
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Extrema
else:
    import Extrema
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import GeomAdaptor
else:
    import GeomAdaptor
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Geom
else:
    import Geom
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Adaptor3d
else:
    import Adaptor3d
del _swig_python_version_info
class Geom2dHatch_Hatching(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Geom2dHatch_Hatching self) -> Geom2dHatch_Hatching
        __init__(Geom2dHatch_Hatching self, Geom2dAdaptor_Curve Curve) -> Geom2dHatch_Hatching

        Creates a hatching.

        :type Curve: OCC.wrapper.Geom2dAdaptor.Geom2dAdaptor_Curve

        """
        this = _Geom2dHatch.new_Geom2dHatch_Hatching(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Curve(self, *args):
        """
        Returns the curve associated to the hatching.

        :rtype: OCC.wrapper.Geom2dAdaptor.Geom2dAdaptor_Curve

        """
        res = _Geom2dHatch.Geom2dHatch_Hatching_Curve(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeCurve(self, *args):
        """
        ChangeCurve(Geom2dHatch_Hatching self) -> Geom2dAdaptor_Curve

        Returns the curve associated to the hatching.

        :rtype: OCC.wrapper.Geom2dAdaptor.Geom2dAdaptor_Curve

        """
        return _Geom2dHatch.Geom2dHatch_Hatching_ChangeCurve(self, *args)


    def TrimDone(self, *args):
        """
        TrimDone(Geom2dHatch_Hatching self, Standard_Boolean const Flag)
        TrimDone(Geom2dHatch_Hatching self) -> Standard_Boolean

        Returns the flag about the trimming computations.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom2dHatch.Geom2dHatch_Hatching_TrimDone(self, *args)


    def TrimFailed(self, *args):
        """
        TrimFailed(Geom2dHatch_Hatching self, Standard_Boolean const Flag)
        TrimFailed(Geom2dHatch_Hatching self) -> Standard_Boolean

        Returns the flag about the trimming failure.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom2dHatch.Geom2dHatch_Hatching_TrimFailed(self, *args)


    def IsDone(self, *args):
        """
        IsDone(Geom2dHatch_Hatching self, Standard_Boolean const Flag)
        IsDone(Geom2dHatch_Hatching self) -> Standard_Boolean

        Returns the flag about the domains computation.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom2dHatch.Geom2dHatch_Hatching_IsDone(self, *args)


    def Status(self, *args):
        """
        Status(Geom2dHatch_Hatching self, HatchGen_ErrorStatus const theStatus)
        Status(Geom2dHatch_Hatching self) -> HatchGen_ErrorStatus

        Returns the error status.

        :rtype: OCC.wrapper.HatchGen.HatchGen_ErrorStatus

        """
        return _Geom2dHatch.Geom2dHatch_Hatching_Status(self, *args)


    def AddPoint(self, *args):
        """
        AddPoint(Geom2dHatch_Hatching self, HatchGen_PointOnHatching Point, Standard_Real const Confusion)

        Adds an intersection point to the hatching.

        :type Point: OCC.wrapper.HatchGen.HatchGen_PointOnHatching
        :type Confusion: float

        """
        return _Geom2dHatch.Geom2dHatch_Hatching_AddPoint(self, *args)


    def NbPoints(self, *args):
        """
        NbPoints(Geom2dHatch_Hatching self) -> Standard_Integer

        Returns the number of intersection points
        of the hatching.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom2dHatch.Geom2dHatch_Hatching_NbPoints(self, *args)


    def Point(self, *args):
        """
        Returns the Index-th intersection point of the
        hatching.
        The exception OutOfRange is raised if
        Index < 1 or Index > NbPoints.

        :type Index: int
        :rtype: OCC.wrapper.HatchGen.HatchGen_PointOnHatching

        """
        res = _Geom2dHatch.Geom2dHatch_Hatching_Point(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangePoint(self, *args):
        """
        ChangePoint(Geom2dHatch_Hatching self, Standard_Integer const Index) -> HatchGen_PointOnHatching

        Returns the Index-th intersection point of the
        hatching.
        The exception OutOfRange is raised if
        Index < 1 or Index > NbPoints.

        :type Index: int
        :rtype: OCC.wrapper.HatchGen.HatchGen_PointOnHatching

        """
        return _Geom2dHatch.Geom2dHatch_Hatching_ChangePoint(self, *args)


    def RemPoint(self, *args):
        """
        RemPoint(Geom2dHatch_Hatching self, Standard_Integer const Index)

        Removes the Index-th intersection point of the
        hatching.
        The exception OutOfRange is raised if
        Index < 1 or Index > NbPoints.

        :type Index: int

        """
        return _Geom2dHatch.Geom2dHatch_Hatching_RemPoint(self, *args)


    def ClrPoints(self, *args):
        """
        ClrPoints(Geom2dHatch_Hatching self)

        Removes all the intersection points of the hatching.


        """
        return _Geom2dHatch.Geom2dHatch_Hatching_ClrPoints(self, *args)


    def AddDomain(self, *args):
        """
        AddDomain(Geom2dHatch_Hatching self, HatchGen_Domain Domain)

        Adds a domain to the hatching.

        :type Domain: OCC.wrapper.HatchGen.HatchGen_Domain

        """
        return _Geom2dHatch.Geom2dHatch_Hatching_AddDomain(self, *args)


    def NbDomains(self, *args):
        """
        NbDomains(Geom2dHatch_Hatching self) -> Standard_Integer

        Returns the number of domains of the hatching.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom2dHatch.Geom2dHatch_Hatching_NbDomains(self, *args)


    def Domain(self, *args):
        """
        Returns the Index-th domain of the hatching.
        The exception OutOfRange is raised if
        Index < 1 or Index > NbDomains.

        :type Index: int
        :rtype: OCC.wrapper.HatchGen.HatchGen_Domain

        """
        res = _Geom2dHatch.Geom2dHatch_Hatching_Domain(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def RemDomain(self, *args):
        """
        RemDomain(Geom2dHatch_Hatching self, Standard_Integer const Index)

        Removes the Index-th domain of the hatching.
        The exception OutOfRange is raised if
        Index < 1 or Index > NbDomains.

        :type Index: int

        """
        return _Geom2dHatch.Geom2dHatch_Hatching_RemDomain(self, *args)


    def ClrDomains(self, *args):
        """
        ClrDomains(Geom2dHatch_Hatching self)

        Removes all the domains of the hatching.


        """
        return _Geom2dHatch.Geom2dHatch_Hatching_ClrDomains(self, *args)


    def ClassificationPoint(self, *args):
        """
        ClassificationPoint(Geom2dHatch_Hatching self) -> gp_Pnt2d

        Returns a point on the curve.
        This point will be used for the classification.

        :rtype: OCC.wrapper.gp.gp_Pnt2d

        """
        return _Geom2dHatch.Geom2dHatch_Hatching_ClassificationPoint(self, *args)

    __swig_destroy__ = _Geom2dHatch.delete_Geom2dHatch_Hatching
Geom2dHatch_Hatching_swigregister = _Geom2dHatch.Geom2dHatch_Hatching_swigregister
Geom2dHatch_Hatching_swigregister(Geom2dHatch_Hatching)

class Geom2dHatch_Element(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Geom2dHatch_Element self) -> Geom2dHatch_Element
        __init__(Geom2dHatch_Element self, Geom2dHatch_Element Other) -> Geom2dHatch_Element
        __init__(Geom2dHatch_Element self, Geom2dAdaptor_Curve Curve, TopAbs_Orientation const Orientation=TopAbs_FORWARD) -> Geom2dHatch_Element

        Creates an element.

        :type Curve: OCC.wrapper.Geom2dAdaptor.Geom2dAdaptor_Curve
        :type Orientation: OCC.wrapper.TopAbs.TopAbs_Orientation

        """
        this = _Geom2dHatch.new_Geom2dHatch_Element(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Curve(self, *args):
        """
        Returns the curve associated to the element.

        :rtype: OCC.wrapper.Geom2dAdaptor.Geom2dAdaptor_Curve

        """
        res = _Geom2dHatch.Geom2dHatch_Element_Curve(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeCurve(self, *args):
        """
        ChangeCurve(Geom2dHatch_Element self) -> Geom2dAdaptor_Curve

        Returns the curve associated to the element.

        :rtype: OCC.wrapper.Geom2dAdaptor.Geom2dAdaptor_Curve

        """
        return _Geom2dHatch.Geom2dHatch_Element_ChangeCurve(self, *args)


    def Orientation(self, *args):
        """
        Orientation(Geom2dHatch_Element self, TopAbs_Orientation const Orientation)
        Orientation(Geom2dHatch_Element self) -> TopAbs_Orientation

        Returns the orientation of the element.

        :rtype: OCC.wrapper.TopAbs.TopAbs_Orientation

        """
        return _Geom2dHatch.Geom2dHatch_Element_Orientation(self, *args)

    __swig_destroy__ = _Geom2dHatch.delete_Geom2dHatch_Element
Geom2dHatch_Element_swigregister = _Geom2dHatch.Geom2dHatch_Element_swigregister
Geom2dHatch_Element_swigregister(Geom2dHatch_Element)

class Geom2dHatch_Classifier(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Geom2dHatch_Classifier self) -> Geom2dHatch_Classifier
        __init__(Geom2dHatch_Classifier self, Geom2dHatch_Elements F, gp_Pnt2d P, Standard_Real const Tol) -> Geom2dHatch_Classifier

        Creates an algorithm to classify the Point  P with
        Tolerance <T> on the face described by <F>.

        :type F: OCC.wrapper.Geom2dHatch.Geom2dHatch_Elements
        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type Tol: float

        """
        this = _Geom2dHatch.new_Geom2dHatch_Classifier(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Perform(self, *args):
        """
        Perform(Geom2dHatch_Classifier self, Geom2dHatch_Elements F, gp_Pnt2d P, Standard_Real const Tol)

        Classify  the Point  P  with  Tolerance <T> on the
        face described by <F>.

        :type F: OCC.wrapper.Geom2dHatch.Geom2dHatch_Elements
        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type Tol: float

        """
        return _Geom2dHatch.Geom2dHatch_Classifier_Perform(self, *args)


    def State(self, *args):
        """
        State(Geom2dHatch_Classifier self) -> TopAbs_State

        Returns the result of the classification.

        :rtype: OCC.wrapper.TopAbs.TopAbs_State

        """
        return _Geom2dHatch.Geom2dHatch_Classifier_State(self, *args)


    def Rejected(self, *args):
        """
        Rejected(Geom2dHatch_Classifier self) -> Standard_Boolean

        Returns  True when  the   state was computed by  a
        rejection. The state is OUT.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom2dHatch.Geom2dHatch_Classifier_Rejected(self, *args)


    def NoWires(self, *args):
        """
        NoWires(Geom2dHatch_Classifier self) -> Standard_Boolean

        Returns True if  the face  contains  no wire.  The
        state is IN.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom2dHatch.Geom2dHatch_Classifier_NoWires(self, *args)


    def Edge(self, *args):
        """
        Returns   the    Edge  used   to    determine  the
        classification. When the State is ON  this  is the
        Edge containing the point.

        :rtype: OCC.wrapper.Geom2dAdaptor.Geom2dAdaptor_Curve

        """
        res = _Geom2dHatch.Geom2dHatch_Classifier_Edge(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def EdgeParameter(self, *args):
        """
        EdgeParameter(Geom2dHatch_Classifier self) -> Standard_Real

        Returns the parameter on Edge() used to determine  the
        classification.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2dHatch.Geom2dHatch_Classifier_EdgeParameter(self, *args)


    def Position(self, *args):
        """
        Position(Geom2dHatch_Classifier self) -> IntRes2d_Position

        Returns the  position of  the   point on the  edge
        returned by Edge.

        :rtype: OCC.wrapper.IntRes2d.IntRes2d_Position

        """
        return _Geom2dHatch.Geom2dHatch_Classifier_Position(self, *args)

    __swig_destroy__ = _Geom2dHatch.delete_Geom2dHatch_Classifier
Geom2dHatch_Classifier_swigregister = _Geom2dHatch.Geom2dHatch_Classifier_swigregister
Geom2dHatch_Classifier_swigregister(Geom2dHatch_Classifier)

class NCollection_DataMap_Standard_Integer_Geom2dHatch_Element_TColStd_MapIntegerHasher(NCollection.NCollection_BaseMap):
    """
    Purpose:     The DataMap is a Map to store keys with associated
    Items. See Map  from NCollection for  a discussion
    about the number of buckets.

    The DataMap can be seen as an extended array where
    the Keys  are the   indices.  For this reason  the
    operator () is defined on DataMap to fetch an Item
    from a Key. So the following syntax can be used :

    anItem = aMap(aKey);
    aMap(aKey) = anItem;

    This analogy has its  limit.   aMap(aKey) = anItem
    can  be done only  if aKey was previously bound to
    an item in the map.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_DataMap_Standard_Integer_Geom2dHatch_Element_TColStd_MapIntegerHasher self) -> NCollection_DataMap< Standard_Integer,Geom2dHatch_Element,TColStd_MapIntegerHasher >::iterator

        Returns an iterator pointing to the first element in the map.

        :rtype: iterator

        """
        return _Geom2dHatch.NCollection_DataMap_Standard_Integer_Geom2dHatch_Element_TColStd_MapIntegerHasher_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_DataMap_Standard_Integer_Geom2dHatch_Element_TColStd_MapIntegerHasher self) -> NCollection_DataMap< Standard_Integer,Geom2dHatch_Element,TColStd_MapIntegerHasher >::iterator

        Returns an iterator referring to the past-the-end element in the map.

        :rtype: iterator

        """
        return _Geom2dHatch.NCollection_DataMap_Standard_Integer_Geom2dHatch_Element_TColStd_MapIntegerHasher_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_DataMap_Standard_Integer_Geom2dHatch_Element_TColStd_MapIntegerHasher self) -> NCollection_DataMap< Standard_Integer,Geom2dHatch_Element,TColStd_MapIntegerHasher >::const_iterator

        Returns a const iterator pointing to the first element in the map.

        :rtype: const_iterator

        """
        return _Geom2dHatch.NCollection_DataMap_Standard_Integer_Geom2dHatch_Element_TColStd_MapIntegerHasher_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_DataMap_Standard_Integer_Geom2dHatch_Element_TColStd_MapIntegerHasher self) -> NCollection_DataMap< Standard_Integer,Geom2dHatch_Element,TColStd_MapIntegerHasher >::const_iterator

        Returns a const iterator referring to the past-the-end element in the map.

        :rtype: const_iterator

        """
        return _Geom2dHatch.NCollection_DataMap_Standard_Integer_Geom2dHatch_Element_TColStd_MapIntegerHasher_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     The DataMap is a Map to store keys with associated
        Items. See Map  from NCollection for  a discussion
        about the number of buckets.

        The DataMap can be seen as an extended array where
        the Keys  are the   indices.  For this reason  the
        operator () is defined on DataMap to fetch an Item
        from a Key. So the following syntax can be used :

        anItem = aMap(aKey);
        aMap(aKey) = anItem;

        This analogy has its  limit.   aMap(aKey) = anItem
        can  be done only  if aKey was previously bound to
        an item in the map.
        """
        this = _Geom2dHatch.new_NCollection_DataMap_Standard_Integer_Geom2dHatch_Element_TColStd_MapIntegerHasher(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Exchange(self, *args):
        """
        Exchange(NCollection_DataMap_Standard_Integer_Geom2dHatch_Element_TColStd_MapIntegerHasher self, NCollection_DataMap_Standard_Integer_Geom2dHatch_Element_TColStd_MapIntegerHasher theOther)

        Exchange the content of two maps without re-allocations.
        Notice that allocators will be swapped as well!

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _Geom2dHatch.NCollection_DataMap_Standard_Integer_Geom2dHatch_Element_TColStd_MapIntegerHasher_Exchange(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_DataMap_Standard_Integer_Geom2dHatch_Element_TColStd_MapIntegerHasher self, NCollection_DataMap_Standard_Integer_Geom2dHatch_Element_TColStd_MapIntegerHasher theOther) -> NCollection_DataMap_Standard_Integer_Geom2dHatch_Element_TColStd_MapIntegerHasher

        Assignment.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _Geom2dHatch.NCollection_DataMap_Standard_Integer_Geom2dHatch_Element_TColStd_MapIntegerHasher_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_DataMap_Standard_Integer_Geom2dHatch_Element_TColStd_MapIntegerHasher self, NCollection_DataMap_Standard_Integer_Geom2dHatch_Element_TColStd_MapIntegerHasher theOther) -> NCollection_DataMap_Standard_Integer_Geom2dHatch_Element_TColStd_MapIntegerHasher

        Assignment operator

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _Geom2dHatch.NCollection_DataMap_Standard_Integer_Geom2dHatch_Element_TColStd_MapIntegerHasher_assign(self, *args)


    def ReSize(self, *args):
        """
        ReSize(NCollection_DataMap_Standard_Integer_Geom2dHatch_Element_TColStd_MapIntegerHasher self, Standard_Integer const N)

        ReSize

        :type N: int

        """
        return _Geom2dHatch.NCollection_DataMap_Standard_Integer_Geom2dHatch_Element_TColStd_MapIntegerHasher_ReSize(self, *args)


    def Bind(self, *args):
        """
        Bind(NCollection_DataMap_Standard_Integer_Geom2dHatch_Element_TColStd_MapIntegerHasher self, int const & theKey, Geom2dHatch_Element theItem) -> Standard_Boolean

        Bind binds Item to Key in map.
        @param theKey  key to add/update
        @param theItem new item; overrides value previously bound to the key, if any
        @return Standard_True if Key was not bound already

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom2dHatch.NCollection_DataMap_Standard_Integer_Geom2dHatch_Element_TColStd_MapIntegerHasher_Bind(self, *args)


    def Bound(self, *args):
        """
        Bound(NCollection_DataMap_Standard_Integer_Geom2dHatch_Element_TColStd_MapIntegerHasher self, int const & theKey, Geom2dHatch_Element theItem) -> Geom2dHatch_Element

        Bound binds Item to Key in map. Returns modifiable Item 

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: TheItemType *

        """
        return _Geom2dHatch.NCollection_DataMap_Standard_Integer_Geom2dHatch_Element_TColStd_MapIntegerHasher_Bound(self, *args)


    def IsBound(self, *args):
        """
        IsBound(NCollection_DataMap_Standard_Integer_Geom2dHatch_Element_TColStd_MapIntegerHasher self, int const & theKey) -> Standard_Boolean

        IsBound

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom2dHatch.NCollection_DataMap_Standard_Integer_Geom2dHatch_Element_TColStd_MapIntegerHasher_IsBound(self, *args)


    def UnBind(self, *args):
        """
        UnBind(NCollection_DataMap_Standard_Integer_Geom2dHatch_Element_TColStd_MapIntegerHasher self, int const & theKey) -> Standard_Boolean

        UnBind removes Item Key pair from map

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom2dHatch.NCollection_DataMap_Standard_Integer_Geom2dHatch_Element_TColStd_MapIntegerHasher_UnBind(self, *args)


    def Seek(self, *args):
        """
        Seek(NCollection_DataMap_Standard_Integer_Geom2dHatch_Element_TColStd_MapIntegerHasher self, int const & theKey) -> Geom2dHatch_Element

        Seek returns pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: const TheItemType *

        """
        return _Geom2dHatch.NCollection_DataMap_Standard_Integer_Geom2dHatch_Element_TColStd_MapIntegerHasher_Seek(self, *args)


    def Find(self, *args):
        """
        Find returns the Item for Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _Geom2dHatch.NCollection_DataMap_Standard_Integer_Geom2dHatch_Element_TColStd_MapIntegerHasher_Find(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeSeek(self, *args):
        """
        ChangeSeek(NCollection_DataMap_Standard_Integer_Geom2dHatch_Element_TColStd_MapIntegerHasher self, int const & theKey) -> Geom2dHatch_Element

        ChangeSeek returns modifiable pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: TheItemType *

        """
        return _Geom2dHatch.NCollection_DataMap_Standard_Integer_Geom2dHatch_Element_TColStd_MapIntegerHasher_ChangeSeek(self, *args)


    def ChangeFind(self, *args):
        """
        ChangeFind(NCollection_DataMap_Standard_Integer_Geom2dHatch_Element_TColStd_MapIntegerHasher self, int const & theKey) -> Geom2dHatch_Element

        ChangeFind returns mofifiable Item by Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: TheItemType &

        """
        return _Geom2dHatch.NCollection_DataMap_Standard_Integer_Geom2dHatch_Element_TColStd_MapIntegerHasher_ChangeFind(self, *args)


    def __call__(self, *args):
        """
        operator ()

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _Geom2dHatch.NCollection_DataMap_Standard_Integer_Geom2dHatch_Element_TColStd_MapIntegerHasher___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Clear(self, *args):
        """
        Clear(NCollection_DataMap_Standard_Integer_Geom2dHatch_Element_TColStd_MapIntegerHasher self, Standard_Boolean const doReleaseMemory)
        Clear(NCollection_DataMap_Standard_Integer_Geom2dHatch_Element_TColStd_MapIntegerHasher self, Handle_NCollection_BaseAllocator theAllocator)

        Clear data and reset allocator

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _Geom2dHatch.NCollection_DataMap_Standard_Integer_Geom2dHatch_Element_TColStd_MapIntegerHasher_Clear(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_DataMap_Standard_Integer_Geom2dHatch_Element_TColStd_MapIntegerHasher self) -> Standard_Integer

        Size

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom2dHatch.NCollection_DataMap_Standard_Integer_Geom2dHatch_Element_TColStd_MapIntegerHasher_Size(self, *args)


    def __iter__(self):
        return _Geom2dHatch.NCollection_DataMap_Standard_Integer_Geom2dHatch_Element_TColStd_MapIntegerHasher___iter__(self)
    __swig_destroy__ = _Geom2dHatch.delete_NCollection_DataMap_Standard_Integer_Geom2dHatch_Element_TColStd_MapIntegerHasher
NCollection_DataMap_Standard_Integer_Geom2dHatch_Element_TColStd_MapIntegerHasher_swigregister = _Geom2dHatch.NCollection_DataMap_Standard_Integer_Geom2dHatch_Element_TColStd_MapIntegerHasher_swigregister
NCollection_DataMap_Standard_Integer_Geom2dHatch_Element_TColStd_MapIntegerHasher_swigregister(NCollection_DataMap_Standard_Integer_Geom2dHatch_Element_TColStd_MapIntegerHasher)

class NCollection_DataMap_Standard_Integer_Geom2dHatch_Element_TColStd_MapIntegerHasher_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _Geom2dHatch.new_NCollection_DataMap_Standard_Integer_Geom2dHatch_Element_TColStd_MapIntegerHasher_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _Geom2dHatch.delete_NCollection_DataMap_Standard_Integer_Geom2dHatch_Element_TColStd_MapIntegerHasher_IteratorHelper

    def __next__(self):
        return _Geom2dHatch.NCollection_DataMap_Standard_Integer_Geom2dHatch_Element_TColStd_MapIntegerHasher_IteratorHelper___next__(self)
NCollection_DataMap_Standard_Integer_Geom2dHatch_Element_TColStd_MapIntegerHasher_IteratorHelper_swigregister = _Geom2dHatch.NCollection_DataMap_Standard_Integer_Geom2dHatch_Element_TColStd_MapIntegerHasher_IteratorHelper_swigregister
NCollection_DataMap_Standard_Integer_Geom2dHatch_Element_TColStd_MapIntegerHasher_IteratorHelper_swigregister(NCollection_DataMap_Standard_Integer_Geom2dHatch_Element_TColStd_MapIntegerHasher_IteratorHelper)


try:
	Geom2dHatch_MapOfElements = NCollection_DataMap_Standard_Integer_Geom2dHatch_Element_TColStd_MapIntegerHasher
except NameError:
	pass # does not exist, probably ignored

class NCollection_DataMap_Standard_Integer_Geom2dHatch_Hatching_TColStd_MapIntegerHasher(NCollection.NCollection_BaseMap):
    """
    Purpose:     The DataMap is a Map to store keys with associated
    Items. See Map  from NCollection for  a discussion
    about the number of buckets.

    The DataMap can be seen as an extended array where
    the Keys  are the   indices.  For this reason  the
    operator () is defined on DataMap to fetch an Item
    from a Key. So the following syntax can be used :

    anItem = aMap(aKey);
    aMap(aKey) = anItem;

    This analogy has its  limit.   aMap(aKey) = anItem
    can  be done only  if aKey was previously bound to
    an item in the map.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_DataMap_Standard_Integer_Geom2dHatch_Hatching_TColStd_MapIntegerHasher self) -> NCollection_DataMap< Standard_Integer,Geom2dHatch_Hatching,TColStd_MapIntegerHasher >::iterator

        Returns an iterator pointing to the first element in the map.

        :rtype: iterator

        """
        return _Geom2dHatch.NCollection_DataMap_Standard_Integer_Geom2dHatch_Hatching_TColStd_MapIntegerHasher_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_DataMap_Standard_Integer_Geom2dHatch_Hatching_TColStd_MapIntegerHasher self) -> NCollection_DataMap< Standard_Integer,Geom2dHatch_Hatching,TColStd_MapIntegerHasher >::iterator

        Returns an iterator referring to the past-the-end element in the map.

        :rtype: iterator

        """
        return _Geom2dHatch.NCollection_DataMap_Standard_Integer_Geom2dHatch_Hatching_TColStd_MapIntegerHasher_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_DataMap_Standard_Integer_Geom2dHatch_Hatching_TColStd_MapIntegerHasher self) -> NCollection_DataMap< Standard_Integer,Geom2dHatch_Hatching,TColStd_MapIntegerHasher >::const_iterator

        Returns a const iterator pointing to the first element in the map.

        :rtype: const_iterator

        """
        return _Geom2dHatch.NCollection_DataMap_Standard_Integer_Geom2dHatch_Hatching_TColStd_MapIntegerHasher_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_DataMap_Standard_Integer_Geom2dHatch_Hatching_TColStd_MapIntegerHasher self) -> NCollection_DataMap< Standard_Integer,Geom2dHatch_Hatching,TColStd_MapIntegerHasher >::const_iterator

        Returns a const iterator referring to the past-the-end element in the map.

        :rtype: const_iterator

        """
        return _Geom2dHatch.NCollection_DataMap_Standard_Integer_Geom2dHatch_Hatching_TColStd_MapIntegerHasher_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     The DataMap is a Map to store keys with associated
        Items. See Map  from NCollection for  a discussion
        about the number of buckets.

        The DataMap can be seen as an extended array where
        the Keys  are the   indices.  For this reason  the
        operator () is defined on DataMap to fetch an Item
        from a Key. So the following syntax can be used :

        anItem = aMap(aKey);
        aMap(aKey) = anItem;

        This analogy has its  limit.   aMap(aKey) = anItem
        can  be done only  if aKey was previously bound to
        an item in the map.
        """
        this = _Geom2dHatch.new_NCollection_DataMap_Standard_Integer_Geom2dHatch_Hatching_TColStd_MapIntegerHasher(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Exchange(self, *args):
        """
        Exchange(NCollection_DataMap_Standard_Integer_Geom2dHatch_Hatching_TColStd_MapIntegerHasher self, NCollection_DataMap_Standard_Integer_Geom2dHatch_Hatching_TColStd_MapIntegerHasher theOther)

        Exchange the content of two maps without re-allocations.
        Notice that allocators will be swapped as well!

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _Geom2dHatch.NCollection_DataMap_Standard_Integer_Geom2dHatch_Hatching_TColStd_MapIntegerHasher_Exchange(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_DataMap_Standard_Integer_Geom2dHatch_Hatching_TColStd_MapIntegerHasher self, NCollection_DataMap_Standard_Integer_Geom2dHatch_Hatching_TColStd_MapIntegerHasher theOther) -> NCollection_DataMap_Standard_Integer_Geom2dHatch_Hatching_TColStd_MapIntegerHasher

        Assignment.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _Geom2dHatch.NCollection_DataMap_Standard_Integer_Geom2dHatch_Hatching_TColStd_MapIntegerHasher_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_DataMap_Standard_Integer_Geom2dHatch_Hatching_TColStd_MapIntegerHasher self, NCollection_DataMap_Standard_Integer_Geom2dHatch_Hatching_TColStd_MapIntegerHasher theOther) -> NCollection_DataMap_Standard_Integer_Geom2dHatch_Hatching_TColStd_MapIntegerHasher

        Assignment operator

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _Geom2dHatch.NCollection_DataMap_Standard_Integer_Geom2dHatch_Hatching_TColStd_MapIntegerHasher_assign(self, *args)


    def ReSize(self, *args):
        """
        ReSize(NCollection_DataMap_Standard_Integer_Geom2dHatch_Hatching_TColStd_MapIntegerHasher self, Standard_Integer const N)

        ReSize

        :type N: int

        """
        return _Geom2dHatch.NCollection_DataMap_Standard_Integer_Geom2dHatch_Hatching_TColStd_MapIntegerHasher_ReSize(self, *args)


    def Bind(self, *args):
        """
        Bind(NCollection_DataMap_Standard_Integer_Geom2dHatch_Hatching_TColStd_MapIntegerHasher self, int const & theKey, Geom2dHatch_Hatching theItem) -> Standard_Boolean

        Bind binds Item to Key in map.
        @param theKey  key to add/update
        @param theItem new item; overrides value previously bound to the key, if any
        @return Standard_True if Key was not bound already

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom2dHatch.NCollection_DataMap_Standard_Integer_Geom2dHatch_Hatching_TColStd_MapIntegerHasher_Bind(self, *args)


    def Bound(self, *args):
        """
        Bound(NCollection_DataMap_Standard_Integer_Geom2dHatch_Hatching_TColStd_MapIntegerHasher self, int const & theKey, Geom2dHatch_Hatching theItem) -> Geom2dHatch_Hatching

        Bound binds Item to Key in map. Returns modifiable Item 

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: TheItemType *

        """
        return _Geom2dHatch.NCollection_DataMap_Standard_Integer_Geom2dHatch_Hatching_TColStd_MapIntegerHasher_Bound(self, *args)


    def IsBound(self, *args):
        """
        IsBound(NCollection_DataMap_Standard_Integer_Geom2dHatch_Hatching_TColStd_MapIntegerHasher self, int const & theKey) -> Standard_Boolean

        IsBound

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom2dHatch.NCollection_DataMap_Standard_Integer_Geom2dHatch_Hatching_TColStd_MapIntegerHasher_IsBound(self, *args)


    def UnBind(self, *args):
        """
        UnBind(NCollection_DataMap_Standard_Integer_Geom2dHatch_Hatching_TColStd_MapIntegerHasher self, int const & theKey) -> Standard_Boolean

        UnBind removes Item Key pair from map

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom2dHatch.NCollection_DataMap_Standard_Integer_Geom2dHatch_Hatching_TColStd_MapIntegerHasher_UnBind(self, *args)


    def Seek(self, *args):
        """
        Seek(NCollection_DataMap_Standard_Integer_Geom2dHatch_Hatching_TColStd_MapIntegerHasher self, int const & theKey) -> Geom2dHatch_Hatching

        Seek returns pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: const TheItemType *

        """
        return _Geom2dHatch.NCollection_DataMap_Standard_Integer_Geom2dHatch_Hatching_TColStd_MapIntegerHasher_Seek(self, *args)


    def Find(self, *args):
        """
        Find returns the Item for Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _Geom2dHatch.NCollection_DataMap_Standard_Integer_Geom2dHatch_Hatching_TColStd_MapIntegerHasher_Find(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeSeek(self, *args):
        """
        ChangeSeek(NCollection_DataMap_Standard_Integer_Geom2dHatch_Hatching_TColStd_MapIntegerHasher self, int const & theKey) -> Geom2dHatch_Hatching

        ChangeSeek returns modifiable pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: TheItemType *

        """
        return _Geom2dHatch.NCollection_DataMap_Standard_Integer_Geom2dHatch_Hatching_TColStd_MapIntegerHasher_ChangeSeek(self, *args)


    def ChangeFind(self, *args):
        """
        ChangeFind(NCollection_DataMap_Standard_Integer_Geom2dHatch_Hatching_TColStd_MapIntegerHasher self, int const & theKey) -> Geom2dHatch_Hatching

        ChangeFind returns mofifiable Item by Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: TheItemType &

        """
        return _Geom2dHatch.NCollection_DataMap_Standard_Integer_Geom2dHatch_Hatching_TColStd_MapIntegerHasher_ChangeFind(self, *args)


    def __call__(self, *args):
        """
        operator ()

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _Geom2dHatch.NCollection_DataMap_Standard_Integer_Geom2dHatch_Hatching_TColStd_MapIntegerHasher___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Clear(self, *args):
        """
        Clear(NCollection_DataMap_Standard_Integer_Geom2dHatch_Hatching_TColStd_MapIntegerHasher self, Standard_Boolean const doReleaseMemory)
        Clear(NCollection_DataMap_Standard_Integer_Geom2dHatch_Hatching_TColStd_MapIntegerHasher self, Handle_NCollection_BaseAllocator theAllocator)

        Clear data and reset allocator

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _Geom2dHatch.NCollection_DataMap_Standard_Integer_Geom2dHatch_Hatching_TColStd_MapIntegerHasher_Clear(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_DataMap_Standard_Integer_Geom2dHatch_Hatching_TColStd_MapIntegerHasher self) -> Standard_Integer

        Size

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom2dHatch.NCollection_DataMap_Standard_Integer_Geom2dHatch_Hatching_TColStd_MapIntegerHasher_Size(self, *args)


    def __iter__(self):
        return _Geom2dHatch.NCollection_DataMap_Standard_Integer_Geom2dHatch_Hatching_TColStd_MapIntegerHasher___iter__(self)
    __swig_destroy__ = _Geom2dHatch.delete_NCollection_DataMap_Standard_Integer_Geom2dHatch_Hatching_TColStd_MapIntegerHasher
NCollection_DataMap_Standard_Integer_Geom2dHatch_Hatching_TColStd_MapIntegerHasher_swigregister = _Geom2dHatch.NCollection_DataMap_Standard_Integer_Geom2dHatch_Hatching_TColStd_MapIntegerHasher_swigregister
NCollection_DataMap_Standard_Integer_Geom2dHatch_Hatching_TColStd_MapIntegerHasher_swigregister(NCollection_DataMap_Standard_Integer_Geom2dHatch_Hatching_TColStd_MapIntegerHasher)

class NCollection_DataMap_Standard_Integer_Geom2dHatch_Hatching_TColStd_MapIntegerHasher_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _Geom2dHatch.new_NCollection_DataMap_Standard_Integer_Geom2dHatch_Hatching_TColStd_MapIntegerHasher_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _Geom2dHatch.delete_NCollection_DataMap_Standard_Integer_Geom2dHatch_Hatching_TColStd_MapIntegerHasher_IteratorHelper

    def __next__(self):
        return _Geom2dHatch.NCollection_DataMap_Standard_Integer_Geom2dHatch_Hatching_TColStd_MapIntegerHasher_IteratorHelper___next__(self)
NCollection_DataMap_Standard_Integer_Geom2dHatch_Hatching_TColStd_MapIntegerHasher_IteratorHelper_swigregister = _Geom2dHatch.NCollection_DataMap_Standard_Integer_Geom2dHatch_Hatching_TColStd_MapIntegerHasher_IteratorHelper_swigregister
NCollection_DataMap_Standard_Integer_Geom2dHatch_Hatching_TColStd_MapIntegerHasher_IteratorHelper_swigregister(NCollection_DataMap_Standard_Integer_Geom2dHatch_Hatching_TColStd_MapIntegerHasher_IteratorHelper)


try:
	Geom2dHatch_Hatchings = NCollection_DataMap_Standard_Integer_Geom2dHatch_Hatching_TColStd_MapIntegerHasher
except NameError:
	pass # does not exist, probably ignored

class Geom2dHatch_Intersector(Geom2dInt.Geom2dInt_GInter):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def ConfusionTolerance(self, *args):
        """
        ConfusionTolerance(Geom2dHatch_Intersector self) -> Standard_Real

        Returns the confusion tolerance of the
        intersector.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2dHatch.Geom2dHatch_Intersector_ConfusionTolerance(self, *args)


    def SetConfusionTolerance(self, *args):
        """
        SetConfusionTolerance(Geom2dHatch_Intersector self, Standard_Real const Confusion)

        Sets the confusion tolerance of the intersector.

        :type Confusion: float

        """
        return _Geom2dHatch.Geom2dHatch_Intersector_SetConfusionTolerance(self, *args)


    def TangencyTolerance(self, *args):
        """
        TangencyTolerance(Geom2dHatch_Intersector self) -> Standard_Real

        Returns the tangency tolerance of the
        intersector.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2dHatch.Geom2dHatch_Intersector_TangencyTolerance(self, *args)


    def SetTangencyTolerance(self, *args):
        """
        SetTangencyTolerance(Geom2dHatch_Intersector self, Standard_Real const Tangency)

        Sets the tangency tolerance of the intersector.

        :type Tangency: float

        """
        return _Geom2dHatch.Geom2dHatch_Intersector_SetTangencyTolerance(self, *args)


    def Intersect(self, *args):
        """
        Intersect(Geom2dHatch_Intersector self, Geom2dAdaptor_Curve C1, Geom2dAdaptor_Curve C2)

        Intersects the curves C1 and C2.
        The results are retreived by the usual methods
        described in IntRes2d_Intersection.
        Creates an intersector.

        :type C1: OCC.wrapper.Geom2dAdaptor.Geom2dAdaptor_Curve
        :type C2: OCC.wrapper.Geom2dAdaptor.Geom2dAdaptor_Curve

        """
        return _Geom2dHatch.Geom2dHatch_Intersector_Intersect(self, *args)


    def __init__(self, *args):
        """
        __init__(Geom2dHatch_Intersector self, Standard_Real const Confusion, Standard_Real const Tangency) -> Geom2dHatch_Intersector
        __init__(Geom2dHatch_Intersector self) -> Geom2dHatch_Intersector

        Creates an intersector.

        :type Confusion: float
        :type Tangency: float

        """
        this = _Geom2dHatch.new_Geom2dHatch_Intersector(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Perform(self, *args):
        """
        Perform(Geom2dHatch_Intersector self, gp_Lin2d L, Standard_Real const P, Standard_Real const Tol, Geom2dAdaptor_Curve E)

        Performs the intersection   between the  2d   line
        segment (<L>, <P>) and  the  Curve <E>.  The  line
        segment  is the  part  of  the  2d   line   <L> of
        parameter range [0, <P>] (P is positive and can be
        RealLast()). Tol is the  Tolerance on the segment.
        The order  is relevant, the  first argument is the
        segment, the second the Edge.

        :type L: OCC.wrapper.gp.gp_Lin2d
        :type P: float
        :type Tol: float
        :type E: OCC.wrapper.Geom2dAdaptor.Geom2dAdaptor_Curve

        """
        return _Geom2dHatch.Geom2dHatch_Intersector_Perform(self, *args)


    def LocalGeometry(self, *args):
        """
        LocalGeometry(Geom2dHatch_Intersector self, Geom2dAdaptor_Curve E, Standard_Real const U, gp_Dir2d T, gp_Dir2d N)

        Returns in <T>,  <N> and <C>  the tangent,  normal
        and  curvature of the edge  <E> at parameter value
        <U>.

        :type E: OCC.wrapper.Geom2dAdaptor.Geom2dAdaptor_Curve
        :type U: float
        :type T: OCC.wrapper.gp.gp_Dir2d
        :type N: OCC.wrapper.gp.gp_Dir2d
        :type C: float

        """
        return _Geom2dHatch.Geom2dHatch_Intersector_LocalGeometry(self, *args)

    __swig_destroy__ = _Geom2dHatch.delete_Geom2dHatch_Intersector
Geom2dHatch_Intersector_swigregister = _Geom2dHatch.Geom2dHatch_Intersector_swigregister
Geom2dHatch_Intersector_swigregister(Geom2dHatch_Intersector)

class Geom2dHatch_FClass2dOfClassifier(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Geom2dHatch_FClass2dOfClassifier self) -> Geom2dHatch_FClass2dOfClassifier

        Creates an undefined classifier.


        """
        this = _Geom2dHatch.new_Geom2dHatch_FClass2dOfClassifier(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Reset(self, *args):
        """
        Reset(Geom2dHatch_FClass2dOfClassifier self, gp_Lin2d L, Standard_Real const P, Standard_Real const Tol)

        Starts  a  classification process.   The  point to
        classify is the origin of  the  line <L>.  <P>  is
        the original length of the segment on <L>  used to
        compute  intersections.   <Tol> is the   tolerance
        attached to the line segment in intersections.

        :type L: OCC.wrapper.gp.gp_Lin2d
        :type P: float
        :type Tol: float

        """
        return _Geom2dHatch.Geom2dHatch_FClass2dOfClassifier_Reset(self, *args)


    def Compare(self, *args):
        """
        Compare(Geom2dHatch_FClass2dOfClassifier self, Geom2dAdaptor_Curve E, TopAbs_Orientation const Or)

        Updates  the classification process with  the edge
        <E> from the boundary.

        :type E: OCC.wrapper.Geom2dAdaptor.Geom2dAdaptor_Curve
        :type Or: OCC.wrapper.TopAbs.TopAbs_Orientation

        """
        return _Geom2dHatch.Geom2dHatch_FClass2dOfClassifier_Compare(self, *args)


    def Parameter(self, *args):
        """
        Parameter(Geom2dHatch_FClass2dOfClassifier self) -> Standard_Real

        Returns the current value of the parameter.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2dHatch.Geom2dHatch_FClass2dOfClassifier_Parameter(self, *args)


    def Intersector(self, *args):
        """
        Intersector(Geom2dHatch_FClass2dOfClassifier self) -> Geom2dHatch_Intersector

        Returns the intersecting algorithm.

        :rtype: OCC.wrapper.Geom2dHatch.Geom2dHatch_Intersector

        """
        return _Geom2dHatch.Geom2dHatch_FClass2dOfClassifier_Intersector(self, *args)


    def ClosestIntersection(self, *args):
        """
        ClosestIntersection(Geom2dHatch_FClass2dOfClassifier self) -> Standard_Integer

        Returns  0  if  the   last  compared   edge had no
        relevant intersection.  Else returns  the index of
        this   intersection  in the    last   intersection
        algorithm.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom2dHatch.Geom2dHatch_FClass2dOfClassifier_ClosestIntersection(self, *args)


    def State(self, *args):
        """
        State(Geom2dHatch_FClass2dOfClassifier self) -> TopAbs_State

        Returns the current state of the point.

        :rtype: OCC.wrapper.TopAbs.TopAbs_State

        """
        return _Geom2dHatch.Geom2dHatch_FClass2dOfClassifier_State(self, *args)


    def IsHeadOrEnd(self, *args):
        """
        IsHeadOrEnd(Geom2dHatch_FClass2dOfClassifier self) -> Standard_Boolean

        Returns the Standard_True if the closest intersection point
        represents head or end of the edge. Returns Standard_False
        otherwise.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom2dHatch.Geom2dHatch_FClass2dOfClassifier_IsHeadOrEnd(self, *args)

    __swig_destroy__ = _Geom2dHatch.delete_Geom2dHatch_FClass2dOfClassifier
Geom2dHatch_FClass2dOfClassifier_swigregister = _Geom2dHatch.Geom2dHatch_FClass2dOfClassifier_swigregister
Geom2dHatch_FClass2dOfClassifier_swigregister(Geom2dHatch_FClass2dOfClassifier)

class Geom2dHatch_Elements(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Geom2dHatch_Elements self) -> Geom2dHatch_Elements
        __init__(Geom2dHatch_Elements self, Geom2dHatch_Elements Other) -> Geom2dHatch_Elements

        :type Other: OCC.wrapper.Geom2dHatch.Geom2dHatch_Elements

        """
        this = _Geom2dHatch.new_Geom2dHatch_Elements(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Clear(self, *args):
        """Clear(Geom2dHatch_Elements self)"""
        return _Geom2dHatch.Geom2dHatch_Elements_Clear(self, *args)


    def Bind(self, *args):
        """
        Bind(Geom2dHatch_Elements self, Standard_Integer const K, Geom2dHatch_Element I) -> Standard_Boolean

        :type K: int
        :type I: OCC.wrapper.Geom2dHatch.Geom2dHatch_Element
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom2dHatch.Geom2dHatch_Elements_Bind(self, *args)


    def IsBound(self, *args):
        """
        IsBound(Geom2dHatch_Elements self, Standard_Integer const K) -> Standard_Boolean

        :type K: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom2dHatch.Geom2dHatch_Elements_IsBound(self, *args)


    def UnBind(self, *args):
        """
        UnBind(Geom2dHatch_Elements self, Standard_Integer const K) -> Standard_Boolean

        :type K: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom2dHatch.Geom2dHatch_Elements_UnBind(self, *args)


    def Find(self, *args):
        """
        :type K: int
        :rtype: OCC.wrapper.Geom2dHatch.Geom2dHatch_Element

        """
        res = _Geom2dHatch.Geom2dHatch_Elements_Find(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFind(self, *args):
        """
        ChangeFind(Geom2dHatch_Elements self, Standard_Integer const K) -> Geom2dHatch_Element

        :type K: int
        :rtype: OCC.wrapper.Geom2dHatch.Geom2dHatch_Element

        """
        return _Geom2dHatch.Geom2dHatch_Elements_ChangeFind(self, *args)


    def __call__(self, *args):
        """
        :type K: int
        :rtype: OCC.wrapper.Geom2dHatch.Geom2dHatch_Element

        """
        res = _Geom2dHatch.Geom2dHatch_Elements___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def CheckPoint(self, *args):
        """
        CheckPoint(Geom2dHatch_Elements self, gp_Pnt2d P) -> Standard_Boolean

        :type P: OCC.wrapper.gp.gp_Pnt2d
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom2dHatch.Geom2dHatch_Elements_CheckPoint(self, *args)


    def Reject(self, *args):
        """
        Reject(Geom2dHatch_Elements self, gp_Pnt2d P) -> Standard_Boolean

        :type P: OCC.wrapper.gp.gp_Pnt2d
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom2dHatch.Geom2dHatch_Elements_Reject(self, *args)


    def Segment(self, *args):
        """
        Segment(Geom2dHatch_Elements self, gp_Pnt2d P, gp_Lin2d L) -> Standard_Boolean

        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type L: OCC.wrapper.gp.gp_Lin2d
        :type Par: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom2dHatch.Geom2dHatch_Elements_Segment(self, *args)


    def OtherSegment(self, *args):
        """
        OtherSegment(Geom2dHatch_Elements self, gp_Pnt2d P, gp_Lin2d L) -> Standard_Boolean

        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type L: OCC.wrapper.gp.gp_Lin2d
        :type Par: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom2dHatch.Geom2dHatch_Elements_OtherSegment(self, *args)


    def InitWires(self, *args):
        """InitWires(Geom2dHatch_Elements self)"""
        return _Geom2dHatch.Geom2dHatch_Elements_InitWires(self, *args)


    def MoreWires(self, *args):
        """
        MoreWires(Geom2dHatch_Elements self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom2dHatch.Geom2dHatch_Elements_MoreWires(self, *args)


    def NextWire(self, *args):
        """NextWire(Geom2dHatch_Elements self)"""
        return _Geom2dHatch.Geom2dHatch_Elements_NextWire(self, *args)


    def RejectWire(self, *args):
        """
        RejectWire(Geom2dHatch_Elements self, gp_Lin2d L, Standard_Real const Par) -> Standard_Boolean

        :type L: OCC.wrapper.gp.gp_Lin2d
        :type Par: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom2dHatch.Geom2dHatch_Elements_RejectWire(self, *args)


    def InitEdges(self, *args):
        """InitEdges(Geom2dHatch_Elements self)"""
        return _Geom2dHatch.Geom2dHatch_Elements_InitEdges(self, *args)


    def MoreEdges(self, *args):
        """
        MoreEdges(Geom2dHatch_Elements self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom2dHatch.Geom2dHatch_Elements_MoreEdges(self, *args)


    def NextEdge(self, *args):
        """NextEdge(Geom2dHatch_Elements self)"""
        return _Geom2dHatch.Geom2dHatch_Elements_NextEdge(self, *args)


    def RejectEdge(self, *args):
        """
        RejectEdge(Geom2dHatch_Elements self, gp_Lin2d L, Standard_Real const Par) -> Standard_Boolean

        :type L: OCC.wrapper.gp.gp_Lin2d
        :type Par: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom2dHatch.Geom2dHatch_Elements_RejectEdge(self, *args)


    def CurrentEdge(self, *args):
        """
        CurrentEdge(Geom2dHatch_Elements self, Geom2dAdaptor_Curve E)

        :type E: OCC.wrapper.Geom2dAdaptor.Geom2dAdaptor_Curve
        :type Or: OCC.wrapper.TopAbs.TopAbs_Orientation

        """
        return _Geom2dHatch.Geom2dHatch_Elements_CurrentEdge(self, *args)

    __swig_destroy__ = _Geom2dHatch.delete_Geom2dHatch_Elements
Geom2dHatch_Elements_swigregister = _Geom2dHatch.Geom2dHatch_Elements_swigregister
Geom2dHatch_Elements_swigregister(Geom2dHatch_Elements)

class Geom2dHatch_Hatcher(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Geom2dHatch_Hatcher self, Geom2dHatch_Intersector Intersector, Standard_Real const Confusion2d, Standard_Real const Confusion3d, Standard_Boolean const KeepPnt, Standard_Boolean const KeepSeg) -> Geom2dHatch_Hatcher

        Returns an empty hatcher.

        :type Intersector: OCC.wrapper.Geom2dHatch.Geom2dHatch_Intersector
        :type Confusion2d: float
        :type Confusion3d: float
        :type KeepPnt: bool
        :type KeepSeg: bool

        """
        this = _Geom2dHatch.new_Geom2dHatch_Hatcher(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Intersector(self, *args):
        """
        Returns the associated intersector.

        :rtype: OCC.wrapper.Geom2dHatch.Geom2dHatch_Intersector

        """
        res = _Geom2dHatch.Geom2dHatch_Hatcher_Intersector(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeIntersector(self, *args):
        """
        ChangeIntersector(Geom2dHatch_Hatcher self) -> Geom2dHatch_Intersector

        Returns the associated intersector.

        :rtype: OCC.wrapper.Geom2dHatch.Geom2dHatch_Intersector

        """
        return _Geom2dHatch.Geom2dHatch_Hatcher_ChangeIntersector(self, *args)


    def Confusion2d(self, *args):
        """
        Confusion2d(Geom2dHatch_Hatcher self, Standard_Real const Confusion)
        Confusion2d(Geom2dHatch_Hatcher self) -> Standard_Real

        Returns the 2d confusion tolerance, i.e. the value under
        which two points are considered identical in the
        parametric space of the hatching.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2dHatch.Geom2dHatch_Hatcher_Confusion2d(self, *args)


    def Confusion3d(self, *args):
        """
        Confusion3d(Geom2dHatch_Hatcher self, Standard_Real const Confusion)
        Confusion3d(Geom2dHatch_Hatcher self) -> Standard_Real

        Returns the 3d confusion tolerance, i.e. the value under
        which two points are considered identical in the
        3d space of the hatching.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2dHatch.Geom2dHatch_Hatcher_Confusion3d(self, *args)


    def KeepPoints(self, *args):
        """
        KeepPoints(Geom2dHatch_Hatcher self, Standard_Boolean const Keep)
        KeepPoints(Geom2dHatch_Hatcher self) -> Standard_Boolean

        Returns the flag about the points consideration.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom2dHatch.Geom2dHatch_Hatcher_KeepPoints(self, *args)


    def KeepSegments(self, *args):
        """
        KeepSegments(Geom2dHatch_Hatcher self, Standard_Boolean const Keep)
        KeepSegments(Geom2dHatch_Hatcher self) -> Standard_Boolean

        Returns the flag about the segments consideration.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom2dHatch.Geom2dHatch_Hatcher_KeepSegments(self, *args)


    def Clear(self, *args):
        """
        Clear(Geom2dHatch_Hatcher self)

        Removes all the hatchings and all the elements.


        """
        return _Geom2dHatch.Geom2dHatch_Hatcher_Clear(self, *args)


    def ElementCurve(self, *args):
        """
        Returns the curve associated to the IndE-th element.

        :type IndE: int
        :rtype: OCC.wrapper.Geom2dAdaptor.Geom2dAdaptor_Curve

        """
        res = _Geom2dHatch.Geom2dHatch_Hatcher_ElementCurve(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def AddElement(self, *args):
        """
        AddElement(Geom2dHatch_Hatcher self, Geom2dAdaptor_Curve Curve, TopAbs_Orientation const Orientation=TopAbs_FORWARD) -> Standard_Integer
        AddElement(Geom2dHatch_Hatcher self, Handle_Geom2d_Curve Curve, TopAbs_Orientation const Orientation=TopAbs_FORWARD) -> Standard_Integer

        Adds an element to the hatcher and returns its index.

        :type Curve: OCC.wrapper.Geom2d.Handle_Geom2d_Curve
        :type Orientation: OCC.wrapper.TopAbs.TopAbs_Orientation
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom2dHatch.Geom2dHatch_Hatcher_AddElement(self, *args)


    def RemElement(self, *args):
        """
        RemElement(Geom2dHatch_Hatcher self, Standard_Integer const IndE)

        Removes the IndE-th element from the hatcher.

        :type IndE: int

        """
        return _Geom2dHatch.Geom2dHatch_Hatcher_RemElement(self, *args)


    def ClrElements(self, *args):
        """
        ClrElements(Geom2dHatch_Hatcher self)

        Removes all the elements from the hatcher.


        """
        return _Geom2dHatch.Geom2dHatch_Hatcher_ClrElements(self, *args)


    def HatchingCurve(self, *args):
        """
        Returns the curve associated to the IndH-th hatching.

        :type IndH: int
        :rtype: OCC.wrapper.Geom2dAdaptor.Geom2dAdaptor_Curve

        """
        res = _Geom2dHatch.Geom2dHatch_Hatcher_HatchingCurve(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def AddHatching(self, *args):
        """
        AddHatching(Geom2dHatch_Hatcher self, Geom2dAdaptor_Curve Curve) -> Standard_Integer

        Adds a hatching to the hatcher and returns its index.

        :type Curve: OCC.wrapper.Geom2dAdaptor.Geom2dAdaptor_Curve
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom2dHatch.Geom2dHatch_Hatcher_AddHatching(self, *args)


    def RemHatching(self, *args):
        """
        RemHatching(Geom2dHatch_Hatcher self, Standard_Integer const IndH)

        Removes the IndH-th hatching from the hatcher.

        :type IndH: int

        """
        return _Geom2dHatch.Geom2dHatch_Hatcher_RemHatching(self, *args)


    def ClrHatchings(self, *args):
        """
        ClrHatchings(Geom2dHatch_Hatcher self)

        Removes all the hatchings from the hatcher.


        """
        return _Geom2dHatch.Geom2dHatch_Hatcher_ClrHatchings(self, *args)


    def NbPoints(self, *args):
        """
        NbPoints(Geom2dHatch_Hatcher self, Standard_Integer const IndH) -> Standard_Integer

        Returns the number of intersection points of
        the IndH-th hatching.

        :type IndH: int
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom2dHatch.Geom2dHatch_Hatcher_NbPoints(self, *args)


    def Point(self, *args):
        """
        Returns the IndP-th intersection point of the
        IndH-th hatching.

        :type IndH: int
        :type IndP: int
        :rtype: OCC.wrapper.HatchGen.HatchGen_PointOnHatching

        """
        res = _Geom2dHatch.Geom2dHatch_Hatcher_Point(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Trim(self, *args):
        """
        Trim(Geom2dHatch_Hatcher self)
        Trim(Geom2dHatch_Hatcher self, Geom2dAdaptor_Curve Curve) -> Standard_Integer
        Trim(Geom2dHatch_Hatcher self, Standard_Integer const IndH)

        Trims the IndH-th hatching by the elements
        already given.

        :type IndH: int

        """
        return _Geom2dHatch.Geom2dHatch_Hatcher_Trim(self, *args)


    def ComputeDomains(self, *args):
        """
        ComputeDomains(Geom2dHatch_Hatcher self)
        ComputeDomains(Geom2dHatch_Hatcher self, Standard_Integer const IndH)

        Computes the domains of the IndH-th hatching.

        :type IndH: int

        """
        return _Geom2dHatch.Geom2dHatch_Hatcher_ComputeDomains(self, *args)


    def TrimDone(self, *args):
        """
        TrimDone(Geom2dHatch_Hatcher self, Standard_Integer const IndH) -> Standard_Boolean

        Returns the fact that the intersections were computed
        for the IndH-th hatching.

        :type IndH: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom2dHatch.Geom2dHatch_Hatcher_TrimDone(self, *args)


    def TrimFailed(self, *args):
        """
        TrimFailed(Geom2dHatch_Hatcher self, Standard_Integer const IndH) -> Standard_Boolean

        Returns the fact that the intersections failed
        for the IndH-th hatching.

        :type IndH: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom2dHatch.Geom2dHatch_Hatcher_TrimFailed(self, *args)


    def IsDone(self, *args):
        """
        IsDone(Geom2dHatch_Hatcher self, Standard_Integer const IndH) -> Standard_Boolean

        Returns the fact that the domains were computed
        for the IndH-th hatching.

        :type IndH: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom2dHatch.Geom2dHatch_Hatcher_IsDone(self, *args)


    def Status(self, *args):
        """
        Status(Geom2dHatch_Hatcher self, Standard_Integer const IndH) -> HatchGen_ErrorStatus

        Returns the status about the IndH-th hatching.

        :type IndH: int
        :rtype: OCC.wrapper.HatchGen.HatchGen_ErrorStatus

        """
        return _Geom2dHatch.Geom2dHatch_Hatcher_Status(self, *args)


    def NbDomains(self, *args):
        """
        NbDomains(Geom2dHatch_Hatcher self, Standard_Integer const IndH) -> Standard_Integer

        Returns the number of domains of the IndH-th hatching.
        Only ONE "INFINITE" domain means that the hatching is
        fully included in the contour defined by the elements.

        :type IndH: int
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom2dHatch.Geom2dHatch_Hatcher_NbDomains(self, *args)


    def Domain(self, *args):
        """
        Returns the IDom-th domain of the IndH-th hatching.

        :type IndH: int
        :type IDom: int
        :rtype: OCC.wrapper.HatchGen.HatchGen_Domain

        """
        res = _Geom2dHatch.Geom2dHatch_Hatcher_Domain(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Dump(self, *args):
        """
        Dump(Geom2dHatch_Hatcher self)

        Dump the hatcher.


        """
        return _Geom2dHatch.Geom2dHatch_Hatcher_Dump(self, *args)

    __swig_destroy__ = _Geom2dHatch.delete_Geom2dHatch_Hatcher
Geom2dHatch_Hatcher_swigregister = _Geom2dHatch.Geom2dHatch_Hatcher_swigregister
Geom2dHatch_Hatcher_swigregister(Geom2dHatch_Hatcher)


try:
	TColStd_MapIntegerHasher = TColStd.NCollection_DefaultHasher_Standard_Integer
except AttributeError:
	pass # does not exist, probably ignored




# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_BRepFill')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_BRepFill')
    _BRepFill = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_BRepFill', [dirname(__file__)])
        except ImportError:
            import _BRepFill
            return _BRepFill
        try:
            _mod = imp.load_module('_BRepFill', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _BRepFill = swig_import_helper()
    del swig_import_helper
else:
    import _BRepFill
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


class SwigPyIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _BRepFill.delete_SwigPyIterator

    def value(self):
        return _BRepFill.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _BRepFill.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _BRepFill.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _BRepFill.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _BRepFill.SwigPyIterator_equal(self, x)

    def copy(self):
        return _BRepFill.SwigPyIterator_copy(self)

    def next(self):
        return _BRepFill.SwigPyIterator_next(self)

    def __next__(self):
        return _BRepFill.SwigPyIterator___next__(self)

    def previous(self):
        return _BRepFill.SwigPyIterator_previous(self)

    def advance(self, n):
        return _BRepFill.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _BRepFill.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _BRepFill.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _BRepFill.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _BRepFill.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _BRepFill.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _BRepFill.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self
SwigPyIterator_swigregister = _BRepFill.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

class NCollection_CellFilter_InspectorXYZ(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _BRepFill.NCollection_CellFilter_InspectorXYZ_Dimension
    Coord = staticmethod(_BRepFill.NCollection_CellFilter_InspectorXYZ_Coord)

    def Shift(self, thePnt, theTol):
        return _BRepFill.NCollection_CellFilter_InspectorXYZ_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _BRepFill.new_NCollection_CellFilter_InspectorXYZ()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _BRepFill.delete_NCollection_CellFilter_InspectorXYZ
NCollection_CellFilter_InspectorXYZ_swigregister = _BRepFill.NCollection_CellFilter_InspectorXYZ_swigregister
NCollection_CellFilter_InspectorXYZ_swigregister(NCollection_CellFilter_InspectorXYZ)

def NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt):
    return _BRepFill.NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt)
NCollection_CellFilter_InspectorXYZ_Coord = _BRepFill.NCollection_CellFilter_InspectorXYZ_Coord

class NCollection_CellFilter_InspectorXY(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _BRepFill.NCollection_CellFilter_InspectorXY_Dimension
    Coord = staticmethod(_BRepFill.NCollection_CellFilter_InspectorXY_Coord)

    def Shift(self, thePnt, theTol):
        return _BRepFill.NCollection_CellFilter_InspectorXY_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _BRepFill.new_NCollection_CellFilter_InspectorXY()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _BRepFill.delete_NCollection_CellFilter_InspectorXY
NCollection_CellFilter_InspectorXY_swigregister = _BRepFill.NCollection_CellFilter_InspectorXY_swigregister
NCollection_CellFilter_InspectorXY_swigregister(NCollection_CellFilter_InspectorXY)

def NCollection_CellFilter_InspectorXY_Coord(i, thePnt):
    return _BRepFill.NCollection_CellFilter_InspectorXY_Coord(i, thePnt)
NCollection_CellFilter_InspectorXY_Coord = _BRepFill.NCollection_CellFilter_InspectorXY_Coord


def ptr_to_number(item):
    return _BRepFill.ptr_to_number(item)
ptr_to_number = _BRepFill.ptr_to_number

def HashCode(*args):
    return _BRepFill.HashCode(*args)
HashCode = _BRepFill.HashCode

def ptr_equal(a, b):
    return _BRepFill.ptr_equal(a, b)
ptr_equal = _BRepFill.ptr_equal
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import GeomFill
else:
    import GeomFill
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Convert
else:
    import Convert
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import NCollection
else:
    import NCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Standard
else:
    import Standard
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import gp
else:
    import gp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColStd
else:
    import TColStd
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TCollection
else:
    import TCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColgp
else:
    import TColgp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Geom2d
else:
    import Geom2d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import GeomAbs
else:
    import GeomAbs
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Geom
else:
    import Geom
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Approx
else:
    import Approx
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import AppCont
else:
    import AppCont
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import AppParCurves
else:
    import AppParCurves
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import math
else:
    import math
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import AdvApprox
else:
    import AdvApprox
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import PLib
else:
    import PLib
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Adaptor2d
else:
    import Adaptor2d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Adaptor3d
else:
    import Adaptor3d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopAbs
else:
    import TopAbs
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import AppBlend
else:
    import AppBlend
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColGeom
else:
    import TColGeom
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Law
else:
    import Law
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import BRepMAT2d
else:
    import BRepMAT2d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColGeom2d
else:
    import TColGeom2d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import MAT
else:
    import MAT
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Bisector
else:
    import Bisector
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import GccInt
else:
    import GccInt
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import IntRes2d
else:
    import IntRes2d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopoDS
else:
    import TopoDS
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Message
else:
    import Message
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopLoc
else:
    import TopLoc
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopTools
else:
    import TopTools
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Bnd
else:
    import Bnd
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import GeomPlate
else:
    import GeomPlate
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Plate
else:
    import Plate
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import GeomLProp
else:
    import GeomLProp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import AdvApp2Var
else:
    import AdvApp2Var
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import BRepTools
else:
    import BRepTools
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Poly
else:
    import Poly
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TShort
else:
    import TShort
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import BRep
else:
    import BRep
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import BOPDS
else:
    import BOPDS
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import IntTools
else:
    import IntTools
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import GeomAPI
else:
    import GeomAPI
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Extrema
else:
    import Extrema
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import GeomAdaptor
else:
    import GeomAdaptor
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Geom2dHatch
else:
    import Geom2dHatch
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import HatchGen
else:
    import HatchGen
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Geom2dAdaptor
else:
    import Geom2dAdaptor
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Geom2dInt
else:
    import Geom2dInt
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Intf
else:
    import Intf
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import IntCurve
else:
    import IntCurve
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import IntPatch
else:
    import IntPatch
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import IntSurf
else:
    import IntSurf
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import IntAna
else:
    import IntAna
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import IntWalk
else:
    import IntWalk
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import IntImp
else:
    import IntImp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import BRepClass3d
else:
    import BRepClass3d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import IntCurveSurface
else:
    import IntCurveSurface
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import IntCurvesFace
else:
    import IntCurvesFace
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import BRepAdaptor
else:
    import BRepAdaptor
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import GeomInt
else:
    import GeomInt
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import ApproxInt
else:
    import ApproxInt
del _swig_python_version_info
BRepFill_Modified = _BRepFill.BRepFill_Modified
BRepFill_Right = _BRepFill.BRepFill_Right
BRepFill_Round = _BRepFill.BRepFill_Round
BRepFill_NoContact = _BRepFill.BRepFill_NoContact
BRepFill_Contact = _BRepFill.BRepFill_Contact
BRepFill_ContactOnBorder = _BRepFill.BRepFill_ContactOnBorder
class BRepFill_LocationLaw(Standard.Standard_Transient):
    """Location Law on a  Wire."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_BRepFill_LocationLaw
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_BRepFill_LocationLaw(self) 
            return h


    def GetStatus(self, *args):
        """
        GetStatus(BRepFill_LocationLaw self) -> GeomFill_PipeError

        Return a error status, if the  status is not PipeOk then
        it exist a parameter tlike the law is not valuable for t.

        :rtype: OCC.wrapper.GeomFill.GeomFill_PipeError

        """
        return _BRepFill.BRepFill_LocationLaw_GetStatus(self, *args)


    def TransformInG0Law(self, *args):
        """
        TransformInG0Law(BRepFill_LocationLaw self)

        Apply a linear   transformation  on each law, to  have
        continuity of the global law beetween the edges.


        """
        return _BRepFill.BRepFill_LocationLaw_TransformInG0Law(self, *args)


    def TransformInCompatibleLaw(self, *args):
        """
        TransformInCompatibleLaw(BRepFill_LocationLaw self, Standard_Real const AngularTolerance)

        Apply a linear transformation on each law, to reduce
        the   dicontinuities  of law at one  rotation.

        :type AngularTolerance: float

        """
        return _BRepFill.BRepFill_LocationLaw_TransformInCompatibleLaw(self, *args)


    def DeleteTransform(self, *args):
        """DeleteTransform(BRepFill_LocationLaw self)"""
        return _BRepFill.BRepFill_LocationLaw_DeleteTransform(self, *args)


    def NbHoles(self, *args):
        """
        NbHoles(BRepFill_LocationLaw self, Standard_Real const Tol=1.0e-7) -> Standard_Integer

        :type Tol: float
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepFill.BRepFill_LocationLaw_NbHoles(self, *args)


    def Holes(self, *args):
        """
        Holes(BRepFill_LocationLaw self, NCollection_Array1_Standard_Integer Interval)

        :type Interval: OCC.wrapper.TColStd.TColStd_Array1OfInteger

        """
        return _BRepFill.BRepFill_LocationLaw_Holes(self, *args)


    def NbLaw(self, *args):
        """
        NbLaw(BRepFill_LocationLaw self) -> Standard_Integer

        Return the number of elementary Law

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepFill.BRepFill_LocationLaw_NbLaw(self, *args)


    def Law(self, *args):
        """
        Return the elementary Law of rank <Index>
        <Index> have to be in [1, NbLaw()]

        :type Index: int
        :rtype: OCC.wrapper.GeomFill.Handle_GeomFill_LocationLaw

        """
        res = _BRepFill.BRepFill_LocationLaw_Law_(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Wire(self, *args):
        """
        return the path

        :rtype: OCC.wrapper.TopoDS.TopoDS_Wire

        """
        res = _BRepFill.BRepFill_LocationLaw_Wire(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Edge(self, *args):
        """
        Return the Edge of rank <Index> in the path
        <Index> have to be in [1, NbLaw()]

        :type Index: int
        :rtype: OCC.wrapper.TopoDS.TopoDS_Edge

        """
        res = _BRepFill.BRepFill_LocationLaw_Edge(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Vertex(self, *args):
        """
        Vertex(BRepFill_LocationLaw self, Standard_Integer const Index) -> TopoDS_Vertex

        Return the vertex of rank <Index> in the path
        <Index> have to be in [0, NbLaw()]

        :type Index: int
        :rtype: OCC.wrapper.TopoDS.TopoDS_Vertex

        """
        return _BRepFill.BRepFill_LocationLaw_Vertex(self, *args)


    def PerformVertex(self, *args):
        """
        PerformVertex(BRepFill_LocationLaw self, Standard_Integer const Index, TopoDS_Vertex InputVertex, Standard_Real const TolMin, TopoDS_Vertex OutputVertex, Standard_Integer const Location=0)

        Compute <OutputVertex> like a transformation of
        <InputVertex>  the  transformation   is given by
        evaluation of the location law   in the vertex of
        rank   <Index>.
        <Location> is used to manage discontinuities :
        - -1 : The law before the vertex is used.
        -  1 : The law after the vertex is used.
        -  0 : Average of the both laws is used.

        :type Index: int
        :type InputVertex: OCC.wrapper.TopoDS.TopoDS_Vertex
        :type TolMin: float
        :type OutputVertex: OCC.wrapper.TopoDS.TopoDS_Vertex
        :type Location: int

        """
        return _BRepFill.BRepFill_LocationLaw_PerformVertex(self, *args)


    def CurvilinearBounds(self, *args):
        """
        CurvilinearBounds(BRepFill_LocationLaw self, Standard_Integer const Index)

        Return the Curvilinear Bounds of the <Index> Law

        :type Index: int
        :type First: float
        :type Last: float

        """
        return _BRepFill.BRepFill_LocationLaw_CurvilinearBounds(self, *args)


    def IsClosed(self, *args):
        """
        IsClosed(BRepFill_LocationLaw self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepFill.BRepFill_LocationLaw_IsClosed(self, *args)


    def IsG1(self, *args):
        """
        IsG1(BRepFill_LocationLaw self, Standard_Integer const Index, Standard_Real const SpatialTolerance=1.0e-7, Standard_Real const AngularTolerance=1.0e-4) -> Standard_Integer

        Compute the Law's continuity beetween 2 edges of the path
        The result can be :
        -1 : Case Not connex
        0  : It is connex (G0)
        1  : It is tangent (G1)

        :type Index: int
        :type SpatialTolerance: float
        :type AngularTolerance: float
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepFill.BRepFill_LocationLaw_IsG1(self, *args)


    def D0(self, *args):
        """
        D0(BRepFill_LocationLaw self, Standard_Real const Abscissa, TopoDS_Shape Section)

        Apply the Law to a shape, for a given Curnilinear abscissa

        :type Abscissa: float
        :type Section: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _BRepFill.BRepFill_LocationLaw_D0(self, *args)


    def Parameter(self, *args):
        """
        Parameter(BRepFill_LocationLaw self, Standard_Real const Abscissa)

        Find the  index Law  and the  parmaeter, for  a given
        Curnilinear abscissa

        :type Abscissa: float
        :type Index: int
        :type Param: float

        """
        return _BRepFill.BRepFill_LocationLaw_Parameter(self, *args)


    def Abscissa(self, *args):
        """
        Abscissa(BRepFill_LocationLaw self, Standard_Integer const Index, Standard_Real const Param) -> Standard_Real

        Return the curvilinear abscissa  corresponding to a point
        of  the path, defined by  <Index>  of  Edge and a
        parameter on the edge.

        :type Index: int
        :type Param: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _BRepFill.BRepFill_LocationLaw_Abscissa(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _BRepFill.BRepFill_LocationLaw_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _BRepFill.BRepFill_LocationLaw_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _BRepFill.BRepFill_LocationLaw_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __init__(self):
        """Location Law on a  Wire."""
        this = _BRepFill.new_BRepFill_LocationLaw()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle



    __swig_destroy__ = _BRepFill.delete_BRepFill_LocationLaw
BRepFill_LocationLaw_swigregister = _BRepFill.BRepFill_LocationLaw_swigregister
BRepFill_LocationLaw_swigregister(BRepFill_LocationLaw)

def BRepFill_LocationLaw_get_type_name(*args):
    """
    BRepFill_LocationLaw_get_type_name() -> char const *

    :rtype: const char *

    """
    return _BRepFill.BRepFill_LocationLaw_get_type_name(*args)

def BRepFill_LocationLaw_get_type_descriptor(*args):
    """
    BRepFill_LocationLaw_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _BRepFill.BRepFill_LocationLaw_get_type_descriptor(*args)

class BRepFill_Edge3DLaw(BRepFill_LocationLaw):
    """Build Location Law, with a  Wire."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_BRepFill_Edge3DLaw
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_BRepFill_Edge3DLaw(self) 
            return h


    def __init__(self, *args):
        """
        __init__(BRepFill_Edge3DLaw self, TopoDS_Wire Path, Handle_GeomFill_LocationLaw Law) -> BRepFill_Edge3DLaw

        :type Path: OCC.wrapper.TopoDS.TopoDS_Wire
        :type Law: OCC.wrapper.GeomFill.Handle_GeomFill_LocationLaw

        """
        this = _BRepFill.new_BRepFill_Edge3DLaw(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _BRepFill.BRepFill_Edge3DLaw_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _BRepFill.BRepFill_Edge3DLaw_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _BRepFill.BRepFill_Edge3DLaw_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _BRepFill.delete_BRepFill_Edge3DLaw
BRepFill_Edge3DLaw_swigregister = _BRepFill.BRepFill_Edge3DLaw_swigregister
BRepFill_Edge3DLaw_swigregister(BRepFill_Edge3DLaw)

def BRepFill_Edge3DLaw_get_type_name(*args):
    """
    BRepFill_Edge3DLaw_get_type_name() -> char const *

    :rtype: const char *

    """
    return _BRepFill.BRepFill_Edge3DLaw_get_type_name(*args)

def BRepFill_Edge3DLaw_get_type_descriptor(*args):
    """
    BRepFill_Edge3DLaw_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _BRepFill.BRepFill_Edge3DLaw_get_type_descriptor(*args)

class BRepFill_SectionLaw(Standard.Standard_Transient):
    """Build Section Law, with an Vertex, or an Wire"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_BRepFill_SectionLaw
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_BRepFill_SectionLaw(self) 
            return h


    def NbLaw(self, *args):
        """
        NbLaw(BRepFill_SectionLaw self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepFill.BRepFill_SectionLaw_NbLaw(self, *args)


    def Law(self, *args):
        """
        :type Index: int
        :rtype: OCC.wrapper.GeomFill.Handle_GeomFill_SectionLaw

        """
        res = _BRepFill.BRepFill_SectionLaw_Law_(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def IndexOfEdge(self, *args):
        """
        IndexOfEdge(BRepFill_SectionLaw self, TopoDS_Shape anEdge) -> Standard_Integer

        :type anEdge: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepFill.BRepFill_SectionLaw_IndexOfEdge(self, *args)


    def IsConstant(self, *args):
        """
        IsConstant(BRepFill_SectionLaw self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepFill.BRepFill_SectionLaw_IsConstant(self, *args)


    def IsUClosed(self, *args):
        """
        IsUClosed(BRepFill_SectionLaw self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepFill.BRepFill_SectionLaw_IsUClosed(self, *args)


    def IsVClosed(self, *args):
        """
        IsVClosed(BRepFill_SectionLaw self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepFill.BRepFill_SectionLaw_IsVClosed(self, *args)


    def IsDone(self, *args):
        """
        IsDone(BRepFill_SectionLaw self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepFill.BRepFill_SectionLaw_IsDone(self, *args)


    def IsVertex(self, *args):
        """
        IsVertex(BRepFill_SectionLaw self) -> Standard_Boolean

        Say if the input shape is a  vertex.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepFill.BRepFill_SectionLaw_IsVertex(self, *args)


    def ConcatenedLaw(self, *args):
        """
        ConcatenedLaw(BRepFill_SectionLaw self) -> Handle_GeomFill_SectionLaw

        :rtype: OCC.wrapper.GeomFill.Handle_GeomFill_SectionLaw

        """
        return _BRepFill.BRepFill_SectionLaw_ConcatenedLaw(self, *args)


    def Continuity(self, *args):
        """
        Continuity(BRepFill_SectionLaw self, Standard_Integer const Index, Standard_Real const TolAngular) -> GeomAbs_Shape

        :type Index: int
        :type TolAngular: float
        :rtype: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _BRepFill.BRepFill_SectionLaw_Continuity(self, *args)


    def VertexTol(self, *args):
        """
        VertexTol(BRepFill_SectionLaw self, Standard_Integer const Index, Standard_Real const Param) -> Standard_Real

        :type Index: int
        :type Param: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _BRepFill.BRepFill_SectionLaw_VertexTol(self, *args)


    def Vertex(self, *args):
        """
        Vertex(BRepFill_SectionLaw self, Standard_Integer const Index, Standard_Real const Param) -> TopoDS_Vertex

        :type Index: int
        :type Param: float
        :rtype: OCC.wrapper.TopoDS.TopoDS_Vertex

        """
        return _BRepFill.BRepFill_SectionLaw_Vertex(self, *args)


    def D0(self, *args):
        """
        D0(BRepFill_SectionLaw self, Standard_Real const U, TopoDS_Shape S)

        :type U: float
        :type S: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _BRepFill.BRepFill_SectionLaw_D0(self, *args)


    def Init(self, *args):
        """
        Init(BRepFill_SectionLaw self, TopoDS_Wire W)

        :type W: OCC.wrapper.TopoDS.TopoDS_Wire

        """
        return _BRepFill.BRepFill_SectionLaw_Init(self, *args)


    def CurrentEdge(self, *args):
        """
        CurrentEdge(BRepFill_SectionLaw self) -> TopoDS_Edge

        :rtype: OCC.wrapper.TopoDS.TopoDS_Edge

        """
        return _BRepFill.BRepFill_SectionLaw_CurrentEdge(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _BRepFill.BRepFill_SectionLaw_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _BRepFill.BRepFill_SectionLaw_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _BRepFill.BRepFill_SectionLaw_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _BRepFill.delete_BRepFill_SectionLaw
BRepFill_SectionLaw_swigregister = _BRepFill.BRepFill_SectionLaw_swigregister
BRepFill_SectionLaw_swigregister(BRepFill_SectionLaw)

def BRepFill_SectionLaw_get_type_name(*args):
    """
    BRepFill_SectionLaw_get_type_name() -> char const *

    :rtype: const char *

    """
    return _BRepFill.BRepFill_SectionLaw_get_type_name(*args)

def BRepFill_SectionLaw_get_type_descriptor(*args):
    """
    BRepFill_SectionLaw_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _BRepFill.BRepFill_SectionLaw_get_type_descriptor(*args)

class BRepFill_PipeShell(Standard.Standard_Transient):
    """
    Computes a topological shell using some wires
    (spines and profiles) and diplacement option
    Perform general sweeping construction
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_BRepFill_PipeShell
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_BRepFill_PipeShell(self) 
            return h


    def __init__(self, *args):
        """
        __init__(BRepFill_PipeShell self, TopoDS_Wire Spine) -> BRepFill_PipeShell

        Set an sweep's mode
        If no mode are setted, the mode use in MakePipe is used

        :type Spine: OCC.wrapper.TopoDS.TopoDS_Wire

        """
        this = _BRepFill.new_BRepFill_PipeShell(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def SetDiscrete(self, *args):
        """
        SetDiscrete(BRepFill_PipeShell self)

        Set a Discrete trihedron
        to  perform  the  sweeping


        """
        return _BRepFill.BRepFill_PipeShell_SetDiscrete(self, *args)


    def Set(self, *args):
        """
        Set(BRepFill_PipeShell self, Standard_Boolean const Frenet)
        Set(BRepFill_PipeShell self, gp_Ax2 Axe)
        Set(BRepFill_PipeShell self, gp_Dir BiNormal)
        Set(BRepFill_PipeShell self, TopoDS_Shape SpineSupport) -> Standard_Boolean
        Set(BRepFill_PipeShell self, TopoDS_Wire AuxiliarySpine, Standard_Boolean const CurvilinearEquivalence, BRepFill_TypeOfContact const KeepContact=BRepFill_NoContact)

        Set  an  auxiliary  spine  to  define  the Normal
        For  each  Point  of  the  Spine  P,  an  Point  Q  is  evalued
        on  <AuxiliarySpine>
        If <CurvilinearEquivalence>
        Q split <AuxiliarySpine> with  the  same  length ratio
        than P split  <Spline>.
        Else  the  plan  define  by  P  and  the  tangent  to  the  <Spine>
        intersect <AuxiliarySpine> in Q.
        If <KeepContact> equals BRepFill_NoContact: The Normal is defined
        by the vector PQ.
        If <KeepContact> equals BRepFill_Contact: The Normal is defined to
        achieve that the sweeped section is in contact to the
        auxiliarySpine. The width of section is constant all along the path.
        In other words, the auxiliary spine lies on the swept surface,
        but not necessarily is a boundary of this surface. However,
        the auxiliary spine has to be close enough to the main spine
        to provide intersection with any section all along the path.
        If <KeepContact> equals BRepFill_ContactOnBorder: The auxiliary spine
        becomes a boundary of the swept surface and the width of section varies
        along the path.

        :type AuxiliarySpine: OCC.wrapper.TopoDS.TopoDS_Wire
        :type CurvilinearEquivalence: bool
        :type KeepContact: OCC.wrapper.BRepFill.BRepFill_TypeOfContact

        """
        return _BRepFill.BRepFill_PipeShell_Set(self, *args)


    def SetMaxDegree(self, *args):
        """
        SetMaxDegree(BRepFill_PipeShell self, Standard_Integer const NewMaxDegree)

        Define the maximum V degree of resulting surface

        :type NewMaxDegree: int

        """
        return _BRepFill.BRepFill_PipeShell_SetMaxDegree(self, *args)


    def SetMaxSegments(self, *args):
        """
        SetMaxSegments(BRepFill_PipeShell self, Standard_Integer const NewMaxSegments)

        Define the maximum number of spans in V-direction
        on resulting surface

        :type NewMaxSegments: int

        """
        return _BRepFill.BRepFill_PipeShell_SetMaxSegments(self, *args)


    def SetForceApproxC1(self, *args):
        """
        SetForceApproxC1(BRepFill_PipeShell self, Standard_Boolean const ForceApproxC1)

        Set the flag that indicates attempt to approximate
        a C1-continuous surface if a swept surface proved
        to be C0.
        Give section to sweep.
        Possibilities are :
        - Give one or sevral profile
        - Give one profile and an homotetic law.
        - Automatic compute of correspondance beetween profile, and section
        on the sweeped shape
        - correspondance beetween profile, and section on the sweeped shape
        defined by a vertex of the spine

        :type ForceApproxC1: bool

        """
        return _BRepFill.BRepFill_PipeShell_SetForceApproxC1(self, *args)


    def Add(self, *args):
        """
        Add(BRepFill_PipeShell self, TopoDS_Shape Profile, Standard_Boolean const WithContact, Standard_Boolean const WithCorrection)
        Add(BRepFill_PipeShell self, TopoDS_Shape Profile, TopoDS_Vertex Location, Standard_Boolean const WithContact, Standard_Boolean const WithCorrection)

        Set an section.   The corespondance with the spine, is
        given by  <Location>

        :type Profile: OCC.wrapper.TopoDS.TopoDS_Shape
        :type Location: OCC.wrapper.TopoDS.TopoDS_Vertex
        :type WithContact: bool
        :type WithCorrection: bool

        """
        return _BRepFill.BRepFill_PipeShell_Add(self, *args)


    def SetLaw(self, *args):
        """
        SetLaw(BRepFill_PipeShell self, TopoDS_Shape Profile, Handle_Law_Function L, Standard_Boolean const WithContact, Standard_Boolean const WithCorrection)
        SetLaw(BRepFill_PipeShell self, TopoDS_Shape Profile, Handle_Law_Function L, TopoDS_Vertex Location, Standard_Boolean const WithContact, Standard_Boolean const WithCorrection)

        Set  an    section  and  an   homotetic    law.
        The  homotetie  center  is  given  by  point  on  the  <Spine>

        :type Profile: OCC.wrapper.TopoDS.TopoDS_Shape
        :type L: OCC.wrapper.Law.Handle_Law_Function
        :type Location: OCC.wrapper.TopoDS.TopoDS_Vertex
        :type WithContact: bool
        :type WithCorrection: bool

        """
        return _BRepFill.BRepFill_PipeShell_SetLaw(self, *args)


    def DeleteProfile(self, *args):
        """
        DeleteProfile(BRepFill_PipeShell self, TopoDS_Shape Profile)

        Delete an section.

        :type Profile: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _BRepFill.BRepFill_PipeShell_DeleteProfile(self, *args)


    def IsReady(self, *args):
        """
        IsReady(BRepFill_PipeShell self) -> Standard_Boolean

        Say if <me> is ready to build the shape
        return False if <me> do not have section definition

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepFill.BRepFill_PipeShell_IsReady(self, *args)


    def GetStatus(self, *args):
        """
        GetStatus(BRepFill_PipeShell self) -> GeomFill_PipeError

        Get a status, when Simulate or Build failed.

        :rtype: OCC.wrapper.GeomFill.GeomFill_PipeError

        """
        return _BRepFill.BRepFill_PipeShell_GetStatus(self, *args)


    def SetTolerance(self, *args):
        """
        SetTolerance(BRepFill_PipeShell self, Standard_Real const Tol3d=1.0e-4, Standard_Real const BoundTol=1.0e-4, Standard_Real const TolAngular=1.0e-2)

        :type Tol3d: float
        :type BoundTol: float
        :type TolAngular: float

        """
        return _BRepFill.BRepFill_PipeShell_SetTolerance(self, *args)


    def SetTransition(self, *args):
        """
        SetTransition(BRepFill_PipeShell self, BRepFill_TransitionStyle const Mode=BRepFill_Modified, Standard_Real const Angmin=1.0e-2, Standard_Real const Angmax=6.0)

        Set the  Transition Mode to manage discontinuities
        on the sweep.

        :type Mode: OCC.wrapper.BRepFill.BRepFill_TransitionStyle
        :type Angmin: float
        :type Angmax: float

        """
        return _BRepFill.BRepFill_PipeShell_SetTransition(self, *args)


    def Simulate(self, *args):
        """
        Simulate(BRepFill_PipeShell self, Standard_Integer const NumberOfSection, NCollection_List_TopoDS_Shape Sections)

        Perform simulation of the sweep :
        Somes Section are returned.

        :type NumberOfSection: int
        :type Sections: OCC.wrapper.TopTools.TopTools_ListOfShape

        """
        return _BRepFill.BRepFill_PipeShell_Simulate(self, *args)


    def Build(self, *args):
        """
        Build(BRepFill_PipeShell self) -> Standard_Boolean

        Builds the resulting shape (redefined from MakeShape).

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepFill.BRepFill_PipeShell_Build(self, *args)


    def MakeSolid(self, *args):
        """
        MakeSolid(BRepFill_PipeShell self) -> Standard_Boolean

        Transform the sweeping Shell in Solid.
        If the section are not closed returns False

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepFill.BRepFill_PipeShell_MakeSolid(self, *args)


    def Shape(self, *args):
        """
        Returns the result Shape.

        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _BRepFill.BRepFill_PipeShell_Shape(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ErrorOnSurface(self, *args):
        """
        ErrorOnSurface(BRepFill_PipeShell self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _BRepFill.BRepFill_PipeShell_ErrorOnSurface(self, *args)


    def FirstShape(self, *args):
        """
        Returns the  TopoDS  Shape of the bottom of the sweep.

        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _BRepFill.BRepFill_PipeShell_FirstShape(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def LastShape(self, *args):
        """
        Returns the TopoDS Shape of the top of the sweep.

        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _BRepFill.BRepFill_PipeShell_LastShape(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Profiles(self, *args):
        """
        Profiles(BRepFill_PipeShell self, NCollection_List_TopoDS_Shape theProfiles)

        Returns the list of original profiles

        :type theProfiles: OCC.wrapper.TopTools.TopTools_ListOfShape

        """
        return _BRepFill.BRepFill_PipeShell_Profiles(self, *args)


    def Spine(self, *args):
        """
        Returns the spine

        :rtype: OCC.wrapper.TopoDS.TopoDS_Wire

        """
        res = _BRepFill.BRepFill_PipeShell_Spine(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Generated(self, *args):
        """
        Generated(BRepFill_PipeShell self, TopoDS_Shape S, NCollection_List_TopoDS_Shape L)

        Returns the  list   of shapes generated   from the
        shape <S>.

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :type L: OCC.wrapper.TopTools.TopTools_ListOfShape

        """
        return _BRepFill.BRepFill_PipeShell_Generated(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _BRepFill.BRepFill_PipeShell_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _BRepFill.BRepFill_PipeShell_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _BRepFill.BRepFill_PipeShell_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _BRepFill.delete_BRepFill_PipeShell
BRepFill_PipeShell_swigregister = _BRepFill.BRepFill_PipeShell_swigregister
BRepFill_PipeShell_swigregister(BRepFill_PipeShell)

def BRepFill_PipeShell_get_type_name(*args):
    """
    BRepFill_PipeShell_get_type_name() -> char const *

    :rtype: const char *

    """
    return _BRepFill.BRepFill_PipeShell_get_type_name(*args)

def BRepFill_PipeShell_get_type_descriptor(*args):
    """
    BRepFill_PipeShell_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _BRepFill.BRepFill_PipeShell_get_type_descriptor(*args)

class BRepFill_DraftLaw(BRepFill_Edge3DLaw):
    """Build Location Law, with a  Wire."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_BRepFill_DraftLaw
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_BRepFill_DraftLaw(self) 
            return h


    def __init__(self, *args):
        """
        __init__(BRepFill_DraftLaw self, TopoDS_Wire Path, Handle_GeomFill_LocationDraft Law) -> BRepFill_DraftLaw

        :type Path: OCC.wrapper.TopoDS.TopoDS_Wire
        :type Law: OCC.wrapper.GeomFill.Handle_GeomFill_LocationDraft

        """
        this = _BRepFill.new_BRepFill_DraftLaw(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def CleanLaw(self, *args):
        """
        CleanLaw(BRepFill_DraftLaw self, Standard_Real const TolAngular)

        To clean the little discontinuities.

        :type TolAngular: float

        """
        return _BRepFill.BRepFill_DraftLaw_CleanLaw(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _BRepFill.BRepFill_DraftLaw_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _BRepFill.BRepFill_DraftLaw_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _BRepFill.BRepFill_DraftLaw_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _BRepFill.delete_BRepFill_DraftLaw
BRepFill_DraftLaw_swigregister = _BRepFill.BRepFill_DraftLaw_swigregister
BRepFill_DraftLaw_swigregister(BRepFill_DraftLaw)

def BRepFill_DraftLaw_get_type_name(*args):
    """
    BRepFill_DraftLaw_get_type_name() -> char const *

    :rtype: const char *

    """
    return _BRepFill.BRepFill_DraftLaw_get_type_name(*args)

def BRepFill_DraftLaw_get_type_descriptor(*args):
    """
    BRepFill_DraftLaw_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _BRepFill.BRepFill_DraftLaw_get_type_descriptor(*args)

class BRepFill_NSections(BRepFill_SectionLaw):
    """Build Section Law, with N Sections"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_BRepFill_NSections
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_BRepFill_NSections(self) 
            return h


    def __init__(self, *args):
        """
        __init__(BRepFill_NSections self, NCollection_Sequence_TopoDS_Shape S, Standard_Boolean const Build) -> BRepFill_NSections
        __init__(BRepFill_NSections self, NCollection_Sequence_TopoDS_Shape S, NCollection_Sequence_gp_Trsf Trsfs, NCollection_Sequence_Standard_Real P, Standard_Real const VF, Standard_Real const VL, Standard_Boolean const Build) -> BRepFill_NSections

        Construct

        :type S: OCC.wrapper.TopTools.TopTools_SequenceOfShape
        :type Trsfs: OCC.wrapper.GeomFill.GeomFill_SequenceOfTrsf
        :type P: OCC.wrapper.TColStd.TColStd_SequenceOfReal
        :type VF: float
        :type VL: float
        :type Build: bool

        """
        this = _BRepFill.new_BRepFill_NSections(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def IsVertex(self, *args):
        """
        IsVertex(BRepFill_NSections self) -> Standard_Boolean

        Say if the input shape is a  vertex.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepFill.BRepFill_NSections_IsVertex(self, *args)


    def IsConstant(self, *args):
        """
        IsConstant(BRepFill_NSections self) -> Standard_Boolean

        Say if the Law is  Constant.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepFill.BRepFill_NSections_IsConstant(self, *args)


    def ConcatenedLaw(self, *args):
        """
        ConcatenedLaw(BRepFill_NSections self) -> Handle_GeomFill_SectionLaw

        Give the law build on a concatened section

        :rtype: OCC.wrapper.GeomFill.Handle_GeomFill_SectionLaw

        """
        return _BRepFill.BRepFill_NSections_ConcatenedLaw(self, *args)


    def Continuity(self, *args):
        """
        Continuity(BRepFill_NSections self, Standard_Integer const Index, Standard_Real const TolAngular) -> GeomAbs_Shape

        :type Index: int
        :type TolAngular: float
        :rtype: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _BRepFill.BRepFill_NSections_Continuity(self, *args)


    def VertexTol(self, *args):
        """
        VertexTol(BRepFill_NSections self, Standard_Integer const Index, Standard_Real const Param) -> Standard_Real

        :type Index: int
        :type Param: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _BRepFill.BRepFill_NSections_VertexTol(self, *args)


    def Vertex(self, *args):
        """
        Vertex(BRepFill_NSections self, Standard_Integer const Index, Standard_Real const Param) -> TopoDS_Vertex

        :type Index: int
        :type Param: float
        :rtype: OCC.wrapper.TopoDS.TopoDS_Vertex

        """
        return _BRepFill.BRepFill_NSections_Vertex(self, *args)


    def D0(self, *args):
        """
        D0(BRepFill_NSections self, Standard_Real const Param, TopoDS_Shape S)

        :type Param: float
        :type S: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _BRepFill.BRepFill_NSections_D0(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _BRepFill.BRepFill_NSections_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _BRepFill.BRepFill_NSections_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _BRepFill.BRepFill_NSections_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _BRepFill.delete_BRepFill_NSections
BRepFill_NSections_swigregister = _BRepFill.BRepFill_NSections_swigregister
BRepFill_NSections_swigregister(BRepFill_NSections)

def BRepFill_NSections_get_type_name(*args):
    """
    BRepFill_NSections_get_type_name() -> char const *

    :rtype: const char *

    """
    return _BRepFill.BRepFill_NSections_get_type_name(*args)

def BRepFill_NSections_get_type_descriptor(*args):
    """
    BRepFill_NSections_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _BRepFill.BRepFill_NSections_get_type_descriptor(*args)

class BRepFill_Section(object):
    """To store section definition"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BRepFill_Section self) -> BRepFill_Section
        __init__(BRepFill_Section self, TopoDS_Shape Profile, TopoDS_Vertex V, Standard_Boolean const WithContact, Standard_Boolean const WithCorrection) -> BRepFill_Section

        :type Profile: OCC.wrapper.TopoDS.TopoDS_Shape
        :type V: OCC.wrapper.TopoDS.TopoDS_Vertex
        :type WithContact: bool
        :type WithCorrection: bool

        """
        this = _BRepFill.new_BRepFill_Section(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Set(self, *args):
        """
        Set(BRepFill_Section self, Standard_Boolean const IsLaw)

        :type IsLaw: bool

        """
        return _BRepFill.BRepFill_Section_Set(self, *args)


    def OriginalShape(self, *args):
        """
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _BRepFill.BRepFill_Section_OriginalShape(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Wire(self, *args):
        """
        :rtype: OCC.wrapper.TopoDS.TopoDS_Wire

        """
        res = _BRepFill.BRepFill_Section_Wire(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Vertex(self, *args):
        """
        :rtype: OCC.wrapper.TopoDS.TopoDS_Vertex

        """
        res = _BRepFill.BRepFill_Section_Vertex(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ModifiedShape(self, *args):
        """
        ModifiedShape(BRepFill_Section self, TopoDS_Shape theShape) -> TopoDS_Shape

        :type theShape: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _BRepFill.BRepFill_Section_ModifiedShape(self, *args)


    def IsLaw(self, *args):
        """
        IsLaw(BRepFill_Section self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepFill.BRepFill_Section_IsLaw(self, *args)


    def IsPunctual(self, *args):
        """
        IsPunctual(BRepFill_Section self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepFill.BRepFill_Section_IsPunctual(self, *args)


    def WithContact(self, *args):
        """
        WithContact(BRepFill_Section self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepFill.BRepFill_Section_WithContact(self, *args)


    def WithCorrection(self, *args):
        """
        WithCorrection(BRepFill_Section self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepFill.BRepFill_Section_WithCorrection(self, *args)

    __swig_destroy__ = _BRepFill.delete_BRepFill_Section
BRepFill_Section_swigregister = _BRepFill.BRepFill_Section_swigregister
BRepFill_Section_swigregister(BRepFill_Section)

class BRepFill_ACRLaw(BRepFill_LocationLaw):
    """
    Build Location Law,  with a Wire.   In the case
    of guided contour and trihedron by reduced
    curvilinear abscissa
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_BRepFill_ACRLaw
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_BRepFill_ACRLaw(self) 
            return h


    def __init__(self, *args):
        """
        __init__(BRepFill_ACRLaw self, TopoDS_Wire Path, Handle_GeomFill_LocationGuide Law) -> BRepFill_ACRLaw

        :type Path: OCC.wrapper.TopoDS.TopoDS_Wire
        :type Law: OCC.wrapper.GeomFill.Handle_GeomFill_LocationGuide

        """
        this = _BRepFill.new_BRepFill_ACRLaw(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _BRepFill.BRepFill_ACRLaw_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _BRepFill.BRepFill_ACRLaw_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _BRepFill.BRepFill_ACRLaw_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _BRepFill.delete_BRepFill_ACRLaw
BRepFill_ACRLaw_swigregister = _BRepFill.BRepFill_ACRLaw_swigregister
BRepFill_ACRLaw_swigregister(BRepFill_ACRLaw)

def BRepFill_ACRLaw_get_type_name(*args):
    """
    BRepFill_ACRLaw_get_type_name() -> char const *

    :rtype: const char *

    """
    return _BRepFill.BRepFill_ACRLaw_get_type_name(*args)

def BRepFill_ACRLaw_get_type_descriptor(*args):
    """
    BRepFill_ACRLaw_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _BRepFill.BRepFill_ACRLaw_get_type_descriptor(*args)

class BRepFill_ShapeLaw(BRepFill_SectionLaw):
    """Build Section Law, with an Vertex, or an Wire"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_BRepFill_ShapeLaw
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_BRepFill_ShapeLaw(self) 
            return h


    def __init__(self, *args):
        """
        __init__(BRepFill_ShapeLaw self, TopoDS_Vertex V, Standard_Boolean const Build) -> BRepFill_ShapeLaw
        __init__(BRepFill_ShapeLaw self, TopoDS_Wire W, Standard_Boolean const Build) -> BRepFill_ShapeLaw
        __init__(BRepFill_ShapeLaw self, TopoDS_Wire W, Handle_Law_Function L, Standard_Boolean const Build) -> BRepFill_ShapeLaw

        Construct an evolutive Law

        :type W: OCC.wrapper.TopoDS.TopoDS_Wire
        :type L: OCC.wrapper.Law.Handle_Law_Function
        :type Build: bool

        """
        this = _BRepFill.new_BRepFill_ShapeLaw(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def IsVertex(self, *args):
        """
        IsVertex(BRepFill_ShapeLaw self) -> Standard_Boolean

        Say if the input shape is a  vertex.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepFill.BRepFill_ShapeLaw_IsVertex(self, *args)


    def IsConstant(self, *args):
        """
        IsConstant(BRepFill_ShapeLaw self) -> Standard_Boolean

        Say if the Law is  Constant.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepFill.BRepFill_ShapeLaw_IsConstant(self, *args)


    def ConcatenedLaw(self, *args):
        """
        ConcatenedLaw(BRepFill_ShapeLaw self) -> Handle_GeomFill_SectionLaw

        Give the law build on a concaneted section

        :rtype: OCC.wrapper.GeomFill.Handle_GeomFill_SectionLaw

        """
        return _BRepFill.BRepFill_ShapeLaw_ConcatenedLaw(self, *args)


    def Continuity(self, *args):
        """
        Continuity(BRepFill_ShapeLaw self, Standard_Integer const Index, Standard_Real const TolAngular) -> GeomAbs_Shape

        :type Index: int
        :type TolAngular: float
        :rtype: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _BRepFill.BRepFill_ShapeLaw_Continuity(self, *args)


    def VertexTol(self, *args):
        """
        VertexTol(BRepFill_ShapeLaw self, Standard_Integer const Index, Standard_Real const Param) -> Standard_Real

        :type Index: int
        :type Param: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _BRepFill.BRepFill_ShapeLaw_VertexTol(self, *args)


    def Vertex(self, *args):
        """
        Vertex(BRepFill_ShapeLaw self, Standard_Integer const Index, Standard_Real const Param) -> TopoDS_Vertex

        :type Index: int
        :type Param: float
        :rtype: OCC.wrapper.TopoDS.TopoDS_Vertex

        """
        return _BRepFill.BRepFill_ShapeLaw_Vertex(self, *args)


    def D0(self, *args):
        """
        D0(BRepFill_ShapeLaw self, Standard_Real const Param, TopoDS_Shape S)

        :type Param: float
        :type S: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _BRepFill.BRepFill_ShapeLaw_D0(self, *args)


    def Edge(self, *args):
        """
        :type Index: int
        :rtype: OCC.wrapper.TopoDS.TopoDS_Edge

        """
        res = _BRepFill.BRepFill_ShapeLaw_Edge(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _BRepFill.BRepFill_ShapeLaw_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _BRepFill.BRepFill_ShapeLaw_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _BRepFill.BRepFill_ShapeLaw_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _BRepFill.delete_BRepFill_ShapeLaw
BRepFill_ShapeLaw_swigregister = _BRepFill.BRepFill_ShapeLaw_swigregister
BRepFill_ShapeLaw_swigregister(BRepFill_ShapeLaw)

def BRepFill_ShapeLaw_get_type_name(*args):
    """
    BRepFill_ShapeLaw_get_type_name() -> char const *

    :rtype: const char *

    """
    return _BRepFill.BRepFill_ShapeLaw_get_type_name(*args)

def BRepFill_ShapeLaw_get_type_descriptor(*args):
    """
    BRepFill_ShapeLaw_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _BRepFill.BRepFill_ShapeLaw_get_type_descriptor(*args)

class BRepFill_CurveConstraint(GeomPlate.GeomPlate_CurveConstraint):
    """
    same as CurveConstraint from GeomPlate
    with BRepAdaptor_Surface instead of
    GeomAdaptor_Surface
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_BRepFill_CurveConstraint
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_BRepFill_CurveConstraint(self) 
            return h


    def __init__(self, *args):
        """
        __init__(BRepFill_CurveConstraint self, Handle_Adaptor3d_HCurveOnSurface Boundary, Standard_Integer const Order, Standard_Integer const NPt=10, Standard_Real const TolDist=0.0001, Standard_Real const TolAng=0.01, Standard_Real const TolCurv=0.1) -> BRepFill_CurveConstraint
        __init__(BRepFill_CurveConstraint self, Handle_Adaptor3d_HCurve Boundary, Standard_Integer const Tang, Standard_Integer const NPt=10, Standard_Real const TolDist=0.0001) -> BRepFill_CurveConstraint

        :type Boundary: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HCurve
        :type Tang: int
        :type NPt: int
        :type TolDist: float

        """
        this = _BRepFill.new_BRepFill_CurveConstraint(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _BRepFill.BRepFill_CurveConstraint_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _BRepFill.BRepFill_CurveConstraint_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _BRepFill.BRepFill_CurveConstraint_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _BRepFill.delete_BRepFill_CurveConstraint
BRepFill_CurveConstraint_swigregister = _BRepFill.BRepFill_CurveConstraint_swigregister
BRepFill_CurveConstraint_swigregister(BRepFill_CurveConstraint)

def BRepFill_CurveConstraint_get_type_name(*args):
    """
    BRepFill_CurveConstraint_get_type_name() -> char const *

    :rtype: const char *

    """
    return _BRepFill.BRepFill_CurveConstraint_get_type_name(*args)

def BRepFill_CurveConstraint_get_type_descriptor(*args):
    """
    BRepFill_CurveConstraint_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _BRepFill.BRepFill_CurveConstraint_get_type_descriptor(*args)

class BRepFill_EdgeFaceAndOrder(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BRepFill_EdgeFaceAndOrder self) -> BRepFill_EdgeFaceAndOrder
        __init__(BRepFill_EdgeFaceAndOrder self, TopoDS_Edge anEdge, TopoDS_Face aFace, GeomAbs_Shape const anOrder) -> BRepFill_EdgeFaceAndOrder

        :type anEdge: OCC.wrapper.TopoDS.TopoDS_Edge
        :type aFace: OCC.wrapper.TopoDS.TopoDS_Face
        :type anOrder: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        this = _BRepFill.new_BRepFill_EdgeFaceAndOrder(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _BRepFill.delete_BRepFill_EdgeFaceAndOrder
BRepFill_EdgeFaceAndOrder_swigregister = _BRepFill.BRepFill_EdgeFaceAndOrder_swigregister
BRepFill_EdgeFaceAndOrder_swigregister(BRepFill_EdgeFaceAndOrder)


try:
	TColStd_MapTransientHasher = TColStd.NCollection_DefaultHasher_Handle_Standard_Transient
except AttributeError:
	pass # does not exist, probably ignored

class BRepFill_EdgeOnSurfLaw(BRepFill_LocationLaw):
    """Build Location Law, with a Wire and a  Surface."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_BRepFill_EdgeOnSurfLaw
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_BRepFill_EdgeOnSurfLaw(self) 
            return h


    def __init__(self, *args):
        """
        __init__(BRepFill_EdgeOnSurfLaw self, TopoDS_Wire Path, TopoDS_Shape Surf) -> BRepFill_EdgeOnSurfLaw

        :type Path: OCC.wrapper.TopoDS.TopoDS_Wire
        :type Surf: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        this = _BRepFill.new_BRepFill_EdgeOnSurfLaw(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def HasResult(self, *args):
        """
        HasResult(BRepFill_EdgeOnSurfLaw self) -> Standard_Boolean

        returns <False> if one  Edge of <Path> do not have
        representation on  <Surf>.   In this  case  it is
        impossible to use this object.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepFill.BRepFill_EdgeOnSurfLaw_HasResult(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _BRepFill.BRepFill_EdgeOnSurfLaw_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _BRepFill.BRepFill_EdgeOnSurfLaw_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _BRepFill.BRepFill_EdgeOnSurfLaw_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _BRepFill.delete_BRepFill_EdgeOnSurfLaw
BRepFill_EdgeOnSurfLaw_swigregister = _BRepFill.BRepFill_EdgeOnSurfLaw_swigregister
BRepFill_EdgeOnSurfLaw_swigregister(BRepFill_EdgeOnSurfLaw)

def BRepFill_EdgeOnSurfLaw_get_type_name(*args):
    """
    BRepFill_EdgeOnSurfLaw_get_type_name() -> char const *

    :rtype: const char *

    """
    return _BRepFill.BRepFill_EdgeOnSurfLaw_get_type_name(*args)

def BRepFill_EdgeOnSurfLaw_get_type_descriptor(*args):
    """
    BRepFill_EdgeOnSurfLaw_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _BRepFill.BRepFill_EdgeOnSurfLaw_get_type_descriptor(*args)


try:
	TopTools_ListOfShape = TopoDS.NCollection_List_TopoDS_Shape
except AttributeError:
	pass # does not exist, probably ignored

class Handle_BRepFill_PipeShell(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_BRepFill_PipeShell self)

        Nullify the handle


        """
        return _BRepFill.Handle_BRepFill_PipeShell_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_BRepFill_PipeShell self) -> bool

        Check for being null

        :rtype: bool

        """
        return _BRepFill.Handle_BRepFill_PipeShell_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_BRepFill_PipeShell self, BRepFill_PipeShell thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _BRepFill.Handle_BRepFill_PipeShell_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_BRepFill_PipeShell self, Handle_BRepFill_PipeShell theHandle) -> Handle_BRepFill_PipeShell
        assign(Handle_BRepFill_PipeShell self, BRepFill_PipeShell thePtr) -> Handle_BRepFill_PipeShell
        assign(Handle_BRepFill_PipeShell self, Handle_BRepFill_PipeShell theHandle) -> Handle_BRepFill_PipeShell

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _BRepFill.Handle_BRepFill_PipeShell_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_BRepFill_PipeShell self) -> BRepFill_PipeShell

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _BRepFill.Handle_BRepFill_PipeShell_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_BRepFill_PipeShell self) -> BRepFill_PipeShell

        Member access operator (note non-const)

        :rtype: T *

        """
        return _BRepFill.Handle_BRepFill_PipeShell___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_BRepFill_PipeShell self) -> BRepFill_PipeShell

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _BRepFill.Handle_BRepFill_PipeShell___ref__(self, *args)


    def __hash__(self):
        return _BRepFill.Handle_BRepFill_PipeShell___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _BRepFill.Handle_BRepFill_PipeShell___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _BRepFill.new_Handle_BRepFill_PipeShell(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_BRepFill.Handle_BRepFill_PipeShell_DownCast)
    __swig_destroy__ = _BRepFill.delete_Handle_BRepFill_PipeShell

    def Set(self, *args):
        """
        Set(Handle_BRepFill_PipeShell self, Standard_Boolean const Frenet)
        Set(Handle_BRepFill_PipeShell self, gp_Ax2 Axe)
        Set(Handle_BRepFill_PipeShell self, gp_Dir BiNormal)
        Set(Handle_BRepFill_PipeShell self, TopoDS_Shape SpineSupport) -> Standard_Boolean
        Set(Handle_BRepFill_PipeShell self, TopoDS_Wire AuxiliarySpine, Standard_Boolean const CurvilinearEquivalence, BRepFill_TypeOfContact const KeepContact=BRepFill_NoContact)

        Set  an  auxiliary  spine  to  define  the Normal
        For  each  Point  of  the  Spine  P,  an  Point  Q  is  evalued
        on  <AuxiliarySpine>
        If <CurvilinearEquivalence>
        Q split <AuxiliarySpine> with  the  same  length ratio
        than P split  <Spline>.
        Else  the  plan  define  by  P  and  the  tangent  to  the  <Spine>
        intersect <AuxiliarySpine> in Q.
        If <KeepContact> equals BRepFill_NoContact: The Normal is defined
        by the vector PQ.
        If <KeepContact> equals BRepFill_Contact: The Normal is defined to
        achieve that the sweeped section is in contact to the
        auxiliarySpine. The width of section is constant all along the path.
        In other words, the auxiliary spine lies on the swept surface,
        but not necessarily is a boundary of this surface. However,
        the auxiliary spine has to be close enough to the main spine
        to provide intersection with any section all along the path.
        If <KeepContact> equals BRepFill_ContactOnBorder: The auxiliary spine
        becomes a boundary of the swept surface and the width of section varies
        along the path.

        :type AuxiliarySpine: OCC.wrapper.TopoDS.TopoDS_Wire
        :type CurvilinearEquivalence: bool
        :type KeepContact: OCC.wrapper.BRepFill.BRepFill_TypeOfContact

        """
        return _BRepFill.Handle_BRepFill_PipeShell_Set(self, *args)


    def SetDiscrete(self, *args):
        """
        SetDiscrete(Handle_BRepFill_PipeShell self)

        Set a Discrete trihedron
        to  perform  the  sweeping


        """
        return _BRepFill.Handle_BRepFill_PipeShell_SetDiscrete(self, *args)


    def SetMaxDegree(self, *args):
        """
        SetMaxDegree(Handle_BRepFill_PipeShell self, Standard_Integer const NewMaxDegree)

        Define the maximum V degree of resulting surface

        :type NewMaxDegree: int

        """
        return _BRepFill.Handle_BRepFill_PipeShell_SetMaxDegree(self, *args)


    def SetMaxSegments(self, *args):
        """
        SetMaxSegments(Handle_BRepFill_PipeShell self, Standard_Integer const NewMaxSegments)

        Define the maximum number of spans in V-direction
        on resulting surface

        :type NewMaxSegments: int

        """
        return _BRepFill.Handle_BRepFill_PipeShell_SetMaxSegments(self, *args)


    def SetForceApproxC1(self, *args):
        """
        SetForceApproxC1(Handle_BRepFill_PipeShell self, Standard_Boolean const ForceApproxC1)

        Set the flag that indicates attempt to approximate
        a C1-continuous surface if a swept surface proved
        to be C0.
        Give section to sweep.
        Possibilities are :
        - Give one or sevral profile
        - Give one profile and an homotetic law.
        - Automatic compute of correspondance beetween profile, and section
        on the sweeped shape
        - correspondance beetween profile, and section on the sweeped shape
        defined by a vertex of the spine

        :type ForceApproxC1: bool

        """
        return _BRepFill.Handle_BRepFill_PipeShell_SetForceApproxC1(self, *args)


    def Add(self, *args):
        """
        Add(Handle_BRepFill_PipeShell self, TopoDS_Shape Profile, Standard_Boolean const WithContact, Standard_Boolean const WithCorrection)
        Add(Handle_BRepFill_PipeShell self, TopoDS_Shape Profile, TopoDS_Vertex Location, Standard_Boolean const WithContact, Standard_Boolean const WithCorrection)

        Set an section.   The corespondance with the spine, is
        given by  <Location>

        :type Profile: OCC.wrapper.TopoDS.TopoDS_Shape
        :type Location: OCC.wrapper.TopoDS.TopoDS_Vertex
        :type WithContact: bool
        :type WithCorrection: bool

        """
        return _BRepFill.Handle_BRepFill_PipeShell_Add(self, *args)


    def SetLaw(self, *args):
        """
        SetLaw(Handle_BRepFill_PipeShell self, TopoDS_Shape Profile, Handle_Law_Function L, Standard_Boolean const WithContact, Standard_Boolean const WithCorrection)
        SetLaw(Handle_BRepFill_PipeShell self, TopoDS_Shape Profile, Handle_Law_Function L, TopoDS_Vertex Location, Standard_Boolean const WithContact, Standard_Boolean const WithCorrection)

        Set  an    section  and  an   homotetic    law.
        The  homotetie  center  is  given  by  point  on  the  <Spine>

        :type Profile: OCC.wrapper.TopoDS.TopoDS_Shape
        :type L: OCC.wrapper.Law.Handle_Law_Function
        :type Location: OCC.wrapper.TopoDS.TopoDS_Vertex
        :type WithContact: bool
        :type WithCorrection: bool

        """
        return _BRepFill.Handle_BRepFill_PipeShell_SetLaw(self, *args)


    def DeleteProfile(self, *args):
        """
        DeleteProfile(Handle_BRepFill_PipeShell self, TopoDS_Shape Profile)

        Delete an section.

        :type Profile: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _BRepFill.Handle_BRepFill_PipeShell_DeleteProfile(self, *args)


    def IsReady(self, *args):
        """
        IsReady(Handle_BRepFill_PipeShell self) -> Standard_Boolean

        Say if <me> is ready to build the shape
        return False if <me> do not have section definition

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepFill.Handle_BRepFill_PipeShell_IsReady(self, *args)


    def GetStatus(self, *args):
        """
        GetStatus(Handle_BRepFill_PipeShell self) -> GeomFill_PipeError

        Get a status, when Simulate or Build failed.

        :rtype: OCC.wrapper.GeomFill.GeomFill_PipeError

        """
        return _BRepFill.Handle_BRepFill_PipeShell_GetStatus(self, *args)


    def SetTolerance(self, *args):
        """
        SetTolerance(Handle_BRepFill_PipeShell self, Standard_Real const Tol3d=1.0e-4, Standard_Real const BoundTol=1.0e-4, Standard_Real const TolAngular=1.0e-2)

        :type Tol3d: float
        :type BoundTol: float
        :type TolAngular: float

        """
        return _BRepFill.Handle_BRepFill_PipeShell_SetTolerance(self, *args)


    def SetTransition(self, *args):
        """
        SetTransition(Handle_BRepFill_PipeShell self, BRepFill_TransitionStyle const Mode=BRepFill_Modified, Standard_Real const Angmin=1.0e-2, Standard_Real const Angmax=6.0)

        Set the  Transition Mode to manage discontinuities
        on the sweep.

        :type Mode: OCC.wrapper.BRepFill.BRepFill_TransitionStyle
        :type Angmin: float
        :type Angmax: float

        """
        return _BRepFill.Handle_BRepFill_PipeShell_SetTransition(self, *args)


    def Simulate(self, *args):
        """
        Simulate(Handle_BRepFill_PipeShell self, Standard_Integer const NumberOfSection, NCollection_List_TopoDS_Shape Sections)

        Perform simulation of the sweep :
        Somes Section are returned.

        :type NumberOfSection: int
        :type Sections: OCC.wrapper.TopTools.TopTools_ListOfShape

        """
        return _BRepFill.Handle_BRepFill_PipeShell_Simulate(self, *args)


    def Build(self, *args):
        """
        Build(Handle_BRepFill_PipeShell self) -> Standard_Boolean

        Builds the resulting shape (redefined from MakeShape).

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepFill.Handle_BRepFill_PipeShell_Build(self, *args)


    def MakeSolid(self, *args):
        """
        MakeSolid(Handle_BRepFill_PipeShell self) -> Standard_Boolean

        Transform the sweeping Shell in Solid.
        If the section are not closed returns False

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepFill.Handle_BRepFill_PipeShell_MakeSolid(self, *args)


    def Shape(self, *args):
        """
        Returns the result Shape.

        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _BRepFill.Handle_BRepFill_PipeShell_Shape(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ErrorOnSurface(self, *args):
        """
        ErrorOnSurface(Handle_BRepFill_PipeShell self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _BRepFill.Handle_BRepFill_PipeShell_ErrorOnSurface(self, *args)


    def FirstShape(self, *args):
        """
        Returns the  TopoDS  Shape of the bottom of the sweep.

        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _BRepFill.Handle_BRepFill_PipeShell_FirstShape(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def LastShape(self, *args):
        """
        Returns the TopoDS Shape of the top of the sweep.

        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _BRepFill.Handle_BRepFill_PipeShell_LastShape(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Profiles(self, *args):
        """
        Profiles(Handle_BRepFill_PipeShell self, NCollection_List_TopoDS_Shape theProfiles)

        Returns the list of original profiles

        :type theProfiles: OCC.wrapper.TopTools.TopTools_ListOfShape

        """
        return _BRepFill.Handle_BRepFill_PipeShell_Profiles(self, *args)


    def Spine(self, *args):
        """
        Returns the spine

        :rtype: OCC.wrapper.TopoDS.TopoDS_Wire

        """
        res = _BRepFill.Handle_BRepFill_PipeShell_Spine(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Generated(self, *args):
        """
        Generated(Handle_BRepFill_PipeShell self, TopoDS_Shape S, NCollection_List_TopoDS_Shape L)

        Returns the  list   of shapes generated   from the
        shape <S>.

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :type L: OCC.wrapper.TopTools.TopTools_ListOfShape

        """
        return _BRepFill.Handle_BRepFill_PipeShell_Generated(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_BRepFill_PipeShell self) -> char const *

        :rtype: const char *

        """
        return _BRepFill.Handle_BRepFill_PipeShell_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _BRepFill.Handle_BRepFill_PipeShell_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _BRepFill.Handle_BRepFill_PipeShell_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_BRepFill_PipeShell self)

        Memory deallocator for transient classes


        """
        return _BRepFill.Handle_BRepFill_PipeShell_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_BRepFill_PipeShell self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_BRepFill_PipeShell self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepFill.Handle_BRepFill_PipeShell_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_BRepFill_PipeShell self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_BRepFill_PipeShell self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepFill.Handle_BRepFill_PipeShell_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_BRepFill_PipeShell self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _BRepFill.Handle_BRepFill_PipeShell_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_BRepFill_PipeShell self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepFill.Handle_BRepFill_PipeShell_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_BRepFill_PipeShell self)

        Increments the reference counter of this object


        """
        return _BRepFill.Handle_BRepFill_PipeShell_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_BRepFill_PipeShell self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepFill.Handle_BRepFill_PipeShell_DecrementRefCounter(self, *args)

Handle_BRepFill_PipeShell_swigregister = _BRepFill.Handle_BRepFill_PipeShell_swigregister
Handle_BRepFill_PipeShell_swigregister(Handle_BRepFill_PipeShell)

def Handle_BRepFill_PipeShell_DownCast(thing):
    return _BRepFill.Handle_BRepFill_PipeShell_DownCast(thing)
Handle_BRepFill_PipeShell_DownCast = _BRepFill.Handle_BRepFill_PipeShell_DownCast


try:
	TColStd_SequenceOfReal = TColStd.NCollection_Sequence_Standard_Real
except AttributeError:
	pass # does not exist, probably ignored

class BRepFill_(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Face(*args):
        """
        Face(TopoDS_Edge Edge1, TopoDS_Edge Edge2) -> TopoDS_Face

        Computes a ruled surface between two edges.

        :type Edge1: OCC.wrapper.TopoDS.TopoDS_Edge
        :type Edge2: OCC.wrapper.TopoDS.TopoDS_Edge
        :rtype: OCC.wrapper.TopoDS.TopoDS_Face

        """
        return _BRepFill.BRepFill__Face(*args)

    Face = staticmethod(Face)

    def Shell(*args):
        """
        Shell(TopoDS_Wire Wire1, TopoDS_Wire Wire2) -> TopoDS_Shell

        Computes a ruled surface between two wires.
        The wires must have the same number of edges.

        :type Wire1: OCC.wrapper.TopoDS.TopoDS_Wire
        :type Wire2: OCC.wrapper.TopoDS.TopoDS_Wire
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shell

        """
        return _BRepFill.BRepFill__Shell(*args)

    Shell = staticmethod(Shell)

    def Axe(*args):
        """
        Axe(TopoDS_Shape Spine, TopoDS_Wire Profile, gp_Ax3 AxeProf, Standard_Real const Tol)

        Computes  <AxeProf>  as Follow. <Location> is
        the Position of the nearest vertex V  of <Profile>
        to <Spine>.<XDirection> is confused with the tangent
        to <Spine> at the projected point of V on the Spine.
        <Direction> is normal to <Spine>.
        <Spine> is a plane wire or a plane face.

        :type Spine: OCC.wrapper.TopoDS.TopoDS_Shape
        :type Profile: OCC.wrapper.TopoDS.TopoDS_Wire
        :type AxeProf: OCC.wrapper.gp.gp_Ax3
        :type ProfOnSpine: bool
        :type Tol: float

        """
        return _BRepFill.BRepFill__Axe(*args)

    Axe = staticmethod(Axe)

    def ComputeACR(*args):
        """
        ComputeACR(TopoDS_Wire wire, NCollection_Array1_Standard_Real ACR)

        Compute ACR on a  wire

        :type wire: OCC.wrapper.TopoDS.TopoDS_Wire
        :type ACR: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        return _BRepFill.BRepFill__ComputeACR(*args)

    ComputeACR = staticmethod(ComputeACR)

    def InsertACR(*args):
        """
        InsertACR(TopoDS_Wire wire, NCollection_Array1_Standard_Real ACRcuts, Standard_Real const prec) -> TopoDS_Wire

        Insert ACR on a  wire

        :type wire: OCC.wrapper.TopoDS.TopoDS_Wire
        :type ACRcuts: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type prec: float
        :rtype: OCC.wrapper.TopoDS.TopoDS_Wire

        """
        return _BRepFill.BRepFill__InsertACR(*args)

    InsertACR = staticmethod(InsertACR)

    def __init__(self):
        this = _BRepFill.new_BRepFill_()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _BRepFill.delete_BRepFill_
BRepFill__swigregister = _BRepFill.BRepFill__swigregister
BRepFill__swigregister(BRepFill_)

def BRepFill__Face(*args):
    """
    BRepFill__Face(TopoDS_Edge Edge1, TopoDS_Edge Edge2) -> TopoDS_Face

    Computes a ruled surface between two edges.

    :type Edge1: OCC.wrapper.TopoDS.TopoDS_Edge
    :type Edge2: OCC.wrapper.TopoDS.TopoDS_Edge
    :rtype: OCC.wrapper.TopoDS.TopoDS_Face

    """
    return _BRepFill.BRepFill__Face(*args)

def BRepFill__Shell(*args):
    """
    BRepFill__Shell(TopoDS_Wire Wire1, TopoDS_Wire Wire2) -> TopoDS_Shell

    Computes a ruled surface between two wires.
    The wires must have the same number of edges.

    :type Wire1: OCC.wrapper.TopoDS.TopoDS_Wire
    :type Wire2: OCC.wrapper.TopoDS.TopoDS_Wire
    :rtype: OCC.wrapper.TopoDS.TopoDS_Shell

    """
    return _BRepFill.BRepFill__Shell(*args)

def BRepFill__Axe(*args):
    """
    BRepFill__Axe(TopoDS_Shape Spine, TopoDS_Wire Profile, gp_Ax3 AxeProf, Standard_Real const Tol)

    Computes  <AxeProf>  as Follow. <Location> is
    the Position of the nearest vertex V  of <Profile>
    to <Spine>.<XDirection> is confused with the tangent
    to <Spine> at the projected point of V on the Spine.
    <Direction> is normal to <Spine>.
    <Spine> is a plane wire or a plane face.

    :type Spine: OCC.wrapper.TopoDS.TopoDS_Shape
    :type Profile: OCC.wrapper.TopoDS.TopoDS_Wire
    :type AxeProf: OCC.wrapper.gp.gp_Ax3
    :type ProfOnSpine: bool
    :type Tol: float

    """
    return _BRepFill.BRepFill__Axe(*args)

def BRepFill__ComputeACR(*args):
    """
    BRepFill__ComputeACR(TopoDS_Wire wire, NCollection_Array1_Standard_Real ACR)

    Compute ACR on a  wire

    :type wire: OCC.wrapper.TopoDS.TopoDS_Wire
    :type ACR: OCC.wrapper.TColStd.TColStd_Array1OfReal

    """
    return _BRepFill.BRepFill__ComputeACR(*args)

def BRepFill__InsertACR(*args):
    """
    BRepFill__InsertACR(TopoDS_Wire wire, NCollection_Array1_Standard_Real ACRcuts, Standard_Real const prec) -> TopoDS_Wire

    Insert ACR on a  wire

    :type wire: OCC.wrapper.TopoDS.TopoDS_Wire
    :type ACRcuts: OCC.wrapper.TColStd.TColStd_Array1OfReal
    :type prec: float
    :rtype: OCC.wrapper.TopoDS.TopoDS_Wire

    """
    return _BRepFill.BRepFill__InsertACR(*args)

class BRepFill_FaceAndOrder(object):
    """A structure containing Face and Order of constraint"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BRepFill_FaceAndOrder self) -> BRepFill_FaceAndOrder
        __init__(BRepFill_FaceAndOrder self, TopoDS_Face aFace, GeomAbs_Shape const anOrder) -> BRepFill_FaceAndOrder

        :type aFace: OCC.wrapper.TopoDS.TopoDS_Face
        :type anOrder: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        this = _BRepFill.new_BRepFill_FaceAndOrder(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _BRepFill.delete_BRepFill_FaceAndOrder
BRepFill_FaceAndOrder_swigregister = _BRepFill.BRepFill_FaceAndOrder_swigregister
BRepFill_FaceAndOrder_swigregister(BRepFill_FaceAndOrder)

class Handle_BRepFill_SectionLaw(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_BRepFill_SectionLaw self)

        Nullify the handle


        """
        return _BRepFill.Handle_BRepFill_SectionLaw_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_BRepFill_SectionLaw self) -> bool

        Check for being null

        :rtype: bool

        """
        return _BRepFill.Handle_BRepFill_SectionLaw_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_BRepFill_SectionLaw self, BRepFill_SectionLaw thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _BRepFill.Handle_BRepFill_SectionLaw_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_BRepFill_SectionLaw self, Handle_BRepFill_SectionLaw theHandle) -> Handle_BRepFill_SectionLaw
        assign(Handle_BRepFill_SectionLaw self, BRepFill_SectionLaw thePtr) -> Handle_BRepFill_SectionLaw
        assign(Handle_BRepFill_SectionLaw self, Handle_BRepFill_SectionLaw theHandle) -> Handle_BRepFill_SectionLaw

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _BRepFill.Handle_BRepFill_SectionLaw_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_BRepFill_SectionLaw self) -> BRepFill_SectionLaw

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _BRepFill.Handle_BRepFill_SectionLaw_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_BRepFill_SectionLaw self) -> BRepFill_SectionLaw

        Member access operator (note non-const)

        :rtype: T *

        """
        return _BRepFill.Handle_BRepFill_SectionLaw___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_BRepFill_SectionLaw self) -> BRepFill_SectionLaw

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _BRepFill.Handle_BRepFill_SectionLaw___ref__(self, *args)


    def __hash__(self):
        return _BRepFill.Handle_BRepFill_SectionLaw___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _BRepFill.Handle_BRepFill_SectionLaw___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _BRepFill.new_Handle_BRepFill_SectionLaw(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_BRepFill.Handle_BRepFill_SectionLaw_DownCast)
    __swig_destroy__ = _BRepFill.delete_Handle_BRepFill_SectionLaw

    def NbLaw(self, *args):
        """
        NbLaw(Handle_BRepFill_SectionLaw self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepFill.Handle_BRepFill_SectionLaw_NbLaw(self, *args)


    def Law(self, *args):
        """
        :type Index: int
        :rtype: OCC.wrapper.GeomFill.Handle_GeomFill_SectionLaw

        """
        res = _BRepFill.Handle_BRepFill_SectionLaw_Law_(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def IndexOfEdge(self, *args):
        """
        IndexOfEdge(Handle_BRepFill_SectionLaw self, TopoDS_Shape anEdge) -> Standard_Integer

        :type anEdge: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepFill.Handle_BRepFill_SectionLaw_IndexOfEdge(self, *args)


    def IsConstant(self, *args):
        """
        IsConstant(Handle_BRepFill_SectionLaw self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepFill.Handle_BRepFill_SectionLaw_IsConstant(self, *args)


    def IsUClosed(self, *args):
        """
        IsUClosed(Handle_BRepFill_SectionLaw self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepFill.Handle_BRepFill_SectionLaw_IsUClosed(self, *args)


    def IsVClosed(self, *args):
        """
        IsVClosed(Handle_BRepFill_SectionLaw self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepFill.Handle_BRepFill_SectionLaw_IsVClosed(self, *args)


    def IsDone(self, *args):
        """
        IsDone(Handle_BRepFill_SectionLaw self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepFill.Handle_BRepFill_SectionLaw_IsDone(self, *args)


    def IsVertex(self, *args):
        """
        IsVertex(Handle_BRepFill_SectionLaw self) -> Standard_Boolean

        Say if the input shape is a  vertex.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepFill.Handle_BRepFill_SectionLaw_IsVertex(self, *args)


    def ConcatenedLaw(self, *args):
        """
        ConcatenedLaw(Handle_BRepFill_SectionLaw self) -> Handle_GeomFill_SectionLaw

        :rtype: OCC.wrapper.GeomFill.Handle_GeomFill_SectionLaw

        """
        return _BRepFill.Handle_BRepFill_SectionLaw_ConcatenedLaw(self, *args)


    def Continuity(self, *args):
        """
        Continuity(Handle_BRepFill_SectionLaw self, Standard_Integer const Index, Standard_Real const TolAngular) -> GeomAbs_Shape

        :type Index: int
        :type TolAngular: float
        :rtype: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _BRepFill.Handle_BRepFill_SectionLaw_Continuity(self, *args)


    def VertexTol(self, *args):
        """
        VertexTol(Handle_BRepFill_SectionLaw self, Standard_Integer const Index, Standard_Real const Param) -> Standard_Real

        :type Index: int
        :type Param: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _BRepFill.Handle_BRepFill_SectionLaw_VertexTol(self, *args)


    def Vertex(self, *args):
        """
        Vertex(Handle_BRepFill_SectionLaw self, Standard_Integer const Index, Standard_Real const Param) -> TopoDS_Vertex

        :type Index: int
        :type Param: float
        :rtype: OCC.wrapper.TopoDS.TopoDS_Vertex

        """
        return _BRepFill.Handle_BRepFill_SectionLaw_Vertex(self, *args)


    def D0(self, *args):
        """
        D0(Handle_BRepFill_SectionLaw self, Standard_Real const U, TopoDS_Shape S)

        :type U: float
        :type S: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _BRepFill.Handle_BRepFill_SectionLaw_D0(self, *args)


    def Init(self, *args):
        """
        Init(Handle_BRepFill_SectionLaw self, TopoDS_Wire W)

        :type W: OCC.wrapper.TopoDS.TopoDS_Wire

        """
        return _BRepFill.Handle_BRepFill_SectionLaw_Init(self, *args)


    def CurrentEdge(self, *args):
        """
        CurrentEdge(Handle_BRepFill_SectionLaw self) -> TopoDS_Edge

        :rtype: OCC.wrapper.TopoDS.TopoDS_Edge

        """
        return _BRepFill.Handle_BRepFill_SectionLaw_CurrentEdge(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_BRepFill_SectionLaw self) -> char const *

        :rtype: const char *

        """
        return _BRepFill.Handle_BRepFill_SectionLaw_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _BRepFill.Handle_BRepFill_SectionLaw_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _BRepFill.Handle_BRepFill_SectionLaw_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_BRepFill_SectionLaw self)

        Memory deallocator for transient classes


        """
        return _BRepFill.Handle_BRepFill_SectionLaw_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_BRepFill_SectionLaw self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_BRepFill_SectionLaw self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepFill.Handle_BRepFill_SectionLaw_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_BRepFill_SectionLaw self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_BRepFill_SectionLaw self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepFill.Handle_BRepFill_SectionLaw_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_BRepFill_SectionLaw self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _BRepFill.Handle_BRepFill_SectionLaw_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_BRepFill_SectionLaw self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepFill.Handle_BRepFill_SectionLaw_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_BRepFill_SectionLaw self)

        Increments the reference counter of this object


        """
        return _BRepFill.Handle_BRepFill_SectionLaw_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_BRepFill_SectionLaw self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepFill.Handle_BRepFill_SectionLaw_DecrementRefCounter(self, *args)

Handle_BRepFill_SectionLaw_swigregister = _BRepFill.Handle_BRepFill_SectionLaw_swigregister
Handle_BRepFill_SectionLaw_swigregister(Handle_BRepFill_SectionLaw)

def Handle_BRepFill_SectionLaw_DownCast(thing):
    return _BRepFill.Handle_BRepFill_SectionLaw_DownCast(thing)
Handle_BRepFill_SectionLaw_DownCast = _BRepFill.Handle_BRepFill_SectionLaw_DownCast

class Handle_BRepFill_NSections(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_BRepFill_NSections self)

        Nullify the handle


        """
        return _BRepFill.Handle_BRepFill_NSections_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_BRepFill_NSections self) -> bool

        Check for being null

        :rtype: bool

        """
        return _BRepFill.Handle_BRepFill_NSections_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_BRepFill_NSections self, BRepFill_NSections thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _BRepFill.Handle_BRepFill_NSections_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_BRepFill_NSections self, Handle_BRepFill_NSections theHandle) -> Handle_BRepFill_NSections
        assign(Handle_BRepFill_NSections self, BRepFill_NSections thePtr) -> Handle_BRepFill_NSections
        assign(Handle_BRepFill_NSections self, Handle_BRepFill_NSections theHandle) -> Handle_BRepFill_NSections

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _BRepFill.Handle_BRepFill_NSections_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_BRepFill_NSections self) -> BRepFill_NSections

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _BRepFill.Handle_BRepFill_NSections_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_BRepFill_NSections self) -> BRepFill_NSections

        Member access operator (note non-const)

        :rtype: T *

        """
        return _BRepFill.Handle_BRepFill_NSections___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_BRepFill_NSections self) -> BRepFill_NSections

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _BRepFill.Handle_BRepFill_NSections___ref__(self, *args)


    def __hash__(self):
        return _BRepFill.Handle_BRepFill_NSections___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _BRepFill.Handle_BRepFill_NSections___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _BRepFill.new_Handle_BRepFill_NSections(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_BRepFill.Handle_BRepFill_NSections_DownCast)
    __swig_destroy__ = _BRepFill.delete_Handle_BRepFill_NSections

    def IsVertex(self, *args):
        """
        IsVertex(Handle_BRepFill_NSections self) -> Standard_Boolean

        Say if the input shape is a  vertex.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepFill.Handle_BRepFill_NSections_IsVertex(self, *args)


    def IsConstant(self, *args):
        """
        IsConstant(Handle_BRepFill_NSections self) -> Standard_Boolean

        Say if the Law is  Constant.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepFill.Handle_BRepFill_NSections_IsConstant(self, *args)


    def ConcatenedLaw(self, *args):
        """
        ConcatenedLaw(Handle_BRepFill_NSections self) -> Handle_GeomFill_SectionLaw

        Give the law build on a concatened section

        :rtype: OCC.wrapper.GeomFill.Handle_GeomFill_SectionLaw

        """
        return _BRepFill.Handle_BRepFill_NSections_ConcatenedLaw(self, *args)


    def Continuity(self, *args):
        """
        Continuity(Handle_BRepFill_NSections self, Standard_Integer const Index, Standard_Real const TolAngular) -> GeomAbs_Shape

        :type Index: int
        :type TolAngular: float
        :rtype: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _BRepFill.Handle_BRepFill_NSections_Continuity(self, *args)


    def VertexTol(self, *args):
        """
        VertexTol(Handle_BRepFill_NSections self, Standard_Integer const Index, Standard_Real const Param) -> Standard_Real

        :type Index: int
        :type Param: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _BRepFill.Handle_BRepFill_NSections_VertexTol(self, *args)


    def Vertex(self, *args):
        """
        Vertex(Handle_BRepFill_NSections self, Standard_Integer const Index, Standard_Real const Param) -> TopoDS_Vertex

        :type Index: int
        :type Param: float
        :rtype: OCC.wrapper.TopoDS.TopoDS_Vertex

        """
        return _BRepFill.Handle_BRepFill_NSections_Vertex(self, *args)


    def D0(self, *args):
        """
        D0(Handle_BRepFill_NSections self, Standard_Real const Param, TopoDS_Shape S)

        :type Param: float
        :type S: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _BRepFill.Handle_BRepFill_NSections_D0(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_BRepFill_NSections self) -> char const *

        :rtype: const char *

        """
        return _BRepFill.Handle_BRepFill_NSections_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _BRepFill.Handle_BRepFill_NSections_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _BRepFill.Handle_BRepFill_NSections_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def NbLaw(self, *args):
        """
        NbLaw(Handle_BRepFill_NSections self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepFill.Handle_BRepFill_NSections_NbLaw(self, *args)


    def Law(self, *args):
        """
        :type Index: int
        :rtype: OCC.wrapper.GeomFill.Handle_GeomFill_SectionLaw

        """
        res = _BRepFill.Handle_BRepFill_NSections_Law_(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def IndexOfEdge(self, *args):
        """
        IndexOfEdge(Handle_BRepFill_NSections self, TopoDS_Shape anEdge) -> Standard_Integer

        :type anEdge: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepFill.Handle_BRepFill_NSections_IndexOfEdge(self, *args)


    def IsUClosed(self, *args):
        """
        IsUClosed(Handle_BRepFill_NSections self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepFill.Handle_BRepFill_NSections_IsUClosed(self, *args)


    def IsVClosed(self, *args):
        """
        IsVClosed(Handle_BRepFill_NSections self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepFill.Handle_BRepFill_NSections_IsVClosed(self, *args)


    def IsDone(self, *args):
        """
        IsDone(Handle_BRepFill_NSections self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepFill.Handle_BRepFill_NSections_IsDone(self, *args)


    def CurrentEdge(self, *args):
        """
        CurrentEdge(Handle_BRepFill_NSections self) -> TopoDS_Edge

        :rtype: OCC.wrapper.TopoDS.TopoDS_Edge

        """
        return _BRepFill.Handle_BRepFill_NSections_CurrentEdge(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_BRepFill_NSections self)

        Memory deallocator for transient classes


        """
        return _BRepFill.Handle_BRepFill_NSections_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_BRepFill_NSections self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_BRepFill_NSections self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepFill.Handle_BRepFill_NSections_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_BRepFill_NSections self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_BRepFill_NSections self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepFill.Handle_BRepFill_NSections_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_BRepFill_NSections self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _BRepFill.Handle_BRepFill_NSections_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_BRepFill_NSections self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepFill.Handle_BRepFill_NSections_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_BRepFill_NSections self)

        Increments the reference counter of this object


        """
        return _BRepFill.Handle_BRepFill_NSections_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_BRepFill_NSections self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepFill.Handle_BRepFill_NSections_DecrementRefCounter(self, *args)

Handle_BRepFill_NSections_swigregister = _BRepFill.Handle_BRepFill_NSections_swigregister
Handle_BRepFill_NSections_swigregister(Handle_BRepFill_NSections)

def Handle_BRepFill_NSections_DownCast(thing):
    return _BRepFill.Handle_BRepFill_NSections_DownCast(thing)
Handle_BRepFill_NSections_DownCast = _BRepFill.Handle_BRepFill_NSections_DownCast

class NCollection_Sequence_BRepFill_Section(NCollection.NCollection_BaseSequence):
    """
    Purpose:     Definition of a sequence of elements indexed by
    an Integer in range of 1..n
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Sequence_BRepFill_Section self) -> NCollection_Sequence< BRepFill_Section >::iterator

        Returns an iterator pointing to the first element in the sequence.

        :rtype: iterator

        """
        return _BRepFill.NCollection_Sequence_BRepFill_Section_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Sequence_BRepFill_Section self) -> NCollection_Sequence< BRepFill_Section >::iterator

        Returns an iterator referring to the past-the-end element in the sequence.

        :rtype: iterator

        """
        return _BRepFill.NCollection_Sequence_BRepFill_Section_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Sequence_BRepFill_Section self) -> NCollection_Sequence< BRepFill_Section >::const_iterator

        Returns a const iterator pointing to the first element in the sequence.

        :rtype: const_iterator

        """
        return _BRepFill.NCollection_Sequence_BRepFill_Section_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Sequence_BRepFill_Section self) -> NCollection_Sequence< BRepFill_Section >::const_iterator

        Returns a const iterator referring to the past-the-end element in the sequence.

        :rtype: const_iterator

        """
        return _BRepFill.NCollection_Sequence_BRepFill_Section_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     Definition of a sequence of elements indexed by
        an Integer in range of 1..n
        """
        this = _BRepFill.new_NCollection_Sequence_BRepFill_Section(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Size(self, *args):
        """
        Size(NCollection_Sequence_BRepFill_Section self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepFill.NCollection_Sequence_BRepFill_Section_Size(self, *args)


    def Length(self, *args):
        """
        Length(NCollection_Sequence_BRepFill_Section self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepFill.NCollection_Sequence_BRepFill_Section_Length(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Sequence_BRepFill_Section self) -> Standard_Integer

        Method for consistency with other collections.
        @return Lower bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepFill.NCollection_Sequence_BRepFill_Section_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Sequence_BRepFill_Section self) -> Standard_Integer

        Method for consistency with other collections.
        @return Upper bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepFill.NCollection_Sequence_BRepFill_Section_Upper(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Sequence_BRepFill_Section self) -> Standard_Boolean

        Empty query

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepFill.NCollection_Sequence_BRepFill_Section_IsEmpty(self, *args)


    def Reverse(self, *args):
        """
        Reverse(NCollection_Sequence_BRepFill_Section self)

        Reverse sequence


        """
        return _BRepFill.NCollection_Sequence_BRepFill_Section_Reverse(self, *args)


    def Exchange(self, *args):
        """
        Exchange(NCollection_Sequence_BRepFill_Section self, Standard_Integer const I, Standard_Integer const J)

        Exchange two members

        :type I: int
        :type J: int

        """
        return _BRepFill.NCollection_Sequence_BRepFill_Section_Exchange(self, *args)


    def delNode(*args):
        """
        delNode(NCollection_SeqNode theNode, Handle_NCollection_BaseAllocator theAl)

        Static deleter to be passed to BaseSequence

        :type theNode: OCC.wrapper.NCollection.NCollection_SeqNode
        :type theAl: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _BRepFill.NCollection_Sequence_BRepFill_Section_delNode(*args)

    delNode = staticmethod(delNode)

    def Clear(self, *args):
        """
        Clear(NCollection_Sequence_BRepFill_Section self, Handle_NCollection_BaseAllocator theAllocator=0)

        Clear the items out, take a new allocator if non null

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _BRepFill.NCollection_Sequence_BRepFill_Section_Clear(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Sequence_BRepFill_Section self, NCollection_Sequence_BRepFill_Section theOther) -> NCollection_Sequence_BRepFill_Section

        Replace this sequence by the items of theOther.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_Sequence
        :rtype: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _BRepFill.NCollection_Sequence_BRepFill_Section_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Sequence_BRepFill_Section self, NCollection_Sequence_BRepFill_Section theOther) -> NCollection_Sequence_BRepFill_Section

        Replacement operator

        :type theOther: OCC.wrapper.NCollection.NCollection_Sequence
        :rtype: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _BRepFill.NCollection_Sequence_BRepFill_Section_assign(self, *args)


    def Remove(self, *args):
        """
        Remove(NCollection_Sequence_BRepFill_Section self, NCollection_Sequence< BRepFill_Section >::Iterator & thePosition)
        Remove(NCollection_Sequence_BRepFill_Section self, Standard_Integer const theIndex)
        Remove(NCollection_Sequence_BRepFill_Section self, Standard_Integer const theFromIndex, Standard_Integer const theToIndex)

        Remove range of items

        :type theFromIndex: int
        :type theToIndex: int

        """
        return _BRepFill.NCollection_Sequence_BRepFill_Section_Remove(self, *args)


    def Append(self, *args):
        """
        Append(NCollection_Sequence_BRepFill_Section self, BRepFill_Section theItem)
        Append(NCollection_Sequence_BRepFill_Section self, NCollection_Sequence_BRepFill_Section theSeq)

        Append another sequence (making it empty)

        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _BRepFill.NCollection_Sequence_BRepFill_Section_Append(self, *args)


    def Prepend(self, *args):
        """
        Prepend(NCollection_Sequence_BRepFill_Section self, BRepFill_Section theItem)
        Prepend(NCollection_Sequence_BRepFill_Section self, NCollection_Sequence_BRepFill_Section theSeq)

        Prepend another sequence (making it empty)

        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _BRepFill.NCollection_Sequence_BRepFill_Section_Prepend(self, *args)


    def InsertBefore(self, *args):
        """
        InsertBefore(NCollection_Sequence_BRepFill_Section self, Standard_Integer const theIndex, BRepFill_Section theItem)
        InsertBefore(NCollection_Sequence_BRepFill_Section self, Standard_Integer const theIndex, NCollection_Sequence_BRepFill_Section theSeq)

        InsertBefore theIndex another sequence

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _BRepFill.NCollection_Sequence_BRepFill_Section_InsertBefore(self, *args)


    def InsertAfter(self, *args):
        """
        InsertAfter(NCollection_Sequence_BRepFill_Section self, NCollection_Sequence< BRepFill_Section >::Iterator & thePosition, BRepFill_Section theItem)
        InsertAfter(NCollection_Sequence_BRepFill_Section self, Standard_Integer const theIndex, NCollection_Sequence_BRepFill_Section theSeq)
        InsertAfter(NCollection_Sequence_BRepFill_Section self, Standard_Integer const theIndex, BRepFill_Section theItem)

        InsertAfter theIndex another sequence

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _BRepFill.NCollection_Sequence_BRepFill_Section_InsertAfter(self, *args)


    def Split(self, *args):
        """
        Split(NCollection_Sequence_BRepFill_Section self, Standard_Integer const theIndex, NCollection_Sequence_BRepFill_Section theSeq)

        Split in two sequences

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _BRepFill.NCollection_Sequence_BRepFill_Section_Split(self, *args)


    def First(self, *args):
        """
        First item access

        :rtype: const TheItemType &

        """
        res = _BRepFill.NCollection_Sequence_BRepFill_Section_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Sequence_BRepFill_Section self) -> BRepFill_Section

        First item access

        :rtype: TheItemType &

        """
        return _BRepFill.NCollection_Sequence_BRepFill_Section_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        Last item access

        :rtype: const TheItemType &

        """
        res = _BRepFill.NCollection_Sequence_BRepFill_Section_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Sequence_BRepFill_Section self) -> BRepFill_Section

        Last item access

        :rtype: TheItemType &

        """
        return _BRepFill.NCollection_Sequence_BRepFill_Section_ChangeLast(self, *args)


    def Value(self, *args):
        """
        Constant item access by theIndex

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _BRepFill.NCollection_Sequence_BRepFill_Section_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Sequence_BRepFill_Section self, Standard_Integer const theIndex) -> BRepFill_Section

        Variable item access by theIndex

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _BRepFill.NCollection_Sequence_BRepFill_Section_ChangeValue(self, *args)


    def __call__(self, *args):
        """
        Constant operator()

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _BRepFill.NCollection_Sequence_BRepFill_Section___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetValue(self, *args):
        """
        SetValue(NCollection_Sequence_BRepFill_Section self, Standard_Integer const theIndex, BRepFill_Section theItem)

        Set item value by theIndex

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _BRepFill.NCollection_Sequence_BRepFill_Section_SetValue(self, *args)


    def __iter__(self):
        return _BRepFill.NCollection_Sequence_BRepFill_Section___iter__(self)
    __swig_destroy__ = _BRepFill.delete_NCollection_Sequence_BRepFill_Section
NCollection_Sequence_BRepFill_Section_swigregister = _BRepFill.NCollection_Sequence_BRepFill_Section_swigregister
NCollection_Sequence_BRepFill_Section_swigregister(NCollection_Sequence_BRepFill_Section)

def NCollection_Sequence_BRepFill_Section_delNode(*args):
    """
    NCollection_Sequence_BRepFill_Section_delNode(NCollection_SeqNode theNode, Handle_NCollection_BaseAllocator theAl)

    Static deleter to be passed to BaseSequence

    :type theNode: OCC.wrapper.NCollection.NCollection_SeqNode
    :type theAl: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

    """
    return _BRepFill.NCollection_Sequence_BRepFill_Section_delNode(*args)

class NCollection_Sequence_BRepFill_Section_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _BRepFill.new_NCollection_Sequence_BRepFill_Section_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _BRepFill.delete_NCollection_Sequence_BRepFill_Section_IteratorHelper

    def __next__(self):
        return _BRepFill.NCollection_Sequence_BRepFill_Section_IteratorHelper___next__(self)
NCollection_Sequence_BRepFill_Section_IteratorHelper_swigregister = _BRepFill.NCollection_Sequence_BRepFill_Section_IteratorHelper_swigregister
NCollection_Sequence_BRepFill_Section_IteratorHelper_swigregister(NCollection_Sequence_BRepFill_Section_IteratorHelper)


try:
	BRepFill_SequenceOfSection = NCollection_Sequence_BRepFill_Section
except NameError:
	pass # does not exist, probably ignored

class BRepFill_MultiLine(AppCont.AppCont_Function):
    """
    Class used to compute the 3d curve and the
    two 2d curves resulting from the intersection of a
    surface of linear extrusion( Bissec, Dz) and the 2
    faces.
    This 3 curves will  have  the same parametrization
    as the Bissectrice.
    This  class  is  to  be  send  to an approximation
    routine.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BRepFill_MultiLine self) -> BRepFill_MultiLine
        __init__(BRepFill_MultiLine self, TopoDS_Face Face1, TopoDS_Face Face2, TopoDS_Edge Edge1, TopoDS_Edge Edge2, Standard_Boolean const Inv1, Standard_Boolean const Inv2, Handle_Geom2d_Curve Bissec) -> BRepFill_MultiLine

        :type Face1: OCC.wrapper.TopoDS.TopoDS_Face
        :type Face2: OCC.wrapper.TopoDS.TopoDS_Face
        :type Edge1: OCC.wrapper.TopoDS.TopoDS_Edge
        :type Edge2: OCC.wrapper.TopoDS.TopoDS_Edge
        :type Inv1: bool
        :type Inv2: bool
        :type Bissec: OCC.wrapper.Geom2d.Handle_Geom2d_Curve

        """
        this = _BRepFill.new_BRepFill_MultiLine(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def IsParticularCase(self, *args):
        """
        IsParticularCase(BRepFill_MultiLine self) -> Standard_Boolean

        Search if the Projection of the Bissectrice on the
        faces needs an approximation or not.
        Returns true if the approximation is not needed.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepFill.BRepFill_MultiLine_IsParticularCase(self, *args)


    def Continuity(self, *args):
        """
        Continuity(BRepFill_MultiLine self) -> GeomAbs_Shape

        Returns   the continuity  betwwen  the two  faces
        seShape         from GeomAbsparated by myBis.

        :rtype: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _BRepFill.BRepFill_MultiLine_Continuity(self, *args)


    def Curves(self, *args):
        """
        Curves(BRepFill_MultiLine self, Handle_Geom_Curve Curve, Handle_Geom2d_Curve PCurve1, Handle_Geom2d_Curve PCurve2)

        raises if IsParticularCase is <False>.

        :type Curve: OCC.wrapper.Geom.Handle_Geom_Curve
        :type PCurve1: OCC.wrapper.Geom2d.Handle_Geom2d_Curve
        :type PCurve2: OCC.wrapper.Geom2d.Handle_Geom2d_Curve

        """
        return _BRepFill.BRepFill_MultiLine_Curves(self, *args)


    def FirstParameter(self, *args):
        """
        FirstParameter(BRepFill_MultiLine self) -> Standard_Real

        returns the first parameter of the Bissectrice.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _BRepFill.BRepFill_MultiLine_FirstParameter(self, *args)


    def LastParameter(self, *args):
        """
        LastParameter(BRepFill_MultiLine self) -> Standard_Real

        returns the last parameter of the Bissectrice.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _BRepFill.BRepFill_MultiLine_LastParameter(self, *args)


    def ValueOnF1(self, *args):
        """
        ValueOnF1(BRepFill_MultiLine self, Standard_Real const U) -> gp_Pnt2d

        returns the current point on the PCurve of the
        first face

        :type U: float
        :rtype: OCC.wrapper.gp.gp_Pnt2d

        """
        return _BRepFill.BRepFill_MultiLine_ValueOnF1(self, *args)


    def ValueOnF2(self, *args):
        """
        ValueOnF2(BRepFill_MultiLine self, Standard_Real const U) -> gp_Pnt2d

        returns the current point on the PCurve of the
        first face

        :type U: float
        :rtype: OCC.wrapper.gp.gp_Pnt2d

        """
        return _BRepFill.BRepFill_MultiLine_ValueOnF2(self, *args)


    def Value3dOnF1OnF2(self, *args):
        """
        Value3dOnF1OnF2(BRepFill_MultiLine self, Standard_Real const U, gp_Pnt P3d, gp_Pnt2d PF1, gp_Pnt2d PF2)

        :type U: float
        :type P3d: OCC.wrapper.gp.gp_Pnt
        :type PF1: OCC.wrapper.gp.gp_Pnt2d
        :type PF2: OCC.wrapper.gp.gp_Pnt2d

        """
        return _BRepFill.BRepFill_MultiLine_Value3dOnF1OnF2(self, *args)


    def Value(self, *args):
        """
        Value(BRepFill_MultiLine self, Standard_Real const U) -> gp_Pnt
        Value(BRepFill_MultiLine self, Standard_Real const theU, NCollection_Array1_gp_Pnt2d thePnt2d, NCollection_Array1_gp_Pnt thePnt) -> Standard_Boolean

        Returns the point at parameter <theU>.

        :type theU: float
        :type thePnt2d: OCC.wrapper.TColgp.NCollection_Array1_gp_Pnt2d
        :type thePnt: OCC.wrapper.TColgp.NCollection_Array1_gp_Pnt
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepFill.BRepFill_MultiLine_Value(self, *args)


    def D1(self, *args):
        """
        D1(BRepFill_MultiLine self, Standard_Real const theU, NCollection_Array1_gp_Vec2d theVec2d, NCollection_Array1_gp_Vec theVec) -> Standard_Boolean

        Returns the derivative at parameter <theU>.

        :type theU: float
        :type theVec2d: OCC.wrapper.TColgp.NCollection_Array1_gp_Vec2d
        :type theVec: OCC.wrapper.TColgp.NCollection_Array1_gp_Vec
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepFill.BRepFill_MultiLine_D1(self, *args)

    __swig_destroy__ = _BRepFill.delete_BRepFill_MultiLine
BRepFill_MultiLine_swigregister = _BRepFill.BRepFill_MultiLine_swigregister
BRepFill_MultiLine_swigregister(BRepFill_MultiLine)

class Handle_BRepFill_ShapeLaw(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_BRepFill_ShapeLaw self)

        Nullify the handle


        """
        return _BRepFill.Handle_BRepFill_ShapeLaw_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_BRepFill_ShapeLaw self) -> bool

        Check for being null

        :rtype: bool

        """
        return _BRepFill.Handle_BRepFill_ShapeLaw_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_BRepFill_ShapeLaw self, BRepFill_ShapeLaw thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _BRepFill.Handle_BRepFill_ShapeLaw_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_BRepFill_ShapeLaw self, Handle_BRepFill_ShapeLaw theHandle) -> Handle_BRepFill_ShapeLaw
        assign(Handle_BRepFill_ShapeLaw self, BRepFill_ShapeLaw thePtr) -> Handle_BRepFill_ShapeLaw
        assign(Handle_BRepFill_ShapeLaw self, Handle_BRepFill_ShapeLaw theHandle) -> Handle_BRepFill_ShapeLaw

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _BRepFill.Handle_BRepFill_ShapeLaw_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_BRepFill_ShapeLaw self) -> BRepFill_ShapeLaw

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _BRepFill.Handle_BRepFill_ShapeLaw_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_BRepFill_ShapeLaw self) -> BRepFill_ShapeLaw

        Member access operator (note non-const)

        :rtype: T *

        """
        return _BRepFill.Handle_BRepFill_ShapeLaw___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_BRepFill_ShapeLaw self) -> BRepFill_ShapeLaw

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _BRepFill.Handle_BRepFill_ShapeLaw___ref__(self, *args)


    def __hash__(self):
        return _BRepFill.Handle_BRepFill_ShapeLaw___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _BRepFill.Handle_BRepFill_ShapeLaw___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _BRepFill.new_Handle_BRepFill_ShapeLaw(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_BRepFill.Handle_BRepFill_ShapeLaw_DownCast)
    __swig_destroy__ = _BRepFill.delete_Handle_BRepFill_ShapeLaw

    def IsVertex(self, *args):
        """
        IsVertex(Handle_BRepFill_ShapeLaw self) -> Standard_Boolean

        Say if the input shape is a  vertex.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepFill.Handle_BRepFill_ShapeLaw_IsVertex(self, *args)


    def IsConstant(self, *args):
        """
        IsConstant(Handle_BRepFill_ShapeLaw self) -> Standard_Boolean

        Say if the Law is  Constant.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepFill.Handle_BRepFill_ShapeLaw_IsConstant(self, *args)


    def ConcatenedLaw(self, *args):
        """
        ConcatenedLaw(Handle_BRepFill_ShapeLaw self) -> Handle_GeomFill_SectionLaw

        Give the law build on a concaneted section

        :rtype: OCC.wrapper.GeomFill.Handle_GeomFill_SectionLaw

        """
        return _BRepFill.Handle_BRepFill_ShapeLaw_ConcatenedLaw(self, *args)


    def Continuity(self, *args):
        """
        Continuity(Handle_BRepFill_ShapeLaw self, Standard_Integer const Index, Standard_Real const TolAngular) -> GeomAbs_Shape

        :type Index: int
        :type TolAngular: float
        :rtype: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _BRepFill.Handle_BRepFill_ShapeLaw_Continuity(self, *args)


    def VertexTol(self, *args):
        """
        VertexTol(Handle_BRepFill_ShapeLaw self, Standard_Integer const Index, Standard_Real const Param) -> Standard_Real

        :type Index: int
        :type Param: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _BRepFill.Handle_BRepFill_ShapeLaw_VertexTol(self, *args)


    def Vertex(self, *args):
        """
        Vertex(Handle_BRepFill_ShapeLaw self, Standard_Integer const Index, Standard_Real const Param) -> TopoDS_Vertex

        :type Index: int
        :type Param: float
        :rtype: OCC.wrapper.TopoDS.TopoDS_Vertex

        """
        return _BRepFill.Handle_BRepFill_ShapeLaw_Vertex(self, *args)


    def D0(self, *args):
        """
        D0(Handle_BRepFill_ShapeLaw self, Standard_Real const Param, TopoDS_Shape S)

        :type Param: float
        :type S: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _BRepFill.Handle_BRepFill_ShapeLaw_D0(self, *args)


    def Edge(self, *args):
        """
        :type Index: int
        :rtype: OCC.wrapper.TopoDS.TopoDS_Edge

        """
        res = _BRepFill.Handle_BRepFill_ShapeLaw_Edge(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def get_type_name(self, *args):
        """
        get_type_name(Handle_BRepFill_ShapeLaw self) -> char const *

        :rtype: const char *

        """
        return _BRepFill.Handle_BRepFill_ShapeLaw_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _BRepFill.Handle_BRepFill_ShapeLaw_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _BRepFill.Handle_BRepFill_ShapeLaw_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def NbLaw(self, *args):
        """
        NbLaw(Handle_BRepFill_ShapeLaw self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepFill.Handle_BRepFill_ShapeLaw_NbLaw(self, *args)


    def Law(self, *args):
        """
        :type Index: int
        :rtype: OCC.wrapper.GeomFill.Handle_GeomFill_SectionLaw

        """
        res = _BRepFill.Handle_BRepFill_ShapeLaw_Law_(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def IndexOfEdge(self, *args):
        """
        IndexOfEdge(Handle_BRepFill_ShapeLaw self, TopoDS_Shape anEdge) -> Standard_Integer

        :type anEdge: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepFill.Handle_BRepFill_ShapeLaw_IndexOfEdge(self, *args)


    def IsUClosed(self, *args):
        """
        IsUClosed(Handle_BRepFill_ShapeLaw self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepFill.Handle_BRepFill_ShapeLaw_IsUClosed(self, *args)


    def IsVClosed(self, *args):
        """
        IsVClosed(Handle_BRepFill_ShapeLaw self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepFill.Handle_BRepFill_ShapeLaw_IsVClosed(self, *args)


    def IsDone(self, *args):
        """
        IsDone(Handle_BRepFill_ShapeLaw self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepFill.Handle_BRepFill_ShapeLaw_IsDone(self, *args)


    def CurrentEdge(self, *args):
        """
        CurrentEdge(Handle_BRepFill_ShapeLaw self) -> TopoDS_Edge

        :rtype: OCC.wrapper.TopoDS.TopoDS_Edge

        """
        return _BRepFill.Handle_BRepFill_ShapeLaw_CurrentEdge(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_BRepFill_ShapeLaw self)

        Memory deallocator for transient classes


        """
        return _BRepFill.Handle_BRepFill_ShapeLaw_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_BRepFill_ShapeLaw self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_BRepFill_ShapeLaw self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepFill.Handle_BRepFill_ShapeLaw_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_BRepFill_ShapeLaw self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_BRepFill_ShapeLaw self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepFill.Handle_BRepFill_ShapeLaw_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_BRepFill_ShapeLaw self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _BRepFill.Handle_BRepFill_ShapeLaw_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_BRepFill_ShapeLaw self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepFill.Handle_BRepFill_ShapeLaw_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_BRepFill_ShapeLaw self)

        Increments the reference counter of this object


        """
        return _BRepFill.Handle_BRepFill_ShapeLaw_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_BRepFill_ShapeLaw self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepFill.Handle_BRepFill_ShapeLaw_DecrementRefCounter(self, *args)

Handle_BRepFill_ShapeLaw_swigregister = _BRepFill.Handle_BRepFill_ShapeLaw_swigregister
Handle_BRepFill_ShapeLaw_swigregister(Handle_BRepFill_ShapeLaw)

def Handle_BRepFill_ShapeLaw_DownCast(thing):
    return _BRepFill.Handle_BRepFill_ShapeLaw_DownCast(thing)
Handle_BRepFill_ShapeLaw_DownCast = _BRepFill.Handle_BRepFill_ShapeLaw_DownCast

class BRepFill_TrimShellCorner(object):
    """Trims sets of faces in the corner to make proper parts of pipe"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BRepFill_TrimShellCorner self, Handle_TopTools_HArray2OfShape theFaces, BRepFill_TransitionStyle const theTransition, gp_Ax2 theAxeOfBisPlane) -> BRepFill_TrimShellCorner

        Constructor: takes faces to intersect,
        type of transition (it can be RightCorner or RoundCorner)
        and axis of bisector plane

        :type theFaces: OCC.wrapper.TopTools.Handle_TopTools_HArray2OfShape
        :type theTransition: OCC.wrapper.BRepFill.BRepFill_TransitionStyle
        :type theAxeOfBisPlane: OCC.wrapper.gp.gp_Ax2

        """
        this = _BRepFill.new_BRepFill_TrimShellCorner(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def AddBounds(self, *args):
        """
        AddBounds(BRepFill_TrimShellCorner self, Handle_TopTools_HArray2OfShape Bounds)

        :type Bounds: OCC.wrapper.TopTools.Handle_TopTools_HArray2OfShape

        """
        return _BRepFill.BRepFill_TrimShellCorner_AddBounds(self, *args)


    def AddUEdges(self, *args):
        """
        AddUEdges(BRepFill_TrimShellCorner self, Handle_TopTools_HArray2OfShape theUEdges)

        :type theUEdges: OCC.wrapper.TopTools.Handle_TopTools_HArray2OfShape

        """
        return _BRepFill.BRepFill_TrimShellCorner_AddUEdges(self, *args)


    def AddVEdges(self, *args):
        """
        AddVEdges(BRepFill_TrimShellCorner self, Handle_TopTools_HArray2OfShape theVEdges, Standard_Integer const theIndex)

        :type theVEdges: OCC.wrapper.TopTools.Handle_TopTools_HArray2OfShape
        :type theIndex: int

        """
        return _BRepFill.BRepFill_TrimShellCorner_AddVEdges(self, *args)


    def Perform(self, *args):
        """Perform(BRepFill_TrimShellCorner self)"""
        return _BRepFill.BRepFill_TrimShellCorner_Perform(self, *args)


    def IsDone(self, *args):
        """
        IsDone(BRepFill_TrimShellCorner self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepFill.BRepFill_TrimShellCorner_IsDone(self, *args)


    def HasSection(self, *args):
        """
        HasSection(BRepFill_TrimShellCorner self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepFill.BRepFill_TrimShellCorner_HasSection(self, *args)


    def Modified(self, *args):
        """
        Modified(BRepFill_TrimShellCorner self, TopoDS_Shape S, NCollection_List_TopoDS_Shape theModified)

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :type theModified: OCC.wrapper.TopTools.TopTools_ListOfShape

        """
        return _BRepFill.BRepFill_TrimShellCorner_Modified(self, *args)

    __swig_destroy__ = _BRepFill.delete_BRepFill_TrimShellCorner
BRepFill_TrimShellCorner_swigregister = _BRepFill.BRepFill_TrimShellCorner_swigregister
BRepFill_TrimShellCorner_swigregister(BRepFill_TrimShellCorner)

class Handle_BRepFill_DraftLaw(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_BRepFill_DraftLaw self)

        Nullify the handle


        """
        return _BRepFill.Handle_BRepFill_DraftLaw_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_BRepFill_DraftLaw self) -> bool

        Check for being null

        :rtype: bool

        """
        return _BRepFill.Handle_BRepFill_DraftLaw_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_BRepFill_DraftLaw self, BRepFill_DraftLaw thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _BRepFill.Handle_BRepFill_DraftLaw_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_BRepFill_DraftLaw self, Handle_BRepFill_DraftLaw theHandle) -> Handle_BRepFill_DraftLaw
        assign(Handle_BRepFill_DraftLaw self, BRepFill_DraftLaw thePtr) -> Handle_BRepFill_DraftLaw
        assign(Handle_BRepFill_DraftLaw self, Handle_BRepFill_DraftLaw theHandle) -> Handle_BRepFill_DraftLaw

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _BRepFill.Handle_BRepFill_DraftLaw_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_BRepFill_DraftLaw self) -> BRepFill_DraftLaw

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _BRepFill.Handle_BRepFill_DraftLaw_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_BRepFill_DraftLaw self) -> BRepFill_DraftLaw

        Member access operator (note non-const)

        :rtype: T *

        """
        return _BRepFill.Handle_BRepFill_DraftLaw___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_BRepFill_DraftLaw self) -> BRepFill_DraftLaw

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _BRepFill.Handle_BRepFill_DraftLaw___ref__(self, *args)


    def __hash__(self):
        return _BRepFill.Handle_BRepFill_DraftLaw___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _BRepFill.Handle_BRepFill_DraftLaw___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _BRepFill.new_Handle_BRepFill_DraftLaw(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_BRepFill.Handle_BRepFill_DraftLaw_DownCast)
    __swig_destroy__ = _BRepFill.delete_Handle_BRepFill_DraftLaw

    def CleanLaw(self, *args):
        """
        CleanLaw(Handle_BRepFill_DraftLaw self, Standard_Real const TolAngular)

        To clean the little discontinuities.

        :type TolAngular: float

        """
        return _BRepFill.Handle_BRepFill_DraftLaw_CleanLaw(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_BRepFill_DraftLaw self) -> char const *

        :rtype: const char *

        """
        return _BRepFill.Handle_BRepFill_DraftLaw_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _BRepFill.Handle_BRepFill_DraftLaw_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _BRepFill.Handle_BRepFill_DraftLaw_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def GetStatus(self, *args):
        """
        GetStatus(Handle_BRepFill_DraftLaw self) -> GeomFill_PipeError

        Return a error status, if the  status is not PipeOk then
        it exist a parameter tlike the law is not valuable for t.

        :rtype: OCC.wrapper.GeomFill.GeomFill_PipeError

        """
        return _BRepFill.Handle_BRepFill_DraftLaw_GetStatus(self, *args)


    def TransformInG0Law(self, *args):
        """
        TransformInG0Law(Handle_BRepFill_DraftLaw self)

        Apply a linear   transformation  on each law, to  have
        continuity of the global law beetween the edges.


        """
        return _BRepFill.Handle_BRepFill_DraftLaw_TransformInG0Law(self, *args)


    def TransformInCompatibleLaw(self, *args):
        """
        TransformInCompatibleLaw(Handle_BRepFill_DraftLaw self, Standard_Real const AngularTolerance)

        Apply a linear transformation on each law, to reduce
        the   dicontinuities  of law at one  rotation.

        :type AngularTolerance: float

        """
        return _BRepFill.Handle_BRepFill_DraftLaw_TransformInCompatibleLaw(self, *args)


    def DeleteTransform(self, *args):
        """DeleteTransform(Handle_BRepFill_DraftLaw self)"""
        return _BRepFill.Handle_BRepFill_DraftLaw_DeleteTransform(self, *args)


    def NbHoles(self, *args):
        """
        NbHoles(Handle_BRepFill_DraftLaw self, Standard_Real const Tol=1.0e-7) -> Standard_Integer

        :type Tol: float
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepFill.Handle_BRepFill_DraftLaw_NbHoles(self, *args)


    def Holes(self, *args):
        """
        Holes(Handle_BRepFill_DraftLaw self, NCollection_Array1_Standard_Integer Interval)

        :type Interval: OCC.wrapper.TColStd.TColStd_Array1OfInteger

        """
        return _BRepFill.Handle_BRepFill_DraftLaw_Holes(self, *args)


    def NbLaw(self, *args):
        """
        NbLaw(Handle_BRepFill_DraftLaw self) -> Standard_Integer

        Return the number of elementary Law

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepFill.Handle_BRepFill_DraftLaw_NbLaw(self, *args)


    def Law(self, *args):
        """
        Return the elementary Law of rank <Index>
        <Index> have to be in [1, NbLaw()]

        :type Index: int
        :rtype: OCC.wrapper.GeomFill.Handle_GeomFill_LocationLaw

        """
        res = _BRepFill.Handle_BRepFill_DraftLaw_Law_(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Wire(self, *args):
        """
        return the path

        :rtype: OCC.wrapper.TopoDS.TopoDS_Wire

        """
        res = _BRepFill.Handle_BRepFill_DraftLaw_Wire(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Edge(self, *args):
        """
        Return the Edge of rank <Index> in the path
        <Index> have to be in [1, NbLaw()]

        :type Index: int
        :rtype: OCC.wrapper.TopoDS.TopoDS_Edge

        """
        res = _BRepFill.Handle_BRepFill_DraftLaw_Edge(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Vertex(self, *args):
        """
        Vertex(Handle_BRepFill_DraftLaw self, Standard_Integer const Index) -> TopoDS_Vertex

        Return the vertex of rank <Index> in the path
        <Index> have to be in [0, NbLaw()]

        :type Index: int
        :rtype: OCC.wrapper.TopoDS.TopoDS_Vertex

        """
        return _BRepFill.Handle_BRepFill_DraftLaw_Vertex(self, *args)


    def PerformVertex(self, *args):
        """
        PerformVertex(Handle_BRepFill_DraftLaw self, Standard_Integer const Index, TopoDS_Vertex InputVertex, Standard_Real const TolMin, TopoDS_Vertex OutputVertex, Standard_Integer const Location=0)

        Compute <OutputVertex> like a transformation of
        <InputVertex>  the  transformation   is given by
        evaluation of the location law   in the vertex of
        rank   <Index>.
        <Location> is used to manage discontinuities :
        - -1 : The law before the vertex is used.
        -  1 : The law after the vertex is used.
        -  0 : Average of the both laws is used.

        :type Index: int
        :type InputVertex: OCC.wrapper.TopoDS.TopoDS_Vertex
        :type TolMin: float
        :type OutputVertex: OCC.wrapper.TopoDS.TopoDS_Vertex
        :type Location: int

        """
        return _BRepFill.Handle_BRepFill_DraftLaw_PerformVertex(self, *args)


    def CurvilinearBounds(self, *args):
        """
        CurvilinearBounds(Handle_BRepFill_DraftLaw self, Standard_Integer const Index)

        Return the Curvilinear Bounds of the <Index> Law

        :type Index: int
        :type First: float
        :type Last: float

        """
        return _BRepFill.Handle_BRepFill_DraftLaw_CurvilinearBounds(self, *args)


    def IsClosed(self, *args):
        """
        IsClosed(Handle_BRepFill_DraftLaw self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepFill.Handle_BRepFill_DraftLaw_IsClosed(self, *args)


    def IsG1(self, *args):
        """
        IsG1(Handle_BRepFill_DraftLaw self, Standard_Integer const Index, Standard_Real const SpatialTolerance=1.0e-7, Standard_Real const AngularTolerance=1.0e-4) -> Standard_Integer

        Compute the Law's continuity beetween 2 edges of the path
        The result can be :
        -1 : Case Not connex
        0  : It is connex (G0)
        1  : It is tangent (G1)

        :type Index: int
        :type SpatialTolerance: float
        :type AngularTolerance: float
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepFill.Handle_BRepFill_DraftLaw_IsG1(self, *args)


    def D0(self, *args):
        """
        D0(Handle_BRepFill_DraftLaw self, Standard_Real const Abscissa, TopoDS_Shape Section)

        Apply the Law to a shape, for a given Curnilinear abscissa

        :type Abscissa: float
        :type Section: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _BRepFill.Handle_BRepFill_DraftLaw_D0(self, *args)


    def Parameter(self, *args):
        """
        Parameter(Handle_BRepFill_DraftLaw self, Standard_Real const Abscissa)

        Find the  index Law  and the  parmaeter, for  a given
        Curnilinear abscissa

        :type Abscissa: float
        :type Index: int
        :type Param: float

        """
        return _BRepFill.Handle_BRepFill_DraftLaw_Parameter(self, *args)


    def Abscissa(self, *args):
        """
        Abscissa(Handle_BRepFill_DraftLaw self, Standard_Integer const Index, Standard_Real const Param) -> Standard_Real

        Return the curvilinear abscissa  corresponding to a point
        of  the path, defined by  <Index>  of  Edge and a
        parameter on the edge.

        :type Index: int
        :type Param: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _BRepFill.Handle_BRepFill_DraftLaw_Abscissa(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_BRepFill_DraftLaw self)

        Memory deallocator for transient classes


        """
        return _BRepFill.Handle_BRepFill_DraftLaw_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_BRepFill_DraftLaw self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_BRepFill_DraftLaw self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepFill.Handle_BRepFill_DraftLaw_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_BRepFill_DraftLaw self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_BRepFill_DraftLaw self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepFill.Handle_BRepFill_DraftLaw_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_BRepFill_DraftLaw self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _BRepFill.Handle_BRepFill_DraftLaw_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_BRepFill_DraftLaw self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepFill.Handle_BRepFill_DraftLaw_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_BRepFill_DraftLaw self)

        Increments the reference counter of this object


        """
        return _BRepFill.Handle_BRepFill_DraftLaw_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_BRepFill_DraftLaw self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepFill.Handle_BRepFill_DraftLaw_DecrementRefCounter(self, *args)

Handle_BRepFill_DraftLaw_swigregister = _BRepFill.Handle_BRepFill_DraftLaw_swigregister
Handle_BRepFill_DraftLaw_swigregister(Handle_BRepFill_DraftLaw)

def Handle_BRepFill_DraftLaw_DownCast(thing):
    return _BRepFill.Handle_BRepFill_DraftLaw_DownCast(thing)
Handle_BRepFill_DraftLaw_DownCast = _BRepFill.Handle_BRepFill_DraftLaw_DownCast

class BRepFill_TrimEdgeTool(object):
    """Geometric Tool using to construct Offset Wires."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BRepFill_TrimEdgeTool self) -> BRepFill_TrimEdgeTool
        __init__(BRepFill_TrimEdgeTool self, Bisector_Bisec Bisec, Handle_Geom2d_Geometry S1, Handle_Geom2d_Geometry S2, Standard_Real const Offset) -> BRepFill_TrimEdgeTool

        :type Bisec: OCC.wrapper.Bisector.Bisector_Bisec
        :type S1: OCC.wrapper.Geom2d.Handle_Geom2d_Geometry
        :type S2: OCC.wrapper.Geom2d.Handle_Geom2d_Geometry
        :type Offset: float

        """
        this = _BRepFill.new_BRepFill_TrimEdgeTool(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def IntersectWith(self, *args):
        """
        IntersectWith(BRepFill_TrimEdgeTool self, TopoDS_Edge Edge1, TopoDS_Edge Edge2, TopoDS_Shape InitShape1, TopoDS_Shape InitShape2, TopoDS_Vertex End1, TopoDS_Vertex End2, GeomAbs_JoinType const theJoinType, Standard_Boolean const IsOpenResult, NCollection_Sequence_gp_Pnt Params)

        :type Edge1: OCC.wrapper.TopoDS.TopoDS_Edge
        :type Edge2: OCC.wrapper.TopoDS.TopoDS_Edge
        :type InitShape1: OCC.wrapper.TopoDS.TopoDS_Shape
        :type InitShape2: OCC.wrapper.TopoDS.TopoDS_Shape
        :type End1: OCC.wrapper.TopoDS.TopoDS_Vertex
        :type End2: OCC.wrapper.TopoDS.TopoDS_Vertex
        :type theJoinType: OCC.wrapper.GeomAbs.GeomAbs_JoinType
        :type IsOpenResult: bool
        :type Params: OCC.wrapper.TColgp.TColgp_SequenceOfPnt

        """
        return _BRepFill.BRepFill_TrimEdgeTool_IntersectWith(self, *args)


    def AddOrConfuse(self, *args):
        """
        AddOrConfuse(BRepFill_TrimEdgeTool self, Standard_Boolean const Start, TopoDS_Edge Edge1, TopoDS_Edge Edge2, NCollection_Sequence_gp_Pnt Params)

        :type Start: bool
        :type Edge1: OCC.wrapper.TopoDS.TopoDS_Edge
        :type Edge2: OCC.wrapper.TopoDS.TopoDS_Edge
        :type Params: OCC.wrapper.TColgp.TColgp_SequenceOfPnt

        """
        return _BRepFill.BRepFill_TrimEdgeTool_AddOrConfuse(self, *args)


    def IsInside(self, *args):
        """
        IsInside(BRepFill_TrimEdgeTool self, gp_Pnt2d P) -> Standard_Boolean

        :type P: OCC.wrapper.gp.gp_Pnt2d
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepFill.BRepFill_TrimEdgeTool_IsInside(self, *args)

    __swig_destroy__ = _BRepFill.delete_BRepFill_TrimEdgeTool
BRepFill_TrimEdgeTool_swigregister = _BRepFill.BRepFill_TrimEdgeTool_swigregister
BRepFill_TrimEdgeTool_swigregister(BRepFill_TrimEdgeTool)

class BRepFill_Evolved(object):
    """
    Constructs an evolved volume from a spine (wire or face)
    and  a profile ( wire).
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BRepFill_Evolved self) -> BRepFill_Evolved
        __init__(BRepFill_Evolved self, TopoDS_Wire Spine, TopoDS_Wire Profile, gp_Ax3 AxeProf, GeomAbs_JoinType const Join=GeomAbs_Arc, Standard_Boolean const Solid) -> BRepFill_Evolved
        __init__(BRepFill_Evolved self, TopoDS_Face Spine, TopoDS_Wire Profile, gp_Ax3 AxeProf, GeomAbs_JoinType const Join=GeomAbs_Arc, Standard_Boolean const Solid) -> BRepFill_Evolved

        Creates an  evolved shape  by sweeping the <Profile>
        along the <Spine>

        :type Spine: OCC.wrapper.TopoDS.TopoDS_Face
        :type Profile: OCC.wrapper.TopoDS.TopoDS_Wire
        :type AxeProf: OCC.wrapper.gp.gp_Ax3
        :type Join: OCC.wrapper.GeomAbs.GeomAbs_JoinType
        :type Solid: bool

        """
        this = _BRepFill.new_BRepFill_Evolved(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Perform(self, *args):
        """
        Perform(BRepFill_Evolved self, TopoDS_Wire Spine, TopoDS_Wire Profile, gp_Ax3 AxeProf, GeomAbs_JoinType const Join=GeomAbs_Arc, Standard_Boolean const Solid)
        Perform(BRepFill_Evolved self, TopoDS_Face Spine, TopoDS_Wire Profile, gp_Ax3 AxeProf, GeomAbs_JoinType const Join=GeomAbs_Arc, Standard_Boolean const Solid)

        Performs an  evolved shape  by sweeping the <Profile>
        along the <Spine>

        :type Spine: OCC.wrapper.TopoDS.TopoDS_Face
        :type Profile: OCC.wrapper.TopoDS.TopoDS_Wire
        :type AxeProf: OCC.wrapper.gp.gp_Ax3
        :type Join: OCC.wrapper.GeomAbs.GeomAbs_JoinType
        :type Solid: bool

        """
        return _BRepFill.BRepFill_Evolved_Perform(self, *args)


    def IsDone(self, *args):
        """
        IsDone(BRepFill_Evolved self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepFill.BRepFill_Evolved_IsDone(self, *args)


    def Shape(self, *args):
        """
        returns the generated shape.

        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _BRepFill.BRepFill_Evolved_Shape(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def GeneratedShapes(self, *args):
        """
        Returns   the  shapes  created  from   a  subshape
        <SpineShape>  of     the  spine   and   a subshape
        <ProfShape> on the profile.

        :type SpineShape: OCC.wrapper.TopoDS.TopoDS_Shape
        :type ProfShape: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.TopTools.TopTools_ListOfShape

        """
        res = _BRepFill.BRepFill_Evolved_GeneratedShapes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def JoinType(self, *args):
        """
        JoinType(BRepFill_Evolved self) -> GeomAbs_JoinType

        :rtype: OCC.wrapper.GeomAbs.GeomAbs_JoinType

        """
        return _BRepFill.BRepFill_Evolved_JoinType(self, *args)


    def Top(self, *args):
        """
        Return the face Top if <Solid> is True in the constructor.

        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _BRepFill.BRepFill_Evolved_Top(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Bottom(self, *args):
        """
        Return the face Bottom  if <Solid> is True in the constructor.

        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _BRepFill.BRepFill_Evolved_Bottom(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _BRepFill.delete_BRepFill_Evolved
BRepFill_Evolved_swigregister = _BRepFill.BRepFill_Evolved_swigregister
BRepFill_Evolved_swigregister(BRepFill_Evolved)

class NCollection_DataMap_TopoDS_Shape_TColStd_SequenceOfReal_TopTools_ShapeMapHasher(NCollection.NCollection_BaseMap):
    """
    Purpose:     The DataMap is a Map to store keys with associated
    Items. See Map  from NCollection for  a discussion
    about the number of buckets.

    The DataMap can be seen as an extended array where
    the Keys  are the   indices.  For this reason  the
    operator () is defined on DataMap to fetch an Item
    from a Key. So the following syntax can be used :

    anItem = aMap(aKey);
    aMap(aKey) = anItem;

    This analogy has its  limit.   aMap(aKey) = anItem
    can  be done only  if aKey was previously bound to
    an item in the map.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_DataMap_TopoDS_Shape_TColStd_SequenceOfReal_TopTools_ShapeMapHasher self) -> NCollection_DataMap< TopoDS_Shape,TColStd_SequenceOfReal,TopTools_ShapeMapHasher >::iterator

        Returns an iterator pointing to the first element in the map.

        :rtype: iterator

        """
        return _BRepFill.NCollection_DataMap_TopoDS_Shape_TColStd_SequenceOfReal_TopTools_ShapeMapHasher_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_DataMap_TopoDS_Shape_TColStd_SequenceOfReal_TopTools_ShapeMapHasher self) -> NCollection_DataMap< TopoDS_Shape,TColStd_SequenceOfReal,TopTools_ShapeMapHasher >::iterator

        Returns an iterator referring to the past-the-end element in the map.

        :rtype: iterator

        """
        return _BRepFill.NCollection_DataMap_TopoDS_Shape_TColStd_SequenceOfReal_TopTools_ShapeMapHasher_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_DataMap_TopoDS_Shape_TColStd_SequenceOfReal_TopTools_ShapeMapHasher self) -> NCollection_DataMap< TopoDS_Shape,TColStd_SequenceOfReal,TopTools_ShapeMapHasher >::const_iterator

        Returns a const iterator pointing to the first element in the map.

        :rtype: const_iterator

        """
        return _BRepFill.NCollection_DataMap_TopoDS_Shape_TColStd_SequenceOfReal_TopTools_ShapeMapHasher_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_DataMap_TopoDS_Shape_TColStd_SequenceOfReal_TopTools_ShapeMapHasher self) -> NCollection_DataMap< TopoDS_Shape,TColStd_SequenceOfReal,TopTools_ShapeMapHasher >::const_iterator

        Returns a const iterator referring to the past-the-end element in the map.

        :rtype: const_iterator

        """
        return _BRepFill.NCollection_DataMap_TopoDS_Shape_TColStd_SequenceOfReal_TopTools_ShapeMapHasher_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     The DataMap is a Map to store keys with associated
        Items. See Map  from NCollection for  a discussion
        about the number of buckets.

        The DataMap can be seen as an extended array where
        the Keys  are the   indices.  For this reason  the
        operator () is defined on DataMap to fetch an Item
        from a Key. So the following syntax can be used :

        anItem = aMap(aKey);
        aMap(aKey) = anItem;

        This analogy has its  limit.   aMap(aKey) = anItem
        can  be done only  if aKey was previously bound to
        an item in the map.
        """
        this = _BRepFill.new_NCollection_DataMap_TopoDS_Shape_TColStd_SequenceOfReal_TopTools_ShapeMapHasher(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Exchange(self, *args):
        """
        Exchange(NCollection_DataMap_TopoDS_Shape_TColStd_SequenceOfReal_TopTools_ShapeMapHasher self, NCollection_DataMap_TopoDS_Shape_TColStd_SequenceOfReal_TopTools_ShapeMapHasher theOther)

        Exchange the content of two maps without re-allocations.
        Notice that allocators will be swapped as well!

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _BRepFill.NCollection_DataMap_TopoDS_Shape_TColStd_SequenceOfReal_TopTools_ShapeMapHasher_Exchange(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_DataMap_TopoDS_Shape_TColStd_SequenceOfReal_TopTools_ShapeMapHasher self, NCollection_DataMap_TopoDS_Shape_TColStd_SequenceOfReal_TopTools_ShapeMapHasher theOther) -> NCollection_DataMap_TopoDS_Shape_TColStd_SequenceOfReal_TopTools_ShapeMapHasher

        Assignment.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _BRepFill.NCollection_DataMap_TopoDS_Shape_TColStd_SequenceOfReal_TopTools_ShapeMapHasher_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_DataMap_TopoDS_Shape_TColStd_SequenceOfReal_TopTools_ShapeMapHasher self, NCollection_DataMap_TopoDS_Shape_TColStd_SequenceOfReal_TopTools_ShapeMapHasher theOther) -> NCollection_DataMap_TopoDS_Shape_TColStd_SequenceOfReal_TopTools_ShapeMapHasher

        Assignment operator

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _BRepFill.NCollection_DataMap_TopoDS_Shape_TColStd_SequenceOfReal_TopTools_ShapeMapHasher_assign(self, *args)


    def ReSize(self, *args):
        """
        ReSize(NCollection_DataMap_TopoDS_Shape_TColStd_SequenceOfReal_TopTools_ShapeMapHasher self, Standard_Integer const N)

        ReSize

        :type N: int

        """
        return _BRepFill.NCollection_DataMap_TopoDS_Shape_TColStd_SequenceOfReal_TopTools_ShapeMapHasher_ReSize(self, *args)


    def Bind(self, *args):
        """
        Bind(NCollection_DataMap_TopoDS_Shape_TColStd_SequenceOfReal_TopTools_ShapeMapHasher self, TopoDS_Shape theKey, NCollection_Sequence_Standard_Real theItem) -> Standard_Boolean

        Bind binds Item to Key in map.
        @param theKey  key to add/update
        @param theItem new item; overrides value previously bound to the key, if any
        @return Standard_True if Key was not bound already

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepFill.NCollection_DataMap_TopoDS_Shape_TColStd_SequenceOfReal_TopTools_ShapeMapHasher_Bind(self, *args)


    def Bound(self, *args):
        """
        Bound(NCollection_DataMap_TopoDS_Shape_TColStd_SequenceOfReal_TopTools_ShapeMapHasher self, TopoDS_Shape theKey, NCollection_Sequence_Standard_Real theItem) -> NCollection_Sequence_Standard_Real

        Bound binds Item to Key in map. Returns modifiable Item 

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: TheItemType *

        """
        return _BRepFill.NCollection_DataMap_TopoDS_Shape_TColStd_SequenceOfReal_TopTools_ShapeMapHasher_Bound(self, *args)


    def IsBound(self, *args):
        """
        IsBound(NCollection_DataMap_TopoDS_Shape_TColStd_SequenceOfReal_TopTools_ShapeMapHasher self, TopoDS_Shape theKey) -> Standard_Boolean

        IsBound

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepFill.NCollection_DataMap_TopoDS_Shape_TColStd_SequenceOfReal_TopTools_ShapeMapHasher_IsBound(self, *args)


    def UnBind(self, *args):
        """
        UnBind(NCollection_DataMap_TopoDS_Shape_TColStd_SequenceOfReal_TopTools_ShapeMapHasher self, TopoDS_Shape theKey) -> Standard_Boolean

        UnBind removes Item Key pair from map

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepFill.NCollection_DataMap_TopoDS_Shape_TColStd_SequenceOfReal_TopTools_ShapeMapHasher_UnBind(self, *args)


    def Seek(self, *args):
        """
        Seek(NCollection_DataMap_TopoDS_Shape_TColStd_SequenceOfReal_TopTools_ShapeMapHasher self, TopoDS_Shape theKey) -> NCollection_Sequence_Standard_Real

        Seek returns pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: const TheItemType *

        """
        return _BRepFill.NCollection_DataMap_TopoDS_Shape_TColStd_SequenceOfReal_TopTools_ShapeMapHasher_Seek(self, *args)


    def Find(self, *args):
        """
        Find returns the Item for Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _BRepFill.NCollection_DataMap_TopoDS_Shape_TColStd_SequenceOfReal_TopTools_ShapeMapHasher_Find(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeSeek(self, *args):
        """
        ChangeSeek(NCollection_DataMap_TopoDS_Shape_TColStd_SequenceOfReal_TopTools_ShapeMapHasher self, TopoDS_Shape theKey) -> NCollection_Sequence_Standard_Real

        ChangeSeek returns modifiable pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: TheItemType *

        """
        return _BRepFill.NCollection_DataMap_TopoDS_Shape_TColStd_SequenceOfReal_TopTools_ShapeMapHasher_ChangeSeek(self, *args)


    def ChangeFind(self, *args):
        """
        ChangeFind(NCollection_DataMap_TopoDS_Shape_TColStd_SequenceOfReal_TopTools_ShapeMapHasher self, TopoDS_Shape theKey) -> NCollection_Sequence_Standard_Real

        ChangeFind returns mofifiable Item by Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: TheItemType &

        """
        return _BRepFill.NCollection_DataMap_TopoDS_Shape_TColStd_SequenceOfReal_TopTools_ShapeMapHasher_ChangeFind(self, *args)


    def __call__(self, *args):
        """
        operator ()

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _BRepFill.NCollection_DataMap_TopoDS_Shape_TColStd_SequenceOfReal_TopTools_ShapeMapHasher___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Clear(self, *args):
        """
        Clear(NCollection_DataMap_TopoDS_Shape_TColStd_SequenceOfReal_TopTools_ShapeMapHasher self, Standard_Boolean const doReleaseMemory)
        Clear(NCollection_DataMap_TopoDS_Shape_TColStd_SequenceOfReal_TopTools_ShapeMapHasher self, Handle_NCollection_BaseAllocator theAllocator)

        Clear data and reset allocator

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _BRepFill.NCollection_DataMap_TopoDS_Shape_TColStd_SequenceOfReal_TopTools_ShapeMapHasher_Clear(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_DataMap_TopoDS_Shape_TColStd_SequenceOfReal_TopTools_ShapeMapHasher self) -> Standard_Integer

        Size

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepFill.NCollection_DataMap_TopoDS_Shape_TColStd_SequenceOfReal_TopTools_ShapeMapHasher_Size(self, *args)


    def __iter__(self):
        return _BRepFill.NCollection_DataMap_TopoDS_Shape_TColStd_SequenceOfReal_TopTools_ShapeMapHasher___iter__(self)
    __swig_destroy__ = _BRepFill.delete_NCollection_DataMap_TopoDS_Shape_TColStd_SequenceOfReal_TopTools_ShapeMapHasher
NCollection_DataMap_TopoDS_Shape_TColStd_SequenceOfReal_TopTools_ShapeMapHasher_swigregister = _BRepFill.NCollection_DataMap_TopoDS_Shape_TColStd_SequenceOfReal_TopTools_ShapeMapHasher_swigregister
NCollection_DataMap_TopoDS_Shape_TColStd_SequenceOfReal_TopTools_ShapeMapHasher_swigregister(NCollection_DataMap_TopoDS_Shape_TColStd_SequenceOfReal_TopTools_ShapeMapHasher)

class NCollection_DataMap_TopoDS_Shape_TColStd_SequenceOfReal_TopTools_ShapeMapHasher_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _BRepFill.new_NCollection_DataMap_TopoDS_Shape_TColStd_SequenceOfReal_TopTools_ShapeMapHasher_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _BRepFill.delete_NCollection_DataMap_TopoDS_Shape_TColStd_SequenceOfReal_TopTools_ShapeMapHasher_IteratorHelper

    def __next__(self):
        return _BRepFill.NCollection_DataMap_TopoDS_Shape_TColStd_SequenceOfReal_TopTools_ShapeMapHasher_IteratorHelper___next__(self)
NCollection_DataMap_TopoDS_Shape_TColStd_SequenceOfReal_TopTools_ShapeMapHasher_IteratorHelper_swigregister = _BRepFill.NCollection_DataMap_TopoDS_Shape_TColStd_SequenceOfReal_TopTools_ShapeMapHasher_IteratorHelper_swigregister
NCollection_DataMap_TopoDS_Shape_TColStd_SequenceOfReal_TopTools_ShapeMapHasher_IteratorHelper_swigregister(NCollection_DataMap_TopoDS_Shape_TColStd_SequenceOfReal_TopTools_ShapeMapHasher_IteratorHelper)


try:
	BRepFill_DataMapOfShapeSequenceOfReal = NCollection_DataMap_TopoDS_Shape_TColStd_SequenceOfReal_TopTools_ShapeMapHasher
except NameError:
	pass # does not exist, probably ignored

class BRepFill_SectionPlacement(object):
    """Place a shape in a local axis coordinate"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BRepFill_SectionPlacement self, Handle_BRepFill_LocationLaw Law, TopoDS_Shape Section, Standard_Boolean const WithContact, Standard_Boolean const WithCorrection) -> BRepFill_SectionPlacement
        __init__(BRepFill_SectionPlacement self, Handle_BRepFill_LocationLaw Law, TopoDS_Shape Section, TopoDS_Shape Vertex, Standard_Boolean const WithContact, Standard_Boolean const WithCorrection) -> BRepFill_SectionPlacement

        Placement on vertex

        :type Law: OCC.wrapper.BRepFill.Handle_BRepFill_LocationLaw
        :type Section: OCC.wrapper.TopoDS.TopoDS_Shape
        :type Vertex: OCC.wrapper.TopoDS.TopoDS_Shape
        :type WithContact: bool
        :type WithCorrection: bool

        """
        this = _BRepFill.new_BRepFill_SectionPlacement(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Transformation(self, *args):
        """
        :rtype: OCC.wrapper.gp.gp_Trsf

        """
        res = _BRepFill.BRepFill_SectionPlacement_Transformation(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def AbscissaOnPath(self, *args):
        """
        AbscissaOnPath(BRepFill_SectionPlacement self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _BRepFill.BRepFill_SectionPlacement_AbscissaOnPath(self, *args)

    __swig_destroy__ = _BRepFill.delete_BRepFill_SectionPlacement
BRepFill_SectionPlacement_swigregister = _BRepFill.BRepFill_SectionPlacement_swigregister
BRepFill_SectionPlacement_swigregister(BRepFill_SectionPlacement)

class BRepFill_TrimSurfaceTool(object):
    """
    Compute the Pcurves and  the 3d curves resulting
    of the trimming of a face by an extruded surface.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BRepFill_TrimSurfaceTool self, Handle_Geom2d_Curve Bis, TopoDS_Face Face1, TopoDS_Face Face2, TopoDS_Edge Edge1, TopoDS_Edge Edge2, Standard_Boolean const Inv1, Standard_Boolean const Inv2) -> BRepFill_TrimSurfaceTool

        :type Bis: OCC.wrapper.Geom2d.Handle_Geom2d_Curve
        :type Face1: OCC.wrapper.TopoDS.TopoDS_Face
        :type Face2: OCC.wrapper.TopoDS.TopoDS_Face
        :type Edge1: OCC.wrapper.TopoDS.TopoDS_Edge
        :type Edge2: OCC.wrapper.TopoDS.TopoDS_Edge
        :type Inv1: bool
        :type Inv2: bool

        """
        this = _BRepFill.new_BRepFill_TrimSurfaceTool(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def IntersectWith(self, *args):
        """
        IntersectWith(BRepFill_TrimSurfaceTool self, TopoDS_Edge EdgeOnF1, TopoDS_Edge EdgeOnF2, NCollection_Sequence_gp_Pnt Points)

        Intersect <Bis>  with the  projection of the edges
        <EdgeOnFi> and returns the intersecting parameters
        on Bis and on the edges
        P.X() : Parameter on Bis
        P.Y() : Parameter on EdgeOnF1
        P.Z() : Parameter on EdgeOnF2
        raises if <Edge> is not a edge of Face1 or Face2.

        :type EdgeOnF1: OCC.wrapper.TopoDS.TopoDS_Edge
        :type EdgeOnF2: OCC.wrapper.TopoDS.TopoDS_Edge
        :type Points: OCC.wrapper.TColgp.TColgp_SequenceOfPnt

        """
        return _BRepFill.BRepFill_TrimSurfaceTool_IntersectWith(self, *args)


    def IsOnFace(self, *args):
        """
        IsOnFace(BRepFill_TrimSurfaceTool self, gp_Pnt2d Point) -> Standard_Boolean

        returns True if the Line (P, DZ) intersect the Faces

        :type Point: OCC.wrapper.gp.gp_Pnt2d
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepFill.BRepFill_TrimSurfaceTool_IsOnFace(self, *args)


    def ProjOn(self, *args):
        """
        ProjOn(BRepFill_TrimSurfaceTool self, gp_Pnt2d Point, TopoDS_Edge Edge) -> Standard_Real

        returns the parameter of the  point <Point> on the
        Edge <Edge>, assuming that the point is on the edge.

        :type Point: OCC.wrapper.gp.gp_Pnt2d
        :type Edge: OCC.wrapper.TopoDS.TopoDS_Edge
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _BRepFill.BRepFill_TrimSurfaceTool_ProjOn(self, *args)


    def Project(self, *args):
        """
        Project(BRepFill_TrimSurfaceTool self, Standard_Real const U1, Standard_Real const U2, Handle_Geom_Curve Curve, Handle_Geom2d_Curve PCurve1, Handle_Geom2d_Curve PCurve2)

        :type U1: float
        :type U2: float
        :type Curve: OCC.wrapper.Geom.Handle_Geom_Curve
        :type PCurve1: OCC.wrapper.Geom2d.Handle_Geom2d_Curve
        :type PCurve2: OCC.wrapper.Geom2d.Handle_Geom2d_Curve
        :type myCont: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _BRepFill.BRepFill_TrimSurfaceTool_Project(self, *args)

    __swig_destroy__ = _BRepFill.delete_BRepFill_TrimSurfaceTool
BRepFill_TrimSurfaceTool_swigregister = _BRepFill.BRepFill_TrimSurfaceTool_swigregister
BRepFill_TrimSurfaceTool_swigregister(BRepFill_TrimSurfaceTool)

class NCollection_DataMap_TopoDS_Shape_TopTools_DataMapOfShapeListOfShape_TopTools_ShapeMapHasher(NCollection.NCollection_BaseMap):
    """
    Purpose:     The DataMap is a Map to store keys with associated
    Items. See Map  from NCollection for  a discussion
    about the number of buckets.

    The DataMap can be seen as an extended array where
    the Keys  are the   indices.  For this reason  the
    operator () is defined on DataMap to fetch an Item
    from a Key. So the following syntax can be used :

    anItem = aMap(aKey);
    aMap(aKey) = anItem;

    This analogy has its  limit.   aMap(aKey) = anItem
    can  be done only  if aKey was previously bound to
    an item in the map.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_DataMap_TopoDS_Shape_TopTools_DataMapOfShapeListOfShape_TopTools_ShapeMapHasher self) -> NCollection_DataMap< TopoDS_Shape,TopTools_DataMapOfShapeListOfShape,TopTools_ShapeMapHasher >::iterator

        Returns an iterator pointing to the first element in the map.

        :rtype: iterator

        """
        return _BRepFill.NCollection_DataMap_TopoDS_Shape_TopTools_DataMapOfShapeListOfShape_TopTools_ShapeMapHasher_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_DataMap_TopoDS_Shape_TopTools_DataMapOfShapeListOfShape_TopTools_ShapeMapHasher self) -> NCollection_DataMap< TopoDS_Shape,TopTools_DataMapOfShapeListOfShape,TopTools_ShapeMapHasher >::iterator

        Returns an iterator referring to the past-the-end element in the map.

        :rtype: iterator

        """
        return _BRepFill.NCollection_DataMap_TopoDS_Shape_TopTools_DataMapOfShapeListOfShape_TopTools_ShapeMapHasher_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_DataMap_TopoDS_Shape_TopTools_DataMapOfShapeListOfShape_TopTools_ShapeMapHasher self) -> NCollection_DataMap< TopoDS_Shape,TopTools_DataMapOfShapeListOfShape,TopTools_ShapeMapHasher >::const_iterator

        Returns a const iterator pointing to the first element in the map.

        :rtype: const_iterator

        """
        return _BRepFill.NCollection_DataMap_TopoDS_Shape_TopTools_DataMapOfShapeListOfShape_TopTools_ShapeMapHasher_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_DataMap_TopoDS_Shape_TopTools_DataMapOfShapeListOfShape_TopTools_ShapeMapHasher self) -> NCollection_DataMap< TopoDS_Shape,TopTools_DataMapOfShapeListOfShape,TopTools_ShapeMapHasher >::const_iterator

        Returns a const iterator referring to the past-the-end element in the map.

        :rtype: const_iterator

        """
        return _BRepFill.NCollection_DataMap_TopoDS_Shape_TopTools_DataMapOfShapeListOfShape_TopTools_ShapeMapHasher_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     The DataMap is a Map to store keys with associated
        Items. See Map  from NCollection for  a discussion
        about the number of buckets.

        The DataMap can be seen as an extended array where
        the Keys  are the   indices.  For this reason  the
        operator () is defined on DataMap to fetch an Item
        from a Key. So the following syntax can be used :

        anItem = aMap(aKey);
        aMap(aKey) = anItem;

        This analogy has its  limit.   aMap(aKey) = anItem
        can  be done only  if aKey was previously bound to
        an item in the map.
        """
        this = _BRepFill.new_NCollection_DataMap_TopoDS_Shape_TopTools_DataMapOfShapeListOfShape_TopTools_ShapeMapHasher(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Exchange(self, *args):
        """
        Exchange(NCollection_DataMap_TopoDS_Shape_TopTools_DataMapOfShapeListOfShape_TopTools_ShapeMapHasher self, NCollection_DataMap_TopoDS_Shape_TopTools_DataMapOfShapeListOfShape_TopTools_ShapeMapHasher theOther)

        Exchange the content of two maps without re-allocations.
        Notice that allocators will be swapped as well!

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _BRepFill.NCollection_DataMap_TopoDS_Shape_TopTools_DataMapOfShapeListOfShape_TopTools_ShapeMapHasher_Exchange(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_DataMap_TopoDS_Shape_TopTools_DataMapOfShapeListOfShape_TopTools_ShapeMapHasher self, NCollection_DataMap_TopoDS_Shape_TopTools_DataMapOfShapeListOfShape_TopTools_ShapeMapHasher theOther) -> NCollection_DataMap_TopoDS_Shape_TopTools_DataMapOfShapeListOfShape_TopTools_ShapeMapHasher

        Assignment.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _BRepFill.NCollection_DataMap_TopoDS_Shape_TopTools_DataMapOfShapeListOfShape_TopTools_ShapeMapHasher_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_DataMap_TopoDS_Shape_TopTools_DataMapOfShapeListOfShape_TopTools_ShapeMapHasher self, NCollection_DataMap_TopoDS_Shape_TopTools_DataMapOfShapeListOfShape_TopTools_ShapeMapHasher theOther) -> NCollection_DataMap_TopoDS_Shape_TopTools_DataMapOfShapeListOfShape_TopTools_ShapeMapHasher

        Assignment operator

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _BRepFill.NCollection_DataMap_TopoDS_Shape_TopTools_DataMapOfShapeListOfShape_TopTools_ShapeMapHasher_assign(self, *args)


    def ReSize(self, *args):
        """
        ReSize(NCollection_DataMap_TopoDS_Shape_TopTools_DataMapOfShapeListOfShape_TopTools_ShapeMapHasher self, Standard_Integer const N)

        ReSize

        :type N: int

        """
        return _BRepFill.NCollection_DataMap_TopoDS_Shape_TopTools_DataMapOfShapeListOfShape_TopTools_ShapeMapHasher_ReSize(self, *args)


    def Bind(self, *args):
        """
        Bind(NCollection_DataMap_TopoDS_Shape_TopTools_DataMapOfShapeListOfShape_TopTools_ShapeMapHasher self, TopoDS_Shape theKey, NCollection_DataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_ShapeMapHasher theItem) -> Standard_Boolean

        Bind binds Item to Key in map.
        @param theKey  key to add/update
        @param theItem new item; overrides value previously bound to the key, if any
        @return Standard_True if Key was not bound already

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepFill.NCollection_DataMap_TopoDS_Shape_TopTools_DataMapOfShapeListOfShape_TopTools_ShapeMapHasher_Bind(self, *args)


    def Bound(self, *args):
        """
        Bound(NCollection_DataMap_TopoDS_Shape_TopTools_DataMapOfShapeListOfShape_TopTools_ShapeMapHasher self, TopoDS_Shape theKey, NCollection_DataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_ShapeMapHasher theItem) -> NCollection_DataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_ShapeMapHasher

        Bound binds Item to Key in map. Returns modifiable Item 

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: TheItemType *

        """
        return _BRepFill.NCollection_DataMap_TopoDS_Shape_TopTools_DataMapOfShapeListOfShape_TopTools_ShapeMapHasher_Bound(self, *args)


    def IsBound(self, *args):
        """
        IsBound(NCollection_DataMap_TopoDS_Shape_TopTools_DataMapOfShapeListOfShape_TopTools_ShapeMapHasher self, TopoDS_Shape theKey) -> Standard_Boolean

        IsBound

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepFill.NCollection_DataMap_TopoDS_Shape_TopTools_DataMapOfShapeListOfShape_TopTools_ShapeMapHasher_IsBound(self, *args)


    def UnBind(self, *args):
        """
        UnBind(NCollection_DataMap_TopoDS_Shape_TopTools_DataMapOfShapeListOfShape_TopTools_ShapeMapHasher self, TopoDS_Shape theKey) -> Standard_Boolean

        UnBind removes Item Key pair from map

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepFill.NCollection_DataMap_TopoDS_Shape_TopTools_DataMapOfShapeListOfShape_TopTools_ShapeMapHasher_UnBind(self, *args)


    def Seek(self, *args):
        """
        Seek(NCollection_DataMap_TopoDS_Shape_TopTools_DataMapOfShapeListOfShape_TopTools_ShapeMapHasher self, TopoDS_Shape theKey) -> NCollection_DataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_ShapeMapHasher

        Seek returns pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: const TheItemType *

        """
        return _BRepFill.NCollection_DataMap_TopoDS_Shape_TopTools_DataMapOfShapeListOfShape_TopTools_ShapeMapHasher_Seek(self, *args)


    def Find(self, *args):
        """
        Find returns the Item for Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _BRepFill.NCollection_DataMap_TopoDS_Shape_TopTools_DataMapOfShapeListOfShape_TopTools_ShapeMapHasher_Find(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeSeek(self, *args):
        """
        ChangeSeek(NCollection_DataMap_TopoDS_Shape_TopTools_DataMapOfShapeListOfShape_TopTools_ShapeMapHasher self, TopoDS_Shape theKey) -> NCollection_DataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_ShapeMapHasher

        ChangeSeek returns modifiable pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: TheItemType *

        """
        return _BRepFill.NCollection_DataMap_TopoDS_Shape_TopTools_DataMapOfShapeListOfShape_TopTools_ShapeMapHasher_ChangeSeek(self, *args)


    def ChangeFind(self, *args):
        """
        ChangeFind(NCollection_DataMap_TopoDS_Shape_TopTools_DataMapOfShapeListOfShape_TopTools_ShapeMapHasher self, TopoDS_Shape theKey) -> NCollection_DataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_ShapeMapHasher

        ChangeFind returns mofifiable Item by Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: TheItemType &

        """
        return _BRepFill.NCollection_DataMap_TopoDS_Shape_TopTools_DataMapOfShapeListOfShape_TopTools_ShapeMapHasher_ChangeFind(self, *args)


    def __call__(self, *args):
        """
        operator ()

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _BRepFill.NCollection_DataMap_TopoDS_Shape_TopTools_DataMapOfShapeListOfShape_TopTools_ShapeMapHasher___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Clear(self, *args):
        """
        Clear(NCollection_DataMap_TopoDS_Shape_TopTools_DataMapOfShapeListOfShape_TopTools_ShapeMapHasher self, Standard_Boolean const doReleaseMemory)
        Clear(NCollection_DataMap_TopoDS_Shape_TopTools_DataMapOfShapeListOfShape_TopTools_ShapeMapHasher self, Handle_NCollection_BaseAllocator theAllocator)

        Clear data and reset allocator

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _BRepFill.NCollection_DataMap_TopoDS_Shape_TopTools_DataMapOfShapeListOfShape_TopTools_ShapeMapHasher_Clear(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_DataMap_TopoDS_Shape_TopTools_DataMapOfShapeListOfShape_TopTools_ShapeMapHasher self) -> Standard_Integer

        Size

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepFill.NCollection_DataMap_TopoDS_Shape_TopTools_DataMapOfShapeListOfShape_TopTools_ShapeMapHasher_Size(self, *args)


    def __iter__(self):
        return _BRepFill.NCollection_DataMap_TopoDS_Shape_TopTools_DataMapOfShapeListOfShape_TopTools_ShapeMapHasher___iter__(self)
    __swig_destroy__ = _BRepFill.delete_NCollection_DataMap_TopoDS_Shape_TopTools_DataMapOfShapeListOfShape_TopTools_ShapeMapHasher
NCollection_DataMap_TopoDS_Shape_TopTools_DataMapOfShapeListOfShape_TopTools_ShapeMapHasher_swigregister = _BRepFill.NCollection_DataMap_TopoDS_Shape_TopTools_DataMapOfShapeListOfShape_TopTools_ShapeMapHasher_swigregister
NCollection_DataMap_TopoDS_Shape_TopTools_DataMapOfShapeListOfShape_TopTools_ShapeMapHasher_swigregister(NCollection_DataMap_TopoDS_Shape_TopTools_DataMapOfShapeListOfShape_TopTools_ShapeMapHasher)

class NCollection_DataMap_TopoDS_Shape_TopTools_DataMapOfShapeListOfShape_TopTools_ShapeMapHasher_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _BRepFill.new_NCollection_DataMap_TopoDS_Shape_TopTools_DataMapOfShapeListOfShape_TopTools_ShapeMapHasher_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _BRepFill.delete_NCollection_DataMap_TopoDS_Shape_TopTools_DataMapOfShapeListOfShape_TopTools_ShapeMapHasher_IteratorHelper

    def __next__(self):
        return _BRepFill.NCollection_DataMap_TopoDS_Shape_TopTools_DataMapOfShapeListOfShape_TopTools_ShapeMapHasher_IteratorHelper___next__(self)
NCollection_DataMap_TopoDS_Shape_TopTools_DataMapOfShapeListOfShape_TopTools_ShapeMapHasher_IteratorHelper_swigregister = _BRepFill.NCollection_DataMap_TopoDS_Shape_TopTools_DataMapOfShapeListOfShape_TopTools_ShapeMapHasher_IteratorHelper_swigregister
NCollection_DataMap_TopoDS_Shape_TopTools_DataMapOfShapeListOfShape_TopTools_ShapeMapHasher_IteratorHelper_swigregister(NCollection_DataMap_TopoDS_Shape_TopTools_DataMapOfShapeListOfShape_TopTools_ShapeMapHasher_IteratorHelper)


try:
	BRepFill_DataMapOfShapeDataMapOfShapeListOfShape = NCollection_DataMap_TopoDS_Shape_TopTools_DataMapOfShapeListOfShape_TopTools_ShapeMapHasher
except NameError:
	pass # does not exist, probably ignored

class BRepFill_Pipe(object):
    """
    Create a  shape by sweeping a shape  (the profile)
    along a wire (the spine).

    For each edge  or vertex from the spine  the  user
    may ask for the shape generated from each subshape
    of the profile.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BRepFill_Pipe self) -> BRepFill_Pipe
        __init__(BRepFill_Pipe self, TopoDS_Wire Spine, TopoDS_Shape Profile, GeomFill_Trihedron const aMode=GeomFill_IsCorrectedFrenet, Standard_Boolean const ForceApproxC1, Standard_Boolean const GeneratePartCase) -> BRepFill_Pipe

        :type Spine: OCC.wrapper.TopoDS.TopoDS_Wire
        :type Profile: OCC.wrapper.TopoDS.TopoDS_Shape
        :type aMode: OCC.wrapper.GeomFill.GeomFill_Trihedron
        :type ForceApproxC1: bool
        :type GeneratePartCase: bool

        """
        this = _BRepFill.new_BRepFill_Pipe(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Perform(self, *args):
        """
        Perform(BRepFill_Pipe self, TopoDS_Wire Spine, TopoDS_Shape Profile, Standard_Boolean const GeneratePartCase)

        :type Spine: OCC.wrapper.TopoDS.TopoDS_Wire
        :type Profile: OCC.wrapper.TopoDS.TopoDS_Shape
        :type GeneratePartCase: bool

        """
        return _BRepFill.BRepFill_Pipe_Perform(self, *args)


    def Spine(self, *args):
        """
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _BRepFill.BRepFill_Pipe_Spine(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Profile(self, *args):
        """
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _BRepFill.BRepFill_Pipe_Profile(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Shape(self, *args):
        """
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _BRepFill.BRepFill_Pipe_Shape(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ErrorOnSurface(self, *args):
        """
        ErrorOnSurface(BRepFill_Pipe self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _BRepFill.BRepFill_Pipe_ErrorOnSurface(self, *args)


    def FirstShape(self, *args):
        """
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _BRepFill.BRepFill_Pipe_FirstShape(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def LastShape(self, *args):
        """
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _BRepFill.BRepFill_Pipe_LastShape(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Generated(self, *args):
        """
        Generated(BRepFill_Pipe self, TopoDS_Shape S, NCollection_List_TopoDS_Shape L)

        Returns the  list   of shapes generated   from the
        shape <S>.

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :type L: OCC.wrapper.TopTools.TopTools_ListOfShape

        """
        return _BRepFill.BRepFill_Pipe_Generated(self, *args)


    def Face(self, *args):
        """
        Face(BRepFill_Pipe self, TopoDS_Edge ESpine, TopoDS_Edge EProfile) -> TopoDS_Face

        Returns the face created from an edge of the spine
        and an edge of the profile.
        if the edges are not in the spine or the profile

        :type ESpine: OCC.wrapper.TopoDS.TopoDS_Edge
        :type EProfile: OCC.wrapper.TopoDS.TopoDS_Edge
        :rtype: OCC.wrapper.TopoDS.TopoDS_Face

        """
        return _BRepFill.BRepFill_Pipe_Face(self, *args)


    def Edge(self, *args):
        """
        Edge(BRepFill_Pipe self, TopoDS_Edge ESpine, TopoDS_Vertex VProfile) -> TopoDS_Edge

        Returns the edge created from an edge of the spine
        and a vertex of the profile.
        if the edge or the vertex are not in  the spine or
        the profile.

        :type ESpine: OCC.wrapper.TopoDS.TopoDS_Edge
        :type VProfile: OCC.wrapper.TopoDS.TopoDS_Vertex
        :rtype: OCC.wrapper.TopoDS.TopoDS_Edge

        """
        return _BRepFill.BRepFill_Pipe_Edge(self, *args)


    def Section(self, *args):
        """
        Section(BRepFill_Pipe self, TopoDS_Vertex VSpine) -> TopoDS_Shape

        Returns  the shape created from the profile at the
        position of the vertex VSpine.
        if the vertex is not in the Spine

        :type VSpine: OCC.wrapper.TopoDS.TopoDS_Vertex
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _BRepFill.BRepFill_Pipe_Section(self, *args)


    def PipeLine(self, *args):
        """
        PipeLine(BRepFill_Pipe self, gp_Pnt Point) -> TopoDS_Wire

        Create a Wire by sweeping the Point along the <spine>
        if the <Spine> is undefined

        :type Point: OCC.wrapper.gp.gp_Pnt
        :rtype: OCC.wrapper.TopoDS.TopoDS_Wire

        """
        return _BRepFill.BRepFill_Pipe_PipeLine(self, *args)

    __swig_destroy__ = _BRepFill.delete_BRepFill_Pipe
BRepFill_Pipe_swigregister = _BRepFill.BRepFill_Pipe_swigregister
BRepFill_Pipe_swigregister(BRepFill_Pipe)

class Handle_BRepFill_ACRLaw(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_BRepFill_ACRLaw self)

        Nullify the handle


        """
        return _BRepFill.Handle_BRepFill_ACRLaw_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_BRepFill_ACRLaw self) -> bool

        Check for being null

        :rtype: bool

        """
        return _BRepFill.Handle_BRepFill_ACRLaw_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_BRepFill_ACRLaw self, BRepFill_ACRLaw thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _BRepFill.Handle_BRepFill_ACRLaw_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_BRepFill_ACRLaw self, Handle_BRepFill_ACRLaw theHandle) -> Handle_BRepFill_ACRLaw
        assign(Handle_BRepFill_ACRLaw self, BRepFill_ACRLaw thePtr) -> Handle_BRepFill_ACRLaw
        assign(Handle_BRepFill_ACRLaw self, Handle_BRepFill_ACRLaw theHandle) -> Handle_BRepFill_ACRLaw

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _BRepFill.Handle_BRepFill_ACRLaw_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_BRepFill_ACRLaw self) -> BRepFill_ACRLaw

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _BRepFill.Handle_BRepFill_ACRLaw_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_BRepFill_ACRLaw self) -> BRepFill_ACRLaw

        Member access operator (note non-const)

        :rtype: T *

        """
        return _BRepFill.Handle_BRepFill_ACRLaw___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_BRepFill_ACRLaw self) -> BRepFill_ACRLaw

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _BRepFill.Handle_BRepFill_ACRLaw___ref__(self, *args)


    def __hash__(self):
        return _BRepFill.Handle_BRepFill_ACRLaw___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _BRepFill.Handle_BRepFill_ACRLaw___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _BRepFill.new_Handle_BRepFill_ACRLaw(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_BRepFill.Handle_BRepFill_ACRLaw_DownCast)
    __swig_destroy__ = _BRepFill.delete_Handle_BRepFill_ACRLaw

    def get_type_name(self, *args):
        """
        get_type_name(Handle_BRepFill_ACRLaw self) -> char const *

        :rtype: const char *

        """
        return _BRepFill.Handle_BRepFill_ACRLaw_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _BRepFill.Handle_BRepFill_ACRLaw_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _BRepFill.Handle_BRepFill_ACRLaw_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def GetStatus(self, *args):
        """
        GetStatus(Handle_BRepFill_ACRLaw self) -> GeomFill_PipeError

        Return a error status, if the  status is not PipeOk then
        it exist a parameter tlike the law is not valuable for t.

        :rtype: OCC.wrapper.GeomFill.GeomFill_PipeError

        """
        return _BRepFill.Handle_BRepFill_ACRLaw_GetStatus(self, *args)


    def TransformInG0Law(self, *args):
        """
        TransformInG0Law(Handle_BRepFill_ACRLaw self)

        Apply a linear   transformation  on each law, to  have
        continuity of the global law beetween the edges.


        """
        return _BRepFill.Handle_BRepFill_ACRLaw_TransformInG0Law(self, *args)


    def TransformInCompatibleLaw(self, *args):
        """
        TransformInCompatibleLaw(Handle_BRepFill_ACRLaw self, Standard_Real const AngularTolerance)

        Apply a linear transformation on each law, to reduce
        the   dicontinuities  of law at one  rotation.

        :type AngularTolerance: float

        """
        return _BRepFill.Handle_BRepFill_ACRLaw_TransformInCompatibleLaw(self, *args)


    def DeleteTransform(self, *args):
        """DeleteTransform(Handle_BRepFill_ACRLaw self)"""
        return _BRepFill.Handle_BRepFill_ACRLaw_DeleteTransform(self, *args)


    def NbHoles(self, *args):
        """
        NbHoles(Handle_BRepFill_ACRLaw self, Standard_Real const Tol=1.0e-7) -> Standard_Integer

        :type Tol: float
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepFill.Handle_BRepFill_ACRLaw_NbHoles(self, *args)


    def Holes(self, *args):
        """
        Holes(Handle_BRepFill_ACRLaw self, NCollection_Array1_Standard_Integer Interval)

        :type Interval: OCC.wrapper.TColStd.TColStd_Array1OfInteger

        """
        return _BRepFill.Handle_BRepFill_ACRLaw_Holes(self, *args)


    def NbLaw(self, *args):
        """
        NbLaw(Handle_BRepFill_ACRLaw self) -> Standard_Integer

        Return the number of elementary Law

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepFill.Handle_BRepFill_ACRLaw_NbLaw(self, *args)


    def Law(self, *args):
        """
        Return the elementary Law of rank <Index>
        <Index> have to be in [1, NbLaw()]

        :type Index: int
        :rtype: OCC.wrapper.GeomFill.Handle_GeomFill_LocationLaw

        """
        res = _BRepFill.Handle_BRepFill_ACRLaw_Law_(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Wire(self, *args):
        """
        return the path

        :rtype: OCC.wrapper.TopoDS.TopoDS_Wire

        """
        res = _BRepFill.Handle_BRepFill_ACRLaw_Wire(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Edge(self, *args):
        """
        Return the Edge of rank <Index> in the path
        <Index> have to be in [1, NbLaw()]

        :type Index: int
        :rtype: OCC.wrapper.TopoDS.TopoDS_Edge

        """
        res = _BRepFill.Handle_BRepFill_ACRLaw_Edge(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Vertex(self, *args):
        """
        Vertex(Handle_BRepFill_ACRLaw self, Standard_Integer const Index) -> TopoDS_Vertex

        Return the vertex of rank <Index> in the path
        <Index> have to be in [0, NbLaw()]

        :type Index: int
        :rtype: OCC.wrapper.TopoDS.TopoDS_Vertex

        """
        return _BRepFill.Handle_BRepFill_ACRLaw_Vertex(self, *args)


    def PerformVertex(self, *args):
        """
        PerformVertex(Handle_BRepFill_ACRLaw self, Standard_Integer const Index, TopoDS_Vertex InputVertex, Standard_Real const TolMin, TopoDS_Vertex OutputVertex, Standard_Integer const Location=0)

        Compute <OutputVertex> like a transformation of
        <InputVertex>  the  transformation   is given by
        evaluation of the location law   in the vertex of
        rank   <Index>.
        <Location> is used to manage discontinuities :
        - -1 : The law before the vertex is used.
        -  1 : The law after the vertex is used.
        -  0 : Average of the both laws is used.

        :type Index: int
        :type InputVertex: OCC.wrapper.TopoDS.TopoDS_Vertex
        :type TolMin: float
        :type OutputVertex: OCC.wrapper.TopoDS.TopoDS_Vertex
        :type Location: int

        """
        return _BRepFill.Handle_BRepFill_ACRLaw_PerformVertex(self, *args)


    def CurvilinearBounds(self, *args):
        """
        CurvilinearBounds(Handle_BRepFill_ACRLaw self, Standard_Integer const Index)

        Return the Curvilinear Bounds of the <Index> Law

        :type Index: int
        :type First: float
        :type Last: float

        """
        return _BRepFill.Handle_BRepFill_ACRLaw_CurvilinearBounds(self, *args)


    def IsClosed(self, *args):
        """
        IsClosed(Handle_BRepFill_ACRLaw self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepFill.Handle_BRepFill_ACRLaw_IsClosed(self, *args)


    def IsG1(self, *args):
        """
        IsG1(Handle_BRepFill_ACRLaw self, Standard_Integer const Index, Standard_Real const SpatialTolerance=1.0e-7, Standard_Real const AngularTolerance=1.0e-4) -> Standard_Integer

        Compute the Law's continuity beetween 2 edges of the path
        The result can be :
        -1 : Case Not connex
        0  : It is connex (G0)
        1  : It is tangent (G1)

        :type Index: int
        :type SpatialTolerance: float
        :type AngularTolerance: float
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepFill.Handle_BRepFill_ACRLaw_IsG1(self, *args)


    def D0(self, *args):
        """
        D0(Handle_BRepFill_ACRLaw self, Standard_Real const Abscissa, TopoDS_Shape Section)

        Apply the Law to a shape, for a given Curnilinear abscissa

        :type Abscissa: float
        :type Section: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _BRepFill.Handle_BRepFill_ACRLaw_D0(self, *args)


    def Parameter(self, *args):
        """
        Parameter(Handle_BRepFill_ACRLaw self, Standard_Real const Abscissa)

        Find the  index Law  and the  parmaeter, for  a given
        Curnilinear abscissa

        :type Abscissa: float
        :type Index: int
        :type Param: float

        """
        return _BRepFill.Handle_BRepFill_ACRLaw_Parameter(self, *args)


    def Abscissa(self, *args):
        """
        Abscissa(Handle_BRepFill_ACRLaw self, Standard_Integer const Index, Standard_Real const Param) -> Standard_Real

        Return the curvilinear abscissa  corresponding to a point
        of  the path, defined by  <Index>  of  Edge and a
        parameter on the edge.

        :type Index: int
        :type Param: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _BRepFill.Handle_BRepFill_ACRLaw_Abscissa(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_BRepFill_ACRLaw self)

        Memory deallocator for transient classes


        """
        return _BRepFill.Handle_BRepFill_ACRLaw_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_BRepFill_ACRLaw self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_BRepFill_ACRLaw self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepFill.Handle_BRepFill_ACRLaw_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_BRepFill_ACRLaw self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_BRepFill_ACRLaw self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepFill.Handle_BRepFill_ACRLaw_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_BRepFill_ACRLaw self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _BRepFill.Handle_BRepFill_ACRLaw_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_BRepFill_ACRLaw self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepFill.Handle_BRepFill_ACRLaw_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_BRepFill_ACRLaw self)

        Increments the reference counter of this object


        """
        return _BRepFill.Handle_BRepFill_ACRLaw_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_BRepFill_ACRLaw self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepFill.Handle_BRepFill_ACRLaw_DecrementRefCounter(self, *args)

Handle_BRepFill_ACRLaw_swigregister = _BRepFill.Handle_BRepFill_ACRLaw_swigregister
Handle_BRepFill_ACRLaw_swigregister(Handle_BRepFill_ACRLaw)

def Handle_BRepFill_ACRLaw_DownCast(thing):
    return _BRepFill.Handle_BRepFill_ACRLaw_DownCast(thing)
Handle_BRepFill_ACRLaw_DownCast = _BRepFill.Handle_BRepFill_ACRLaw_DownCast

class BRepFill_OffsetWire(object):
    """
    Constructs a Offset Wire to a spine (wire or face).
    Offset direction will be to outer region in case of
    positive offset value and to inner region in case of
    negative offset value.
    Inner/Outer region for open wire is defined by the
    following rule: when we go along the wire (taking into
    account of edges orientation) then outer region will be
    on the right side, inner region will be on the left side.
    In case of closed wire, inner region will always be
    inside the wire (at that, edges orientation is not taken
    into account).
    The Wire or the Face must be planar and oriented correctly.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BRepFill_OffsetWire self) -> BRepFill_OffsetWire
        __init__(BRepFill_OffsetWire self, TopoDS_Face Spine, GeomAbs_JoinType const Join=GeomAbs_Arc, Standard_Boolean const IsOpenResult) -> BRepFill_OffsetWire

        :type Spine: OCC.wrapper.TopoDS.TopoDS_Face
        :type Join: OCC.wrapper.GeomAbs.GeomAbs_JoinType
        :type IsOpenResult: bool

        """
        this = _BRepFill.new_BRepFill_OffsetWire(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(BRepFill_OffsetWire self, TopoDS_Face Spine, GeomAbs_JoinType const Join=GeomAbs_Arc, Standard_Boolean const IsOpenResult)

        Initialize the evaluation of Offseting.

        :type Spine: OCC.wrapper.TopoDS.TopoDS_Face
        :type Join: OCC.wrapper.GeomAbs.GeomAbs_JoinType
        :type IsOpenResult: bool

        """
        return _BRepFill.BRepFill_OffsetWire_Init(self, *args)


    def Perform(self, *args):
        """
        Perform(BRepFill_OffsetWire self, Standard_Real const Offset, Standard_Real const Alt=0.0)

        Performs  an OffsetWire at  an altitude <Alt> from
        the  face ( According  to  the orientation of  the
        face)

        :type Offset: float
        :type Alt: float

        """
        return _BRepFill.BRepFill_OffsetWire_Perform(self, *args)


    def PerformWithBiLo(self, *args):
        """
        PerformWithBiLo(BRepFill_OffsetWire self, TopoDS_Face WSP, Standard_Real const Offset, BRepMAT2d_BisectingLocus Locus, BRepMAT2d_LinkTopoBilo Link, GeomAbs_JoinType const Join=GeomAbs_Arc, Standard_Real const Alt=0.0)

        Performs an  OffsetWire

        :type WSP: OCC.wrapper.TopoDS.TopoDS_Face
        :type Offset: float
        :type Locus: OCC.wrapper.BRepMAT2d.BRepMAT2d_BisectingLocus
        :type Link: OCC.wrapper.BRepMAT2d.BRepMAT2d_LinkTopoBilo
        :type Join: OCC.wrapper.GeomAbs.GeomAbs_JoinType
        :type Alt: float

        """
        return _BRepFill.BRepFill_OffsetWire_PerformWithBiLo(self, *args)


    def IsDone(self, *args):
        """
        IsDone(BRepFill_OffsetWire self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepFill.BRepFill_OffsetWire_IsDone(self, *args)


    def Spine(self, *args):
        """
        :rtype: OCC.wrapper.TopoDS.TopoDS_Face

        """
        res = _BRepFill.BRepFill_OffsetWire_Spine(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Shape(self, *args):
        """
        returns the generated shape.

        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _BRepFill.BRepFill_OffsetWire_Shape(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def GeneratedShapes(self, *args):
        """
        Returns   the  shapes  created  from   a  subshape
        <SpineShape> of the spine.
        Returns the last computed Offset.

        :type SpineShape: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.TopTools.TopTools_ListOfShape

        """
        res = _BRepFill.BRepFill_OffsetWire_GeneratedShapes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def JoinType(self, *args):
        """
        JoinType(BRepFill_OffsetWire self) -> GeomAbs_JoinType

        :rtype: OCC.wrapper.GeomAbs.GeomAbs_JoinType

        """
        return _BRepFill.BRepFill_OffsetWire_JoinType(self, *args)

    __swig_destroy__ = _BRepFill.delete_BRepFill_OffsetWire
BRepFill_OffsetWire_swigregister = _BRepFill.BRepFill_OffsetWire_swigregister
BRepFill_OffsetWire_swigregister(BRepFill_OffsetWire)

class BRepFill_OffsetAncestors(object):
    """
    this class is used to find the generating shapes
    of an OffsetWire.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BRepFill_OffsetAncestors self) -> BRepFill_OffsetAncestors
        __init__(BRepFill_OffsetAncestors self, BRepFill_OffsetWire Paral) -> BRepFill_OffsetAncestors

        :type Paral: OCC.wrapper.BRepFill.BRepFill_OffsetWire

        """
        this = _BRepFill.new_BRepFill_OffsetAncestors(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Perform(self, *args):
        """
        Perform(BRepFill_OffsetAncestors self, BRepFill_OffsetWire Paral)

        :type Paral: OCC.wrapper.BRepFill.BRepFill_OffsetWire

        """
        return _BRepFill.BRepFill_OffsetAncestors_Perform(self, *args)


    def IsDone(self, *args):
        """
        IsDone(BRepFill_OffsetAncestors self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepFill.BRepFill_OffsetAncestors_IsDone(self, *args)


    def HasAncestor(self, *args):
        """
        HasAncestor(BRepFill_OffsetAncestors self, TopoDS_Edge S1) -> Standard_Boolean

        :type S1: OCC.wrapper.TopoDS.TopoDS_Edge
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepFill.BRepFill_OffsetAncestors_HasAncestor(self, *args)


    def Ancestor(self, *args):
        """
        may return a Null Shape if S1 is not a subShape
        of <Paral>;
        if Perform is not done.

        :type S1: OCC.wrapper.TopoDS.TopoDS_Edge
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _BRepFill.BRepFill_OffsetAncestors_Ancestor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _BRepFill.delete_BRepFill_OffsetAncestors
BRepFill_OffsetAncestors_swigregister = _BRepFill.BRepFill_OffsetAncestors_swigregister
BRepFill_OffsetAncestors_swigregister(BRepFill_OffsetAncestors)

class Handle_BRepFill_Edge3DLaw(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_BRepFill_Edge3DLaw self)

        Nullify the handle


        """
        return _BRepFill.Handle_BRepFill_Edge3DLaw_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_BRepFill_Edge3DLaw self) -> bool

        Check for being null

        :rtype: bool

        """
        return _BRepFill.Handle_BRepFill_Edge3DLaw_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_BRepFill_Edge3DLaw self, BRepFill_Edge3DLaw thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _BRepFill.Handle_BRepFill_Edge3DLaw_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_BRepFill_Edge3DLaw self, Handle_BRepFill_Edge3DLaw theHandle) -> Handle_BRepFill_Edge3DLaw
        assign(Handle_BRepFill_Edge3DLaw self, BRepFill_Edge3DLaw thePtr) -> Handle_BRepFill_Edge3DLaw
        assign(Handle_BRepFill_Edge3DLaw self, Handle_BRepFill_Edge3DLaw theHandle) -> Handle_BRepFill_Edge3DLaw

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _BRepFill.Handle_BRepFill_Edge3DLaw_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_BRepFill_Edge3DLaw self) -> BRepFill_Edge3DLaw

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _BRepFill.Handle_BRepFill_Edge3DLaw_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_BRepFill_Edge3DLaw self) -> BRepFill_Edge3DLaw

        Member access operator (note non-const)

        :rtype: T *

        """
        return _BRepFill.Handle_BRepFill_Edge3DLaw___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_BRepFill_Edge3DLaw self) -> BRepFill_Edge3DLaw

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _BRepFill.Handle_BRepFill_Edge3DLaw___ref__(self, *args)


    def __hash__(self):
        return _BRepFill.Handle_BRepFill_Edge3DLaw___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _BRepFill.Handle_BRepFill_Edge3DLaw___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _BRepFill.new_Handle_BRepFill_Edge3DLaw(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_BRepFill.Handle_BRepFill_Edge3DLaw_DownCast)
    __swig_destroy__ = _BRepFill.delete_Handle_BRepFill_Edge3DLaw

    def get_type_name(self, *args):
        """
        get_type_name(Handle_BRepFill_Edge3DLaw self) -> char const *

        :rtype: const char *

        """
        return _BRepFill.Handle_BRepFill_Edge3DLaw_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _BRepFill.Handle_BRepFill_Edge3DLaw_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _BRepFill.Handle_BRepFill_Edge3DLaw_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def GetStatus(self, *args):
        """
        GetStatus(Handle_BRepFill_Edge3DLaw self) -> GeomFill_PipeError

        Return a error status, if the  status is not PipeOk then
        it exist a parameter tlike the law is not valuable for t.

        :rtype: OCC.wrapper.GeomFill.GeomFill_PipeError

        """
        return _BRepFill.Handle_BRepFill_Edge3DLaw_GetStatus(self, *args)


    def TransformInG0Law(self, *args):
        """
        TransformInG0Law(Handle_BRepFill_Edge3DLaw self)

        Apply a linear   transformation  on each law, to  have
        continuity of the global law beetween the edges.


        """
        return _BRepFill.Handle_BRepFill_Edge3DLaw_TransformInG0Law(self, *args)


    def TransformInCompatibleLaw(self, *args):
        """
        TransformInCompatibleLaw(Handle_BRepFill_Edge3DLaw self, Standard_Real const AngularTolerance)

        Apply a linear transformation on each law, to reduce
        the   dicontinuities  of law at one  rotation.

        :type AngularTolerance: float

        """
        return _BRepFill.Handle_BRepFill_Edge3DLaw_TransformInCompatibleLaw(self, *args)


    def DeleteTransform(self, *args):
        """DeleteTransform(Handle_BRepFill_Edge3DLaw self)"""
        return _BRepFill.Handle_BRepFill_Edge3DLaw_DeleteTransform(self, *args)


    def NbHoles(self, *args):
        """
        NbHoles(Handle_BRepFill_Edge3DLaw self, Standard_Real const Tol=1.0e-7) -> Standard_Integer

        :type Tol: float
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepFill.Handle_BRepFill_Edge3DLaw_NbHoles(self, *args)


    def Holes(self, *args):
        """
        Holes(Handle_BRepFill_Edge3DLaw self, NCollection_Array1_Standard_Integer Interval)

        :type Interval: OCC.wrapper.TColStd.TColStd_Array1OfInteger

        """
        return _BRepFill.Handle_BRepFill_Edge3DLaw_Holes(self, *args)


    def NbLaw(self, *args):
        """
        NbLaw(Handle_BRepFill_Edge3DLaw self) -> Standard_Integer

        Return the number of elementary Law

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepFill.Handle_BRepFill_Edge3DLaw_NbLaw(self, *args)


    def Law(self, *args):
        """
        Return the elementary Law of rank <Index>
        <Index> have to be in [1, NbLaw()]

        :type Index: int
        :rtype: OCC.wrapper.GeomFill.Handle_GeomFill_LocationLaw

        """
        res = _BRepFill.Handle_BRepFill_Edge3DLaw_Law_(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Wire(self, *args):
        """
        return the path

        :rtype: OCC.wrapper.TopoDS.TopoDS_Wire

        """
        res = _BRepFill.Handle_BRepFill_Edge3DLaw_Wire(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Edge(self, *args):
        """
        Return the Edge of rank <Index> in the path
        <Index> have to be in [1, NbLaw()]

        :type Index: int
        :rtype: OCC.wrapper.TopoDS.TopoDS_Edge

        """
        res = _BRepFill.Handle_BRepFill_Edge3DLaw_Edge(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Vertex(self, *args):
        """
        Vertex(Handle_BRepFill_Edge3DLaw self, Standard_Integer const Index) -> TopoDS_Vertex

        Return the vertex of rank <Index> in the path
        <Index> have to be in [0, NbLaw()]

        :type Index: int
        :rtype: OCC.wrapper.TopoDS.TopoDS_Vertex

        """
        return _BRepFill.Handle_BRepFill_Edge3DLaw_Vertex(self, *args)


    def PerformVertex(self, *args):
        """
        PerformVertex(Handle_BRepFill_Edge3DLaw self, Standard_Integer const Index, TopoDS_Vertex InputVertex, Standard_Real const TolMin, TopoDS_Vertex OutputVertex, Standard_Integer const Location=0)

        Compute <OutputVertex> like a transformation of
        <InputVertex>  the  transformation   is given by
        evaluation of the location law   in the vertex of
        rank   <Index>.
        <Location> is used to manage discontinuities :
        - -1 : The law before the vertex is used.
        -  1 : The law after the vertex is used.
        -  0 : Average of the both laws is used.

        :type Index: int
        :type InputVertex: OCC.wrapper.TopoDS.TopoDS_Vertex
        :type TolMin: float
        :type OutputVertex: OCC.wrapper.TopoDS.TopoDS_Vertex
        :type Location: int

        """
        return _BRepFill.Handle_BRepFill_Edge3DLaw_PerformVertex(self, *args)


    def CurvilinearBounds(self, *args):
        """
        CurvilinearBounds(Handle_BRepFill_Edge3DLaw self, Standard_Integer const Index)

        Return the Curvilinear Bounds of the <Index> Law

        :type Index: int
        :type First: float
        :type Last: float

        """
        return _BRepFill.Handle_BRepFill_Edge3DLaw_CurvilinearBounds(self, *args)


    def IsClosed(self, *args):
        """
        IsClosed(Handle_BRepFill_Edge3DLaw self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepFill.Handle_BRepFill_Edge3DLaw_IsClosed(self, *args)


    def IsG1(self, *args):
        """
        IsG1(Handle_BRepFill_Edge3DLaw self, Standard_Integer const Index, Standard_Real const SpatialTolerance=1.0e-7, Standard_Real const AngularTolerance=1.0e-4) -> Standard_Integer

        Compute the Law's continuity beetween 2 edges of the path
        The result can be :
        -1 : Case Not connex
        0  : It is connex (G0)
        1  : It is tangent (G1)

        :type Index: int
        :type SpatialTolerance: float
        :type AngularTolerance: float
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepFill.Handle_BRepFill_Edge3DLaw_IsG1(self, *args)


    def D0(self, *args):
        """
        D0(Handle_BRepFill_Edge3DLaw self, Standard_Real const Abscissa, TopoDS_Shape Section)

        Apply the Law to a shape, for a given Curnilinear abscissa

        :type Abscissa: float
        :type Section: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _BRepFill.Handle_BRepFill_Edge3DLaw_D0(self, *args)


    def Parameter(self, *args):
        """
        Parameter(Handle_BRepFill_Edge3DLaw self, Standard_Real const Abscissa)

        Find the  index Law  and the  parmaeter, for  a given
        Curnilinear abscissa

        :type Abscissa: float
        :type Index: int
        :type Param: float

        """
        return _BRepFill.Handle_BRepFill_Edge3DLaw_Parameter(self, *args)


    def Abscissa(self, *args):
        """
        Abscissa(Handle_BRepFill_Edge3DLaw self, Standard_Integer const Index, Standard_Real const Param) -> Standard_Real

        Return the curvilinear abscissa  corresponding to a point
        of  the path, defined by  <Index>  of  Edge and a
        parameter on the edge.

        :type Index: int
        :type Param: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _BRepFill.Handle_BRepFill_Edge3DLaw_Abscissa(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_BRepFill_Edge3DLaw self)

        Memory deallocator for transient classes


        """
        return _BRepFill.Handle_BRepFill_Edge3DLaw_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_BRepFill_Edge3DLaw self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_BRepFill_Edge3DLaw self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepFill.Handle_BRepFill_Edge3DLaw_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_BRepFill_Edge3DLaw self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_BRepFill_Edge3DLaw self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepFill.Handle_BRepFill_Edge3DLaw_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_BRepFill_Edge3DLaw self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _BRepFill.Handle_BRepFill_Edge3DLaw_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_BRepFill_Edge3DLaw self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepFill.Handle_BRepFill_Edge3DLaw_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_BRepFill_Edge3DLaw self)

        Increments the reference counter of this object


        """
        return _BRepFill.Handle_BRepFill_Edge3DLaw_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_BRepFill_Edge3DLaw self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepFill.Handle_BRepFill_Edge3DLaw_DecrementRefCounter(self, *args)

Handle_BRepFill_Edge3DLaw_swigregister = _BRepFill.Handle_BRepFill_Edge3DLaw_swigregister
Handle_BRepFill_Edge3DLaw_swigregister(Handle_BRepFill_Edge3DLaw)

def Handle_BRepFill_Edge3DLaw_DownCast(thing):
    return _BRepFill.Handle_BRepFill_Edge3DLaw_DownCast(thing)
Handle_BRepFill_Edge3DLaw_DownCast = _BRepFill.Handle_BRepFill_Edge3DLaw_DownCast

class NCollection_DataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_OrientedShapeMapHasher(NCollection.NCollection_BaseMap):
    """
    Purpose:     The DataMap is a Map to store keys with associated
    Items. See Map  from NCollection for  a discussion
    about the number of buckets.

    The DataMap can be seen as an extended array where
    the Keys  are the   indices.  For this reason  the
    operator () is defined on DataMap to fetch an Item
    from a Key. So the following syntax can be used :

    anItem = aMap(aKey);
    aMap(aKey) = anItem;

    This analogy has its  limit.   aMap(aKey) = anItem
    can  be done only  if aKey was previously bound to
    an item in the map.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_DataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_OrientedShapeMapHasher self) -> NCollection_DataMap< TopoDS_Shape,TopTools_ListOfShape,TopTools_OrientedShapeMapHasher >::iterator

        Returns an iterator pointing to the first element in the map.

        :rtype: iterator

        """
        return _BRepFill.NCollection_DataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_OrientedShapeMapHasher_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_DataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_OrientedShapeMapHasher self) -> NCollection_DataMap< TopoDS_Shape,TopTools_ListOfShape,TopTools_OrientedShapeMapHasher >::iterator

        Returns an iterator referring to the past-the-end element in the map.

        :rtype: iterator

        """
        return _BRepFill.NCollection_DataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_OrientedShapeMapHasher_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_DataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_OrientedShapeMapHasher self) -> NCollection_DataMap< TopoDS_Shape,TopTools_ListOfShape,TopTools_OrientedShapeMapHasher >::const_iterator

        Returns a const iterator pointing to the first element in the map.

        :rtype: const_iterator

        """
        return _BRepFill.NCollection_DataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_OrientedShapeMapHasher_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_DataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_OrientedShapeMapHasher self) -> NCollection_DataMap< TopoDS_Shape,TopTools_ListOfShape,TopTools_OrientedShapeMapHasher >::const_iterator

        Returns a const iterator referring to the past-the-end element in the map.

        :rtype: const_iterator

        """
        return _BRepFill.NCollection_DataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_OrientedShapeMapHasher_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     The DataMap is a Map to store keys with associated
        Items. See Map  from NCollection for  a discussion
        about the number of buckets.

        The DataMap can be seen as an extended array where
        the Keys  are the   indices.  For this reason  the
        operator () is defined on DataMap to fetch an Item
        from a Key. So the following syntax can be used :

        anItem = aMap(aKey);
        aMap(aKey) = anItem;

        This analogy has its  limit.   aMap(aKey) = anItem
        can  be done only  if aKey was previously bound to
        an item in the map.
        """
        this = _BRepFill.new_NCollection_DataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_OrientedShapeMapHasher(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Exchange(self, *args):
        """
        Exchange(NCollection_DataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_OrientedShapeMapHasher self, NCollection_DataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_OrientedShapeMapHasher theOther)

        Exchange the content of two maps without re-allocations.
        Notice that allocators will be swapped as well!

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _BRepFill.NCollection_DataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_OrientedShapeMapHasher_Exchange(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_DataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_OrientedShapeMapHasher self, NCollection_DataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_OrientedShapeMapHasher theOther) -> NCollection_DataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_OrientedShapeMapHasher

        Assignment.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _BRepFill.NCollection_DataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_OrientedShapeMapHasher_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_DataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_OrientedShapeMapHasher self, NCollection_DataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_OrientedShapeMapHasher theOther) -> NCollection_DataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_OrientedShapeMapHasher

        Assignment operator

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _BRepFill.NCollection_DataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_OrientedShapeMapHasher_assign(self, *args)


    def ReSize(self, *args):
        """
        ReSize(NCollection_DataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_OrientedShapeMapHasher self, Standard_Integer const N)

        ReSize

        :type N: int

        """
        return _BRepFill.NCollection_DataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_OrientedShapeMapHasher_ReSize(self, *args)


    def Bind(self, *args):
        """
        Bind(NCollection_DataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_OrientedShapeMapHasher self, TopoDS_Shape theKey, NCollection_List_TopoDS_Shape theItem) -> Standard_Boolean

        Bind binds Item to Key in map.
        @param theKey  key to add/update
        @param theItem new item; overrides value previously bound to the key, if any
        @return Standard_True if Key was not bound already

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepFill.NCollection_DataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_OrientedShapeMapHasher_Bind(self, *args)


    def Bound(self, *args):
        """
        Bound(NCollection_DataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_OrientedShapeMapHasher self, TopoDS_Shape theKey, NCollection_List_TopoDS_Shape theItem) -> NCollection_List_TopoDS_Shape

        Bound binds Item to Key in map. Returns modifiable Item 

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: TheItemType *

        """
        return _BRepFill.NCollection_DataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_OrientedShapeMapHasher_Bound(self, *args)


    def IsBound(self, *args):
        """
        IsBound(NCollection_DataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_OrientedShapeMapHasher self, TopoDS_Shape theKey) -> Standard_Boolean

        IsBound

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepFill.NCollection_DataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_OrientedShapeMapHasher_IsBound(self, *args)


    def UnBind(self, *args):
        """
        UnBind(NCollection_DataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_OrientedShapeMapHasher self, TopoDS_Shape theKey) -> Standard_Boolean

        UnBind removes Item Key pair from map

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepFill.NCollection_DataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_OrientedShapeMapHasher_UnBind(self, *args)


    def Seek(self, *args):
        """
        Seek(NCollection_DataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_OrientedShapeMapHasher self, TopoDS_Shape theKey) -> NCollection_List_TopoDS_Shape

        Seek returns pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: const TheItemType *

        """
        return _BRepFill.NCollection_DataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_OrientedShapeMapHasher_Seek(self, *args)


    def Find(self, *args):
        """
        Find returns the Item for Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _BRepFill.NCollection_DataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_OrientedShapeMapHasher_Find(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeSeek(self, *args):
        """
        ChangeSeek(NCollection_DataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_OrientedShapeMapHasher self, TopoDS_Shape theKey) -> NCollection_List_TopoDS_Shape

        ChangeSeek returns modifiable pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: TheItemType *

        """
        return _BRepFill.NCollection_DataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_OrientedShapeMapHasher_ChangeSeek(self, *args)


    def ChangeFind(self, *args):
        """
        ChangeFind(NCollection_DataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_OrientedShapeMapHasher self, TopoDS_Shape theKey) -> NCollection_List_TopoDS_Shape

        ChangeFind returns mofifiable Item by Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: TheItemType &

        """
        return _BRepFill.NCollection_DataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_OrientedShapeMapHasher_ChangeFind(self, *args)


    def __call__(self, *args):
        """
        operator ()

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _BRepFill.NCollection_DataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_OrientedShapeMapHasher___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Clear(self, *args):
        """
        Clear(NCollection_DataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_OrientedShapeMapHasher self, Standard_Boolean const doReleaseMemory)
        Clear(NCollection_DataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_OrientedShapeMapHasher self, Handle_NCollection_BaseAllocator theAllocator)

        Clear data and reset allocator

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _BRepFill.NCollection_DataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_OrientedShapeMapHasher_Clear(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_DataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_OrientedShapeMapHasher self) -> Standard_Integer

        Size

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepFill.NCollection_DataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_OrientedShapeMapHasher_Size(self, *args)


    def __iter__(self):
        return _BRepFill.NCollection_DataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_OrientedShapeMapHasher___iter__(self)
    __swig_destroy__ = _BRepFill.delete_NCollection_DataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_OrientedShapeMapHasher
NCollection_DataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_OrientedShapeMapHasher_swigregister = _BRepFill.NCollection_DataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_OrientedShapeMapHasher_swigregister
NCollection_DataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_OrientedShapeMapHasher_swigregister(NCollection_DataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_OrientedShapeMapHasher)

class NCollection_DataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_OrientedShapeMapHasher_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _BRepFill.new_NCollection_DataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_OrientedShapeMapHasher_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _BRepFill.delete_NCollection_DataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_OrientedShapeMapHasher_IteratorHelper

    def __next__(self):
        return _BRepFill.NCollection_DataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_OrientedShapeMapHasher_IteratorHelper___next__(self)
NCollection_DataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_OrientedShapeMapHasher_IteratorHelper_swigregister = _BRepFill.NCollection_DataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_OrientedShapeMapHasher_IteratorHelper_swigregister
NCollection_DataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_OrientedShapeMapHasher_IteratorHelper_swigregister(NCollection_DataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_OrientedShapeMapHasher_IteratorHelper)


try:
	BRepFill_DataMapOfOrientedShapeListOfShape = NCollection_DataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_OrientedShapeMapHasher
except NameError:
	pass # does not exist, probably ignored

class BRepFill_Filling(object):
    """
    N-Side Filling
    This algorithm avoids to build a face from:
    * a set of edges defining the bounds of the face and some
    constraints the surface support has to satisfy
    * a set of edges and points defining some constraints
    the support surface has to satisfy
    * an initial surface to deform for satisfying the constraints
    * a set of parameters to control the constraints.

    The support surface of the face is computed by deformation
    of the initial surface in order to satisfy the given constraints.
    The set of bounding edges defines the wire of the face.

    If no initial surface is given, the algorithm computes it
    automatically.
    If the set of edges is not connected (Free constraint)
    missing edges are automatically computed.

    Limitations:
    * If some constraints are not compatible
    The algorithm does not take them into account.
    So the constraints will not be satisfyed in an area containing
    the incompatibilitries.
    * The constraints defining the bound of the face have to be
    entered in order to have a continuous wire.

    Other Applications:
    * Deformation of a face to satisfy internal constraints
    * Deformation of a face to improve Gi continuity with
    connected faces
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BRepFill_Filling self, Standard_Integer const Degree=3, Standard_Integer const NbPtsOnCur=15, Standard_Integer const NbIter=2, Standard_Boolean const Anisotropie, Standard_Real const Tol2d=0.00001, Standard_Real const Tol3d=0.0001, Standard_Real const TolAng=0.01, Standard_Real const TolCurv=0.1, Standard_Integer const MaxDeg=8, Standard_Integer const MaxSegments=9) -> BRepFill_Filling

        Constructor

        :type Degree: int
        :type NbPtsOnCur: int
        :type NbIter: int
        :type Anisotropie: bool
        :type Tol2d: float
        :type Tol3d: float
        :type TolAng: float
        :type TolCurv: float
        :type MaxDeg: int
        :type MaxSegments: int

        """
        this = _BRepFill.new_BRepFill_Filling(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def SetConstrParam(self, *args):
        """
        SetConstrParam(BRepFill_Filling self, Standard_Real const Tol2d=0.00001, Standard_Real const Tol3d=0.0001, Standard_Real const TolAng=0.01, Standard_Real const TolCurv=0.1)

        Sets the values of Tolerances used to control the constraint.
        Tol2d:
        Tol3d:   it is the maximum distance allowed between the support surface
        and the constraints
        TolAng:  it is the maximum angle allowed between the normal of the surface
        and the constraints
        TolCurv: it is the maximum difference of curvature allowed between
        the surface and the constraint

        :type Tol2d: float
        :type Tol3d: float
        :type TolAng: float
        :type TolCurv: float

        """
        return _BRepFill.BRepFill_Filling_SetConstrParam(self, *args)


    def SetResolParam(self, *args):
        """
        SetResolParam(BRepFill_Filling self, Standard_Integer const Degree=3, Standard_Integer const NbPtsOnCur=15, Standard_Integer const NbIter=2, Standard_Boolean const Anisotropie)

        Sets the parameters used for resolution.
        The default values of these parameters have been chosen for a good
        ratio quality/performance.
        Degree:      it is the order of energy criterion to minimize for computing
        the deformation of the surface.
        The default value is 3
        The recommanded value is i+2 where i is the maximum order of the
        constraints.
        NbPtsOnCur:  it is the average number of points for discretisation
        of the edges.
        NbIter:      it is the maximum number of iterations of the process.
        For each iteration the number of discretisation points is
        increased.
        Anisotropie:

        :type Degree: int
        :type NbPtsOnCur: int
        :type NbIter: int
        :type Anisotropie: bool

        """
        return _BRepFill.BRepFill_Filling_SetResolParam(self, *args)


    def SetApproxParam(self, *args):
        """
        SetApproxParam(BRepFill_Filling self, Standard_Integer const MaxDeg=8, Standard_Integer const MaxSegments=9)

        Sets the parameters used for approximation of the surface

        :type MaxDeg: int
        :type MaxSegments: int

        """
        return _BRepFill.BRepFill_Filling_SetApproxParam(self, *args)


    def LoadInitSurface(self, *args):
        """
        LoadInitSurface(BRepFill_Filling self, TopoDS_Face aFace)

        Loads the initial Surface
        The initial surface must have orthogonal local coordinates,
        i.e. partial derivatives dS/du and dS/dv must be orthogonal
        at each point of surface.
        If this condition breaks, distortions of resulting surface
        are possible.

        :type aFace: OCC.wrapper.TopoDS.TopoDS_Face

        """
        return _BRepFill.BRepFill_Filling_LoadInitSurface(self, *args)


    def Add(self, *args):
        """
        Add(BRepFill_Filling self, TopoDS_Edge anEdge, GeomAbs_Shape const Order, Standard_Boolean const IsBound) -> Standard_Integer
        Add(BRepFill_Filling self, TopoDS_Edge anEdge, TopoDS_Face Support, GeomAbs_Shape const Order, Standard_Boolean const IsBound) -> Standard_Integer
        Add(BRepFill_Filling self, TopoDS_Face Support, GeomAbs_Shape const Order) -> Standard_Integer
        Add(BRepFill_Filling self, gp_Pnt Point) -> Standard_Integer
        Add(BRepFill_Filling self, Standard_Real const U, Standard_Real const V, TopoDS_Face Support, GeomAbs_Shape const Order) -> Standard_Integer

        Adds a punctual constraint.

        :type U: float
        :type V: float
        :type Support: OCC.wrapper.TopoDS.TopoDS_Face
        :type Order: OCC.wrapper.GeomAbs.GeomAbs_Shape
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepFill.BRepFill_Filling_Add(self, *args)


    def Build(self, *args):
        """
        Build(BRepFill_Filling self)

        Builds the resulting faces


        """
        return _BRepFill.BRepFill_Filling_Build(self, *args)


    def IsDone(self, *args):
        """
        IsDone(BRepFill_Filling self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepFill.BRepFill_Filling_IsDone(self, *args)


    def Face(self, *args):
        """
        Face(BRepFill_Filling self) -> TopoDS_Face

        :rtype: OCC.wrapper.TopoDS.TopoDS_Face

        """
        return _BRepFill.BRepFill_Filling_Face(self, *args)


    def Generated(self, *args):
        """
        Returns the list of shapes generated from the
        shape <S>.

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.TopTools.TopTools_ListOfShape

        """
        res = _BRepFill.BRepFill_Filling_Generated(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def G0Error(self, *args):
        """
        G0Error(BRepFill_Filling self) -> Standard_Real
        G0Error(BRepFill_Filling self, Standard_Integer const Index) -> Standard_Real

        :type Index: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _BRepFill.BRepFill_Filling_G0Error(self, *args)


    def G1Error(self, *args):
        """
        G1Error(BRepFill_Filling self) -> Standard_Real
        G1Error(BRepFill_Filling self, Standard_Integer const Index) -> Standard_Real

        :type Index: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _BRepFill.BRepFill_Filling_G1Error(self, *args)


    def G2Error(self, *args):
        """
        G2Error(BRepFill_Filling self) -> Standard_Real
        G2Error(BRepFill_Filling self, Standard_Integer const Index) -> Standard_Real

        :type Index: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _BRepFill.BRepFill_Filling_G2Error(self, *args)

    __swig_destroy__ = _BRepFill.delete_BRepFill_Filling
BRepFill_Filling_swigregister = _BRepFill.BRepFill_Filling_swigregister
BRepFill_Filling_swigregister(BRepFill_Filling)

class Handle_BRepFill_CurveConstraint(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_BRepFill_CurveConstraint self)

        Nullify the handle


        """
        return _BRepFill.Handle_BRepFill_CurveConstraint_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_BRepFill_CurveConstraint self) -> bool

        Check for being null

        :rtype: bool

        """
        return _BRepFill.Handle_BRepFill_CurveConstraint_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_BRepFill_CurveConstraint self, BRepFill_CurveConstraint thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _BRepFill.Handle_BRepFill_CurveConstraint_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_BRepFill_CurveConstraint self, Handle_BRepFill_CurveConstraint theHandle) -> Handle_BRepFill_CurveConstraint
        assign(Handle_BRepFill_CurveConstraint self, BRepFill_CurveConstraint thePtr) -> Handle_BRepFill_CurveConstraint
        assign(Handle_BRepFill_CurveConstraint self, Handle_BRepFill_CurveConstraint theHandle) -> Handle_BRepFill_CurveConstraint

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _BRepFill.Handle_BRepFill_CurveConstraint_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_BRepFill_CurveConstraint self) -> BRepFill_CurveConstraint

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _BRepFill.Handle_BRepFill_CurveConstraint_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_BRepFill_CurveConstraint self) -> BRepFill_CurveConstraint

        Member access operator (note non-const)

        :rtype: T *

        """
        return _BRepFill.Handle_BRepFill_CurveConstraint___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_BRepFill_CurveConstraint self) -> BRepFill_CurveConstraint

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _BRepFill.Handle_BRepFill_CurveConstraint___ref__(self, *args)


    def __hash__(self):
        return _BRepFill.Handle_BRepFill_CurveConstraint___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _BRepFill.Handle_BRepFill_CurveConstraint___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _BRepFill.new_Handle_BRepFill_CurveConstraint(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_BRepFill.Handle_BRepFill_CurveConstraint_DownCast)
    __swig_destroy__ = _BRepFill.delete_Handle_BRepFill_CurveConstraint

    def get_type_name(self, *args):
        """
        get_type_name(Handle_BRepFill_CurveConstraint self) -> char const *

        :rtype: const char *

        """
        return _BRepFill.Handle_BRepFill_CurveConstraint_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _BRepFill.Handle_BRepFill_CurveConstraint_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _BRepFill.Handle_BRepFill_CurveConstraint_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetOrder(self, *args):
        """
        SetOrder(Handle_BRepFill_CurveConstraint self, Standard_Integer const Order)

        Allows you to set the order of continuity required for
        the constraints: G0, G1, and G2, controlled
        respectively by G0Criterion G1Criterion and G2Criterion.

        :type Order: int

        """
        return _BRepFill.Handle_BRepFill_CurveConstraint_SetOrder(self, *args)


    def Order(self, *args):
        """
        Order(Handle_BRepFill_CurveConstraint self) -> Standard_Integer

        Returns the order of constraint, one of G0, G1 or G2.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepFill.Handle_BRepFill_CurveConstraint_Order(self, *args)


    def NbPoints(self, *args):
        """
        NbPoints(Handle_BRepFill_CurveConstraint self) -> Standard_Integer

        Returns the number of points on the curve used as a
        constraint. The default setting is 10. This parameter
        affects computation time, which increases by the cube of
        the number of points.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepFill.Handle_BRepFill_CurveConstraint_NbPoints(self, *args)


    def SetNbPoints(self, *args):
        """
        SetNbPoints(Handle_BRepFill_CurveConstraint self, Standard_Integer const NewNb)

        Allows you to set the number of points on the curve
        constraint. The default setting is 10. This parameter
        affects computation time, which increases by the cube of
        the number of points.

        :type NewNb: int

        """
        return _BRepFill.Handle_BRepFill_CurveConstraint_SetNbPoints(self, *args)


    def SetG0Criterion(self, *args):
        """
        SetG0Criterion(Handle_BRepFill_CurveConstraint self, Handle_Law_Function G0Crit)

        Allows you to set the G0 criterion. This is the law
        defining the greatest distance allowed between the
        constraint and the target surface for each point of the
        constraint. If this criterion is not set, TolDist, the
        distance tolerance from the constructor, is used.

        :type G0Crit: OCC.wrapper.Law.Handle_Law_Function

        """
        return _BRepFill.Handle_BRepFill_CurveConstraint_SetG0Criterion(self, *args)


    def SetG1Criterion(self, *args):
        """
        SetG1Criterion(Handle_BRepFill_CurveConstraint self, Handle_Law_Function G1Crit)

        Allows you to set the G1 criterion. This is the law
        defining the greatest angle allowed between the
        constraint and the target surface. If this criterion is not
        set, TolAng, the angular tolerance from the constructor, is used.
        Raises  ConstructionError if  the  curve  is  not  on  a  surface

        :type G1Crit: OCC.wrapper.Law.Handle_Law_Function

        """
        return _BRepFill.Handle_BRepFill_CurveConstraint_SetG1Criterion(self, *args)


    def SetG2Criterion(self, *args):
        """
        SetG2Criterion(Handle_BRepFill_CurveConstraint self, Handle_Law_Function G2Crit)

        :type G2Crit: OCC.wrapper.Law.Handle_Law_Function

        """
        return _BRepFill.Handle_BRepFill_CurveConstraint_SetG2Criterion(self, *args)


    def G0Criterion(self, *args):
        """
        G0Criterion(Handle_BRepFill_CurveConstraint self, Standard_Real const U) -> Standard_Real

        Returns the G0 criterion at the parametric point U on
        the curve. This is the greatest distance allowed between
        the constraint and the target surface at U.

        :type U: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _BRepFill.Handle_BRepFill_CurveConstraint_G0Criterion(self, *args)


    def G1Criterion(self, *args):
        """
        G1Criterion(Handle_BRepFill_CurveConstraint self, Standard_Real const U) -> Standard_Real

        Returns the G1 criterion at the parametric point U on
        the curve. This is the greatest angle allowed between
        the constraint and the target surface at U.
        Raises  ConstructionError if  the  curve  is  not  on  a  surface

        :type U: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _BRepFill.Handle_BRepFill_CurveConstraint_G1Criterion(self, *args)


    def G2Criterion(self, *args):
        """
        G2Criterion(Handle_BRepFill_CurveConstraint self, Standard_Real const U) -> Standard_Real

        Returns the G2 criterion at the parametric point U on
        the curve. This is the greatest difference in curvature
        allowed between the constraint and the target surface at U.
        Raises  ConstructionError if  the  curve  is  not  on  a  surface

        :type U: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _BRepFill.Handle_BRepFill_CurveConstraint_G2Criterion(self, *args)


    def FirstParameter(self, *args):
        """
        FirstParameter(Handle_BRepFill_CurveConstraint self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _BRepFill.Handle_BRepFill_CurveConstraint_FirstParameter(self, *args)


    def LastParameter(self, *args):
        """
        LastParameter(Handle_BRepFill_CurveConstraint self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _BRepFill.Handle_BRepFill_CurveConstraint_LastParameter(self, *args)


    def Length(self, *args):
        """
        Length(Handle_BRepFill_CurveConstraint self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _BRepFill.Handle_BRepFill_CurveConstraint_Length(self, *args)


    def LPropSurf(self, *args):
        """
        LPropSurf(Handle_BRepFill_CurveConstraint self, Standard_Real const U) -> GeomLProp_SLProps

        :type U: float
        :rtype: OCC.wrapper.GeomLProp.GeomLProp_SLProps

        """
        return _BRepFill.Handle_BRepFill_CurveConstraint_LPropSurf(self, *args)


    def D0(self, *args):
        """
        D0(Handle_BRepFill_CurveConstraint self, Standard_Real const U, gp_Pnt P)

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt

        """
        return _BRepFill.Handle_BRepFill_CurveConstraint_D0(self, *args)


    def D1(self, *args):
        """
        D1(Handle_BRepFill_CurveConstraint self, Standard_Real const U, gp_Pnt P, gp_Vec V1, gp_Vec V2)

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type V1: OCC.wrapper.gp.gp_Vec
        :type V2: OCC.wrapper.gp.gp_Vec

        """
        return _BRepFill.Handle_BRepFill_CurveConstraint_D1(self, *args)


    def D2(self, *args):
        """
        D2(Handle_BRepFill_CurveConstraint self, Standard_Real const U, gp_Pnt P, gp_Vec V1, gp_Vec V2, gp_Vec V3, gp_Vec V4, gp_Vec V5)

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type V1: OCC.wrapper.gp.gp_Vec
        :type V2: OCC.wrapper.gp.gp_Vec
        :type V3: OCC.wrapper.gp.gp_Vec
        :type V4: OCC.wrapper.gp.gp_Vec
        :type V5: OCC.wrapper.gp.gp_Vec

        """
        return _BRepFill.Handle_BRepFill_CurveConstraint_D2(self, *args)


    def Curve3d(self, *args):
        """
        Curve3d(Handle_BRepFill_CurveConstraint self) -> Handle_Adaptor3d_HCurve

        :rtype: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HCurve

        """
        return _BRepFill.Handle_BRepFill_CurveConstraint_Curve3d(self, *args)


    def SetCurve2dOnSurf(self, *args):
        """
        SetCurve2dOnSurf(Handle_BRepFill_CurveConstraint self, Handle_Geom2d_Curve Curve2d)

        loads a 2d curve associated the surface resulting of the constraints

        :type Curve2d: OCC.wrapper.Geom2d.Handle_Geom2d_Curve

        """
        return _BRepFill.Handle_BRepFill_CurveConstraint_SetCurve2dOnSurf(self, *args)


    def Curve2dOnSurf(self, *args):
        """
        Curve2dOnSurf(Handle_BRepFill_CurveConstraint self) -> Handle_Geom2d_Curve

        Returns a 2d curve associated the surface resulting of the constraints

        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Curve

        """
        return _BRepFill.Handle_BRepFill_CurveConstraint_Curve2dOnSurf(self, *args)


    def SetProjectedCurve(self, *args):
        """
        SetProjectedCurve(Handle_BRepFill_CurveConstraint self, Handle_Adaptor2d_HCurve2d Curve2d, Standard_Real const TolU, Standard_Real const TolV)

        loads a 2d curve  resulting from the normal projection of
        the curve on the initial surface

        :type Curve2d: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d
        :type TolU: float
        :type TolV: float

        """
        return _BRepFill.Handle_BRepFill_CurveConstraint_SetProjectedCurve(self, *args)


    def ProjectedCurve(self, *args):
        """
        ProjectedCurve(Handle_BRepFill_CurveConstraint self) -> Handle_Adaptor2d_HCurve2d

        Returns the projected curve resulting from the normal projection of the
        curve on the initial surface

        :rtype: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d

        """
        return _BRepFill.Handle_BRepFill_CurveConstraint_ProjectedCurve(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_BRepFill_CurveConstraint self)

        Memory deallocator for transient classes


        """
        return _BRepFill.Handle_BRepFill_CurveConstraint_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_BRepFill_CurveConstraint self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_BRepFill_CurveConstraint self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepFill.Handle_BRepFill_CurveConstraint_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_BRepFill_CurveConstraint self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_BRepFill_CurveConstraint self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepFill.Handle_BRepFill_CurveConstraint_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_BRepFill_CurveConstraint self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _BRepFill.Handle_BRepFill_CurveConstraint_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_BRepFill_CurveConstraint self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepFill.Handle_BRepFill_CurveConstraint_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_BRepFill_CurveConstraint self)

        Increments the reference counter of this object


        """
        return _BRepFill.Handle_BRepFill_CurveConstraint_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_BRepFill_CurveConstraint self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepFill.Handle_BRepFill_CurveConstraint_DecrementRefCounter(self, *args)

Handle_BRepFill_CurveConstraint_swigregister = _BRepFill.Handle_BRepFill_CurveConstraint_swigregister
Handle_BRepFill_CurveConstraint_swigregister(Handle_BRepFill_CurveConstraint)

def Handle_BRepFill_CurveConstraint_DownCast(thing):
    return _BRepFill.Handle_BRepFill_CurveConstraint_DownCast(thing)
Handle_BRepFill_CurveConstraint_DownCast = _BRepFill.Handle_BRepFill_CurveConstraint_DownCast

class NCollection_IndexedDataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_OrientedShapeMapHasher(NCollection.NCollection_BaseMap):
    """
    Purpose:     An indexed map is used  to store keys and to  bind
    an index to them.  Each  new key stored in the map
    gets an index.  Index are  incremented as keys are
    stored in the map. A key can be found by the index
    and an index by the key.  No  key but the last can
    be  removed so the  indices   are in the range 1..
    Extent.  An Item is stored with each key.

    This   class is   similar  to  IndexedMap     from
    NCollection  with the Item as  a new feature. Note
    the important difference on  the operator  ().  In
    the IndexedMap this operator returns  the Key.  In
    the IndexedDataMap this operator returns the Item.

    See  the  class   Map   from NCollection   for   a
    discussion about the number of buckets.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_IndexedDataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_OrientedShapeMapHasher self) -> NCollection_IndexedDataMap< TopoDS_Shape,TopTools_ListOfShape,TopTools_OrientedShapeMapHasher >::iterator

        Returns an iterator pointing to the first element in the map.

        :rtype: iterator

        """
        return _BRepFill.NCollection_IndexedDataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_OrientedShapeMapHasher_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_IndexedDataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_OrientedShapeMapHasher self) -> NCollection_IndexedDataMap< TopoDS_Shape,TopTools_ListOfShape,TopTools_OrientedShapeMapHasher >::iterator

        Returns an iterator referring to the past-the-end element in the map.

        :rtype: iterator

        """
        return _BRepFill.NCollection_IndexedDataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_OrientedShapeMapHasher_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_IndexedDataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_OrientedShapeMapHasher self) -> NCollection_IndexedDataMap< TopoDS_Shape,TopTools_ListOfShape,TopTools_OrientedShapeMapHasher >::const_iterator

        Returns a const iterator pointing to the first element in the map.

        :rtype: const_iterator

        """
        return _BRepFill.NCollection_IndexedDataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_OrientedShapeMapHasher_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_IndexedDataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_OrientedShapeMapHasher self) -> NCollection_IndexedDataMap< TopoDS_Shape,TopTools_ListOfShape,TopTools_OrientedShapeMapHasher >::const_iterator

        Returns a const iterator referring to the past-the-end element in the map.

        :rtype: const_iterator

        """
        return _BRepFill.NCollection_IndexedDataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_OrientedShapeMapHasher_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     An indexed map is used  to store keys and to  bind
        an index to them.  Each  new key stored in the map
        gets an index.  Index are  incremented as keys are
        stored in the map. A key can be found by the index
        and an index by the key.  No  key but the last can
        be  removed so the  indices   are in the range 1..
        Extent.  An Item is stored with each key.

        This   class is   similar  to  IndexedMap     from
        NCollection  with the Item as  a new feature. Note
        the important difference on  the operator  ().  In
        the IndexedMap this operator returns  the Key.  In
        the IndexedDataMap this operator returns the Item.

        See  the  class   Map   from NCollection   for   a
        discussion about the number of buckets.
        """
        this = _BRepFill.new_NCollection_IndexedDataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_OrientedShapeMapHasher(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Exchange(self, *args):
        """
        Exchange(NCollection_IndexedDataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_OrientedShapeMapHasher self, NCollection_IndexedDataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_OrientedShapeMapHasher theOther)

        Exchange the content of two maps without re-allocations.
        Notice that allocators will be swapped as well!

        :type theOther: OCC.wrapper.NCollection.NCollection_IndexedDataMap

        """
        return _BRepFill.NCollection_IndexedDataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_OrientedShapeMapHasher_Exchange(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_IndexedDataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_OrientedShapeMapHasher self, NCollection_IndexedDataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_OrientedShapeMapHasher theOther) -> NCollection_IndexedDataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_OrientedShapeMapHasher

        Assignment.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_IndexedDataMap
        :rtype: OCC.wrapper.NCollection.NCollection_IndexedDataMap

        """
        return _BRepFill.NCollection_IndexedDataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_OrientedShapeMapHasher_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_IndexedDataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_OrientedShapeMapHasher self, NCollection_IndexedDataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_OrientedShapeMapHasher theOther) -> NCollection_IndexedDataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_OrientedShapeMapHasher

        Assignment operator

        :type theOther: OCC.wrapper.NCollection.NCollection_IndexedDataMap
        :rtype: OCC.wrapper.NCollection.NCollection_IndexedDataMap

        """
        return _BRepFill.NCollection_IndexedDataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_OrientedShapeMapHasher_assign(self, *args)


    def ReSize(self, *args):
        """
        ReSize(NCollection_IndexedDataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_OrientedShapeMapHasher self, Standard_Integer const N)

        ReSize

        :type N: int

        """
        return _BRepFill.NCollection_IndexedDataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_OrientedShapeMapHasher_ReSize(self, *args)


    def Add(self, *args):
        """
        Add(NCollection_IndexedDataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_OrientedShapeMapHasher self, TopoDS_Shape theKey1, NCollection_List_TopoDS_Shape theItem) -> Standard_Integer

        Returns the Index of already bound Key or appends new Key with specified Item value.
        @param theKey1 Key to search (and to bind, if it was not bound already)
        @param theItem Item value to set for newly bound Key; ignored if Key was already bound
        @return index of Key

        :type theKey1: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepFill.NCollection_IndexedDataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_OrientedShapeMapHasher_Add(self, *args)


    def Contains(self, *args):
        """
        Contains(NCollection_IndexedDataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_OrientedShapeMapHasher self, TopoDS_Shape theKey1) -> Standard_Boolean

        Contains

        :type theKey1: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepFill.NCollection_IndexedDataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_OrientedShapeMapHasher_Contains(self, *args)


    def Substitute(self, *args):
        """
        Substitute(NCollection_IndexedDataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_OrientedShapeMapHasher self, Standard_Integer const theIndex, TopoDS_Shape theKey1, NCollection_List_TopoDS_Shape theItem)

        Substitute

        :type theIndex: int
        :type theKey1: const TheKeyType &
        :type theItem: const TheItemType &

        """
        return _BRepFill.NCollection_IndexedDataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_OrientedShapeMapHasher_Substitute(self, *args)


    def Swap(self, *args):
        """
        Swap(NCollection_IndexedDataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_OrientedShapeMapHasher self, Standard_Integer const theIndex1, Standard_Integer const theIndex2)

        Swaps two elements with the given indices.

        :type theIndex1: int
        :type theIndex2: int

        """
        return _BRepFill.NCollection_IndexedDataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_OrientedShapeMapHasher_Swap(self, *args)


    def RemoveLast(self, *args):
        """
        RemoveLast(NCollection_IndexedDataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_OrientedShapeMapHasher self)

        RemoveLast


        """
        return _BRepFill.NCollection_IndexedDataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_OrientedShapeMapHasher_RemoveLast(self, *args)


    def RemoveFromIndex(self, *args):
        """
        RemoveFromIndex(NCollection_IndexedDataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_OrientedShapeMapHasher self, Standard_Integer const theIndex)

        Remove the key of the given index.
        Caution! The index of the last key can be changed.

        :type theIndex: int

        """
        return _BRepFill.NCollection_IndexedDataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_OrientedShapeMapHasher_RemoveFromIndex(self, *args)


    def RemoveKey(self, *args):
        """
        RemoveKey(NCollection_IndexedDataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_OrientedShapeMapHasher self, TopoDS_Shape theKey1)

        Remove the given key.
        Caution! The index of the last key can be changed.

        :type theKey1: const TheKeyType &

        """
        return _BRepFill.NCollection_IndexedDataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_OrientedShapeMapHasher_RemoveKey(self, *args)


    def FindKey(self, *args):
        """
        FindKey

        :type theIndex: int
        :rtype: const TheKeyType &

        """
        res = _BRepFill.NCollection_IndexedDataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_OrientedShapeMapHasher_FindKey(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def FindFromIndex(self, *args):
        """
        FindFromIndex

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _BRepFill.NCollection_IndexedDataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_OrientedShapeMapHasher_FindFromIndex(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFromIndex(self, *args):
        """
        ChangeFromIndex(NCollection_IndexedDataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_OrientedShapeMapHasher self, Standard_Integer const theIndex) -> NCollection_List_TopoDS_Shape

        ChangeFromIndex

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _BRepFill.NCollection_IndexedDataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_OrientedShapeMapHasher_ChangeFromIndex(self, *args)


    def __call__(self, *args):
        """
        operator ()

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _BRepFill.NCollection_IndexedDataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_OrientedShapeMapHasher___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def FindIndex(self, *args):
        """
        FindIndex(NCollection_IndexedDataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_OrientedShapeMapHasher self, TopoDS_Shape theKey1) -> Standard_Integer

        FindIndex

        :type theKey1: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepFill.NCollection_IndexedDataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_OrientedShapeMapHasher_FindIndex(self, *args)


    def ChangeFromKey(self, *args):
        """
        ChangeFromKey(NCollection_IndexedDataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_OrientedShapeMapHasher self, TopoDS_Shape theKey1) -> NCollection_List_TopoDS_Shape

        ChangeFromKey

        :type theKey1: const TheKeyType &
        :rtype: TheItemType &

        """
        return _BRepFill.NCollection_IndexedDataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_OrientedShapeMapHasher_ChangeFromKey(self, *args)


    def Seek(self, *args):
        """
        Seek(NCollection_IndexedDataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_OrientedShapeMapHasher self, TopoDS_Shape theKey1) -> NCollection_List_TopoDS_Shape

        Seek returns pointer to Item by Key. Returns
        NULL if Key was not found.

        :type theKey1: const TheKeyType &
        :rtype: const TheItemType *

        """
        return _BRepFill.NCollection_IndexedDataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_OrientedShapeMapHasher_Seek(self, *args)


    def ChangeSeek(self, *args):
        """
        ChangeSeek(NCollection_IndexedDataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_OrientedShapeMapHasher self, TopoDS_Shape theKey1) -> NCollection_List_TopoDS_Shape

        ChangeSeek returns modifiable pointer to Item by Key. Returns
        NULL if Key was not found.

        :type theKey1: const TheKeyType &
        :rtype: TheItemType *

        """
        return _BRepFill.NCollection_IndexedDataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_OrientedShapeMapHasher_ChangeSeek(self, *args)


    def FindFromKey(self, *args):
        """
        FindFromKey

        :type theKey1: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _BRepFill.NCollection_IndexedDataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_OrientedShapeMapHasher_FindFromKey(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Clear(self, *args):
        """
        Clear(NCollection_IndexedDataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_OrientedShapeMapHasher self, Standard_Boolean const doReleaseMemory)
        Clear(NCollection_IndexedDataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_OrientedShapeMapHasher self, Handle_NCollection_BaseAllocator theAllocator)

        Clear data and reset allocator

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _BRepFill.NCollection_IndexedDataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_OrientedShapeMapHasher_Clear(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_IndexedDataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_OrientedShapeMapHasher self) -> Standard_Integer

        Size

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepFill.NCollection_IndexedDataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_OrientedShapeMapHasher_Size(self, *args)


    def __iter__(self):
        return _BRepFill.NCollection_IndexedDataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_OrientedShapeMapHasher___iter__(self)
    __swig_destroy__ = _BRepFill.delete_NCollection_IndexedDataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_OrientedShapeMapHasher
NCollection_IndexedDataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_OrientedShapeMapHasher_swigregister = _BRepFill.NCollection_IndexedDataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_OrientedShapeMapHasher_swigregister
NCollection_IndexedDataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_OrientedShapeMapHasher_swigregister(NCollection_IndexedDataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_OrientedShapeMapHasher)

class NCollection_IndexedDataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_OrientedShapeMapHasher_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _BRepFill.new_NCollection_IndexedDataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_OrientedShapeMapHasher_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _BRepFill.delete_NCollection_IndexedDataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_OrientedShapeMapHasher_IteratorHelper

    def __next__(self):
        return _BRepFill.NCollection_IndexedDataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_OrientedShapeMapHasher_IteratorHelper___next__(self)
NCollection_IndexedDataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_OrientedShapeMapHasher_IteratorHelper_swigregister = _BRepFill.NCollection_IndexedDataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_OrientedShapeMapHasher_IteratorHelper_swigregister
NCollection_IndexedDataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_OrientedShapeMapHasher_IteratorHelper_swigregister(NCollection_IndexedDataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_OrientedShapeMapHasher_IteratorHelper)


try:
	BRepFill_IndexedDataMapOfOrientedShapeListOfShape = NCollection_IndexedDataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_OrientedShapeMapHasher
except NameError:
	pass # does not exist, probably ignored

class BRepFill_CompatibleWires(object):
    """
    Constructs a sequence of Wires (with good orientation
    and origin) agreed each other so that the surface passing
    through these sections is not twisted
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BRepFill_CompatibleWires self) -> BRepFill_CompatibleWires
        __init__(BRepFill_CompatibleWires self, NCollection_Sequence_TopoDS_Shape Sections) -> BRepFill_CompatibleWires

        :type Sections: OCC.wrapper.TopTools.TopTools_SequenceOfShape

        """
        this = _BRepFill.new_BRepFill_CompatibleWires(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(BRepFill_CompatibleWires self, NCollection_Sequence_TopoDS_Shape Sections)

        :type Sections: OCC.wrapper.TopTools.TopTools_SequenceOfShape

        """
        return _BRepFill.BRepFill_CompatibleWires_Init(self, *args)


    def SetPercent(self, *args):
        """
        SetPercent(BRepFill_CompatibleWires self, Standard_Real const percent=0.01)

        :type percent: float

        """
        return _BRepFill.BRepFill_CompatibleWires_SetPercent(self, *args)


    def Perform(self, *args):
        """
        Perform(BRepFill_CompatibleWires self, Standard_Boolean const WithRotation)

        Performs  CompatibleWires According  to  the orientation
        and the origin of  each other

        :type WithRotation: bool

        """
        return _BRepFill.BRepFill_CompatibleWires_Perform(self, *args)


    def IsDone(self, *args):
        """
        IsDone(BRepFill_CompatibleWires self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepFill.BRepFill_CompatibleWires_IsDone(self, *args)


    def Shape(self, *args):
        """
        returns the generated sequence.

        :rtype: OCC.wrapper.TopTools.TopTools_SequenceOfShape

        """
        res = _BRepFill.BRepFill_CompatibleWires_Shape(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def GeneratedShapes(self, *args):
        """
        Returns   the  shapes  created  from   a  subshape
        <SubSection> of a section.

        :type SubSection: OCC.wrapper.TopoDS.TopoDS_Edge
        :rtype: OCC.wrapper.TopTools.TopTools_ListOfShape

        """
        res = _BRepFill.BRepFill_CompatibleWires_GeneratedShapes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Generated(self, *args):
        """
        :rtype: OCC.wrapper.TopTools.TopTools_DataMapOfShapeListOfShape

        """
        res = _BRepFill.BRepFill_CompatibleWires_Generated(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def IsDegeneratedFirstSection(self, *args):
        """
        IsDegeneratedFirstSection(BRepFill_CompatibleWires self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepFill.BRepFill_CompatibleWires_IsDegeneratedFirstSection(self, *args)


    def IsDegeneratedLastSection(self, *args):
        """
        IsDegeneratedLastSection(BRepFill_CompatibleWires self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepFill.BRepFill_CompatibleWires_IsDegeneratedLastSection(self, *args)

    __swig_destroy__ = _BRepFill.delete_BRepFill_CompatibleWires
BRepFill_CompatibleWires_swigregister = _BRepFill.BRepFill_CompatibleWires_swigregister
BRepFill_CompatibleWires_swigregister(BRepFill_CompatibleWires)


try:
	TopTools_DataMapOfShapeShape = TopTools.NCollection_DataMap_TopoDS_Shape_TopoDS_Shape_TopTools_ShapeMapHasher
except AttributeError:
	pass # does not exist, probably ignored

class NCollection_Sequence_BRepFill_FaceAndOrder(NCollection.NCollection_BaseSequence):
    """
    Purpose:     Definition of a sequence of elements indexed by
    an Integer in range of 1..n
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Sequence_BRepFill_FaceAndOrder self) -> NCollection_Sequence< BRepFill_FaceAndOrder >::iterator

        Returns an iterator pointing to the first element in the sequence.

        :rtype: iterator

        """
        return _BRepFill.NCollection_Sequence_BRepFill_FaceAndOrder_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Sequence_BRepFill_FaceAndOrder self) -> NCollection_Sequence< BRepFill_FaceAndOrder >::iterator

        Returns an iterator referring to the past-the-end element in the sequence.

        :rtype: iterator

        """
        return _BRepFill.NCollection_Sequence_BRepFill_FaceAndOrder_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Sequence_BRepFill_FaceAndOrder self) -> NCollection_Sequence< BRepFill_FaceAndOrder >::const_iterator

        Returns a const iterator pointing to the first element in the sequence.

        :rtype: const_iterator

        """
        return _BRepFill.NCollection_Sequence_BRepFill_FaceAndOrder_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Sequence_BRepFill_FaceAndOrder self) -> NCollection_Sequence< BRepFill_FaceAndOrder >::const_iterator

        Returns a const iterator referring to the past-the-end element in the sequence.

        :rtype: const_iterator

        """
        return _BRepFill.NCollection_Sequence_BRepFill_FaceAndOrder_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     Definition of a sequence of elements indexed by
        an Integer in range of 1..n
        """
        this = _BRepFill.new_NCollection_Sequence_BRepFill_FaceAndOrder(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Size(self, *args):
        """
        Size(NCollection_Sequence_BRepFill_FaceAndOrder self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepFill.NCollection_Sequence_BRepFill_FaceAndOrder_Size(self, *args)


    def Length(self, *args):
        """
        Length(NCollection_Sequence_BRepFill_FaceAndOrder self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepFill.NCollection_Sequence_BRepFill_FaceAndOrder_Length(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Sequence_BRepFill_FaceAndOrder self) -> Standard_Integer

        Method for consistency with other collections.
        @return Lower bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepFill.NCollection_Sequence_BRepFill_FaceAndOrder_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Sequence_BRepFill_FaceAndOrder self) -> Standard_Integer

        Method for consistency with other collections.
        @return Upper bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepFill.NCollection_Sequence_BRepFill_FaceAndOrder_Upper(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Sequence_BRepFill_FaceAndOrder self) -> Standard_Boolean

        Empty query

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepFill.NCollection_Sequence_BRepFill_FaceAndOrder_IsEmpty(self, *args)


    def Reverse(self, *args):
        """
        Reverse(NCollection_Sequence_BRepFill_FaceAndOrder self)

        Reverse sequence


        """
        return _BRepFill.NCollection_Sequence_BRepFill_FaceAndOrder_Reverse(self, *args)


    def Exchange(self, *args):
        """
        Exchange(NCollection_Sequence_BRepFill_FaceAndOrder self, Standard_Integer const I, Standard_Integer const J)

        Exchange two members

        :type I: int
        :type J: int

        """
        return _BRepFill.NCollection_Sequence_BRepFill_FaceAndOrder_Exchange(self, *args)


    def delNode(*args):
        """
        delNode(NCollection_SeqNode theNode, Handle_NCollection_BaseAllocator theAl)

        Static deleter to be passed to BaseSequence

        :type theNode: OCC.wrapper.NCollection.NCollection_SeqNode
        :type theAl: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _BRepFill.NCollection_Sequence_BRepFill_FaceAndOrder_delNode(*args)

    delNode = staticmethod(delNode)

    def Clear(self, *args):
        """
        Clear(NCollection_Sequence_BRepFill_FaceAndOrder self, Handle_NCollection_BaseAllocator theAllocator=0)

        Clear the items out, take a new allocator if non null

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _BRepFill.NCollection_Sequence_BRepFill_FaceAndOrder_Clear(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Sequence_BRepFill_FaceAndOrder self, NCollection_Sequence_BRepFill_FaceAndOrder theOther) -> NCollection_Sequence_BRepFill_FaceAndOrder

        Replace this sequence by the items of theOther.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_Sequence
        :rtype: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _BRepFill.NCollection_Sequence_BRepFill_FaceAndOrder_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Sequence_BRepFill_FaceAndOrder self, NCollection_Sequence_BRepFill_FaceAndOrder theOther) -> NCollection_Sequence_BRepFill_FaceAndOrder

        Replacement operator

        :type theOther: OCC.wrapper.NCollection.NCollection_Sequence
        :rtype: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _BRepFill.NCollection_Sequence_BRepFill_FaceAndOrder_assign(self, *args)


    def Remove(self, *args):
        """
        Remove(NCollection_Sequence_BRepFill_FaceAndOrder self, NCollection_Sequence< BRepFill_FaceAndOrder >::Iterator & thePosition)
        Remove(NCollection_Sequence_BRepFill_FaceAndOrder self, Standard_Integer const theIndex)
        Remove(NCollection_Sequence_BRepFill_FaceAndOrder self, Standard_Integer const theFromIndex, Standard_Integer const theToIndex)

        Remove range of items

        :type theFromIndex: int
        :type theToIndex: int

        """
        return _BRepFill.NCollection_Sequence_BRepFill_FaceAndOrder_Remove(self, *args)


    def Append(self, *args):
        """
        Append(NCollection_Sequence_BRepFill_FaceAndOrder self, BRepFill_FaceAndOrder theItem)
        Append(NCollection_Sequence_BRepFill_FaceAndOrder self, NCollection_Sequence_BRepFill_FaceAndOrder theSeq)

        Append another sequence (making it empty)

        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _BRepFill.NCollection_Sequence_BRepFill_FaceAndOrder_Append(self, *args)


    def Prepend(self, *args):
        """
        Prepend(NCollection_Sequence_BRepFill_FaceAndOrder self, BRepFill_FaceAndOrder theItem)
        Prepend(NCollection_Sequence_BRepFill_FaceAndOrder self, NCollection_Sequence_BRepFill_FaceAndOrder theSeq)

        Prepend another sequence (making it empty)

        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _BRepFill.NCollection_Sequence_BRepFill_FaceAndOrder_Prepend(self, *args)


    def InsertBefore(self, *args):
        """
        InsertBefore(NCollection_Sequence_BRepFill_FaceAndOrder self, Standard_Integer const theIndex, BRepFill_FaceAndOrder theItem)
        InsertBefore(NCollection_Sequence_BRepFill_FaceAndOrder self, Standard_Integer const theIndex, NCollection_Sequence_BRepFill_FaceAndOrder theSeq)

        InsertBefore theIndex another sequence

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _BRepFill.NCollection_Sequence_BRepFill_FaceAndOrder_InsertBefore(self, *args)


    def InsertAfter(self, *args):
        """
        InsertAfter(NCollection_Sequence_BRepFill_FaceAndOrder self, NCollection_Sequence< BRepFill_FaceAndOrder >::Iterator & thePosition, BRepFill_FaceAndOrder theItem)
        InsertAfter(NCollection_Sequence_BRepFill_FaceAndOrder self, Standard_Integer const theIndex, NCollection_Sequence_BRepFill_FaceAndOrder theSeq)
        InsertAfter(NCollection_Sequence_BRepFill_FaceAndOrder self, Standard_Integer const theIndex, BRepFill_FaceAndOrder theItem)

        InsertAfter theIndex another sequence

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _BRepFill.NCollection_Sequence_BRepFill_FaceAndOrder_InsertAfter(self, *args)


    def Split(self, *args):
        """
        Split(NCollection_Sequence_BRepFill_FaceAndOrder self, Standard_Integer const theIndex, NCollection_Sequence_BRepFill_FaceAndOrder theSeq)

        Split in two sequences

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _BRepFill.NCollection_Sequence_BRepFill_FaceAndOrder_Split(self, *args)


    def First(self, *args):
        """
        First item access

        :rtype: const TheItemType &

        """
        res = _BRepFill.NCollection_Sequence_BRepFill_FaceAndOrder_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Sequence_BRepFill_FaceAndOrder self) -> BRepFill_FaceAndOrder

        First item access

        :rtype: TheItemType &

        """
        return _BRepFill.NCollection_Sequence_BRepFill_FaceAndOrder_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        Last item access

        :rtype: const TheItemType &

        """
        res = _BRepFill.NCollection_Sequence_BRepFill_FaceAndOrder_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Sequence_BRepFill_FaceAndOrder self) -> BRepFill_FaceAndOrder

        Last item access

        :rtype: TheItemType &

        """
        return _BRepFill.NCollection_Sequence_BRepFill_FaceAndOrder_ChangeLast(self, *args)


    def Value(self, *args):
        """
        Constant item access by theIndex

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _BRepFill.NCollection_Sequence_BRepFill_FaceAndOrder_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Sequence_BRepFill_FaceAndOrder self, Standard_Integer const theIndex) -> BRepFill_FaceAndOrder

        Variable item access by theIndex

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _BRepFill.NCollection_Sequence_BRepFill_FaceAndOrder_ChangeValue(self, *args)


    def __call__(self, *args):
        """
        Constant operator()

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _BRepFill.NCollection_Sequence_BRepFill_FaceAndOrder___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetValue(self, *args):
        """
        SetValue(NCollection_Sequence_BRepFill_FaceAndOrder self, Standard_Integer const theIndex, BRepFill_FaceAndOrder theItem)

        Set item value by theIndex

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _BRepFill.NCollection_Sequence_BRepFill_FaceAndOrder_SetValue(self, *args)


    def __iter__(self):
        return _BRepFill.NCollection_Sequence_BRepFill_FaceAndOrder___iter__(self)
    __swig_destroy__ = _BRepFill.delete_NCollection_Sequence_BRepFill_FaceAndOrder
NCollection_Sequence_BRepFill_FaceAndOrder_swigregister = _BRepFill.NCollection_Sequence_BRepFill_FaceAndOrder_swigregister
NCollection_Sequence_BRepFill_FaceAndOrder_swigregister(NCollection_Sequence_BRepFill_FaceAndOrder)

def NCollection_Sequence_BRepFill_FaceAndOrder_delNode(*args):
    """
    NCollection_Sequence_BRepFill_FaceAndOrder_delNode(NCollection_SeqNode theNode, Handle_NCollection_BaseAllocator theAl)

    Static deleter to be passed to BaseSequence

    :type theNode: OCC.wrapper.NCollection.NCollection_SeqNode
    :type theAl: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

    """
    return _BRepFill.NCollection_Sequence_BRepFill_FaceAndOrder_delNode(*args)

class NCollection_Sequence_BRepFill_FaceAndOrder_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _BRepFill.new_NCollection_Sequence_BRepFill_FaceAndOrder_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _BRepFill.delete_NCollection_Sequence_BRepFill_FaceAndOrder_IteratorHelper

    def __next__(self):
        return _BRepFill.NCollection_Sequence_BRepFill_FaceAndOrder_IteratorHelper___next__(self)
NCollection_Sequence_BRepFill_FaceAndOrder_IteratorHelper_swigregister = _BRepFill.NCollection_Sequence_BRepFill_FaceAndOrder_IteratorHelper_swigregister
NCollection_Sequence_BRepFill_FaceAndOrder_IteratorHelper_swigregister(NCollection_Sequence_BRepFill_FaceAndOrder_IteratorHelper)


try:
	BRepFill_SequenceOfFaceAndOrder = NCollection_Sequence_BRepFill_FaceAndOrder
except NameError:
	pass # does not exist, probably ignored

class BRepFill_ComputeCLine(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BRepFill_ComputeCLine self, BRepFill_MultiLine Line, Standard_Integer const degreemin=3, Standard_Integer const degreemax=8, Standard_Real const Tolerance3d=1.0e-5, Standard_Real const Tolerance2d=1.0e-5, Standard_Boolean const cutting, AppParCurves_Constraint const FirstC=AppParCurves_TangencyPoint, AppParCurves_Constraint const LastC=AppParCurves_TangencyPoint) -> BRepFill_ComputeCLine
        __init__(BRepFill_ComputeCLine self, Standard_Integer const degreemin=3, Standard_Integer const degreemax=8, Standard_Real const Tolerance3d=1.0e-05, Standard_Real const Tolerance2d=1.0e-05, Standard_Boolean const cutting, AppParCurves_Constraint const FirstC=AppParCurves_TangencyPoint, AppParCurves_Constraint const LastC=AppParCurves_TangencyPoint) -> BRepFill_ComputeCLine

        Initializes the fields of the algorithm.

        :type degreemin: int
        :type degreemax: int
        :type Tolerance3d: float
        :type Tolerance2d: float
        :type cutting: bool
        :type FirstC: OCC.wrapper.AppParCurves.AppParCurves_Constraint
        :type LastC: OCC.wrapper.AppParCurves.AppParCurves_Constraint

        """
        this = _BRepFill.new_BRepFill_ComputeCLine(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Perform(self, *args):
        """
        Perform(BRepFill_ComputeCLine self, BRepFill_MultiLine Line)

        runs the algorithm after having initialized the fields.

        :type Line: OCC.wrapper.BRepFill.BRepFill_MultiLine

        """
        return _BRepFill.BRepFill_ComputeCLine_Perform(self, *args)


    def SetDegrees(self, *args):
        """
        SetDegrees(BRepFill_ComputeCLine self, Standard_Integer const degreemin, Standard_Integer const degreemax)

        changes the degrees of the approximation.

        :type degreemin: int
        :type degreemax: int

        """
        return _BRepFill.BRepFill_ComputeCLine_SetDegrees(self, *args)


    def SetTolerances(self, *args):
        """
        SetTolerances(BRepFill_ComputeCLine self, Standard_Real const Tolerance3d, Standard_Real const Tolerance2d)

        Changes the tolerances of the approximation.

        :type Tolerance3d: float
        :type Tolerance2d: float

        """
        return _BRepFill.BRepFill_ComputeCLine_SetTolerances(self, *args)


    def SetConstraints(self, *args):
        """
        SetConstraints(BRepFill_ComputeCLine self, AppParCurves_Constraint const FirstC, AppParCurves_Constraint const LastC)

        Changes the constraints of the approximation.

        :type FirstC: OCC.wrapper.AppParCurves.AppParCurves_Constraint
        :type LastC: OCC.wrapper.AppParCurves.AppParCurves_Constraint

        """
        return _BRepFill.BRepFill_ComputeCLine_SetConstraints(self, *args)


    def SetMaxSegments(self, *args):
        """
        SetMaxSegments(BRepFill_ComputeCLine self, Standard_Integer const theMaxSegments)

        Changes the max number of segments, which is allowed for cutting.

        :type theMaxSegments: int

        """
        return _BRepFill.BRepFill_ComputeCLine_SetMaxSegments(self, *args)


    def IsAllApproximated(self, *args):
        """
        IsAllApproximated(BRepFill_ComputeCLine self) -> Standard_Boolean

        returns False if at a moment of the approximation,
        the status NoApproximation has been sent by the user
        when more points were needed.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepFill.BRepFill_ComputeCLine_IsAllApproximated(self, *args)


    def IsToleranceReached(self, *args):
        """
        IsToleranceReached(BRepFill_ComputeCLine self) -> Standard_Boolean

        returns False if the status NoPointsAdded has been sent.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepFill.BRepFill_ComputeCLine_IsToleranceReached(self, *args)


    def Error(self, *args):
        """
        Error(BRepFill_ComputeCLine self, Standard_Integer const Index)

        returns the tolerances 2d and 3d of the <Index> MultiCurve.

        :type Index: int
        :type tol3d: float
        :type tol2d: float

        """
        return _BRepFill.BRepFill_ComputeCLine_Error(self, *args)


    def NbMultiCurves(self, *args):
        """
        NbMultiCurves(BRepFill_ComputeCLine self) -> Standard_Integer

        Returns the number of MultiCurve doing the approximation
        of the MultiLine.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepFill.BRepFill_ComputeCLine_NbMultiCurves(self, *args)


    def Value(self, *args):
        """
        Value(BRepFill_ComputeCLine self, Standard_Integer const Index=1) -> AppParCurves_MultiCurve

        returns the approximation MultiCurve of range <Index>.

        :type Index: int
        :rtype: OCC.wrapper.AppParCurves.AppParCurves_MultiCurve

        """
        return _BRepFill.BRepFill_ComputeCLine_Value(self, *args)


    def Parameters(self, *args):
        """
        Parameters(BRepFill_ComputeCLine self, Standard_Integer const Index)

        :type Index: int
        :type firstp: float
        :type lastp: float

        """
        return _BRepFill.BRepFill_ComputeCLine_Parameters(self, *args)

    __swig_destroy__ = _BRepFill.delete_BRepFill_ComputeCLine
BRepFill_ComputeCLine_swigregister = _BRepFill.BRepFill_ComputeCLine_swigregister
BRepFill_ComputeCLine_swigregister(BRepFill_ComputeCLine)

class BRepFill_Sweep(object):
    """
    Topological Sweep Algorithm
    Computes an  Sweep  shell using a  generating
    wire, an SectionLaw and an LocationLaw.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BRepFill_Sweep self, Handle_BRepFill_SectionLaw Section, Handle_BRepFill_LocationLaw Location, Standard_Boolean const WithKPart) -> BRepFill_Sweep

        :type Section: OCC.wrapper.BRepFill.Handle_BRepFill_SectionLaw
        :type Location: OCC.wrapper.BRepFill.Handle_BRepFill_LocationLaw
        :type WithKPart: bool

        """
        this = _BRepFill.new_BRepFill_Sweep(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def SetBounds(self, *args):
        """
        SetBounds(BRepFill_Sweep self, TopoDS_Wire FirstShape, TopoDS_Wire LastShape)

        :type FirstShape: OCC.wrapper.TopoDS.TopoDS_Wire
        :type LastShape: OCC.wrapper.TopoDS.TopoDS_Wire

        """
        return _BRepFill.BRepFill_Sweep_SetBounds(self, *args)


    def SetTolerance(self, *args):
        """
        SetTolerance(BRepFill_Sweep self, Standard_Real const Tol3d, Standard_Real const BoundTol=1.0, Standard_Real const Tol2d=1.0e-5, Standard_Real const TolAngular=1.0e-2)

        Set Approximation Tolerance
        Tol3d : Tolerance to surface approximation
        Tol2d : Tolerance used to perform curve approximation
        Normaly the 2d curve are approximated with a
        tolerance given by the resolution on support surfaces,
        but if this tolerance is too large Tol2d is used.
        TolAngular : Tolerance (in radian) to control the angle
        beetween tangents on the section law and
        tangent of iso-v on approximed surface

        :type Tol3d: float
        :type BoundTol: float
        :type Tol2d: float
        :type TolAngular: float

        """
        return _BRepFill.BRepFill_Sweep_SetTolerance(self, *args)


    def SetAngularControl(self, *args):
        """
        SetAngularControl(BRepFill_Sweep self, Standard_Real const AngleMin=0.01, Standard_Real const AngleMax=6.0)

        Tolerance  To controle Corner management.

        If the discontinuity is lesser than <AngleMin> in radian The
        Transition Performed will be alway "Modified"

        :type AngleMin: float
        :type AngleMax: float

        """
        return _BRepFill.BRepFill_Sweep_SetAngularControl(self, *args)


    def SetForceApproxC1(self, *args):
        """
        SetForceApproxC1(BRepFill_Sweep self, Standard_Boolean const ForceApproxC1)

        Set the flag that indicates attempt to approximate
        a C1-continuous surface if a swept surface proved
        to be C0.

        :type ForceApproxC1: bool

        """
        return _BRepFill.BRepFill_Sweep_SetForceApproxC1(self, *args)


    def Build(self, *args):
        """
        Build(BRepFill_Sweep self, NCollection_Map_TopoDS_Shape_TopTools_ShapeMapHasher ReversedEdges, NCollection_DataMap_TopoDS_Shape_Handle_TopTools_HArray2OfShape_TopTools_ShapeMapHasher Tapes, NCollection_DataMap_TopoDS_Shape_Handle_TopTools_HArray2OfShape_TopTools_ShapeMapHasher Rails, BRepFill_TransitionStyle const Transition=BRepFill_Modified, GeomAbs_Shape const Continuity=GeomAbs_C2, GeomFill_ApproxStyle const Approx=GeomFill_Location, Standard_Integer const Degmax=11, Standard_Integer const Segmax=30)

        Build the Sweeep  Surface
        Transition define Transition strategy
        Approx define Approximation Strategy
        - GeomFill_Section : The composed Function Location X Section
        is directly approximed.
        - GeomFill_Location : The location law is approximed, and the
        SweepSurface is bulid algebric composition
        of approximed location law and section law
        This option is Ok, if Section.Surface() methode
        is effective.
        Continuity : The continuity in v waiting on the surface
        Degmax     : The maximum degree in v requiered on the surface
        Segmax     : The maximum number of span in v requiered on
        the surface.

        :type ReversedEdges: OCC.wrapper.TopTools.TopTools_MapOfShape
        :type Tapes: OCC.wrapper.BRepFill.BRepFill_DataMapOfShapeHArray2OfShape
        :type Rails: OCC.wrapper.BRepFill.BRepFill_DataMapOfShapeHArray2OfShape
        :type Transition: OCC.wrapper.BRepFill.BRepFill_TransitionStyle
        :type Continuity: OCC.wrapper.GeomAbs.GeomAbs_Shape
        :type Approx: OCC.wrapper.GeomFill.GeomFill_ApproxStyle
        :type Degmax: int
        :type Segmax: int

        """
        return _BRepFill.BRepFill_Sweep_Build(self, *args)


    def IsDone(self, *args):
        """
        IsDone(BRepFill_Sweep self) -> Standard_Boolean

        Say if the Shape is Build.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepFill.BRepFill_Sweep_IsDone(self, *args)


    def Shape(self, *args):
        """
        Shape(BRepFill_Sweep self) -> TopoDS_Shape

        returns the Sweeping Shape

        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _BRepFill.BRepFill_Sweep_Shape(self, *args)


    def ErrorOnSurface(self, *args):
        """
        ErrorOnSurface(BRepFill_Sweep self) -> Standard_Real

        Get the Approximation  error.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _BRepFill.BRepFill_Sweep_ErrorOnSurface(self, *args)


    def SubShape(self, *args):
        """
        SubShape(BRepFill_Sweep self) -> Handle_TopTools_HArray2OfShape

        :rtype: OCC.wrapper.TopTools.Handle_TopTools_HArray2OfShape

        """
        return _BRepFill.BRepFill_Sweep_SubShape(self, *args)


    def InterFaces(self, *args):
        """
        InterFaces(BRepFill_Sweep self) -> Handle_TopTools_HArray2OfShape

        :rtype: OCC.wrapper.TopTools.Handle_TopTools_HArray2OfShape

        """
        return _BRepFill.BRepFill_Sweep_InterFaces(self, *args)


    def Sections(self, *args):
        """
        Sections(BRepFill_Sweep self) -> Handle_TopTools_HArray2OfShape

        :rtype: OCC.wrapper.TopTools.Handle_TopTools_HArray2OfShape

        """
        return _BRepFill.BRepFill_Sweep_Sections(self, *args)


    def Tape(self, *args):
        """
        Tape(BRepFill_Sweep self, Standard_Integer const Index) -> TopoDS_Shape

        returns the Tape corresponding to Index-th edge of section

        :type Index: int
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _BRepFill.BRepFill_Sweep_Tape(self, *args)

    __swig_destroy__ = _BRepFill.delete_BRepFill_Sweep
BRepFill_Sweep_swigregister = _BRepFill.BRepFill_Sweep_swigregister
BRepFill_Sweep_swigregister(BRepFill_Sweep)

class BRepFill_Generator(object):
    """
    Compute a topological surface ( a  shell) using
    generating wires. The face of the shell will be
    ruled surfaces passing by the wires.
    The wires must have the same number of edges.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BRepFill_Generator self) -> BRepFill_Generator

        Compute a topological surface ( a  shell) using
        generating wires. The face of the shell will be
        ruled surfaces passing by the wires.
        The wires must have the same number of edges.
        """
        this = _BRepFill.new_BRepFill_Generator(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def AddWire(self, *args):
        """
        AddWire(BRepFill_Generator self, TopoDS_Wire Wire)

        :type Wire: OCC.wrapper.TopoDS.TopoDS_Wire

        """
        return _BRepFill.BRepFill_Generator_AddWire(self, *args)


    def Perform(self, *args):
        """
        Perform(BRepFill_Generator self)

        Compute the  shell.


        """
        return _BRepFill.BRepFill_Generator_Perform(self, *args)


    def Shell(self, *args):
        """
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shell

        """
        res = _BRepFill.BRepFill_Generator_Shell(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Generated(self, *args):
        """
        Returns  all   the shapes created

        :rtype: OCC.wrapper.TopTools.TopTools_DataMapOfShapeListOfShape

        """
        res = _BRepFill.BRepFill_Generator_Generated(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def GeneratedShapes(self, *args):
        """
        Returns   the  shapes  created  from   a  subshape
        <SSection>  of a  section.

        :type SSection: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.TopTools.TopTools_ListOfShape

        """
        res = _BRepFill.BRepFill_Generator_GeneratedShapes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _BRepFill.delete_BRepFill_Generator
BRepFill_Generator_swigregister = _BRepFill.BRepFill_Generator_swigregister
BRepFill_Generator_swigregister(BRepFill_Generator)

class NCollection_List_BRepFill_OffsetWire_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _BRepFill.new_NCollection_List_BRepFill_OffsetWire_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _BRepFill.delete_NCollection_List_BRepFill_OffsetWire_IteratorHelper

    def __next__(self):
        return _BRepFill.NCollection_List_BRepFill_OffsetWire_IteratorHelper___next__(self)
NCollection_List_BRepFill_OffsetWire_IteratorHelper_swigregister = _BRepFill.NCollection_List_BRepFill_OffsetWire_IteratorHelper_swigregister
NCollection_List_BRepFill_OffsetWire_IteratorHelper_swigregister(NCollection_List_BRepFill_OffsetWire_IteratorHelper)


try:
	BRepFill_ListOfOffsetWire = NCollection_List_BRepFill_OffsetWire
except NameError:
	pass # does not exist, probably ignored

class BRepFill_ApproxSeewing(object):
    """
    Evaluate the 3dCurve  and the PCurves described in
    a MultiLine from BRepFill.  The parametrization of
    those curves is  not  imposed by  the Bissectrice.
    The  parametrization  is given  approximatively by
    the abscissa of the curve3d.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BRepFill_ApproxSeewing self) -> BRepFill_ApproxSeewing
        __init__(BRepFill_ApproxSeewing self, BRepFill_MultiLine ML) -> BRepFill_ApproxSeewing

        :type ML: OCC.wrapper.BRepFill.BRepFill_MultiLine

        """
        this = _BRepFill.new_BRepFill_ApproxSeewing(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Perform(self, *args):
        """
        Perform(BRepFill_ApproxSeewing self, BRepFill_MultiLine ML)

        :type ML: OCC.wrapper.BRepFill.BRepFill_MultiLine

        """
        return _BRepFill.BRepFill_ApproxSeewing_Perform(self, *args)


    def IsDone(self, *args):
        """
        IsDone(BRepFill_ApproxSeewing self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepFill.BRepFill_ApproxSeewing_IsDone(self, *args)


    def Curve(self, *args):
        """
        returns the approximation of the 3d Curve

        :rtype: OCC.wrapper.Geom.Handle_Geom_Curve

        """
        res = _BRepFill.BRepFill_ApproxSeewing_Curve(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def CurveOnF1(self, *args):
        """
        returns the  approximation  of the  PCurve  on the
        first face of the MultiLine

        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Curve

        """
        res = _BRepFill.BRepFill_ApproxSeewing_CurveOnF1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def CurveOnF2(self, *args):
        """
        returns the  approximation  of the  PCurve  on the
        first face of the MultiLine

        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Curve

        """
        res = _BRepFill.BRepFill_ApproxSeewing_CurveOnF2(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _BRepFill.delete_BRepFill_ApproxSeewing
BRepFill_ApproxSeewing_swigregister = _BRepFill.BRepFill_ApproxSeewing_swigregister
BRepFill_ApproxSeewing_swigregister(BRepFill_ApproxSeewing)

class NCollection_Sequence_BRepFill_EdgeFaceAndOrder(NCollection.NCollection_BaseSequence):
    """
    Purpose:     Definition of a sequence of elements indexed by
    an Integer in range of 1..n
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Sequence_BRepFill_EdgeFaceAndOrder self) -> NCollection_Sequence< BRepFill_EdgeFaceAndOrder >::iterator

        Returns an iterator pointing to the first element in the sequence.

        :rtype: iterator

        """
        return _BRepFill.NCollection_Sequence_BRepFill_EdgeFaceAndOrder_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Sequence_BRepFill_EdgeFaceAndOrder self) -> NCollection_Sequence< BRepFill_EdgeFaceAndOrder >::iterator

        Returns an iterator referring to the past-the-end element in the sequence.

        :rtype: iterator

        """
        return _BRepFill.NCollection_Sequence_BRepFill_EdgeFaceAndOrder_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Sequence_BRepFill_EdgeFaceAndOrder self) -> NCollection_Sequence< BRepFill_EdgeFaceAndOrder >::const_iterator

        Returns a const iterator pointing to the first element in the sequence.

        :rtype: const_iterator

        """
        return _BRepFill.NCollection_Sequence_BRepFill_EdgeFaceAndOrder_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Sequence_BRepFill_EdgeFaceAndOrder self) -> NCollection_Sequence< BRepFill_EdgeFaceAndOrder >::const_iterator

        Returns a const iterator referring to the past-the-end element in the sequence.

        :rtype: const_iterator

        """
        return _BRepFill.NCollection_Sequence_BRepFill_EdgeFaceAndOrder_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     Definition of a sequence of elements indexed by
        an Integer in range of 1..n
        """
        this = _BRepFill.new_NCollection_Sequence_BRepFill_EdgeFaceAndOrder(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Size(self, *args):
        """
        Size(NCollection_Sequence_BRepFill_EdgeFaceAndOrder self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepFill.NCollection_Sequence_BRepFill_EdgeFaceAndOrder_Size(self, *args)


    def Length(self, *args):
        """
        Length(NCollection_Sequence_BRepFill_EdgeFaceAndOrder self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepFill.NCollection_Sequence_BRepFill_EdgeFaceAndOrder_Length(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Sequence_BRepFill_EdgeFaceAndOrder self) -> Standard_Integer

        Method for consistency with other collections.
        @return Lower bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepFill.NCollection_Sequence_BRepFill_EdgeFaceAndOrder_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Sequence_BRepFill_EdgeFaceAndOrder self) -> Standard_Integer

        Method for consistency with other collections.
        @return Upper bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepFill.NCollection_Sequence_BRepFill_EdgeFaceAndOrder_Upper(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Sequence_BRepFill_EdgeFaceAndOrder self) -> Standard_Boolean

        Empty query

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepFill.NCollection_Sequence_BRepFill_EdgeFaceAndOrder_IsEmpty(self, *args)


    def Reverse(self, *args):
        """
        Reverse(NCollection_Sequence_BRepFill_EdgeFaceAndOrder self)

        Reverse sequence


        """
        return _BRepFill.NCollection_Sequence_BRepFill_EdgeFaceAndOrder_Reverse(self, *args)


    def Exchange(self, *args):
        """
        Exchange(NCollection_Sequence_BRepFill_EdgeFaceAndOrder self, Standard_Integer const I, Standard_Integer const J)

        Exchange two members

        :type I: int
        :type J: int

        """
        return _BRepFill.NCollection_Sequence_BRepFill_EdgeFaceAndOrder_Exchange(self, *args)


    def delNode(*args):
        """
        delNode(NCollection_SeqNode theNode, Handle_NCollection_BaseAllocator theAl)

        Static deleter to be passed to BaseSequence

        :type theNode: OCC.wrapper.NCollection.NCollection_SeqNode
        :type theAl: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _BRepFill.NCollection_Sequence_BRepFill_EdgeFaceAndOrder_delNode(*args)

    delNode = staticmethod(delNode)

    def Clear(self, *args):
        """
        Clear(NCollection_Sequence_BRepFill_EdgeFaceAndOrder self, Handle_NCollection_BaseAllocator theAllocator=0)

        Clear the items out, take a new allocator if non null

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _BRepFill.NCollection_Sequence_BRepFill_EdgeFaceAndOrder_Clear(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Sequence_BRepFill_EdgeFaceAndOrder self, NCollection_Sequence_BRepFill_EdgeFaceAndOrder theOther) -> NCollection_Sequence_BRepFill_EdgeFaceAndOrder

        Replace this sequence by the items of theOther.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_Sequence
        :rtype: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _BRepFill.NCollection_Sequence_BRepFill_EdgeFaceAndOrder_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Sequence_BRepFill_EdgeFaceAndOrder self, NCollection_Sequence_BRepFill_EdgeFaceAndOrder theOther) -> NCollection_Sequence_BRepFill_EdgeFaceAndOrder

        Replacement operator

        :type theOther: OCC.wrapper.NCollection.NCollection_Sequence
        :rtype: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _BRepFill.NCollection_Sequence_BRepFill_EdgeFaceAndOrder_assign(self, *args)


    def Remove(self, *args):
        """
        Remove(NCollection_Sequence_BRepFill_EdgeFaceAndOrder self, NCollection_Sequence< BRepFill_EdgeFaceAndOrder >::Iterator & thePosition)
        Remove(NCollection_Sequence_BRepFill_EdgeFaceAndOrder self, Standard_Integer const theIndex)
        Remove(NCollection_Sequence_BRepFill_EdgeFaceAndOrder self, Standard_Integer const theFromIndex, Standard_Integer const theToIndex)

        Remove range of items

        :type theFromIndex: int
        :type theToIndex: int

        """
        return _BRepFill.NCollection_Sequence_BRepFill_EdgeFaceAndOrder_Remove(self, *args)


    def Append(self, *args):
        """
        Append(NCollection_Sequence_BRepFill_EdgeFaceAndOrder self, BRepFill_EdgeFaceAndOrder theItem)
        Append(NCollection_Sequence_BRepFill_EdgeFaceAndOrder self, NCollection_Sequence_BRepFill_EdgeFaceAndOrder theSeq)

        Append another sequence (making it empty)

        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _BRepFill.NCollection_Sequence_BRepFill_EdgeFaceAndOrder_Append(self, *args)


    def Prepend(self, *args):
        """
        Prepend(NCollection_Sequence_BRepFill_EdgeFaceAndOrder self, BRepFill_EdgeFaceAndOrder theItem)
        Prepend(NCollection_Sequence_BRepFill_EdgeFaceAndOrder self, NCollection_Sequence_BRepFill_EdgeFaceAndOrder theSeq)

        Prepend another sequence (making it empty)

        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _BRepFill.NCollection_Sequence_BRepFill_EdgeFaceAndOrder_Prepend(self, *args)


    def InsertBefore(self, *args):
        """
        InsertBefore(NCollection_Sequence_BRepFill_EdgeFaceAndOrder self, Standard_Integer const theIndex, BRepFill_EdgeFaceAndOrder theItem)
        InsertBefore(NCollection_Sequence_BRepFill_EdgeFaceAndOrder self, Standard_Integer const theIndex, NCollection_Sequence_BRepFill_EdgeFaceAndOrder theSeq)

        InsertBefore theIndex another sequence

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _BRepFill.NCollection_Sequence_BRepFill_EdgeFaceAndOrder_InsertBefore(self, *args)


    def InsertAfter(self, *args):
        """
        InsertAfter(NCollection_Sequence_BRepFill_EdgeFaceAndOrder self, NCollection_Sequence< BRepFill_EdgeFaceAndOrder >::Iterator & thePosition, BRepFill_EdgeFaceAndOrder theItem)
        InsertAfter(NCollection_Sequence_BRepFill_EdgeFaceAndOrder self, Standard_Integer const theIndex, NCollection_Sequence_BRepFill_EdgeFaceAndOrder theSeq)
        InsertAfter(NCollection_Sequence_BRepFill_EdgeFaceAndOrder self, Standard_Integer const theIndex, BRepFill_EdgeFaceAndOrder theItem)

        InsertAfter theIndex another sequence

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _BRepFill.NCollection_Sequence_BRepFill_EdgeFaceAndOrder_InsertAfter(self, *args)


    def Split(self, *args):
        """
        Split(NCollection_Sequence_BRepFill_EdgeFaceAndOrder self, Standard_Integer const theIndex, NCollection_Sequence_BRepFill_EdgeFaceAndOrder theSeq)

        Split in two sequences

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _BRepFill.NCollection_Sequence_BRepFill_EdgeFaceAndOrder_Split(self, *args)


    def First(self, *args):
        """
        First item access

        :rtype: const TheItemType &

        """
        res = _BRepFill.NCollection_Sequence_BRepFill_EdgeFaceAndOrder_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Sequence_BRepFill_EdgeFaceAndOrder self) -> BRepFill_EdgeFaceAndOrder

        First item access

        :rtype: TheItemType &

        """
        return _BRepFill.NCollection_Sequence_BRepFill_EdgeFaceAndOrder_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        Last item access

        :rtype: const TheItemType &

        """
        res = _BRepFill.NCollection_Sequence_BRepFill_EdgeFaceAndOrder_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Sequence_BRepFill_EdgeFaceAndOrder self) -> BRepFill_EdgeFaceAndOrder

        Last item access

        :rtype: TheItemType &

        """
        return _BRepFill.NCollection_Sequence_BRepFill_EdgeFaceAndOrder_ChangeLast(self, *args)


    def Value(self, *args):
        """
        Constant item access by theIndex

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _BRepFill.NCollection_Sequence_BRepFill_EdgeFaceAndOrder_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Sequence_BRepFill_EdgeFaceAndOrder self, Standard_Integer const theIndex) -> BRepFill_EdgeFaceAndOrder

        Variable item access by theIndex

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _BRepFill.NCollection_Sequence_BRepFill_EdgeFaceAndOrder_ChangeValue(self, *args)


    def __call__(self, *args):
        """
        Constant operator()

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _BRepFill.NCollection_Sequence_BRepFill_EdgeFaceAndOrder___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetValue(self, *args):
        """
        SetValue(NCollection_Sequence_BRepFill_EdgeFaceAndOrder self, Standard_Integer const theIndex, BRepFill_EdgeFaceAndOrder theItem)

        Set item value by theIndex

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _BRepFill.NCollection_Sequence_BRepFill_EdgeFaceAndOrder_SetValue(self, *args)


    def __iter__(self):
        return _BRepFill.NCollection_Sequence_BRepFill_EdgeFaceAndOrder___iter__(self)
    __swig_destroy__ = _BRepFill.delete_NCollection_Sequence_BRepFill_EdgeFaceAndOrder
NCollection_Sequence_BRepFill_EdgeFaceAndOrder_swigregister = _BRepFill.NCollection_Sequence_BRepFill_EdgeFaceAndOrder_swigregister
NCollection_Sequence_BRepFill_EdgeFaceAndOrder_swigregister(NCollection_Sequence_BRepFill_EdgeFaceAndOrder)

def NCollection_Sequence_BRepFill_EdgeFaceAndOrder_delNode(*args):
    """
    NCollection_Sequence_BRepFill_EdgeFaceAndOrder_delNode(NCollection_SeqNode theNode, Handle_NCollection_BaseAllocator theAl)

    Static deleter to be passed to BaseSequence

    :type theNode: OCC.wrapper.NCollection.NCollection_SeqNode
    :type theAl: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

    """
    return _BRepFill.NCollection_Sequence_BRepFill_EdgeFaceAndOrder_delNode(*args)

class NCollection_Sequence_BRepFill_EdgeFaceAndOrder_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _BRepFill.new_NCollection_Sequence_BRepFill_EdgeFaceAndOrder_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _BRepFill.delete_NCollection_Sequence_BRepFill_EdgeFaceAndOrder_IteratorHelper

    def __next__(self):
        return _BRepFill.NCollection_Sequence_BRepFill_EdgeFaceAndOrder_IteratorHelper___next__(self)
NCollection_Sequence_BRepFill_EdgeFaceAndOrder_IteratorHelper_swigregister = _BRepFill.NCollection_Sequence_BRepFill_EdgeFaceAndOrder_IteratorHelper_swigregister
NCollection_Sequence_BRepFill_EdgeFaceAndOrder_IteratorHelper_swigregister(NCollection_Sequence_BRepFill_EdgeFaceAndOrder_IteratorHelper)


try:
	BRepFill_SequenceOfEdgeFaceAndOrder = NCollection_Sequence_BRepFill_EdgeFaceAndOrder
except NameError:
	pass # does not exist, probably ignored

class NCollection_DataMap_TopoDS_Shape_Handle_TopTools_HArray2OfShape_TopTools_ShapeMapHasher(NCollection.NCollection_BaseMap):
    """
    Purpose:     The DataMap is a Map to store keys with associated
    Items. See Map  from NCollection for  a discussion
    about the number of buckets.

    The DataMap can be seen as an extended array where
    the Keys  are the   indices.  For this reason  the
    operator () is defined on DataMap to fetch an Item
    from a Key. So the following syntax can be used :

    anItem = aMap(aKey);
    aMap(aKey) = anItem;

    This analogy has its  limit.   aMap(aKey) = anItem
    can  be done only  if aKey was previously bound to
    an item in the map.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_DataMap_TopoDS_Shape_Handle_TopTools_HArray2OfShape_TopTools_ShapeMapHasher self) -> NCollection_DataMap< TopoDS_Shape,opencascade::handle< TopTools_HArray2OfShape >,TopTools_ShapeMapHasher >::iterator

        Returns an iterator pointing to the first element in the map.

        :rtype: iterator

        """
        return _BRepFill.NCollection_DataMap_TopoDS_Shape_Handle_TopTools_HArray2OfShape_TopTools_ShapeMapHasher_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_DataMap_TopoDS_Shape_Handle_TopTools_HArray2OfShape_TopTools_ShapeMapHasher self) -> NCollection_DataMap< TopoDS_Shape,opencascade::handle< TopTools_HArray2OfShape >,TopTools_ShapeMapHasher >::iterator

        Returns an iterator referring to the past-the-end element in the map.

        :rtype: iterator

        """
        return _BRepFill.NCollection_DataMap_TopoDS_Shape_Handle_TopTools_HArray2OfShape_TopTools_ShapeMapHasher_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_DataMap_TopoDS_Shape_Handle_TopTools_HArray2OfShape_TopTools_ShapeMapHasher self) -> NCollection_DataMap< TopoDS_Shape,opencascade::handle< TopTools_HArray2OfShape >,TopTools_ShapeMapHasher >::const_iterator

        Returns a const iterator pointing to the first element in the map.

        :rtype: const_iterator

        """
        return _BRepFill.NCollection_DataMap_TopoDS_Shape_Handle_TopTools_HArray2OfShape_TopTools_ShapeMapHasher_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_DataMap_TopoDS_Shape_Handle_TopTools_HArray2OfShape_TopTools_ShapeMapHasher self) -> NCollection_DataMap< TopoDS_Shape,opencascade::handle< TopTools_HArray2OfShape >,TopTools_ShapeMapHasher >::const_iterator

        Returns a const iterator referring to the past-the-end element in the map.

        :rtype: const_iterator

        """
        return _BRepFill.NCollection_DataMap_TopoDS_Shape_Handle_TopTools_HArray2OfShape_TopTools_ShapeMapHasher_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     The DataMap is a Map to store keys with associated
        Items. See Map  from NCollection for  a discussion
        about the number of buckets.

        The DataMap can be seen as an extended array where
        the Keys  are the   indices.  For this reason  the
        operator () is defined on DataMap to fetch an Item
        from a Key. So the following syntax can be used :

        anItem = aMap(aKey);
        aMap(aKey) = anItem;

        This analogy has its  limit.   aMap(aKey) = anItem
        can  be done only  if aKey was previously bound to
        an item in the map.
        """
        this = _BRepFill.new_NCollection_DataMap_TopoDS_Shape_Handle_TopTools_HArray2OfShape_TopTools_ShapeMapHasher(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Exchange(self, *args):
        """
        Exchange(NCollection_DataMap_TopoDS_Shape_Handle_TopTools_HArray2OfShape_TopTools_ShapeMapHasher self, NCollection_DataMap_TopoDS_Shape_Handle_TopTools_HArray2OfShape_TopTools_ShapeMapHasher theOther)

        Exchange the content of two maps without re-allocations.
        Notice that allocators will be swapped as well!

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _BRepFill.NCollection_DataMap_TopoDS_Shape_Handle_TopTools_HArray2OfShape_TopTools_ShapeMapHasher_Exchange(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_DataMap_TopoDS_Shape_Handle_TopTools_HArray2OfShape_TopTools_ShapeMapHasher self, NCollection_DataMap_TopoDS_Shape_Handle_TopTools_HArray2OfShape_TopTools_ShapeMapHasher theOther) -> NCollection_DataMap_TopoDS_Shape_Handle_TopTools_HArray2OfShape_TopTools_ShapeMapHasher

        Assignment.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _BRepFill.NCollection_DataMap_TopoDS_Shape_Handle_TopTools_HArray2OfShape_TopTools_ShapeMapHasher_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_DataMap_TopoDS_Shape_Handle_TopTools_HArray2OfShape_TopTools_ShapeMapHasher self, NCollection_DataMap_TopoDS_Shape_Handle_TopTools_HArray2OfShape_TopTools_ShapeMapHasher theOther) -> NCollection_DataMap_TopoDS_Shape_Handle_TopTools_HArray2OfShape_TopTools_ShapeMapHasher

        Assignment operator

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _BRepFill.NCollection_DataMap_TopoDS_Shape_Handle_TopTools_HArray2OfShape_TopTools_ShapeMapHasher_assign(self, *args)


    def ReSize(self, *args):
        """
        ReSize(NCollection_DataMap_TopoDS_Shape_Handle_TopTools_HArray2OfShape_TopTools_ShapeMapHasher self, Standard_Integer const N)

        ReSize

        :type N: int

        """
        return _BRepFill.NCollection_DataMap_TopoDS_Shape_Handle_TopTools_HArray2OfShape_TopTools_ShapeMapHasher_ReSize(self, *args)


    def Bind(self, *args):
        """
        Bind(NCollection_DataMap_TopoDS_Shape_Handle_TopTools_HArray2OfShape_TopTools_ShapeMapHasher self, TopoDS_Shape theKey, Handle_TopTools_HArray2OfShape theItem) -> Standard_Boolean

        Bind binds Item to Key in map.
        @param theKey  key to add/update
        @param theItem new item; overrides value previously bound to the key, if any
        @return Standard_True if Key was not bound already

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepFill.NCollection_DataMap_TopoDS_Shape_Handle_TopTools_HArray2OfShape_TopTools_ShapeMapHasher_Bind(self, *args)


    def Bound(self, *args):
        """
        Bound(NCollection_DataMap_TopoDS_Shape_Handle_TopTools_HArray2OfShape_TopTools_ShapeMapHasher self, TopoDS_Shape theKey, Handle_TopTools_HArray2OfShape theItem) -> Handle_TopTools_HArray2OfShape

        Bound binds Item to Key in map. Returns modifiable Item 

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: TheItemType *

        """
        return _BRepFill.NCollection_DataMap_TopoDS_Shape_Handle_TopTools_HArray2OfShape_TopTools_ShapeMapHasher_Bound(self, *args)


    def IsBound(self, *args):
        """
        IsBound(NCollection_DataMap_TopoDS_Shape_Handle_TopTools_HArray2OfShape_TopTools_ShapeMapHasher self, TopoDS_Shape theKey) -> Standard_Boolean

        IsBound

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepFill.NCollection_DataMap_TopoDS_Shape_Handle_TopTools_HArray2OfShape_TopTools_ShapeMapHasher_IsBound(self, *args)


    def UnBind(self, *args):
        """
        UnBind(NCollection_DataMap_TopoDS_Shape_Handle_TopTools_HArray2OfShape_TopTools_ShapeMapHasher self, TopoDS_Shape theKey) -> Standard_Boolean

        UnBind removes Item Key pair from map

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepFill.NCollection_DataMap_TopoDS_Shape_Handle_TopTools_HArray2OfShape_TopTools_ShapeMapHasher_UnBind(self, *args)


    def Seek(self, *args):
        """
        Seek(NCollection_DataMap_TopoDS_Shape_Handle_TopTools_HArray2OfShape_TopTools_ShapeMapHasher self, TopoDS_Shape theKey) -> Handle_TopTools_HArray2OfShape

        Seek returns pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: const TheItemType *

        """
        return _BRepFill.NCollection_DataMap_TopoDS_Shape_Handle_TopTools_HArray2OfShape_TopTools_ShapeMapHasher_Seek(self, *args)


    def Find(self, *args):
        """
        Find returns the Item for Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _BRepFill.NCollection_DataMap_TopoDS_Shape_Handle_TopTools_HArray2OfShape_TopTools_ShapeMapHasher_Find(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeSeek(self, *args):
        """
        ChangeSeek(NCollection_DataMap_TopoDS_Shape_Handle_TopTools_HArray2OfShape_TopTools_ShapeMapHasher self, TopoDS_Shape theKey) -> Handle_TopTools_HArray2OfShape

        ChangeSeek returns modifiable pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: TheItemType *

        """
        return _BRepFill.NCollection_DataMap_TopoDS_Shape_Handle_TopTools_HArray2OfShape_TopTools_ShapeMapHasher_ChangeSeek(self, *args)


    def ChangeFind(self, *args):
        """
        ChangeFind(NCollection_DataMap_TopoDS_Shape_Handle_TopTools_HArray2OfShape_TopTools_ShapeMapHasher self, TopoDS_Shape theKey) -> Handle_TopTools_HArray2OfShape

        ChangeFind returns mofifiable Item by Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: TheItemType &

        """
        return _BRepFill.NCollection_DataMap_TopoDS_Shape_Handle_TopTools_HArray2OfShape_TopTools_ShapeMapHasher_ChangeFind(self, *args)


    def __call__(self, *args):
        """
        operator ()

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _BRepFill.NCollection_DataMap_TopoDS_Shape_Handle_TopTools_HArray2OfShape_TopTools_ShapeMapHasher___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Clear(self, *args):
        """
        Clear(NCollection_DataMap_TopoDS_Shape_Handle_TopTools_HArray2OfShape_TopTools_ShapeMapHasher self, Standard_Boolean const doReleaseMemory)
        Clear(NCollection_DataMap_TopoDS_Shape_Handle_TopTools_HArray2OfShape_TopTools_ShapeMapHasher self, Handle_NCollection_BaseAllocator theAllocator)

        Clear data and reset allocator

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _BRepFill.NCollection_DataMap_TopoDS_Shape_Handle_TopTools_HArray2OfShape_TopTools_ShapeMapHasher_Clear(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_DataMap_TopoDS_Shape_Handle_TopTools_HArray2OfShape_TopTools_ShapeMapHasher self) -> Standard_Integer

        Size

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepFill.NCollection_DataMap_TopoDS_Shape_Handle_TopTools_HArray2OfShape_TopTools_ShapeMapHasher_Size(self, *args)


    def __iter__(self):
        return _BRepFill.NCollection_DataMap_TopoDS_Shape_Handle_TopTools_HArray2OfShape_TopTools_ShapeMapHasher___iter__(self)
    __swig_destroy__ = _BRepFill.delete_NCollection_DataMap_TopoDS_Shape_Handle_TopTools_HArray2OfShape_TopTools_ShapeMapHasher
NCollection_DataMap_TopoDS_Shape_Handle_TopTools_HArray2OfShape_TopTools_ShapeMapHasher_swigregister = _BRepFill.NCollection_DataMap_TopoDS_Shape_Handle_TopTools_HArray2OfShape_TopTools_ShapeMapHasher_swigregister
NCollection_DataMap_TopoDS_Shape_Handle_TopTools_HArray2OfShape_TopTools_ShapeMapHasher_swigregister(NCollection_DataMap_TopoDS_Shape_Handle_TopTools_HArray2OfShape_TopTools_ShapeMapHasher)

class NCollection_DataMap_TopoDS_Shape_Handle_TopTools_HArray2OfShape_TopTools_ShapeMapHasher_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _BRepFill.new_NCollection_DataMap_TopoDS_Shape_Handle_TopTools_HArray2OfShape_TopTools_ShapeMapHasher_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _BRepFill.delete_NCollection_DataMap_TopoDS_Shape_Handle_TopTools_HArray2OfShape_TopTools_ShapeMapHasher_IteratorHelper

    def __next__(self):
        return _BRepFill.NCollection_DataMap_TopoDS_Shape_Handle_TopTools_HArray2OfShape_TopTools_ShapeMapHasher_IteratorHelper___next__(self)
NCollection_DataMap_TopoDS_Shape_Handle_TopTools_HArray2OfShape_TopTools_ShapeMapHasher_IteratorHelper_swigregister = _BRepFill.NCollection_DataMap_TopoDS_Shape_Handle_TopTools_HArray2OfShape_TopTools_ShapeMapHasher_IteratorHelper_swigregister
NCollection_DataMap_TopoDS_Shape_Handle_TopTools_HArray2OfShape_TopTools_ShapeMapHasher_IteratorHelper_swigregister(NCollection_DataMap_TopoDS_Shape_Handle_TopTools_HArray2OfShape_TopTools_ShapeMapHasher_IteratorHelper)


try:
	BRepFill_DataMapOfShapeHArray2OfShape = NCollection_DataMap_TopoDS_Shape_Handle_TopTools_HArray2OfShape_TopTools_ShapeMapHasher
except NameError:
	pass # does not exist, probably ignored

class BRepFill_Draft(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BRepFill_Draft self, TopoDS_Shape Shape, gp_Dir Dir, Standard_Real const Angle) -> BRepFill_Draft

        :type Shape: OCC.wrapper.TopoDS.TopoDS_Shape
        :type Dir: OCC.wrapper.gp.gp_Dir
        :type Angle: float

        """
        this = _BRepFill.new_BRepFill_Draft(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def SetOptions(self, *args):
        """
        SetOptions(BRepFill_Draft self, BRepFill_TransitionStyle const Style=BRepFill_Right, Standard_Real const AngleMin=0.01, Standard_Real const AngleMax=3.0)

        :type Style: OCC.wrapper.BRepFill.BRepFill_TransitionStyle
        :type AngleMin: float
        :type AngleMax: float

        """
        return _BRepFill.BRepFill_Draft_SetOptions(self, *args)


    def SetDraft(self, *args):
        """
        SetDraft(BRepFill_Draft self, Standard_Boolean const IsInternal)

        :type IsInternal: bool

        """
        return _BRepFill.BRepFill_Draft_SetDraft(self, *args)


    def Perform(self, *args):
        """
        Perform(BRepFill_Draft self, Standard_Real const LengthMax)
        Perform(BRepFill_Draft self, Handle_Geom_Surface Surface, Standard_Boolean const KeepInsideSurface)
        Perform(BRepFill_Draft self, TopoDS_Shape StopShape, Standard_Boolean const KeepOutSide)

        :type StopShape: OCC.wrapper.TopoDS.TopoDS_Shape
        :type KeepOutSide: bool

        """
        return _BRepFill.BRepFill_Draft_Perform(self, *args)


    def IsDone(self, *args):
        """
        IsDone(BRepFill_Draft self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepFill.BRepFill_Draft_IsDone(self, *args)


    def Shell(self, *args):
        """
        Shell(BRepFill_Draft self) -> TopoDS_Shell

        Returns the draft surface
        To have the complete shape
        you have to use the Shape() methode.

        :rtype: OCC.wrapper.TopoDS.TopoDS_Shell

        """
        return _BRepFill.BRepFill_Draft_Shell(self, *args)


    def Generated(self, *args):
        """
        Returns the  list   of shapes generated   from the
        shape <S>.

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.TopTools.TopTools_ListOfShape

        """
        res = _BRepFill.BRepFill_Draft_Generated(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Shape(self, *args):
        """
        Shape(BRepFill_Draft self) -> TopoDS_Shape

        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _BRepFill.BRepFill_Draft_Shape(self, *args)

    __swig_destroy__ = _BRepFill.delete_BRepFill_Draft
BRepFill_Draft_swigregister = _BRepFill.BRepFill_Draft_swigregister
BRepFill_Draft_swigregister(BRepFill_Draft)


try:
	TopTools_DataMapOfShapeListOfShape = TopTools.NCollection_DataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_ShapeMapHasher
except AttributeError:
	pass # does not exist, probably ignored

class NCollection_DataMap_Handle_MAT_Node_TopTools_DataMapOfShapeShape_TColStd_MapTransientHasher(NCollection.NCollection_BaseMap):
    """
    Purpose:     The DataMap is a Map to store keys with associated
    Items. See Map  from NCollection for  a discussion
    about the number of buckets.

    The DataMap can be seen as an extended array where
    the Keys  are the   indices.  For this reason  the
    operator () is defined on DataMap to fetch an Item
    from a Key. So the following syntax can be used :

    anItem = aMap(aKey);
    aMap(aKey) = anItem;

    This analogy has its  limit.   aMap(aKey) = anItem
    can  be done only  if aKey was previously bound to
    an item in the map.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_DataMap_Handle_MAT_Node_TopTools_DataMapOfShapeShape_TColStd_MapTransientHasher self) -> NCollection_DataMap< opencascade::handle< MAT_Node >,TopTools_DataMapOfShapeShape,TColStd_MapTransientHasher >::iterator

        Returns an iterator pointing to the first element in the map.

        :rtype: iterator

        """
        return _BRepFill.NCollection_DataMap_Handle_MAT_Node_TopTools_DataMapOfShapeShape_TColStd_MapTransientHasher_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_DataMap_Handle_MAT_Node_TopTools_DataMapOfShapeShape_TColStd_MapTransientHasher self) -> NCollection_DataMap< opencascade::handle< MAT_Node >,TopTools_DataMapOfShapeShape,TColStd_MapTransientHasher >::iterator

        Returns an iterator referring to the past-the-end element in the map.

        :rtype: iterator

        """
        return _BRepFill.NCollection_DataMap_Handle_MAT_Node_TopTools_DataMapOfShapeShape_TColStd_MapTransientHasher_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_DataMap_Handle_MAT_Node_TopTools_DataMapOfShapeShape_TColStd_MapTransientHasher self) -> NCollection_DataMap< opencascade::handle< MAT_Node >,TopTools_DataMapOfShapeShape,TColStd_MapTransientHasher >::const_iterator

        Returns a const iterator pointing to the first element in the map.

        :rtype: const_iterator

        """
        return _BRepFill.NCollection_DataMap_Handle_MAT_Node_TopTools_DataMapOfShapeShape_TColStd_MapTransientHasher_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_DataMap_Handle_MAT_Node_TopTools_DataMapOfShapeShape_TColStd_MapTransientHasher self) -> NCollection_DataMap< opencascade::handle< MAT_Node >,TopTools_DataMapOfShapeShape,TColStd_MapTransientHasher >::const_iterator

        Returns a const iterator referring to the past-the-end element in the map.

        :rtype: const_iterator

        """
        return _BRepFill.NCollection_DataMap_Handle_MAT_Node_TopTools_DataMapOfShapeShape_TColStd_MapTransientHasher_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     The DataMap is a Map to store keys with associated
        Items. See Map  from NCollection for  a discussion
        about the number of buckets.

        The DataMap can be seen as an extended array where
        the Keys  are the   indices.  For this reason  the
        operator () is defined on DataMap to fetch an Item
        from a Key. So the following syntax can be used :

        anItem = aMap(aKey);
        aMap(aKey) = anItem;

        This analogy has its  limit.   aMap(aKey) = anItem
        can  be done only  if aKey was previously bound to
        an item in the map.
        """
        this = _BRepFill.new_NCollection_DataMap_Handle_MAT_Node_TopTools_DataMapOfShapeShape_TColStd_MapTransientHasher(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Exchange(self, *args):
        """
        Exchange(NCollection_DataMap_Handle_MAT_Node_TopTools_DataMapOfShapeShape_TColStd_MapTransientHasher self, NCollection_DataMap_Handle_MAT_Node_TopTools_DataMapOfShapeShape_TColStd_MapTransientHasher theOther)

        Exchange the content of two maps without re-allocations.
        Notice that allocators will be swapped as well!

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _BRepFill.NCollection_DataMap_Handle_MAT_Node_TopTools_DataMapOfShapeShape_TColStd_MapTransientHasher_Exchange(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_DataMap_Handle_MAT_Node_TopTools_DataMapOfShapeShape_TColStd_MapTransientHasher self, NCollection_DataMap_Handle_MAT_Node_TopTools_DataMapOfShapeShape_TColStd_MapTransientHasher theOther) -> NCollection_DataMap_Handle_MAT_Node_TopTools_DataMapOfShapeShape_TColStd_MapTransientHasher

        Assignment.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _BRepFill.NCollection_DataMap_Handle_MAT_Node_TopTools_DataMapOfShapeShape_TColStd_MapTransientHasher_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_DataMap_Handle_MAT_Node_TopTools_DataMapOfShapeShape_TColStd_MapTransientHasher self, NCollection_DataMap_Handle_MAT_Node_TopTools_DataMapOfShapeShape_TColStd_MapTransientHasher theOther) -> NCollection_DataMap_Handle_MAT_Node_TopTools_DataMapOfShapeShape_TColStd_MapTransientHasher

        Assignment operator

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _BRepFill.NCollection_DataMap_Handle_MAT_Node_TopTools_DataMapOfShapeShape_TColStd_MapTransientHasher_assign(self, *args)


    def ReSize(self, *args):
        """
        ReSize(NCollection_DataMap_Handle_MAT_Node_TopTools_DataMapOfShapeShape_TColStd_MapTransientHasher self, Standard_Integer const N)

        ReSize

        :type N: int

        """
        return _BRepFill.NCollection_DataMap_Handle_MAT_Node_TopTools_DataMapOfShapeShape_TColStd_MapTransientHasher_ReSize(self, *args)


    def Bind(self, *args):
        """
        Bind(NCollection_DataMap_Handle_MAT_Node_TopTools_DataMapOfShapeShape_TColStd_MapTransientHasher self, Handle_MAT_Node theKey, NCollection_DataMap_TopoDS_Shape_TopoDS_Shape_TopTools_ShapeMapHasher theItem) -> Standard_Boolean

        Bind binds Item to Key in map.
        @param theKey  key to add/update
        @param theItem new item; overrides value previously bound to the key, if any
        @return Standard_True if Key was not bound already

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepFill.NCollection_DataMap_Handle_MAT_Node_TopTools_DataMapOfShapeShape_TColStd_MapTransientHasher_Bind(self, *args)


    def Bound(self, *args):
        """
        Bound(NCollection_DataMap_Handle_MAT_Node_TopTools_DataMapOfShapeShape_TColStd_MapTransientHasher self, Handle_MAT_Node theKey, NCollection_DataMap_TopoDS_Shape_TopoDS_Shape_TopTools_ShapeMapHasher theItem) -> NCollection_DataMap_TopoDS_Shape_TopoDS_Shape_TopTools_ShapeMapHasher

        Bound binds Item to Key in map. Returns modifiable Item 

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: TheItemType *

        """
        return _BRepFill.NCollection_DataMap_Handle_MAT_Node_TopTools_DataMapOfShapeShape_TColStd_MapTransientHasher_Bound(self, *args)


    def IsBound(self, *args):
        """
        IsBound(NCollection_DataMap_Handle_MAT_Node_TopTools_DataMapOfShapeShape_TColStd_MapTransientHasher self, Handle_MAT_Node theKey) -> Standard_Boolean

        IsBound

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepFill.NCollection_DataMap_Handle_MAT_Node_TopTools_DataMapOfShapeShape_TColStd_MapTransientHasher_IsBound(self, *args)


    def UnBind(self, *args):
        """
        UnBind(NCollection_DataMap_Handle_MAT_Node_TopTools_DataMapOfShapeShape_TColStd_MapTransientHasher self, Handle_MAT_Node theKey) -> Standard_Boolean

        UnBind removes Item Key pair from map

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepFill.NCollection_DataMap_Handle_MAT_Node_TopTools_DataMapOfShapeShape_TColStd_MapTransientHasher_UnBind(self, *args)


    def Seek(self, *args):
        """
        Seek(NCollection_DataMap_Handle_MAT_Node_TopTools_DataMapOfShapeShape_TColStd_MapTransientHasher self, Handle_MAT_Node theKey) -> NCollection_DataMap_TopoDS_Shape_TopoDS_Shape_TopTools_ShapeMapHasher

        Seek returns pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: const TheItemType *

        """
        return _BRepFill.NCollection_DataMap_Handle_MAT_Node_TopTools_DataMapOfShapeShape_TColStd_MapTransientHasher_Seek(self, *args)


    def Find(self, *args):
        """
        Find returns the Item for Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _BRepFill.NCollection_DataMap_Handle_MAT_Node_TopTools_DataMapOfShapeShape_TColStd_MapTransientHasher_Find(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeSeek(self, *args):
        """
        ChangeSeek(NCollection_DataMap_Handle_MAT_Node_TopTools_DataMapOfShapeShape_TColStd_MapTransientHasher self, Handle_MAT_Node theKey) -> NCollection_DataMap_TopoDS_Shape_TopoDS_Shape_TopTools_ShapeMapHasher

        ChangeSeek returns modifiable pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: TheItemType *

        """
        return _BRepFill.NCollection_DataMap_Handle_MAT_Node_TopTools_DataMapOfShapeShape_TColStd_MapTransientHasher_ChangeSeek(self, *args)


    def ChangeFind(self, *args):
        """
        ChangeFind(NCollection_DataMap_Handle_MAT_Node_TopTools_DataMapOfShapeShape_TColStd_MapTransientHasher self, Handle_MAT_Node theKey) -> NCollection_DataMap_TopoDS_Shape_TopoDS_Shape_TopTools_ShapeMapHasher

        ChangeFind returns mofifiable Item by Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: TheItemType &

        """
        return _BRepFill.NCollection_DataMap_Handle_MAT_Node_TopTools_DataMapOfShapeShape_TColStd_MapTransientHasher_ChangeFind(self, *args)


    def __call__(self, *args):
        """
        operator ()

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _BRepFill.NCollection_DataMap_Handle_MAT_Node_TopTools_DataMapOfShapeShape_TColStd_MapTransientHasher___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Clear(self, *args):
        """
        Clear(NCollection_DataMap_Handle_MAT_Node_TopTools_DataMapOfShapeShape_TColStd_MapTransientHasher self, Standard_Boolean const doReleaseMemory)
        Clear(NCollection_DataMap_Handle_MAT_Node_TopTools_DataMapOfShapeShape_TColStd_MapTransientHasher self, Handle_NCollection_BaseAllocator theAllocator)

        Clear data and reset allocator

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _BRepFill.NCollection_DataMap_Handle_MAT_Node_TopTools_DataMapOfShapeShape_TColStd_MapTransientHasher_Clear(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_DataMap_Handle_MAT_Node_TopTools_DataMapOfShapeShape_TColStd_MapTransientHasher self) -> Standard_Integer

        Size

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepFill.NCollection_DataMap_Handle_MAT_Node_TopTools_DataMapOfShapeShape_TColStd_MapTransientHasher_Size(self, *args)


    def __iter__(self):
        return _BRepFill.NCollection_DataMap_Handle_MAT_Node_TopTools_DataMapOfShapeShape_TColStd_MapTransientHasher___iter__(self)
    __swig_destroy__ = _BRepFill.delete_NCollection_DataMap_Handle_MAT_Node_TopTools_DataMapOfShapeShape_TColStd_MapTransientHasher
NCollection_DataMap_Handle_MAT_Node_TopTools_DataMapOfShapeShape_TColStd_MapTransientHasher_swigregister = _BRepFill.NCollection_DataMap_Handle_MAT_Node_TopTools_DataMapOfShapeShape_TColStd_MapTransientHasher_swigregister
NCollection_DataMap_Handle_MAT_Node_TopTools_DataMapOfShapeShape_TColStd_MapTransientHasher_swigregister(NCollection_DataMap_Handle_MAT_Node_TopTools_DataMapOfShapeShape_TColStd_MapTransientHasher)

class NCollection_DataMap_Handle_MAT_Node_TopTools_DataMapOfShapeShape_TColStd_MapTransientHasher_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _BRepFill.new_NCollection_DataMap_Handle_MAT_Node_TopTools_DataMapOfShapeShape_TColStd_MapTransientHasher_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _BRepFill.delete_NCollection_DataMap_Handle_MAT_Node_TopTools_DataMapOfShapeShape_TColStd_MapTransientHasher_IteratorHelper

    def __next__(self):
        return _BRepFill.NCollection_DataMap_Handle_MAT_Node_TopTools_DataMapOfShapeShape_TColStd_MapTransientHasher_IteratorHelper___next__(self)
NCollection_DataMap_Handle_MAT_Node_TopTools_DataMapOfShapeShape_TColStd_MapTransientHasher_IteratorHelper_swigregister = _BRepFill.NCollection_DataMap_Handle_MAT_Node_TopTools_DataMapOfShapeShape_TColStd_MapTransientHasher_IteratorHelper_swigregister
NCollection_DataMap_Handle_MAT_Node_TopTools_DataMapOfShapeShape_TColStd_MapTransientHasher_IteratorHelper_swigregister(NCollection_DataMap_Handle_MAT_Node_TopTools_DataMapOfShapeShape_TColStd_MapTransientHasher_IteratorHelper)


try:
	BRepFill_DataMapOfNodeDataMapOfShapeShape = NCollection_DataMap_Handle_MAT_Node_TopTools_DataMapOfShapeShape_TColStd_MapTransientHasher
except NameError:
	pass # does not exist, probably ignored

class NCollection_DataMap_TopoDS_Shape_TColgp_SequenceOfPnt_TopTools_ShapeMapHasher(NCollection.NCollection_BaseMap):
    """
    Purpose:     The DataMap is a Map to store keys with associated
    Items. See Map  from NCollection for  a discussion
    about the number of buckets.

    The DataMap can be seen as an extended array where
    the Keys  are the   indices.  For this reason  the
    operator () is defined on DataMap to fetch an Item
    from a Key. So the following syntax can be used :

    anItem = aMap(aKey);
    aMap(aKey) = anItem;

    This analogy has its  limit.   aMap(aKey) = anItem
    can  be done only  if aKey was previously bound to
    an item in the map.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_DataMap_TopoDS_Shape_TColgp_SequenceOfPnt_TopTools_ShapeMapHasher self) -> NCollection_DataMap< TopoDS_Shape,TColgp_SequenceOfPnt,TopTools_ShapeMapHasher >::iterator

        Returns an iterator pointing to the first element in the map.

        :rtype: iterator

        """
        return _BRepFill.NCollection_DataMap_TopoDS_Shape_TColgp_SequenceOfPnt_TopTools_ShapeMapHasher_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_DataMap_TopoDS_Shape_TColgp_SequenceOfPnt_TopTools_ShapeMapHasher self) -> NCollection_DataMap< TopoDS_Shape,TColgp_SequenceOfPnt,TopTools_ShapeMapHasher >::iterator

        Returns an iterator referring to the past-the-end element in the map.

        :rtype: iterator

        """
        return _BRepFill.NCollection_DataMap_TopoDS_Shape_TColgp_SequenceOfPnt_TopTools_ShapeMapHasher_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_DataMap_TopoDS_Shape_TColgp_SequenceOfPnt_TopTools_ShapeMapHasher self) -> NCollection_DataMap< TopoDS_Shape,TColgp_SequenceOfPnt,TopTools_ShapeMapHasher >::const_iterator

        Returns a const iterator pointing to the first element in the map.

        :rtype: const_iterator

        """
        return _BRepFill.NCollection_DataMap_TopoDS_Shape_TColgp_SequenceOfPnt_TopTools_ShapeMapHasher_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_DataMap_TopoDS_Shape_TColgp_SequenceOfPnt_TopTools_ShapeMapHasher self) -> NCollection_DataMap< TopoDS_Shape,TColgp_SequenceOfPnt,TopTools_ShapeMapHasher >::const_iterator

        Returns a const iterator referring to the past-the-end element in the map.

        :rtype: const_iterator

        """
        return _BRepFill.NCollection_DataMap_TopoDS_Shape_TColgp_SequenceOfPnt_TopTools_ShapeMapHasher_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     The DataMap is a Map to store keys with associated
        Items. See Map  from NCollection for  a discussion
        about the number of buckets.

        The DataMap can be seen as an extended array where
        the Keys  are the   indices.  For this reason  the
        operator () is defined on DataMap to fetch an Item
        from a Key. So the following syntax can be used :

        anItem = aMap(aKey);
        aMap(aKey) = anItem;

        This analogy has its  limit.   aMap(aKey) = anItem
        can  be done only  if aKey was previously bound to
        an item in the map.
        """
        this = _BRepFill.new_NCollection_DataMap_TopoDS_Shape_TColgp_SequenceOfPnt_TopTools_ShapeMapHasher(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Exchange(self, *args):
        """
        Exchange(NCollection_DataMap_TopoDS_Shape_TColgp_SequenceOfPnt_TopTools_ShapeMapHasher self, NCollection_DataMap_TopoDS_Shape_TColgp_SequenceOfPnt_TopTools_ShapeMapHasher theOther)

        Exchange the content of two maps without re-allocations.
        Notice that allocators will be swapped as well!

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _BRepFill.NCollection_DataMap_TopoDS_Shape_TColgp_SequenceOfPnt_TopTools_ShapeMapHasher_Exchange(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_DataMap_TopoDS_Shape_TColgp_SequenceOfPnt_TopTools_ShapeMapHasher self, NCollection_DataMap_TopoDS_Shape_TColgp_SequenceOfPnt_TopTools_ShapeMapHasher theOther) -> NCollection_DataMap_TopoDS_Shape_TColgp_SequenceOfPnt_TopTools_ShapeMapHasher

        Assignment.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _BRepFill.NCollection_DataMap_TopoDS_Shape_TColgp_SequenceOfPnt_TopTools_ShapeMapHasher_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_DataMap_TopoDS_Shape_TColgp_SequenceOfPnt_TopTools_ShapeMapHasher self, NCollection_DataMap_TopoDS_Shape_TColgp_SequenceOfPnt_TopTools_ShapeMapHasher theOther) -> NCollection_DataMap_TopoDS_Shape_TColgp_SequenceOfPnt_TopTools_ShapeMapHasher

        Assignment operator

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _BRepFill.NCollection_DataMap_TopoDS_Shape_TColgp_SequenceOfPnt_TopTools_ShapeMapHasher_assign(self, *args)


    def ReSize(self, *args):
        """
        ReSize(NCollection_DataMap_TopoDS_Shape_TColgp_SequenceOfPnt_TopTools_ShapeMapHasher self, Standard_Integer const N)

        ReSize

        :type N: int

        """
        return _BRepFill.NCollection_DataMap_TopoDS_Shape_TColgp_SequenceOfPnt_TopTools_ShapeMapHasher_ReSize(self, *args)


    def Bind(self, *args):
        """
        Bind(NCollection_DataMap_TopoDS_Shape_TColgp_SequenceOfPnt_TopTools_ShapeMapHasher self, TopoDS_Shape theKey, NCollection_Sequence_gp_Pnt theItem) -> Standard_Boolean

        Bind binds Item to Key in map.
        @param theKey  key to add/update
        @param theItem new item; overrides value previously bound to the key, if any
        @return Standard_True if Key was not bound already

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepFill.NCollection_DataMap_TopoDS_Shape_TColgp_SequenceOfPnt_TopTools_ShapeMapHasher_Bind(self, *args)


    def Bound(self, *args):
        """
        Bound(NCollection_DataMap_TopoDS_Shape_TColgp_SequenceOfPnt_TopTools_ShapeMapHasher self, TopoDS_Shape theKey, NCollection_Sequence_gp_Pnt theItem) -> NCollection_Sequence_gp_Pnt

        Bound binds Item to Key in map. Returns modifiable Item 

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: TheItemType *

        """
        return _BRepFill.NCollection_DataMap_TopoDS_Shape_TColgp_SequenceOfPnt_TopTools_ShapeMapHasher_Bound(self, *args)


    def IsBound(self, *args):
        """
        IsBound(NCollection_DataMap_TopoDS_Shape_TColgp_SequenceOfPnt_TopTools_ShapeMapHasher self, TopoDS_Shape theKey) -> Standard_Boolean

        IsBound

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepFill.NCollection_DataMap_TopoDS_Shape_TColgp_SequenceOfPnt_TopTools_ShapeMapHasher_IsBound(self, *args)


    def UnBind(self, *args):
        """
        UnBind(NCollection_DataMap_TopoDS_Shape_TColgp_SequenceOfPnt_TopTools_ShapeMapHasher self, TopoDS_Shape theKey) -> Standard_Boolean

        UnBind removes Item Key pair from map

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepFill.NCollection_DataMap_TopoDS_Shape_TColgp_SequenceOfPnt_TopTools_ShapeMapHasher_UnBind(self, *args)


    def Seek(self, *args):
        """
        Seek(NCollection_DataMap_TopoDS_Shape_TColgp_SequenceOfPnt_TopTools_ShapeMapHasher self, TopoDS_Shape theKey) -> NCollection_Sequence_gp_Pnt

        Seek returns pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: const TheItemType *

        """
        return _BRepFill.NCollection_DataMap_TopoDS_Shape_TColgp_SequenceOfPnt_TopTools_ShapeMapHasher_Seek(self, *args)


    def Find(self, *args):
        """
        Find returns the Item for Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _BRepFill.NCollection_DataMap_TopoDS_Shape_TColgp_SequenceOfPnt_TopTools_ShapeMapHasher_Find(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeSeek(self, *args):
        """
        ChangeSeek(NCollection_DataMap_TopoDS_Shape_TColgp_SequenceOfPnt_TopTools_ShapeMapHasher self, TopoDS_Shape theKey) -> NCollection_Sequence_gp_Pnt

        ChangeSeek returns modifiable pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: TheItemType *

        """
        return _BRepFill.NCollection_DataMap_TopoDS_Shape_TColgp_SequenceOfPnt_TopTools_ShapeMapHasher_ChangeSeek(self, *args)


    def ChangeFind(self, *args):
        """
        ChangeFind(NCollection_DataMap_TopoDS_Shape_TColgp_SequenceOfPnt_TopTools_ShapeMapHasher self, TopoDS_Shape theKey) -> NCollection_Sequence_gp_Pnt

        ChangeFind returns mofifiable Item by Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: TheItemType &

        """
        return _BRepFill.NCollection_DataMap_TopoDS_Shape_TColgp_SequenceOfPnt_TopTools_ShapeMapHasher_ChangeFind(self, *args)


    def __call__(self, *args):
        """
        operator ()

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _BRepFill.NCollection_DataMap_TopoDS_Shape_TColgp_SequenceOfPnt_TopTools_ShapeMapHasher___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Clear(self, *args):
        """
        Clear(NCollection_DataMap_TopoDS_Shape_TColgp_SequenceOfPnt_TopTools_ShapeMapHasher self, Standard_Boolean const doReleaseMemory)
        Clear(NCollection_DataMap_TopoDS_Shape_TColgp_SequenceOfPnt_TopTools_ShapeMapHasher self, Handle_NCollection_BaseAllocator theAllocator)

        Clear data and reset allocator

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _BRepFill.NCollection_DataMap_TopoDS_Shape_TColgp_SequenceOfPnt_TopTools_ShapeMapHasher_Clear(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_DataMap_TopoDS_Shape_TColgp_SequenceOfPnt_TopTools_ShapeMapHasher self) -> Standard_Integer

        Size

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepFill.NCollection_DataMap_TopoDS_Shape_TColgp_SequenceOfPnt_TopTools_ShapeMapHasher_Size(self, *args)


    def __iter__(self):
        return _BRepFill.NCollection_DataMap_TopoDS_Shape_TColgp_SequenceOfPnt_TopTools_ShapeMapHasher___iter__(self)
    __swig_destroy__ = _BRepFill.delete_NCollection_DataMap_TopoDS_Shape_TColgp_SequenceOfPnt_TopTools_ShapeMapHasher
NCollection_DataMap_TopoDS_Shape_TColgp_SequenceOfPnt_TopTools_ShapeMapHasher_swigregister = _BRepFill.NCollection_DataMap_TopoDS_Shape_TColgp_SequenceOfPnt_TopTools_ShapeMapHasher_swigregister
NCollection_DataMap_TopoDS_Shape_TColgp_SequenceOfPnt_TopTools_ShapeMapHasher_swigregister(NCollection_DataMap_TopoDS_Shape_TColgp_SequenceOfPnt_TopTools_ShapeMapHasher)

class NCollection_DataMap_TopoDS_Shape_TColgp_SequenceOfPnt_TopTools_ShapeMapHasher_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _BRepFill.new_NCollection_DataMap_TopoDS_Shape_TColgp_SequenceOfPnt_TopTools_ShapeMapHasher_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _BRepFill.delete_NCollection_DataMap_TopoDS_Shape_TColgp_SequenceOfPnt_TopTools_ShapeMapHasher_IteratorHelper

    def __next__(self):
        return _BRepFill.NCollection_DataMap_TopoDS_Shape_TColgp_SequenceOfPnt_TopTools_ShapeMapHasher_IteratorHelper___next__(self)
NCollection_DataMap_TopoDS_Shape_TColgp_SequenceOfPnt_TopTools_ShapeMapHasher_IteratorHelper_swigregister = _BRepFill.NCollection_DataMap_TopoDS_Shape_TColgp_SequenceOfPnt_TopTools_ShapeMapHasher_IteratorHelper_swigregister
NCollection_DataMap_TopoDS_Shape_TColgp_SequenceOfPnt_TopTools_ShapeMapHasher_IteratorHelper_swigregister(NCollection_DataMap_TopoDS_Shape_TColgp_SequenceOfPnt_TopTools_ShapeMapHasher_IteratorHelper)


try:
	BRepFill_DataMapOfShapeSequenceOfPnt = NCollection_DataMap_TopoDS_Shape_TColgp_SequenceOfPnt_TopTools_ShapeMapHasher
except NameError:
	pass # does not exist, probably ignored

class Handle_BRepFill_EdgeOnSurfLaw(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_BRepFill_EdgeOnSurfLaw self)

        Nullify the handle


        """
        return _BRepFill.Handle_BRepFill_EdgeOnSurfLaw_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_BRepFill_EdgeOnSurfLaw self) -> bool

        Check for being null

        :rtype: bool

        """
        return _BRepFill.Handle_BRepFill_EdgeOnSurfLaw_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_BRepFill_EdgeOnSurfLaw self, BRepFill_EdgeOnSurfLaw thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _BRepFill.Handle_BRepFill_EdgeOnSurfLaw_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_BRepFill_EdgeOnSurfLaw self, Handle_BRepFill_EdgeOnSurfLaw theHandle) -> Handle_BRepFill_EdgeOnSurfLaw
        assign(Handle_BRepFill_EdgeOnSurfLaw self, BRepFill_EdgeOnSurfLaw thePtr) -> Handle_BRepFill_EdgeOnSurfLaw
        assign(Handle_BRepFill_EdgeOnSurfLaw self, Handle_BRepFill_EdgeOnSurfLaw theHandle) -> Handle_BRepFill_EdgeOnSurfLaw

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _BRepFill.Handle_BRepFill_EdgeOnSurfLaw_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_BRepFill_EdgeOnSurfLaw self) -> BRepFill_EdgeOnSurfLaw

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _BRepFill.Handle_BRepFill_EdgeOnSurfLaw_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_BRepFill_EdgeOnSurfLaw self) -> BRepFill_EdgeOnSurfLaw

        Member access operator (note non-const)

        :rtype: T *

        """
        return _BRepFill.Handle_BRepFill_EdgeOnSurfLaw___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_BRepFill_EdgeOnSurfLaw self) -> BRepFill_EdgeOnSurfLaw

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _BRepFill.Handle_BRepFill_EdgeOnSurfLaw___ref__(self, *args)


    def __hash__(self):
        return _BRepFill.Handle_BRepFill_EdgeOnSurfLaw___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _BRepFill.Handle_BRepFill_EdgeOnSurfLaw___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _BRepFill.new_Handle_BRepFill_EdgeOnSurfLaw(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_BRepFill.Handle_BRepFill_EdgeOnSurfLaw_DownCast)
    __swig_destroy__ = _BRepFill.delete_Handle_BRepFill_EdgeOnSurfLaw

    def HasResult(self, *args):
        """
        HasResult(Handle_BRepFill_EdgeOnSurfLaw self) -> Standard_Boolean

        returns <False> if one  Edge of <Path> do not have
        representation on  <Surf>.   In this  case  it is
        impossible to use this object.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepFill.Handle_BRepFill_EdgeOnSurfLaw_HasResult(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_BRepFill_EdgeOnSurfLaw self) -> char const *

        :rtype: const char *

        """
        return _BRepFill.Handle_BRepFill_EdgeOnSurfLaw_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _BRepFill.Handle_BRepFill_EdgeOnSurfLaw_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _BRepFill.Handle_BRepFill_EdgeOnSurfLaw_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def GetStatus(self, *args):
        """
        GetStatus(Handle_BRepFill_EdgeOnSurfLaw self) -> GeomFill_PipeError

        Return a error status, if the  status is not PipeOk then
        it exist a parameter tlike the law is not valuable for t.

        :rtype: OCC.wrapper.GeomFill.GeomFill_PipeError

        """
        return _BRepFill.Handle_BRepFill_EdgeOnSurfLaw_GetStatus(self, *args)


    def TransformInG0Law(self, *args):
        """
        TransformInG0Law(Handle_BRepFill_EdgeOnSurfLaw self)

        Apply a linear   transformation  on each law, to  have
        continuity of the global law beetween the edges.


        """
        return _BRepFill.Handle_BRepFill_EdgeOnSurfLaw_TransformInG0Law(self, *args)


    def TransformInCompatibleLaw(self, *args):
        """
        TransformInCompatibleLaw(Handle_BRepFill_EdgeOnSurfLaw self, Standard_Real const AngularTolerance)

        Apply a linear transformation on each law, to reduce
        the   dicontinuities  of law at one  rotation.

        :type AngularTolerance: float

        """
        return _BRepFill.Handle_BRepFill_EdgeOnSurfLaw_TransformInCompatibleLaw(self, *args)


    def DeleteTransform(self, *args):
        """DeleteTransform(Handle_BRepFill_EdgeOnSurfLaw self)"""
        return _BRepFill.Handle_BRepFill_EdgeOnSurfLaw_DeleteTransform(self, *args)


    def NbHoles(self, *args):
        """
        NbHoles(Handle_BRepFill_EdgeOnSurfLaw self, Standard_Real const Tol=1.0e-7) -> Standard_Integer

        :type Tol: float
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepFill.Handle_BRepFill_EdgeOnSurfLaw_NbHoles(self, *args)


    def Holes(self, *args):
        """
        Holes(Handle_BRepFill_EdgeOnSurfLaw self, NCollection_Array1_Standard_Integer Interval)

        :type Interval: OCC.wrapper.TColStd.TColStd_Array1OfInteger

        """
        return _BRepFill.Handle_BRepFill_EdgeOnSurfLaw_Holes(self, *args)


    def NbLaw(self, *args):
        """
        NbLaw(Handle_BRepFill_EdgeOnSurfLaw self) -> Standard_Integer

        Return the number of elementary Law

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepFill.Handle_BRepFill_EdgeOnSurfLaw_NbLaw(self, *args)


    def Law(self, *args):
        """
        Return the elementary Law of rank <Index>
        <Index> have to be in [1, NbLaw()]

        :type Index: int
        :rtype: OCC.wrapper.GeomFill.Handle_GeomFill_LocationLaw

        """
        res = _BRepFill.Handle_BRepFill_EdgeOnSurfLaw_Law_(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Wire(self, *args):
        """
        return the path

        :rtype: OCC.wrapper.TopoDS.TopoDS_Wire

        """
        res = _BRepFill.Handle_BRepFill_EdgeOnSurfLaw_Wire(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Edge(self, *args):
        """
        Return the Edge of rank <Index> in the path
        <Index> have to be in [1, NbLaw()]

        :type Index: int
        :rtype: OCC.wrapper.TopoDS.TopoDS_Edge

        """
        res = _BRepFill.Handle_BRepFill_EdgeOnSurfLaw_Edge(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Vertex(self, *args):
        """
        Vertex(Handle_BRepFill_EdgeOnSurfLaw self, Standard_Integer const Index) -> TopoDS_Vertex

        Return the vertex of rank <Index> in the path
        <Index> have to be in [0, NbLaw()]

        :type Index: int
        :rtype: OCC.wrapper.TopoDS.TopoDS_Vertex

        """
        return _BRepFill.Handle_BRepFill_EdgeOnSurfLaw_Vertex(self, *args)


    def PerformVertex(self, *args):
        """
        PerformVertex(Handle_BRepFill_EdgeOnSurfLaw self, Standard_Integer const Index, TopoDS_Vertex InputVertex, Standard_Real const TolMin, TopoDS_Vertex OutputVertex, Standard_Integer const Location=0)

        Compute <OutputVertex> like a transformation of
        <InputVertex>  the  transformation   is given by
        evaluation of the location law   in the vertex of
        rank   <Index>.
        <Location> is used to manage discontinuities :
        - -1 : The law before the vertex is used.
        -  1 : The law after the vertex is used.
        -  0 : Average of the both laws is used.

        :type Index: int
        :type InputVertex: OCC.wrapper.TopoDS.TopoDS_Vertex
        :type TolMin: float
        :type OutputVertex: OCC.wrapper.TopoDS.TopoDS_Vertex
        :type Location: int

        """
        return _BRepFill.Handle_BRepFill_EdgeOnSurfLaw_PerformVertex(self, *args)


    def CurvilinearBounds(self, *args):
        """
        CurvilinearBounds(Handle_BRepFill_EdgeOnSurfLaw self, Standard_Integer const Index)

        Return the Curvilinear Bounds of the <Index> Law

        :type Index: int
        :type First: float
        :type Last: float

        """
        return _BRepFill.Handle_BRepFill_EdgeOnSurfLaw_CurvilinearBounds(self, *args)


    def IsClosed(self, *args):
        """
        IsClosed(Handle_BRepFill_EdgeOnSurfLaw self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepFill.Handle_BRepFill_EdgeOnSurfLaw_IsClosed(self, *args)


    def IsG1(self, *args):
        """
        IsG1(Handle_BRepFill_EdgeOnSurfLaw self, Standard_Integer const Index, Standard_Real const SpatialTolerance=1.0e-7, Standard_Real const AngularTolerance=1.0e-4) -> Standard_Integer

        Compute the Law's continuity beetween 2 edges of the path
        The result can be :
        -1 : Case Not connex
        0  : It is connex (G0)
        1  : It is tangent (G1)

        :type Index: int
        :type SpatialTolerance: float
        :type AngularTolerance: float
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepFill.Handle_BRepFill_EdgeOnSurfLaw_IsG1(self, *args)


    def D0(self, *args):
        """
        D0(Handle_BRepFill_EdgeOnSurfLaw self, Standard_Real const Abscissa, TopoDS_Shape Section)

        Apply the Law to a shape, for a given Curnilinear abscissa

        :type Abscissa: float
        :type Section: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _BRepFill.Handle_BRepFill_EdgeOnSurfLaw_D0(self, *args)


    def Parameter(self, *args):
        """
        Parameter(Handle_BRepFill_EdgeOnSurfLaw self, Standard_Real const Abscissa)

        Find the  index Law  and the  parmaeter, for  a given
        Curnilinear abscissa

        :type Abscissa: float
        :type Index: int
        :type Param: float

        """
        return _BRepFill.Handle_BRepFill_EdgeOnSurfLaw_Parameter(self, *args)


    def Abscissa(self, *args):
        """
        Abscissa(Handle_BRepFill_EdgeOnSurfLaw self, Standard_Integer const Index, Standard_Real const Param) -> Standard_Real

        Return the curvilinear abscissa  corresponding to a point
        of  the path, defined by  <Index>  of  Edge and a
        parameter on the edge.

        :type Index: int
        :type Param: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _BRepFill.Handle_BRepFill_EdgeOnSurfLaw_Abscissa(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_BRepFill_EdgeOnSurfLaw self)

        Memory deallocator for transient classes


        """
        return _BRepFill.Handle_BRepFill_EdgeOnSurfLaw_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_BRepFill_EdgeOnSurfLaw self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_BRepFill_EdgeOnSurfLaw self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepFill.Handle_BRepFill_EdgeOnSurfLaw_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_BRepFill_EdgeOnSurfLaw self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_BRepFill_EdgeOnSurfLaw self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepFill.Handle_BRepFill_EdgeOnSurfLaw_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_BRepFill_EdgeOnSurfLaw self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _BRepFill.Handle_BRepFill_EdgeOnSurfLaw_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_BRepFill_EdgeOnSurfLaw self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepFill.Handle_BRepFill_EdgeOnSurfLaw_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_BRepFill_EdgeOnSurfLaw self)

        Increments the reference counter of this object


        """
        return _BRepFill.Handle_BRepFill_EdgeOnSurfLaw_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_BRepFill_EdgeOnSurfLaw self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepFill.Handle_BRepFill_EdgeOnSurfLaw_DecrementRefCounter(self, *args)

Handle_BRepFill_EdgeOnSurfLaw_swigregister = _BRepFill.Handle_BRepFill_EdgeOnSurfLaw_swigregister
Handle_BRepFill_EdgeOnSurfLaw_swigregister(Handle_BRepFill_EdgeOnSurfLaw)

def Handle_BRepFill_EdgeOnSurfLaw_DownCast(thing):
    return _BRepFill.Handle_BRepFill_EdgeOnSurfLaw_DownCast(thing)
Handle_BRepFill_EdgeOnSurfLaw_DownCast = _BRepFill.Handle_BRepFill_EdgeOnSurfLaw_DownCast

class Handle_BRepFill_LocationLaw(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_BRepFill_LocationLaw self)

        Nullify the handle


        """
        return _BRepFill.Handle_BRepFill_LocationLaw_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_BRepFill_LocationLaw self) -> bool

        Check for being null

        :rtype: bool

        """
        return _BRepFill.Handle_BRepFill_LocationLaw_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_BRepFill_LocationLaw self, BRepFill_LocationLaw thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _BRepFill.Handle_BRepFill_LocationLaw_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_BRepFill_LocationLaw self, Handle_BRepFill_LocationLaw theHandle) -> Handle_BRepFill_LocationLaw
        assign(Handle_BRepFill_LocationLaw self, BRepFill_LocationLaw thePtr) -> Handle_BRepFill_LocationLaw
        assign(Handle_BRepFill_LocationLaw self, Handle_BRepFill_LocationLaw theHandle) -> Handle_BRepFill_LocationLaw

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _BRepFill.Handle_BRepFill_LocationLaw_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_BRepFill_LocationLaw self) -> BRepFill_LocationLaw

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _BRepFill.Handle_BRepFill_LocationLaw_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_BRepFill_LocationLaw self) -> BRepFill_LocationLaw

        Member access operator (note non-const)

        :rtype: T *

        """
        return _BRepFill.Handle_BRepFill_LocationLaw___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_BRepFill_LocationLaw self) -> BRepFill_LocationLaw

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _BRepFill.Handle_BRepFill_LocationLaw___ref__(self, *args)


    def __hash__(self):
        return _BRepFill.Handle_BRepFill_LocationLaw___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _BRepFill.Handle_BRepFill_LocationLaw___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _BRepFill.new_Handle_BRepFill_LocationLaw(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_BRepFill.Handle_BRepFill_LocationLaw_DownCast)
    __swig_destroy__ = _BRepFill.delete_Handle_BRepFill_LocationLaw

    def GetStatus(self, *args):
        """
        GetStatus(Handle_BRepFill_LocationLaw self) -> GeomFill_PipeError

        Return a error status, if the  status is not PipeOk then
        it exist a parameter tlike the law is not valuable for t.

        :rtype: OCC.wrapper.GeomFill.GeomFill_PipeError

        """
        return _BRepFill.Handle_BRepFill_LocationLaw_GetStatus(self, *args)


    def TransformInG0Law(self, *args):
        """
        TransformInG0Law(Handle_BRepFill_LocationLaw self)

        Apply a linear   transformation  on each law, to  have
        continuity of the global law beetween the edges.


        """
        return _BRepFill.Handle_BRepFill_LocationLaw_TransformInG0Law(self, *args)


    def TransformInCompatibleLaw(self, *args):
        """
        TransformInCompatibleLaw(Handle_BRepFill_LocationLaw self, Standard_Real const AngularTolerance)

        Apply a linear transformation on each law, to reduce
        the   dicontinuities  of law at one  rotation.

        :type AngularTolerance: float

        """
        return _BRepFill.Handle_BRepFill_LocationLaw_TransformInCompatibleLaw(self, *args)


    def DeleteTransform(self, *args):
        """DeleteTransform(Handle_BRepFill_LocationLaw self)"""
        return _BRepFill.Handle_BRepFill_LocationLaw_DeleteTransform(self, *args)


    def NbHoles(self, *args):
        """
        NbHoles(Handle_BRepFill_LocationLaw self, Standard_Real const Tol=1.0e-7) -> Standard_Integer

        :type Tol: float
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepFill.Handle_BRepFill_LocationLaw_NbHoles(self, *args)


    def Holes(self, *args):
        """
        Holes(Handle_BRepFill_LocationLaw self, NCollection_Array1_Standard_Integer Interval)

        :type Interval: OCC.wrapper.TColStd.TColStd_Array1OfInteger

        """
        return _BRepFill.Handle_BRepFill_LocationLaw_Holes(self, *args)


    def NbLaw(self, *args):
        """
        NbLaw(Handle_BRepFill_LocationLaw self) -> Standard_Integer

        Return the number of elementary Law

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepFill.Handle_BRepFill_LocationLaw_NbLaw(self, *args)


    def Law(self, *args):
        """
        Return the elementary Law of rank <Index>
        <Index> have to be in [1, NbLaw()]

        :type Index: int
        :rtype: OCC.wrapper.GeomFill.Handle_GeomFill_LocationLaw

        """
        res = _BRepFill.Handle_BRepFill_LocationLaw_Law_(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Wire(self, *args):
        """
        return the path

        :rtype: OCC.wrapper.TopoDS.TopoDS_Wire

        """
        res = _BRepFill.Handle_BRepFill_LocationLaw_Wire(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Edge(self, *args):
        """
        Return the Edge of rank <Index> in the path
        <Index> have to be in [1, NbLaw()]

        :type Index: int
        :rtype: OCC.wrapper.TopoDS.TopoDS_Edge

        """
        res = _BRepFill.Handle_BRepFill_LocationLaw_Edge(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Vertex(self, *args):
        """
        Vertex(Handle_BRepFill_LocationLaw self, Standard_Integer const Index) -> TopoDS_Vertex

        Return the vertex of rank <Index> in the path
        <Index> have to be in [0, NbLaw()]

        :type Index: int
        :rtype: OCC.wrapper.TopoDS.TopoDS_Vertex

        """
        return _BRepFill.Handle_BRepFill_LocationLaw_Vertex(self, *args)


    def PerformVertex(self, *args):
        """
        PerformVertex(Handle_BRepFill_LocationLaw self, Standard_Integer const Index, TopoDS_Vertex InputVertex, Standard_Real const TolMin, TopoDS_Vertex OutputVertex, Standard_Integer const Location=0)

        Compute <OutputVertex> like a transformation of
        <InputVertex>  the  transformation   is given by
        evaluation of the location law   in the vertex of
        rank   <Index>.
        <Location> is used to manage discontinuities :
        - -1 : The law before the vertex is used.
        -  1 : The law after the vertex is used.
        -  0 : Average of the both laws is used.

        :type Index: int
        :type InputVertex: OCC.wrapper.TopoDS.TopoDS_Vertex
        :type TolMin: float
        :type OutputVertex: OCC.wrapper.TopoDS.TopoDS_Vertex
        :type Location: int

        """
        return _BRepFill.Handle_BRepFill_LocationLaw_PerformVertex(self, *args)


    def CurvilinearBounds(self, *args):
        """
        CurvilinearBounds(Handle_BRepFill_LocationLaw self, Standard_Integer const Index)

        Return the Curvilinear Bounds of the <Index> Law

        :type Index: int
        :type First: float
        :type Last: float

        """
        return _BRepFill.Handle_BRepFill_LocationLaw_CurvilinearBounds(self, *args)


    def IsClosed(self, *args):
        """
        IsClosed(Handle_BRepFill_LocationLaw self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepFill.Handle_BRepFill_LocationLaw_IsClosed(self, *args)


    def IsG1(self, *args):
        """
        IsG1(Handle_BRepFill_LocationLaw self, Standard_Integer const Index, Standard_Real const SpatialTolerance=1.0e-7, Standard_Real const AngularTolerance=1.0e-4) -> Standard_Integer

        Compute the Law's continuity beetween 2 edges of the path
        The result can be :
        -1 : Case Not connex
        0  : It is connex (G0)
        1  : It is tangent (G1)

        :type Index: int
        :type SpatialTolerance: float
        :type AngularTolerance: float
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepFill.Handle_BRepFill_LocationLaw_IsG1(self, *args)


    def D0(self, *args):
        """
        D0(Handle_BRepFill_LocationLaw self, Standard_Real const Abscissa, TopoDS_Shape Section)

        Apply the Law to a shape, for a given Curnilinear abscissa

        :type Abscissa: float
        :type Section: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _BRepFill.Handle_BRepFill_LocationLaw_D0(self, *args)


    def Parameter(self, *args):
        """
        Parameter(Handle_BRepFill_LocationLaw self, Standard_Real const Abscissa)

        Find the  index Law  and the  parmaeter, for  a given
        Curnilinear abscissa

        :type Abscissa: float
        :type Index: int
        :type Param: float

        """
        return _BRepFill.Handle_BRepFill_LocationLaw_Parameter(self, *args)


    def Abscissa(self, *args):
        """
        Abscissa(Handle_BRepFill_LocationLaw self, Standard_Integer const Index, Standard_Real const Param) -> Standard_Real

        Return the curvilinear abscissa  corresponding to a point
        of  the path, defined by  <Index>  of  Edge and a
        parameter on the edge.

        :type Index: int
        :type Param: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _BRepFill.Handle_BRepFill_LocationLaw_Abscissa(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_BRepFill_LocationLaw self) -> char const *

        :rtype: const char *

        """
        return _BRepFill.Handle_BRepFill_LocationLaw_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _BRepFill.Handle_BRepFill_LocationLaw_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _BRepFill.Handle_BRepFill_LocationLaw_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_BRepFill_LocationLaw self)

        Memory deallocator for transient classes


        """
        return _BRepFill.Handle_BRepFill_LocationLaw_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_BRepFill_LocationLaw self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_BRepFill_LocationLaw self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepFill.Handle_BRepFill_LocationLaw_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_BRepFill_LocationLaw self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_BRepFill_LocationLaw self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepFill.Handle_BRepFill_LocationLaw_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_BRepFill_LocationLaw self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _BRepFill.Handle_BRepFill_LocationLaw_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_BRepFill_LocationLaw self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepFill.Handle_BRepFill_LocationLaw_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_BRepFill_LocationLaw self)

        Increments the reference counter of this object


        """
        return _BRepFill.Handle_BRepFill_LocationLaw_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_BRepFill_LocationLaw self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepFill.Handle_BRepFill_LocationLaw_DecrementRefCounter(self, *args)

Handle_BRepFill_LocationLaw_swigregister = _BRepFill.Handle_BRepFill_LocationLaw_swigregister
Handle_BRepFill_LocationLaw_swigregister(Handle_BRepFill_LocationLaw)

def Handle_BRepFill_LocationLaw_DownCast(thing):
    return _BRepFill.Handle_BRepFill_LocationLaw_DownCast(thing)
Handle_BRepFill_LocationLaw_DownCast = _BRepFill.Handle_BRepFill_LocationLaw_DownCast


try:
	TColgp_SequenceOfPnt = TColgp.NCollection_Sequence_gp_Pnt
except AttributeError:
	pass # does not exist, probably ignored

class NCollection_DataMap_Handle_MAT_Node_TopoDS_Shape_TColStd_MapTransientHasher(NCollection.NCollection_BaseMap):
    """
    Purpose:     The DataMap is a Map to store keys with associated
    Items. See Map  from NCollection for  a discussion
    about the number of buckets.

    The DataMap can be seen as an extended array where
    the Keys  are the   indices.  For this reason  the
    operator () is defined on DataMap to fetch an Item
    from a Key. So the following syntax can be used :

    anItem = aMap(aKey);
    aMap(aKey) = anItem;

    This analogy has its  limit.   aMap(aKey) = anItem
    can  be done only  if aKey was previously bound to
    an item in the map.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_DataMap_Handle_MAT_Node_TopoDS_Shape_TColStd_MapTransientHasher self) -> NCollection_DataMap< opencascade::handle< MAT_Node >,TopoDS_Shape,TColStd_MapTransientHasher >::iterator

        Returns an iterator pointing to the first element in the map.

        :rtype: iterator

        """
        return _BRepFill.NCollection_DataMap_Handle_MAT_Node_TopoDS_Shape_TColStd_MapTransientHasher_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_DataMap_Handle_MAT_Node_TopoDS_Shape_TColStd_MapTransientHasher self) -> NCollection_DataMap< opencascade::handle< MAT_Node >,TopoDS_Shape,TColStd_MapTransientHasher >::iterator

        Returns an iterator referring to the past-the-end element in the map.

        :rtype: iterator

        """
        return _BRepFill.NCollection_DataMap_Handle_MAT_Node_TopoDS_Shape_TColStd_MapTransientHasher_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_DataMap_Handle_MAT_Node_TopoDS_Shape_TColStd_MapTransientHasher self) -> NCollection_DataMap< opencascade::handle< MAT_Node >,TopoDS_Shape,TColStd_MapTransientHasher >::const_iterator

        Returns a const iterator pointing to the first element in the map.

        :rtype: const_iterator

        """
        return _BRepFill.NCollection_DataMap_Handle_MAT_Node_TopoDS_Shape_TColStd_MapTransientHasher_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_DataMap_Handle_MAT_Node_TopoDS_Shape_TColStd_MapTransientHasher self) -> NCollection_DataMap< opencascade::handle< MAT_Node >,TopoDS_Shape,TColStd_MapTransientHasher >::const_iterator

        Returns a const iterator referring to the past-the-end element in the map.

        :rtype: const_iterator

        """
        return _BRepFill.NCollection_DataMap_Handle_MAT_Node_TopoDS_Shape_TColStd_MapTransientHasher_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     The DataMap is a Map to store keys with associated
        Items. See Map  from NCollection for  a discussion
        about the number of buckets.

        The DataMap can be seen as an extended array where
        the Keys  are the   indices.  For this reason  the
        operator () is defined on DataMap to fetch an Item
        from a Key. So the following syntax can be used :

        anItem = aMap(aKey);
        aMap(aKey) = anItem;

        This analogy has its  limit.   aMap(aKey) = anItem
        can  be done only  if aKey was previously bound to
        an item in the map.
        """
        this = _BRepFill.new_NCollection_DataMap_Handle_MAT_Node_TopoDS_Shape_TColStd_MapTransientHasher(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Exchange(self, *args):
        """
        Exchange(NCollection_DataMap_Handle_MAT_Node_TopoDS_Shape_TColStd_MapTransientHasher self, NCollection_DataMap_Handle_MAT_Node_TopoDS_Shape_TColStd_MapTransientHasher theOther)

        Exchange the content of two maps without re-allocations.
        Notice that allocators will be swapped as well!

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _BRepFill.NCollection_DataMap_Handle_MAT_Node_TopoDS_Shape_TColStd_MapTransientHasher_Exchange(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_DataMap_Handle_MAT_Node_TopoDS_Shape_TColStd_MapTransientHasher self, NCollection_DataMap_Handle_MAT_Node_TopoDS_Shape_TColStd_MapTransientHasher theOther) -> NCollection_DataMap_Handle_MAT_Node_TopoDS_Shape_TColStd_MapTransientHasher

        Assignment.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _BRepFill.NCollection_DataMap_Handle_MAT_Node_TopoDS_Shape_TColStd_MapTransientHasher_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_DataMap_Handle_MAT_Node_TopoDS_Shape_TColStd_MapTransientHasher self, NCollection_DataMap_Handle_MAT_Node_TopoDS_Shape_TColStd_MapTransientHasher theOther) -> NCollection_DataMap_Handle_MAT_Node_TopoDS_Shape_TColStd_MapTransientHasher

        Assignment operator

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _BRepFill.NCollection_DataMap_Handle_MAT_Node_TopoDS_Shape_TColStd_MapTransientHasher_assign(self, *args)


    def ReSize(self, *args):
        """
        ReSize(NCollection_DataMap_Handle_MAT_Node_TopoDS_Shape_TColStd_MapTransientHasher self, Standard_Integer const N)

        ReSize

        :type N: int

        """
        return _BRepFill.NCollection_DataMap_Handle_MAT_Node_TopoDS_Shape_TColStd_MapTransientHasher_ReSize(self, *args)


    def Bind(self, *args):
        """
        Bind(NCollection_DataMap_Handle_MAT_Node_TopoDS_Shape_TColStd_MapTransientHasher self, Handle_MAT_Node theKey, TopoDS_Shape theItem) -> Standard_Boolean

        Bind binds Item to Key in map.
        @param theKey  key to add/update
        @param theItem new item; overrides value previously bound to the key, if any
        @return Standard_True if Key was not bound already

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepFill.NCollection_DataMap_Handle_MAT_Node_TopoDS_Shape_TColStd_MapTransientHasher_Bind(self, *args)


    def Bound(self, *args):
        """
        Bound(NCollection_DataMap_Handle_MAT_Node_TopoDS_Shape_TColStd_MapTransientHasher self, Handle_MAT_Node theKey, TopoDS_Shape theItem) -> TopoDS_Shape

        Bound binds Item to Key in map. Returns modifiable Item 

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: TheItemType *

        """
        return _BRepFill.NCollection_DataMap_Handle_MAT_Node_TopoDS_Shape_TColStd_MapTransientHasher_Bound(self, *args)


    def IsBound(self, *args):
        """
        IsBound(NCollection_DataMap_Handle_MAT_Node_TopoDS_Shape_TColStd_MapTransientHasher self, Handle_MAT_Node theKey) -> Standard_Boolean

        IsBound

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepFill.NCollection_DataMap_Handle_MAT_Node_TopoDS_Shape_TColStd_MapTransientHasher_IsBound(self, *args)


    def UnBind(self, *args):
        """
        UnBind(NCollection_DataMap_Handle_MAT_Node_TopoDS_Shape_TColStd_MapTransientHasher self, Handle_MAT_Node theKey) -> Standard_Boolean

        UnBind removes Item Key pair from map

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepFill.NCollection_DataMap_Handle_MAT_Node_TopoDS_Shape_TColStd_MapTransientHasher_UnBind(self, *args)


    def Seek(self, *args):
        """
        Seek(NCollection_DataMap_Handle_MAT_Node_TopoDS_Shape_TColStd_MapTransientHasher self, Handle_MAT_Node theKey) -> TopoDS_Shape

        Seek returns pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: const TheItemType *

        """
        return _BRepFill.NCollection_DataMap_Handle_MAT_Node_TopoDS_Shape_TColStd_MapTransientHasher_Seek(self, *args)


    def Find(self, *args):
        """
        Find returns the Item for Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _BRepFill.NCollection_DataMap_Handle_MAT_Node_TopoDS_Shape_TColStd_MapTransientHasher_Find(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeSeek(self, *args):
        """
        ChangeSeek(NCollection_DataMap_Handle_MAT_Node_TopoDS_Shape_TColStd_MapTransientHasher self, Handle_MAT_Node theKey) -> TopoDS_Shape

        ChangeSeek returns modifiable pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: TheItemType *

        """
        return _BRepFill.NCollection_DataMap_Handle_MAT_Node_TopoDS_Shape_TColStd_MapTransientHasher_ChangeSeek(self, *args)


    def ChangeFind(self, *args):
        """
        ChangeFind(NCollection_DataMap_Handle_MAT_Node_TopoDS_Shape_TColStd_MapTransientHasher self, Handle_MAT_Node theKey) -> TopoDS_Shape

        ChangeFind returns mofifiable Item by Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: TheItemType &

        """
        return _BRepFill.NCollection_DataMap_Handle_MAT_Node_TopoDS_Shape_TColStd_MapTransientHasher_ChangeFind(self, *args)


    def __call__(self, *args):
        """
        operator ()

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _BRepFill.NCollection_DataMap_Handle_MAT_Node_TopoDS_Shape_TColStd_MapTransientHasher___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Clear(self, *args):
        """
        Clear(NCollection_DataMap_Handle_MAT_Node_TopoDS_Shape_TColStd_MapTransientHasher self, Standard_Boolean const doReleaseMemory)
        Clear(NCollection_DataMap_Handle_MAT_Node_TopoDS_Shape_TColStd_MapTransientHasher self, Handle_NCollection_BaseAllocator theAllocator)

        Clear data and reset allocator

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _BRepFill.NCollection_DataMap_Handle_MAT_Node_TopoDS_Shape_TColStd_MapTransientHasher_Clear(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_DataMap_Handle_MAT_Node_TopoDS_Shape_TColStd_MapTransientHasher self) -> Standard_Integer

        Size

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepFill.NCollection_DataMap_Handle_MAT_Node_TopoDS_Shape_TColStd_MapTransientHasher_Size(self, *args)


    def __iter__(self):
        return _BRepFill.NCollection_DataMap_Handle_MAT_Node_TopoDS_Shape_TColStd_MapTransientHasher___iter__(self)
    __swig_destroy__ = _BRepFill.delete_NCollection_DataMap_Handle_MAT_Node_TopoDS_Shape_TColStd_MapTransientHasher
NCollection_DataMap_Handle_MAT_Node_TopoDS_Shape_TColStd_MapTransientHasher_swigregister = _BRepFill.NCollection_DataMap_Handle_MAT_Node_TopoDS_Shape_TColStd_MapTransientHasher_swigregister
NCollection_DataMap_Handle_MAT_Node_TopoDS_Shape_TColStd_MapTransientHasher_swigregister(NCollection_DataMap_Handle_MAT_Node_TopoDS_Shape_TColStd_MapTransientHasher)

class NCollection_DataMap_Handle_MAT_Node_TopoDS_Shape_TColStd_MapTransientHasher_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _BRepFill.new_NCollection_DataMap_Handle_MAT_Node_TopoDS_Shape_TColStd_MapTransientHasher_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _BRepFill.delete_NCollection_DataMap_Handle_MAT_Node_TopoDS_Shape_TColStd_MapTransientHasher_IteratorHelper

    def __next__(self):
        return _BRepFill.NCollection_DataMap_Handle_MAT_Node_TopoDS_Shape_TColStd_MapTransientHasher_IteratorHelper___next__(self)
NCollection_DataMap_Handle_MAT_Node_TopoDS_Shape_TColStd_MapTransientHasher_IteratorHelper_swigregister = _BRepFill.NCollection_DataMap_Handle_MAT_Node_TopoDS_Shape_TColStd_MapTransientHasher_IteratorHelper_swigregister
NCollection_DataMap_Handle_MAT_Node_TopoDS_Shape_TColStd_MapTransientHasher_IteratorHelper_swigregister(NCollection_DataMap_Handle_MAT_Node_TopoDS_Shape_TColStd_MapTransientHasher_IteratorHelper)


try:
	BRepFill_DataMapOfNodeShape = NCollection_DataMap_Handle_MAT_Node_TopoDS_Shape_TColStd_MapTransientHasher
except NameError:
	pass # does not exist, probably ignored




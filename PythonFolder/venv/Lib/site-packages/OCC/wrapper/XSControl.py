# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_XSControl')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_XSControl')
    _XSControl = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_XSControl', [dirname(__file__)])
        except ImportError:
            import _XSControl
            return _XSControl
        try:
            _mod = imp.load_module('_XSControl', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _XSControl = swig_import_helper()
    del swig_import_helper
else:
    import _XSControl
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


class SwigPyIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _XSControl.delete_SwigPyIterator

    def value(self):
        return _XSControl.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _XSControl.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _XSControl.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _XSControl.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _XSControl.SwigPyIterator_equal(self, x)

    def copy(self):
        return _XSControl.SwigPyIterator_copy(self)

    def next(self):
        return _XSControl.SwigPyIterator_next(self)

    def __next__(self):
        return _XSControl.SwigPyIterator___next__(self)

    def previous(self):
        return _XSControl.SwigPyIterator_previous(self)

    def advance(self, n):
        return _XSControl.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _XSControl.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _XSControl.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _XSControl.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _XSControl.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _XSControl.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _XSControl.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self
SwigPyIterator_swigregister = _XSControl.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

class NCollection_CellFilter_InspectorXYZ(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _XSControl.NCollection_CellFilter_InspectorXYZ_Dimension
    Coord = staticmethod(_XSControl.NCollection_CellFilter_InspectorXYZ_Coord)

    def Shift(self, thePnt, theTol):
        return _XSControl.NCollection_CellFilter_InspectorXYZ_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _XSControl.new_NCollection_CellFilter_InspectorXYZ()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _XSControl.delete_NCollection_CellFilter_InspectorXYZ
NCollection_CellFilter_InspectorXYZ_swigregister = _XSControl.NCollection_CellFilter_InspectorXYZ_swigregister
NCollection_CellFilter_InspectorXYZ_swigregister(NCollection_CellFilter_InspectorXYZ)

def NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt):
    return _XSControl.NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt)
NCollection_CellFilter_InspectorXYZ_Coord = _XSControl.NCollection_CellFilter_InspectorXYZ_Coord

class NCollection_CellFilter_InspectorXY(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _XSControl.NCollection_CellFilter_InspectorXY_Dimension
    Coord = staticmethod(_XSControl.NCollection_CellFilter_InspectorXY_Coord)

    def Shift(self, thePnt, theTol):
        return _XSControl.NCollection_CellFilter_InspectorXY_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _XSControl.new_NCollection_CellFilter_InspectorXY()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _XSControl.delete_NCollection_CellFilter_InspectorXY
NCollection_CellFilter_InspectorXY_swigregister = _XSControl.NCollection_CellFilter_InspectorXY_swigregister
NCollection_CellFilter_InspectorXY_swigregister(NCollection_CellFilter_InspectorXY)

def NCollection_CellFilter_InspectorXY_Coord(i, thePnt):
    return _XSControl.NCollection_CellFilter_InspectorXY_Coord(i, thePnt)
NCollection_CellFilter_InspectorXY_Coord = _XSControl.NCollection_CellFilter_InspectorXY_Coord


def ptr_to_number(item):
    return _XSControl.ptr_to_number(item)
ptr_to_number = _XSControl.ptr_to_number

def HashCode(*args):
    return _XSControl.HashCode(*args)
HashCode = _XSControl.HashCode

def ptr_equal(a, b):
    return _XSControl.ptr_equal(a, b)
ptr_equal = _XSControl.ptr_equal
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Geom2d
else:
    import Geom2d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import GeomAbs
else:
    import GeomAbs
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColStd
else:
    import TColStd
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TCollection
else:
    import TCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Standard
else:
    import Standard
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import NCollection
else:
    import NCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import gp
else:
    import gp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColgp
else:
    import TColgp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Transfer
else:
    import Transfer
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Interface
else:
    import Interface
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import MoniTool
else:
    import MoniTool
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopoDS
else:
    import TopoDS
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopAbs
else:
    import TopAbs
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Message
else:
    import Message
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopLoc
else:
    import TopLoc
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import OSD
else:
    import OSD
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Quantity
else:
    import Quantity
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopTools
else:
    import TopTools
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Bnd
else:
    import Bnd
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Geom
else:
    import Geom
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import IFSelect
else:
    import IFSelect
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import IFGraph
else:
    import IFGraph
del _swig_python_version_info
class XSControl_SelectForTransfer(IFSelect.IFSelect_SelectExtract):
    """
    This selection selects the entities which are recognised for
    transfer by an Actor for Read : current one or another one.

    An Actor is an operator which runs transfers from interface
    entities to objects for Imagine. It has a method to recognize
    the entities it can process (by default, it recognises all,
    this method can be redefined).

    A TransferReader brings an Actor, according to the currently
    selected norm and transfer conditions.

    This selection considers, either the current Actor (brought by
    the TransferReader, updated as required), or a precise one.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_XSControl_SelectForTransfer
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_XSControl_SelectForTransfer(self) 
            return h


    def __init__(self, *args):
        """
        __init__(XSControl_SelectForTransfer self) -> XSControl_SelectForTransfer
        __init__(XSControl_SelectForTransfer self, Handle_XSControl_TransferReader TR) -> XSControl_SelectForTransfer

        Creates a SelectForTransfer, which will work with the
        currently defined Actor brought by the TransferReader

        :type TR: OCC.wrapper.XSControl.Handle_XSControl_TransferReader

        """
        this = _XSControl.new_XSControl_SelectForTransfer(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def SetReader(self, *args):
        """
        SetReader(XSControl_SelectForTransfer self, Handle_XSControl_TransferReader TR)

        Sets a TransferReader to sort entities : it brings the Actor,
        which may change, while the TransferReader does not

        :type TR: OCC.wrapper.XSControl.Handle_XSControl_TransferReader

        """
        return _XSControl.XSControl_SelectForTransfer_SetReader(self, *args)


    def SetActor(self, *args):
        """
        SetActor(XSControl_SelectForTransfer self, Handle_Transfer_ActorOfTransientProcess act)

        Sets a precise actor to sort entities
        This definition oversedes the creation with a TransferReader

        :type act: OCC.wrapper.Transfer.Handle_Transfer_ActorOfTransientProcess

        """
        return _XSControl.XSControl_SelectForTransfer_SetActor(self, *args)


    def Actor(self, *args):
        """
        Actor(XSControl_SelectForTransfer self) -> Handle_Transfer_ActorOfTransientProcess

        Returns the Actor used as precised one.
        Returns a Null Handle for a creation from a TransferReader
        without any further setting

        :rtype: OCC.wrapper.Transfer.Handle_Transfer_ActorOfTransientProcess

        """
        return _XSControl.XSControl_SelectForTransfer_Actor(self, *args)


    def Reader(self, *args):
        """
        Reader(XSControl_SelectForTransfer self) -> Handle_XSControl_TransferReader

        Returns the Reader (if created with a Reader)
        Returns a Null Handle if not created with a Reader

        :rtype: OCC.wrapper.XSControl.Handle_XSControl_TransferReader

        """
        return _XSControl.XSControl_SelectForTransfer_Reader(self, *args)


    def Sort(self, *args):
        """
        Sort(XSControl_SelectForTransfer self, Standard_Integer const rank, Handle_Standard_Transient ent, Handle_Interface_InterfaceModel model) -> Standard_Boolean

        Returns True for an Entity which is recognized by the Actor,
        either the precised one, or the one defined by TransferReader

        :type rank: int
        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type model: OCC.wrapper.Interface.Handle_Interface_InterfaceModel
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _XSControl.XSControl_SelectForTransfer_Sort(self, *args)


    def ExtractLabel(self, *args):
        """
        ExtractLabel(XSControl_SelectForTransfer self) -> TCollection_AsciiString

        Returns a text defining the criterium : "Recognized for Transfer [(current actor)]"

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _XSControl.XSControl_SelectForTransfer_ExtractLabel(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _XSControl.XSControl_SelectForTransfer_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _XSControl.XSControl_SelectForTransfer_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _XSControl.XSControl_SelectForTransfer_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _XSControl.delete_XSControl_SelectForTransfer
XSControl_SelectForTransfer_swigregister = _XSControl.XSControl_SelectForTransfer_swigregister
XSControl_SelectForTransfer_swigregister(XSControl_SelectForTransfer)

def XSControl_SelectForTransfer_get_type_name(*args):
    """
    XSControl_SelectForTransfer_get_type_name() -> char const *

    :rtype: const char *

    """
    return _XSControl.XSControl_SelectForTransfer_get_type_name(*args)

def XSControl_SelectForTransfer_get_type_descriptor(*args):
    """
    XSControl_SelectForTransfer_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _XSControl.XSControl_SelectForTransfer_get_type_descriptor(*args)

class XSControl_Controller(Standard.Standard_Transient):
    """
    This class allows a general X-STEP engine to run generic
    functions on any interface norm, in the same way. It includes
    the transfer operations. I.e. it gathers the already available
    general modules, the engine has just to know it

    The important point is that a given X-STEP Controller is
    attached to a given couple made of an Interface Norm (such as
    IGES-5.1) and an application data model (CasCade Shapes for
    instance).

    Finally, Controller can be gathered in a general dictionary then
    retreived later by a general call (method Recorded)

    It does not manage the produced data, but the Actors make the
    link between the norm and the application
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_XSControl_Controller
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_XSControl_Controller(self) 
            return h


    def SetNames(self, *args):
        """
        SetNames(XSControl_Controller self, Standard_CString const theLongName, Standard_CString const theShortName)

        Changes names
        if a name is empty, the formerly set one remains
        Remark : Does not call Record or AutoRecord

        :type theLongName: OCC.wrapper.Standard.Standard_CString
        :type theShortName: OCC.wrapper.Standard.Standard_CString

        """
        return _XSControl.XSControl_Controller_SetNames(self, *args)


    def AutoRecord(self, *args):
        """
        AutoRecord(XSControl_Controller self)

        Records <me> is a general dictionary under Short and Long
        Names (see method Name)


        """
        return _XSControl.XSControl_Controller_AutoRecord(self, *args)


    def Record(self, *args):
        """
        Record(XSControl_Controller self, Standard_CString const name)

        Records <me> in a general dictionary under a name
        Error if <name> already used for another one

        :type name: OCC.wrapper.Standard.Standard_CString

        """
        return _XSControl.XSControl_Controller_Record(self, *args)


    def Recorded(*args):
        """
        Recorded(Standard_CString const name) -> Handle_XSControl_Controller

        Returns the Controller attached to a given name
        Returns a Null Handle if <name> is unknown

        :type name: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.XSControl.Handle_XSControl_Controller

        """
        return _XSControl.XSControl_Controller_Recorded(*args)

    Recorded = staticmethod(Recorded)

    def Name(self, *args):
        """
        Name(XSControl_Controller self, Standard_Boolean const rsc) -> Standard_CString

        Returns a name, as given when initializing :
        rsc = False (D) : True Name attached to the Norm (long name)
        rsc = True : Name of the ressource set (i.e. short name)

        :type rsc: bool
        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _XSControl.XSControl_Controller_Name(self, *args)


    def Protocol(self, *args):
        """
        Returns the Protocol attached to the Norm (from field)

        :rtype: OCC.wrapper.Interface.Handle_Interface_Protocol

        """
        res = _XSControl.XSControl_Controller_Protocol(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def WorkLibrary(self, *args):
        """
        Returns the WorkLibrary attached to the Norm. Remark that it
        has to be in phase with the Protocol  (read from field)

        :rtype: OCC.wrapper.IFSelect.Handle_IFSelect_WorkLibrary

        """
        res = _XSControl.XSControl_Controller_WorkLibrary(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def NewModel(self, *args):
        """
        NewModel(XSControl_Controller self) -> Handle_Interface_InterfaceModel

        Creates a new empty Model ready to receive data of the Norm
        Used to write data from Imagine to an interface file

        :rtype: OCC.wrapper.Interface.Handle_Interface_InterfaceModel

        """
        return _XSControl.XSControl_Controller_NewModel(self, *args)


    def ActorRead(self, *args):
        """
        ActorRead(XSControl_Controller self, Handle_Interface_InterfaceModel model) -> Handle_Transfer_ActorOfTransientProcess

        Returns the Actor for Read attached to the pair (norm,appli)
        It can be adapted for data of the input Model, as required
        Can be read from field then adapted with Model as required

        :type model: OCC.wrapper.Interface.Handle_Interface_InterfaceModel
        :rtype: OCC.wrapper.Transfer.Handle_Transfer_ActorOfTransientProcess

        """
        return _XSControl.XSControl_Controller_ActorRead(self, *args)


    def ActorWrite(self, *args):
        """
        ActorWrite(XSControl_Controller self) -> Handle_Transfer_ActorOfFinderProcess

        Returns the Actor for Write attached to the pair (norm,appli)
        Read from field. Can be redefined

        :rtype: OCC.wrapper.Transfer.Handle_Transfer_ActorOfFinderProcess

        """
        return _XSControl.XSControl_Controller_ActorWrite(self, *args)


    def SetModeWrite(self, *args):
        """
        SetModeWrite(XSControl_Controller self, Standard_Integer const modemin, Standard_Integer const modemax, Standard_Boolean const shape)

        Sets mininum and maximum values for modetrans (write)
        Erases formerly recorded bounds and values
        Actually only for shape
        Then, for each value a little help can be attached

        :type modemin: int
        :type modemax: int
        :type shape: bool

        """
        return _XSControl.XSControl_Controller_SetModeWrite(self, *args)


    def SetModeWriteHelp(self, *args):
        """
        SetModeWriteHelp(XSControl_Controller self, Standard_Integer const modetrans, Standard_CString const help, Standard_Boolean const shape)

        Attaches a short line of help to a value of modetrans (write)

        :type modetrans: int
        :type help: OCC.wrapper.Standard.Standard_CString
        :type shape: bool

        """
        return _XSControl.XSControl_Controller_SetModeWriteHelp(self, *args)


    def ModeWriteBounds(self, *args):
        """
        ModeWriteBounds(XSControl_Controller self, Standard_Boolean const shape) -> Standard_Boolean

        Returns recorded min and max values for modetrans (write)
        Actually only for shapes
        Returns True if bounds are set, False else (then, free value)

        :type modemin: int
        :type modemax: int
        :type shape: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _XSControl.XSControl_Controller_ModeWriteBounds(self, *args)


    def IsModeWrite(self, *args):
        """
        IsModeWrite(XSControl_Controller self, Standard_Integer const modetrans, Standard_Boolean const shape) -> Standard_Boolean

        Tells if a value of <modetrans> is a good value(within bounds)
        Actually only for shapes

        :type modetrans: int
        :type shape: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _XSControl.XSControl_Controller_IsModeWrite(self, *args)


    def ModeWriteHelp(self, *args):
        """
        ModeWriteHelp(XSControl_Controller self, Standard_Integer const modetrans, Standard_Boolean const shape) -> Standard_CString

        Returns the help line recorded for a value of modetrans
        empty if help not defined or not within bounds or if values are free

        :type modetrans: int
        :type shape: bool
        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _XSControl.XSControl_Controller_ModeWriteHelp(self, *args)


    def RecognizeWriteTransient(self, *args):
        """
        RecognizeWriteTransient(XSControl_Controller self, Handle_Standard_Transient obj, Standard_Integer const modetrans=0) -> Standard_Boolean

        Tells if <obj> (an application object) is a valid candidate
        for a transfer to a Model.
        By default, asks the ActorWrite if known (through a
        TransientMapper). Can be redefined

        :type obj: OCC.wrapper.Standard.Handle_Standard_Transient
        :type modetrans: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _XSControl.XSControl_Controller_RecognizeWriteTransient(self, *args)


    def TransferWriteTransient(self, *args):
        """
        TransferWriteTransient(XSControl_Controller self, Handle_Standard_Transient obj, Handle_Transfer_FinderProcess FP, Handle_Interface_InterfaceModel model, Standard_Integer const modetrans=0) -> IFSelect_ReturnStatus

        Takes one Transient Object and transfers it to an
        InterfaceModel (already created, e.g. by NewModel)
        (result is recorded in the model by AddWithRefs)
        FP records produced results and checks

        Default uses ActorWrite; can be redefined as necessary
        Returned value is a status, as follows :
        0  OK ,  1 No Result ,  2 Fail (e.g. exception raised)
        -1 bad conditions ,  -2 bad model or null model
        For type of object not recognized : should return 1

        :type obj: OCC.wrapper.Standard.Handle_Standard_Transient
        :type FP: OCC.wrapper.Transfer.Handle_Transfer_FinderProcess
        :type model: OCC.wrapper.Interface.Handle_Interface_InterfaceModel
        :type modetrans: int
        :rtype: OCC.wrapper.IFSelect.IFSelect_ReturnStatus

        """
        return _XSControl.XSControl_Controller_TransferWriteTransient(self, *args)


    def RecognizeWriteShape(self, *args):
        """
        RecognizeWriteShape(XSControl_Controller self, TopoDS_Shape shape, Standard_Integer const modetrans=0) -> Standard_Boolean

        Tells if a shape is valid for a transfer to a model
        Asks the ActorWrite (through a ShapeMapper)

        :type shape: OCC.wrapper.TopoDS.TopoDS_Shape
        :type modetrans: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _XSControl.XSControl_Controller_RecognizeWriteShape(self, *args)


    def TransferWriteShape(self, *args):
        """
        TransferWriteShape(XSControl_Controller self, TopoDS_Shape shape, Handle_Transfer_FinderProcess FP, Handle_Interface_InterfaceModel model, Standard_Integer const modetrans=0) -> IFSelect_ReturnStatus

        Takes one Shape and transfers it to an
        InterfaceModel (already created, e.g. by NewModel)
        Default uses ActorWrite; can be redefined as necessary
        Returned value is a status, as follows :
        Done  OK ,  Void : No Result ,  Fail : Fail (e.g. exception)
        Error : bad conditions , bad model or null model

        :type shape: OCC.wrapper.TopoDS.TopoDS_Shape
        :type FP: OCC.wrapper.Transfer.Handle_Transfer_FinderProcess
        :type model: OCC.wrapper.Interface.Handle_Interface_InterfaceModel
        :type modetrans: int
        :rtype: OCC.wrapper.IFSelect.IFSelect_ReturnStatus

        """
        return _XSControl.XSControl_Controller_TransferWriteShape(self, *args)


    def AddSessionItem(self, *args):
        """
        AddSessionItem(XSControl_Controller self, Handle_Standard_Transient theItem, Standard_CString const theName, Standard_Boolean const toApply)

        Records a Session Item, to be added for customisation of the Work Session.
        It must have a specific name.
        <setapplied> is used if <item> is a GeneralModifier, to decide
        If set to true, <item> will be applied to the hook list "send".
        Else, it is not applied to any hook list.
        Remark : this method is to be called at Create time,
        the recorded items will be used by Customise
        Warning : if <name> conflicts, the last recorded item is kept

        :type theItem: OCC.wrapper.Standard.Handle_Standard_Transient
        :type theName: OCC.wrapper.Standard.Standard_CString
        :type toApply: bool

        """
        return _XSControl.XSControl_Controller_AddSessionItem(self, *args)


    def SessionItem(self, *args):
        """
        SessionItem(XSControl_Controller self, Standard_CString const theName) -> Handle_Standard_Transient

        Returns an item given its name to record in a Session
        If <name> is unknown, returns a Null Handle

        :type theName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _XSControl.XSControl_Controller_SessionItem(self, *args)


    def Customise(self, *args):
        """
        Customise(XSControl_Controller self, Handle_XSControl_WorkSession WS)

        Customises a WorkSession, by adding to it the recorded items (by AddSessionItem)

        :type WS: OCC.wrapper.XSControl.Handle_XSControl_WorkSession

        """
        return _XSControl.XSControl_Controller_Customise(self, *args)


    def AdaptorSession(self, *args):
        """
        :rtype: OCC.wrapper.XSControl.NCollection_DataMap_TCollection_AsciiString_Handle_Standard_Transient

        """
        res = _XSControl.XSControl_Controller_AdaptorSession(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _XSControl.XSControl_Controller_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _XSControl.XSControl_Controller_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _XSControl.XSControl_Controller_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _XSControl.delete_XSControl_Controller
XSControl_Controller_swigregister = _XSControl.XSControl_Controller_swigregister
XSControl_Controller_swigregister(XSControl_Controller)

def XSControl_Controller_Recorded(*args):
    """
    XSControl_Controller_Recorded(Standard_CString const name) -> Handle_XSControl_Controller

    Returns the Controller attached to a given name
    Returns a Null Handle if <name> is unknown

    :type name: OCC.wrapper.Standard.Standard_CString
    :rtype: OCC.wrapper.XSControl.Handle_XSControl_Controller

    """
    return _XSControl.XSControl_Controller_Recorded(*args)

def XSControl_Controller_get_type_name(*args):
    """
    XSControl_Controller_get_type_name() -> char const *

    :rtype: const char *

    """
    return _XSControl.XSControl_Controller_get_type_name(*args)

def XSControl_Controller_get_type_descriptor(*args):
    """
    XSControl_Controller_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _XSControl.XSControl_Controller_get_type_descriptor(*args)

class XSControl_TransferWriter(Standard.Standard_Transient):
    """
    TransferWriter gives help to control transfer to write a file
    after having converted data from Cascade/Imagine

    It works with a Controller (which itself can work with an
    Actor to Write) and a FinderProcess. It records results and
    checks
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_XSControl_TransferWriter
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_XSControl_TransferWriter(self) 
            return h


    def __init__(self, *args):
        """
        __init__(XSControl_TransferWriter self) -> XSControl_TransferWriter

        Creates a TransferWriter, empty, ready to run
        with an empty FinderProcess (but no controller, etc)


        """
        this = _XSControl.new_XSControl_TransferWriter(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def FinderProcess(self, *args):
        """
        Returns the FinderProcess itself

        :rtype: OCC.wrapper.Transfer.Handle_Transfer_FinderProcess

        """
        res = _XSControl.XSControl_TransferWriter_FinderProcess(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetFinderProcess(self, *args):
        """
        SetFinderProcess(XSControl_TransferWriter self, Handle_Transfer_FinderProcess theFP)

        Sets a new FinderProcess and forgets the former one

        :type theFP: OCC.wrapper.Transfer.Handle_Transfer_FinderProcess

        """
        return _XSControl.XSControl_TransferWriter_SetFinderProcess(self, *args)


    def Controller(self, *args):
        """
        Returns the currently used Controller

        :rtype: OCC.wrapper.XSControl.Handle_XSControl_Controller

        """
        res = _XSControl.XSControl_TransferWriter_Controller(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetController(self, *args):
        """
        SetController(XSControl_TransferWriter self, Handle_XSControl_Controller theCtl)

        Sets a new Controller, also sets a new FinderProcess

        :type theCtl: OCC.wrapper.XSControl.Handle_XSControl_Controller

        """
        return _XSControl.XSControl_TransferWriter_SetController(self, *args)


    def Clear(self, *args):
        """
        Clear(XSControl_TransferWriter self, Standard_Integer const theMode)

        Clears recorded data according a mode
        0 clears FinderProcess (results, checks)
        -1 create a new FinderProcess

        :type theMode: int

        """
        return _XSControl.XSControl_TransferWriter_Clear(self, *args)


    def TransferMode(self, *args):
        """
        TransferMode(XSControl_TransferWriter self) -> Standard_Integer

        Returns the current Transfer Mode (an Integer)
        It will be interpreted by the Controller to run Transfers
        This call form could be later replaced by more specific ones
        (parameters suited for each norm / transfer case)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _XSControl.XSControl_TransferWriter_TransferMode(self, *args)


    def SetTransferMode(self, *args):
        """
        SetTransferMode(XSControl_TransferWriter self, Standard_Integer const theMode)

        Changes the Transfer Mode

        :type theMode: int

        """
        return _XSControl.XSControl_TransferWriter_SetTransferMode(self, *args)


    def PrintStats(self, *args):
        """
        PrintStats(XSControl_TransferWriter self, Standard_Integer const theWhat, Standard_Integer const theMode=0)

        Prints statistics on current Trace File, according what,mode
        See PrintStatsProcess for details

        :type theWhat: int
        :type theMode: int

        """
        return _XSControl.XSControl_TransferWriter_PrintStats(self, *args)


    def RecognizeTransient(self, *args):
        """
        RecognizeTransient(XSControl_TransferWriter self, Handle_Standard_Transient theObj) -> Standard_Boolean

        Tells if a transient object (from an application) is a valid
        candidate for a transfer to a model
        Asks the Controller (RecognizeWriteTransient)
        If <obj> is a HShape, calls RecognizeShape

        :type theObj: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _XSControl.XSControl_TransferWriter_RecognizeTransient(self, *args)


    def TransferWriteTransient(self, *args):
        """
        TransferWriteTransient(XSControl_TransferWriter self, Handle_Interface_InterfaceModel theModel, Handle_Standard_Transient theObj) -> IFSelect_ReturnStatus

        Transfers a Transient object (from an application) to a model
        of current norm, according to the last call to SetTransferMode
        Works by calling the Controller
        Returns status : =0 if OK, >0 if error during transfer, <0 if
        transfer badly initialised

        :type theModel: OCC.wrapper.Interface.Handle_Interface_InterfaceModel
        :type theObj: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.IFSelect.IFSelect_ReturnStatus

        """
        return _XSControl.XSControl_TransferWriter_TransferWriteTransient(self, *args)


    def RecognizeShape(self, *args):
        """
        RecognizeShape(XSControl_TransferWriter self, TopoDS_Shape theShape) -> Standard_Boolean

        Tells if a Shape is valid for a transfer to a model
        Asks the Controller (RecognizeWriteShape)

        :type theShape: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _XSControl.XSControl_TransferWriter_RecognizeShape(self, *args)


    def TransferWriteShape(self, *args):
        """
        TransferWriteShape(XSControl_TransferWriter self, Handle_Interface_InterfaceModel theModel, TopoDS_Shape theShape) -> IFSelect_ReturnStatus

        Transfers a Shape from CasCade to a model of current norm,
        according to the last call to SetTransferMode
        Works by calling the Controller
        Returns status : =0 if OK, >0 if error during transfer, <0 if
        transfer badly initialised

        :type theModel: OCC.wrapper.Interface.Handle_Interface_InterfaceModel
        :type theShape: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.IFSelect.IFSelect_ReturnStatus

        """
        return _XSControl.XSControl_TransferWriter_TransferWriteShape(self, *args)


    def CheckList(self, *args):
        """
        CheckList(XSControl_TransferWriter self) -> Interface_CheckIterator

        Returns the check-list of last transfer (write), i.e. the
        check-list currently recorded in the FinderProcess

        :rtype: OCC.wrapper.Interface.Interface_CheckIterator

        """
        return _XSControl.XSControl_TransferWriter_CheckList(self, *args)


    def ResultCheckList(self, *args):
        """
        ResultCheckList(XSControl_TransferWriter self, Handle_Interface_InterfaceModel theModel) -> Interface_CheckIterator

        Returns the check-list of last transfer (write), but tries
        to bind to each check, the resulting entity in the model
        instead of keeping the original Mapper, whenever known

        :type theModel: OCC.wrapper.Interface.Handle_Interface_InterfaceModel
        :rtype: OCC.wrapper.Interface.Interface_CheckIterator

        """
        return _XSControl.XSControl_TransferWriter_ResultCheckList(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _XSControl.XSControl_TransferWriter_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _XSControl.XSControl_TransferWriter_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _XSControl.XSControl_TransferWriter_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _XSControl.delete_XSControl_TransferWriter
XSControl_TransferWriter_swigregister = _XSControl.XSControl_TransferWriter_swigregister
XSControl_TransferWriter_swigregister(XSControl_TransferWriter)

def XSControl_TransferWriter_get_type_name(*args):
    """
    XSControl_TransferWriter_get_type_name() -> char const *

    :rtype: const char *

    """
    return _XSControl.XSControl_TransferWriter_get_type_name(*args)

def XSControl_TransferWriter_get_type_descriptor(*args):
    """
    XSControl_TransferWriter_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _XSControl.XSControl_TransferWriter_get_type_descriptor(*args)

class XSControl_TransferReader(Standard.Standard_Transient):
    """
    A TransferReader performs, manages, handles results of,
    transfers done when reading a file (i.e. from entities of an
    InterfaceModel, to objects for Imagine)

    Running is organised around basic tools : TransientProcess and
    its Actor, results are Binders and CheckIterators. It implies
    control by a Controller (which prepares the Actor as required)

    Getting results can be done directly on TransientProcess, but
    these are immediate "last produced" results. Each transfer of
    an entity gives a final result, but also possible intermediate
    data, and checks, which can be attached to sub-entities.

    Hence, final results (which intermediates and checks) are
    recorded as ResultFromModel and can be queried individually.

    Some more direct access are given for results which are
    Transient or Shapes
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_XSControl_TransferReader
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_XSControl_TransferReader(self) 
            return h


    def __init__(self, *args):
        """
        __init__(XSControl_TransferReader self) -> XSControl_TransferReader

        Creates a TransferReader, empty


        """
        this = _XSControl.new_XSControl_TransferReader(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def SetController(self, *args):
        """
        SetController(XSControl_TransferReader self, Handle_XSControl_Controller theControl)

        Sets a Controller. It is required to generate the Actor.
        Elsewhere, the Actor must be provided directly

        :type theControl: OCC.wrapper.XSControl.Handle_XSControl_Controller

        """
        return _XSControl.XSControl_TransferReader_SetController(self, *args)


    def SetActor(self, *args):
        """
        SetActor(XSControl_TransferReader self, Handle_Transfer_ActorOfTransientProcess theActor)

        Sets the Actor directly : this value will be used if the
        Controller is not set

        :type theActor: OCC.wrapper.Transfer.Handle_Transfer_ActorOfTransientProcess

        """
        return _XSControl.XSControl_TransferReader_SetActor(self, *args)


    def Actor(self, *args):
        """
        Actor(XSControl_TransferReader self) -> Handle_Transfer_ActorOfTransientProcess

        Returns the Actor, determined by the Controller, or if this
        one is unknown, directly set.
        Once it has been defined, it can then be edited.

        :rtype: OCC.wrapper.Transfer.Handle_Transfer_ActorOfTransientProcess

        """
        return _XSControl.XSControl_TransferReader_Actor(self, *args)


    def SetModel(self, *args):
        """
        SetModel(XSControl_TransferReader self, Handle_Interface_InterfaceModel theModel)

        Sets an InterfaceModel. This causes former results, computed
        from another one, to be lost (see also Clear)

        :type theModel: OCC.wrapper.Interface.Handle_Interface_InterfaceModel

        """
        return _XSControl.XSControl_TransferReader_SetModel(self, *args)


    def SetGraph(self, *args):
        """
        SetGraph(XSControl_TransferReader self, Handle_Interface_HGraph theGraph)

        Sets a Graph and its InterfaceModel (calls SetModel)

        :type theGraph: OCC.wrapper.Interface.Handle_Interface_HGraph

        """
        return _XSControl.XSControl_TransferReader_SetGraph(self, *args)


    def Model(self, *args):
        """
        Returns the currently set InterfaceModel

        :rtype: OCC.wrapper.Interface.Handle_Interface_InterfaceModel

        """
        res = _XSControl.XSControl_TransferReader_Model(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetContext(self, *args):
        """
        SetContext(XSControl_TransferReader self, Standard_CString const theName, Handle_Standard_Transient theCtx)

        Sets a Context : according to receiving appli, to be
        interpreted by the Actor

        :type theName: OCC.wrapper.Standard.Standard_CString
        :type theCtx: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _XSControl.XSControl_TransferReader_SetContext(self, *args)


    def GetContext(self, *args):
        """
        GetContext(XSControl_TransferReader self, Standard_CString const theName, Handle_Standard_Type theType, Handle_Standard_Transient theCtx) -> Standard_Boolean

        Returns the Context attached to a name, if set and if it is
        Kind of the type, else a Null Handle
        Returns True if OK, False if no Context

        :type theName: OCC.wrapper.Standard.Standard_CString
        :type theType: OCC.wrapper.Standard.Handle_Standard_Type
        :type theCtx: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _XSControl.XSControl_TransferReader_GetContext(self, *args)


    def Context(self, *args):
        """
        Context(XSControl_TransferReader self) -> NCollection_DataMap< TCollection_AsciiString,opencascade::handle< Standard_Transient > > &

        Returns (modifiable) the whole definition of Context
        Rather for internal use (ex.: preparing and setting in once)

        :rtype: OCC.wrapper.XSControl.NCollection_DataMap_TCollection_AsciiString_Handle_Standard_Transient

        """
        return _XSControl.XSControl_TransferReader_Context(self, *args)


    def SetFileName(self, *args):
        """
        SetFileName(XSControl_TransferReader self, Standard_CString const theName)

        Sets a new value for (loaded) file name

        :type theName: OCC.wrapper.Standard.Standard_CString

        """
        return _XSControl.XSControl_TransferReader_SetFileName(self, *args)


    def FileName(self, *args):
        """
        FileName(XSControl_TransferReader self) -> Standard_CString

        Returns actual value of file name

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _XSControl.XSControl_TransferReader_FileName(self, *args)


    def Clear(self, *args):
        """
        Clear(XSControl_TransferReader self, Standard_Integer const theMode)

        Clears data, according mode :
        -1 all
        0 nothing done
        +1 final results
        +2 working data (model, context, transfer process)

        :type theMode: int

        """
        return _XSControl.XSControl_TransferReader_Clear(self, *args)


    def TransientProcess(self, *args):
        """
        Returns the currently used TransientProcess
        It is computed from the model by TransferReadRoots, or by
        BeginTransferRead

        :rtype: OCC.wrapper.Transfer.Handle_Transfer_TransientProcess

        """
        res = _XSControl.XSControl_TransferReader_TransientProcess(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetTransientProcess(self, *args):
        """
        SetTransientProcess(XSControl_TransferReader self, Handle_Transfer_TransientProcess theTP)

        Forces the TransientProcess
        Remark : it also changes the Model and the Actor, from those
        recorded in the new TransientProcess

        :type theTP: OCC.wrapper.Transfer.Handle_Transfer_TransientProcess

        """
        return _XSControl.XSControl_TransferReader_SetTransientProcess(self, *args)


    def RecordResult(self, *args):
        """
        RecordResult(XSControl_TransferReader self, Handle_Standard_Transient theEnt) -> Standard_Boolean

        Records a final result of transferring an entity
        This result is recorded as a ResultFromModel, taken from
        the TransientProcess
        Returns True if a result is available, False else

        :type theEnt: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _XSControl.XSControl_TransferReader_RecordResult(self, *args)


    def IsRecorded(self, *args):
        """
        IsRecorded(XSControl_TransferReader self, Handle_Standard_Transient theEnt) -> Standard_Boolean

        Returns True if a final result is recorded for an entity
        Remark that it can bring no effective result if transfer has
        completely failed (FinalResult brings only fail messages ...)

        :type theEnt: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _XSControl.XSControl_TransferReader_IsRecorded(self, *args)


    def HasResult(self, *args):
        """
        HasResult(XSControl_TransferReader self, Handle_Standard_Transient theEnt) -> Standard_Boolean

        Returns True if a final result is recorded AND BRINGS AN
        EFFECTIVE RESULT (else, it brings only fail messages)

        :type theEnt: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _XSControl.XSControl_TransferReader_HasResult(self, *args)


    def RecordedList(self, *args):
        """
        RecordedList(XSControl_TransferReader self) -> Handle_TColStd_HSequenceOfTransient

        Returns the list of entities to which a final result is
        attached (i.e. processed by RecordResult)

        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfTransient

        """
        return _XSControl.XSControl_TransferReader_RecordedList(self, *args)


    def Skip(self, *args):
        """
        Skip(XSControl_TransferReader self, Handle_Standard_Transient theEnt) -> Standard_Boolean

        Note that an entity has been required for transfer but no
        result at all is available (typically : case not implemented)
        It is not an error, but it gives a specific status : Skipped
        Returns True if done, False if <ent> is not in starting model

        :type theEnt: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _XSControl.XSControl_TransferReader_Skip(self, *args)


    def IsSkipped(self, *args):
        """
        IsSkipped(XSControl_TransferReader self, Handle_Standard_Transient theEnt) -> Standard_Boolean

        Returns True if an entity is noted as skipped

        :type theEnt: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _XSControl.XSControl_TransferReader_IsSkipped(self, *args)


    def IsMarked(self, *args):
        """
        IsMarked(XSControl_TransferReader self, Handle_Standard_Transient theEnt) -> Standard_Boolean

        Returns True if an entity has been asked for transfert, hence
        it is marked, as : Recorded (a computation has ran, with or
        without an effective result), or Skipped (case ignored)

        :type theEnt: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _XSControl.XSControl_TransferReader_IsMarked(self, *args)


    def FinalResult(self, *args):
        """
        FinalResult(XSControl_TransferReader self, Handle_Standard_Transient theEnt) -> Handle_Transfer_ResultFromModel

        Returns the final result recorded for an entity, as such

        :type theEnt: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Transfer.Handle_Transfer_ResultFromModel

        """
        return _XSControl.XSControl_TransferReader_FinalResult(self, *args)


    def FinalEntityLabel(self, *args):
        """
        FinalEntityLabel(XSControl_TransferReader self, Handle_Standard_Transient theEnt) -> Standard_CString

        Returns the label attached to an entity recorded for final,
        or an empty string if not recorded

        :type theEnt: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _XSControl.XSControl_TransferReader_FinalEntityLabel(self, *args)


    def FinalEntityNumber(self, *args):
        """
        FinalEntityNumber(XSControl_TransferReader self, Handle_Standard_Transient theEnt) -> Standard_Integer

        Returns the number attached to the entity recorded for final,
        or zero if not recorded (looks in the ResultFromModel)

        :type theEnt: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _XSControl.XSControl_TransferReader_FinalEntityNumber(self, *args)


    def ResultFromNumber(self, *args):
        """
        ResultFromNumber(XSControl_TransferReader self, Standard_Integer const theNum) -> Handle_Transfer_ResultFromModel

        Returns the final result recorded for a NUMBER of entity
        (internal use). Null if out of range

        :type theNum: int
        :rtype: OCC.wrapper.Transfer.Handle_Transfer_ResultFromModel

        """
        return _XSControl.XSControl_TransferReader_ResultFromNumber(self, *args)


    def TransientResult(self, *args):
        """
        TransientResult(XSControl_TransferReader self, Handle_Standard_Transient theEnt) -> Handle_Standard_Transient

        Returns the resulting object as a Transient
        Null Handle if no result or result not transient

        :type theEnt: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _XSControl.XSControl_TransferReader_TransientResult(self, *args)


    def ShapeResult(self, *args):
        """
        ShapeResult(XSControl_TransferReader self, Handle_Standard_Transient theEnt) -> TopoDS_Shape

        Returns the resulting object as a Shape
        Null Shape if no result or result not a shape

        :type theEnt: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _XSControl.XSControl_TransferReader_ShapeResult(self, *args)


    def ClearResult(self, *args):
        """
        ClearResult(XSControl_TransferReader self, Handle_Standard_Transient theEnt, Standard_Integer const theMode) -> Standard_Boolean

        Clears recorded result for an entity, according mode
        <mode> = -1 : true, complete, clearing (erasing result)
        <mode> >= 0 : simple "stripping", see ResultFromModel,
        in particular, 0 for simple internal strip,
        10 for all but final result,
        11 for all : just label, status and filename are kept
        Returns True when done, False if nothing was to clear

        :type theEnt: OCC.wrapper.Standard.Handle_Standard_Transient
        :type theMode: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _XSControl.XSControl_TransferReader_ClearResult(self, *args)


    def EntityFromResult(self, *args):
        """
        EntityFromResult(XSControl_TransferReader self, Handle_Standard_Transient theRes, Standard_Integer const theMode=0) -> Handle_Standard_Transient

        Returns an entity from which a given result was produced.
        If <mode> = 0 (D), searches in last root transfers
        If <mode> = 1,     searches in last (root & sub) transfers
        If <mode> = 2,     searches in root recorded results
        If <mode> = 3,     searches in all (root & sub) recordeds
        <res> can be, either a transient object (result itself) or
        a binder. For a binder of shape, calls EntityFromShapeResult
        Returns a Null Handle if <res> not recorded

        :type theRes: OCC.wrapper.Standard.Handle_Standard_Transient
        :type theMode: int
        :rtype: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _XSControl.XSControl_TransferReader_EntityFromResult(self, *args)


    def EntityFromShapeResult(self, *args):
        """
        EntityFromShapeResult(XSControl_TransferReader self, TopoDS_Shape theRes, Standard_Integer const theMode=0) -> Handle_Standard_Transient

        Returns an entity from which a given shape result was produced
        Returns a Null Handle if <res> not recorded or not a Shape

        :type theRes: OCC.wrapper.TopoDS.TopoDS_Shape
        :type theMode: int
        :rtype: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _XSControl.XSControl_TransferReader_EntityFromShapeResult(self, *args)


    def EntitiesFromShapeList(self, *args):
        """
        EntitiesFromShapeList(XSControl_TransferReader self, Handle_TopTools_HSequenceOfShape theRes, Standard_Integer const theMode=0) -> Handle_TColStd_HSequenceOfTransient

        Returns the list of entities from which some shapes were
        produced : it corresponds to a loop on EntityFromShapeResult,
        but is optimised

        :type theRes: OCC.wrapper.TopTools.Handle_TopTools_HSequenceOfShape
        :type theMode: int
        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfTransient

        """
        return _XSControl.XSControl_TransferReader_EntitiesFromShapeList(self, *args)


    def CheckList(self, *args):
        """
        CheckList(XSControl_TransferReader self, Handle_Standard_Transient theEnt, Standard_Integer const theLevel=0) -> Interface_CheckIterator

        Returns the CheckList resulting from transferring <ent>, i.e.
        stored in its recorded form ResultFromModel
        (empty if transfer successful or not recorded ...)

        If <ent> is the Model, returns the complete cumulated
        check-list, <level> is ignored

        If <ent> is an entity of the Model, <level> applies as follows
        <level> : -1 for <ent> only, LAST transfer (TransientProcess)
        <level> : 0  for <ent> only (D)
        1  for <ent> and its immediate subtransfers, if any
        2  for <ent> and subtransferts at all levels

        :type theEnt: OCC.wrapper.Standard.Handle_Standard_Transient
        :type theLevel: int
        :rtype: OCC.wrapper.Interface.Interface_CheckIterator

        """
        return _XSControl.XSControl_TransferReader_CheckList(self, *args)


    def HasChecks(self, *args):
        """
        HasChecks(XSControl_TransferReader self, Handle_Standard_Transient theEnt, Standard_Boolean const FailsOnly) -> Standard_Boolean

        Returns True if an entity (with a final result) has checks :
        - failsonly = False : any kind of check message
        - failsonly = True  : fails only
        Returns False if <ent> is not recorded

        :type theEnt: OCC.wrapper.Standard.Handle_Standard_Transient
        :type FailsOnly: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _XSControl.XSControl_TransferReader_HasChecks(self, *args)


    def CheckedList(self, *args):
        """
        CheckedList(XSControl_TransferReader self, Handle_Standard_Transient theEnt, Interface_CheckStatus const WithCheck=Interface_CheckAny, Standard_Boolean const theResult) -> Handle_TColStd_HSequenceOfTransient

        Returns the list of starting entities to which a given check
        status is attached, IN FINAL RESULTS
        <ent> can be an entity, or the model to query all entities
        Below, "entities" are, either <ent> plus its sub-transferred,
        or all the entities of the model

        <check> = -2 , all entities whatever the check (see result)
        <check> = -1 , entities with no fail (warning allowed)
        <check> =  0 , entities with no check at all
        <check> =  1 , entities with warning but no fail
        <check> =  2 , entities with fail
        <result> : if True, only entities with an attached result
        Remark : result True and check=0 will give an empty list

        :type theEnt: OCC.wrapper.Standard.Handle_Standard_Transient
        :type WithCheck: OCC.wrapper.Interface.Interface_CheckStatus
        :type theResult: bool
        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfTransient

        """
        return _XSControl.XSControl_TransferReader_CheckedList(self, *args)


    def BeginTransfer(self, *args):
        """
        BeginTransfer(XSControl_TransferReader self) -> Standard_Boolean

        Defines a new TransferProcess for reading transfer
        Returns True if done, False if data are not properly defined
        (the Model, the Actor for Read)

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _XSControl.XSControl_TransferReader_BeginTransfer(self, *args)


    def Recognize(self, *args):
        """
        Recognize(XSControl_TransferReader self, Handle_Standard_Transient theEnt) -> Standard_Boolean

        Tells if an entity is recognized as a valid candidate for
        Transfer. Calls method Recognize from the Actor (if known)

        :type theEnt: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _XSControl.XSControl_TransferReader_Recognize(self, *args)


    def TransferOne(self, *args):
        """
        TransferOne(XSControl_TransferReader self, Handle_Standard_Transient theEnt, Standard_Boolean const theRec) -> Standard_Integer

        Commands the transfer on reading for an entity to data for
        Imagine, using the selected Actor for Read
        Returns count of transferred entities, ok or with fails (0/1)
        If <rec> is True (D), the result is recorded by RecordResult

        :type theEnt: OCC.wrapper.Standard.Handle_Standard_Transient
        :type theRec: bool
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _XSControl.XSControl_TransferReader_TransferOne(self, *args)


    def TransferList(self, *args):
        """
        TransferList(XSControl_TransferReader self, Handle_TColStd_HSequenceOfTransient theList, Standard_Boolean const theRec) -> Standard_Integer

        Commands the transfer on reading for a list of entities to
        data for Imagine, using the selected Actor for Read
        Returns count of transferred entities, ok or with fails (0/1)
        If <rec> is True (D), the results are recorded by RecordResult

        :type theList: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfTransient
        :type theRec: bool
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _XSControl.XSControl_TransferReader_TransferList(self, *args)


    def TransferRoots(self, *args):
        """
        TransferRoots(XSControl_TransferReader self, Interface_Graph theGraph) -> Standard_Integer

        Transfers the content of the current Interface Model to
        data handled by Imagine, starting from its Roots (determined
        by the Graph <G>),  using the selected Actor for Read
        Returns the count of performed root transfers (i.e. 0 if none)
        or -1 if no actor is defined

        :type theGraph: OCC.wrapper.Interface.Interface_Graph
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _XSControl.XSControl_TransferReader_TransferRoots(self, *args)


    def TransferClear(self, *args):
        """
        TransferClear(XSControl_TransferReader self, Handle_Standard_Transient theEnt, Standard_Integer const theLevel=0)

        Clears the results attached to an entity
        if <ents> equates the starting model, clears all results

        :type theEnt: OCC.wrapper.Standard.Handle_Standard_Transient
        :type theLevel: int

        """
        return _XSControl.XSControl_TransferReader_TransferClear(self, *args)


    def PrintStats(self, *args):
        """
        PrintStats(XSControl_TransferReader self, Standard_Integer const theWhat, Standard_Integer const theMode=0)

        Prints statistics on current Trace File, according <what> and
        <mode>.  See PrintStatsProcess for details

        :type theWhat: int
        :type theMode: int

        """
        return _XSControl.XSControl_TransferReader_PrintStats(self, *args)


    def LastCheckList(self, *args):
        """
        LastCheckList(XSControl_TransferReader self) -> Interface_CheckIterator

        Returns the CheckList resulting from last TransferRead
        i.e. from TransientProcess itself, recorded from last Clear

        :rtype: OCC.wrapper.Interface.Interface_CheckIterator

        """
        return _XSControl.XSControl_TransferReader_LastCheckList(self, *args)


    def LastTransferList(self, *args):
        """
        LastTransferList(XSControl_TransferReader self, Standard_Boolean const theRoots) -> Handle_TColStd_HSequenceOfTransient

        Returns the list of entities recorded as lastly transferred
        i.e. from TransientProcess itself, recorded from last Clear
        If <roots> is True , considers only roots of transfer
        If <roots> is False, considers all entities bound with result

        :type theRoots: bool
        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfTransient

        """
        return _XSControl.XSControl_TransferReader_LastTransferList(self, *args)


    def ShapeResultList(self, *args):
        """
        Returns a list of result Shapes
        If <rec> is True , sees RecordedList
        If <rec> is False, sees LastTransferList (last ROOT transfers)
        For each one, if it is a Shape, it is cumulated to the list
        If no Shape is found, returns an empty Sequence

        :type theRec: bool
        :rtype: OCC.wrapper.TopTools.Handle_TopTools_HSequenceOfShape

        """
        res = _XSControl.XSControl_TransferReader_ShapeResultList(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def PrintStatsProcess(*args):
        """
        PrintStatsProcess(Handle_Transfer_TransientProcess theTP, Standard_Integer const theWhat, Standard_Integer const theMode=0)

        This routines prints statistics about a TransientProcess
        It can be called, by a TransferReader, or isolately
        Prints are done on the default trace file
        <what> defines what kind of statistics are to be printed :
        0 : basic figures
        1 : root results
        2 : all recorded (roots, intermediate, checked entities)
        3 : abnormal records
        4 : check messages (warnings and fails)
        5 : fail messages

        <mode> is used according <what> :
        <what> = 0 : <mode> is ignored
        <what> = 1,2,3 : <mode> as follows :
        0 (D) : just lists numbers of concerned entities in the model
        1 : for each entity, gives number,label, type and result
        type and/or status (fail/warning...)
        2 : for each entity, gives maximal information (i.e. checks)
        3 : counts per type of starting entity (class type)
        4 : counts per result type and/or status
        5 : counts per couple (starting type / result type/status)
        6 : idem plus gives for each item, the list of numbers of
        entities in the starting model

        <what> = 4,5 : modes relays on an enum PrintCount :
        0 (D) : ItemsByEntity (sequential list by entity)
        1 : CountByItem
        2 : ShortByItem       (count + 5 first numbers)
        3 : ListByItem        (count + entity numbers)
        4 : EntitiesByItem    (count + entity numbers and labels)

        :type theTP: OCC.wrapper.Transfer.Handle_Transfer_TransientProcess
        :type theWhat: int
        :type theMode: int

        """
        return _XSControl.XSControl_TransferReader_PrintStatsProcess(*args)

    PrintStatsProcess = staticmethod(PrintStatsProcess)

    def PrintStatsOnList(*args):
        """
        PrintStatsOnList(Handle_Transfer_TransientProcess theTP, Handle_TColStd_HSequenceOfTransient theList, Standard_Integer const theWhat, Standard_Integer const theMode=0)

        Works as PrintStatsProcess, but displays data only on the
        entities which are in <list> (filter)

        :type theTP: OCC.wrapper.Transfer.Handle_Transfer_TransientProcess
        :type theList: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfTransient
        :type theWhat: int
        :type theMode: int

        """
        return _XSControl.XSControl_TransferReader_PrintStatsOnList(*args)

    PrintStatsOnList = staticmethod(PrintStatsOnList)

    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _XSControl.XSControl_TransferReader_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _XSControl.XSControl_TransferReader_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _XSControl.XSControl_TransferReader_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _XSControl.delete_XSControl_TransferReader
XSControl_TransferReader_swigregister = _XSControl.XSControl_TransferReader_swigregister
XSControl_TransferReader_swigregister(XSControl_TransferReader)

def XSControl_TransferReader_PrintStatsProcess(*args):
    """
    XSControl_TransferReader_PrintStatsProcess(Handle_Transfer_TransientProcess theTP, Standard_Integer const theWhat, Standard_Integer const theMode=0)

    This routines prints statistics about a TransientProcess
    It can be called, by a TransferReader, or isolately
    Prints are done on the default trace file
    <what> defines what kind of statistics are to be printed :
    0 : basic figures
    1 : root results
    2 : all recorded (roots, intermediate, checked entities)
    3 : abnormal records
    4 : check messages (warnings and fails)
    5 : fail messages

    <mode> is used according <what> :
    <what> = 0 : <mode> is ignored
    <what> = 1,2,3 : <mode> as follows :
    0 (D) : just lists numbers of concerned entities in the model
    1 : for each entity, gives number,label, type and result
    type and/or status (fail/warning...)
    2 : for each entity, gives maximal information (i.e. checks)
    3 : counts per type of starting entity (class type)
    4 : counts per result type and/or status
    5 : counts per couple (starting type / result type/status)
    6 : idem plus gives for each item, the list of numbers of
    entities in the starting model

    <what> = 4,5 : modes relays on an enum PrintCount :
    0 (D) : ItemsByEntity (sequential list by entity)
    1 : CountByItem
    2 : ShortByItem       (count + 5 first numbers)
    3 : ListByItem        (count + entity numbers)
    4 : EntitiesByItem    (count + entity numbers and labels)

    :type theTP: OCC.wrapper.Transfer.Handle_Transfer_TransientProcess
    :type theWhat: int
    :type theMode: int

    """
    return _XSControl.XSControl_TransferReader_PrintStatsProcess(*args)

def XSControl_TransferReader_PrintStatsOnList(*args):
    """
    XSControl_TransferReader_PrintStatsOnList(Handle_Transfer_TransientProcess theTP, Handle_TColStd_HSequenceOfTransient theList, Standard_Integer const theWhat, Standard_Integer const theMode=0)

    Works as PrintStatsProcess, but displays data only on the
    entities which are in <list> (filter)

    :type theTP: OCC.wrapper.Transfer.Handle_Transfer_TransientProcess
    :type theList: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfTransient
    :type theWhat: int
    :type theMode: int

    """
    return _XSControl.XSControl_TransferReader_PrintStatsOnList(*args)

def XSControl_TransferReader_get_type_name(*args):
    """
    XSControl_TransferReader_get_type_name() -> char const *

    :rtype: const char *

    """
    return _XSControl.XSControl_TransferReader_get_type_name(*args)

def XSControl_TransferReader_get_type_descriptor(*args):
    """
    XSControl_TransferReader_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _XSControl.XSControl_TransferReader_get_type_descriptor(*args)

class XSControl_WorkSession(IFSelect.IFSelect_WorkSession):
    """
    This WorkSession completes the basic one, by adding :
    - use of Controller, with norm selection...
    - management of transfers (both ways) with auxiliary classes
    TransferReader and TransferWriter
    -> these transfers may work with a Context List : its items
    are given by the user, according to the transfer to be
    i.e. it is interpreted by the Actors
    Each item is accessed by a Name
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_XSControl_WorkSession
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_XSControl_WorkSession(self) 
            return h


    def __init__(self, *args):
        """
        __init__(XSControl_WorkSession self) -> XSControl_WorkSession

        This WorkSession completes the basic one, by adding :
        - use of Controller, with norm selection...
        - management of transfers (both ways) with auxiliary classes
        TransferReader and TransferWriter
        -> these transfers may work with a Context List : its items
        are given by the user, according to the transfer to be
        i.e. it is interpreted by the Actors
        Each item is accessed by a Name
        """
        this = _XSControl.new_XSControl_WorkSession(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def ClearData(self, *args):
        """
        ClearData(XSControl_WorkSession self, Standard_Integer const theMode)

        In addition to basic ClearData, clears Transfer and Management
        for interactive use, for mode = 0,1,2 and over 4
        Plus : mode = 5 to clear Transfers (both ways) only
        mode = 6 to clear enforced results
        mode = 7 to clear transfers, results

        :type theMode: int

        """
        return _XSControl.XSControl_WorkSession_ClearData(self, *args)


    def SelectNorm(self, *args):
        """
        SelectNorm(XSControl_WorkSession self, Standard_CString const theNormName) -> Standard_Boolean

        Selects a Norm defined by its name.
        A Norm is described and handled by a Controller
        Returns True if done, False if <normname> is unknown

        The current Profile for this Norm is taken.

        :type theNormName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _XSControl.XSControl_WorkSession_SelectNorm(self, *args)


    def SetController(self, *args):
        """
        SetController(XSControl_WorkSession self, Handle_XSControl_Controller theCtl)

        Selects a Norm defined by its Controller itself

        :type theCtl: OCC.wrapper.XSControl.Handle_XSControl_Controller

        """
        return _XSControl.XSControl_WorkSession_SetController(self, *args)


    def SelectedNorm(self, *args):
        """
        SelectedNorm(XSControl_WorkSession self, Standard_Boolean const theRsc) -> Standard_CString

        Returns the name of the last Selected Norm. If none is
        defined, returns an empty string
        By default, returns the complete name of the norm
        If <rsc> is True, returns the short name used for resource

        :type theRsc: bool
        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _XSControl.XSControl_WorkSession_SelectedNorm(self, *args)


    def NormAdaptor(self, *args):
        """
        Returns the norm controller itself

        :rtype: OCC.wrapper.XSControl.Handle_XSControl_Controller

        """
        res = _XSControl.XSControl_WorkSession_NormAdaptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Context(self, *args):
        """
        Returns the current Context List, Null if not defined
        The Context is given to the TransientProcess for TransferRead

        :rtype: OCC.wrapper.XSControl.NCollection_DataMap_TCollection_AsciiString_Handle_Standard_Transient

        """
        res = _XSControl.XSControl_WorkSession_Context(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetAllContext(self, *args):
        """
        SetAllContext(XSControl_WorkSession self, NCollection_DataMap< TCollection_AsciiString,opencascade::handle< Standard_Transient > > const & theContext)

        Sets the current Context List, as a whole
        Sets it to the TransferReader

        :type theContext: OCC.wrapper.XSControl.NCollection_DataMap_TCollection_AsciiString_Handle_Standard_Transient

        """
        return _XSControl.XSControl_WorkSession_SetAllContext(self, *args)


    def ClearContext(self, *args):
        """
        ClearContext(XSControl_WorkSession self)

        Clears the whole current Context (nullifies it)


        """
        return _XSControl.XSControl_WorkSession_ClearContext(self, *args)


    def PrintTransferStatus(self, *args):
        """
        PrintTransferStatus(XSControl_WorkSession self, Standard_Integer const theNum, Standard_Boolean const theWri, Handle_Message_Messenger theS) -> Standard_Boolean

        Prints the transfer status of a transferred item, as beeing
        the Mapped n0 <num>, from MapWriter if <wri> is True, or
        from MapReader if <wri> is False
        Returns True when done, False else (i.e. num out of range)

        :type theNum: int
        :type theWri: bool
        :type theS: OCC.wrapper.Message.Handle_Message_Messenger
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _XSControl.XSControl_WorkSession_PrintTransferStatus(self, *args)


    def InitTransferReader(self, *args):
        """
        InitTransferReader(XSControl_WorkSession self, Standard_Integer const theMode)

        Sets a Transfer Reader, by internal ways, according mode :
        0 recreates it clear,  1 clears it (does not recreate)
        2 aligns Roots of TransientProcess from final Results
        3 aligns final Results from Roots of TransientProcess
        4 begins a new transfer (by BeginTransfer)
        5 recreates TransferReader then begins a new transfer

        :type theMode: int

        """
        return _XSControl.XSControl_WorkSession_InitTransferReader(self, *args)


    def SetTransferReader(self, *args):
        """
        SetTransferReader(XSControl_WorkSession self, Handle_XSControl_TransferReader theTR)

        Sets a Transfer Reader, which manages transfers on reading

        :type theTR: OCC.wrapper.XSControl.Handle_XSControl_TransferReader

        """
        return _XSControl.XSControl_WorkSession_SetTransferReader(self, *args)


    def TransferReader(self, *args):
        """
        Returns the Transfer Reader, Null if not set

        :rtype: OCC.wrapper.XSControl.Handle_XSControl_TransferReader

        """
        res = _XSControl.XSControl_WorkSession_TransferReader(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def MapReader(self, *args):
        """
        MapReader(XSControl_WorkSession self) -> Handle_Transfer_TransientProcess

        Returns the TransientProcess(internal data for TransferReader)

        :rtype: OCC.wrapper.Transfer.Handle_Transfer_TransientProcess

        """
        return _XSControl.XSControl_WorkSession_MapReader(self, *args)


    def SetMapReader(self, *args):
        """
        SetMapReader(XSControl_WorkSession self, Handle_Transfer_TransientProcess theTP) -> Standard_Boolean

        Changes the Map Reader, i.e. considers that the new one
        defines the relevant read results (forgets the former ones)
        Returns True when done, False in case of bad definition, i.e.
        if Model from TP differs from that of Session

        :type theTP: OCC.wrapper.Transfer.Handle_Transfer_TransientProcess
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _XSControl.XSControl_WorkSession_SetMapReader(self, *args)


    def Result(self, *args):
        """
        Result(XSControl_WorkSession self, Handle_Standard_Transient theEnt, Standard_Integer const theMode) -> Handle_Standard_Transient

        Returns the result attached to a starting entity
        If <mode> = 0, returns Final Result
        If <mode> = 1, considers Last Result
        If <mode> = 2, considers Final, else if absent, Last
        returns it as Transient, if result is not transient returns
        the Binder
        <mode> = 10,11,12 idem but returns the Binder itself
        (if it is not, e.g. Shape, returns the Binder)
        <mode> = 20, returns the ResultFromModel

        :type theEnt: OCC.wrapper.Standard.Handle_Standard_Transient
        :type theMode: int
        :rtype: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _XSControl.XSControl_WorkSession_Result(self, *args)


    def TransferReadOne(self, *args):
        """
        TransferReadOne(XSControl_WorkSession self, Handle_Standard_Transient theEnts) -> Standard_Integer

        Commands the transfer of, either one entity, or a list
        I.E. calls the TransferReader after having analysed <ents>
        It is cumulated from the last BeginTransfer
        <ents> is processed by GiveList, hence :
        - <ents> a Selection : its SelectionResult
        - <ents> a HSequenceOfTransient : this list
        - <ents> the Model : in this specific case, all the roots,
        with no cumulation of former transfers (TransferReadRoots)

        :type theEnts: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _XSControl.XSControl_WorkSession_TransferReadOne(self, *args)


    def TransferReadRoots(self, *args):
        """
        TransferReadRoots(XSControl_WorkSession self) -> Standard_Integer

        Commands the transfer of all the root entities of the model
        i.e. calls TransferRoot from the TransferReader with the Graph
        No cumulation with former calls to TransferReadOne

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _XSControl.XSControl_WorkSession_TransferReadRoots(self, *args)


    def NewModel(self, *args):
        """
        NewModel(XSControl_WorkSession self) -> Handle_Interface_InterfaceModel

        produces and returns a new Model well conditionned
        It is produced by the Norm Controller
        It can be Null (if this function is not implemented)

        :rtype: OCC.wrapper.Interface.Handle_Interface_InterfaceModel

        """
        return _XSControl.XSControl_WorkSession_NewModel(self, *args)


    def TransferWriter(self, *args):
        """
        Returns the Transfer Reader, Null if not set

        :rtype: OCC.wrapper.XSControl.Handle_XSControl_TransferWriter

        """
        res = _XSControl.XSControl_WorkSession_TransferWriter(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetMapWriter(self, *args):
        """
        SetMapWriter(XSControl_WorkSession self, Handle_Transfer_FinderProcess theFP) -> Standard_Boolean

        Changes the Map Reader, i.e. considers that the new one
        defines the relevant read results (forgets the former ones)
        Returns True when done, False if <FP> is Null

        :type theFP: OCC.wrapper.Transfer.Handle_Transfer_FinderProcess
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _XSControl.XSControl_WorkSession_SetMapWriter(self, *args)


    def TransferWriteShape(self, *args):
        """
        TransferWriteShape(XSControl_WorkSession self, TopoDS_Shape theShape, Standard_Boolean const theCompGraph) -> IFSelect_ReturnStatus

        Transfers a Shape from CasCade to a model of current norm,
        according to the last call to SetModeWriteShape
        Returns status :Done if OK, Fail if error during transfer,
        Error if transfer badly initialised

        :type theShape: OCC.wrapper.TopoDS.TopoDS_Shape
        :type theCompGraph: bool
        :rtype: OCC.wrapper.IFSelect.IFSelect_ReturnStatus

        """
        return _XSControl.XSControl_WorkSession_TransferWriteShape(self, *args)


    def TransferWriteCheckList(self, *args):
        """
        TransferWriteCheckList(XSControl_WorkSession self) -> Interface_CheckIterator

        Returns the check-list of last transfer (write)
        It is recorded in the FinderProcess, but it must be bound with
        resulting entities (in the resulting file model) rather than
        with original objects (in fact, their mappers)

        :rtype: OCC.wrapper.Interface.Interface_CheckIterator

        """
        return _XSControl.XSControl_WorkSession_TransferWriteCheckList(self, *args)


    def Vars(self, *args):
        """
        :rtype: OCC.wrapper.XSControl.Handle_XSControl_Vars

        """
        res = _XSControl.XSControl_WorkSession_Vars(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetVars(self, *args):
        """
        SetVars(XSControl_WorkSession self, Handle_XSControl_Vars theVars)

        :type theVars: OCC.wrapper.XSControl.Handle_XSControl_Vars

        """
        return _XSControl.XSControl_WorkSession_SetVars(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _XSControl.XSControl_WorkSession_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _XSControl.XSControl_WorkSession_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _XSControl.XSControl_WorkSession_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _XSControl.delete_XSControl_WorkSession
XSControl_WorkSession_swigregister = _XSControl.XSControl_WorkSession_swigregister
XSControl_WorkSession_swigregister(XSControl_WorkSession)

def XSControl_WorkSession_get_type_name(*args):
    """
    XSControl_WorkSession_get_type_name() -> char const *

    :rtype: const char *

    """
    return _XSControl.XSControl_WorkSession_get_type_name(*args)

def XSControl_WorkSession_get_type_descriptor(*args):
    """
    XSControl_WorkSession_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _XSControl.XSControl_WorkSession_get_type_descriptor(*args)

class XSControl_SignTransferStatus(IFSelect.IFSelect_Signature):
    """
    This Signatures gives the Transfer Status of an entity, as
    recorded in a TransferProcess. It can be :
    - Void : not recorded, or recorded as void with no message
    (attributes are not taken into account)
    - Warning : no result, warning message(s), no fail
    - Fail : no result, fail messages (with or without warning)
    - Result.. : result, no message (neither warning nor fail)
    Result.. i.e. Result:TypeName of the result
    - Result../Warning : result, with warning but no fail
    - Result../Fail : result, with fail (.e. bad result)
    - Fail on run : no result yet recorded, no message, but
    an exception occurred while recording the result
    (this should not appear and indicates a programming error)
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_XSControl_SignTransferStatus
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_XSControl_SignTransferStatus(self) 
            return h


    def __init__(self, *args):
        """
        __init__(XSControl_SignTransferStatus self) -> XSControl_SignTransferStatus
        __init__(XSControl_SignTransferStatus self, Handle_XSControl_TransferReader TR) -> XSControl_SignTransferStatus

        Creates a SignTransferStatus, which will work on the current
        TransientProcess brought by the TransferReader (its MapReader)

        :type TR: OCC.wrapper.XSControl.Handle_XSControl_TransferReader

        """
        this = _XSControl.new_XSControl_SignTransferStatus(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def SetReader(self, *args):
        """
        SetReader(XSControl_SignTransferStatus self, Handle_XSControl_TransferReader TR)

        Sets a TransferReader to work

        :type TR: OCC.wrapper.XSControl.Handle_XSControl_TransferReader

        """
        return _XSControl.XSControl_SignTransferStatus_SetReader(self, *args)


    def SetMap(self, *args):
        """
        SetMap(XSControl_SignTransferStatus self, Handle_Transfer_TransientProcess TP)

        Sets a precise map to sign entities
        This definition oversedes the creation with a TransferReader

        :type TP: OCC.wrapper.Transfer.Handle_Transfer_TransientProcess

        """
        return _XSControl.XSControl_SignTransferStatus_SetMap(self, *args)


    def Map(self, *args):
        """
        Map(XSControl_SignTransferStatus self) -> Handle_Transfer_TransientProcess

        Returns the TransientProcess used as precised one
        Returns a Null Handle for a creation from a TransferReader
        without any further setting

        :rtype: OCC.wrapper.Transfer.Handle_Transfer_TransientProcess

        """
        return _XSControl.XSControl_SignTransferStatus_Map(self, *args)


    def Reader(self, *args):
        """
        Reader(XSControl_SignTransferStatus self) -> Handle_XSControl_TransferReader

        Returns the Reader (if created with a Reader)
        Returns a Null Handle if not created with a Reader

        :rtype: OCC.wrapper.XSControl.Handle_XSControl_TransferReader

        """
        return _XSControl.XSControl_SignTransferStatus_Reader(self, *args)


    def Value(self, *args):
        """
        Value(XSControl_SignTransferStatus self, Handle_Standard_Transient ent, Handle_Interface_InterfaceModel model) -> Standard_CString

        Returns the Signature for a Transient object, as its transfer
        status

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type model: OCC.wrapper.Interface.Handle_Interface_InterfaceModel
        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _XSControl.XSControl_SignTransferStatus_Value(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _XSControl.XSControl_SignTransferStatus_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _XSControl.XSControl_SignTransferStatus_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _XSControl.XSControl_SignTransferStatus_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _XSControl.delete_XSControl_SignTransferStatus
XSControl_SignTransferStatus_swigregister = _XSControl.XSControl_SignTransferStatus_swigregister
XSControl_SignTransferStatus_swigregister(XSControl_SignTransferStatus)

def XSControl_SignTransferStatus_get_type_name(*args):
    """
    XSControl_SignTransferStatus_get_type_name() -> char const *

    :rtype: const char *

    """
    return _XSControl.XSControl_SignTransferStatus_get_type_name(*args)

def XSControl_SignTransferStatus_get_type_descriptor(*args):
    """
    XSControl_SignTransferStatus_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _XSControl.XSControl_SignTransferStatus_get_type_descriptor(*args)

class XSControl_ConnectedShapes(IFSelect.IFSelect_SelectExplore):
    """
    From a TopoDS_Shape, or from the entity which has produced it,
    searches for the shapes, and the entities which have produced
    them in last transfer, which are adjacent to it by VERTICES
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_XSControl_ConnectedShapes
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_XSControl_ConnectedShapes(self) 
            return h


    def __init__(self, *args):
        """
        __init__(XSControl_ConnectedShapes self) -> XSControl_ConnectedShapes
        __init__(XSControl_ConnectedShapes self, Handle_XSControl_TransferReader TR) -> XSControl_ConnectedShapes

        Creates a Selection ConnectedShapes, which will work with the
        current TransferProcess brought by the TransferReader

        :type TR: OCC.wrapper.XSControl.Handle_XSControl_TransferReader

        """
        this = _XSControl.new_XSControl_ConnectedShapes(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def SetReader(self, *args):
        """
        SetReader(XSControl_ConnectedShapes self, Handle_XSControl_TransferReader TR)

        Sets a TransferReader to sort entities : it brings the
        TransferProcess which may change, while the TransferReader does not

        :type TR: OCC.wrapper.XSControl.Handle_XSControl_TransferReader

        """
        return _XSControl.XSControl_ConnectedShapes_SetReader(self, *args)


    def Explore(self, *args):
        """
        Explore(XSControl_ConnectedShapes self, Standard_Integer const level, Handle_Standard_Transient ent, Interface_Graph G, Interface_EntityIterator explored) -> Standard_Boolean

        Explores an entity : entities from which are connected to that
        produced by this entity, including itself

        :type level: int
        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type G: OCC.wrapper.Interface.Interface_Graph
        :type explored: OCC.wrapper.Interface.Interface_EntityIterator
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _XSControl.XSControl_ConnectedShapes_Explore(self, *args)


    def ExploreLabel(self, *args):
        """
        ExploreLabel(XSControl_ConnectedShapes self) -> TCollection_AsciiString

        Returns a text defining the criterium.
        "Connected Entities through produced Shapes"

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _XSControl.XSControl_ConnectedShapes_ExploreLabel(self, *args)


    def AdjacentEntities(*args):
        """
        AdjacentEntities(TopoDS_Shape ashape, Handle_Transfer_TransientProcess TP, TopAbs_ShapeEnum const type) -> Handle_TColStd_HSequenceOfTransient

        This functions considers a shape from a transfer and performs
        the search function explained above

        :type ashape: OCC.wrapper.TopoDS.TopoDS_Shape
        :type TP: OCC.wrapper.Transfer.Handle_Transfer_TransientProcess
        :type type: OCC.wrapper.TopAbs.TopAbs_ShapeEnum
        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfTransient

        """
        return _XSControl.XSControl_ConnectedShapes_AdjacentEntities(*args)

    AdjacentEntities = staticmethod(AdjacentEntities)

    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _XSControl.XSControl_ConnectedShapes_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _XSControl.XSControl_ConnectedShapes_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _XSControl.XSControl_ConnectedShapes_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _XSControl.delete_XSControl_ConnectedShapes
XSControl_ConnectedShapes_swigregister = _XSControl.XSControl_ConnectedShapes_swigregister
XSControl_ConnectedShapes_swigregister(XSControl_ConnectedShapes)

def XSControl_ConnectedShapes_AdjacentEntities(*args):
    """
    XSControl_ConnectedShapes_AdjacentEntities(TopoDS_Shape ashape, Handle_Transfer_TransientProcess TP, TopAbs_ShapeEnum const type) -> Handle_TColStd_HSequenceOfTransient

    This functions considers a shape from a transfer and performs
    the search function explained above

    :type ashape: OCC.wrapper.TopoDS.TopoDS_Shape
    :type TP: OCC.wrapper.Transfer.Handle_Transfer_TransientProcess
    :type type: OCC.wrapper.TopAbs.TopAbs_ShapeEnum
    :rtype: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfTransient

    """
    return _XSControl.XSControl_ConnectedShapes_AdjacentEntities(*args)

def XSControl_ConnectedShapes_get_type_name(*args):
    """
    XSControl_ConnectedShapes_get_type_name() -> char const *

    :rtype: const char *

    """
    return _XSControl.XSControl_ConnectedShapes_get_type_name(*args)

def XSControl_ConnectedShapes_get_type_descriptor(*args):
    """
    XSControl_ConnectedShapes_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _XSControl.XSControl_ConnectedShapes_get_type_descriptor(*args)

class XSControl_Vars(Standard.Standard_Transient):
    """
    Defines a receptacle for externally defined variables, each
    one has a name

    I.E. a WorkSession for XSTEP is generally used inside a
    context, which brings variables, especially shapes and
    geometries. For instance DRAW or an application engine

    This class provides a common form for this. It also provides
    a default implementation (locally recorded variables in a
    dictionary), but which is aimed to be redefined
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_XSControl_Vars
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_XSControl_Vars(self) 
            return h


    def __init__(self, *args):
        """
        __init__(XSControl_Vars self) -> XSControl_Vars

        Defines a receptacle for externally defined variables, each
        one has a name

        I.E. a WorkSession for XSTEP is generally used inside a
        context, which brings variables, especially shapes and
        geometries. For instance DRAW or an application engine

        This class provides a common form for this. It also provides
        a default implementation (locally recorded variables in a
        dictionary), but which is aimed to be redefined
        """
        this = _XSControl.new_XSControl_Vars(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Set(self, *args):
        """
        Set(XSControl_Vars self, Standard_CString const name, Handle_Standard_Transient val)

        :type name: OCC.wrapper.Standard.Standard_CString
        :type val: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _XSControl.XSControl_Vars_Set(self, *args)


    def Get(self, *args):
        """
        Get(XSControl_Vars self, Standard_CString & name) -> Handle_Standard_Transient

        :type name: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _XSControl.XSControl_Vars_Get(self, *args)


    def GetGeom(self, *args):
        """
        GetGeom(XSControl_Vars self, Standard_CString & name) -> Handle_Geom_Geometry

        :type name: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _XSControl.XSControl_Vars_GetGeom(self, *args)


    def GetCurve2d(self, *args):
        """
        GetCurve2d(XSControl_Vars self, Standard_CString & name) -> Handle_Geom2d_Curve

        :type name: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Curve

        """
        return _XSControl.XSControl_Vars_GetCurve2d(self, *args)


    def GetCurve(self, *args):
        """
        GetCurve(XSControl_Vars self, Standard_CString & name) -> Handle_Geom_Curve

        :type name: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Geom.Handle_Geom_Curve

        """
        return _XSControl.XSControl_Vars_GetCurve(self, *args)


    def GetSurface(self, *args):
        """
        GetSurface(XSControl_Vars self, Standard_CString & name) -> Handle_Geom_Surface

        :type name: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Geom.Handle_Geom_Surface

        """
        return _XSControl.XSControl_Vars_GetSurface(self, *args)


    def SetPoint(self, *args):
        """
        SetPoint(XSControl_Vars self, Standard_CString const name, gp_Pnt val)

        :type name: OCC.wrapper.Standard.Standard_CString
        :type val: OCC.wrapper.gp.gp_Pnt

        """
        return _XSControl.XSControl_Vars_SetPoint(self, *args)


    def SetPoint2d(self, *args):
        """
        SetPoint2d(XSControl_Vars self, Standard_CString const name, gp_Pnt2d val)

        :type name: OCC.wrapper.Standard.Standard_CString
        :type val: OCC.wrapper.gp.gp_Pnt2d

        """
        return _XSControl.XSControl_Vars_SetPoint2d(self, *args)


    def GetPoint(self, *args):
        """
        GetPoint(XSControl_Vars self, Standard_CString & name, gp_Pnt pnt) -> Standard_Boolean

        :type name: OCC.wrapper.Standard.Standard_CString
        :type pnt: OCC.wrapper.gp.gp_Pnt
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _XSControl.XSControl_Vars_GetPoint(self, *args)


    def GetPoint2d(self, *args):
        """
        GetPoint2d(XSControl_Vars self, Standard_CString & name, gp_Pnt2d pnt) -> Standard_Boolean

        :type name: OCC.wrapper.Standard.Standard_CString
        :type pnt: OCC.wrapper.gp.gp_Pnt2d
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _XSControl.XSControl_Vars_GetPoint2d(self, *args)


    def SetShape(self, *args):
        """
        SetShape(XSControl_Vars self, Standard_CString const name, TopoDS_Shape val)

        :type name: OCC.wrapper.Standard.Standard_CString
        :type val: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _XSControl.XSControl_Vars_SetShape(self, *args)


    def GetShape(self, *args):
        """
        GetShape(XSControl_Vars self, Standard_CString & name) -> TopoDS_Shape

        :type name: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _XSControl.XSControl_Vars_GetShape(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _XSControl.XSControl_Vars_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _XSControl.XSControl_Vars_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _XSControl.XSControl_Vars_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _XSControl.delete_XSControl_Vars
XSControl_Vars_swigregister = _XSControl.XSControl_Vars_swigregister
XSControl_Vars_swigregister(XSControl_Vars)

def XSControl_Vars_get_type_name(*args):
    """
    XSControl_Vars_get_type_name() -> char const *

    :rtype: const char *

    """
    return _XSControl.XSControl_Vars_get_type_name(*args)

def XSControl_Vars_get_type_descriptor(*args):
    """
    XSControl_Vars_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _XSControl.XSControl_Vars_get_type_descriptor(*args)

class Handle_XSControl_SignTransferStatus(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_XSControl_SignTransferStatus self)

        Nullify the handle


        """
        return _XSControl.Handle_XSControl_SignTransferStatus_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_XSControl_SignTransferStatus self) -> bool

        Check for being null

        :rtype: bool

        """
        return _XSControl.Handle_XSControl_SignTransferStatus_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_XSControl_SignTransferStatus self, XSControl_SignTransferStatus thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _XSControl.Handle_XSControl_SignTransferStatus_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_XSControl_SignTransferStatus self, Handle_XSControl_SignTransferStatus theHandle) -> Handle_XSControl_SignTransferStatus
        assign(Handle_XSControl_SignTransferStatus self, XSControl_SignTransferStatus thePtr) -> Handle_XSControl_SignTransferStatus
        assign(Handle_XSControl_SignTransferStatus self, Handle_XSControl_SignTransferStatus theHandle) -> Handle_XSControl_SignTransferStatus

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _XSControl.Handle_XSControl_SignTransferStatus_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_XSControl_SignTransferStatus self) -> XSControl_SignTransferStatus

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _XSControl.Handle_XSControl_SignTransferStatus_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_XSControl_SignTransferStatus self) -> XSControl_SignTransferStatus

        Member access operator (note non-const)

        :rtype: T *

        """
        return _XSControl.Handle_XSControl_SignTransferStatus___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_XSControl_SignTransferStatus self) -> XSControl_SignTransferStatus

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _XSControl.Handle_XSControl_SignTransferStatus___ref__(self, *args)


    def __hash__(self):
        return _XSControl.Handle_XSControl_SignTransferStatus___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _XSControl.Handle_XSControl_SignTransferStatus___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _XSControl.new_Handle_XSControl_SignTransferStatus(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_XSControl.Handle_XSControl_SignTransferStatus_DownCast)
    __swig_destroy__ = _XSControl.delete_Handle_XSControl_SignTransferStatus

    def SetReader(self, *args):
        """
        SetReader(Handle_XSControl_SignTransferStatus self, Handle_XSControl_TransferReader TR)

        Sets a TransferReader to work

        :type TR: OCC.wrapper.XSControl.Handle_XSControl_TransferReader

        """
        return _XSControl.Handle_XSControl_SignTransferStatus_SetReader(self, *args)


    def SetMap(self, *args):
        """
        SetMap(Handle_XSControl_SignTransferStatus self, Handle_Transfer_TransientProcess TP)

        Sets a precise map to sign entities
        This definition oversedes the creation with a TransferReader

        :type TP: OCC.wrapper.Transfer.Handle_Transfer_TransientProcess

        """
        return _XSControl.Handle_XSControl_SignTransferStatus_SetMap(self, *args)


    def Map(self, *args):
        """
        Map(Handle_XSControl_SignTransferStatus self) -> Handle_Transfer_TransientProcess

        Returns the TransientProcess used as precised one
        Returns a Null Handle for a creation from a TransferReader
        without any further setting

        :rtype: OCC.wrapper.Transfer.Handle_Transfer_TransientProcess

        """
        return _XSControl.Handle_XSControl_SignTransferStatus_Map(self, *args)


    def Reader(self, *args):
        """
        Reader(Handle_XSControl_SignTransferStatus self) -> Handle_XSControl_TransferReader

        Returns the Reader (if created with a Reader)
        Returns a Null Handle if not created with a Reader

        :rtype: OCC.wrapper.XSControl.Handle_XSControl_TransferReader

        """
        return _XSControl.Handle_XSControl_SignTransferStatus_Reader(self, *args)


    def Value(self, *args):
        """
        Value(Handle_XSControl_SignTransferStatus self, Handle_Standard_Transient ent, Handle_Interface_InterfaceModel model) -> Standard_CString

        Returns the Signature for a Transient object, as its transfer
        status

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type model: OCC.wrapper.Interface.Handle_Interface_InterfaceModel
        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _XSControl.Handle_XSControl_SignTransferStatus_Value(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_XSControl_SignTransferStatus self) -> char const *

        :rtype: const char *

        """
        return _XSControl.Handle_XSControl_SignTransferStatus_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _XSControl.Handle_XSControl_SignTransferStatus_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _XSControl.Handle_XSControl_SignTransferStatus_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetIntCase(self, *args):
        """
        SetIntCase(Handle_XSControl_SignTransferStatus self, Standard_Boolean const hasmin, Standard_Integer const valmin, Standard_Boolean const hasmax, Standard_Integer const valmax)

        Sets the information data to tell "integer cases" with
        possible min and max values
        To be called when creating

        :type hasmin: bool
        :type valmin: int
        :type hasmax: bool
        :type valmax: int

        """
        return _XSControl.Handle_XSControl_SignTransferStatus_SetIntCase(self, *args)


    def IsIntCase(self, *args):
        """
        IsIntCase(Handle_XSControl_SignTransferStatus self) -> Standard_Boolean

        Tells if this Signature gives integer values
        and returns values from SetIntCase if True

        :type hasmin: bool
        :type valmin: int
        :type hasmax: bool
        :type valmax: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _XSControl.Handle_XSControl_SignTransferStatus_IsIntCase(self, *args)


    def AddCase(self, *args):
        """
        AddCase(Handle_XSControl_SignTransferStatus self, Standard_CString const acase)

        Adds a possible case
        To be called when creating, IF the list of possible cases for
        Value is known when starting
        For instance, for CDL types, rather do not fill this,
        but for a specific enumeration (such as a status), can be used

        :type acase: OCC.wrapper.Standard.Standard_CString

        """
        return _XSControl.Handle_XSControl_SignTransferStatus_AddCase(self, *args)


    def CaseList(self, *args):
        """
        CaseList(Handle_XSControl_SignTransferStatus self) -> Handle_TColStd_HSequenceOfAsciiString

        Returns the predefined list of possible cases, filled by AddCase
        Null Handle if no predefined list (hence, to be counted)
        Useful to filter on  really possible vase, for instance, or
        for a help

        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfAsciiString

        """
        return _XSControl.Handle_XSControl_SignTransferStatus_CaseList(self, *args)


    def Name(self, *args):
        """
        Name(Handle_XSControl_SignTransferStatus self) -> Standard_CString

        Returns an identification of the Signature (a word), given at
        initialization time
        Returns the Signature for a Transient object. It is specific
        of each sub-class of Signature. For a Null Handle, it should
        provide ""
        It can work with the model which contains the entity

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _XSControl.Handle_XSControl_SignTransferStatus_Name(self, *args)


    def Label(self, *args):
        """
        Label(Handle_XSControl_SignTransferStatus self) -> TCollection_AsciiString

        The label of a Signature uses its name as follow :
        "Signature : <name>"

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _XSControl.Handle_XSControl_SignTransferStatus_Label(self, *args)


    def Matches(self, *args):
        """
        Matches(Handle_XSControl_SignTransferStatus self, Handle_Standard_Transient ent, Handle_Interface_InterfaceModel model, TCollection_AsciiString text, Standard_Boolean const exact) -> Standard_Boolean

        Tells if the value for <ent> in <model> matches a text, with
        a criterium <exact>.
        The default definition calls MatchValue
        Can be redefined

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type model: OCC.wrapper.Interface.Handle_Interface_InterfaceModel
        :type text: OCC.wrapper.TCollection.TCollection_AsciiString
        :type exact: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _XSControl.Handle_XSControl_SignTransferStatus_Matches(self, *args)


    def MatchValue(self, *args):
        """
        MatchValue(Handle_XSControl_SignTransferStatus self, Standard_CString const val, TCollection_AsciiString text, Standard_Boolean const exact) -> Standard_Boolean

        Default procedure to tell if a value <val> matches a text
        with a criterium <exact>. <exact> = True requires equality,
        else only contained (no reg-exp)

        :type val: OCC.wrapper.Standard.Standard_CString
        :type text: OCC.wrapper.TCollection.TCollection_AsciiString
        :type exact: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _XSControl.Handle_XSControl_SignTransferStatus_MatchValue(self, *args)


    def IntValue(self, *args):
        """
        IntValue(Handle_XSControl_SignTransferStatus self, Standard_Integer const val) -> Standard_CString

        This procedure converts an Integer to a CString
        It is a convenient way when the value of a signature has the
        form of a simple integer value
        The value is to be used immediately (one buffer only, no copy)

        :type val: int
        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _XSControl.Handle_XSControl_SignTransferStatus_IntValue(self, *args)


    def Text(self, *args):
        """
        Text(Handle_XSControl_SignTransferStatus self, Handle_Standard_Transient ent, Handle_Standard_Transient context) -> TCollection_AsciiString

        Returns an identification of the Signature (a word), given at
        initialization time
        Specialised to consider context as an InterfaceModel

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type context: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _XSControl.Handle_XSControl_SignTransferStatus_Text(self, *args)


    def ClassName(self, *args):
        """
        ClassName(Handle_XSControl_SignTransferStatus self, Standard_CString const typnam) -> Standard_CString

        From a CDL Type Name, returns the Class part (package dropped)
        WARNING : buffered, to be immediately copied or printed

        :type typnam: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _XSControl.Handle_XSControl_SignTransferStatus_ClassName(self, *args)


    def TextAlone(self, *args):
        """
        TextAlone(Handle_XSControl_SignTransferStatus self, Handle_Standard_Transient ent) -> TCollection_AsciiString

        Gives a text as a signature for a transient object alone, i.e.
        without defined context.
        By default, calls Text with undefined context (Null Handle) and
        if empty, then returns DynamicType

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _XSControl.Handle_XSControl_SignTransferStatus_TextAlone(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_XSControl_SignTransferStatus self)

        Memory deallocator for transient classes


        """
        return _XSControl.Handle_XSControl_SignTransferStatus_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_XSControl_SignTransferStatus self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_XSControl_SignTransferStatus self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _XSControl.Handle_XSControl_SignTransferStatus_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_XSControl_SignTransferStatus self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_XSControl_SignTransferStatus self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _XSControl.Handle_XSControl_SignTransferStatus_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_XSControl_SignTransferStatus self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _XSControl.Handle_XSControl_SignTransferStatus_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_XSControl_SignTransferStatus self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _XSControl.Handle_XSControl_SignTransferStatus_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_XSControl_SignTransferStatus self)

        Increments the reference counter of this object


        """
        return _XSControl.Handle_XSControl_SignTransferStatus_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_XSControl_SignTransferStatus self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _XSControl.Handle_XSControl_SignTransferStatus_DecrementRefCounter(self, *args)

Handle_XSControl_SignTransferStatus_swigregister = _XSControl.Handle_XSControl_SignTransferStatus_swigregister
Handle_XSControl_SignTransferStatus_swigregister(Handle_XSControl_SignTransferStatus)

def Handle_XSControl_SignTransferStatus_DownCast(thing):
    return _XSControl.Handle_XSControl_SignTransferStatus_DownCast(thing)
Handle_XSControl_SignTransferStatus_DownCast = _XSControl.Handle_XSControl_SignTransferStatus_DownCast

class Handle_XSControl_SelectForTransfer(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_XSControl_SelectForTransfer self)

        Nullify the handle


        """
        return _XSControl.Handle_XSControl_SelectForTransfer_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_XSControl_SelectForTransfer self) -> bool

        Check for being null

        :rtype: bool

        """
        return _XSControl.Handle_XSControl_SelectForTransfer_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_XSControl_SelectForTransfer self, XSControl_SelectForTransfer thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _XSControl.Handle_XSControl_SelectForTransfer_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_XSControl_SelectForTransfer self, Handle_XSControl_SelectForTransfer theHandle) -> Handle_XSControl_SelectForTransfer
        assign(Handle_XSControl_SelectForTransfer self, XSControl_SelectForTransfer thePtr) -> Handle_XSControl_SelectForTransfer
        assign(Handle_XSControl_SelectForTransfer self, Handle_XSControl_SelectForTransfer theHandle) -> Handle_XSControl_SelectForTransfer

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _XSControl.Handle_XSControl_SelectForTransfer_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_XSControl_SelectForTransfer self) -> XSControl_SelectForTransfer

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _XSControl.Handle_XSControl_SelectForTransfer_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_XSControl_SelectForTransfer self) -> XSControl_SelectForTransfer

        Member access operator (note non-const)

        :rtype: T *

        """
        return _XSControl.Handle_XSControl_SelectForTransfer___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_XSControl_SelectForTransfer self) -> XSControl_SelectForTransfer

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _XSControl.Handle_XSControl_SelectForTransfer___ref__(self, *args)


    def __hash__(self):
        return _XSControl.Handle_XSControl_SelectForTransfer___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _XSControl.Handle_XSControl_SelectForTransfer___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _XSControl.new_Handle_XSControl_SelectForTransfer(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_XSControl.Handle_XSControl_SelectForTransfer_DownCast)
    __swig_destroy__ = _XSControl.delete_Handle_XSControl_SelectForTransfer

    def SetReader(self, *args):
        """
        SetReader(Handle_XSControl_SelectForTransfer self, Handle_XSControl_TransferReader TR)

        Sets a TransferReader to sort entities : it brings the Actor,
        which may change, while the TransferReader does not

        :type TR: OCC.wrapper.XSControl.Handle_XSControl_TransferReader

        """
        return _XSControl.Handle_XSControl_SelectForTransfer_SetReader(self, *args)


    def SetActor(self, *args):
        """
        SetActor(Handle_XSControl_SelectForTransfer self, Handle_Transfer_ActorOfTransientProcess act)

        Sets a precise actor to sort entities
        This definition oversedes the creation with a TransferReader

        :type act: OCC.wrapper.Transfer.Handle_Transfer_ActorOfTransientProcess

        """
        return _XSControl.Handle_XSControl_SelectForTransfer_SetActor(self, *args)


    def Actor(self, *args):
        """
        Actor(Handle_XSControl_SelectForTransfer self) -> Handle_Transfer_ActorOfTransientProcess

        Returns the Actor used as precised one.
        Returns a Null Handle for a creation from a TransferReader
        without any further setting

        :rtype: OCC.wrapper.Transfer.Handle_Transfer_ActorOfTransientProcess

        """
        return _XSControl.Handle_XSControl_SelectForTransfer_Actor(self, *args)


    def Reader(self, *args):
        """
        Reader(Handle_XSControl_SelectForTransfer self) -> Handle_XSControl_TransferReader

        Returns the Reader (if created with a Reader)
        Returns a Null Handle if not created with a Reader

        :rtype: OCC.wrapper.XSControl.Handle_XSControl_TransferReader

        """
        return _XSControl.Handle_XSControl_SelectForTransfer_Reader(self, *args)


    def Sort(self, *args):
        """
        Sort(Handle_XSControl_SelectForTransfer self, Standard_Integer const rank, Handle_Standard_Transient ent, Handle_Interface_InterfaceModel model) -> Standard_Boolean

        Returns True for an Entity which is recognized by the Actor,
        either the precised one, or the one defined by TransferReader

        :type rank: int
        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type model: OCC.wrapper.Interface.Handle_Interface_InterfaceModel
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _XSControl.Handle_XSControl_SelectForTransfer_Sort(self, *args)


    def ExtractLabel(self, *args):
        """
        ExtractLabel(Handle_XSControl_SelectForTransfer self) -> TCollection_AsciiString

        Returns a text defining the criterium : "Recognized for Transfer [(current actor)]"

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _XSControl.Handle_XSControl_SelectForTransfer_ExtractLabel(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_XSControl_SelectForTransfer self) -> char const *

        :rtype: const char *

        """
        return _XSControl.Handle_XSControl_SelectForTransfer_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _XSControl.Handle_XSControl_SelectForTransfer_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _XSControl.Handle_XSControl_SelectForTransfer_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def IsDirect(self, *args):
        """
        IsDirect(Handle_XSControl_SelectForTransfer self) -> Standard_Boolean

        Returns True if Sort criterium is Direct, False if Reverse

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _XSControl.Handle_XSControl_SelectForTransfer_IsDirect(self, *args)


    def SetDirect(self, *args):
        """
        SetDirect(Handle_XSControl_SelectForTransfer self, Standard_Boolean const direct)

        Sets Sort criterium sense to a new value
        (True : Direct , False : Reverse)

        :type direct: bool

        """
        return _XSControl.Handle_XSControl_SelectForTransfer_SetDirect(self, *args)


    def RootResult(self, *args):
        """
        RootResult(Handle_XSControl_SelectForTransfer self, Interface_Graph G) -> Interface_EntityIterator

        Returns the list of selected entities. Works by calling the
        method Sort on each input Entity : the Entity is kept as
        output if Sort returns the same value as Direct status

        :type G: OCC.wrapper.Interface.Interface_Graph
        :rtype: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _XSControl.Handle_XSControl_SelectForTransfer_RootResult(self, *args)


    def SortInGraph(self, *args):
        """
        SortInGraph(Handle_XSControl_SelectForTransfer self, Standard_Integer const rank, Handle_Standard_Transient ent, Interface_Graph G) -> Standard_Boolean

        Works as Sort but works on the Graph
        Default directly calls Sort, but it can be redefined
        If SortInGraph is redefined, Sort should be defined even if
        not called (to avoid deferred methods in a final class)

        :type rank: int
        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type G: OCC.wrapper.Interface.Interface_Graph
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _XSControl.Handle_XSControl_SelectForTransfer_SortInGraph(self, *args)


    def Label(self, *args):
        """
        Label(Handle_XSControl_SelectForTransfer self) -> TCollection_AsciiString

        Returns a text saying "Picked" or "Removed", plus the
        specific criterium returned by ExtractLabel (see below)

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _XSControl.Handle_XSControl_SelectForTransfer_Label(self, *args)


    def SetInput(self, *args):
        """
        SetInput(Handle_XSControl_SelectForTransfer self, Handle_IFSelect_Selection sel)

        Defines or Changes the Input Selection

        :type sel: OCC.wrapper.IFSelect.Handle_IFSelect_Selection

        """
        return _XSControl.Handle_XSControl_SelectForTransfer_SetInput(self, *args)


    def Input(self, *args):
        """
        Input(Handle_XSControl_SelectForTransfer self) -> Handle_IFSelect_Selection

        Returns the Input Selection

        :rtype: OCC.wrapper.IFSelect.Handle_IFSelect_Selection

        """
        return _XSControl.Handle_XSControl_SelectForTransfer_Input(self, *args)


    def HasInput(self, *args):
        """
        HasInput(Handle_XSControl_SelectForTransfer self) -> Standard_Boolean

        Returns True if the Input Selection is defined, False else

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _XSControl.Handle_XSControl_SelectForTransfer_HasInput(self, *args)


    def HasAlternate(self, *args):
        """
        HasAlternate(Handle_XSControl_SelectForTransfer self) -> Standard_Boolean

        Tells if an Alternate List has been set, i.e. : the Alternate
        Definition is present and set

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _XSControl.Handle_XSControl_SelectForTransfer_HasAlternate(self, *args)


    def Alternate(self, *args):
        """
        Alternate(Handle_XSControl_SelectForTransfer self) -> Handle_IFSelect_SelectPointed

        Returns the Alternate Definition
        It is returned modifiable, hence an already defined
        SelectPointed can be used
        But if it was not yet defined, it is created the first time

        It is exploited by InputResult

        :rtype: OCC.wrapper.IFSelect.Handle_IFSelect_SelectPointed

        """
        return _XSControl.Handle_XSControl_SelectForTransfer_Alternate(self, *args)


    def InputResult(self, *args):
        """
        InputResult(Handle_XSControl_SelectForTransfer self, Interface_Graph G) -> Interface_EntityIterator

        Returns the Result determined by Input Selection, as Unique
        if Input Selection is not defined, returns an empty list.

        If Alternate is set, InputResult takes its definition instead
        of calling the Input Selection, then clears it

        :type G: OCC.wrapper.Interface.Interface_Graph
        :rtype: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _XSControl.Handle_XSControl_SelectForTransfer_InputResult(self, *args)


    def FillIterator(self, *args):
        """
        FillIterator(Handle_XSControl_SelectForTransfer self, IFSelect_SelectionIterator iter)

        Puts in an Iterator the Selections from which "me" depends
        This list contains one Selection : the InputSelection

        :type iter: OCC.wrapper.IFSelect.IFSelect_SelectionIterator

        """
        return _XSControl.Handle_XSControl_SelectForTransfer_FillIterator(self, *args)


    def UniqueResult(self, *args):
        """
        UniqueResult(Handle_XSControl_SelectForTransfer self, Interface_Graph G) -> Interface_EntityIterator

        Returns the list of selected entities, each of them beeing
        unique. Default definition works from RootResult. According
        HasUniqueResult, UniqueResult returns directly RootResult,
        or build a Unique Result from it with a Graph.

        :type G: OCC.wrapper.Interface.Interface_Graph
        :rtype: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _XSControl.Handle_XSControl_SelectForTransfer_UniqueResult(self, *args)


    def CompleteResult(self, *args):
        """
        CompleteResult(Handle_XSControl_SelectForTransfer self, Interface_Graph G) -> Interface_EntityIterator

        Returns the list of entities involved by a Selection, i.e.
        UniqueResult plus the shared entities (directly or not)

        :type G: OCC.wrapper.Interface.Interface_Graph
        :rtype: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _XSControl.Handle_XSControl_SelectForTransfer_CompleteResult(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_XSControl_SelectForTransfer self)

        Memory deallocator for transient classes


        """
        return _XSControl.Handle_XSControl_SelectForTransfer_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_XSControl_SelectForTransfer self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_XSControl_SelectForTransfer self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _XSControl.Handle_XSControl_SelectForTransfer_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_XSControl_SelectForTransfer self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_XSControl_SelectForTransfer self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _XSControl.Handle_XSControl_SelectForTransfer_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_XSControl_SelectForTransfer self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _XSControl.Handle_XSControl_SelectForTransfer_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_XSControl_SelectForTransfer self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _XSControl.Handle_XSControl_SelectForTransfer_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_XSControl_SelectForTransfer self)

        Increments the reference counter of this object


        """
        return _XSControl.Handle_XSControl_SelectForTransfer_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_XSControl_SelectForTransfer self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _XSControl.Handle_XSControl_SelectForTransfer_DecrementRefCounter(self, *args)

Handle_XSControl_SelectForTransfer_swigregister = _XSControl.Handle_XSControl_SelectForTransfer_swigregister
Handle_XSControl_SelectForTransfer_swigregister(Handle_XSControl_SelectForTransfer)

def Handle_XSControl_SelectForTransfer_DownCast(thing):
    return _XSControl.Handle_XSControl_SelectForTransfer_DownCast(thing)
Handle_XSControl_SelectForTransfer_DownCast = _XSControl.Handle_XSControl_SelectForTransfer_DownCast

class Handle_XSControl_TransferReader(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_XSControl_TransferReader self)

        Nullify the handle


        """
        return _XSControl.Handle_XSControl_TransferReader_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_XSControl_TransferReader self) -> bool

        Check for being null

        :rtype: bool

        """
        return _XSControl.Handle_XSControl_TransferReader_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_XSControl_TransferReader self, XSControl_TransferReader thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _XSControl.Handle_XSControl_TransferReader_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_XSControl_TransferReader self, Handle_XSControl_TransferReader theHandle) -> Handle_XSControl_TransferReader
        assign(Handle_XSControl_TransferReader self, XSControl_TransferReader thePtr) -> Handle_XSControl_TransferReader
        assign(Handle_XSControl_TransferReader self, Handle_XSControl_TransferReader theHandle) -> Handle_XSControl_TransferReader

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _XSControl.Handle_XSControl_TransferReader_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_XSControl_TransferReader self) -> XSControl_TransferReader

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _XSControl.Handle_XSControl_TransferReader_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_XSControl_TransferReader self) -> XSControl_TransferReader

        Member access operator (note non-const)

        :rtype: T *

        """
        return _XSControl.Handle_XSControl_TransferReader___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_XSControl_TransferReader self) -> XSControl_TransferReader

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _XSControl.Handle_XSControl_TransferReader___ref__(self, *args)


    def __hash__(self):
        return _XSControl.Handle_XSControl_TransferReader___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _XSControl.Handle_XSControl_TransferReader___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _XSControl.new_Handle_XSControl_TransferReader(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_XSControl.Handle_XSControl_TransferReader_DownCast)
    __swig_destroy__ = _XSControl.delete_Handle_XSControl_TransferReader

    def SetController(self, *args):
        """
        SetController(Handle_XSControl_TransferReader self, Handle_XSControl_Controller theControl)

        Sets a Controller. It is required to generate the Actor.
        Elsewhere, the Actor must be provided directly

        :type theControl: OCC.wrapper.XSControl.Handle_XSControl_Controller

        """
        return _XSControl.Handle_XSControl_TransferReader_SetController(self, *args)


    def SetActor(self, *args):
        """
        SetActor(Handle_XSControl_TransferReader self, Handle_Transfer_ActorOfTransientProcess theActor)

        Sets the Actor directly : this value will be used if the
        Controller is not set

        :type theActor: OCC.wrapper.Transfer.Handle_Transfer_ActorOfTransientProcess

        """
        return _XSControl.Handle_XSControl_TransferReader_SetActor(self, *args)


    def Actor(self, *args):
        """
        Actor(Handle_XSControl_TransferReader self) -> Handle_Transfer_ActorOfTransientProcess

        Returns the Actor, determined by the Controller, or if this
        one is unknown, directly set.
        Once it has been defined, it can then be edited.

        :rtype: OCC.wrapper.Transfer.Handle_Transfer_ActorOfTransientProcess

        """
        return _XSControl.Handle_XSControl_TransferReader_Actor(self, *args)


    def SetModel(self, *args):
        """
        SetModel(Handle_XSControl_TransferReader self, Handle_Interface_InterfaceModel theModel)

        Sets an InterfaceModel. This causes former results, computed
        from another one, to be lost (see also Clear)

        :type theModel: OCC.wrapper.Interface.Handle_Interface_InterfaceModel

        """
        return _XSControl.Handle_XSControl_TransferReader_SetModel(self, *args)


    def SetGraph(self, *args):
        """
        SetGraph(Handle_XSControl_TransferReader self, Handle_Interface_HGraph theGraph)

        Sets a Graph and its InterfaceModel (calls SetModel)

        :type theGraph: OCC.wrapper.Interface.Handle_Interface_HGraph

        """
        return _XSControl.Handle_XSControl_TransferReader_SetGraph(self, *args)


    def Model(self, *args):
        """
        Returns the currently set InterfaceModel

        :rtype: OCC.wrapper.Interface.Handle_Interface_InterfaceModel

        """
        res = _XSControl.Handle_XSControl_TransferReader_Model(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetContext(self, *args):
        """
        SetContext(Handle_XSControl_TransferReader self, Standard_CString const theName, Handle_Standard_Transient theCtx)

        Sets a Context : according to receiving appli, to be
        interpreted by the Actor

        :type theName: OCC.wrapper.Standard.Standard_CString
        :type theCtx: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _XSControl.Handle_XSControl_TransferReader_SetContext(self, *args)


    def GetContext(self, *args):
        """
        GetContext(Handle_XSControl_TransferReader self, Standard_CString const theName, Handle_Standard_Type theType, Handle_Standard_Transient theCtx) -> Standard_Boolean

        Returns the Context attached to a name, if set and if it is
        Kind of the type, else a Null Handle
        Returns True if OK, False if no Context

        :type theName: OCC.wrapper.Standard.Standard_CString
        :type theType: OCC.wrapper.Standard.Handle_Standard_Type
        :type theCtx: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _XSControl.Handle_XSControl_TransferReader_GetContext(self, *args)


    def Context(self, *args):
        """
        Context(Handle_XSControl_TransferReader self) -> NCollection_DataMap< TCollection_AsciiString,opencascade::handle< Standard_Transient > > &

        Returns (modifiable) the whole definition of Context
        Rather for internal use (ex.: preparing and setting in once)

        :rtype: OCC.wrapper.XSControl.NCollection_DataMap_TCollection_AsciiString_Handle_Standard_Transient

        """
        return _XSControl.Handle_XSControl_TransferReader_Context(self, *args)


    def SetFileName(self, *args):
        """
        SetFileName(Handle_XSControl_TransferReader self, Standard_CString const theName)

        Sets a new value for (loaded) file name

        :type theName: OCC.wrapper.Standard.Standard_CString

        """
        return _XSControl.Handle_XSControl_TransferReader_SetFileName(self, *args)


    def FileName(self, *args):
        """
        FileName(Handle_XSControl_TransferReader self) -> Standard_CString

        Returns actual value of file name

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _XSControl.Handle_XSControl_TransferReader_FileName(self, *args)


    def Clear(self, *args):
        """
        Clear(Handle_XSControl_TransferReader self, Standard_Integer const theMode)

        Clears data, according mode :
        -1 all
        0 nothing done
        +1 final results
        +2 working data (model, context, transfer process)

        :type theMode: int

        """
        return _XSControl.Handle_XSControl_TransferReader_Clear(self, *args)


    def TransientProcess(self, *args):
        """
        Returns the currently used TransientProcess
        It is computed from the model by TransferReadRoots, or by
        BeginTransferRead

        :rtype: OCC.wrapper.Transfer.Handle_Transfer_TransientProcess

        """
        res = _XSControl.Handle_XSControl_TransferReader_TransientProcess(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetTransientProcess(self, *args):
        """
        SetTransientProcess(Handle_XSControl_TransferReader self, Handle_Transfer_TransientProcess theTP)

        Forces the TransientProcess
        Remark : it also changes the Model and the Actor, from those
        recorded in the new TransientProcess

        :type theTP: OCC.wrapper.Transfer.Handle_Transfer_TransientProcess

        """
        return _XSControl.Handle_XSControl_TransferReader_SetTransientProcess(self, *args)


    def RecordResult(self, *args):
        """
        RecordResult(Handle_XSControl_TransferReader self, Handle_Standard_Transient theEnt) -> Standard_Boolean

        Records a final result of transferring an entity
        This result is recorded as a ResultFromModel, taken from
        the TransientProcess
        Returns True if a result is available, False else

        :type theEnt: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _XSControl.Handle_XSControl_TransferReader_RecordResult(self, *args)


    def IsRecorded(self, *args):
        """
        IsRecorded(Handle_XSControl_TransferReader self, Handle_Standard_Transient theEnt) -> Standard_Boolean

        Returns True if a final result is recorded for an entity
        Remark that it can bring no effective result if transfer has
        completely failed (FinalResult brings only fail messages ...)

        :type theEnt: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _XSControl.Handle_XSControl_TransferReader_IsRecorded(self, *args)


    def HasResult(self, *args):
        """
        HasResult(Handle_XSControl_TransferReader self, Handle_Standard_Transient theEnt) -> Standard_Boolean

        Returns True if a final result is recorded AND BRINGS AN
        EFFECTIVE RESULT (else, it brings only fail messages)

        :type theEnt: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _XSControl.Handle_XSControl_TransferReader_HasResult(self, *args)


    def RecordedList(self, *args):
        """
        RecordedList(Handle_XSControl_TransferReader self) -> Handle_TColStd_HSequenceOfTransient

        Returns the list of entities to which a final result is
        attached (i.e. processed by RecordResult)

        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfTransient

        """
        return _XSControl.Handle_XSControl_TransferReader_RecordedList(self, *args)


    def Skip(self, *args):
        """
        Skip(Handle_XSControl_TransferReader self, Handle_Standard_Transient theEnt) -> Standard_Boolean

        Note that an entity has been required for transfer but no
        result at all is available (typically : case not implemented)
        It is not an error, but it gives a specific status : Skipped
        Returns True if done, False if <ent> is not in starting model

        :type theEnt: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _XSControl.Handle_XSControl_TransferReader_Skip(self, *args)


    def IsSkipped(self, *args):
        """
        IsSkipped(Handle_XSControl_TransferReader self, Handle_Standard_Transient theEnt) -> Standard_Boolean

        Returns True if an entity is noted as skipped

        :type theEnt: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _XSControl.Handle_XSControl_TransferReader_IsSkipped(self, *args)


    def IsMarked(self, *args):
        """
        IsMarked(Handle_XSControl_TransferReader self, Handle_Standard_Transient theEnt) -> Standard_Boolean

        Returns True if an entity has been asked for transfert, hence
        it is marked, as : Recorded (a computation has ran, with or
        without an effective result), or Skipped (case ignored)

        :type theEnt: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _XSControl.Handle_XSControl_TransferReader_IsMarked(self, *args)


    def FinalResult(self, *args):
        """
        FinalResult(Handle_XSControl_TransferReader self, Handle_Standard_Transient theEnt) -> Handle_Transfer_ResultFromModel

        Returns the final result recorded for an entity, as such

        :type theEnt: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Transfer.Handle_Transfer_ResultFromModel

        """
        return _XSControl.Handle_XSControl_TransferReader_FinalResult(self, *args)


    def FinalEntityLabel(self, *args):
        """
        FinalEntityLabel(Handle_XSControl_TransferReader self, Handle_Standard_Transient theEnt) -> Standard_CString

        Returns the label attached to an entity recorded for final,
        or an empty string if not recorded

        :type theEnt: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _XSControl.Handle_XSControl_TransferReader_FinalEntityLabel(self, *args)


    def FinalEntityNumber(self, *args):
        """
        FinalEntityNumber(Handle_XSControl_TransferReader self, Handle_Standard_Transient theEnt) -> Standard_Integer

        Returns the number attached to the entity recorded for final,
        or zero if not recorded (looks in the ResultFromModel)

        :type theEnt: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _XSControl.Handle_XSControl_TransferReader_FinalEntityNumber(self, *args)


    def ResultFromNumber(self, *args):
        """
        ResultFromNumber(Handle_XSControl_TransferReader self, Standard_Integer const theNum) -> Handle_Transfer_ResultFromModel

        Returns the final result recorded for a NUMBER of entity
        (internal use). Null if out of range

        :type theNum: int
        :rtype: OCC.wrapper.Transfer.Handle_Transfer_ResultFromModel

        """
        return _XSControl.Handle_XSControl_TransferReader_ResultFromNumber(self, *args)


    def TransientResult(self, *args):
        """
        TransientResult(Handle_XSControl_TransferReader self, Handle_Standard_Transient theEnt) -> Handle_Standard_Transient

        Returns the resulting object as a Transient
        Null Handle if no result or result not transient

        :type theEnt: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _XSControl.Handle_XSControl_TransferReader_TransientResult(self, *args)


    def ShapeResult(self, *args):
        """
        ShapeResult(Handle_XSControl_TransferReader self, Handle_Standard_Transient theEnt) -> TopoDS_Shape

        Returns the resulting object as a Shape
        Null Shape if no result or result not a shape

        :type theEnt: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _XSControl.Handle_XSControl_TransferReader_ShapeResult(self, *args)


    def ClearResult(self, *args):
        """
        ClearResult(Handle_XSControl_TransferReader self, Handle_Standard_Transient theEnt, Standard_Integer const theMode) -> Standard_Boolean

        Clears recorded result for an entity, according mode
        <mode> = -1 : true, complete, clearing (erasing result)
        <mode> >= 0 : simple "stripping", see ResultFromModel,
        in particular, 0 for simple internal strip,
        10 for all but final result,
        11 for all : just label, status and filename are kept
        Returns True when done, False if nothing was to clear

        :type theEnt: OCC.wrapper.Standard.Handle_Standard_Transient
        :type theMode: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _XSControl.Handle_XSControl_TransferReader_ClearResult(self, *args)


    def EntityFromResult(self, *args):
        """
        EntityFromResult(Handle_XSControl_TransferReader self, Handle_Standard_Transient theRes, Standard_Integer const theMode=0) -> Handle_Standard_Transient

        Returns an entity from which a given result was produced.
        If <mode> = 0 (D), searches in last root transfers
        If <mode> = 1,     searches in last (root & sub) transfers
        If <mode> = 2,     searches in root recorded results
        If <mode> = 3,     searches in all (root & sub) recordeds
        <res> can be, either a transient object (result itself) or
        a binder. For a binder of shape, calls EntityFromShapeResult
        Returns a Null Handle if <res> not recorded

        :type theRes: OCC.wrapper.Standard.Handle_Standard_Transient
        :type theMode: int
        :rtype: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _XSControl.Handle_XSControl_TransferReader_EntityFromResult(self, *args)


    def EntityFromShapeResult(self, *args):
        """
        EntityFromShapeResult(Handle_XSControl_TransferReader self, TopoDS_Shape theRes, Standard_Integer const theMode=0) -> Handle_Standard_Transient

        Returns an entity from which a given shape result was produced
        Returns a Null Handle if <res> not recorded or not a Shape

        :type theRes: OCC.wrapper.TopoDS.TopoDS_Shape
        :type theMode: int
        :rtype: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _XSControl.Handle_XSControl_TransferReader_EntityFromShapeResult(self, *args)


    def EntitiesFromShapeList(self, *args):
        """
        EntitiesFromShapeList(Handle_XSControl_TransferReader self, Handle_TopTools_HSequenceOfShape theRes, Standard_Integer const theMode=0) -> Handle_TColStd_HSequenceOfTransient

        Returns the list of entities from which some shapes were
        produced : it corresponds to a loop on EntityFromShapeResult,
        but is optimised

        :type theRes: OCC.wrapper.TopTools.Handle_TopTools_HSequenceOfShape
        :type theMode: int
        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfTransient

        """
        return _XSControl.Handle_XSControl_TransferReader_EntitiesFromShapeList(self, *args)


    def CheckList(self, *args):
        """
        CheckList(Handle_XSControl_TransferReader self, Handle_Standard_Transient theEnt, Standard_Integer const theLevel=0) -> Interface_CheckIterator

        Returns the CheckList resulting from transferring <ent>, i.e.
        stored in its recorded form ResultFromModel
        (empty if transfer successful or not recorded ...)

        If <ent> is the Model, returns the complete cumulated
        check-list, <level> is ignored

        If <ent> is an entity of the Model, <level> applies as follows
        <level> : -1 for <ent> only, LAST transfer (TransientProcess)
        <level> : 0  for <ent> only (D)
        1  for <ent> and its immediate subtransfers, if any
        2  for <ent> and subtransferts at all levels

        :type theEnt: OCC.wrapper.Standard.Handle_Standard_Transient
        :type theLevel: int
        :rtype: OCC.wrapper.Interface.Interface_CheckIterator

        """
        return _XSControl.Handle_XSControl_TransferReader_CheckList(self, *args)


    def HasChecks(self, *args):
        """
        HasChecks(Handle_XSControl_TransferReader self, Handle_Standard_Transient theEnt, Standard_Boolean const FailsOnly) -> Standard_Boolean

        Returns True if an entity (with a final result) has checks :
        - failsonly = False : any kind of check message
        - failsonly = True  : fails only
        Returns False if <ent> is not recorded

        :type theEnt: OCC.wrapper.Standard.Handle_Standard_Transient
        :type FailsOnly: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _XSControl.Handle_XSControl_TransferReader_HasChecks(self, *args)


    def CheckedList(self, *args):
        """
        CheckedList(Handle_XSControl_TransferReader self, Handle_Standard_Transient theEnt, Interface_CheckStatus const WithCheck=Interface_CheckAny, Standard_Boolean const theResult) -> Handle_TColStd_HSequenceOfTransient

        Returns the list of starting entities to which a given check
        status is attached, IN FINAL RESULTS
        <ent> can be an entity, or the model to query all entities
        Below, "entities" are, either <ent> plus its sub-transferred,
        or all the entities of the model

        <check> = -2 , all entities whatever the check (see result)
        <check> = -1 , entities with no fail (warning allowed)
        <check> =  0 , entities with no check at all
        <check> =  1 , entities with warning but no fail
        <check> =  2 , entities with fail
        <result> : if True, only entities with an attached result
        Remark : result True and check=0 will give an empty list

        :type theEnt: OCC.wrapper.Standard.Handle_Standard_Transient
        :type WithCheck: OCC.wrapper.Interface.Interface_CheckStatus
        :type theResult: bool
        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfTransient

        """
        return _XSControl.Handle_XSControl_TransferReader_CheckedList(self, *args)


    def BeginTransfer(self, *args):
        """
        BeginTransfer(Handle_XSControl_TransferReader self) -> Standard_Boolean

        Defines a new TransferProcess for reading transfer
        Returns True if done, False if data are not properly defined
        (the Model, the Actor for Read)

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _XSControl.Handle_XSControl_TransferReader_BeginTransfer(self, *args)


    def Recognize(self, *args):
        """
        Recognize(Handle_XSControl_TransferReader self, Handle_Standard_Transient theEnt) -> Standard_Boolean

        Tells if an entity is recognized as a valid candidate for
        Transfer. Calls method Recognize from the Actor (if known)

        :type theEnt: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _XSControl.Handle_XSControl_TransferReader_Recognize(self, *args)


    def TransferOne(self, *args):
        """
        TransferOne(Handle_XSControl_TransferReader self, Handle_Standard_Transient theEnt, Standard_Boolean const theRec) -> Standard_Integer

        Commands the transfer on reading for an entity to data for
        Imagine, using the selected Actor for Read
        Returns count of transferred entities, ok or with fails (0/1)
        If <rec> is True (D), the result is recorded by RecordResult

        :type theEnt: OCC.wrapper.Standard.Handle_Standard_Transient
        :type theRec: bool
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _XSControl.Handle_XSControl_TransferReader_TransferOne(self, *args)


    def TransferList(self, *args):
        """
        TransferList(Handle_XSControl_TransferReader self, Handle_TColStd_HSequenceOfTransient theList, Standard_Boolean const theRec) -> Standard_Integer

        Commands the transfer on reading for a list of entities to
        data for Imagine, using the selected Actor for Read
        Returns count of transferred entities, ok or with fails (0/1)
        If <rec> is True (D), the results are recorded by RecordResult

        :type theList: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfTransient
        :type theRec: bool
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _XSControl.Handle_XSControl_TransferReader_TransferList(self, *args)


    def TransferRoots(self, *args):
        """
        TransferRoots(Handle_XSControl_TransferReader self, Interface_Graph theGraph) -> Standard_Integer

        Transfers the content of the current Interface Model to
        data handled by Imagine, starting from its Roots (determined
        by the Graph <G>),  using the selected Actor for Read
        Returns the count of performed root transfers (i.e. 0 if none)
        or -1 if no actor is defined

        :type theGraph: OCC.wrapper.Interface.Interface_Graph
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _XSControl.Handle_XSControl_TransferReader_TransferRoots(self, *args)


    def TransferClear(self, *args):
        """
        TransferClear(Handle_XSControl_TransferReader self, Handle_Standard_Transient theEnt, Standard_Integer const theLevel=0)

        Clears the results attached to an entity
        if <ents> equates the starting model, clears all results

        :type theEnt: OCC.wrapper.Standard.Handle_Standard_Transient
        :type theLevel: int

        """
        return _XSControl.Handle_XSControl_TransferReader_TransferClear(self, *args)


    def PrintStats(self, *args):
        """
        PrintStats(Handle_XSControl_TransferReader self, Standard_Integer const theWhat, Standard_Integer const theMode=0)

        Prints statistics on current Trace File, according <what> and
        <mode>.  See PrintStatsProcess for details

        :type theWhat: int
        :type theMode: int

        """
        return _XSControl.Handle_XSControl_TransferReader_PrintStats(self, *args)


    def LastCheckList(self, *args):
        """
        LastCheckList(Handle_XSControl_TransferReader self) -> Interface_CheckIterator

        Returns the CheckList resulting from last TransferRead
        i.e. from TransientProcess itself, recorded from last Clear

        :rtype: OCC.wrapper.Interface.Interface_CheckIterator

        """
        return _XSControl.Handle_XSControl_TransferReader_LastCheckList(self, *args)


    def LastTransferList(self, *args):
        """
        LastTransferList(Handle_XSControl_TransferReader self, Standard_Boolean const theRoots) -> Handle_TColStd_HSequenceOfTransient

        Returns the list of entities recorded as lastly transferred
        i.e. from TransientProcess itself, recorded from last Clear
        If <roots> is True , considers only roots of transfer
        If <roots> is False, considers all entities bound with result

        :type theRoots: bool
        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfTransient

        """
        return _XSControl.Handle_XSControl_TransferReader_LastTransferList(self, *args)


    def ShapeResultList(self, *args):
        """
        Returns a list of result Shapes
        If <rec> is True , sees RecordedList
        If <rec> is False, sees LastTransferList (last ROOT transfers)
        For each one, if it is a Shape, it is cumulated to the list
        If no Shape is found, returns an empty Sequence

        :type theRec: bool
        :rtype: OCC.wrapper.TopTools.Handle_TopTools_HSequenceOfShape

        """
        res = _XSControl.Handle_XSControl_TransferReader_ShapeResultList(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def PrintStatsProcess(self, *args):
        """
        PrintStatsProcess(Handle_XSControl_TransferReader self, Handle_Transfer_TransientProcess theTP, Standard_Integer const theWhat, Standard_Integer const theMode=0)

        This routines prints statistics about a TransientProcess
        It can be called, by a TransferReader, or isolately
        Prints are done on the default trace file
        <what> defines what kind of statistics are to be printed :
        0 : basic figures
        1 : root results
        2 : all recorded (roots, intermediate, checked entities)
        3 : abnormal records
        4 : check messages (warnings and fails)
        5 : fail messages

        <mode> is used according <what> :
        <what> = 0 : <mode> is ignored
        <what> = 1,2,3 : <mode> as follows :
        0 (D) : just lists numbers of concerned entities in the model
        1 : for each entity, gives number,label, type and result
        type and/or status (fail/warning...)
        2 : for each entity, gives maximal information (i.e. checks)
        3 : counts per type of starting entity (class type)
        4 : counts per result type and/or status
        5 : counts per couple (starting type / result type/status)
        6 : idem plus gives for each item, the list of numbers of
        entities in the starting model

        <what> = 4,5 : modes relays on an enum PrintCount :
        0 (D) : ItemsByEntity (sequential list by entity)
        1 : CountByItem
        2 : ShortByItem       (count + 5 first numbers)
        3 : ListByItem        (count + entity numbers)
        4 : EntitiesByItem    (count + entity numbers and labels)

        :type theTP: OCC.wrapper.Transfer.Handle_Transfer_TransientProcess
        :type theWhat: int
        :type theMode: int

        """
        return _XSControl.Handle_XSControl_TransferReader_PrintStatsProcess(self, *args)


    def PrintStatsOnList(self, *args):
        """
        PrintStatsOnList(Handle_XSControl_TransferReader self, Handle_Transfer_TransientProcess theTP, Handle_TColStd_HSequenceOfTransient theList, Standard_Integer const theWhat, Standard_Integer const theMode=0)

        Works as PrintStatsProcess, but displays data only on the
        entities which are in <list> (filter)

        :type theTP: OCC.wrapper.Transfer.Handle_Transfer_TransientProcess
        :type theList: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfTransient
        :type theWhat: int
        :type theMode: int

        """
        return _XSControl.Handle_XSControl_TransferReader_PrintStatsOnList(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_XSControl_TransferReader self) -> char const *

        :rtype: const char *

        """
        return _XSControl.Handle_XSControl_TransferReader_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _XSControl.Handle_XSControl_TransferReader_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _XSControl.Handle_XSControl_TransferReader_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_XSControl_TransferReader self)

        Memory deallocator for transient classes


        """
        return _XSControl.Handle_XSControl_TransferReader_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_XSControl_TransferReader self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_XSControl_TransferReader self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _XSControl.Handle_XSControl_TransferReader_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_XSControl_TransferReader self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_XSControl_TransferReader self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _XSControl.Handle_XSControl_TransferReader_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_XSControl_TransferReader self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _XSControl.Handle_XSControl_TransferReader_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_XSControl_TransferReader self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _XSControl.Handle_XSControl_TransferReader_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_XSControl_TransferReader self)

        Increments the reference counter of this object


        """
        return _XSControl.Handle_XSControl_TransferReader_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_XSControl_TransferReader self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _XSControl.Handle_XSControl_TransferReader_DecrementRefCounter(self, *args)

Handle_XSControl_TransferReader_swigregister = _XSControl.Handle_XSControl_TransferReader_swigregister
Handle_XSControl_TransferReader_swigregister(Handle_XSControl_TransferReader)

def Handle_XSControl_TransferReader_DownCast(thing):
    return _XSControl.Handle_XSControl_TransferReader_DownCast(thing)
Handle_XSControl_TransferReader_DownCast = _XSControl.Handle_XSControl_TransferReader_DownCast

class Handle_XSControl_Controller(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_XSControl_Controller self)

        Nullify the handle


        """
        return _XSControl.Handle_XSControl_Controller_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_XSControl_Controller self) -> bool

        Check for being null

        :rtype: bool

        """
        return _XSControl.Handle_XSControl_Controller_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_XSControl_Controller self, XSControl_Controller thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _XSControl.Handle_XSControl_Controller_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_XSControl_Controller self, Handle_XSControl_Controller theHandle) -> Handle_XSControl_Controller
        assign(Handle_XSControl_Controller self, XSControl_Controller thePtr) -> Handle_XSControl_Controller
        assign(Handle_XSControl_Controller self, Handle_XSControl_Controller theHandle) -> Handle_XSControl_Controller

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _XSControl.Handle_XSControl_Controller_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_XSControl_Controller self) -> XSControl_Controller

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _XSControl.Handle_XSControl_Controller_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_XSControl_Controller self) -> XSControl_Controller

        Member access operator (note non-const)

        :rtype: T *

        """
        return _XSControl.Handle_XSControl_Controller___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_XSControl_Controller self) -> XSControl_Controller

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _XSControl.Handle_XSControl_Controller___ref__(self, *args)


    def __hash__(self):
        return _XSControl.Handle_XSControl_Controller___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _XSControl.Handle_XSControl_Controller___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _XSControl.new_Handle_XSControl_Controller(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_XSControl.Handle_XSControl_Controller_DownCast)
    __swig_destroy__ = _XSControl.delete_Handle_XSControl_Controller

    def SetNames(self, *args):
        """
        SetNames(Handle_XSControl_Controller self, Standard_CString const theLongName, Standard_CString const theShortName)

        Changes names
        if a name is empty, the formerly set one remains
        Remark : Does not call Record or AutoRecord

        :type theLongName: OCC.wrapper.Standard.Standard_CString
        :type theShortName: OCC.wrapper.Standard.Standard_CString

        """
        return _XSControl.Handle_XSControl_Controller_SetNames(self, *args)


    def AutoRecord(self, *args):
        """
        AutoRecord(Handle_XSControl_Controller self)

        Records <me> is a general dictionary under Short and Long
        Names (see method Name)


        """
        return _XSControl.Handle_XSControl_Controller_AutoRecord(self, *args)


    def Record(self, *args):
        """
        Record(Handle_XSControl_Controller self, Standard_CString const name)

        Records <me> in a general dictionary under a name
        Error if <name> already used for another one

        :type name: OCC.wrapper.Standard.Standard_CString

        """
        return _XSControl.Handle_XSControl_Controller_Record(self, *args)


    def Recorded(self, *args):
        """
        Recorded(Handle_XSControl_Controller self, Standard_CString const name) -> Handle_XSControl_Controller

        Returns the Controller attached to a given name
        Returns a Null Handle if <name> is unknown

        :type name: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.XSControl.Handle_XSControl_Controller

        """
        return _XSControl.Handle_XSControl_Controller_Recorded(self, *args)


    def Name(self, *args):
        """
        Name(Handle_XSControl_Controller self, Standard_Boolean const rsc) -> Standard_CString

        Returns a name, as given when initializing :
        rsc = False (D) : True Name attached to the Norm (long name)
        rsc = True : Name of the ressource set (i.e. short name)

        :type rsc: bool
        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _XSControl.Handle_XSControl_Controller_Name(self, *args)


    def Protocol(self, *args):
        """
        Returns the Protocol attached to the Norm (from field)

        :rtype: OCC.wrapper.Interface.Handle_Interface_Protocol

        """
        res = _XSControl.Handle_XSControl_Controller_Protocol(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def WorkLibrary(self, *args):
        """
        Returns the WorkLibrary attached to the Norm. Remark that it
        has to be in phase with the Protocol  (read from field)

        :rtype: OCC.wrapper.IFSelect.Handle_IFSelect_WorkLibrary

        """
        res = _XSControl.Handle_XSControl_Controller_WorkLibrary(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def NewModel(self, *args):
        """
        NewModel(Handle_XSControl_Controller self) -> Handle_Interface_InterfaceModel

        Creates a new empty Model ready to receive data of the Norm
        Used to write data from Imagine to an interface file

        :rtype: OCC.wrapper.Interface.Handle_Interface_InterfaceModel

        """
        return _XSControl.Handle_XSControl_Controller_NewModel(self, *args)


    def ActorRead(self, *args):
        """
        ActorRead(Handle_XSControl_Controller self, Handle_Interface_InterfaceModel model) -> Handle_Transfer_ActorOfTransientProcess

        Returns the Actor for Read attached to the pair (norm,appli)
        It can be adapted for data of the input Model, as required
        Can be read from field then adapted with Model as required

        :type model: OCC.wrapper.Interface.Handle_Interface_InterfaceModel
        :rtype: OCC.wrapper.Transfer.Handle_Transfer_ActorOfTransientProcess

        """
        return _XSControl.Handle_XSControl_Controller_ActorRead(self, *args)


    def ActorWrite(self, *args):
        """
        ActorWrite(Handle_XSControl_Controller self) -> Handle_Transfer_ActorOfFinderProcess

        Returns the Actor for Write attached to the pair (norm,appli)
        Read from field. Can be redefined

        :rtype: OCC.wrapper.Transfer.Handle_Transfer_ActorOfFinderProcess

        """
        return _XSControl.Handle_XSControl_Controller_ActorWrite(self, *args)


    def SetModeWrite(self, *args):
        """
        SetModeWrite(Handle_XSControl_Controller self, Standard_Integer const modemin, Standard_Integer const modemax, Standard_Boolean const shape)

        Sets mininum and maximum values for modetrans (write)
        Erases formerly recorded bounds and values
        Actually only for shape
        Then, for each value a little help can be attached

        :type modemin: int
        :type modemax: int
        :type shape: bool

        """
        return _XSControl.Handle_XSControl_Controller_SetModeWrite(self, *args)


    def SetModeWriteHelp(self, *args):
        """
        SetModeWriteHelp(Handle_XSControl_Controller self, Standard_Integer const modetrans, Standard_CString const help, Standard_Boolean const shape)

        Attaches a short line of help to a value of modetrans (write)

        :type modetrans: int
        :type help: OCC.wrapper.Standard.Standard_CString
        :type shape: bool

        """
        return _XSControl.Handle_XSControl_Controller_SetModeWriteHelp(self, *args)


    def ModeWriteBounds(self, *args):
        """
        ModeWriteBounds(Handle_XSControl_Controller self, Standard_Boolean const shape) -> Standard_Boolean

        Returns recorded min and max values for modetrans (write)
        Actually only for shapes
        Returns True if bounds are set, False else (then, free value)

        :type modemin: int
        :type modemax: int
        :type shape: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _XSControl.Handle_XSControl_Controller_ModeWriteBounds(self, *args)


    def IsModeWrite(self, *args):
        """
        IsModeWrite(Handle_XSControl_Controller self, Standard_Integer const modetrans, Standard_Boolean const shape) -> Standard_Boolean

        Tells if a value of <modetrans> is a good value(within bounds)
        Actually only for shapes

        :type modetrans: int
        :type shape: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _XSControl.Handle_XSControl_Controller_IsModeWrite(self, *args)


    def ModeWriteHelp(self, *args):
        """
        ModeWriteHelp(Handle_XSControl_Controller self, Standard_Integer const modetrans, Standard_Boolean const shape) -> Standard_CString

        Returns the help line recorded for a value of modetrans
        empty if help not defined or not within bounds or if values are free

        :type modetrans: int
        :type shape: bool
        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _XSControl.Handle_XSControl_Controller_ModeWriteHelp(self, *args)


    def RecognizeWriteTransient(self, *args):
        """
        RecognizeWriteTransient(Handle_XSControl_Controller self, Handle_Standard_Transient obj, Standard_Integer const modetrans=0) -> Standard_Boolean

        Tells if <obj> (an application object) is a valid candidate
        for a transfer to a Model.
        By default, asks the ActorWrite if known (through a
        TransientMapper). Can be redefined

        :type obj: OCC.wrapper.Standard.Handle_Standard_Transient
        :type modetrans: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _XSControl.Handle_XSControl_Controller_RecognizeWriteTransient(self, *args)


    def TransferWriteTransient(self, *args):
        """
        TransferWriteTransient(Handle_XSControl_Controller self, Handle_Standard_Transient obj, Handle_Transfer_FinderProcess FP, Handle_Interface_InterfaceModel model, Standard_Integer const modetrans=0) -> IFSelect_ReturnStatus

        Takes one Transient Object and transfers it to an
        InterfaceModel (already created, e.g. by NewModel)
        (result is recorded in the model by AddWithRefs)
        FP records produced results and checks

        Default uses ActorWrite; can be redefined as necessary
        Returned value is a status, as follows :
        0  OK ,  1 No Result ,  2 Fail (e.g. exception raised)
        -1 bad conditions ,  -2 bad model or null model
        For type of object not recognized : should return 1

        :type obj: OCC.wrapper.Standard.Handle_Standard_Transient
        :type FP: OCC.wrapper.Transfer.Handle_Transfer_FinderProcess
        :type model: OCC.wrapper.Interface.Handle_Interface_InterfaceModel
        :type modetrans: int
        :rtype: OCC.wrapper.IFSelect.IFSelect_ReturnStatus

        """
        return _XSControl.Handle_XSControl_Controller_TransferWriteTransient(self, *args)


    def RecognizeWriteShape(self, *args):
        """
        RecognizeWriteShape(Handle_XSControl_Controller self, TopoDS_Shape shape, Standard_Integer const modetrans=0) -> Standard_Boolean

        Tells if a shape is valid for a transfer to a model
        Asks the ActorWrite (through a ShapeMapper)

        :type shape: OCC.wrapper.TopoDS.TopoDS_Shape
        :type modetrans: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _XSControl.Handle_XSControl_Controller_RecognizeWriteShape(self, *args)


    def TransferWriteShape(self, *args):
        """
        TransferWriteShape(Handle_XSControl_Controller self, TopoDS_Shape shape, Handle_Transfer_FinderProcess FP, Handle_Interface_InterfaceModel model, Standard_Integer const modetrans=0) -> IFSelect_ReturnStatus

        Takes one Shape and transfers it to an
        InterfaceModel (already created, e.g. by NewModel)
        Default uses ActorWrite; can be redefined as necessary
        Returned value is a status, as follows :
        Done  OK ,  Void : No Result ,  Fail : Fail (e.g. exception)
        Error : bad conditions , bad model or null model

        :type shape: OCC.wrapper.TopoDS.TopoDS_Shape
        :type FP: OCC.wrapper.Transfer.Handle_Transfer_FinderProcess
        :type model: OCC.wrapper.Interface.Handle_Interface_InterfaceModel
        :type modetrans: int
        :rtype: OCC.wrapper.IFSelect.IFSelect_ReturnStatus

        """
        return _XSControl.Handle_XSControl_Controller_TransferWriteShape(self, *args)


    def AddSessionItem(self, *args):
        """
        AddSessionItem(Handle_XSControl_Controller self, Handle_Standard_Transient theItem, Standard_CString const theName, Standard_Boolean const toApply)

        Records a Session Item, to be added for customisation of the Work Session.
        It must have a specific name.
        <setapplied> is used if <item> is a GeneralModifier, to decide
        If set to true, <item> will be applied to the hook list "send".
        Else, it is not applied to any hook list.
        Remark : this method is to be called at Create time,
        the recorded items will be used by Customise
        Warning : if <name> conflicts, the last recorded item is kept

        :type theItem: OCC.wrapper.Standard.Handle_Standard_Transient
        :type theName: OCC.wrapper.Standard.Standard_CString
        :type toApply: bool

        """
        return _XSControl.Handle_XSControl_Controller_AddSessionItem(self, *args)


    def SessionItem(self, *args):
        """
        SessionItem(Handle_XSControl_Controller self, Standard_CString const theName) -> Handle_Standard_Transient

        Returns an item given its name to record in a Session
        If <name> is unknown, returns a Null Handle

        :type theName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _XSControl.Handle_XSControl_Controller_SessionItem(self, *args)


    def Customise(self, *args):
        """
        Customise(Handle_XSControl_Controller self, Handle_XSControl_WorkSession WS)

        Customises a WorkSession, by adding to it the recorded items (by AddSessionItem)

        :type WS: OCC.wrapper.XSControl.Handle_XSControl_WorkSession

        """
        return _XSControl.Handle_XSControl_Controller_Customise(self, *args)


    def AdaptorSession(self, *args):
        """
        :rtype: OCC.wrapper.XSControl.NCollection_DataMap_TCollection_AsciiString_Handle_Standard_Transient

        """
        res = _XSControl.Handle_XSControl_Controller_AdaptorSession(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def get_type_name(self, *args):
        """
        get_type_name(Handle_XSControl_Controller self) -> char const *

        :rtype: const char *

        """
        return _XSControl.Handle_XSControl_Controller_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _XSControl.Handle_XSControl_Controller_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _XSControl.Handle_XSControl_Controller_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_XSControl_Controller self)

        Memory deallocator for transient classes


        """
        return _XSControl.Handle_XSControl_Controller_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_XSControl_Controller self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_XSControl_Controller self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _XSControl.Handle_XSControl_Controller_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_XSControl_Controller self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_XSControl_Controller self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _XSControl.Handle_XSControl_Controller_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_XSControl_Controller self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _XSControl.Handle_XSControl_Controller_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_XSControl_Controller self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _XSControl.Handle_XSControl_Controller_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_XSControl_Controller self)

        Increments the reference counter of this object


        """
        return _XSControl.Handle_XSControl_Controller_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_XSControl_Controller self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _XSControl.Handle_XSControl_Controller_DecrementRefCounter(self, *args)

Handle_XSControl_Controller_swigregister = _XSControl.Handle_XSControl_Controller_swigregister
Handle_XSControl_Controller_swigregister(Handle_XSControl_Controller)

def Handle_XSControl_Controller_DownCast(thing):
    return _XSControl.Handle_XSControl_Controller_DownCast(thing)
Handle_XSControl_Controller_DownCast = _XSControl.Handle_XSControl_Controller_DownCast

class Handle_XSControl_Vars(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_XSControl_Vars self)

        Nullify the handle


        """
        return _XSControl.Handle_XSControl_Vars_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_XSControl_Vars self) -> bool

        Check for being null

        :rtype: bool

        """
        return _XSControl.Handle_XSControl_Vars_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_XSControl_Vars self, XSControl_Vars thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _XSControl.Handle_XSControl_Vars_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_XSControl_Vars self, Handle_XSControl_Vars theHandle) -> Handle_XSControl_Vars
        assign(Handle_XSControl_Vars self, XSControl_Vars thePtr) -> Handle_XSControl_Vars
        assign(Handle_XSControl_Vars self, Handle_XSControl_Vars theHandle) -> Handle_XSControl_Vars

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _XSControl.Handle_XSControl_Vars_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_XSControl_Vars self) -> XSControl_Vars

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _XSControl.Handle_XSControl_Vars_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_XSControl_Vars self) -> XSControl_Vars

        Member access operator (note non-const)

        :rtype: T *

        """
        return _XSControl.Handle_XSControl_Vars___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_XSControl_Vars self) -> XSControl_Vars

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _XSControl.Handle_XSControl_Vars___ref__(self, *args)


    def __hash__(self):
        return _XSControl.Handle_XSControl_Vars___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _XSControl.Handle_XSControl_Vars___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _XSControl.new_Handle_XSControl_Vars(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_XSControl.Handle_XSControl_Vars_DownCast)
    __swig_destroy__ = _XSControl.delete_Handle_XSControl_Vars

    def Set(self, *args):
        """
        Set(Handle_XSControl_Vars self, Standard_CString const name, Handle_Standard_Transient val)

        :type name: OCC.wrapper.Standard.Standard_CString
        :type val: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _XSControl.Handle_XSControl_Vars_Set(self, *args)


    def Get(self, *args):
        """
        Get(Handle_XSControl_Vars self, Standard_CString & name) -> Handle_Standard_Transient

        :type name: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _XSControl.Handle_XSControl_Vars_Get(self, *args)


    def GetGeom(self, *args):
        """
        GetGeom(Handle_XSControl_Vars self, Standard_CString & name) -> Handle_Geom_Geometry

        :type name: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _XSControl.Handle_XSControl_Vars_GetGeom(self, *args)


    def GetCurve2d(self, *args):
        """
        GetCurve2d(Handle_XSControl_Vars self, Standard_CString & name) -> Handle_Geom2d_Curve

        :type name: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Curve

        """
        return _XSControl.Handle_XSControl_Vars_GetCurve2d(self, *args)


    def GetCurve(self, *args):
        """
        GetCurve(Handle_XSControl_Vars self, Standard_CString & name) -> Handle_Geom_Curve

        :type name: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Geom.Handle_Geom_Curve

        """
        return _XSControl.Handle_XSControl_Vars_GetCurve(self, *args)


    def GetSurface(self, *args):
        """
        GetSurface(Handle_XSControl_Vars self, Standard_CString & name) -> Handle_Geom_Surface

        :type name: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Geom.Handle_Geom_Surface

        """
        return _XSControl.Handle_XSControl_Vars_GetSurface(self, *args)


    def SetPoint(self, *args):
        """
        SetPoint(Handle_XSControl_Vars self, Standard_CString const name, gp_Pnt val)

        :type name: OCC.wrapper.Standard.Standard_CString
        :type val: OCC.wrapper.gp.gp_Pnt

        """
        return _XSControl.Handle_XSControl_Vars_SetPoint(self, *args)


    def SetPoint2d(self, *args):
        """
        SetPoint2d(Handle_XSControl_Vars self, Standard_CString const name, gp_Pnt2d val)

        :type name: OCC.wrapper.Standard.Standard_CString
        :type val: OCC.wrapper.gp.gp_Pnt2d

        """
        return _XSControl.Handle_XSControl_Vars_SetPoint2d(self, *args)


    def GetPoint(self, *args):
        """
        GetPoint(Handle_XSControl_Vars self, Standard_CString & name, gp_Pnt pnt) -> Standard_Boolean

        :type name: OCC.wrapper.Standard.Standard_CString
        :type pnt: OCC.wrapper.gp.gp_Pnt
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _XSControl.Handle_XSControl_Vars_GetPoint(self, *args)


    def GetPoint2d(self, *args):
        """
        GetPoint2d(Handle_XSControl_Vars self, Standard_CString & name, gp_Pnt2d pnt) -> Standard_Boolean

        :type name: OCC.wrapper.Standard.Standard_CString
        :type pnt: OCC.wrapper.gp.gp_Pnt2d
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _XSControl.Handle_XSControl_Vars_GetPoint2d(self, *args)


    def SetShape(self, *args):
        """
        SetShape(Handle_XSControl_Vars self, Standard_CString const name, TopoDS_Shape val)

        :type name: OCC.wrapper.Standard.Standard_CString
        :type val: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _XSControl.Handle_XSControl_Vars_SetShape(self, *args)


    def GetShape(self, *args):
        """
        GetShape(Handle_XSControl_Vars self, Standard_CString & name) -> TopoDS_Shape

        :type name: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _XSControl.Handle_XSControl_Vars_GetShape(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_XSControl_Vars self) -> char const *

        :rtype: const char *

        """
        return _XSControl.Handle_XSControl_Vars_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _XSControl.Handle_XSControl_Vars_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _XSControl.Handle_XSControl_Vars_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_XSControl_Vars self)

        Memory deallocator for transient classes


        """
        return _XSControl.Handle_XSControl_Vars_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_XSControl_Vars self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_XSControl_Vars self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _XSControl.Handle_XSControl_Vars_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_XSControl_Vars self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_XSControl_Vars self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _XSControl.Handle_XSControl_Vars_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_XSControl_Vars self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _XSControl.Handle_XSControl_Vars_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_XSControl_Vars self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _XSControl.Handle_XSControl_Vars_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_XSControl_Vars self)

        Increments the reference counter of this object


        """
        return _XSControl.Handle_XSControl_Vars_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_XSControl_Vars self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _XSControl.Handle_XSControl_Vars_DecrementRefCounter(self, *args)

Handle_XSControl_Vars_swigregister = _XSControl.Handle_XSControl_Vars_swigregister
Handle_XSControl_Vars_swigregister(Handle_XSControl_Vars)

def Handle_XSControl_Vars_DownCast(thing):
    return _XSControl.Handle_XSControl_Vars_DownCast(thing)
Handle_XSControl_Vars_DownCast = _XSControl.Handle_XSControl_Vars_DownCast

class Handle_XSControl_TransferWriter(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_XSControl_TransferWriter self)

        Nullify the handle


        """
        return _XSControl.Handle_XSControl_TransferWriter_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_XSControl_TransferWriter self) -> bool

        Check for being null

        :rtype: bool

        """
        return _XSControl.Handle_XSControl_TransferWriter_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_XSControl_TransferWriter self, XSControl_TransferWriter thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _XSControl.Handle_XSControl_TransferWriter_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_XSControl_TransferWriter self, Handle_XSControl_TransferWriter theHandle) -> Handle_XSControl_TransferWriter
        assign(Handle_XSControl_TransferWriter self, XSControl_TransferWriter thePtr) -> Handle_XSControl_TransferWriter
        assign(Handle_XSControl_TransferWriter self, Handle_XSControl_TransferWriter theHandle) -> Handle_XSControl_TransferWriter

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _XSControl.Handle_XSControl_TransferWriter_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_XSControl_TransferWriter self) -> XSControl_TransferWriter

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _XSControl.Handle_XSControl_TransferWriter_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_XSControl_TransferWriter self) -> XSControl_TransferWriter

        Member access operator (note non-const)

        :rtype: T *

        """
        return _XSControl.Handle_XSControl_TransferWriter___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_XSControl_TransferWriter self) -> XSControl_TransferWriter

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _XSControl.Handle_XSControl_TransferWriter___ref__(self, *args)


    def __hash__(self):
        return _XSControl.Handle_XSControl_TransferWriter___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _XSControl.Handle_XSControl_TransferWriter___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _XSControl.new_Handle_XSControl_TransferWriter(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_XSControl.Handle_XSControl_TransferWriter_DownCast)
    __swig_destroy__ = _XSControl.delete_Handle_XSControl_TransferWriter

    def FinderProcess(self, *args):
        """
        Returns the FinderProcess itself

        :rtype: OCC.wrapper.Transfer.Handle_Transfer_FinderProcess

        """
        res = _XSControl.Handle_XSControl_TransferWriter_FinderProcess(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetFinderProcess(self, *args):
        """
        SetFinderProcess(Handle_XSControl_TransferWriter self, Handle_Transfer_FinderProcess theFP)

        Sets a new FinderProcess and forgets the former one

        :type theFP: OCC.wrapper.Transfer.Handle_Transfer_FinderProcess

        """
        return _XSControl.Handle_XSControl_TransferWriter_SetFinderProcess(self, *args)


    def Controller(self, *args):
        """
        Returns the currently used Controller

        :rtype: OCC.wrapper.XSControl.Handle_XSControl_Controller

        """
        res = _XSControl.Handle_XSControl_TransferWriter_Controller(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetController(self, *args):
        """
        SetController(Handle_XSControl_TransferWriter self, Handle_XSControl_Controller theCtl)

        Sets a new Controller, also sets a new FinderProcess

        :type theCtl: OCC.wrapper.XSControl.Handle_XSControl_Controller

        """
        return _XSControl.Handle_XSControl_TransferWriter_SetController(self, *args)


    def Clear(self, *args):
        """
        Clear(Handle_XSControl_TransferWriter self, Standard_Integer const theMode)

        Clears recorded data according a mode
        0 clears FinderProcess (results, checks)
        -1 create a new FinderProcess

        :type theMode: int

        """
        return _XSControl.Handle_XSControl_TransferWriter_Clear(self, *args)


    def TransferMode(self, *args):
        """
        TransferMode(Handle_XSControl_TransferWriter self) -> Standard_Integer

        Returns the current Transfer Mode (an Integer)
        It will be interpreted by the Controller to run Transfers
        This call form could be later replaced by more specific ones
        (parameters suited for each norm / transfer case)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _XSControl.Handle_XSControl_TransferWriter_TransferMode(self, *args)


    def SetTransferMode(self, *args):
        """
        SetTransferMode(Handle_XSControl_TransferWriter self, Standard_Integer const theMode)

        Changes the Transfer Mode

        :type theMode: int

        """
        return _XSControl.Handle_XSControl_TransferWriter_SetTransferMode(self, *args)


    def PrintStats(self, *args):
        """
        PrintStats(Handle_XSControl_TransferWriter self, Standard_Integer const theWhat, Standard_Integer const theMode=0)

        Prints statistics on current Trace File, according what,mode
        See PrintStatsProcess for details

        :type theWhat: int
        :type theMode: int

        """
        return _XSControl.Handle_XSControl_TransferWriter_PrintStats(self, *args)


    def RecognizeTransient(self, *args):
        """
        RecognizeTransient(Handle_XSControl_TransferWriter self, Handle_Standard_Transient theObj) -> Standard_Boolean

        Tells if a transient object (from an application) is a valid
        candidate for a transfer to a model
        Asks the Controller (RecognizeWriteTransient)
        If <obj> is a HShape, calls RecognizeShape

        :type theObj: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _XSControl.Handle_XSControl_TransferWriter_RecognizeTransient(self, *args)


    def TransferWriteTransient(self, *args):
        """
        TransferWriteTransient(Handle_XSControl_TransferWriter self, Handle_Interface_InterfaceModel theModel, Handle_Standard_Transient theObj) -> IFSelect_ReturnStatus

        Transfers a Transient object (from an application) to a model
        of current norm, according to the last call to SetTransferMode
        Works by calling the Controller
        Returns status : =0 if OK, >0 if error during transfer, <0 if
        transfer badly initialised

        :type theModel: OCC.wrapper.Interface.Handle_Interface_InterfaceModel
        :type theObj: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.IFSelect.IFSelect_ReturnStatus

        """
        return _XSControl.Handle_XSControl_TransferWriter_TransferWriteTransient(self, *args)


    def RecognizeShape(self, *args):
        """
        RecognizeShape(Handle_XSControl_TransferWriter self, TopoDS_Shape theShape) -> Standard_Boolean

        Tells if a Shape is valid for a transfer to a model
        Asks the Controller (RecognizeWriteShape)

        :type theShape: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _XSControl.Handle_XSControl_TransferWriter_RecognizeShape(self, *args)


    def TransferWriteShape(self, *args):
        """
        TransferWriteShape(Handle_XSControl_TransferWriter self, Handle_Interface_InterfaceModel theModel, TopoDS_Shape theShape) -> IFSelect_ReturnStatus

        Transfers a Shape from CasCade to a model of current norm,
        according to the last call to SetTransferMode
        Works by calling the Controller
        Returns status : =0 if OK, >0 if error during transfer, <0 if
        transfer badly initialised

        :type theModel: OCC.wrapper.Interface.Handle_Interface_InterfaceModel
        :type theShape: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.IFSelect.IFSelect_ReturnStatus

        """
        return _XSControl.Handle_XSControl_TransferWriter_TransferWriteShape(self, *args)


    def CheckList(self, *args):
        """
        CheckList(Handle_XSControl_TransferWriter self) -> Interface_CheckIterator

        Returns the check-list of last transfer (write), i.e. the
        check-list currently recorded in the FinderProcess

        :rtype: OCC.wrapper.Interface.Interface_CheckIterator

        """
        return _XSControl.Handle_XSControl_TransferWriter_CheckList(self, *args)


    def ResultCheckList(self, *args):
        """
        ResultCheckList(Handle_XSControl_TransferWriter self, Handle_Interface_InterfaceModel theModel) -> Interface_CheckIterator

        Returns the check-list of last transfer (write), but tries
        to bind to each check, the resulting entity in the model
        instead of keeping the original Mapper, whenever known

        :type theModel: OCC.wrapper.Interface.Handle_Interface_InterfaceModel
        :rtype: OCC.wrapper.Interface.Interface_CheckIterator

        """
        return _XSControl.Handle_XSControl_TransferWriter_ResultCheckList(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_XSControl_TransferWriter self) -> char const *

        :rtype: const char *

        """
        return _XSControl.Handle_XSControl_TransferWriter_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _XSControl.Handle_XSControl_TransferWriter_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _XSControl.Handle_XSControl_TransferWriter_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_XSControl_TransferWriter self)

        Memory deallocator for transient classes


        """
        return _XSControl.Handle_XSControl_TransferWriter_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_XSControl_TransferWriter self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_XSControl_TransferWriter self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _XSControl.Handle_XSControl_TransferWriter_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_XSControl_TransferWriter self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_XSControl_TransferWriter self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _XSControl.Handle_XSControl_TransferWriter_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_XSControl_TransferWriter self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _XSControl.Handle_XSControl_TransferWriter_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_XSControl_TransferWriter self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _XSControl.Handle_XSControl_TransferWriter_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_XSControl_TransferWriter self)

        Increments the reference counter of this object


        """
        return _XSControl.Handle_XSControl_TransferWriter_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_XSControl_TransferWriter self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _XSControl.Handle_XSControl_TransferWriter_DecrementRefCounter(self, *args)

Handle_XSControl_TransferWriter_swigregister = _XSControl.Handle_XSControl_TransferWriter_swigregister
Handle_XSControl_TransferWriter_swigregister(Handle_XSControl_TransferWriter)

def Handle_XSControl_TransferWriter_DownCast(thing):
    return _XSControl.Handle_XSControl_TransferWriter_DownCast(thing)
Handle_XSControl_TransferWriter_DownCast = _XSControl.Handle_XSControl_TransferWriter_DownCast

class Handle_XSControl_ConnectedShapes(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_XSControl_ConnectedShapes self)

        Nullify the handle


        """
        return _XSControl.Handle_XSControl_ConnectedShapes_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_XSControl_ConnectedShapes self) -> bool

        Check for being null

        :rtype: bool

        """
        return _XSControl.Handle_XSControl_ConnectedShapes_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_XSControl_ConnectedShapes self, XSControl_ConnectedShapes thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _XSControl.Handle_XSControl_ConnectedShapes_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_XSControl_ConnectedShapes self, Handle_XSControl_ConnectedShapes theHandle) -> Handle_XSControl_ConnectedShapes
        assign(Handle_XSControl_ConnectedShapes self, XSControl_ConnectedShapes thePtr) -> Handle_XSControl_ConnectedShapes
        assign(Handle_XSControl_ConnectedShapes self, Handle_XSControl_ConnectedShapes theHandle) -> Handle_XSControl_ConnectedShapes

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _XSControl.Handle_XSControl_ConnectedShapes_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_XSControl_ConnectedShapes self) -> XSControl_ConnectedShapes

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _XSControl.Handle_XSControl_ConnectedShapes_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_XSControl_ConnectedShapes self) -> XSControl_ConnectedShapes

        Member access operator (note non-const)

        :rtype: T *

        """
        return _XSControl.Handle_XSControl_ConnectedShapes___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_XSControl_ConnectedShapes self) -> XSControl_ConnectedShapes

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _XSControl.Handle_XSControl_ConnectedShapes___ref__(self, *args)


    def __hash__(self):
        return _XSControl.Handle_XSControl_ConnectedShapes___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _XSControl.Handle_XSControl_ConnectedShapes___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _XSControl.new_Handle_XSControl_ConnectedShapes(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_XSControl.Handle_XSControl_ConnectedShapes_DownCast)
    __swig_destroy__ = _XSControl.delete_Handle_XSControl_ConnectedShapes

    def SetReader(self, *args):
        """
        SetReader(Handle_XSControl_ConnectedShapes self, Handle_XSControl_TransferReader TR)

        Sets a TransferReader to sort entities : it brings the
        TransferProcess which may change, while the TransferReader does not

        :type TR: OCC.wrapper.XSControl.Handle_XSControl_TransferReader

        """
        return _XSControl.Handle_XSControl_ConnectedShapes_SetReader(self, *args)


    def Explore(self, *args):
        """
        Explore(Handle_XSControl_ConnectedShapes self, Standard_Integer const level, Handle_Standard_Transient ent, Interface_Graph G, Interface_EntityIterator explored) -> Standard_Boolean

        Explores an entity : entities from which are connected to that
        produced by this entity, including itself

        :type level: int
        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type G: OCC.wrapper.Interface.Interface_Graph
        :type explored: OCC.wrapper.Interface.Interface_EntityIterator
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _XSControl.Handle_XSControl_ConnectedShapes_Explore(self, *args)


    def ExploreLabel(self, *args):
        """
        ExploreLabel(Handle_XSControl_ConnectedShapes self) -> TCollection_AsciiString

        Returns a text defining the criterium.
        "Connected Entities through produced Shapes"

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _XSControl.Handle_XSControl_ConnectedShapes_ExploreLabel(self, *args)


    def AdjacentEntities(self, *args):
        """
        AdjacentEntities(Handle_XSControl_ConnectedShapes self, TopoDS_Shape ashape, Handle_Transfer_TransientProcess TP, TopAbs_ShapeEnum const type) -> Handle_TColStd_HSequenceOfTransient

        This functions considers a shape from a transfer and performs
        the search function explained above

        :type ashape: OCC.wrapper.TopoDS.TopoDS_Shape
        :type TP: OCC.wrapper.Transfer.Handle_Transfer_TransientProcess
        :type type: OCC.wrapper.TopAbs.TopAbs_ShapeEnum
        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfTransient

        """
        return _XSControl.Handle_XSControl_ConnectedShapes_AdjacentEntities(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_XSControl_ConnectedShapes self) -> char const *

        :rtype: const char *

        """
        return _XSControl.Handle_XSControl_ConnectedShapes_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _XSControl.Handle_XSControl_ConnectedShapes_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _XSControl.Handle_XSControl_ConnectedShapes_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Level(self, *args):
        """
        Level(Handle_XSControl_ConnectedShapes self) -> Standard_Integer

        Returns the required exploring level

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _XSControl.Handle_XSControl_ConnectedShapes_Level(self, *args)


    def RootResult(self, *args):
        """
        RootResult(Handle_XSControl_ConnectedShapes self, Interface_Graph G) -> Interface_EntityIterator

        Returns the list of selected entities. Works by calling the
        method Explore on each input entity : it can be rejected,
        taken for output, or to explore. If the maximum level has not
        yet been attained, or if no max level is specified, entities
        to be explored are themselves used as if they were input

        :type G: OCC.wrapper.Interface.Interface_Graph
        :rtype: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _XSControl.Handle_XSControl_ConnectedShapes_RootResult(self, *args)


    def Label(self, *args):
        """
        Label(Handle_XSControl_ConnectedShapes self) -> TCollection_AsciiString

        Returns a text saying "(Recursive)" or "(Level nn)" plus
        specific criterium returned by ExploreLabel (see below)

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _XSControl.Handle_XSControl_ConnectedShapes_Label(self, *args)


    def SetInput(self, *args):
        """
        SetInput(Handle_XSControl_ConnectedShapes self, Handle_IFSelect_Selection sel)

        Defines or Changes the Input Selection

        :type sel: OCC.wrapper.IFSelect.Handle_IFSelect_Selection

        """
        return _XSControl.Handle_XSControl_ConnectedShapes_SetInput(self, *args)


    def Input(self, *args):
        """
        Input(Handle_XSControl_ConnectedShapes self) -> Handle_IFSelect_Selection

        Returns the Input Selection

        :rtype: OCC.wrapper.IFSelect.Handle_IFSelect_Selection

        """
        return _XSControl.Handle_XSControl_ConnectedShapes_Input(self, *args)


    def HasInput(self, *args):
        """
        HasInput(Handle_XSControl_ConnectedShapes self) -> Standard_Boolean

        Returns True if the Input Selection is defined, False else

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _XSControl.Handle_XSControl_ConnectedShapes_HasInput(self, *args)


    def HasAlternate(self, *args):
        """
        HasAlternate(Handle_XSControl_ConnectedShapes self) -> Standard_Boolean

        Tells if an Alternate List has been set, i.e. : the Alternate
        Definition is present and set

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _XSControl.Handle_XSControl_ConnectedShapes_HasAlternate(self, *args)


    def Alternate(self, *args):
        """
        Alternate(Handle_XSControl_ConnectedShapes self) -> Handle_IFSelect_SelectPointed

        Returns the Alternate Definition
        It is returned modifiable, hence an already defined
        SelectPointed can be used
        But if it was not yet defined, it is created the first time

        It is exploited by InputResult

        :rtype: OCC.wrapper.IFSelect.Handle_IFSelect_SelectPointed

        """
        return _XSControl.Handle_XSControl_ConnectedShapes_Alternate(self, *args)


    def InputResult(self, *args):
        """
        InputResult(Handle_XSControl_ConnectedShapes self, Interface_Graph G) -> Interface_EntityIterator

        Returns the Result determined by Input Selection, as Unique
        if Input Selection is not defined, returns an empty list.

        If Alternate is set, InputResult takes its definition instead
        of calling the Input Selection, then clears it

        :type G: OCC.wrapper.Interface.Interface_Graph
        :rtype: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _XSControl.Handle_XSControl_ConnectedShapes_InputResult(self, *args)


    def FillIterator(self, *args):
        """
        FillIterator(Handle_XSControl_ConnectedShapes self, IFSelect_SelectionIterator iter)

        Puts in an Iterator the Selections from which "me" depends
        This list contains one Selection : the InputSelection

        :type iter: OCC.wrapper.IFSelect.IFSelect_SelectionIterator

        """
        return _XSControl.Handle_XSControl_ConnectedShapes_FillIterator(self, *args)


    def UniqueResult(self, *args):
        """
        UniqueResult(Handle_XSControl_ConnectedShapes self, Interface_Graph G) -> Interface_EntityIterator

        Returns the list of selected entities, each of them beeing
        unique. Default definition works from RootResult. According
        HasUniqueResult, UniqueResult returns directly RootResult,
        or build a Unique Result from it with a Graph.

        :type G: OCC.wrapper.Interface.Interface_Graph
        :rtype: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _XSControl.Handle_XSControl_ConnectedShapes_UniqueResult(self, *args)


    def CompleteResult(self, *args):
        """
        CompleteResult(Handle_XSControl_ConnectedShapes self, Interface_Graph G) -> Interface_EntityIterator

        Returns the list of entities involved by a Selection, i.e.
        UniqueResult plus the shared entities (directly or not)

        :type G: OCC.wrapper.Interface.Interface_Graph
        :rtype: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _XSControl.Handle_XSControl_ConnectedShapes_CompleteResult(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_XSControl_ConnectedShapes self)

        Memory deallocator for transient classes


        """
        return _XSControl.Handle_XSControl_ConnectedShapes_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_XSControl_ConnectedShapes self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_XSControl_ConnectedShapes self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _XSControl.Handle_XSControl_ConnectedShapes_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_XSControl_ConnectedShapes self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_XSControl_ConnectedShapes self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _XSControl.Handle_XSControl_ConnectedShapes_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_XSControl_ConnectedShapes self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _XSControl.Handle_XSControl_ConnectedShapes_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_XSControl_ConnectedShapes self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _XSControl.Handle_XSControl_ConnectedShapes_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_XSControl_ConnectedShapes self)

        Increments the reference counter of this object


        """
        return _XSControl.Handle_XSControl_ConnectedShapes_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_XSControl_ConnectedShapes self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _XSControl.Handle_XSControl_ConnectedShapes_DecrementRefCounter(self, *args)

Handle_XSControl_ConnectedShapes_swigregister = _XSControl.Handle_XSControl_ConnectedShapes_swigregister
Handle_XSControl_ConnectedShapes_swigregister(Handle_XSControl_ConnectedShapes)

def Handle_XSControl_ConnectedShapes_DownCast(thing):
    return _XSControl.Handle_XSControl_ConnectedShapes_DownCast(thing)
Handle_XSControl_ConnectedShapes_DownCast = _XSControl.Handle_XSControl_ConnectedShapes_DownCast

class XSControl_FuncShape(object):
    """
    Defines additionnal commands for XSControl to :
    - control of initialisation (xinit, xnorm, newmodel)
    - analyse of the result of a transfer (recorded in a
    TransientProcess for Read, FinderProcess for Write) :
    statistics, various lists (roots,complete,abnormal), what
    about one specific entity, producing a model with the
    abnormal result

    This appendix of XSControl is compiled separately to distinguish
    basic features from user callable forms
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Init(*args):
        """
        Init()

        Defines and loads all functions which work on shapes for XSControl (as ActFunc)


        """
        return _XSControl.XSControl_FuncShape_Init(*args)

    Init = staticmethod(Init)

    def MoreShapes(*args):
        """
        MoreShapes(Handle_XSControl_WorkSession session, Handle_TopTools_HSequenceOfShape list, Standard_CString const name) -> Standard_Integer

        Analyses a name as designating Shapes from a Vars or from
        XSTEP transfer (last Transfer on Reading). <name> can be :
        "*" : all the root shapes produced by last Transfer (Read)
        i.e. considers roots of the TransientProcess
        a name : a name of a variable DRAW

        Returns the count of designated Shapes. Their list is put in
        <list>. If <list> is null, it is firstly created. Then it is
        completed (Append without Clear) by the Shapes found
        Returns 0 if no Shape could be found

        :type session: OCC.wrapper.XSControl.Handle_XSControl_WorkSession
        :type list: OCC.wrapper.TopTools.Handle_TopTools_HSequenceOfShape
        :type name: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _XSControl.XSControl_FuncShape_MoreShapes(*args)

    MoreShapes = staticmethod(MoreShapes)

    def FileAndVar(*args):
        """
        FileAndVar(Handle_XSControl_WorkSession session, Standard_CString const file, Standard_CString const var, Standard_CString const arg4, TCollection_AsciiString resfile, TCollection_AsciiString resvar) -> Standard_Boolean

        Analyses given file name and variable name, with a default
        name for variables. Returns resulting file name and variable
        name plus status "file to read"(True) or "already read"(False)
        In the latter case, empty resfile means no file available

        If <file> is null or empty or equates ".", considers Session
        and returned status is False
        Else, returns resfile = file and status is True
        If <var> is neither null nor empty, resvar = var
        Else, the root part of <resfile> is considered, if defined
        Else, <def> is taken

        :type session: OCC.wrapper.XSControl.Handle_XSControl_WorkSession
        :type file: OCC.wrapper.Standard.Standard_CString
        :type var: OCC.wrapper.Standard.Standard_CString
        :type def: OCC.wrapper.Standard.Standard_CString
        :type resfile: OCC.wrapper.TCollection.TCollection_AsciiString
        :type resvar: OCC.wrapper.TCollection.TCollection_AsciiString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _XSControl.XSControl_FuncShape_FileAndVar(*args)

    FileAndVar = staticmethod(FileAndVar)

    def __init__(self):
        """
        Defines additionnal commands for XSControl to :
        - control of initialisation (xinit, xnorm, newmodel)
        - analyse of the result of a transfer (recorded in a
        TransientProcess for Read, FinderProcess for Write) :
        statistics, various lists (roots,complete,abnormal), what
        about one specific entity, producing a model with the
        abnormal result

        This appendix of XSControl is compiled separately to distinguish
        basic features from user callable forms
        """
        this = _XSControl.new_XSControl_FuncShape()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _XSControl.delete_XSControl_FuncShape
XSControl_FuncShape_swigregister = _XSControl.XSControl_FuncShape_swigregister
XSControl_FuncShape_swigregister(XSControl_FuncShape)

def XSControl_FuncShape_Init(*args):
    """
    XSControl_FuncShape_Init()

    Defines and loads all functions which work on shapes for XSControl (as ActFunc)


    """
    return _XSControl.XSControl_FuncShape_Init(*args)

def XSControl_FuncShape_MoreShapes(*args):
    """
    XSControl_FuncShape_MoreShapes(Handle_XSControl_WorkSession session, Handle_TopTools_HSequenceOfShape list, Standard_CString const name) -> Standard_Integer

    Analyses a name as designating Shapes from a Vars or from
    XSTEP transfer (last Transfer on Reading). <name> can be :
    "*" : all the root shapes produced by last Transfer (Read)
    i.e. considers roots of the TransientProcess
    a name : a name of a variable DRAW

    Returns the count of designated Shapes. Their list is put in
    <list>. If <list> is null, it is firstly created. Then it is
    completed (Append without Clear) by the Shapes found
    Returns 0 if no Shape could be found

    :type session: OCC.wrapper.XSControl.Handle_XSControl_WorkSession
    :type list: OCC.wrapper.TopTools.Handle_TopTools_HSequenceOfShape
    :type name: OCC.wrapper.Standard.Standard_CString
    :rtype: OCC.wrapper.Standard.Standard_Integer

    """
    return _XSControl.XSControl_FuncShape_MoreShapes(*args)

def XSControl_FuncShape_FileAndVar(*args):
    """
    XSControl_FuncShape_FileAndVar(Handle_XSControl_WorkSession session, Standard_CString const file, Standard_CString const var, Standard_CString const arg5, TCollection_AsciiString resfile, TCollection_AsciiString resvar) -> Standard_Boolean

    Analyses given file name and variable name, with a default
    name for variables. Returns resulting file name and variable
    name plus status "file to read"(True) or "already read"(False)
    In the latter case, empty resfile means no file available

    If <file> is null or empty or equates ".", considers Session
    and returned status is False
    Else, returns resfile = file and status is True
    If <var> is neither null nor empty, resvar = var
    Else, the root part of <resfile> is considered, if defined
    Else, <def> is taken

    :type session: OCC.wrapper.XSControl.Handle_XSControl_WorkSession
    :type file: OCC.wrapper.Standard.Standard_CString
    :type var: OCC.wrapper.Standard.Standard_CString
    :type def: OCC.wrapper.Standard.Standard_CString
    :type resfile: OCC.wrapper.TCollection.TCollection_AsciiString
    :type resvar: OCC.wrapper.TCollection.TCollection_AsciiString
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _XSControl.XSControl_FuncShape_FileAndVar(*args)

class XSControl_Utils(object):
    """
    This class provides various useful utility routines, to
    facilitate handling of most common data structures :
    transients (type, type name ...),
    strings (ascii or extended, pointed or handled or ...),
    shapes (reading, writing, testing ...),
    sequences & arrays (of strings, of transients, of shapes ...),
    ...

    Also it gives some helps on some data structures from XSTEP,
    such as printing on standard trace file, recignizing most
    currently used auxiliary types (Binder,Mapper ...)
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(XSControl_Utils self) -> XSControl_Utils

        the only use of this, is to allow a frontal to get one
        distinct "Utils" set per separate engine


        """
        this = _XSControl.new_XSControl_Utils(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def TraceLine(self, *args):
        """
        TraceLine(XSControl_Utils self, Standard_CString const line)

        Just prints a line into the current Trace File. This allows to
        better characterise the various trace outputs, as desired.

        :type line: OCC.wrapper.Standard.Standard_CString

        """
        return _XSControl.XSControl_Utils_TraceLine(self, *args)


    def TraceLines(self, *args):
        """
        TraceLines(XSControl_Utils self, Handle_Standard_Transient lines)

        Just prints a line or a set of lines into the current Trace
        File. <lines> can be a HAscii/ExtendedString (produces a print
        without ending line) or a HSequence or HArray1 Of ..
        (one new line per item)

        :type lines: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _XSControl.XSControl_Utils_TraceLines(self, *args)


    def IsKind(self, *args):
        """
        IsKind(XSControl_Utils self, Handle_Standard_Transient item, Handle_Standard_Type what) -> Standard_Boolean

        :type item: OCC.wrapper.Standard.Handle_Standard_Transient
        :type what: OCC.wrapper.Standard.Handle_Standard_Type
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _XSControl.XSControl_Utils_IsKind(self, *args)


    def TypeName(self, *args):
        """
        TypeName(XSControl_Utils self, Handle_Standard_Transient item, Standard_Boolean const nopk) -> Standard_CString

        Returns the name of the dynamic type of an object, i.e. :
        If it is a Type, its Name
        If it is a object not a type, the Name of its DynamicType
        If it is Null, an empty string
        If <nopk> is False (D), gives complete name
        If <nopk> is True, returns class name without package

        :type item: OCC.wrapper.Standard.Handle_Standard_Transient
        :type nopk: bool
        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _XSControl.XSControl_Utils_TypeName(self, *args)


    def TraValue(self, *args):
        """
        TraValue(XSControl_Utils self, Handle_Standard_Transient list, Standard_Integer const num) -> Handle_Standard_Transient

        :type list: OCC.wrapper.Standard.Handle_Standard_Transient
        :type num: int
        :rtype: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _XSControl.XSControl_Utils_TraValue(self, *args)


    def NewSeqTra(self, *args):
        """
        NewSeqTra(XSControl_Utils self) -> Handle_TColStd_HSequenceOfTransient

        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfTransient

        """
        return _XSControl.XSControl_Utils_NewSeqTra(self, *args)


    def AppendTra(self, *args):
        """
        AppendTra(XSControl_Utils self, Handle_TColStd_HSequenceOfTransient seqval, Handle_Standard_Transient traval)

        :type seqval: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfTransient
        :type traval: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _XSControl.XSControl_Utils_AppendTra(self, *args)


    def DateString(self, *args):
        """
        DateString(XSControl_Utils self, Standard_Integer const yy, Standard_Integer const mm, Standard_Integer const dd, Standard_Integer const hh, Standard_Integer const mn, Standard_Integer const ss) -> Standard_CString

        :type yy: int
        :type mm: int
        :type dd: int
        :type hh: int
        :type mn: int
        :type ss: int
        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _XSControl.XSControl_Utils_DateString(self, *args)


    def DateValues(self, *args):
        """
        DateValues(XSControl_Utils self, Standard_CString const text)

        :type text: OCC.wrapper.Standard.Standard_CString
        :type yy: int
        :type mm: int
        :type dd: int
        :type hh: int
        :type mn: int
        :type ss: int

        """
        return _XSControl.XSControl_Utils_DateValues(self, *args)


    def ToCString(self, *args):
        """
        ToCString(XSControl_Utils self, Handle_TCollection_HAsciiString strval) -> Standard_CString
        ToCString(XSControl_Utils self, TCollection_AsciiString strval) -> Standard_CString

        :type strval: OCC.wrapper.TCollection.TCollection_AsciiString
        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _XSControl.XSControl_Utils_ToCString(self, *args)


    def ToAString(self, *args):
        """
        ToAString(XSControl_Utils self, Standard_CString const strcon) -> TCollection_AsciiString

        :type strcon: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _XSControl.XSControl_Utils_ToAString(self, *args)


    def ToEString(self, *args):
        """
        ToEString(XSControl_Utils self, Handle_TCollection_HExtendedString strval) -> Standard_ExtString
        ToEString(XSControl_Utils self, TCollection_ExtendedString strval) -> Standard_ExtString

        :type strval: OCC.wrapper.TCollection.TCollection_ExtendedString
        :rtype: OCC.wrapper.Standard.Standard_ExtString

        """
        return _XSControl.XSControl_Utils_ToEString(self, *args)


    def ToHString(self, *args):
        """
        ToHString(XSControl_Utils self, Standard_CString const strcon) -> Handle_TCollection_HAsciiString
        ToHString(XSControl_Utils self, Standard_ExtString const strcon) -> Handle_TCollection_HExtendedString

        :type strcon: OCC.wrapper.Standard.Standard_ExtString
        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HExtendedString

        """
        return _XSControl.XSControl_Utils_ToHString(self, *args)


    def ToXString(self, *args):
        """
        ToXString(XSControl_Utils self, Standard_ExtString const strcon) -> TCollection_ExtendedString

        :type strcon: OCC.wrapper.Standard.Standard_ExtString
        :rtype: OCC.wrapper.TCollection.TCollection_ExtendedString

        """
        return _XSControl.XSControl_Utils_ToXString(self, *args)


    def AsciiToExtended(self, *args):
        """
        AsciiToExtended(XSControl_Utils self, Standard_CString const str) -> Standard_ExtString

        :type str: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_ExtString

        """
        return _XSControl.XSControl_Utils_AsciiToExtended(self, *args)


    def IsAscii(self, *args):
        """
        IsAscii(XSControl_Utils self, Standard_ExtString const str) -> Standard_Boolean

        :type str: OCC.wrapper.Standard.Standard_ExtString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _XSControl.XSControl_Utils_IsAscii(self, *args)


    def ExtendedToAscii(self, *args):
        """
        ExtendedToAscii(XSControl_Utils self, Standard_ExtString const str) -> Standard_CString

        :type str: OCC.wrapper.Standard.Standard_ExtString
        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _XSControl.XSControl_Utils_ExtendedToAscii(self, *args)


    def CStrValue(self, *args):
        """
        CStrValue(XSControl_Utils self, Handle_Standard_Transient list, Standard_Integer const num) -> Standard_CString

        :type list: OCC.wrapper.Standard.Handle_Standard_Transient
        :type num: int
        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _XSControl.XSControl_Utils_CStrValue(self, *args)


    def EStrValue(self, *args):
        """
        EStrValue(XSControl_Utils self, Handle_Standard_Transient list, Standard_Integer const num) -> Standard_ExtString

        :type list: OCC.wrapper.Standard.Handle_Standard_Transient
        :type num: int
        :rtype: OCC.wrapper.Standard.Standard_ExtString

        """
        return _XSControl.XSControl_Utils_EStrValue(self, *args)


    def NewSeqCStr(self, *args):
        """
        NewSeqCStr(XSControl_Utils self) -> Handle_TColStd_HSequenceOfHAsciiString

        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfHAsciiString

        """
        return _XSControl.XSControl_Utils_NewSeqCStr(self, *args)


    def AppendCStr(self, *args):
        """
        AppendCStr(XSControl_Utils self, Handle_TColStd_HSequenceOfHAsciiString seqval, Standard_CString const strval)

        :type seqval: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfHAsciiString
        :type strval: OCC.wrapper.Standard.Standard_CString

        """
        return _XSControl.XSControl_Utils_AppendCStr(self, *args)


    def NewSeqEStr(self, *args):
        """
        NewSeqEStr(XSControl_Utils self) -> Handle_TColStd_HSequenceOfHExtendedString

        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfHExtendedString

        """
        return _XSControl.XSControl_Utils_NewSeqEStr(self, *args)


    def AppendEStr(self, *args):
        """
        AppendEStr(XSControl_Utils self, Handle_TColStd_HSequenceOfHExtendedString seqval, Standard_ExtString const strval)

        :type seqval: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfHExtendedString
        :type strval: OCC.wrapper.Standard.Standard_ExtString

        """
        return _XSControl.XSControl_Utils_AppendEStr(self, *args)


    def CompoundFromSeq(self, *args):
        """
        CompoundFromSeq(XSControl_Utils self, Handle_TopTools_HSequenceOfShape seqval) -> TopoDS_Shape

        Converts a list of Shapes to a Compound (a kind of Shape)

        :type seqval: OCC.wrapper.TopTools.Handle_TopTools_HSequenceOfShape
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _XSControl.XSControl_Utils_CompoundFromSeq(self, *args)


    def ShapeType(self, *args):
        """
        ShapeType(XSControl_Utils self, TopoDS_Shape shape, Standard_Boolean const compound) -> TopAbs_ShapeEnum

        Returns the type of a Shape : true type if <compound> is False
        If <compound> is True and <shape> is a Compound, iterates on
        its items. If all are of the same type, returns this type.
        Else, returns COMPOUND. If it is empty, returns SHAPE
        For a Null Shape, returns SHAPE

        :type shape: OCC.wrapper.TopoDS.TopoDS_Shape
        :type compound: bool
        :rtype: OCC.wrapper.TopAbs.TopAbs_ShapeEnum

        """
        return _XSControl.XSControl_Utils_ShapeType(self, *args)


    def SortedCompound(self, *args):
        """
        SortedCompound(XSControl_Utils self, TopoDS_Shape shape, TopAbs_ShapeEnum const type, Standard_Boolean const explore, Standard_Boolean const compound) -> TopoDS_Shape

        From a Shape, builds a Compound as follows :
        explores it level by level
        If <explore> is False, only COMPOUND items. Else, all items
        Adds to the result, shapes which comply to <type>
        + if <type> is WIRE, considers free edges (and makes wires)
        + if <type> is SHELL, considers free faces (and makes shells)
        If <compound> is True, gathers items in compounds which
        correspond to starting COMPOUND,SOLID or SHELL containers, or
        items directly contained in a Compound

        :type shape: OCC.wrapper.TopoDS.TopoDS_Shape
        :type type: OCC.wrapper.TopAbs.TopAbs_ShapeEnum
        :type explore: bool
        :type compound: bool
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _XSControl.XSControl_Utils_SortedCompound(self, *args)


    def ShapeValue(self, *args):
        """
        ShapeValue(XSControl_Utils self, Handle_TopTools_HSequenceOfShape seqv, Standard_Integer const num) -> TopoDS_Shape

        :type seqv: OCC.wrapper.TopTools.Handle_TopTools_HSequenceOfShape
        :type num: int
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _XSControl.XSControl_Utils_ShapeValue(self, *args)


    def NewSeqShape(self, *args):
        """
        NewSeqShape(XSControl_Utils self) -> Handle_TopTools_HSequenceOfShape

        :rtype: OCC.wrapper.TopTools.Handle_TopTools_HSequenceOfShape

        """
        return _XSControl.XSControl_Utils_NewSeqShape(self, *args)


    def AppendShape(self, *args):
        """
        AppendShape(XSControl_Utils self, Handle_TopTools_HSequenceOfShape seqv, TopoDS_Shape shape)

        :type seqv: OCC.wrapper.TopTools.Handle_TopTools_HSequenceOfShape
        :type shape: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _XSControl.XSControl_Utils_AppendShape(self, *args)


    def ShapeBinder(self, *args):
        """
        ShapeBinder(XSControl_Utils self, TopoDS_Shape shape, Standard_Boolean const hs) -> Handle_Standard_Transient

        Creates a Transient Object from a Shape : it is either a Binder
        (used by functions which require a Transient but can process
        a Shape, such as viewing functions) or a HShape (according to hs)
        Default is a HShape

        :type shape: OCC.wrapper.TopoDS.TopoDS_Shape
        :type hs: bool
        :rtype: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _XSControl.XSControl_Utils_ShapeBinder(self, *args)


    def BinderShape(self, *args):
        """
        BinderShape(XSControl_Utils self, Handle_Standard_Transient tr) -> TopoDS_Shape

        From a Transient, returns a Shape.
        In fact, recognizes ShapeBinder ShapeMapper and HShape

        :type tr: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _XSControl.XSControl_Utils_BinderShape(self, *args)


    def SeqLength(self, *args):
        """
        SeqLength(XSControl_Utils self, Handle_Standard_Transient list) -> Standard_Integer

        :type list: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _XSControl.XSControl_Utils_SeqLength(self, *args)


    def SeqToArr(self, *args):
        """
        SeqToArr(XSControl_Utils self, Handle_Standard_Transient seq, Standard_Integer const first=1) -> Handle_Standard_Transient

        :type seq: OCC.wrapper.Standard.Handle_Standard_Transient
        :type first: int
        :rtype: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _XSControl.XSControl_Utils_SeqToArr(self, *args)


    def ArrToSeq(self, *args):
        """
        ArrToSeq(XSControl_Utils self, Handle_Standard_Transient arr) -> Handle_Standard_Transient

        :type arr: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _XSControl.XSControl_Utils_ArrToSeq(self, *args)


    def SeqIntValue(self, *args):
        """
        SeqIntValue(XSControl_Utils self, Handle_TColStd_HSequenceOfInteger list, Standard_Integer const num) -> Standard_Integer

        :type list: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfInteger
        :type num: int
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _XSControl.XSControl_Utils_SeqIntValue(self, *args)

    __swig_destroy__ = _XSControl.delete_XSControl_Utils
XSControl_Utils_swigregister = _XSControl.XSControl_Utils_swigregister
XSControl_Utils_swigregister(XSControl_Utils)

class Handle_XSControl_WorkSession(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_XSControl_WorkSession self)

        Nullify the handle


        """
        return _XSControl.Handle_XSControl_WorkSession_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_XSControl_WorkSession self) -> bool

        Check for being null

        :rtype: bool

        """
        return _XSControl.Handle_XSControl_WorkSession_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_XSControl_WorkSession self, XSControl_WorkSession thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _XSControl.Handle_XSControl_WorkSession_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_XSControl_WorkSession self, Handle_XSControl_WorkSession theHandle) -> Handle_XSControl_WorkSession
        assign(Handle_XSControl_WorkSession self, XSControl_WorkSession thePtr) -> Handle_XSControl_WorkSession
        assign(Handle_XSControl_WorkSession self, Handle_XSControl_WorkSession theHandle) -> Handle_XSControl_WorkSession

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _XSControl.Handle_XSControl_WorkSession_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_XSControl_WorkSession self) -> XSControl_WorkSession

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _XSControl.Handle_XSControl_WorkSession_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_XSControl_WorkSession self) -> XSControl_WorkSession

        Member access operator (note non-const)

        :rtype: T *

        """
        return _XSControl.Handle_XSControl_WorkSession___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_XSControl_WorkSession self) -> XSControl_WorkSession

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _XSControl.Handle_XSControl_WorkSession___ref__(self, *args)


    def __hash__(self):
        return _XSControl.Handle_XSControl_WorkSession___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _XSControl.Handle_XSControl_WorkSession___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _XSControl.new_Handle_XSControl_WorkSession(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_XSControl.Handle_XSControl_WorkSession_DownCast)
    __swig_destroy__ = _XSControl.delete_Handle_XSControl_WorkSession

    def ClearData(self, *args):
        """
        ClearData(Handle_XSControl_WorkSession self, Standard_Integer const theMode)

        In addition to basic ClearData, clears Transfer and Management
        for interactive use, for mode = 0,1,2 and over 4
        Plus : mode = 5 to clear Transfers (both ways) only
        mode = 6 to clear enforced results
        mode = 7 to clear transfers, results

        :type theMode: int

        """
        return _XSControl.Handle_XSControl_WorkSession_ClearData(self, *args)


    def SelectNorm(self, *args):
        """
        SelectNorm(Handle_XSControl_WorkSession self, Standard_CString const theNormName) -> Standard_Boolean

        Selects a Norm defined by its name.
        A Norm is described and handled by a Controller
        Returns True if done, False if <normname> is unknown

        The current Profile for this Norm is taken.

        :type theNormName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _XSControl.Handle_XSControl_WorkSession_SelectNorm(self, *args)


    def SetController(self, *args):
        """
        SetController(Handle_XSControl_WorkSession self, Handle_XSControl_Controller theCtl)

        Selects a Norm defined by its Controller itself

        :type theCtl: OCC.wrapper.XSControl.Handle_XSControl_Controller

        """
        return _XSControl.Handle_XSControl_WorkSession_SetController(self, *args)


    def SelectedNorm(self, *args):
        """
        SelectedNorm(Handle_XSControl_WorkSession self, Standard_Boolean const theRsc) -> Standard_CString

        Returns the name of the last Selected Norm. If none is
        defined, returns an empty string
        By default, returns the complete name of the norm
        If <rsc> is True, returns the short name used for resource

        :type theRsc: bool
        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _XSControl.Handle_XSControl_WorkSession_SelectedNorm(self, *args)


    def NormAdaptor(self, *args):
        """
        Returns the norm controller itself

        :rtype: OCC.wrapper.XSControl.Handle_XSControl_Controller

        """
        res = _XSControl.Handle_XSControl_WorkSession_NormAdaptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Context(self, *args):
        """
        Returns the current Context List, Null if not defined
        The Context is given to the TransientProcess for TransferRead

        :rtype: OCC.wrapper.XSControl.NCollection_DataMap_TCollection_AsciiString_Handle_Standard_Transient

        """
        res = _XSControl.Handle_XSControl_WorkSession_Context(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetAllContext(self, *args):
        """
        SetAllContext(Handle_XSControl_WorkSession self, NCollection_DataMap< TCollection_AsciiString,opencascade::handle< Standard_Transient > > const & theContext)

        Sets the current Context List, as a whole
        Sets it to the TransferReader

        :type theContext: OCC.wrapper.XSControl.NCollection_DataMap_TCollection_AsciiString_Handle_Standard_Transient

        """
        return _XSControl.Handle_XSControl_WorkSession_SetAllContext(self, *args)


    def ClearContext(self, *args):
        """
        ClearContext(Handle_XSControl_WorkSession self)

        Clears the whole current Context (nullifies it)


        """
        return _XSControl.Handle_XSControl_WorkSession_ClearContext(self, *args)


    def PrintTransferStatus(self, *args):
        """
        PrintTransferStatus(Handle_XSControl_WorkSession self, Standard_Integer const theNum, Standard_Boolean const theWri, Handle_Message_Messenger theS) -> Standard_Boolean

        Prints the transfer status of a transferred item, as beeing
        the Mapped n0 <num>, from MapWriter if <wri> is True, or
        from MapReader if <wri> is False
        Returns True when done, False else (i.e. num out of range)

        :type theNum: int
        :type theWri: bool
        :type theS: OCC.wrapper.Message.Handle_Message_Messenger
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _XSControl.Handle_XSControl_WorkSession_PrintTransferStatus(self, *args)


    def InitTransferReader(self, *args):
        """
        InitTransferReader(Handle_XSControl_WorkSession self, Standard_Integer const theMode)

        Sets a Transfer Reader, by internal ways, according mode :
        0 recreates it clear,  1 clears it (does not recreate)
        2 aligns Roots of TransientProcess from final Results
        3 aligns final Results from Roots of TransientProcess
        4 begins a new transfer (by BeginTransfer)
        5 recreates TransferReader then begins a new transfer

        :type theMode: int

        """
        return _XSControl.Handle_XSControl_WorkSession_InitTransferReader(self, *args)


    def SetTransferReader(self, *args):
        """
        SetTransferReader(Handle_XSControl_WorkSession self, Handle_XSControl_TransferReader theTR)

        Sets a Transfer Reader, which manages transfers on reading

        :type theTR: OCC.wrapper.XSControl.Handle_XSControl_TransferReader

        """
        return _XSControl.Handle_XSControl_WorkSession_SetTransferReader(self, *args)


    def TransferReader(self, *args):
        """
        Returns the Transfer Reader, Null if not set

        :rtype: OCC.wrapper.XSControl.Handle_XSControl_TransferReader

        """
        res = _XSControl.Handle_XSControl_WorkSession_TransferReader(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def MapReader(self, *args):
        """
        MapReader(Handle_XSControl_WorkSession self) -> Handle_Transfer_TransientProcess

        Returns the TransientProcess(internal data for TransferReader)

        :rtype: OCC.wrapper.Transfer.Handle_Transfer_TransientProcess

        """
        return _XSControl.Handle_XSControl_WorkSession_MapReader(self, *args)


    def SetMapReader(self, *args):
        """
        SetMapReader(Handle_XSControl_WorkSession self, Handle_Transfer_TransientProcess theTP) -> Standard_Boolean

        Changes the Map Reader, i.e. considers that the new one
        defines the relevant read results (forgets the former ones)
        Returns True when done, False in case of bad definition, i.e.
        if Model from TP differs from that of Session

        :type theTP: OCC.wrapper.Transfer.Handle_Transfer_TransientProcess
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _XSControl.Handle_XSControl_WorkSession_SetMapReader(self, *args)


    def Result(self, *args):
        """
        Result(Handle_XSControl_WorkSession self, Handle_Standard_Transient theEnt, Standard_Integer const theMode) -> Handle_Standard_Transient

        Returns the result attached to a starting entity
        If <mode> = 0, returns Final Result
        If <mode> = 1, considers Last Result
        If <mode> = 2, considers Final, else if absent, Last
        returns it as Transient, if result is not transient returns
        the Binder
        <mode> = 10,11,12 idem but returns the Binder itself
        (if it is not, e.g. Shape, returns the Binder)
        <mode> = 20, returns the ResultFromModel

        :type theEnt: OCC.wrapper.Standard.Handle_Standard_Transient
        :type theMode: int
        :rtype: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _XSControl.Handle_XSControl_WorkSession_Result(self, *args)


    def TransferReadOne(self, *args):
        """
        TransferReadOne(Handle_XSControl_WorkSession self, Handle_Standard_Transient theEnts) -> Standard_Integer

        Commands the transfer of, either one entity, or a list
        I.E. calls the TransferReader after having analysed <ents>
        It is cumulated from the last BeginTransfer
        <ents> is processed by GiveList, hence :
        - <ents> a Selection : its SelectionResult
        - <ents> a HSequenceOfTransient : this list
        - <ents> the Model : in this specific case, all the roots,
        with no cumulation of former transfers (TransferReadRoots)

        :type theEnts: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _XSControl.Handle_XSControl_WorkSession_TransferReadOne(self, *args)


    def TransferReadRoots(self, *args):
        """
        TransferReadRoots(Handle_XSControl_WorkSession self) -> Standard_Integer

        Commands the transfer of all the root entities of the model
        i.e. calls TransferRoot from the TransferReader with the Graph
        No cumulation with former calls to TransferReadOne

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _XSControl.Handle_XSControl_WorkSession_TransferReadRoots(self, *args)


    def NewModel(self, *args):
        """
        NewModel(Handle_XSControl_WorkSession self) -> Handle_Interface_InterfaceModel

        produces and returns a new Model well conditionned
        It is produced by the Norm Controller
        It can be Null (if this function is not implemented)

        :rtype: OCC.wrapper.Interface.Handle_Interface_InterfaceModel

        """
        return _XSControl.Handle_XSControl_WorkSession_NewModel(self, *args)


    def TransferWriter(self, *args):
        """
        Returns the Transfer Reader, Null if not set

        :rtype: OCC.wrapper.XSControl.Handle_XSControl_TransferWriter

        """
        res = _XSControl.Handle_XSControl_WorkSession_TransferWriter(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetMapWriter(self, *args):
        """
        SetMapWriter(Handle_XSControl_WorkSession self, Handle_Transfer_FinderProcess theFP) -> Standard_Boolean

        Changes the Map Reader, i.e. considers that the new one
        defines the relevant read results (forgets the former ones)
        Returns True when done, False if <FP> is Null

        :type theFP: OCC.wrapper.Transfer.Handle_Transfer_FinderProcess
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _XSControl.Handle_XSControl_WorkSession_SetMapWriter(self, *args)


    def TransferWriteShape(self, *args):
        """
        TransferWriteShape(Handle_XSControl_WorkSession self, TopoDS_Shape theShape, Standard_Boolean const theCompGraph) -> IFSelect_ReturnStatus

        Transfers a Shape from CasCade to a model of current norm,
        according to the last call to SetModeWriteShape
        Returns status :Done if OK, Fail if error during transfer,
        Error if transfer badly initialised

        :type theShape: OCC.wrapper.TopoDS.TopoDS_Shape
        :type theCompGraph: bool
        :rtype: OCC.wrapper.IFSelect.IFSelect_ReturnStatus

        """
        return _XSControl.Handle_XSControl_WorkSession_TransferWriteShape(self, *args)


    def TransferWriteCheckList(self, *args):
        """
        TransferWriteCheckList(Handle_XSControl_WorkSession self) -> Interface_CheckIterator

        Returns the check-list of last transfer (write)
        It is recorded in the FinderProcess, but it must be bound with
        resulting entities (in the resulting file model) rather than
        with original objects (in fact, their mappers)

        :rtype: OCC.wrapper.Interface.Interface_CheckIterator

        """
        return _XSControl.Handle_XSControl_WorkSession_TransferWriteCheckList(self, *args)


    def Vars(self, *args):
        """
        :rtype: OCC.wrapper.XSControl.Handle_XSControl_Vars

        """
        res = _XSControl.Handle_XSControl_WorkSession_Vars(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetVars(self, *args):
        """
        SetVars(Handle_XSControl_WorkSession self, Handle_XSControl_Vars theVars)

        :type theVars: OCC.wrapper.XSControl.Handle_XSControl_Vars

        """
        return _XSControl.Handle_XSControl_WorkSession_SetVars(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_XSControl_WorkSession self) -> char const *

        :rtype: const char *

        """
        return _XSControl.Handle_XSControl_WorkSession_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _XSControl.Handle_XSControl_WorkSession_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _XSControl.Handle_XSControl_WorkSession_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetErrorHandle(self, *args):
        """
        SetErrorHandle(Handle_XSControl_WorkSession self, Standard_Boolean const toHandle)

        Changes the Error Handler status (by default, it is not set)

        :type toHandle: bool

        """
        return _XSControl.Handle_XSControl_WorkSession_SetErrorHandle(self, *args)


    def ErrorHandle(self, *args):
        """
        ErrorHandle(Handle_XSControl_WorkSession self) -> Standard_Boolean

        Returns the Error Handler status

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _XSControl.Handle_XSControl_WorkSession_ErrorHandle(self, *args)


    def ShareOut(self, *args):
        """
        Returns the ShareOut defined at creation time

        :rtype: OCC.wrapper.IFSelect.Handle_IFSelect_ShareOut

        """
        res = _XSControl.Handle_XSControl_WorkSession_ShareOut(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetShareOut(self, *args):
        """
        SetShareOut(Handle_XSControl_WorkSession self, Handle_IFSelect_ShareOut shareout)

        Sets a new ShareOut. Fills Items which its content
        Warning : data from the former ShareOut are lost

        :type shareout: OCC.wrapper.IFSelect.Handle_IFSelect_ShareOut

        """
        return _XSControl.Handle_XSControl_WorkSession_SetShareOut(self, *args)


    def SetModeStat(self, *args):
        """
        SetModeStat(Handle_XSControl_WorkSession self, Standard_Boolean const theMode)

        Set value of mode responsible for precence of selections after loading
        If mode set to true that different selections will be accessible after loading
        else selections will be not accessible after loading( for economy memory in applicatios)

        :type theMode: bool

        """
        return _XSControl.Handle_XSControl_WorkSession_SetModeStat(self, *args)


    def GetModeStat(self, *args):
        """
        GetModeStat(Handle_XSControl_WorkSession self) -> Standard_Boolean

        Return value of mode defining of filling selection during loading

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _XSControl.Handle_XSControl_WorkSession_GetModeStat(self, *args)


    def SetLibrary(self, *args):
        """
        SetLibrary(Handle_XSControl_WorkSession self, Handle_IFSelect_WorkLibrary theLib)

        Sets a WorkLibrary, which will be used to Read and Write Files

        :type theLib: OCC.wrapper.IFSelect.Handle_IFSelect_WorkLibrary

        """
        return _XSControl.Handle_XSControl_WorkSession_SetLibrary(self, *args)


    def WorkLibrary(self, *args):
        """
        Returns the WorkLibrary. Null Handle if not yet set
        should be C++ : return const &

        :rtype: OCC.wrapper.IFSelect.Handle_IFSelect_WorkLibrary

        """
        res = _XSControl.Handle_XSControl_WorkSession_WorkLibrary(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetProtocol(self, *args):
        """
        SetProtocol(Handle_XSControl_WorkSession self, Handle_Interface_Protocol protocol)

        Sets a Protocol, which will be used to determine Graphs, to
        Read and to Write Files

        :type protocol: OCC.wrapper.Interface.Handle_Interface_Protocol

        """
        return _XSControl.Handle_XSControl_WorkSession_SetProtocol(self, *args)


    def Protocol(self, *args):
        """
        Returns the Protocol. Null Handle if not yet set
        should be C++ : return const &

        :rtype: OCC.wrapper.Interface.Handle_Interface_Protocol

        """
        res = _XSControl.Handle_XSControl_WorkSession_Protocol(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetSignType(self, *args):
        """
        SetSignType(Handle_XSControl_WorkSession self, Handle_IFSelect_Signature signtype)

        Sets a specific Signature to be the SignType, i.e. the
        Signature which will determine TypeName from the Model
        (basic function). It is recorded in the GTool
        This Signature is also set as "xst-sign-type" (reserved name)

        :type signtype: OCC.wrapper.IFSelect.Handle_IFSelect_Signature

        """
        return _XSControl.Handle_XSControl_WorkSession_SetSignType(self, *args)


    def SignType(self, *args):
        """
        SignType(Handle_XSControl_WorkSession self) -> Handle_IFSelect_Signature

        Returns the current SignType

        :rtype: OCC.wrapper.IFSelect.Handle_IFSelect_Signature

        """
        return _XSControl.Handle_XSControl_WorkSession_SignType(self, *args)


    def HasModel(self, *args):
        """
        HasModel(Handle_XSControl_WorkSession self) -> Standard_Boolean

        Returns True is a Model has been set

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _XSControl.Handle_XSControl_WorkSession_HasModel(self, *args)


    def SetModel(self, *args):
        """
        SetModel(Handle_XSControl_WorkSession self, Handle_Interface_InterfaceModel model, Standard_Boolean const clearpointed)

        Sets a Model as input : this will be the Model from which the
        ShareOut will work
        if <clearpointed> is True (default) all SelectPointed items
        are cleared, else they must be managed by the caller
        Remark : SetModel clears the Graph, recomputes it if a
        Protocol is set and if the Model is not empty, of course

        :type model: OCC.wrapper.Interface.Handle_Interface_InterfaceModel
        :type clearpointed: bool

        """
        return _XSControl.Handle_XSControl_WorkSession_SetModel(self, *args)


    def Model(self, *args):
        """
        Returns the Model of the Work Session (Null Handle if none)
        should be C++ : return const &

        :rtype: OCC.wrapper.Interface.Handle_Interface_InterfaceModel

        """
        res = _XSControl.Handle_XSControl_WorkSession_Model(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetLoadedFile(self, *args):
        """
        SetLoadedFile(Handle_XSControl_WorkSession self, Standard_CString const theFileName)

        Stores the filename used for read for setting the model
        It is cleared by SetModel and ClearData(1)

        :type theFileName: OCC.wrapper.Standard.Standard_CString

        """
        return _XSControl.Handle_XSControl_WorkSession_SetLoadedFile(self, *args)


    def LoadedFile(self, *args):
        """
        LoadedFile(Handle_XSControl_WorkSession self) -> Standard_CString

        Returns the filename used to load current model
        empty if unknown

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _XSControl.Handle_XSControl_WorkSession_LoadedFile(self, *args)


    def ReadFile(self, *args):
        """
        ReadFile(Handle_XSControl_WorkSession self, Standard_CString const filename) -> IFSelect_ReturnStatus

        Reads a file with the WorkLibrary (sets Model and LoadedFile)
        Returns a integer status which can be :
        RetDone if OK,  RetVoid if no Protocol not defined,
        RetError for file not found, RetFail if fail during read

        :type filename: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.IFSelect.IFSelect_ReturnStatus

        """
        return _XSControl.Handle_XSControl_WorkSession_ReadFile(self, *args)


    def NbStartingEntities(self, *args):
        """
        NbStartingEntities(Handle_XSControl_WorkSession self) -> Standard_Integer

        Returns the count of Entities stored in the Model, or 0

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _XSControl.Handle_XSControl_WorkSession_NbStartingEntities(self, *args)


    def StartingEntity(self, *args):
        """
        StartingEntity(Handle_XSControl_WorkSession self, Standard_Integer const num) -> Handle_Standard_Transient

        Returns an  Entity stored in the Model of the WorkSession
        (Null Handle is no Model or num out of range)

        :type num: int
        :rtype: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _XSControl.Handle_XSControl_WorkSession_StartingEntity(self, *args)


    def StartingNumber(self, *args):
        """
        StartingNumber(Handle_XSControl_WorkSession self, Handle_Standard_Transient ent) -> Standard_Integer

        Returns the Number of an Entity in the Model
        (0 if no Model set or <ent> not in the Model)

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _XSControl.Handle_XSControl_WorkSession_StartingNumber(self, *args)


    def NumberFromLabel(self, *args):
        """
        NumberFromLabel(Handle_XSControl_WorkSession self, Standard_CString const val, Standard_Integer const afternum=0) -> Standard_Integer

        From a given label in Model, returns the corresponding number
        Starts from first entity by Default, may start after a given
        number : this number may be given negative, its absolute value
        is then considered. Hence a loop on NumberFromLabel may be
        programmed (stop test is : returned value positive or null)

        Returns 0 if not found, < 0 if more than one found (first
        found in negative).
        If <val> just gives an integer value, returns it

        :type val: OCC.wrapper.Standard.Standard_CString
        :type afternum: int
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _XSControl.Handle_XSControl_WorkSession_NumberFromLabel(self, *args)


    def EntityLabel(self, *args):
        """
        EntityLabel(Handle_XSControl_WorkSession self, Handle_Standard_Transient ent) -> Handle_TCollection_HAsciiString

        Returns the label for <ent>, as the Model does
        If <ent> is not in the Model or if no Model is loaded, a Null
        Handle is returned

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _XSControl.Handle_XSControl_WorkSession_EntityLabel(self, *args)


    def EntityName(self, *args):
        """
        EntityName(Handle_XSControl_WorkSession self, Handle_Standard_Transient ent) -> Handle_TCollection_HAsciiString

        Returns the Name of an Entity
        This Name is computed by the general service Name
        Returns a Null Handle if fails

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _XSControl.Handle_XSControl_WorkSession_EntityName(self, *args)


    def CategoryNumber(self, *args):
        """
        CategoryNumber(Handle_XSControl_WorkSession self, Handle_Standard_Transient ent) -> Standard_Integer

        Returns the Category Number determined for an entity
        it is computed by the class Category
        An unknown entity (number 0) gives a value -1

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _XSControl.Handle_XSControl_WorkSession_CategoryNumber(self, *args)


    def CategoryName(self, *args):
        """
        CategoryName(Handle_XSControl_WorkSession self, Handle_Standard_Transient ent) -> Standard_CString

        Returns the Category Name determined for an entity
        it is computed by the class Category
        Remark : an unknown entity gives an empty string

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _XSControl.Handle_XSControl_WorkSession_CategoryName(self, *args)


    def ValidityName(self, *args):
        """
        ValidityName(Handle_XSControl_WorkSession self, Handle_Standard_Transient ent) -> Standard_CString

        Returns the Validity Name determined for an entity
        it is computed by the class SignValidity
        Remark : an unknown entity gives an empty string

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _XSControl.Handle_XSControl_WorkSession_ValidityName(self, *args)


    def ComputeGraph(self, *args):
        """
        ComputeGraph(Handle_XSControl_WorkSession self, Standard_Boolean const enforce) -> Standard_Boolean

        Computes the Graph used for Selections, Displays ...
        If a HGraph is already set, with same model as given by method
        Model, does nothing. Else, computes a new Graph.
        If <enforce> is given True, computes a new Graph anyway.
        Remark that a call to ClearGraph will cause ComputeGraph to
        really compute a new Graph
        Returns True if Graph is OK, False else (i.e. if no Protocol
        is set, or if Model is absent or empty).

        :type enforce: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _XSControl.Handle_XSControl_WorkSession_ComputeGraph(self, *args)


    def HGraph(self, *args):
        """
        HGraph(Handle_XSControl_WorkSession self) -> Handle_Interface_HGraph

        Returns the Computed Graph as HGraph (Null Handle if not set)

        :rtype: OCC.wrapper.Interface.Handle_Interface_HGraph

        """
        return _XSControl.Handle_XSControl_WorkSession_HGraph(self, *args)


    def Graph(self, *args):
        """
        Returns the Computed Graph, for Read only

        :rtype: OCC.wrapper.Interface.Interface_Graph

        """
        res = _XSControl.Handle_XSControl_WorkSession_Graph(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Shareds(self, *args):
        """
        Shareds(Handle_XSControl_WorkSession self, Handle_Standard_Transient ent) -> Handle_TColStd_HSequenceOfTransient

        Returns the list of entities shared by <ent> (can be empty)
        Returns a null Handle if <ent> is unknown

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfTransient

        """
        return _XSControl.Handle_XSControl_WorkSession_Shareds(self, *args)


    def Sharings(self, *args):
        """
        Sharings(Handle_XSControl_WorkSession self, Handle_Standard_Transient ent) -> Handle_TColStd_HSequenceOfTransient

        Returns the list of entities sharing <ent> (can be empty)
        Returns a null Handle if <ent> is unknown

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfTransient

        """
        return _XSControl.Handle_XSControl_WorkSession_Sharings(self, *args)


    def IsLoaded(self, *args):
        """
        IsLoaded(Handle_XSControl_WorkSession self) -> Standard_Boolean

        Returns True if a Model is defined and really loaded (not
        empty), a Protocol is set and a Graph has been computed.
        In this case, the WorkSession can start to work

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _XSControl.Handle_XSControl_WorkSession_IsLoaded(self, *args)


    def ComputeCheck(self, *args):
        """
        ComputeCheck(Handle_XSControl_WorkSession self, Standard_Boolean const enforce) -> Standard_Boolean

        Computes the CheckList for the Model currently loaded
        It can then be used for displays, querries ...
        Returns True if OK, False else (i.e. no Protocol set, or Model
        absent). If <enforce> is False, works only if not already done
        or if a new Model has been loaded from last call.
        Remark : computation is enforced by every call to
        SetModel or RunTransformer

        :type enforce: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _XSControl.Handle_XSControl_WorkSession_ComputeCheck(self, *args)


    def ModelCheckList(self, *args):
        """
        ModelCheckList(Handle_XSControl_WorkSession self, Standard_Boolean const complete) -> Interface_CheckIterator

        Returns the Check List for the Model currently loaded :
        <complete> = True  : complete (syntactic & semantic messages),
        computed if not yet done
        <complete> = False : only syntactic (check file form)

        :type complete: bool
        :rtype: OCC.wrapper.Interface.Interface_CheckIterator

        """
        return _XSControl.Handle_XSControl_WorkSession_ModelCheckList(self, *args)


    def CheckOne(self, *args):
        """
        CheckOne(Handle_XSControl_WorkSession self, Handle_Standard_Transient ent, Standard_Boolean const complete) -> Interface_CheckIterator

        Returns a Check for a single entity, under the form of a
        CheckIterator (this gives only one form for the user)
        if <ent> is Null or equates the current Model, it gives the
        Global Check, else the Check for the given entity
        <complete> as for ModelCheckList

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type complete: bool
        :rtype: OCC.wrapper.Interface.Interface_CheckIterator

        """
        return _XSControl.Handle_XSControl_WorkSession_CheckOne(self, *args)


    def LastRunCheckList(self, *args):
        """
        LastRunCheckList(Handle_XSControl_WorkSession self) -> Interface_CheckIterator

        Returns the Check List produced by the last execution of
        either : EvaluateFile(for Split), SendSplit, SendAll,
        SendSelected, RunTransformer-RunModifier
        Cleared by SetModel or ClearData(1)
        The field is protected, hence a specialized WorkSession may
        fill it

        :rtype: OCC.wrapper.Interface.Interface_CheckIterator

        """
        return _XSControl.Handle_XSControl_WorkSession_LastRunCheckList(self, *args)


    def MaxIdent(self, *args):
        """
        MaxIdent(Handle_XSControl_WorkSession self) -> Standard_Integer

        Returns the Maximum Value for an Item Identifier. It can be
        greater to the count of known Items, because some can have
        been removed

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _XSControl.Handle_XSControl_WorkSession_MaxIdent(self, *args)


    def Item(self, *args):
        """
        Item(Handle_XSControl_WorkSession self, Standard_Integer const id) -> Handle_Standard_Transient

        Returns an Item, given its Ident. Returns a Null Handle if
        no Item corresponds to this Ident.

        :type id: int
        :rtype: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _XSControl.Handle_XSControl_WorkSession_Item(self, *args)


    def ItemIdent(self, *args):
        """
        ItemIdent(Handle_XSControl_WorkSession self, Handle_Standard_Transient item) -> Standard_Integer

        Returns the Ident attached to an Item in the WorkSession, or
        Zero if it is unknown

        :type item: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _XSControl.Handle_XSControl_WorkSession_ItemIdent(self, *args)


    def NamedItem(self, *args):
        """
        NamedItem(Handle_XSControl_WorkSession self, Standard_CString const name) -> Handle_Standard_Transient
        NamedItem(Handle_XSControl_WorkSession self, Handle_TCollection_HAsciiString name) -> Handle_Standard_Transient

        Same as above, but <name> is given through a Handle
        Especially Usefull with methods SelectionNames, etc...

        :type name: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :rtype: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _XSControl.Handle_XSControl_WorkSession_NamedItem(self, *args)


    def NameIdent(self, *args):
        """
        NameIdent(Handle_XSControl_WorkSession self, Standard_CString const name) -> Standard_Integer

        Returns the Ident attached to a Name, 0 if name not recorded

        :type name: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _XSControl.Handle_XSControl_WorkSession_NameIdent(self, *args)


    def HasName(self, *args):
        """
        HasName(Handle_XSControl_WorkSession self, Handle_Standard_Transient item) -> Standard_Boolean

        Returns True if an Item of the WorkSession has an attached Name

        :type item: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _XSControl.Handle_XSControl_WorkSession_HasName(self, *args)


    def Name(self, *args):
        """
        Name(Handle_XSControl_WorkSession self, Handle_Standard_Transient item) -> Handle_TCollection_HAsciiString

        Returns the Name attached to an Item as a Variable of this
        WorkSession. If <item> is Null or not recorded, returns an
        empty string.

        :type item: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _XSControl.Handle_XSControl_WorkSession_Name(self, *args)


    def AddItem(self, *args):
        """
        AddItem(Handle_XSControl_WorkSession self, Handle_Standard_Transient item, Standard_Boolean const active) -> Standard_Integer

        Adds an Item and returns its attached Ident. Does nothing
        if <item> is already recorded (and returns its attached Ident)
        <active> if True commands call to SetActive (see below)
        Remark : the determined Ident is used if <item> is a Dispatch,
        to fill the ShareOut

        :type item: OCC.wrapper.Standard.Handle_Standard_Transient
        :type active: bool
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _XSControl.Handle_XSControl_WorkSession_AddItem(self, *args)


    def AddNamedItem(self, *args):
        """
        AddNamedItem(Handle_XSControl_WorkSession self, Standard_CString const name, Handle_Standard_Transient item, Standard_Boolean const active) -> Standard_Integer

        Adds an Item with an attached Name. If the Name is already
        known in the WorkSession, the older item losts it
        Returns Ident if Done, 0 else, i.e. if <item> is null
        If <name> is empty, works as AddItem (i.e. with no name)
        If <item> is already known but with no attached Name, this
        method tries to attached a Name to it
        <active> if True commands call to SetActive (see below)

        :type name: OCC.wrapper.Standard.Standard_CString
        :type item: OCC.wrapper.Standard.Handle_Standard_Transient
        :type active: bool
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _XSControl.Handle_XSControl_WorkSession_AddNamedItem(self, *args)


    def SetActive(self, *args):
        """
        SetActive(Handle_XSControl_WorkSession self, Handle_Standard_Transient item, Standard_Boolean const mode) -> Standard_Boolean

        Following the type of <item> :
        - Dispatch : Adds or Removes it in the ShareOut & FileNaming
        - GeneralModifier : Adds or Removes it for final sending
        (i.e. in the ModelCopier)
        Returns True if it did something, False else (state unchanged)

        :type item: OCC.wrapper.Standard.Handle_Standard_Transient
        :type mode: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _XSControl.Handle_XSControl_WorkSession_SetActive(self, *args)


    def RemoveNamedItem(self, *args):
        """
        RemoveNamedItem(Handle_XSControl_WorkSession self, Standard_CString const name) -> Standard_Boolean

        Removes an Item from the Session, given its Name
        Returns True if Done, False else (Name not recorded)
        (Applies only on Item which are Named)

        :type name: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _XSControl.Handle_XSControl_WorkSession_RemoveNamedItem(self, *args)


    def RemoveName(self, *args):
        """
        RemoveName(Handle_XSControl_WorkSession self, Standard_CString const name) -> Standard_Boolean

        Removes a Name without removing the Item
        Returns True if Done, False else (Name not recorded)

        :type name: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _XSControl.Handle_XSControl_WorkSession_RemoveName(self, *args)


    def RemoveItem(self, *args):
        """
        RemoveItem(Handle_XSControl_WorkSession self, Handle_Standard_Transient item) -> Standard_Boolean

        Removes an Item given its Ident. Returns False if <id> is
        attached to no Item in the WorkSession. For a Named Item,
        also removes its Name.

        :type item: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _XSControl.Handle_XSControl_WorkSession_RemoveItem(self, *args)


    def ClearItems(self, *args):
        """
        ClearItems(Handle_XSControl_WorkSession self)

        Clears all the recorded Items : Selections, Dispatches,
        Modifiers, and Strings & IntParams, with their Idents & Names.
        Remark that if a Model has been loaded, it is not cleared.


        """
        return _XSControl.Handle_XSControl_WorkSession_ClearItems(self, *args)


    def ItemLabel(self, *args):
        """
        ItemLabel(Handle_XSControl_WorkSession self, Standard_Integer const id) -> Handle_TCollection_HAsciiString

        Returns a Label which illustrates the content of an Item,
        given its Ident. This Label is :
        - for a Text Parameter, "Text:<text value>"
        - for an Integer Parameter, "Integer:<integer value>"
        - for a Selection, a Dispatch or a Modifier, its Label
        (see these classes)
        - for any other kind of Variable, its cdl type

        :type id: int
        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _XSControl.Handle_XSControl_WorkSession_ItemLabel(self, *args)


    def ItemIdents(self, *args):
        """
        ItemIdents(Handle_XSControl_WorkSession self, Handle_Standard_Type type) -> Handle_TColStd_HSequenceOfInteger

        Fills a Sequence with the List of Idents attached to the Items
        of which Type complies with (IsKind) <type> (alphabetic order)
        Remark : <type> = TYPE(Standard_Transient) gives all the
        Idents which are suitable in the WorkSession

        :type type: OCC.wrapper.Standard.Handle_Standard_Type
        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfInteger

        """
        return _XSControl.Handle_XSControl_WorkSession_ItemIdents(self, *args)


    def ItemNames(self, *args):
        """
        ItemNames(Handle_XSControl_WorkSession self, Handle_Standard_Type type) -> Handle_TColStd_HSequenceOfHAsciiString

        Fills a Sequence with the list of the Names attached to Items
        of which Type complies with (IsKind) <type> (alphabetic order)
        Remark : <type> = TYPE(Standard_Transient) gives all the Names

        :type type: OCC.wrapper.Standard.Handle_Standard_Type
        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfHAsciiString

        """
        return _XSControl.Handle_XSControl_WorkSession_ItemNames(self, *args)


    def ItemNamesForLabel(self, *args):
        """
        ItemNamesForLabel(Handle_XSControl_WorkSession self, Standard_CString const label) -> Handle_TColStd_HSequenceOfHAsciiString

        Fills a Sequence with the NAMES of the control items, of which
        the label matches <label> (contain it) : see NextIdentForLabel
        Search mode is fixed to "contained"
        If <label> is empty, returns all Names

        :type label: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfHAsciiString

        """
        return _XSControl.Handle_XSControl_WorkSession_ItemNamesForLabel(self, *args)


    def NextIdentForLabel(self, *args):
        """
        NextIdentForLabel(Handle_XSControl_WorkSession self, Standard_CString const label, Standard_Integer const id, Standard_Integer const mode=0) -> Standard_Integer

        For query by Label with possible iterations
        Searches the Ident of which Item has a Label which matches a
        given one, the search starts from an initial Ident.
        Returns the first found Ident which follows <id>, or ZERO

        The search must start with <id> = 0, it returns the next Ident
        which matches. To iterate, call again this method which this
        returned value as <id>. Once an Ident has been returned, the
        Item can be obtained by the method Item

        <mode> precises the required matching mode :
        - 0 (Default) : <label> must match exactly with the Item Label
        - 1 : <label> must match the exact beginning (the end is free)
        - 2 : <label> must be at least once wherever in the Item Label
        - other values are ignored

        :type label: OCC.wrapper.Standard.Standard_CString
        :type id: int
        :type mode: int
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _XSControl.Handle_XSControl_WorkSession_NextIdentForLabel(self, *args)


    def NewParamFromStatic(self, *args):
        """
        NewParamFromStatic(Handle_XSControl_WorkSession self, Standard_CString const statname, Standard_CString const name) -> Handle_Standard_Transient

        Creates a parameter as being bound to a Static
        If the Static is Integer, this creates an IntParam bound to
        it by its name. Else this creates a String which is the value
        of the Static.
        Returns a null handle if <statname> is unknown as a Static

        :type statname: OCC.wrapper.Standard.Standard_CString
        :type name: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _XSControl.Handle_XSControl_WorkSession_NewParamFromStatic(self, *args)


    def IntParam(self, *args):
        """
        IntParam(Handle_XSControl_WorkSession self, Standard_Integer const id) -> Handle_IFSelect_IntParam

        Returns an IntParam, given its Ident in the Session
        Null result if <id> is not suitable for an IntParam
        (undefined, or defined for another kind of variable)

        :type id: int
        :rtype: OCC.wrapper.IFSelect.Handle_IFSelect_IntParam

        """
        return _XSControl.Handle_XSControl_WorkSession_IntParam(self, *args)


    def IntValue(self, *args):
        """
        IntValue(Handle_XSControl_WorkSession self, Handle_IFSelect_IntParam it) -> Standard_Integer

        Returns Integer Value of an IntParam

        :type it: OCC.wrapper.IFSelect.Handle_IFSelect_IntParam
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _XSControl.Handle_XSControl_WorkSession_IntValue(self, *args)


    def NewIntParam(self, *args):
        """
        NewIntParam(Handle_XSControl_WorkSession self, Standard_CString const name) -> Handle_IFSelect_IntParam

        Creates a new IntParam. A Name can be set (Optional)
        Returns the created IntParam, or a Null Handle in case of
        Failure (see AddItem/AddNamedItem)

        :type name: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.IFSelect.Handle_IFSelect_IntParam

        """
        return _XSControl.Handle_XSControl_WorkSession_NewIntParam(self, *args)


    def SetIntValue(self, *args):
        """
        SetIntValue(Handle_XSControl_WorkSession self, Handle_IFSelect_IntParam it, Standard_Integer const val) -> Standard_Boolean

        Changes the Integer Value of an IntParam
        Returns True if Done, False if <it> is not in the WorkSession

        :type it: OCC.wrapper.IFSelect.Handle_IFSelect_IntParam
        :type val: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _XSControl.Handle_XSControl_WorkSession_SetIntValue(self, *args)


    def TextParam(self, *args):
        """
        TextParam(Handle_XSControl_WorkSession self, Standard_Integer const id) -> Handle_TCollection_HAsciiString

        Returns a TextParam, given its Ident in the Session
        Null result if <id> is not suitable for a TextParam
        (undefined, or defined for another kind of variable)

        :type id: int
        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _XSControl.Handle_XSControl_WorkSession_TextParam(self, *args)


    def TextValue(self, *args):
        """
        TextValue(Handle_XSControl_WorkSession self, Handle_TCollection_HAsciiString par) -> TCollection_AsciiString

        Returns Text Value of a TextParam (a String)
        or an empty string if <it> is not in the WorkSession

        :type par: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _XSControl.Handle_XSControl_WorkSession_TextValue(self, *args)


    def NewTextParam(self, *args):
        """
        NewTextParam(Handle_XSControl_WorkSession self, Standard_CString const name) -> Handle_TCollection_HAsciiString

        Creates a new (empty) TextParam. A Name can be set (Optional)
        Returns the created TextParam (as an HAsciiString), or a Null
        Handle in case of Failure (see AddItem/AddNamedItem)

        :type name: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _XSControl.Handle_XSControl_WorkSession_NewTextParam(self, *args)


    def SetTextValue(self, *args):
        """
        SetTextValue(Handle_XSControl_WorkSession self, Handle_TCollection_HAsciiString par, Standard_CString const val) -> Standard_Boolean

        Changes the Text Value of a TextParam (an HAsciiString)
        Returns True if Done, False if <it> is not in the WorkSession

        :type par: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type val: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _XSControl.Handle_XSControl_WorkSession_SetTextValue(self, *args)


    def Signature(self, *args):
        """
        Signature(Handle_XSControl_WorkSession self, Standard_Integer const id) -> Handle_IFSelect_Signature

        Returns a Signature, given its Ident in the Session
        Null result if <id> is not suitable for a Signature
        (undefined, or defined for another kind of variable)

        :type id: int
        :rtype: OCC.wrapper.IFSelect.Handle_IFSelect_Signature

        """
        return _XSControl.Handle_XSControl_WorkSession_Signature(self, *args)


    def SignValue(self, *args):
        """
        SignValue(Handle_XSControl_WorkSession self, Handle_IFSelect_Signature sign, Handle_Standard_Transient ent) -> Standard_CString

        Returns the Value computed by a Signature for an Entity
        Returns an empty string if the entity does not belong to the
        loaded model

        :type sign: OCC.wrapper.IFSelect.Handle_IFSelect_Signature
        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _XSControl.Handle_XSControl_WorkSession_SignValue(self, *args)


    def Selection(self, *args):
        """
        Selection(Handle_XSControl_WorkSession self, Standard_Integer const id) -> Handle_IFSelect_Selection

        Returns a Selection, given its Ident in the Session
        Null result if <id> is not suitable for a Selection
        (undefined, or defined for another kind of variable)

        :type id: int
        :rtype: OCC.wrapper.IFSelect.Handle_IFSelect_Selection

        """
        return _XSControl.Handle_XSControl_WorkSession_Selection(self, *args)


    def EvalSelection(self, *args):
        """
        EvalSelection(Handle_XSControl_WorkSession self, Handle_IFSelect_Selection sel) -> Interface_EntityIterator

        Evaluates the effect of a Selection applied on the input Model
        Returned Result remains empty if no input Model has been set

        :type sel: OCC.wrapper.IFSelect.Handle_IFSelect_Selection
        :rtype: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _XSControl.Handle_XSControl_WorkSession_EvalSelection(self, *args)


    def Sources(self, *args):
        """
        Sources(Handle_XSControl_WorkSession self, Handle_IFSelect_Selection sel) -> IFSelect_SelectionIterator

        Returns the Selections which are source of Selection, given
        its rank in the List of Selections (see SelectionIterator)
        Returned value is empty if <num> is out of range or if
        <sel> is not in the WorkSession

        :type sel: OCC.wrapper.IFSelect.Handle_IFSelect_Selection
        :rtype: OCC.wrapper.IFSelect.IFSelect_SelectionIterator

        """
        return _XSControl.Handle_XSControl_WorkSession_Sources(self, *args)


    def SelectionResult(self, *args):
        """
        SelectionResult(Handle_XSControl_WorkSession self, Handle_IFSelect_Selection sel) -> Handle_TColStd_HSequenceOfTransient

        Returns the result of a Selection, computed by EvalSelection
        (see above) under the form of a HSequence (hence, it can be
        used by a frontal-engine logic). It can be empty
        Returns a Null Handle if <sel> is not in the WorkSession

        :type sel: OCC.wrapper.IFSelect.Handle_IFSelect_Selection
        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfTransient

        """
        return _XSControl.Handle_XSControl_WorkSession_SelectionResult(self, *args)


    def SelectionResultFromList(self, *args):
        """
        SelectionResultFromList(Handle_XSControl_WorkSession self, Handle_IFSelect_Selection sel, Handle_TColStd_HSequenceOfTransient list) -> Handle_TColStd_HSequenceOfTransient

        Returns the result of a Selection, by forcing its input with
        a given list <list> (unless <list> is Null).
        RULES :
        <list> applies only for a SelectDeduct kind Selection :
        its Input is considered : if it is a SelectDeduct kind
        Selection, its Input is considered, etc... until an Input
        is not a Deduct/Extract : its result is replaced by <list>
        and all the chain of deductions is applied

        :type sel: OCC.wrapper.IFSelect.Handle_IFSelect_Selection
        :type list: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfTransient
        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfTransient

        """
        return _XSControl.Handle_XSControl_WorkSession_SelectionResultFromList(self, *args)


    def SetItemSelection(self, *args):
        """
        SetItemSelection(Handle_XSControl_WorkSession self, Handle_Standard_Transient item, Handle_IFSelect_Selection sel) -> Standard_Boolean

        Sets a Selection as input for an item, according its type :
        if <item> is a Dispatch : as Final Selection
        if <item> is a GeneralModifier (i.e. any kind of Modifier) :
        as Selection used to filter entities to modify
        <sel>  Null  causes this Selection to be nullified
        Returns False if <item> is not of a suitable type, or
        <item> or <sel> is not in the WorkSession

        :type item: OCC.wrapper.Standard.Handle_Standard_Transient
        :type sel: OCC.wrapper.IFSelect.Handle_IFSelect_Selection
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _XSControl.Handle_XSControl_WorkSession_SetItemSelection(self, *args)


    def ResetItemSelection(self, *args):
        """
        ResetItemSelection(Handle_XSControl_WorkSession self, Handle_Standard_Transient item) -> Standard_Boolean

        Resets input Selection which was set by SetItemSelection
        Same conditions as for SetItemSelection
        Returns True if done, False if <item> is not in the WorkSession

        :type item: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _XSControl.Handle_XSControl_WorkSession_ResetItemSelection(self, *args)


    def ItemSelection(self, *args):
        """
        ItemSelection(Handle_XSControl_WorkSession self, Handle_Standard_Transient item) -> Handle_IFSelect_Selection

        Returns the Selection of a Dispatch or a GeneralModifier.
        Returns a Null Handle if none is defined or <item> not good type

        :type item: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.IFSelect.Handle_IFSelect_Selection

        """
        return _XSControl.Handle_XSControl_WorkSession_ItemSelection(self, *args)


    def SignCounter(self, *args):
        """
        SignCounter(Handle_XSControl_WorkSession self, Standard_Integer const id) -> Handle_IFSelect_SignCounter

        Returns a SignCounter from its ident in the Session
        Null result if <id> is not suitable for a SignCounter
        (undefined, or defined for another kind of variable)

        :type id: int
        :rtype: OCC.wrapper.IFSelect.Handle_IFSelect_SignCounter

        """
        return _XSControl.Handle_XSControl_WorkSession_SignCounter(self, *args)


    def ComputeCounter(self, *args):
        """
        ComputeCounter(Handle_XSControl_WorkSession self, Handle_IFSelect_SignCounter counter, Standard_Boolean const forced) -> Standard_Boolean

        Computes the content of a SignCounter when it is defined with
        a Selection, then returns True
        Returns False if the SignCounter is not defined with a
        Selection, or if its Selection Mode is inhibited
        <forced> to work around optimisations

        :type counter: OCC.wrapper.IFSelect.Handle_IFSelect_SignCounter
        :type forced: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _XSControl.Handle_XSControl_WorkSession_ComputeCounter(self, *args)


    def ComputeCounterFromList(self, *args):
        """
        ComputeCounterFromList(Handle_XSControl_WorkSession self, Handle_IFSelect_SignCounter counter, Handle_TColStd_HSequenceOfTransient list, Standard_Boolean const clear) -> Standard_Boolean

        Computes the content of a SignCounter from an input list
        If <list> is Null, uses internal definition of the Counter :
        a Selection, else the whole Model (recomputation forced)
        If <clear> is True (D), starts from scratch
        Else, cumulates computations

        :type counter: OCC.wrapper.IFSelect.Handle_IFSelect_SignCounter
        :type list: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfTransient
        :type clear: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _XSControl.Handle_XSControl_WorkSession_ComputeCounterFromList(self, *args)


    def AppliedDispatches(self, *args):
        """
        AppliedDispatches(Handle_XSControl_WorkSession self) -> Handle_TColStd_HSequenceOfInteger

        Returns the ordered list of dispatches stored by the ShareOut

        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfInteger

        """
        return _XSControl.Handle_XSControl_WorkSession_AppliedDispatches(self, *args)


    def ClearShareOut(self, *args):
        """
        ClearShareOut(Handle_XSControl_WorkSession self, Standard_Boolean const onlydisp)

        Clears the list of Dispatches recorded by the ShareOut
        if <only> disp is True, tha's all. Else, clears also the lists
        of Modifiers recorded by the ShareOut

        :type onlydisp: bool

        """
        return _XSControl.Handle_XSControl_WorkSession_ClearShareOut(self, *args)


    def Dispatch(self, *args):
        """
        Dispatch(Handle_XSControl_WorkSession self, Standard_Integer const id) -> Handle_IFSelect_Dispatch

        Returns a Dispatch, given its Ident in the Session
        Null result if <id> is not suitable for a Dispatch
        (undefined, or defined for another kind of variable)

        :type id: int
        :rtype: OCC.wrapper.IFSelect.Handle_IFSelect_Dispatch

        """
        return _XSControl.Handle_XSControl_WorkSession_Dispatch(self, *args)


    def DispatchRank(self, *args):
        """
        DispatchRank(Handle_XSControl_WorkSession self, Handle_IFSelect_Dispatch disp) -> Standard_Integer

        Returns the rank of a Dispatch in the ShareOut, or 0 if <disp>
        is not in the ShareOut or not in the WorkSession

        :type disp: OCC.wrapper.IFSelect.Handle_IFSelect_Dispatch
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _XSControl.Handle_XSControl_WorkSession_DispatchRank(self, *args)


    def ModelCopier(self, *args):
        """
        Gives access to the complete ModelCopier

        :rtype: OCC.wrapper.IFSelect.Handle_IFSelect_ModelCopier

        """
        res = _XSControl.Handle_XSControl_WorkSession_ModelCopier(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetModelCopier(self, *args):
        """
        SetModelCopier(Handle_XSControl_WorkSession self, Handle_IFSelect_ModelCopier copier)

        Sets a new ModelCopier. Fills Items which its content

        :type copier: OCC.wrapper.IFSelect.Handle_IFSelect_ModelCopier

        """
        return _XSControl.Handle_XSControl_WorkSession_SetModelCopier(self, *args)


    def NbFinalModifiers(self, *args):
        """
        NbFinalModifiers(Handle_XSControl_WorkSession self, Standard_Boolean const formodel) -> Standard_Integer

        Returns the count of Modifiers applied to final sending
        Model Modifiers if <formodel> is True, File Modifiers else
        (i.e. Modifiers which apply once the Models have been filled)

        :type formodel: bool
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _XSControl.Handle_XSControl_WorkSession_NbFinalModifiers(self, *args)


    def FinalModifierIdents(self, *args):
        """
        FinalModifierIdents(Handle_XSControl_WorkSession self, Standard_Boolean const formodel) -> Handle_TColStd_HSequenceOfInteger

        Fills a Sequence with a list of Idents, those attached to
        the Modifiers applied to final sending.
        Model Modifiers if <formodel> is True, File Modifiers else
        This list is given in the order in which they will be applied
        (which takes into account the Changes to Modifier Ranks)

        :type formodel: bool
        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfInteger

        """
        return _XSControl.Handle_XSControl_WorkSession_FinalModifierIdents(self, *args)


    def GeneralModifier(self, *args):
        """
        GeneralModifier(Handle_XSControl_WorkSession self, Standard_Integer const id) -> Handle_IFSelect_GeneralModifier

        Returns a Modifier, given its Ident in the Session
        Null result if <id> is not suitable for a Modifier
        (undefined, or defined for another kind of variable)

        :type id: int
        :rtype: OCC.wrapper.IFSelect.Handle_IFSelect_GeneralModifier

        """
        return _XSControl.Handle_XSControl_WorkSession_GeneralModifier(self, *args)


    def ModelModifier(self, *args):
        """
        ModelModifier(Handle_XSControl_WorkSession self, Standard_Integer const id) -> Handle_IFSelect_Modifier

        Returns a Model Modifier, given its Ident in the Session,
        i.e. typed as a Modifier (not simply a GeneralModifier)
        Null result if <id> is not suitable for a Modifier
        (undefined, or defined for another kind of variable)

        :type id: int
        :rtype: OCC.wrapper.IFSelect.Handle_IFSelect_Modifier

        """
        return _XSControl.Handle_XSControl_WorkSession_ModelModifier(self, *args)


    def ModifierRank(self, *args):
        """
        ModifierRank(Handle_XSControl_WorkSession self, Handle_IFSelect_GeneralModifier item) -> Standard_Integer

        Returns the Rank of a Modifier given its Ident. Model or File
        Modifier according its type (ModelModifier or not)
        Remember that Modifiers are applied sequencially following
        their Rank : first Model Modifiers then File Modifiers
        Rank is given by rank of call to AddItem and can be
        changed by ChangeModifierRank

        :type item: OCC.wrapper.IFSelect.Handle_IFSelect_GeneralModifier
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _XSControl.Handle_XSControl_WorkSession_ModifierRank(self, *args)


    def ChangeModifierRank(self, *args):
        """
        ChangeModifierRank(Handle_XSControl_WorkSession self, Standard_Boolean const formodel, Standard_Integer const before, Standard_Integer const after) -> Standard_Boolean

        Changes the Rank of a Modifier in the Session :
        Model Modifiers if <formodel> is True, File Modifiers else
        the Modifier n0 <before> is put to n0 <after>
        Return True if Done, False if <before> or <after> out of range

        :type formodel: bool
        :type before: int
        :type after: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _XSControl.Handle_XSControl_WorkSession_ChangeModifierRank(self, *args)


    def ClearFinalModifiers(self, *args):
        """
        ClearFinalModifiers(Handle_XSControl_WorkSession self)

        Removes all the Modifiers active in the ModelCopier : they
        become inactive and they are removed from the Session


        """
        return _XSControl.Handle_XSControl_WorkSession_ClearFinalModifiers(self, *args)


    def SetAppliedModifier(self, *args):
        """
        SetAppliedModifier(Handle_XSControl_WorkSession self, Handle_IFSelect_GeneralModifier modif, Handle_Standard_Transient item) -> Standard_Boolean

        Sets a GeneralModifier to be applied to an item :
        - item = ShareOut : applies for final sending (all dispatches)
        - item is a Dispatch : applies for this dispatch only
        Returns True if done, False if <modif> or <item> not in <me>

        :type modif: OCC.wrapper.IFSelect.Handle_IFSelect_GeneralModifier
        :type item: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _XSControl.Handle_XSControl_WorkSession_SetAppliedModifier(self, *args)


    def ResetAppliedModifier(self, *args):
        """
        ResetAppliedModifier(Handle_XSControl_WorkSession self, Handle_IFSelect_GeneralModifier modif) -> Standard_Boolean

        Resets a GeneralModifier to be applied
        Returns True if done, False if <modif> was not applied

        :type modif: OCC.wrapper.IFSelect.Handle_IFSelect_GeneralModifier
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _XSControl.Handle_XSControl_WorkSession_ResetAppliedModifier(self, *args)


    def UsesAppliedModifier(self, *args):
        """
        UsesAppliedModifier(Handle_XSControl_WorkSession self, Handle_IFSelect_GeneralModifier modif) -> Handle_Standard_Transient

        Returns the item on which a GeneralModifier is applied :
        the ShareOut, or a given Dispatch
        Returns a Null Handle if <modif> is not applied

        :type modif: OCC.wrapper.IFSelect.Handle_IFSelect_GeneralModifier
        :rtype: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _XSControl.Handle_XSControl_WorkSession_UsesAppliedModifier(self, *args)


    def Transformer(self, *args):
        """
        Transformer(Handle_XSControl_WorkSession self, Standard_Integer const id) -> Handle_IFSelect_Transformer

        Returns a Transformer, given its Ident in the Session
        Null result if <id> is not suitable for a Transformer
        (undefined, or defined for another kind of variable)

        :type id: int
        :rtype: OCC.wrapper.IFSelect.Handle_IFSelect_Transformer

        """
        return _XSControl.Handle_XSControl_WorkSession_Transformer(self, *args)


    def RunTransformer(self, *args):
        """
        RunTransformer(Handle_XSControl_WorkSession self, Handle_IFSelect_Transformer transf) -> Standard_Integer

        Runs a Transformer on starting Model, which can then be edited
        or replaced by a new one. The Protocol can also be changed.
        Fills LastRunCheckList

        Returned status is 0 if nothing done (<transf> or model
        undefined), positive if OK, negative else :
        0  : Nothing done
        1  : OK, edition on the spot with no change to the graph
        of dependances (purely local)
        2  : OK, model edited on the spot (graph recomputed, may
        have changed), protocol unchanged
        3  : OK, new model produced, same protocol
        4  : OK, model edited on the spot (graph recomputed),
        but protocol has changed
        5  : OK, new model produced, protocol has changed
        -1 : Error on the spot (slight changes), data may be corrupted
        (remark : corruption should not be profound)
        -2 : Error on edition the spot, data may be corrupted
        (checking them is recommanded)
        -3 : Error with a new data set, transformation ignored
        -4 : OK as 4, but graph of dependances count not be recomputed
        (the former one is kept) : check the protocol

        :type transf: OCC.wrapper.IFSelect.Handle_IFSelect_Transformer
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _XSControl.Handle_XSControl_WorkSession_RunTransformer(self, *args)


    def RunModifier(self, *args):
        """
        RunModifier(Handle_XSControl_WorkSession self, Handle_IFSelect_Modifier modif, Standard_Boolean const copy) -> Standard_Integer

        Runs a Modifier on Starting Model. It can modify entities, or
        add new ones. But the Model or the Protocol is unchanged.
        The Modifier is applied on each entity of the Model. See also
        RunModifierSelected
        Fills LastRunCheckList

        <copy> : if True, a new data set is produced which brings
        the modifications (Model + its Entities)
        if False, data are modified on the spot

        It works through a TransformStandard defined with <modif>
        Returned status as RunTransformer : 0 nothing done, >0 OK,
        <0 problem, but only between -3 and 3 (protocol unchanged)
        Remark : <copy> True will give <effect> = 3 or -3

        :type modif: OCC.wrapper.IFSelect.Handle_IFSelect_Modifier
        :type copy: bool
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _XSControl.Handle_XSControl_WorkSession_RunModifier(self, *args)


    def RunModifierSelected(self, *args):
        """
        RunModifierSelected(Handle_XSControl_WorkSession self, Handle_IFSelect_Modifier modif, Handle_IFSelect_Selection sel, Standard_Boolean const copy) -> Standard_Integer

        Acts as RunModifier, but the Modifier is applied on the list
        determined by a Selection, rather than on the whole Model
        If the selection is a null handle, the whole model is taken

        :type modif: OCC.wrapper.IFSelect.Handle_IFSelect_Modifier
        :type sel: OCC.wrapper.IFSelect.Handle_IFSelect_Selection
        :type copy: bool
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _XSControl.Handle_XSControl_WorkSession_RunModifierSelected(self, *args)


    def NewTransformStandard(self, *args):
        """
        NewTransformStandard(Handle_XSControl_WorkSession self, Standard_Boolean const copy, Standard_CString const name) -> Handle_IFSelect_Transformer

        Creates and returns a TransformStandard, empty, with its
        Copy Option (True = Copy, False = On the Spot) and an
        optional name.
        To a TransformStandard, the method SetAppliedModifier applies

        :type copy: bool
        :type name: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.IFSelect.Handle_IFSelect_Transformer

        """
        return _XSControl.Handle_XSControl_WorkSession_NewTransformStandard(self, *args)


    def SetModelContent(self, *args):
        """
        SetModelContent(Handle_XSControl_WorkSession self, Handle_IFSelect_Selection sel, Standard_Boolean const keep) -> Standard_Boolean

        Defines a new content from the former one
        If <keep> is True, it is given by entities selected by
        Selection <sel>  (and all shared entities)
        Else, it is given by all the former content but entities
        selected by the Selection <sel> (and properly shared ones)
        Returns True if done. Returns False if the selected list
        (from <sel>) is empty, hence nothing is done

        :type sel: OCC.wrapper.IFSelect.Handle_IFSelect_Selection
        :type keep: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _XSControl.Handle_XSControl_WorkSession_SetModelContent(self, *args)


    def FilePrefix(self, *args):
        """
        FilePrefix(Handle_XSControl_WorkSession self) -> Handle_TCollection_HAsciiString

        Returns the defined File Prefix. Null Handle if not defined

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _XSControl.Handle_XSControl_WorkSession_FilePrefix(self, *args)


    def DefaultFileRoot(self, *args):
        """
        DefaultFileRoot(Handle_XSControl_WorkSession self) -> Handle_TCollection_HAsciiString

        Returns the defined Default File Root. It is used for
        Dispatches which have no specific root attached.
        Null Handle if not defined

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _XSControl.Handle_XSControl_WorkSession_DefaultFileRoot(self, *args)


    def FileExtension(self, *args):
        """
        FileExtension(Handle_XSControl_WorkSession self) -> Handle_TCollection_HAsciiString

        Returns the defined File Extension. Null Handle if not defined

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _XSControl.Handle_XSControl_WorkSession_FileExtension(self, *args)


    def FileRoot(self, *args):
        """
        FileRoot(Handle_XSControl_WorkSession self, Handle_IFSelect_Dispatch disp) -> Handle_TCollection_HAsciiString

        Returns the File Root defined for a Dispatch. Null if no
        Root Name is defined for it (hence, no File will be produced)

        :type disp: OCC.wrapper.IFSelect.Handle_IFSelect_Dispatch
        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _XSControl.Handle_XSControl_WorkSession_FileRoot(self, *args)


    def SetFilePrefix(self, *args):
        """
        SetFilePrefix(Handle_XSControl_WorkSession self, Standard_CString const name)

        Defines a File Prefix

        :type name: OCC.wrapper.Standard.Standard_CString

        """
        return _XSControl.Handle_XSControl_WorkSession_SetFilePrefix(self, *args)


    def SetDefaultFileRoot(self, *args):
        """
        SetDefaultFileRoot(Handle_XSControl_WorkSession self, Standard_CString const name) -> Standard_Boolean

        Defines a Default File Root Name. Clears it is <name> = ""
        Returns True if OK, False if <name> already set for a Dispatch

        :type name: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _XSControl.Handle_XSControl_WorkSession_SetDefaultFileRoot(self, *args)


    def SetFileExtension(self, *args):
        """
        SetFileExtension(Handle_XSControl_WorkSession self, Standard_CString const name)

        Defines a File Extension

        :type name: OCC.wrapper.Standard.Standard_CString

        """
        return _XSControl.Handle_XSControl_WorkSession_SetFileExtension(self, *args)


    def SetFileRoot(self, *args):
        """
        SetFileRoot(Handle_XSControl_WorkSession self, Handle_IFSelect_Dispatch disp, Standard_CString const name) -> Standard_Boolean

        Defines a Root for a Dispatch
        If <name> is empty, clears Root Name
        This has as effect to inhibit the production of File by <disp>
        Returns False if <disp> is not in the WorkSession or if a
        root name is already defined for it

        :type disp: OCC.wrapper.IFSelect.Handle_IFSelect_Dispatch
        :type name: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _XSControl.Handle_XSControl_WorkSession_SetFileRoot(self, *args)


    def GiveFileRoot(self, *args):
        """
        GiveFileRoot(Handle_XSControl_WorkSession self, Standard_CString const file) -> Standard_CString

        Extracts File Root Name from a given complete file name
        (uses OSD_Path)

        :type file: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _XSControl.Handle_XSControl_WorkSession_GiveFileRoot(self, *args)


    def GiveFileComplete(self, *args):
        """
        GiveFileComplete(Handle_XSControl_WorkSession self, Standard_CString const file) -> Standard_CString

        Completes a file name as required, with Prefix and Extension
        (if defined; for a non-defined item, completes nothing)

        :type file: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _XSControl.Handle_XSControl_WorkSession_GiveFileComplete(self, *args)


    def ClearFile(self, *args):
        """
        ClearFile(Handle_XSControl_WorkSession self)

        Erases all stored data from the File Evaluation
        (i.e. ALL former naming informations are lost)


        """
        return _XSControl.Handle_XSControl_WorkSession_ClearFile(self, *args)


    def EvaluateFile(self, *args):
        """
        EvaluateFile(Handle_XSControl_WorkSession self)

        Performs and stores a File Evaluation. The Results are a List
        of produced Models and a List of names (Strings), in parallel
        Fills LastRunCheckList


        """
        return _XSControl.Handle_XSControl_WorkSession_EvaluateFile(self, *args)


    def NbFiles(self, *args):
        """
        NbFiles(Handle_XSControl_WorkSession self) -> Standard_Integer

        Returns the count of produced Models

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _XSControl.Handle_XSControl_WorkSession_NbFiles(self, *args)


    def FileModel(self, *args):
        """
        FileModel(Handle_XSControl_WorkSession self, Standard_Integer const num) -> Handle_Interface_InterfaceModel

        Returns a Model, given its rank in the Evaluation List

        :type num: int
        :rtype: OCC.wrapper.Interface.Handle_Interface_InterfaceModel

        """
        return _XSControl.Handle_XSControl_WorkSession_FileModel(self, *args)


    def FileName(self, *args):
        """
        FileName(Handle_XSControl_WorkSession self, Standard_Integer const num) -> TCollection_AsciiString

        Returns the name of a file corresponding to a produced Model,
        given its rank in the Evaluation List

        :type num: int
        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _XSControl.Handle_XSControl_WorkSession_FileName(self, *args)


    def BeginSentFiles(self, *args):
        """
        BeginSentFiles(Handle_XSControl_WorkSession self, Standard_Boolean const record)

        Commands file sending to clear the list of already sent files,
        commands to record a new one if <record> is True
        This list is managed by the ModelCopier when SendSplit is called
        It allows a global exploitation of the set of sent files

        :type record: bool

        """
        return _XSControl.Handle_XSControl_WorkSession_BeginSentFiles(self, *args)


    def SentFiles(self, *args):
        """
        SentFiles(Handle_XSControl_WorkSession self) -> Handle_TColStd_HSequenceOfHAsciiString

        Returns the list of recorded sent files, or a Null Handle is
        recording has not been enabled

        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfHAsciiString

        """
        return _XSControl.Handle_XSControl_WorkSession_SentFiles(self, *args)


    def SendSplit(self, *args):
        """
        SendSplit(Handle_XSControl_WorkSession self) -> Standard_Boolean

        Performs creation of derived files from the input Model
        Takes its data (sub-models and names), from result EvaluateFile
        if active, else by dynamic Evaluation (not stored)
        After SendSplit, result of EvaluateFile is Cleared
        Fills LastRunCheckList

        Works with the WorkLibrary which acts on specific type of Model
        and can work with File Modifiers (managed by the Model Copier)
        and a ModelCopier, which can work with Model Modifiers
        Returns False if, either WorkLibrary has failed on at least
        one sub-file, or the Work Session is badly conditionned
        (no Model defined, or FileNaming not in phase with ShareOut)

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _XSControl.Handle_XSControl_WorkSession_SendSplit(self, *args)


    def EvalSplit(self, *args):
        """
        EvalSplit(Handle_XSControl_WorkSession self) -> Handle_IFSelect_PacketList

        Returns an Evaluation of the whole ShareOut definition : i.e.
        how the entities of the starting model are forecast to be sent
        to various files :  list of packets according the dispatches,
        effective lists of roots for each packet (which determine the
        content of the corresponding file); plus evaluation of which
        entities are : forgotten (sent into no file), duplicated (sent
        into more than one file), sent into a given file.
        See the class PacketList for more details.

        :rtype: OCC.wrapper.IFSelect.Handle_IFSelect_PacketList

        """
        return _XSControl.Handle_XSControl_WorkSession_EvalSplit(self, *args)


    def SentList(self, *args):
        """
        SentList(Handle_XSControl_WorkSession self, Standard_Integer const count=-1) -> Interface_EntityIterator

        Returns the list of Entities sent in files, accourding the
        count of files each one has been sent (these counts are reset
        by SetModel or SetRemaining(Forget) ) stored in Graph Status
        <count> = -1 (default) is for ENtities sent at least once
        <count> = 0 is for the Remaining List (entities not yet sent)
        <count> = 1 is for entities sent in one and only one file
        (the ideal case)
        Remaining Data are computed on each Sending/Copying output
        files (see methods EvaluateFile and SendSplit)
        Graph Status is 0 for Remaining Entity, <count> for Sent into
        <count> files
        This status is set to 0 (not yet sent) for all by SetModel
        and by SetRemaining(mode=Forget,Display)

        :type count: int
        :rtype: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _XSControl.Handle_XSControl_WorkSession_SentList(self, *args)


    def MaxSendingCount(self, *args):
        """
        MaxSendingCount(Handle_XSControl_WorkSession self) -> Standard_Integer

        Returns the greater count of different files in which any of
        the starting entities could be sent.
        Before any file output, this count is 0.
        Ideal count is 1. More than 1 means that duplications occur.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _XSControl.Handle_XSControl_WorkSession_MaxSendingCount(self, *args)


    def SetRemaining(self, *args):
        """
        SetRemaining(Handle_XSControl_WorkSession self, IFSelect_RemainMode const mode) -> Standard_Boolean

        Processes Remaining data (after having sent files), mode :
        Forget  : forget remaining info (i.e. clear all "Sent" status)
        Compute : compute and keep remaining (does nothing if :
        remaining is empty or if no files has been sent)
        Display : display entities recorded as remaining
        Undo    : restore former state of data (after Remaining(1) )
        Returns True if OK, False else (i.e. mode = 2 and Remaining
        List is either empty or takes all the entities, or mode = 3
        and no former computation of remaining data was done)

        :type mode: OCC.wrapper.IFSelect.IFSelect_RemainMode
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _XSControl.Handle_XSControl_WorkSession_SetRemaining(self, *args)


    def SendAll(self, *args):
        """
        SendAll(Handle_XSControl_WorkSession self, Standard_CString const filename, Standard_Boolean const computegraph) -> IFSelect_ReturnStatus

        Sends the starting Model into one file, without splitting,
        managing remaining data or anything else.
        <computegraph> true commands the Graph to be recomputed before
        sending : required when a Model is filled in several steps

        The Model and File Modifiers recorded to be applied on sending
        files are.
        Returns a status of execution :
        Done if OK,
        Void if no data available,
        Error if errors occured (work library is not defined), errors
        during translation
        Fail if exception during translation is raised
        Stop if no disk space or disk, file is write protected
        Fills LastRunCheckList

        :type filename: OCC.wrapper.Standard.Standard_CString
        :type computegraph: bool
        :rtype: OCC.wrapper.IFSelect.IFSelect_ReturnStatus

        """
        return _XSControl.Handle_XSControl_WorkSession_SendAll(self, *args)


    def SendSelected(self, *args):
        """
        SendSelected(Handle_XSControl_WorkSession self, Standard_CString const filename, Handle_IFSelect_Selection sel, Standard_Boolean const computegraph) -> IFSelect_ReturnStatus

        Sends a part of the starting Model into one file, without
        splitting. But remaining data are managed.
        <computegraph> true commands the Graph to be recomputed before
        sending : required when a Model is filled in several steps

        The Model and File Modifiers recorded to be applied on sending
        files are.
        Returns a status : Done if OK,  Fail if error during send,
        Error : WorkLibrary not defined, Void : selection list empty
        Fills LastRunCheckList

        :type filename: OCC.wrapper.Standard.Standard_CString
        :type sel: OCC.wrapper.IFSelect.Handle_IFSelect_Selection
        :type computegraph: bool
        :rtype: OCC.wrapper.IFSelect.IFSelect_ReturnStatus

        """
        return _XSControl.Handle_XSControl_WorkSession_SendSelected(self, *args)


    def WriteFile(self, *args):
        """
        WriteFile(Handle_XSControl_WorkSession self, Standard_CString const filename) -> IFSelect_ReturnStatus
        WriteFile(Handle_XSControl_WorkSession self, Standard_CString const filename, Handle_IFSelect_Selection sel) -> IFSelect_ReturnStatus

        Writes a sub-part of the current Interface Model to a File,
        as defined by a Selection <sel>, recomputes the Graph, and
        returns a write status which can be :
        Done OK, Fail file could not be written, Error no norm is selected
        Remark  : It is a simple, one-file writing, other operations are
        available (such as splitting ...) which calls SendSelected

        :type filename: OCC.wrapper.Standard.Standard_CString
        :type sel: OCC.wrapper.IFSelect.Handle_IFSelect_Selection
        :rtype: OCC.wrapper.IFSelect.IFSelect_ReturnStatus

        """
        return _XSControl.Handle_XSControl_WorkSession_WriteFile(self, *args)


    def NbSources(self, *args):
        """
        NbSources(Handle_XSControl_WorkSession self, Handle_IFSelect_Selection sel) -> Standard_Integer

        Returns the count of Input Selections known for a Selection,
        or 0 if <sel> not in the WorkSession. This count is one for a
        SelectDeduct / SelectExtract kind, two for SelectControl kind,
        variable for a SelectCombine (Union/Intersection), zero else

        :type sel: OCC.wrapper.IFSelect.Handle_IFSelect_Selection
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _XSControl.Handle_XSControl_WorkSession_NbSources(self, *args)


    def Source(self, *args):
        """
        Source(Handle_XSControl_WorkSession self, Handle_IFSelect_Selection sel, Standard_Integer const num=1) -> Handle_IFSelect_Selection

        Returns the <num>th Input Selection of a Selection
        (see NbSources).
        Returns a Null Handle if <sel> is not in the WorkSession or if
        <num> is out of the range <1-NbSources>
        To obtain more details, see the method Sources

        :type sel: OCC.wrapper.IFSelect.Handle_IFSelect_Selection
        :type num: int
        :rtype: OCC.wrapper.IFSelect.Handle_IFSelect_Selection

        """
        return _XSControl.Handle_XSControl_WorkSession_Source(self, *args)


    def IsReversedSelectExtract(self, *args):
        """
        IsReversedSelectExtract(Handle_XSControl_WorkSession self, Handle_IFSelect_Selection sel) -> Standard_Boolean

        Returns True if <sel> a Reversed SelectExtract, False else

        :type sel: OCC.wrapper.IFSelect.Handle_IFSelect_Selection
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _XSControl.Handle_XSControl_WorkSession_IsReversedSelectExtract(self, *args)


    def ToggleSelectExtract(self, *args):
        """
        ToggleSelectExtract(Handle_XSControl_WorkSession self, Handle_IFSelect_Selection sel) -> Standard_Boolean

        Toggles the Sense (Direct <-> Reversed) of a SelectExtract
        Returns True if Done, False if <sel> is not a SelectExtract or
        is not in the WorkSession

        :type sel: OCC.wrapper.IFSelect.Handle_IFSelect_Selection
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _XSControl.Handle_XSControl_WorkSession_ToggleSelectExtract(self, *args)


    def SetInputSelection(self, *args):
        """
        SetInputSelection(Handle_XSControl_WorkSession self, Handle_IFSelect_Selection sel, Handle_IFSelect_Selection input) -> Standard_Boolean

        Sets an Input Selection (as <input>) to a SelectExtract or
        a SelectDeduct (as <sel>).
        Returns True if Done, False if <sel> is neither a
        SelectExtract nor a SelectDeduct, or not in the WorkSession

        :type sel: OCC.wrapper.IFSelect.Handle_IFSelect_Selection
        :type input: OCC.wrapper.IFSelect.Handle_IFSelect_Selection
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _XSControl.Handle_XSControl_WorkSession_SetInputSelection(self, *args)


    def SetControl(self, *args):
        """
        SetControl(Handle_XSControl_WorkSession self, Handle_IFSelect_Selection sel, Handle_IFSelect_Selection sc, Standard_Boolean const formain) -> Standard_Boolean

        Sets an Input Selection, Main if <formain> is True, Second else
        (as <sc>) to a SelectControl (as <sel>). Returns True if Done,
        False if <sel> is not a SelectControl, or <sc> or <sel> is not
        in the WorkSession

        :type sel: OCC.wrapper.IFSelect.Handle_IFSelect_Selection
        :type sc: OCC.wrapper.IFSelect.Handle_IFSelect_Selection
        :type formain: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _XSControl.Handle_XSControl_WorkSession_SetControl(self, *args)


    def CombineAdd(self, *args):
        """
        CombineAdd(Handle_XSControl_WorkSession self, Handle_IFSelect_Selection selcomb, Handle_IFSelect_Selection seladd, Standard_Integer const atnum=0) -> Standard_Integer

        Adds an input selection to a SelectCombine (Union or Inters.).
        Returns new count of inputs for this SelectCombine if Done or
        0 if <sel> is not kind of SelectCombine, or if <seladd> or
        <sel> is not in the WorkSession
        By default, adding is done at the end of the list
        Else, it is an insertion to rank <atnum> (usefull for Un-ReDo)

        :type selcomb: OCC.wrapper.IFSelect.Handle_IFSelect_Selection
        :type seladd: OCC.wrapper.IFSelect.Handle_IFSelect_Selection
        :type atnum: int
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _XSControl.Handle_XSControl_WorkSession_CombineAdd(self, *args)


    def CombineRemove(self, *args):
        """
        CombineRemove(Handle_XSControl_WorkSession self, Handle_IFSelect_Selection selcomb, Handle_IFSelect_Selection selrem) -> Standard_Boolean

        Removes an input selection from a SelectCombine (Union or
        Intersection). Returns True if done, False if <selcomb> is not
        kind of SelectCombine or <selrem> is not source of <selcomb>

        :type selcomb: OCC.wrapper.IFSelect.Handle_IFSelect_Selection
        :type selrem: OCC.wrapper.IFSelect.Handle_IFSelect_Selection
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _XSControl.Handle_XSControl_WorkSession_CombineRemove(self, *args)


    def NewSelectPointed(self, *args):
        """
        NewSelectPointed(Handle_XSControl_WorkSession self, Handle_TColStd_HSequenceOfTransient list, Standard_CString const name) -> Handle_IFSelect_Selection

        Creates a new Selection, of type SelectPointed, its content
        starts with <list>. A name must be given (can be empty)

        :type list: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfTransient
        :type name: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.IFSelect.Handle_IFSelect_Selection

        """
        return _XSControl.Handle_XSControl_WorkSession_NewSelectPointed(self, *args)


    def SetSelectPointed(self, *args):
        """
        SetSelectPointed(Handle_XSControl_WorkSession self, Handle_IFSelect_Selection sel, Handle_TColStd_HSequenceOfTransient list, Standard_Integer const mode) -> Standard_Boolean

        Changes the content of a Selection of type SelectPointed
        According <mode> : 0  set <list> as new content (clear former)
        1  : adds <list> to actual content
        -1  : removes <list> from actual content
        Returns True if done, False if <sel> is not a SelectPointed

        :type sel: OCC.wrapper.IFSelect.Handle_IFSelect_Selection
        :type list: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfTransient
        :type mode: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _XSControl.Handle_XSControl_WorkSession_SetSelectPointed(self, *args)


    def GiveSelection(self, *args):
        """
        GiveSelection(Handle_XSControl_WorkSession self, Standard_CString const selname) -> Handle_IFSelect_Selection

        Returns a Selection from a Name :
        - the name of a Selection : this Selection
        - the name of a Signature + criteria between (..) : a new
        Selection from this Signature
        - an entity or a list of entities : a new SelectPointed
        Else, returns a Null Handle

        :type selname: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.IFSelect.Handle_IFSelect_Selection

        """
        return _XSControl.Handle_XSControl_WorkSession_GiveSelection(self, *args)


    def GiveList(self, *args):
        """
        GiveList(Handle_XSControl_WorkSession self, Handle_Standard_Transient obj) -> Handle_TColStd_HSequenceOfTransient
        GiveList(Handle_XSControl_WorkSession self, Standard_CString const first, Standard_CString const second) -> Handle_TColStd_HSequenceOfTransient

        Computes a List of entities from two alphanums,
        first and second, as follows :
        if <first> is a Number or Label of an entity : this entity
        if <first> is a list of Numbers/Labels : the list of entities
        if <first> is the name of a Selection in <WS>, and <second>
        not defined, the standard result of this Selection
        else, let's consider "first second" : this whole phrase is
        splitted by blanks, as follows (RECURSIVE CALL) :
        - the leftest term is the final selection
        - the other terms define the result of the selection
        - and so on (the "leftest minus one" is a selection, of which
        the input is given by the remaining ...)

        :type first: OCC.wrapper.Standard.Standard_CString
        :type second: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfTransient

        """
        return _XSControl.Handle_XSControl_WorkSession_GiveList(self, *args)


    def GiveListFromList(self, *args):
        """
        GiveListFromList(Handle_XSControl_WorkSession self, Standard_CString const selname, Handle_Standard_Transient ent) -> Handle_TColStd_HSequenceOfTransient

        Computes a List of entities from the model as follows
        <first> beeing a Selection or a combination of Selections,
        <ent> beeing an entity or a list
        of entities (as a HSequenceOfTransient) :
        the standard result of this selection applied to this list
        if <ent> is Null, the standard definition of the selection is
        used (which contains a default input selection)
        if <selname> is erroneous, a null handle is returned

        REMARK : selname is processed as <first second> of preceeding
        GiveList

        :type selname: OCC.wrapper.Standard.Standard_CString
        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfTransient

        """
        return _XSControl.Handle_XSControl_WorkSession_GiveListFromList(self, *args)


    def GiveListCombined(self, *args):
        """
        GiveListCombined(Handle_XSControl_WorkSession self, Handle_TColStd_HSequenceOfTransient l1, Handle_TColStd_HSequenceOfTransient l2, Standard_Integer const mode) -> Handle_TColStd_HSequenceOfTransient

        Combines two lists and returns the result, according to mode :
        <mode> < 0 : entities in <l1> AND NOT in <l2>
        <mode> = 0 : entities in <l1> AND in <l2>
        <mode> > 0 : entities in <l1> OR  in <l2>

        :type l1: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfTransient
        :type l2: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfTransient
        :type mode: int
        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfTransient

        """
        return _XSControl.Handle_XSControl_WorkSession_GiveListCombined(self, *args)


    def QueryCheckList(self, *args):
        """
        QueryCheckList(Handle_XSControl_WorkSession self, Interface_CheckIterator chl)

        Loads data from a check iterator to query status on it

        :type chl: OCC.wrapper.Interface.Interface_CheckIterator

        """
        return _XSControl.Handle_XSControl_WorkSession_QueryCheckList(self, *args)


    def QueryCheckStatus(self, *args):
        """
        QueryCheckStatus(Handle_XSControl_WorkSession self, Handle_Standard_Transient ent) -> Standard_Integer

        Determines check status for an entity regarding last call to
        QueryCheckList :
        -1 : <ent> unknown in the model, ignored
        0 : no check at all, immediate or inherited thru Graph
        1 : immediate warning (no fail), no inherited check
        2 : immediate fail, no inherited check
        +10 : idem but some inherited warning (no fail)
        +20 : idem but some inherited fail

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _XSControl.Handle_XSControl_WorkSession_QueryCheckStatus(self, *args)


    def QueryParent(self, *args):
        """
        QueryParent(Handle_XSControl_WorkSession self, Handle_Standard_Transient entdad, Handle_Standard_Transient entson) -> Standard_Integer

        Determines if <entdad> is parent of <entson> (in the graph),
        returns : -1 if no; 0 if <entdad> = <entson>
        1 if immediate parent, > 1 if parent, gives count of steps

        :type entdad: OCC.wrapper.Standard.Handle_Standard_Transient
        :type entson: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _XSControl.Handle_XSControl_WorkSession_QueryParent(self, *args)


    def SetParams(self, *args):
        """
        SetParams(Handle_XSControl_WorkSession self, NCollection_Vector< opencascade::handle< Standard_Transient > > const & params, NCollection_Vector< Standard_Integer > const & uselist)

        Sets a list of Parameters, i.e. TypedValue, to be handled
        through an Editor
        The two lists are parallel, if <params> is longer than <uses>,
        surnumeral parameters are for general use

        EditForms are created to handle these parameters (list, edit)
        on the basis of a ParamEditor  xst-params-edit

        A use number dispatches the parameter to a given EditForm
        EditForms are defined as follows
        Name                Use   Means
        xst-params          all   All Parameters (complete list)
        xst-params-general  1     Generals
        xst-params-load     2     LoadFile (no Transfer)
        xst-params-send     3     SendFile (Write, no Transfer)
        xst-params-split    4     Split
        xst-param-read      5     Transfer on Reading
        xst-param-write     6     Transfer on Writing

        :type params: OCC.wrapper.IFSelect.NCollection_Vector_Handle_Standard_Transient
        :type uselist: OCC.wrapper.IFSelect.NCollection_Vector_Standard_Integer

        """
        return _XSControl.Handle_XSControl_WorkSession_SetParams(self, *args)


    def TraceStatics(self, *args):
        """
        TraceStatics(Handle_XSControl_WorkSession self, Standard_Integer const use, Standard_Integer const mode=0)

        Traces the Statics attached to a given use number
        If <use> is given positive (normal), the trace is embedded
        with a header and a trailer
        If <use> is negative, just values are printed
        (this allows to make compositions)
        Remark : use number  5 commands use -2 to be traced
        Remark : use numbers 4 and 6 command use -3 to be traced

        :type use: int
        :type mode: int

        """
        return _XSControl.Handle_XSControl_WorkSession_TraceStatics(self, *args)


    def DumpShare(self, *args):
        """
        DumpShare(Handle_XSControl_WorkSession self)

        Dumps contents of the ShareOut (on "cout")


        """
        return _XSControl.Handle_XSControl_WorkSession_DumpShare(self, *args)


    def ListItems(self, *args):
        """
        ListItems(Handle_XSControl_WorkSession self, Standard_CString const label)

        Lists the Labels of all Items of the WorkSession
        If <label> is defined, lists labels which contain it

        :type label: OCC.wrapper.Standard.Standard_CString

        """
        return _XSControl.Handle_XSControl_WorkSession_ListItems(self, *args)


    def ListFinalModifiers(self, *args):
        """
        ListFinalModifiers(Handle_XSControl_WorkSession self, Standard_Boolean const formodel)

        Lists the Modifiers of the session (for each one, displays
        its Label). Listing is done following Ranks (Modifiers are
        invoked following their ranks)
        Model Modifiers if <formodel> is True, File Modifiers else

        :type formodel: bool

        """
        return _XSControl.Handle_XSControl_WorkSession_ListFinalModifiers(self, *args)


    def DumpSelection(self, *args):
        """
        DumpSelection(Handle_XSControl_WorkSession self, Handle_IFSelect_Selection sel)

        Lists a Selection and its Sources (see SelectionIterator),
        given its rank in the list

        :type sel: OCC.wrapper.IFSelect.Handle_IFSelect_Selection

        """
        return _XSControl.Handle_XSControl_WorkSession_DumpSelection(self, *args)


    def DumpModel(self, *args):
        """
        DumpModel(Handle_XSControl_WorkSession self, Standard_Integer const level, Handle_Message_Messenger S)

        Lists the content of the Input Model (if there is one)
        According level : 0 -> gives only count of Entities and Roots
        1 -> Lists also Roots;  2 -> Lists all Entities (by TraceType)
        3 -> Performs a call to CheckList (Fails) and lists the result
        4 -> as 3 but all CheckList (Fails + Warnings)
        5,6,7  : as 3 but resp. Count,List,Labels by Fail
        8,9,10 : as 4 but resp. Count,List,Labels by message

        :type level: int
        :type S: OCC.wrapper.Message.Handle_Message_Messenger

        """
        return _XSControl.Handle_XSControl_WorkSession_DumpModel(self, *args)


    def TraceDumpModel(self, *args):
        """
        TraceDumpModel(Handle_XSControl_WorkSession self, Standard_Integer const mode)

        Dumps the current Model (as inherited DumpModel), on currently
        defined Default Trace File (default is standard output)

        :type mode: int

        """
        return _XSControl.Handle_XSControl_WorkSession_TraceDumpModel(self, *args)


    def DumpEntity(self, *args):
        """
        DumpEntity(Handle_XSControl_WorkSession self, Handle_Standard_Transient ent, Standard_Integer const level, Handle_Message_Messenger S)

        Dumps a starting entity according to the current norm.
        To do this, it calls DumpEntity from WorkLibrary.
        <level> is to be interpreted for each norm : see specific
        classes of WorkLibrary for it. Generally, 0 if for very basic
        (only type ...), greater values give more and more details.

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type level: int
        :type S: OCC.wrapper.Message.Handle_Message_Messenger

        """
        return _XSControl.Handle_XSControl_WorkSession_DumpEntity(self, *args)


    def PrintEntityStatus(self, *args):
        """
        PrintEntityStatus(Handle_XSControl_WorkSession self, Handle_Standard_Transient ent, Handle_Message_Messenger S)

        Prints main informations about an entity : its number, type,
        validity (and checks if any), category, shareds and sharings..
        mutable because it can recompute checks as necessary

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type S: OCC.wrapper.Message.Handle_Message_Messenger

        """
        return _XSControl.Handle_XSControl_WorkSession_PrintEntityStatus(self, *args)


    def TraceDumpEntity(self, *args):
        """
        TraceDumpEntity(Handle_XSControl_WorkSession self, Handle_Standard_Transient ent, Standard_Integer const level)

        Dumps an entity from the current Model as inherited DumpEntity
        on currently defined Default Trace File
        (<level> interpreted according to the Norm, see WorkLibrary)

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type level: int

        """
        return _XSControl.Handle_XSControl_WorkSession_TraceDumpEntity(self, *args)


    def PrintCheckList(self, *args):
        """
        PrintCheckList(Handle_XSControl_WorkSession self, Interface_CheckIterator checklist, Standard_Boolean const failsonly, IFSelect_PrintCount const mode)

        Prints a CheckIterator to the current Trace File, controlled
        with the current Model
        complete or fails only, according to <failsonly>
        <mode> defines the mode of printing
        0 : sequential, according entities; else with a CheckCounter
        1 : according messages, count of entities
        2 : id but with list of entities, designated by their numbers
        3 : as 2 but with labels of entities

        :type checklist: OCC.wrapper.Interface.Interface_CheckIterator
        :type failsonly: bool
        :type mode: OCC.wrapper.IFSelect.IFSelect_PrintCount

        """
        return _XSControl.Handle_XSControl_WorkSession_PrintCheckList(self, *args)


    def PrintSignatureList(self, *args):
        """
        PrintSignatureList(Handle_XSControl_WorkSession self, Handle_IFSelect_SignatureList signlist, IFSelect_PrintCount const mode)

        Prints a SignatureList to the current Trace File, controlled
        with the current Model
        <mode> defines the mode of printing (see SignatureList)

        :type signlist: OCC.wrapper.IFSelect.Handle_IFSelect_SignatureList
        :type mode: OCC.wrapper.IFSelect.IFSelect_PrintCount

        """
        return _XSControl.Handle_XSControl_WorkSession_PrintSignatureList(self, *args)


    def EvaluateSelection(self, *args):
        """
        EvaluateSelection(Handle_XSControl_WorkSession self, Handle_IFSelect_Selection sel)

        Displays the list of Entities selected by a Selection (i.e.
        the result of EvalSelection).

        :type sel: OCC.wrapper.IFSelect.Handle_IFSelect_Selection

        """
        return _XSControl.Handle_XSControl_WorkSession_EvaluateSelection(self, *args)


    def EvaluateDispatch(self, *args):
        """
        EvaluateDispatch(Handle_XSControl_WorkSession self, Handle_IFSelect_Dispatch disp, Standard_Integer const mode=0)

        Displays the result of applying a Dispatch on the input Model
        (also shows Remainder if there is)
        <mode> = 0 (default), displays nothing else
        <mode> = 1 : displays also duplicated entities (because of
        this dispatch)
        <mode> = 2 : displays the entities of the starting Model
        which are not taken by this dispatch (forgotten entities)
        <mode> = 3 : displays both duplicated and forgotten entities
        Remark : EvaluateComplete displays these data evaluated for
        for all the dispatches, if there are several

        :type disp: OCC.wrapper.IFSelect.Handle_IFSelect_Dispatch
        :type mode: int

        """
        return _XSControl.Handle_XSControl_WorkSession_EvaluateDispatch(self, *args)


    def EvaluateComplete(self, *args):
        """
        EvaluateComplete(Handle_XSControl_WorkSession self, Standard_Integer const mode=0)

        Displays the effect of applying the ShareOut on the input
        Model.
        <mode> = 0 (default) : displays only roots for each packet,
        <mode> = 1 : displays all entities for each packet, plus
        duplicated entities
        <mode> = 2 : same as <mode> = 1, plus displays forgotten
        entities (which are in no packet at all)

        :type mode: int

        """
        return _XSControl.Handle_XSControl_WorkSession_EvaluateComplete(self, *args)


    def ListEntities(self, *args):
        """
        ListEntities(Handle_XSControl_WorkSession self, Interface_EntityIterator iter, Standard_Integer const mode)

        Internal method which displays an EntityIterator
        <mode> 0 gives short display (only entity numbers)
        1 gives a more complete trace (1 line per Entity)
        (can be used each time a trace has to be output from a list)
        2 gives a form suitable for givelist : (n1,n2,n3...)

        :type iter: OCC.wrapper.Interface.Interface_EntityIterator
        :type mode: int

        """
        return _XSControl.Handle_XSControl_WorkSession_ListEntities(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_XSControl_WorkSession self)

        Memory deallocator for transient classes


        """
        return _XSControl.Handle_XSControl_WorkSession_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_XSControl_WorkSession self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_XSControl_WorkSession self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _XSControl.Handle_XSControl_WorkSession_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_XSControl_WorkSession self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_XSControl_WorkSession self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _XSControl.Handle_XSControl_WorkSession_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_XSControl_WorkSession self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _XSControl.Handle_XSControl_WorkSession_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_XSControl_WorkSession self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _XSControl.Handle_XSControl_WorkSession_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_XSControl_WorkSession self)

        Increments the reference counter of this object


        """
        return _XSControl.Handle_XSControl_WorkSession_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_XSControl_WorkSession self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _XSControl.Handle_XSControl_WorkSession_DecrementRefCounter(self, *args)

Handle_XSControl_WorkSession_swigregister = _XSControl.Handle_XSControl_WorkSession_swigregister
Handle_XSControl_WorkSession_swigregister(Handle_XSControl_WorkSession)

def Handle_XSControl_WorkSession_DownCast(thing):
    return _XSControl.Handle_XSControl_WorkSession_DownCast(thing)
Handle_XSControl_WorkSession_DownCast = _XSControl.Handle_XSControl_WorkSession_DownCast

class XSControl_Reader(object):
    """
    A groundwork to convert a shape to data which complies
    with a particular norm. This data can be that of a whole
    model or that of a specific list of entities in the model.
    You specify the list using a single selection or a
    combination of selections. A selection is an operator which
    computes a list of entities from a list given in input. To
    specify the input, you can use:
    - A predefined selection such as "xst-transferrable-roots"
    - A filter based on a  signature.
    A signature is an operator which returns a string from an
    entity according to its type.
    For example:
    - "xst-type" (CDL)
    - "iges-level"
    - "step-type".
    A filter can be based on a signature by giving a value to
    be matched by the string returned. For example,
    "xst-type(Curve)".
    If no list is specified, the selection computes its list of
    entities from the whole model. To use this class, you have to
    initialize the transfer norm first, as shown in the example below.
    Example:
    Control_Reader reader;
    IFSelect_ReturnStatus status = reader.ReadFile (filename.);
    When using IGESControl_Reader or STEPControl_Reader - as the
    above example shows - the reader initializes the norm directly.
    Note that loading the file only stores the data. It does
    not translate this data. Shapes are accumulated by
    successive transfers. The last shape is cleared by:
    - ClearShapes which allows you to handle a new batch
    - TransferRoots which restarts the list of shapes from scratch.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(XSControl_Reader self) -> XSControl_Reader
        __init__(XSControl_Reader self, Standard_CString const norm) -> XSControl_Reader
        __init__(XSControl_Reader self, Handle_XSControl_WorkSession WS, Standard_Boolean const scratch) -> XSControl_Reader

        Creates a Reader from an already existing Session, with a
        Controller already set
        Virtual destructor

        :type WS: OCC.wrapper.XSControl.Handle_XSControl_WorkSession
        :type scratch: bool

        """
        this = _XSControl.new_XSControl_Reader(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def SetNorm(self, *args):
        """
        SetNorm(XSControl_Reader self, Standard_CString const norm) -> Standard_Boolean

        Sets a specific norm to <me>
        Returns True if done, False if <norm> is not available

        :type norm: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _XSControl.XSControl_Reader_SetNorm(self, *args)


    def SetWS(self, *args):
        """
        SetWS(XSControl_Reader self, Handle_XSControl_WorkSession WS, Standard_Boolean const scratch)

        Sets a specific session to <me>

        :type WS: OCC.wrapper.XSControl.Handle_XSControl_WorkSession
        :type scratch: bool

        """
        return _XSControl.XSControl_Reader_SetWS(self, *args)


    def WS(self, *args):
        """
        WS(XSControl_Reader self) -> Handle_XSControl_WorkSession

        Returns the session used in <me>

        :rtype: OCC.wrapper.XSControl.Handle_XSControl_WorkSession

        """
        return _XSControl.XSControl_Reader_WS(self, *args)


    def ReadFile(self, *args):
        """
        ReadFile(XSControl_Reader self, Standard_CString const filename) -> IFSelect_ReturnStatus

        Loads a file and returns the read status
        Zero for a Model which compies with the Controller

        :type filename: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.IFSelect.IFSelect_ReturnStatus

        """
        return _XSControl.XSControl_Reader_ReadFile(self, *args)


    def Model(self, *args):
        """
        Model(XSControl_Reader self) -> Handle_Interface_InterfaceModel

        Returns the model. It can then be consulted (header, product)

        :rtype: OCC.wrapper.Interface.Handle_Interface_InterfaceModel

        """
        return _XSControl.XSControl_Reader_Model(self, *args)


    def GiveList(self, *args):
        """
        GiveList(XSControl_Reader self, Standard_CString const first, Standard_CString const second) -> Handle_TColStd_HSequenceOfTransient
        GiveList(XSControl_Reader self, Standard_CString const first, Handle_Standard_Transient ent) -> Handle_TColStd_HSequenceOfTransient

        Computes a List of entities from the model as follows
        <first> beeing a Selection, <ent> beeing an entity or a list
        of entities (as a HSequenceOfTransient) :
        the standard result of this selection applied to this list
        if <first> is erroneous, a null handle is returned

        :type first: OCC.wrapper.Standard.Standard_CString
        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfTransient

        """
        return _XSControl.XSControl_Reader_GiveList(self, *args)


    def NbRootsForTransfer(self, *args):
        """
        NbRootsForTransfer(XSControl_Reader self) -> Standard_Integer

        Determines the list of root entities which are candidate for
        a transfer to a Shape, and returns the number
        of entities in the list

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _XSControl.XSControl_Reader_NbRootsForTransfer(self, *args)


    def RootForTransfer(self, *args):
        """
        RootForTransfer(XSControl_Reader self, Standard_Integer const num=1) -> Handle_Standard_Transient

        Returns an IGES or STEP root
        entity for translation. The entity is identified by its
        rank in a list.

        :type num: int
        :rtype: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _XSControl.XSControl_Reader_RootForTransfer(self, *args)


    def TransferOneRoot(self, *args):
        """
        TransferOneRoot(XSControl_Reader self, Standard_Integer const num=1) -> Standard_Boolean

        Translates a root identified by the rank num in the model.
        false is returned if no shape is produced.

        :type num: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _XSControl.XSControl_Reader_TransferOneRoot(self, *args)


    def TransferOne(self, *args):
        """
        TransferOne(XSControl_Reader self, Standard_Integer const num) -> Standard_Boolean

        Translates an IGES or STEP
        entity identified by the rank num in the model.
        false is returned if no shape is produced.

        :type num: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _XSControl.XSControl_Reader_TransferOne(self, *args)


    def TransferEntity(self, *args):
        """
        TransferEntity(XSControl_Reader self, Handle_Standard_Transient start) -> Standard_Boolean

        Translates an IGES or STEP
        entity in the model. true is returned if a shape is
        produced; otherwise, false is returned.

        :type start: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _XSControl.XSControl_Reader_TransferEntity(self, *args)


    def TransferList(self, *args):
        """
        TransferList(XSControl_Reader self, Handle_TColStd_HSequenceOfTransient list) -> Standard_Integer

        Translates a list of entities.
        Returns the number of IGES or STEP entities that were
        successfully translated. The list can be produced with GiveList.
        Warning - This function does not clear the existing output shapes.

        :type list: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfTransient
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _XSControl.XSControl_Reader_TransferList(self, *args)


    def TransferRoots(self, *args):
        """
        TransferRoots(XSControl_Reader self) -> Standard_Integer

        Translates all translatable
        roots and returns the number of successful translations.
        Warning - This function clears existing output shapes first.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _XSControl.XSControl_Reader_TransferRoots(self, *args)


    def ClearShapes(self, *args):
        """
        ClearShapes(XSControl_Reader self)

        Clears the list of shapes that
        may have accumulated in calls to TransferOne or TransferRoot.C


        """
        return _XSControl.XSControl_Reader_ClearShapes(self, *args)


    def NbShapes(self, *args):
        """
        NbShapes(XSControl_Reader self) -> Standard_Integer

        Returns the number of shapes produced by translation.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _XSControl.XSControl_Reader_NbShapes(self, *args)


    def Shape(self, *args):
        """
        Shape(XSControl_Reader self, Standard_Integer const num=1) -> TopoDS_Shape

        Returns the shape resulting
        from a translation and identified by the rank num.
        num equals 1 by default. In other words, the first shape
        resulting from the translation is returned.

        :type num: int
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _XSControl.XSControl_Reader_Shape(self, *args)


    def OneShape(self, *args):
        """
        OneShape(XSControl_Reader self) -> TopoDS_Shape

        Returns all of the results in
        a single shape which is:
        - a null shape if there are no results,
        - a shape if there is one result,
        - a compound containing the resulting shapes if there are more than one.

        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _XSControl.XSControl_Reader_OneShape(self, *args)


    def PrintCheckLoad(self, *args):
        """
        PrintCheckLoad(XSControl_Reader self, Standard_Boolean const failsonly, IFSelect_PrintCount const mode)

        Prints the check list attached to loaded data, on the Standard
        Trace File (starts at cout)
        All messages or fails only, according to <failsonly>
        mode = 0 : per entity, prints messages
        mode = 1 : per message, just gives count of entities per check
        mode = 2 : also gives entity numbers

        :type failsonly: bool
        :type mode: OCC.wrapper.IFSelect.IFSelect_PrintCount

        """
        return _XSControl.XSControl_Reader_PrintCheckLoad(self, *args)


    def PrintCheckTransfer(self, *args):
        """
        PrintCheckTransfer(XSControl_Reader self, Standard_Boolean const failsonly, IFSelect_PrintCount const mode)

        Displays check results for the
        last translation of IGES or STEP entities to Open CASCADE
        entities. Only fail messages are displayed if failsonly is
        true. All messages are displayed if failsonly is
        false. mode determines the contents and the order of the
        messages according to the terms of the IFSelect_PrintCount enumeration.

        :type failsonly: bool
        :type mode: OCC.wrapper.IFSelect.IFSelect_PrintCount

        """
        return _XSControl.XSControl_Reader_PrintCheckTransfer(self, *args)


    def PrintStatsTransfer(self, *args):
        """
        PrintStatsTransfer(XSControl_Reader self, Standard_Integer const what, Standard_Integer const mode=0)

        Displays the statistics for
        the last translation. what defines the kind of
        statistics that are displayed as follows:
        - 0 gives general statistics (number of translated roots,
        number of warnings, number of fail messages),
        - 1 gives root results,
        - 2 gives statistics for all checked entities,
        - 3 gives the list of translated entities,
        - 4 gives warning and fail messages,
        - 5 gives fail messages only.
        The use of mode depends on the value of what. If what is 0,
        mode is ignored. If what is 1, 2 or 3, mode defines the following:
        - 0 lists the numbers of IGES or STEP entities in the respective model
        - 1 gives the number, identifier, type and result
        type for each IGES or STEP entity and/or its status
        (fail, warning, etc.)
        - 2 gives maximum information for each IGES or STEP entity (i.e. checks)
        - 3 gives the number of entities per type of IGES or STEP entity
        - 4 gives the number of IGES or STEP entities per result type and/or status
        - 5 gives the number of pairs (IGES or STEP or result type and status)
        - 6 gives the number of pairs (IGES or STEP or result type
        and status) AND the list of entity numbers in the IGES or STEP model.
        If what is 4 or 5, mode defines the warning and fail
        messages as follows:
        - if mode is 0 all warnings and checks per entity are returned
        - if mode is 2 the list of entities per warning is returned.
        If mode is not set, only the list of all entities per warning is given.

        :type what: int
        :type mode: int

        """
        return _XSControl.XSControl_Reader_PrintStatsTransfer(self, *args)


    def GetStatsTransfer(self, *args):
        """
        GetStatsTransfer(XSControl_Reader self, Handle_TColStd_HSequenceOfTransient list)

        Gives statistics about Transfer

        :type list: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfTransient
        :type nbMapped: int
        :type nbWithResult: int
        :type nbWithFail: int

        """
        return _XSControl.XSControl_Reader_GetStatsTransfer(self, *args)

    __swig_destroy__ = _XSControl.delete_XSControl_Reader
XSControl_Reader_swigregister = _XSControl.XSControl_Reader_swigregister
XSControl_Reader_swigregister(XSControl_Reader)

class XSControl_Functions(object):
    """
    Functions from XSControl gives access to actions which can be
    commanded with the resources provided by XSControl: especially
    Controller and Transfer

    It works by adding functions by method Init
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Init(*args):
        """
        Init()

        Defines and loads all functions for XSControl (as ActFunc)


        """
        return _XSControl.XSControl_Functions_Init(*args)

    Init = staticmethod(Init)

    def __init__(self):
        """
        Functions from XSControl gives access to actions which can be
        commanded with the resources provided by XSControl: especially
        Controller and Transfer

        It works by adding functions by method Init
        """
        this = _XSControl.new_XSControl_Functions()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _XSControl.delete_XSControl_Functions
XSControl_Functions_swigregister = _XSControl.XSControl_Functions_swigregister
XSControl_Functions_swigregister(XSControl_Functions)

def XSControl_Functions_Init(*args):
    """
    XSControl_Functions_Init()

    Defines and loads all functions for XSControl (as ActFunc)


    """
    return _XSControl.XSControl_Functions_Init(*args)

class XSControl_Writer(object):
    """
    This class gives a simple way to create then write a
    Model compliant to a given norm, from a Shape
    The model can then be edited by tools by other appropriate tools
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(XSControl_Writer self) -> XSControl_Writer
        __init__(XSControl_Writer self, Standard_CString const norm) -> XSControl_Writer
        __init__(XSControl_Writer self, Handle_XSControl_WorkSession WS, Standard_Boolean const scratch) -> XSControl_Writer

        Creates a Writer from an already existing Session
        If <scratch> is True (D), clears already recorded data

        :type WS: OCC.wrapper.XSControl.Handle_XSControl_WorkSession
        :type scratch: bool

        """
        this = _XSControl.new_XSControl_Writer(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def SetNorm(self, *args):
        """
        SetNorm(XSControl_Writer self, Standard_CString const norm) -> Standard_Boolean

        Sets a specific norm to <me>
        Returns True if done, False if <norm> is not available

        :type norm: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _XSControl.XSControl_Writer_SetNorm(self, *args)


    def SetWS(self, *args):
        """
        SetWS(XSControl_Writer self, Handle_XSControl_WorkSession WS, Standard_Boolean const scratch)

        Sets a specific session to <me>

        :type WS: OCC.wrapper.XSControl.Handle_XSControl_WorkSession
        :type scratch: bool

        """
        return _XSControl.XSControl_Writer_SetWS(self, *args)


    def WS(self, *args):
        """
        WS(XSControl_Writer self) -> Handle_XSControl_WorkSession

        Returns the session used in <me>

        :rtype: OCC.wrapper.XSControl.Handle_XSControl_WorkSession

        """
        return _XSControl.XSControl_Writer_WS(self, *args)


    def Model(self, *args):
        """
        Model(XSControl_Writer self, Standard_Boolean const newone) -> Handle_Interface_InterfaceModel

        Returns the produced model. Produces a new one if not yet done
        or if <newone> is True
        This method allows for instance to edit product or header
        data before writing

        :type newone: bool
        :rtype: OCC.wrapper.Interface.Handle_Interface_InterfaceModel

        """
        return _XSControl.XSControl_Writer_Model(self, *args)


    def TransferShape(self, *args):
        """
        TransferShape(XSControl_Writer self, TopoDS_Shape sh, Standard_Integer const mode=0) -> IFSelect_ReturnStatus

        Transfers a Shape according to the mode

        :type sh: OCC.wrapper.TopoDS.TopoDS_Shape
        :type mode: int
        :rtype: OCC.wrapper.IFSelect.IFSelect_ReturnStatus

        """
        return _XSControl.XSControl_Writer_TransferShape(self, *args)


    def WriteFile(self, *args):
        """
        WriteFile(XSControl_Writer self, Standard_CString const filename) -> IFSelect_ReturnStatus

        Writes the produced model

        :type filename: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.IFSelect.IFSelect_ReturnStatus

        """
        return _XSControl.XSControl_Writer_WriteFile(self, *args)


    def PrintStatsTransfer(self, *args):
        """
        PrintStatsTransfer(XSControl_Writer self, Standard_Integer const what, Standard_Integer const mode=0)

        Prints Statistics about Transfer

        :type what: int
        :type mode: int

        """
        return _XSControl.XSControl_Writer_PrintStatsTransfer(self, *args)

    __swig_destroy__ = _XSControl.delete_XSControl_Writer
XSControl_Writer_swigregister = _XSControl.XSControl_Writer_swigregister
XSControl_Writer_swigregister(XSControl_Writer)

class XSControl_(object):
    """
    This package provides complements to IFSelect & Co for
    control of a session
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Session(*args):
        """
        Session(Handle_IFSelect_SessionPilot pilot) -> Handle_XSControl_WorkSession

        Returns the WorkSession of a SessionPilot, but casts it as
        from XSControl : it then gives access to Control & Transfers

        :type pilot: OCC.wrapper.IFSelect.Handle_IFSelect_SessionPilot
        :rtype: OCC.wrapper.XSControl.Handle_XSControl_WorkSession

        """
        return _XSControl.XSControl__Session(*args)

    Session = staticmethod(Session)

    def Vars(*args):
        """
        Vars(Handle_IFSelect_SessionPilot pilot) -> Handle_XSControl_Vars

        Returns the Vars of a SessionPilot, it is brought by Session
        it provides access to external variables

        :type pilot: OCC.wrapper.IFSelect.Handle_IFSelect_SessionPilot
        :rtype: OCC.wrapper.XSControl.Handle_XSControl_Vars

        """
        return _XSControl.XSControl__Vars(*args)

    Vars = staticmethod(Vars)

    def __init__(self):
        """
        This package provides complements to IFSelect & Co for
        control of a session
        """
        this = _XSControl.new_XSControl_()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _XSControl.delete_XSControl_
XSControl__swigregister = _XSControl.XSControl__swigregister
XSControl__swigregister(XSControl_)

def XSControl__Session(*args):
    """
    XSControl__Session(Handle_IFSelect_SessionPilot pilot) -> Handle_XSControl_WorkSession

    Returns the WorkSession of a SessionPilot, but casts it as
    from XSControl : it then gives access to Control & Transfers

    :type pilot: OCC.wrapper.IFSelect.Handle_IFSelect_SessionPilot
    :rtype: OCC.wrapper.XSControl.Handle_XSControl_WorkSession

    """
    return _XSControl.XSControl__Session(*args)

def XSControl__Vars(*args):
    """
    XSControl__Vars(Handle_IFSelect_SessionPilot pilot) -> Handle_XSControl_Vars

    Returns the Vars of a SessionPilot, it is brought by Session
    it provides access to external variables

    :type pilot: OCC.wrapper.IFSelect.Handle_IFSelect_SessionPilot
    :rtype: OCC.wrapper.XSControl.Handle_XSControl_Vars

    """
    return _XSControl.XSControl__Vars(*args)




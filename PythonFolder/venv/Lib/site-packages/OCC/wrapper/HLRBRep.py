# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_HLRBRep')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_HLRBRep')
    _HLRBRep = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_HLRBRep', [dirname(__file__)])
        except ImportError:
            import _HLRBRep
            return _HLRBRep
        try:
            _mod = imp.load_module('_HLRBRep', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _HLRBRep = swig_import_helper()
    del swig_import_helper
else:
    import _HLRBRep
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


class SwigPyIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _HLRBRep.delete_SwigPyIterator

    def value(self):
        return _HLRBRep.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _HLRBRep.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _HLRBRep.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _HLRBRep.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _HLRBRep.SwigPyIterator_equal(self, x)

    def copy(self):
        return _HLRBRep.SwigPyIterator_copy(self)

    def next(self):
        return _HLRBRep.SwigPyIterator_next(self)

    def __next__(self):
        return _HLRBRep.SwigPyIterator___next__(self)

    def previous(self):
        return _HLRBRep.SwigPyIterator_previous(self)

    def advance(self, n):
        return _HLRBRep.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _HLRBRep.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _HLRBRep.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _HLRBRep.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _HLRBRep.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _HLRBRep.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _HLRBRep.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self
SwigPyIterator_swigregister = _HLRBRep.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

class NCollection_CellFilter_InspectorXYZ(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _HLRBRep.NCollection_CellFilter_InspectorXYZ_Dimension
    Coord = staticmethod(_HLRBRep.NCollection_CellFilter_InspectorXYZ_Coord)

    def Shift(self, thePnt, theTol):
        return _HLRBRep.NCollection_CellFilter_InspectorXYZ_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _HLRBRep.new_NCollection_CellFilter_InspectorXYZ()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _HLRBRep.delete_NCollection_CellFilter_InspectorXYZ
NCollection_CellFilter_InspectorXYZ_swigregister = _HLRBRep.NCollection_CellFilter_InspectorXYZ_swigregister
NCollection_CellFilter_InspectorXYZ_swigregister(NCollection_CellFilter_InspectorXYZ)

def NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt):
    return _HLRBRep.NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt)
NCollection_CellFilter_InspectorXYZ_Coord = _HLRBRep.NCollection_CellFilter_InspectorXYZ_Coord

class NCollection_CellFilter_InspectorXY(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _HLRBRep.NCollection_CellFilter_InspectorXY_Dimension
    Coord = staticmethod(_HLRBRep.NCollection_CellFilter_InspectorXY_Coord)

    def Shift(self, thePnt, theTol):
        return _HLRBRep.NCollection_CellFilter_InspectorXY_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _HLRBRep.new_NCollection_CellFilter_InspectorXY()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _HLRBRep.delete_NCollection_CellFilter_InspectorXY
NCollection_CellFilter_InspectorXY_swigregister = _HLRBRep.NCollection_CellFilter_InspectorXY_swigregister
NCollection_CellFilter_InspectorXY_swigregister(NCollection_CellFilter_InspectorXY)

def NCollection_CellFilter_InspectorXY_Coord(i, thePnt):
    return _HLRBRep.NCollection_CellFilter_InspectorXY_Coord(i, thePnt)
NCollection_CellFilter_InspectorXY_Coord = _HLRBRep.NCollection_CellFilter_InspectorXY_Coord


def ptr_to_number(item):
    return _HLRBRep.ptr_to_number(item)
ptr_to_number = _HLRBRep.ptr_to_number

def HashCode(*args):
    return _HLRBRep.HashCode(*args)
HashCode = _HLRBRep.HashCode

def ptr_equal(a, b):
    return _HLRBRep.ptr_equal(a, b)
ptr_equal = _HLRBRep.ptr_equal
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import NCollection
else:
    import NCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Standard
else:
    import Standard
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import gp
else:
    import gp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColStd
else:
    import TColStd
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TCollection
else:
    import TCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import IntCurve
else:
    import IntCurve
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import GeomAbs
else:
    import GeomAbs
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import IntRes2d
else:
    import IntRes2d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import math
else:
    import math
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColgp
else:
    import TColgp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import IntSurf
else:
    import IntSurf
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Adaptor3d
else:
    import Adaptor3d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Adaptor2d
else:
    import Adaptor2d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Geom2d
else:
    import Geom2d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopAbs
else:
    import TopAbs
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Geom
else:
    import Geom
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import BRepTopAdaptor
else:
    import BRepTopAdaptor
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopoDS
else:
    import TopoDS
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Message
else:
    import Message
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopLoc
else:
    import TopLoc
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import BRepAdaptor
else:
    import BRepAdaptor
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Geom2dAdaptor
else:
    import Geom2dAdaptor
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import GeomAdaptor
else:
    import GeomAdaptor
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopTools
else:
    import TopTools
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Bnd
else:
    import Bnd
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import HLRTopoBRep
else:
    import HLRTopoBRep
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import HLRAlgo
else:
    import HLRAlgo
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Contap
else:
    import Contap
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import IntWalk
else:
    import IntWalk
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import IntImp
else:
    import IntImp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Extrema
else:
    import Extrema
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Intf
else:
    import Intf
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import IntCurveSurface
else:
    import IntCurveSurface
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import IntAna
else:
    import IntAna
del _swig_python_version_info
HLRBRep_Undefined = _HLRBRep.HLRBRep_Undefined
HLRBRep_IsoLine = _HLRBRep.HLRBRep_IsoLine
HLRBRep_OutLine = _HLRBRep.HLRBRep_OutLine
HLRBRep_Rg1Line = _HLRBRep.HLRBRep_Rg1Line
HLRBRep_RgNLine = _HLRBRep.HLRBRep_RgNLine
HLRBRep_Sharp = _HLRBRep.HLRBRep_Sharp
class HLRBRep_AreaLimit(Standard.Standard_Transient):
    """
    The  private  nested class AreaLimit represents   a --
    vertex on  the Edge with the  state on the left and --
    the right.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_HLRBRep_AreaLimit
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_HLRBRep_AreaLimit(self) 
            return h


    def __init__(self, *args):
        """
        __init__(HLRBRep_AreaLimit self, HLRAlgo_Intersection V, Standard_Boolean const Boundary, Standard_Boolean const Interference, TopAbs_State const StateBefore, TopAbs_State const StateAfter, TopAbs_State const EdgeBefore, TopAbs_State const EdgeAfter) -> HLRBRep_AreaLimit

        The previous and next field are set to NULL.

        :type V: OCC.wrapper.HLRAlgo.HLRAlgo_Intersection
        :type Boundary: bool
        :type Interference: bool
        :type StateBefore: OCC.wrapper.TopAbs.TopAbs_State
        :type StateAfter: OCC.wrapper.TopAbs.TopAbs_State
        :type EdgeBefore: OCC.wrapper.TopAbs.TopAbs_State
        :type EdgeAfter: OCC.wrapper.TopAbs.TopAbs_State

        """
        this = _HLRBRep.new_HLRBRep_AreaLimit(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Vertex(self, *args):
        """
        :rtype: OCC.wrapper.HLRAlgo.HLRAlgo_Intersection

        """
        res = _HLRBRep.HLRBRep_AreaLimit_Vertex(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def IsBoundary(self, *args):
        """
        IsBoundary(HLRBRep_AreaLimit self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _HLRBRep.HLRBRep_AreaLimit_IsBoundary(self, *args)


    def IsInterference(self, *args):
        """
        IsInterference(HLRBRep_AreaLimit self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _HLRBRep.HLRBRep_AreaLimit_IsInterference(self, *args)


    def StateBefore(self, *args):
        """
        StateBefore(HLRBRep_AreaLimit self, TopAbs_State const St)
        StateBefore(HLRBRep_AreaLimit self) -> TopAbs_State

        :rtype: OCC.wrapper.TopAbs.TopAbs_State

        """
        return _HLRBRep.HLRBRep_AreaLimit_StateBefore(self, *args)


    def StateAfter(self, *args):
        """
        StateAfter(HLRBRep_AreaLimit self, TopAbs_State const St)
        StateAfter(HLRBRep_AreaLimit self) -> TopAbs_State

        :rtype: OCC.wrapper.TopAbs.TopAbs_State

        """
        return _HLRBRep.HLRBRep_AreaLimit_StateAfter(self, *args)


    def EdgeBefore(self, *args):
        """
        EdgeBefore(HLRBRep_AreaLimit self, TopAbs_State const St)
        EdgeBefore(HLRBRep_AreaLimit self) -> TopAbs_State

        :rtype: OCC.wrapper.TopAbs.TopAbs_State

        """
        return _HLRBRep.HLRBRep_AreaLimit_EdgeBefore(self, *args)


    def EdgeAfter(self, *args):
        """
        EdgeAfter(HLRBRep_AreaLimit self, TopAbs_State const St)
        EdgeAfter(HLRBRep_AreaLimit self) -> TopAbs_State

        :rtype: OCC.wrapper.TopAbs.TopAbs_State

        """
        return _HLRBRep.HLRBRep_AreaLimit_EdgeAfter(self, *args)


    def Previous(self, *args):
        """
        Previous(HLRBRep_AreaLimit self, Handle_HLRBRep_AreaLimit P)
        Previous(HLRBRep_AreaLimit self) -> Handle_HLRBRep_AreaLimit

        :rtype: OCC.wrapper.HLRBRep.Handle_HLRBRep_AreaLimit

        """
        return _HLRBRep.HLRBRep_AreaLimit_Previous(self, *args)


    def Next(self, *args):
        """
        Next(HLRBRep_AreaLimit self, Handle_HLRBRep_AreaLimit N)
        Next(HLRBRep_AreaLimit self) -> Handle_HLRBRep_AreaLimit

        :rtype: OCC.wrapper.HLRBRep.Handle_HLRBRep_AreaLimit

        """
        return _HLRBRep.HLRBRep_AreaLimit_Next(self, *args)


    def Clear(self, *args):
        """Clear(HLRBRep_AreaLimit self)"""
        return _HLRBRep.HLRBRep_AreaLimit_Clear(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _HLRBRep.HLRBRep_AreaLimit_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _HLRBRep.HLRBRep_AreaLimit_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _HLRBRep.HLRBRep_AreaLimit_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _HLRBRep.delete_HLRBRep_AreaLimit
HLRBRep_AreaLimit_swigregister = _HLRBRep.HLRBRep_AreaLimit_swigregister
HLRBRep_AreaLimit_swigregister(HLRBRep_AreaLimit)

def HLRBRep_AreaLimit_get_type_name(*args):
    """
    HLRBRep_AreaLimit_get_type_name() -> char const *

    :rtype: const char *

    """
    return _HLRBRep.HLRBRep_AreaLimit_get_type_name(*args)

def HLRBRep_AreaLimit_get_type_descriptor(*args):
    """
    HLRBRep_AreaLimit_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _HLRBRep.HLRBRep_AreaLimit_get_type_descriptor(*args)

class HLRBRep_InternalAlgo(Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_HLRBRep_InternalAlgo
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_HLRBRep_InternalAlgo(self) 
            return h


    def __init__(self, *args):
        """
        __init__(HLRBRep_InternalAlgo self) -> HLRBRep_InternalAlgo
        __init__(HLRBRep_InternalAlgo self, Handle_HLRBRep_InternalAlgo A) -> HLRBRep_InternalAlgo

        :type A: OCC.wrapper.HLRBRep.Handle_HLRBRep_InternalAlgo

        """
        this = _HLRBRep.new_HLRBRep_InternalAlgo(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Projector(self, *args):
        """
        Projector(HLRBRep_InternalAlgo self, HLRAlgo_Projector P)
        Projector(HLRBRep_InternalAlgo self) -> HLRAlgo_Projector

        set the projector.

        :rtype: OCC.wrapper.HLRAlgo.HLRAlgo_Projector

        """
        return _HLRBRep.HLRBRep_InternalAlgo_Projector(self, *args)


    def Update(self, *args):
        """
        Update(HLRBRep_InternalAlgo self)

        update the DataStructure.


        """
        return _HLRBRep.HLRBRep_InternalAlgo_Update(self, *args)


    def Load(self, *args):
        """
        Load(HLRBRep_InternalAlgo self, Handle_HLRTopoBRep_OutLiner S, Handle_Standard_Transient SData, Standard_Integer const nbIso=0)
        Load(HLRBRep_InternalAlgo self, Handle_HLRTopoBRep_OutLiner S, Standard_Integer const nbIso=0)

        add the shape <S>.

        :type S: OCC.wrapper.HLRTopoBRep.Handle_HLRTopoBRep_OutLiner
        :type nbIso: int

        """
        return _HLRBRep.HLRBRep_InternalAlgo_Load(self, *args)


    def Index(self, *args):
        """
        Index(HLRBRep_InternalAlgo self, Handle_HLRTopoBRep_OutLiner S) -> Standard_Integer

        return the index of the Shape <S> and  return 0 if
        the Shape <S> is not found.

        :type S: OCC.wrapper.HLRTopoBRep.Handle_HLRTopoBRep_OutLiner
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _HLRBRep.HLRBRep_InternalAlgo_Index(self, *args)


    def Remove(self, *args):
        """
        Remove(HLRBRep_InternalAlgo self, Standard_Integer const I)

        remove the Shape of Index <I>.

        :type I: int

        """
        return _HLRBRep.HLRBRep_InternalAlgo_Remove(self, *args)


    def ShapeData(self, *args):
        """
        ShapeData(HLRBRep_InternalAlgo self, Standard_Integer const I, Handle_Standard_Transient SData)

        Change the Shape Data of the Shape of index <I>.

        :type I: int
        :type SData: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _HLRBRep.HLRBRep_InternalAlgo_ShapeData(self, *args)


    def SeqOfShapeBounds(self, *args):
        """
        SeqOfShapeBounds(HLRBRep_InternalAlgo self) -> NCollection_Sequence_HLRBRep_ShapeBounds

        :rtype: OCC.wrapper.HLRBRep.HLRBRep_SeqOfShapeBounds

        """
        return _HLRBRep.HLRBRep_InternalAlgo_SeqOfShapeBounds(self, *args)


    def NbShapes(self, *args):
        """
        NbShapes(HLRBRep_InternalAlgo self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _HLRBRep.HLRBRep_InternalAlgo_NbShapes(self, *args)


    def ShapeBounds(self, *args):
        """
        ShapeBounds(HLRBRep_InternalAlgo self, Standard_Integer const I) -> HLRBRep_ShapeBounds

        :type I: int
        :rtype: OCC.wrapper.HLRBRep.HLRBRep_ShapeBounds

        """
        return _HLRBRep.HLRBRep_InternalAlgo_ShapeBounds(self, *args)


    def InitEdgeStatus(self, *args):
        """
        InitEdgeStatus(HLRBRep_InternalAlgo self)

        init the status of the selected edges depending of
        the back faces of a closed shell.


        """
        return _HLRBRep.HLRBRep_InternalAlgo_InitEdgeStatus(self, *args)


    def Select(self, *args):
        """
        Select(HLRBRep_InternalAlgo self)
        Select(HLRBRep_InternalAlgo self, Standard_Integer const I)

        select  only   the Shape of index <I>.

        :type I: int

        """
        return _HLRBRep.HLRBRep_InternalAlgo_Select(self, *args)


    def SelectEdge(self, *args):
        """
        SelectEdge(HLRBRep_InternalAlgo self, Standard_Integer const I)

        select only the edges of the Shape <S>.

        :type I: int

        """
        return _HLRBRep.HLRBRep_InternalAlgo_SelectEdge(self, *args)


    def SelectFace(self, *args):
        """
        SelectFace(HLRBRep_InternalAlgo self, Standard_Integer const I)

        select only the faces of the Shape <S>.

        :type I: int

        """
        return _HLRBRep.HLRBRep_InternalAlgo_SelectFace(self, *args)


    def ShowAll(self, *args):
        """
        ShowAll(HLRBRep_InternalAlgo self)
        ShowAll(HLRBRep_InternalAlgo self, Standard_Integer const I)

        set to visible all the edges of the Shape <S>.

        :type I: int

        """
        return _HLRBRep.HLRBRep_InternalAlgo_ShowAll(self, *args)


    def HideAll(self, *args):
        """
        HideAll(HLRBRep_InternalAlgo self)
        HideAll(HLRBRep_InternalAlgo self, Standard_Integer const I)

        set to  hide all the  edges of the  Shape <S>.

        :type I: int

        """
        return _HLRBRep.HLRBRep_InternalAlgo_HideAll(self, *args)


    def PartialHide(self, *args):
        """
        PartialHide(HLRBRep_InternalAlgo self)

        own hiding  of all the shapes of the DataStructure
        without hiding by each other.


        """
        return _HLRBRep.HLRBRep_InternalAlgo_PartialHide(self, *args)


    def Hide(self, *args):
        """
        Hide(HLRBRep_InternalAlgo self)
        Hide(HLRBRep_InternalAlgo self, Standard_Integer const I)
        Hide(HLRBRep_InternalAlgo self, Standard_Integer const I, Standard_Integer const J)

        hide the Shape <S1> by the shape <S2>.

        :type I: int
        :type J: int

        """
        return _HLRBRep.HLRBRep_InternalAlgo_Hide(self, *args)


    def Debug(self, *args):
        """
        Debug(HLRBRep_InternalAlgo self, Standard_Boolean const deb)
        Debug(HLRBRep_InternalAlgo self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _HLRBRep.HLRBRep_InternalAlgo_Debug(self, *args)


    def DataStructure(self, *args):
        """
        DataStructure(HLRBRep_InternalAlgo self) -> Handle_HLRBRep_Data

        :rtype: OCC.wrapper.HLRBRep.Handle_HLRBRep_Data

        """
        return _HLRBRep.HLRBRep_InternalAlgo_DataStructure(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _HLRBRep.HLRBRep_InternalAlgo_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _HLRBRep.HLRBRep_InternalAlgo_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _HLRBRep.HLRBRep_InternalAlgo_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _HLRBRep.delete_HLRBRep_InternalAlgo
HLRBRep_InternalAlgo_swigregister = _HLRBRep.HLRBRep_InternalAlgo_swigregister
HLRBRep_InternalAlgo_swigregister(HLRBRep_InternalAlgo)

def HLRBRep_InternalAlgo_get_type_name(*args):
    """
    HLRBRep_InternalAlgo_get_type_name() -> char const *

    :rtype: const char *

    """
    return _HLRBRep.HLRBRep_InternalAlgo_get_type_name(*args)

def HLRBRep_InternalAlgo_get_type_descriptor(*args):
    """
    HLRBRep_InternalAlgo_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _HLRBRep.HLRBRep_InternalAlgo_get_type_descriptor(*args)

class HLRBRep_PolyAlgo(Standard.Standard_Transient):
    """
    to remove Hidden lines on Shapes with Triangulations.
    A framework to compute the shape as seen in
    a projection plane. This is done by calculating
    the visible and the hidden parts of the shape.
    HLRBRep_PolyAlgo works with three types of entity:
    -   shapes to be visualized (these shapes must
    have already been triangulated.)
    -   edges in these shapes (these edges are
    defined as polygonal lines on the
    triangulation of the shape, and are the basic
    entities which will be visualized or hidden), and
    -   triangles in these shapes which hide the edges.
    HLRBRep_PolyAlgo is based on the principle
    of comparing each edge of the shape to be
    visualized with each of the triangles produced
    by the triangulation of the shape, and
    calculating the visible and the hidden parts of each edge.
    For a given projection, HLRBRep_PolyAlgo
    calculates a set of lines characteristic of the
    object being represented. It is also used in
    conjunction with the HLRBRep_PolyHLRToShape extraction
    utilities, which reconstruct a new, simplified
    shape from a selection of calculation results.
    This new shape is made up of edges, which
    represent the shape visualized in the projection.
    HLRBRep_PolyAlgo works with a polyhedral
    simplification of the shape whereas
    HLRBRep_Algo takes the shape itself into
    account. When you use HLRBRep_Algo, you
    obtain an exact result, whereas, when you use
    HLRBRep_PolyAlgo, you reduce computation
    time but obtain polygonal segments.
    An HLRBRep_PolyAlgo object provides a framework for:
    -   defining the point of view
    -   identifying the shape or shapes to be visualized
    -   calculating the outlines
    -   calculating the visible and hidden lines of the shape.
    Warning
    -   Superimposed lines are not eliminated by this algorithm.
    -   There must be no unfinished objects inside the shape you wish to visualize.
    -   Points are not treated.
    -   Note that this is not the sort of algorithm
    used in generating shading, which calculates
    the visible and hidden parts of each face in a
    shape to be visualized by comparing each
    face in the shape with every other face in the same shape.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_HLRBRep_PolyAlgo
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_HLRBRep_PolyAlgo(self) 
            return h


    def __init__(self, *args):
        """
        __init__(HLRBRep_PolyAlgo self) -> HLRBRep_PolyAlgo
        __init__(HLRBRep_PolyAlgo self, Handle_HLRBRep_PolyAlgo A) -> HLRBRep_PolyAlgo
        __init__(HLRBRep_PolyAlgo self, TopoDS_Shape S) -> HLRBRep_PolyAlgo

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        this = _HLRBRep.new_HLRBRep_PolyAlgo(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def NbShapes(self, *args):
        """
        NbShapes(HLRBRep_PolyAlgo self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _HLRBRep.HLRBRep_PolyAlgo_NbShapes(self, *args)


    def Shape(self, *args):
        """
        Shape(HLRBRep_PolyAlgo self, Standard_Integer const I) -> TopoDS_Shape

        :type I: int
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _HLRBRep.HLRBRep_PolyAlgo_Shape(self, *args)


    def Remove(self, *args):
        """
        Remove(HLRBRep_PolyAlgo self, Standard_Integer const I)

        remove the Shape of Index <I>.

        :type I: int

        """
        return _HLRBRep.HLRBRep_PolyAlgo_Remove(self, *args)


    def Index(self, *args):
        """
        Index(HLRBRep_PolyAlgo self, TopoDS_Shape S) -> Standard_Integer

        return the index of the Shape <S> and  return 0 if
        the Shape <S> is not found.

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _HLRBRep.HLRBRep_PolyAlgo_Index(self, *args)


    def Load(self, *args):
        """
        Load(HLRBRep_PolyAlgo self, TopoDS_Shape S)

        Loads the shape S into this framework.
        Warning S must have already been triangulated.

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _HLRBRep.HLRBRep_PolyAlgo_Load(self, *args)


    def Algo(self, *args):
        """
        Algo(HLRBRep_PolyAlgo self) -> Handle_HLRAlgo_PolyAlgo

        :rtype: OCC.wrapper.HLRAlgo.Handle_HLRAlgo_PolyAlgo

        """
        return _HLRBRep.HLRBRep_PolyAlgo_Algo(self, *args)


    def Projector(self, *args):
        """
        Sets the parameters of the view for this framework.
        These parameters are defined by an HLRAlgo_Projector object,
        which is returned by the Projector function on a Prs3d_Projector object.

        :rtype: OCC.wrapper.HLRAlgo.HLRAlgo_Projector

        """
        res = _HLRBRep.HLRBRep_PolyAlgo_Projector(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Angle(self, *args):
        """
        Angle(HLRBRep_PolyAlgo self) -> Standard_Real
        Angle(HLRBRep_PolyAlgo self, Standard_Real const Ang)

        :type Ang: float

        """
        return _HLRBRep.HLRBRep_PolyAlgo_Angle(self, *args)


    def TolAngular(self, *args):
        """
        TolAngular(HLRBRep_PolyAlgo self) -> Standard_Real
        TolAngular(HLRBRep_PolyAlgo self, Standard_Real const Tol)

        :type Tol: float

        """
        return _HLRBRep.HLRBRep_PolyAlgo_TolAngular(self, *args)


    def TolCoef(self, *args):
        """
        TolCoef(HLRBRep_PolyAlgo self) -> Standard_Real
        TolCoef(HLRBRep_PolyAlgo self, Standard_Real const Tol)

        :type Tol: float

        """
        return _HLRBRep.HLRBRep_PolyAlgo_TolCoef(self, *args)


    def Update(self, *args):
        """
        Update(HLRBRep_PolyAlgo self)

        Launches calculation of outlines of the shape
        visualized by this framework. Used after setting the point of view and
        defining the shape or shapes to be visualized.


        """
        return _HLRBRep.HLRBRep_PolyAlgo_Update(self, *args)


    def InitHide(self, *args):
        """InitHide(HLRBRep_PolyAlgo self)"""
        return _HLRBRep.HLRBRep_PolyAlgo_InitHide(self, *args)


    def MoreHide(self, *args):
        """
        MoreHide(HLRBRep_PolyAlgo self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _HLRBRep.HLRBRep_PolyAlgo_MoreHide(self, *args)


    def NextHide(self, *args):
        """NextHide(HLRBRep_PolyAlgo self)"""
        return _HLRBRep.HLRBRep_PolyAlgo_NextHide(self, *args)


    def Hide(self, *args):
        """
        Hide(HLRBRep_PolyAlgo self, HLRAlgo_EdgeStatus status, TopoDS_Shape S) -> HLRAlgo_BiPoint::PointsT &

        :type status: OCC.wrapper.HLRAlgo.HLRAlgo_EdgeStatus
        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :type reg1: bool
        :type regn: bool
        :type outl: bool
        :type intl: bool
        :rtype: PointsT

        """
        return _HLRBRep.HLRBRep_PolyAlgo_Hide(self, *args)


    def InitShow(self, *args):
        """InitShow(HLRBRep_PolyAlgo self)"""
        return _HLRBRep.HLRBRep_PolyAlgo_InitShow(self, *args)


    def MoreShow(self, *args):
        """
        MoreShow(HLRBRep_PolyAlgo self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _HLRBRep.HLRBRep_PolyAlgo_MoreShow(self, *args)


    def NextShow(self, *args):
        """NextShow(HLRBRep_PolyAlgo self)"""
        return _HLRBRep.HLRBRep_PolyAlgo_NextShow(self, *args)


    def Show(self, *args):
        """
        Show(HLRBRep_PolyAlgo self, TopoDS_Shape S) -> HLRAlgo_BiPoint::PointsT &

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :type reg1: bool
        :type regn: bool
        :type outl: bool
        :type intl: bool
        :rtype: PointsT

        """
        return _HLRBRep.HLRBRep_PolyAlgo_Show(self, *args)


    def OutLinedShape(self, *args):
        """
        OutLinedShape(HLRBRep_PolyAlgo self, TopoDS_Shape S) -> TopoDS_Shape

        Make a shape  with  the internal outlines in  each
        face.

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _HLRBRep.HLRBRep_PolyAlgo_OutLinedShape(self, *args)


    def Debug(self, *args):
        """
        Debug(HLRBRep_PolyAlgo self) -> Standard_Boolean
        Debug(HLRBRep_PolyAlgo self, Standard_Boolean const B)

        :type B: bool

        """
        return _HLRBRep.HLRBRep_PolyAlgo_Debug(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _HLRBRep.HLRBRep_PolyAlgo_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _HLRBRep.HLRBRep_PolyAlgo_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _HLRBRep.HLRBRep_PolyAlgo_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _HLRBRep.delete_HLRBRep_PolyAlgo
HLRBRep_PolyAlgo_swigregister = _HLRBRep.HLRBRep_PolyAlgo_swigregister
HLRBRep_PolyAlgo_swigregister(HLRBRep_PolyAlgo)

def HLRBRep_PolyAlgo_get_type_name(*args):
    """
    HLRBRep_PolyAlgo_get_type_name() -> char const *

    :rtype: const char *

    """
    return _HLRBRep.HLRBRep_PolyAlgo_get_type_name(*args)

def HLRBRep_PolyAlgo_get_type_descriptor(*args):
    """
    HLRBRep_PolyAlgo_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _HLRBRep.HLRBRep_PolyAlgo_get_type_descriptor(*args)

class HLRBRep_Algo(HLRBRep_InternalAlgo):
    """
    Inherited  from InternalAlgo  to  provide  methods with Shape from TopoDS.
    A framework to compute a shape as seen in a projection plane. This is done by
    calculating the visible and the hidden parts of the shape.
    HLRBRep_Algo works with three types of entity:
    -   shapes to be visualized
    -   edges in these shapes (these edges are
    the basic entities which will be visualized or hidden), and
    -   faces in these shapes which hide the edges.
    HLRBRep_Algo is based on the principle of comparing each edge of the shape to be
    visualized with each of its faces, and calculating the visible and the hidden parts of each edge.
    For a given projection, HLRBRep_Algo calculates a set of lines characteristic of the
    object being represented. It is also used in conjunction with the
    HLRBRep_HLRToShape extraction utilities, which reconstruct a new, simplified shape
    from a selection of calculation results. This new shape is made up of edges, which
    represent the shape visualized in the projection.
    HLRBRep_Algo takes the shape itself into account whereas HLRBRep_PolyAlgo
    works with a polyhedral simplification of the shape. When you use HLRBRep_Algo, you
    obtain an exact result, whereas, when you use HLRBRep_PolyAlgo, you reduce
    computation time but obtain polygonal segments. In the case of complicated
    shapes, HLRBRep_Algo may be time-consuming.
    An HLRBRep_Algo object provides a framework for:
    -   defining the point of view
    -   identifying the shape or shapes to be visualized
    -   calculating the outlines
    -   calculating the visible and hidden lines of the shape.
    Warning
    -   Superimposed lines are not eliminated by this algorithm.
    -   There must be no unfinished objects inside the shape you wish to visualize.
    -   Points are not treated.
    -   Note that this is not the sort of algorithm used in generating shading, which
    calculates the visible and hidden parts of each face in a shape to be visualized by
    comparing each face in the shape with every other face in the same shape.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_HLRBRep_Algo
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_HLRBRep_Algo(self) 
            return h


    def __init__(self, *args):
        """
        __init__(HLRBRep_Algo self) -> HLRBRep_Algo
        __init__(HLRBRep_Algo self, Handle_HLRBRep_Algo A) -> HLRBRep_Algo

        :type A: OCC.wrapper.HLRBRep.Handle_HLRBRep_Algo

        """
        this = _HLRBRep.new_HLRBRep_Algo(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Add(self, *args):
        """
        Add(HLRBRep_Algo self, TopoDS_Shape S, Handle_Standard_Transient SData, Standard_Integer const nbIso=0)
        Add(HLRBRep_Algo self, TopoDS_Shape S, Standard_Integer const nbIso=0)

        Adds the shape S to this framework, and
        specifies the number of isoparameters nbiso desired in visualizing S.
        You may add as many shapes as you wish. Use the function Add once for each shape.

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :type nbIso: int

        """
        return _HLRBRep.HLRBRep_Algo_Add(self, *args)


    def Index(self, *args):
        """
        Index(HLRBRep_Algo self, TopoDS_Shape S) -> Standard_Integer

        return  the index  of  the  Shape <S>  and
        return 0 if the Shape <S> is not found.

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _HLRBRep.HLRBRep_Algo_Index(self, *args)


    def OutLinedShapeNullify(self, *args):
        """
        OutLinedShapeNullify(HLRBRep_Algo self)

        nullify all the results of OutLiner from HLRTopoBRep.


        """
        return _HLRBRep.HLRBRep_Algo_OutLinedShapeNullify(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _HLRBRep.HLRBRep_Algo_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _HLRBRep.HLRBRep_Algo_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _HLRBRep.HLRBRep_Algo_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _HLRBRep.delete_HLRBRep_Algo
HLRBRep_Algo_swigregister = _HLRBRep.HLRBRep_Algo_swigregister
HLRBRep_Algo_swigregister(HLRBRep_Algo)

def HLRBRep_Algo_get_type_name(*args):
    """
    HLRBRep_Algo_get_type_name() -> char const *

    :rtype: const char *

    """
    return _HLRBRep.HLRBRep_Algo_get_type_name(*args)

def HLRBRep_Algo_get_type_descriptor(*args):
    """
    HLRBRep_Algo_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _HLRBRep.HLRBRep_Algo_get_type_descriptor(*args)

class HLRBRep_ShapeBounds(object):
    """
    Contains  a Shape and the  bounds of its vertices,
    edges and faces in the DataStructure.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(HLRBRep_ShapeBounds self) -> HLRBRep_ShapeBounds
        __init__(HLRBRep_ShapeBounds self, Handle_HLRTopoBRep_OutLiner S, Handle_Standard_Transient SData, Standard_Integer const nbIso, Standard_Integer const V1, Standard_Integer const V2, Standard_Integer const E1, Standard_Integer const E2, Standard_Integer const F1, Standard_Integer const F2) -> HLRBRep_ShapeBounds
        __init__(HLRBRep_ShapeBounds self, Handle_HLRTopoBRep_OutLiner S, Standard_Integer const nbIso, Standard_Integer const V1, Standard_Integer const V2, Standard_Integer const E1, Standard_Integer const E2, Standard_Integer const F1, Standard_Integer const F2) -> HLRBRep_ShapeBounds

        :type S: OCC.wrapper.HLRTopoBRep.Handle_HLRTopoBRep_OutLiner
        :type nbIso: int
        :type V1: int
        :type V2: int
        :type E1: int
        :type E2: int
        :type F1: int
        :type F2: int

        """
        this = _HLRBRep.new_HLRBRep_ShapeBounds(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Translate(self, *args):
        """
        Translate(HLRBRep_ShapeBounds self, Standard_Integer const NV, Standard_Integer const NE, Standard_Integer const NF)

        :type NV: int
        :type NE: int
        :type NF: int

        """
        return _HLRBRep.HLRBRep_ShapeBounds_Translate(self, *args)


    def Shape(self, *args):
        """
        :rtype: OCC.wrapper.HLRTopoBRep.Handle_HLRTopoBRep_OutLiner

        """
        res = _HLRBRep.HLRBRep_ShapeBounds_Shape(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ShapeData(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        res = _HLRBRep.HLRBRep_ShapeBounds_ShapeData(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def NbOfIso(self, *args):
        """
        NbOfIso(HLRBRep_ShapeBounds self, Standard_Integer const nbIso)
        NbOfIso(HLRBRep_ShapeBounds self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _HLRBRep.HLRBRep_ShapeBounds_NbOfIso(self, *args)


    def Sizes(self, *args):
        """
        Sizes(HLRBRep_ShapeBounds self)

        :type NV: int
        :type NE: int
        :type NF: int

        """
        return _HLRBRep.HLRBRep_ShapeBounds_Sizes(self, *args)


    def Bounds(self, *args):
        """
        Bounds(HLRBRep_ShapeBounds self)

        :type V1: int
        :type V2: int
        :type E1: int
        :type E2: int
        :type F1: int
        :type F2: int

        """
        return _HLRBRep.HLRBRep_ShapeBounds_Bounds(self, *args)


    def UpdateMinMax(self, *args):
        """
        UpdateMinMax(HLRBRep_ShapeBounds self, HLRAlgo_EdgesBlock::MinMaxIndices const & theTotMinMax)

        :type theTotMinMax: MinMaxIndices

        """
        return _HLRBRep.HLRBRep_ShapeBounds_UpdateMinMax(self, *args)


    def MinMax(self, *args):
        """
        MinMax(HLRBRep_ShapeBounds self) -> HLRAlgo_EdgesBlock::MinMaxIndices &

        :rtype: MinMaxIndices

        """
        return _HLRBRep.HLRBRep_ShapeBounds_MinMax(self, *args)

    __swig_destroy__ = _HLRBRep.delete_HLRBRep_ShapeBounds
HLRBRep_ShapeBounds_swigregister = _HLRBRep.HLRBRep_ShapeBounds_swigregister
HLRBRep_ShapeBounds_swigregister(HLRBRep_ShapeBounds)

class HLRBRep_BiPoint(object):
    """Contains the colors of a shape."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(HLRBRep_BiPoint self) -> HLRBRep_BiPoint
        __init__(HLRBRep_BiPoint self, Standard_Real const x1, Standard_Real const y1, Standard_Real const z1, Standard_Real const x2, Standard_Real const y2, Standard_Real const z2, TopoDS_Shape S, Standard_Boolean const reg1, Standard_Boolean const regn, Standard_Boolean const outl, Standard_Boolean const intl) -> HLRBRep_BiPoint

        :type x1: float
        :type y1: float
        :type z1: float
        :type x2: float
        :type y2: float
        :type z2: float
        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :type reg1: bool
        :type regn: bool
        :type outl: bool
        :type intl: bool

        """
        this = _HLRBRep.new_HLRBRep_BiPoint(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def P1(self, *args):
        """
        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        res = _HLRBRep.HLRBRep_BiPoint_P1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def P2(self, *args):
        """
        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        res = _HLRBRep.HLRBRep_BiPoint_P2(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Shape(self, *args):
        """
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _HLRBRep.HLRBRep_BiPoint_Shape(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Rg1Line(self, *args):
        """
        Rg1Line(HLRBRep_BiPoint self) -> Standard_Boolean
        Rg1Line(HLRBRep_BiPoint self, Standard_Boolean const B)

        :type B: bool

        """
        return _HLRBRep.HLRBRep_BiPoint_Rg1Line(self, *args)


    def RgNLine(self, *args):
        """
        RgNLine(HLRBRep_BiPoint self) -> Standard_Boolean
        RgNLine(HLRBRep_BiPoint self, Standard_Boolean const B)

        :type B: bool

        """
        return _HLRBRep.HLRBRep_BiPoint_RgNLine(self, *args)


    def OutLine(self, *args):
        """
        OutLine(HLRBRep_BiPoint self) -> Standard_Boolean
        OutLine(HLRBRep_BiPoint self, Standard_Boolean const B)

        :type B: bool

        """
        return _HLRBRep.HLRBRep_BiPoint_OutLine(self, *args)


    def IntLine(self, *args):
        """
        IntLine(HLRBRep_BiPoint self) -> Standard_Boolean
        IntLine(HLRBRep_BiPoint self, Standard_Boolean const B)

        :type B: bool

        """
        return _HLRBRep.HLRBRep_BiPoint_IntLine(self, *args)

    __swig_destroy__ = _HLRBRep.delete_HLRBRep_BiPoint
HLRBRep_BiPoint_swigregister = _HLRBRep.HLRBRep_BiPoint_swigregister
HLRBRep_BiPoint_swigregister(HLRBRep_BiPoint)

class HLRBRep_EdgeData(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """__init__(HLRBRep_EdgeData self) -> HLRBRep_EdgeData"""
        this = _HLRBRep.new_HLRBRep_EdgeData(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Set(self, *args):
        """
        Set(HLRBRep_EdgeData self, Standard_Boolean const Reg1, Standard_Boolean const RegN, TopoDS_Edge EG, Standard_Integer const V1, Standard_Integer const V2, Standard_Boolean const Out1, Standard_Boolean const Out2, Standard_Boolean const Cut1, Standard_Boolean const Cut2, Standard_Real const Start, Standard_ShortReal const TolStart, Standard_Real const End, Standard_ShortReal const TolEnd)

        :type Reg1: bool
        :type RegN: bool
        :type EG: OCC.wrapper.TopoDS.TopoDS_Edge
        :type V1: int
        :type V2: int
        :type Out1: bool
        :type Out2: bool
        :type Cut1: bool
        :type Cut2: bool
        :type Start: float
        :type TolStart: float
        :type End: float
        :type TolEnd: float

        """
        return _HLRBRep.HLRBRep_EdgeData_Set(self, *args)


    def Selected(self, *args):
        """
        Selected(HLRBRep_EdgeData self) -> Standard_Boolean
        Selected(HLRBRep_EdgeData self, Standard_Boolean const B)

        :type B: bool

        """
        return _HLRBRep.HLRBRep_EdgeData_Selected(self, *args)


    def Rg1Line(self, *args):
        """
        Rg1Line(HLRBRep_EdgeData self) -> Standard_Boolean
        Rg1Line(HLRBRep_EdgeData self, Standard_Boolean const B)

        :type B: bool

        """
        return _HLRBRep.HLRBRep_EdgeData_Rg1Line(self, *args)


    def RgNLine(self, *args):
        """
        RgNLine(HLRBRep_EdgeData self) -> Standard_Boolean
        RgNLine(HLRBRep_EdgeData self, Standard_Boolean const B)

        :type B: bool

        """
        return _HLRBRep.HLRBRep_EdgeData_RgNLine(self, *args)


    def Vertical(self, *args):
        """
        Vertical(HLRBRep_EdgeData self) -> Standard_Boolean
        Vertical(HLRBRep_EdgeData self, Standard_Boolean const B)

        :type B: bool

        """
        return _HLRBRep.HLRBRep_EdgeData_Vertical(self, *args)


    def Simple(self, *args):
        """
        Simple(HLRBRep_EdgeData self) -> Standard_Boolean
        Simple(HLRBRep_EdgeData self, Standard_Boolean const B)

        :type B: bool

        """
        return _HLRBRep.HLRBRep_EdgeData_Simple(self, *args)


    def OutLVSta(self, *args):
        """
        OutLVSta(HLRBRep_EdgeData self) -> Standard_Boolean
        OutLVSta(HLRBRep_EdgeData self, Standard_Boolean const B)

        :type B: bool

        """
        return _HLRBRep.HLRBRep_EdgeData_OutLVSta(self, *args)


    def OutLVEnd(self, *args):
        """
        OutLVEnd(HLRBRep_EdgeData self) -> Standard_Boolean
        OutLVEnd(HLRBRep_EdgeData self, Standard_Boolean const B)

        :type B: bool

        """
        return _HLRBRep.HLRBRep_EdgeData_OutLVEnd(self, *args)


    def CutAtSta(self, *args):
        """
        CutAtSta(HLRBRep_EdgeData self) -> Standard_Boolean
        CutAtSta(HLRBRep_EdgeData self, Standard_Boolean const B)

        :type B: bool

        """
        return _HLRBRep.HLRBRep_EdgeData_CutAtSta(self, *args)


    def CutAtEnd(self, *args):
        """
        CutAtEnd(HLRBRep_EdgeData self) -> Standard_Boolean
        CutAtEnd(HLRBRep_EdgeData self, Standard_Boolean const B)

        :type B: bool

        """
        return _HLRBRep.HLRBRep_EdgeData_CutAtEnd(self, *args)


    def VerAtSta(self, *args):
        """
        VerAtSta(HLRBRep_EdgeData self) -> Standard_Boolean
        VerAtSta(HLRBRep_EdgeData self, Standard_Boolean const B)

        :type B: bool

        """
        return _HLRBRep.HLRBRep_EdgeData_VerAtSta(self, *args)


    def VerAtEnd(self, *args):
        """
        VerAtEnd(HLRBRep_EdgeData self) -> Standard_Boolean
        VerAtEnd(HLRBRep_EdgeData self, Standard_Boolean const B)

        :type B: bool

        """
        return _HLRBRep.HLRBRep_EdgeData_VerAtEnd(self, *args)


    def AutoIntersectionDone(self, *args):
        """
        AutoIntersectionDone(HLRBRep_EdgeData self) -> Standard_Boolean
        AutoIntersectionDone(HLRBRep_EdgeData self, Standard_Boolean const B)

        :type B: bool

        """
        return _HLRBRep.HLRBRep_EdgeData_AutoIntersectionDone(self, *args)


    def Used(self, *args):
        """
        Used(HLRBRep_EdgeData self) -> Standard_Boolean
        Used(HLRBRep_EdgeData self, Standard_Boolean const B)

        :type B: bool

        """
        return _HLRBRep.HLRBRep_EdgeData_Used(self, *args)


    def HideCount(self, *args):
        """
        HideCount(HLRBRep_EdgeData self) -> Standard_Integer
        HideCount(HLRBRep_EdgeData self, Standard_Integer const I)

        :type I: int

        """
        return _HLRBRep.HLRBRep_EdgeData_HideCount(self, *args)


    def VSta(self, *args):
        """
        VSta(HLRBRep_EdgeData self) -> Standard_Integer
        VSta(HLRBRep_EdgeData self, Standard_Integer const I)

        :type I: int

        """
        return _HLRBRep.HLRBRep_EdgeData_VSta(self, *args)


    def VEnd(self, *args):
        """
        VEnd(HLRBRep_EdgeData self) -> Standard_Integer
        VEnd(HLRBRep_EdgeData self, Standard_Integer const I)

        :type I: int

        """
        return _HLRBRep.HLRBRep_EdgeData_VEnd(self, *args)


    def UpdateMinMax(self, *args):
        """
        UpdateMinMax(HLRBRep_EdgeData self, HLRAlgo_EdgesBlock::MinMaxIndices const & theTotMinMax)

        :type theTotMinMax: MinMaxIndices

        """
        return _HLRBRep.HLRBRep_EdgeData_UpdateMinMax(self, *args)


    def MinMax(self, *args):
        """
        MinMax(HLRBRep_EdgeData self) -> HLRAlgo_EdgesBlock::MinMaxIndices &

        :rtype: MinMaxIndices

        """
        return _HLRBRep.HLRBRep_EdgeData_MinMax(self, *args)


    def Status(self, *args):
        """
        Status(HLRBRep_EdgeData self) -> HLRAlgo_EdgeStatus

        :rtype: OCC.wrapper.HLRAlgo.HLRAlgo_EdgeStatus

        """
        return _HLRBRep.HLRBRep_EdgeData_Status(self, *args)


    def ChangeGeometry(self, *args):
        """
        ChangeGeometry(HLRBRep_EdgeData self) -> HLRBRep_Curve

        :rtype: OCC.wrapper.HLRBRep.HLRBRep_Curve

        """
        return _HLRBRep.HLRBRep_EdgeData_ChangeGeometry(self, *args)


    def Geometry(self, *args):
        """
        :rtype: OCC.wrapper.HLRBRep.HLRBRep_Curve

        """
        res = _HLRBRep.HLRBRep_EdgeData_Geometry(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Curve(self, *args):
        """
        Curve(HLRBRep_EdgeData self) -> HLRBRep_Curve

        :rtype: OCC.wrapper.HLRBRep.HLRBRep_Curve

        """
        return _HLRBRep.HLRBRep_EdgeData_Curve(self, *args)


    def Tolerance(self, *args):
        """
        Tolerance(HLRBRep_EdgeData self) -> Standard_ShortReal

        :rtype: OCC.wrapper.Standard.Standard_ShortReal

        """
        return _HLRBRep.HLRBRep_EdgeData_Tolerance(self, *args)

    __swig_destroy__ = _HLRBRep.delete_HLRBRep_EdgeData
HLRBRep_EdgeData_swigregister = _HLRBRep.HLRBRep_EdgeData_swigregister
HLRBRep_EdgeData_swigregister(HLRBRep_EdgeData)

class HLRBRep_TheCSFunctionOfInterCSurf(math.math_FunctionSetWithDerivatives):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(HLRBRep_TheCSFunctionOfInterCSurf self, Standard_Address const & S, gp_Lin C) -> HLRBRep_TheCSFunctionOfInterCSurf

        :type S: OCC.wrapper.Standard.Standard_Address
        :type C: OCC.wrapper.gp.gp_Lin

        """
        this = _HLRBRep.new_HLRBRep_TheCSFunctionOfInterCSurf(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def NbVariables(self, *args):
        """
        NbVariables(HLRBRep_TheCSFunctionOfInterCSurf self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _HLRBRep.HLRBRep_TheCSFunctionOfInterCSurf_NbVariables(self, *args)


    def NbEquations(self, *args):
        """
        NbEquations(HLRBRep_TheCSFunctionOfInterCSurf self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _HLRBRep.HLRBRep_TheCSFunctionOfInterCSurf_NbEquations(self, *args)


    def Value(self, *args):
        """
        Value(HLRBRep_TheCSFunctionOfInterCSurf self, math_Vector X, math_Vector F) -> Standard_Boolean

        :type X: OCC.wrapper.math.math_Vector
        :type F: OCC.wrapper.math.math_Vector
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _HLRBRep.HLRBRep_TheCSFunctionOfInterCSurf_Value(self, *args)


    def Derivatives(self, *args):
        """
        Derivatives(HLRBRep_TheCSFunctionOfInterCSurf self, math_Vector X, math_Matrix D) -> Standard_Boolean

        :type X: OCC.wrapper.math.math_Vector
        :type D: OCC.wrapper.math.math_Matrix
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _HLRBRep.HLRBRep_TheCSFunctionOfInterCSurf_Derivatives(self, *args)


    def Values(self, *args):
        """
        Values(HLRBRep_TheCSFunctionOfInterCSurf self, math_Vector X, math_Vector F, math_Matrix D) -> Standard_Boolean

        :type X: OCC.wrapper.math.math_Vector
        :type F: OCC.wrapper.math.math_Vector
        :type D: OCC.wrapper.math.math_Matrix
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _HLRBRep.HLRBRep_TheCSFunctionOfInterCSurf_Values(self, *args)


    def Point(self, *args):
        """
        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        res = _HLRBRep.HLRBRep_TheCSFunctionOfInterCSurf_Point(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Root(self, *args):
        """
        Root(HLRBRep_TheCSFunctionOfInterCSurf self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _HLRBRep.HLRBRep_TheCSFunctionOfInterCSurf_Root(self, *args)


    def AuxillarSurface(self, *args):
        """
        AuxillarSurface(HLRBRep_TheCSFunctionOfInterCSurf self) -> Standard_Address const &

        :rtype: OCC.wrapper.Standard.Standard_Address

        """
        return _HLRBRep.HLRBRep_TheCSFunctionOfInterCSurf_AuxillarSurface(self, *args)


    def AuxillarCurve(self, *args):
        """
        :rtype: OCC.wrapper.gp.gp_Lin

        """
        res = _HLRBRep.HLRBRep_TheCSFunctionOfInterCSurf_AuxillarCurve(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _HLRBRep.delete_HLRBRep_TheCSFunctionOfInterCSurf
HLRBRep_TheCSFunctionOfInterCSurf_swigregister = _HLRBRep.HLRBRep_TheCSFunctionOfInterCSurf_swigregister
HLRBRep_TheCSFunctionOfInterCSurf_swigregister(HLRBRep_TheCSFunctionOfInterCSurf)

class HLRBRep_EdgeFaceTool(object):
    """
    The EdgeFaceTool computes the  UV coordinates at a
    given parameter on a Curve and a Surface.  It also
    compute the signed  curvature value in a direction
    at a given u,v point on a surface.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def CurvatureValue(*args):
        """
        CurvatureValue(Standard_Address const F, Standard_Real const U, Standard_Real const V, gp_Dir Tg) -> Standard_Real

        :type F: OCC.wrapper.Standard.Standard_Address
        :type U: float
        :type V: float
        :type Tg: OCC.wrapper.gp.gp_Dir
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _HLRBRep.HLRBRep_EdgeFaceTool_CurvatureValue(*args)

    CurvatureValue = staticmethod(CurvatureValue)

    def UVPoint(*args):
        """
        UVPoint(Standard_Real const Par, Standard_Address const E, Standard_Address const F) -> Standard_Boolean

        return True if U and V are found.

        :type Par: float
        :type E: OCC.wrapper.Standard.Standard_Address
        :type F: OCC.wrapper.Standard.Standard_Address
        :type U: float
        :type V: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _HLRBRep.HLRBRep_EdgeFaceTool_UVPoint(*args)

    UVPoint = staticmethod(UVPoint)

    def __init__(self):
        """
        The EdgeFaceTool computes the  UV coordinates at a
        given parameter on a Curve and a Surface.  It also
        compute the signed  curvature value in a direction
        at a given u,v point on a surface.
        """
        this = _HLRBRep.new_HLRBRep_EdgeFaceTool()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _HLRBRep.delete_HLRBRep_EdgeFaceTool
HLRBRep_EdgeFaceTool_swigregister = _HLRBRep.HLRBRep_EdgeFaceTool_swigregister
HLRBRep_EdgeFaceTool_swigregister(HLRBRep_EdgeFaceTool)

def HLRBRep_EdgeFaceTool_CurvatureValue(*args):
    """
    HLRBRep_EdgeFaceTool_CurvatureValue(Standard_Address const F, Standard_Real const U, Standard_Real const V, gp_Dir Tg) -> Standard_Real

    :type F: OCC.wrapper.Standard.Standard_Address
    :type U: float
    :type V: float
    :type Tg: OCC.wrapper.gp.gp_Dir
    :rtype: OCC.wrapper.Standard.Standard_Real

    """
    return _HLRBRep.HLRBRep_EdgeFaceTool_CurvatureValue(*args)

def HLRBRep_EdgeFaceTool_UVPoint(*args):
    """
    HLRBRep_EdgeFaceTool_UVPoint(Standard_Real const Par, Standard_Address const E, Standard_Address const F) -> Standard_Boolean

    return True if U and V are found.

    :type Par: float
    :type E: OCC.wrapper.Standard.Standard_Address
    :type F: OCC.wrapper.Standard.Standard_Address
    :type U: float
    :type V: float
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _HLRBRep.HLRBRep_EdgeFaceTool_UVPoint(*args)

class HLRBRep_TheIntersectorOfTheIntConicCurveOfCInter(IntRes2d.IntRes2d_Intersection):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(HLRBRep_TheIntersectorOfTheIntConicCurveOfCInter self) -> HLRBRep_TheIntersectorOfTheIntConicCurveOfCInter
        __init__(HLRBRep_TheIntersectorOfTheIntConicCurveOfCInter self, IntCurve_IConicTool ITool, IntRes2d_Domain Dom1, Standard_Address const & PCurve, IntRes2d_Domain Dom2, Standard_Real const TolConf, Standard_Real const Tol) -> HLRBRep_TheIntersectorOfTheIntConicCurveOfCInter

        Intersection between an implicit curve and
        a parametrised curve.
        The exception ConstructionError is raised if the domain
        of the parametrised curve does not verify HasFirstPoint
        and HasLastPoint return True.

        :type ITool: OCC.wrapper.IntCurve.IntCurve_IConicTool
        :type Dom1: OCC.wrapper.IntRes2d.IntRes2d_Domain
        :type PCurve: OCC.wrapper.Standard.Standard_Address
        :type Dom2: OCC.wrapper.IntRes2d.IntRes2d_Domain
        :type TolConf: float
        :type Tol: float

        """
        this = _HLRBRep.new_HLRBRep_TheIntersectorOfTheIntConicCurveOfCInter(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Perform(self, *args):
        """
        Perform(HLRBRep_TheIntersectorOfTheIntConicCurveOfCInter self, IntCurve_IConicTool ITool, IntRes2d_Domain Dom1, Standard_Address const & PCurve, IntRes2d_Domain Dom2, Standard_Real const TolConf, Standard_Real const Tol)

        Intersection between an implicit curve and
        a parametrised curve.
        The exception ConstructionError is raised if the domain
        of the parametrised curve does not verify HasFirstPoint
        and HasLastPoint return True.

        :type ITool: OCC.wrapper.IntCurve.IntCurve_IConicTool
        :type Dom1: OCC.wrapper.IntRes2d.IntRes2d_Domain
        :type PCurve: OCC.wrapper.Standard.Standard_Address
        :type Dom2: OCC.wrapper.IntRes2d.IntRes2d_Domain
        :type TolConf: float
        :type Tol: float

        """
        return _HLRBRep.HLRBRep_TheIntersectorOfTheIntConicCurveOfCInter_Perform(self, *args)


    def FindU(self, *args):
        """
        FindU(HLRBRep_TheIntersectorOfTheIntConicCurveOfCInter self, Standard_Real const parameter, gp_Pnt2d point, Standard_Address const & TheParCurev, IntCurve_IConicTool IntCurve_IConicTool) -> Standard_Real

        :type parameter: float
        :type point: OCC.wrapper.gp.gp_Pnt2d
        :type TheParCurev: OCC.wrapper.Standard.Standard_Address
        :type IntCurve_IConicTool: OCC.wrapper.IntCurve.IntCurve_IConicTool
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _HLRBRep.HLRBRep_TheIntersectorOfTheIntConicCurveOfCInter_FindU(self, *args)


    def FindV(self, *args):
        """
        FindV(HLRBRep_TheIntersectorOfTheIntConicCurveOfCInter self, Standard_Real const parameter, gp_Pnt2d point, IntCurve_IConicTool IntCurve_IConicTool, Standard_Address const & ParCurve, IntRes2d_Domain TheParCurveDomain, Standard_Real const V0, Standard_Real const V1, Standard_Real const Tolerance) -> Standard_Real

        :type parameter: float
        :type point: OCC.wrapper.gp.gp_Pnt2d
        :type IntCurve_IConicTool: OCC.wrapper.IntCurve.IntCurve_IConicTool
        :type ParCurve: OCC.wrapper.Standard.Standard_Address
        :type TheParCurveDomain: OCC.wrapper.IntRes2d.IntRes2d_Domain
        :type V0: float
        :type V1: float
        :type Tolerance: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _HLRBRep.HLRBRep_TheIntersectorOfTheIntConicCurveOfCInter_FindV(self, *args)


    def And_Domaine_Objet1_Intersections(self, *args):
        """
        And_Domaine_Objet1_Intersections(HLRBRep_TheIntersectorOfTheIntConicCurveOfCInter self, IntCurve_IConicTool IntCurve_IConicTool, Standard_Address const & TheParCurve, IntRes2d_Domain TheImpCurveDomain, IntRes2d_Domain TheParCurveDomain, NCollection_Array1_Standard_Real Inter2_And_Domain2, NCollection_Array1_Standard_Real Inter1, NCollection_Array1_Standard_Real Resultat1, NCollection_Array1_Standard_Real Resultat2, Standard_Real const EpsNul)

        :type IntCurve_IConicTool: OCC.wrapper.IntCurve.IntCurve_IConicTool
        :type TheParCurve: OCC.wrapper.Standard.Standard_Address
        :type TheImpCurveDomain: OCC.wrapper.IntRes2d.IntRes2d_Domain
        :type TheParCurveDomain: OCC.wrapper.IntRes2d.IntRes2d_Domain
        :type NbResultats: int
        :type Inter2_And_Domain2: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type Inter1: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type Resultat1: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type Resultat2: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type EpsNul: float

        """
        return _HLRBRep.HLRBRep_TheIntersectorOfTheIntConicCurveOfCInter_And_Domaine_Objet1_Intersections(self, *args)

    __swig_destroy__ = _HLRBRep.delete_HLRBRep_TheIntersectorOfTheIntConicCurveOfCInter
HLRBRep_TheIntersectorOfTheIntConicCurveOfCInter_swigregister = _HLRBRep.HLRBRep_TheIntersectorOfTheIntConicCurveOfCInter_swigregister
HLRBRep_TheIntersectorOfTheIntConicCurveOfCInter_swigregister(HLRBRep_TheIntersectorOfTheIntConicCurveOfCInter)

class HLRBRep_SurfaceTool(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def FirstUParameter(*args):
        """
        FirstUParameter(Standard_Address const S) -> Standard_Real

        :type S: OCC.wrapper.Standard.Standard_Address
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _HLRBRep.HLRBRep_SurfaceTool_FirstUParameter(*args)

    FirstUParameter = staticmethod(FirstUParameter)

    def FirstVParameter(*args):
        """
        FirstVParameter(Standard_Address const S) -> Standard_Real

        :type S: OCC.wrapper.Standard.Standard_Address
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _HLRBRep.HLRBRep_SurfaceTool_FirstVParameter(*args)

    FirstVParameter = staticmethod(FirstVParameter)

    def LastUParameter(*args):
        """
        LastUParameter(Standard_Address const S) -> Standard_Real

        :type S: OCC.wrapper.Standard.Standard_Address
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _HLRBRep.HLRBRep_SurfaceTool_LastUParameter(*args)

    LastUParameter = staticmethod(LastUParameter)

    def LastVParameter(*args):
        """
        LastVParameter(Standard_Address const S) -> Standard_Real

        :type S: OCC.wrapper.Standard.Standard_Address
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _HLRBRep.HLRBRep_SurfaceTool_LastVParameter(*args)

    LastVParameter = staticmethod(LastVParameter)

    def NbUIntervals(*args):
        """
        NbUIntervals(Standard_Address const S, GeomAbs_Shape const Sh) -> Standard_Integer

        :type S: OCC.wrapper.Standard.Standard_Address
        :type Sh: OCC.wrapper.GeomAbs.GeomAbs_Shape
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _HLRBRep.HLRBRep_SurfaceTool_NbUIntervals(*args)

    NbUIntervals = staticmethod(NbUIntervals)

    def NbVIntervals(*args):
        """
        NbVIntervals(Standard_Address const S, GeomAbs_Shape const Sh) -> Standard_Integer

        :type S: OCC.wrapper.Standard.Standard_Address
        :type Sh: OCC.wrapper.GeomAbs.GeomAbs_Shape
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _HLRBRep.HLRBRep_SurfaceTool_NbVIntervals(*args)

    NbVIntervals = staticmethod(NbVIntervals)

    def UIntervals(*args):
        """
        UIntervals(Standard_Address const S, NCollection_Array1_Standard_Real T, GeomAbs_Shape const Sh)

        :type S: OCC.wrapper.Standard.Standard_Address
        :type T: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type Sh: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _HLRBRep.HLRBRep_SurfaceTool_UIntervals(*args)

    UIntervals = staticmethod(UIntervals)

    def VIntervals(*args):
        """
        VIntervals(Standard_Address const S, NCollection_Array1_Standard_Real T, GeomAbs_Shape const Sh)

        :type S: OCC.wrapper.Standard.Standard_Address
        :type T: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type Sh: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _HLRBRep.HLRBRep_SurfaceTool_VIntervals(*args)

    VIntervals = staticmethod(VIntervals)

    def UTrim(*args):
        """
        UTrim(Standard_Address const S, Standard_Real const First, Standard_Real const Last, Standard_Real const Tol) -> Handle_Adaptor3d_HSurface

        If <First> >= <Last>

        :type S: OCC.wrapper.Standard.Standard_Address
        :type First: float
        :type Last: float
        :type Tol: float
        :rtype: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface

        """
        return _HLRBRep.HLRBRep_SurfaceTool_UTrim(*args)

    UTrim = staticmethod(UTrim)

    def VTrim(*args):
        """
        VTrim(Standard_Address const S, Standard_Real const First, Standard_Real const Last, Standard_Real const Tol) -> Handle_Adaptor3d_HSurface

        If <First> >= <Last>

        :type S: OCC.wrapper.Standard.Standard_Address
        :type First: float
        :type Last: float
        :type Tol: float
        :rtype: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface

        """
        return _HLRBRep.HLRBRep_SurfaceTool_VTrim(*args)

    VTrim = staticmethod(VTrim)

    def IsUClosed(*args):
        """
        IsUClosed(Standard_Address const S) -> Standard_Boolean

        :type S: OCC.wrapper.Standard.Standard_Address
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _HLRBRep.HLRBRep_SurfaceTool_IsUClosed(*args)

    IsUClosed = staticmethod(IsUClosed)

    def IsVClosed(*args):
        """
        IsVClosed(Standard_Address const S) -> Standard_Boolean

        :type S: OCC.wrapper.Standard.Standard_Address
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _HLRBRep.HLRBRep_SurfaceTool_IsVClosed(*args)

    IsVClosed = staticmethod(IsVClosed)

    def IsUPeriodic(*args):
        """
        IsUPeriodic(Standard_Address const S) -> Standard_Boolean

        :type S: OCC.wrapper.Standard.Standard_Address
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _HLRBRep.HLRBRep_SurfaceTool_IsUPeriodic(*args)

    IsUPeriodic = staticmethod(IsUPeriodic)

    def UPeriod(*args):
        """
        UPeriod(Standard_Address const S) -> Standard_Real

        :type S: OCC.wrapper.Standard.Standard_Address
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _HLRBRep.HLRBRep_SurfaceTool_UPeriod(*args)

    UPeriod = staticmethod(UPeriod)

    def IsVPeriodic(*args):
        """
        IsVPeriodic(Standard_Address const S) -> Standard_Boolean

        :type S: OCC.wrapper.Standard.Standard_Address
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _HLRBRep.HLRBRep_SurfaceTool_IsVPeriodic(*args)

    IsVPeriodic = staticmethod(IsVPeriodic)

    def VPeriod(*args):
        """
        VPeriod(Standard_Address const S) -> Standard_Real

        :type S: OCC.wrapper.Standard.Standard_Address
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _HLRBRep.HLRBRep_SurfaceTool_VPeriod(*args)

    VPeriod = staticmethod(VPeriod)

    def Value(*args):
        """
        Value(Standard_Address const S, Standard_Real const u, Standard_Real const v) -> gp_Pnt

        :type S: OCC.wrapper.Standard.Standard_Address
        :type u: float
        :type v: float
        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _HLRBRep.HLRBRep_SurfaceTool_Value(*args)

    Value = staticmethod(Value)

    def D0(*args):
        """
        D0(Standard_Address const S, Standard_Real const u, Standard_Real const v, gp_Pnt P)

        :type S: OCC.wrapper.Standard.Standard_Address
        :type u: float
        :type v: float
        :type P: OCC.wrapper.gp.gp_Pnt

        """
        return _HLRBRep.HLRBRep_SurfaceTool_D0(*args)

    D0 = staticmethod(D0)

    def D1(*args):
        """
        D1(Standard_Address const S, Standard_Real const u, Standard_Real const v, gp_Pnt P, gp_Vec D1u, gp_Vec D1v)

        :type S: OCC.wrapper.Standard.Standard_Address
        :type u: float
        :type v: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type D1u: OCC.wrapper.gp.gp_Vec
        :type D1v: OCC.wrapper.gp.gp_Vec

        """
        return _HLRBRep.HLRBRep_SurfaceTool_D1(*args)

    D1 = staticmethod(D1)

    def D2(*args):
        """
        D2(Standard_Address const S, Standard_Real const u, Standard_Real const v, gp_Pnt P, gp_Vec D1U, gp_Vec D1V, gp_Vec D2U, gp_Vec D2V, gp_Vec D2UV)

        :type S: OCC.wrapper.Standard.Standard_Address
        :type u: float
        :type v: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type D1U: OCC.wrapper.gp.gp_Vec
        :type D1V: OCC.wrapper.gp.gp_Vec
        :type D2U: OCC.wrapper.gp.gp_Vec
        :type D2V: OCC.wrapper.gp.gp_Vec
        :type D2UV: OCC.wrapper.gp.gp_Vec

        """
        return _HLRBRep.HLRBRep_SurfaceTool_D2(*args)

    D2 = staticmethod(D2)

    def D3(*args):
        """
        D3(Standard_Address const S, Standard_Real const u, Standard_Real const v, gp_Pnt P, gp_Vec D1U, gp_Vec D1V, gp_Vec D2U, gp_Vec D2V, gp_Vec D2UV, gp_Vec D3U, gp_Vec D3V, gp_Vec D3UUV, gp_Vec D3UVV)

        :type S: OCC.wrapper.Standard.Standard_Address
        :type u: float
        :type v: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type D1U: OCC.wrapper.gp.gp_Vec
        :type D1V: OCC.wrapper.gp.gp_Vec
        :type D2U: OCC.wrapper.gp.gp_Vec
        :type D2V: OCC.wrapper.gp.gp_Vec
        :type D2UV: OCC.wrapper.gp.gp_Vec
        :type D3U: OCC.wrapper.gp.gp_Vec
        :type D3V: OCC.wrapper.gp.gp_Vec
        :type D3UUV: OCC.wrapper.gp.gp_Vec
        :type D3UVV: OCC.wrapper.gp.gp_Vec

        """
        return _HLRBRep.HLRBRep_SurfaceTool_D3(*args)

    D3 = staticmethod(D3)

    def DN(*args):
        """
        DN(Standard_Address const S, Standard_Real const u, Standard_Real const v, Standard_Integer const Nu, Standard_Integer const Nv) -> gp_Vec

        :type S: OCC.wrapper.Standard.Standard_Address
        :type u: float
        :type v: float
        :type Nu: int
        :type Nv: int
        :rtype: OCC.wrapper.gp.gp_Vec

        """
        return _HLRBRep.HLRBRep_SurfaceTool_DN(*args)

    DN = staticmethod(DN)

    def UResolution(*args):
        """
        UResolution(Standard_Address const S, Standard_Real const R3d) -> Standard_Real

        :type S: OCC.wrapper.Standard.Standard_Address
        :type R3d: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _HLRBRep.HLRBRep_SurfaceTool_UResolution(*args)

    UResolution = staticmethod(UResolution)

    def VResolution(*args):
        """
        VResolution(Standard_Address const S, Standard_Real const R3d) -> Standard_Real

        :type S: OCC.wrapper.Standard.Standard_Address
        :type R3d: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _HLRBRep.HLRBRep_SurfaceTool_VResolution(*args)

    VResolution = staticmethod(VResolution)

    def GetType(*args):
        """
        GetType(Standard_Address const S) -> GeomAbs_SurfaceType

        :type S: OCC.wrapper.Standard.Standard_Address
        :rtype: OCC.wrapper.GeomAbs.GeomAbs_SurfaceType

        """
        return _HLRBRep.HLRBRep_SurfaceTool_GetType(*args)

    GetType = staticmethod(GetType)

    def Plane(*args):
        """
        Plane(Standard_Address const S) -> gp_Pln

        :type S: OCC.wrapper.Standard.Standard_Address
        :rtype: OCC.wrapper.gp.gp_Pln

        """
        return _HLRBRep.HLRBRep_SurfaceTool_Plane(*args)

    Plane = staticmethod(Plane)

    def Cylinder(*args):
        """
        Cylinder(Standard_Address const S) -> gp_Cylinder

        :type S: OCC.wrapper.Standard.Standard_Address
        :rtype: OCC.wrapper.gp.gp_Cylinder

        """
        return _HLRBRep.HLRBRep_SurfaceTool_Cylinder(*args)

    Cylinder = staticmethod(Cylinder)

    def Cone(*args):
        """
        Cone(Standard_Address const S) -> gp_Cone

        :type S: OCC.wrapper.Standard.Standard_Address
        :rtype: OCC.wrapper.gp.gp_Cone

        """
        return _HLRBRep.HLRBRep_SurfaceTool_Cone(*args)

    Cone = staticmethod(Cone)

    def Torus(*args):
        """
        Torus(Standard_Address const S) -> gp_Torus

        :type S: OCC.wrapper.Standard.Standard_Address
        :rtype: OCC.wrapper.gp.gp_Torus

        """
        return _HLRBRep.HLRBRep_SurfaceTool_Torus(*args)

    Torus = staticmethod(Torus)

    def Sphere(*args):
        """
        Sphere(Standard_Address const S) -> gp_Sphere

        :type S: OCC.wrapper.Standard.Standard_Address
        :rtype: OCC.wrapper.gp.gp_Sphere

        """
        return _HLRBRep.HLRBRep_SurfaceTool_Sphere(*args)

    Sphere = staticmethod(Sphere)

    def Bezier(*args):
        """
        Bezier(Standard_Address const S) -> Handle_Geom_BezierSurface

        :type S: OCC.wrapper.Standard.Standard_Address
        :rtype: OCC.wrapper.Geom.Handle_Geom_BezierSurface

        """
        return _HLRBRep.HLRBRep_SurfaceTool_Bezier(*args)

    Bezier = staticmethod(Bezier)

    def BSpline(*args):
        """
        BSpline(Standard_Address const S) -> Handle_Geom_BSplineSurface

        :type S: OCC.wrapper.Standard.Standard_Address
        :rtype: OCC.wrapper.Geom.Handle_Geom_BSplineSurface

        """
        return _HLRBRep.HLRBRep_SurfaceTool_BSpline(*args)

    BSpline = staticmethod(BSpline)

    def AxeOfRevolution(*args):
        """
        AxeOfRevolution(Standard_Address const S) -> gp_Ax1

        :type S: OCC.wrapper.Standard.Standard_Address
        :rtype: OCC.wrapper.gp.gp_Ax1

        """
        return _HLRBRep.HLRBRep_SurfaceTool_AxeOfRevolution(*args)

    AxeOfRevolution = staticmethod(AxeOfRevolution)

    def Direction(*args):
        """
        Direction(Standard_Address const S) -> gp_Dir

        :type S: OCC.wrapper.Standard.Standard_Address
        :rtype: OCC.wrapper.gp.gp_Dir

        """
        return _HLRBRep.HLRBRep_SurfaceTool_Direction(*args)

    Direction = staticmethod(Direction)

    def BasisCurve(*args):
        """
        BasisCurve(Standard_Address const S) -> Handle_Adaptor3d_HCurve

        :type S: OCC.wrapper.Standard.Standard_Address
        :rtype: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HCurve

        """
        return _HLRBRep.HLRBRep_SurfaceTool_BasisCurve(*args)

    BasisCurve = staticmethod(BasisCurve)

    def BasisSurface(*args):
        """
        BasisSurface(Standard_Address const S) -> Handle_Adaptor3d_HSurface

        :type S: OCC.wrapper.Standard.Standard_Address
        :rtype: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface

        """
        return _HLRBRep.HLRBRep_SurfaceTool_BasisSurface(*args)

    BasisSurface = staticmethod(BasisSurface)

    def OffsetValue(*args):
        """
        OffsetValue(Standard_Address const S) -> Standard_Real

        :type S: OCC.wrapper.Standard.Standard_Address
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _HLRBRep.HLRBRep_SurfaceTool_OffsetValue(*args)

    OffsetValue = staticmethod(OffsetValue)

    def NbSamplesU(*args):
        """
        NbSamplesU(Standard_Address const S) -> Standard_Integer
        NbSamplesU(Standard_Address const S, Standard_Real const u1, Standard_Real const u2) -> Standard_Integer

        :type S: OCC.wrapper.Standard.Standard_Address
        :type u1: float
        :type u2: float
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _HLRBRep.HLRBRep_SurfaceTool_NbSamplesU(*args)

    NbSamplesU = staticmethod(NbSamplesU)

    def NbSamplesV(*args):
        """
        NbSamplesV(Standard_Address const S) -> Standard_Integer
        NbSamplesV(Standard_Address const S, Standard_Real const v1, Standard_Real const v2) -> Standard_Integer

        :type S: OCC.wrapper.Standard.Standard_Address
        :type v1: float
        :type v2: float
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _HLRBRep.HLRBRep_SurfaceTool_NbSamplesV(*args)

    NbSamplesV = staticmethod(NbSamplesV)

    def __init__(self):
        this = _HLRBRep.new_HLRBRep_SurfaceTool()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _HLRBRep.delete_HLRBRep_SurfaceTool
HLRBRep_SurfaceTool_swigregister = _HLRBRep.HLRBRep_SurfaceTool_swigregister
HLRBRep_SurfaceTool_swigregister(HLRBRep_SurfaceTool)

def HLRBRep_SurfaceTool_FirstUParameter(*args):
    """
    HLRBRep_SurfaceTool_FirstUParameter(Standard_Address const S) -> Standard_Real

    :type S: OCC.wrapper.Standard.Standard_Address
    :rtype: OCC.wrapper.Standard.Standard_Real

    """
    return _HLRBRep.HLRBRep_SurfaceTool_FirstUParameter(*args)

def HLRBRep_SurfaceTool_FirstVParameter(*args):
    """
    HLRBRep_SurfaceTool_FirstVParameter(Standard_Address const S) -> Standard_Real

    :type S: OCC.wrapper.Standard.Standard_Address
    :rtype: OCC.wrapper.Standard.Standard_Real

    """
    return _HLRBRep.HLRBRep_SurfaceTool_FirstVParameter(*args)

def HLRBRep_SurfaceTool_LastUParameter(*args):
    """
    HLRBRep_SurfaceTool_LastUParameter(Standard_Address const S) -> Standard_Real

    :type S: OCC.wrapper.Standard.Standard_Address
    :rtype: OCC.wrapper.Standard.Standard_Real

    """
    return _HLRBRep.HLRBRep_SurfaceTool_LastUParameter(*args)

def HLRBRep_SurfaceTool_LastVParameter(*args):
    """
    HLRBRep_SurfaceTool_LastVParameter(Standard_Address const S) -> Standard_Real

    :type S: OCC.wrapper.Standard.Standard_Address
    :rtype: OCC.wrapper.Standard.Standard_Real

    """
    return _HLRBRep.HLRBRep_SurfaceTool_LastVParameter(*args)

def HLRBRep_SurfaceTool_NbUIntervals(*args):
    """
    HLRBRep_SurfaceTool_NbUIntervals(Standard_Address const S, GeomAbs_Shape const Sh) -> Standard_Integer

    :type S: OCC.wrapper.Standard.Standard_Address
    :type Sh: OCC.wrapper.GeomAbs.GeomAbs_Shape
    :rtype: OCC.wrapper.Standard.Standard_Integer

    """
    return _HLRBRep.HLRBRep_SurfaceTool_NbUIntervals(*args)

def HLRBRep_SurfaceTool_NbVIntervals(*args):
    """
    HLRBRep_SurfaceTool_NbVIntervals(Standard_Address const S, GeomAbs_Shape const Sh) -> Standard_Integer

    :type S: OCC.wrapper.Standard.Standard_Address
    :type Sh: OCC.wrapper.GeomAbs.GeomAbs_Shape
    :rtype: OCC.wrapper.Standard.Standard_Integer

    """
    return _HLRBRep.HLRBRep_SurfaceTool_NbVIntervals(*args)

def HLRBRep_SurfaceTool_UIntervals(*args):
    """
    HLRBRep_SurfaceTool_UIntervals(Standard_Address const S, NCollection_Array1_Standard_Real T, GeomAbs_Shape const Sh)

    :type S: OCC.wrapper.Standard.Standard_Address
    :type T: OCC.wrapper.TColStd.TColStd_Array1OfReal
    :type Sh: OCC.wrapper.GeomAbs.GeomAbs_Shape

    """
    return _HLRBRep.HLRBRep_SurfaceTool_UIntervals(*args)

def HLRBRep_SurfaceTool_VIntervals(*args):
    """
    HLRBRep_SurfaceTool_VIntervals(Standard_Address const S, NCollection_Array1_Standard_Real T, GeomAbs_Shape const Sh)

    :type S: OCC.wrapper.Standard.Standard_Address
    :type T: OCC.wrapper.TColStd.TColStd_Array1OfReal
    :type Sh: OCC.wrapper.GeomAbs.GeomAbs_Shape

    """
    return _HLRBRep.HLRBRep_SurfaceTool_VIntervals(*args)

def HLRBRep_SurfaceTool_UTrim(*args):
    """
    HLRBRep_SurfaceTool_UTrim(Standard_Address const S, Standard_Real const First, Standard_Real const Last, Standard_Real const Tol) -> Handle_Adaptor3d_HSurface

    If <First> >= <Last>

    :type S: OCC.wrapper.Standard.Standard_Address
    :type First: float
    :type Last: float
    :type Tol: float
    :rtype: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface

    """
    return _HLRBRep.HLRBRep_SurfaceTool_UTrim(*args)

def HLRBRep_SurfaceTool_VTrim(*args):
    """
    HLRBRep_SurfaceTool_VTrim(Standard_Address const S, Standard_Real const First, Standard_Real const Last, Standard_Real const Tol) -> Handle_Adaptor3d_HSurface

    If <First> >= <Last>

    :type S: OCC.wrapper.Standard.Standard_Address
    :type First: float
    :type Last: float
    :type Tol: float
    :rtype: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface

    """
    return _HLRBRep.HLRBRep_SurfaceTool_VTrim(*args)

def HLRBRep_SurfaceTool_IsUClosed(*args):
    """
    HLRBRep_SurfaceTool_IsUClosed(Standard_Address const S) -> Standard_Boolean

    :type S: OCC.wrapper.Standard.Standard_Address
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _HLRBRep.HLRBRep_SurfaceTool_IsUClosed(*args)

def HLRBRep_SurfaceTool_IsVClosed(*args):
    """
    HLRBRep_SurfaceTool_IsVClosed(Standard_Address const S) -> Standard_Boolean

    :type S: OCC.wrapper.Standard.Standard_Address
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _HLRBRep.HLRBRep_SurfaceTool_IsVClosed(*args)

def HLRBRep_SurfaceTool_IsUPeriodic(*args):
    """
    HLRBRep_SurfaceTool_IsUPeriodic(Standard_Address const S) -> Standard_Boolean

    :type S: OCC.wrapper.Standard.Standard_Address
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _HLRBRep.HLRBRep_SurfaceTool_IsUPeriodic(*args)

def HLRBRep_SurfaceTool_UPeriod(*args):
    """
    HLRBRep_SurfaceTool_UPeriod(Standard_Address const S) -> Standard_Real

    :type S: OCC.wrapper.Standard.Standard_Address
    :rtype: OCC.wrapper.Standard.Standard_Real

    """
    return _HLRBRep.HLRBRep_SurfaceTool_UPeriod(*args)

def HLRBRep_SurfaceTool_IsVPeriodic(*args):
    """
    HLRBRep_SurfaceTool_IsVPeriodic(Standard_Address const S) -> Standard_Boolean

    :type S: OCC.wrapper.Standard.Standard_Address
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _HLRBRep.HLRBRep_SurfaceTool_IsVPeriodic(*args)

def HLRBRep_SurfaceTool_VPeriod(*args):
    """
    HLRBRep_SurfaceTool_VPeriod(Standard_Address const S) -> Standard_Real

    :type S: OCC.wrapper.Standard.Standard_Address
    :rtype: OCC.wrapper.Standard.Standard_Real

    """
    return _HLRBRep.HLRBRep_SurfaceTool_VPeriod(*args)

def HLRBRep_SurfaceTool_Value(*args):
    """
    HLRBRep_SurfaceTool_Value(Standard_Address const S, Standard_Real const u, Standard_Real const v) -> gp_Pnt

    :type S: OCC.wrapper.Standard.Standard_Address
    :type u: float
    :type v: float
    :rtype: OCC.wrapper.gp.gp_Pnt

    """
    return _HLRBRep.HLRBRep_SurfaceTool_Value(*args)

def HLRBRep_SurfaceTool_D0(*args):
    """
    HLRBRep_SurfaceTool_D0(Standard_Address const S, Standard_Real const u, Standard_Real const v, gp_Pnt P)

    :type S: OCC.wrapper.Standard.Standard_Address
    :type u: float
    :type v: float
    :type P: OCC.wrapper.gp.gp_Pnt

    """
    return _HLRBRep.HLRBRep_SurfaceTool_D0(*args)

def HLRBRep_SurfaceTool_D1(*args):
    """
    HLRBRep_SurfaceTool_D1(Standard_Address const S, Standard_Real const u, Standard_Real const v, gp_Pnt P, gp_Vec D1u, gp_Vec D1v)

    :type S: OCC.wrapper.Standard.Standard_Address
    :type u: float
    :type v: float
    :type P: OCC.wrapper.gp.gp_Pnt
    :type D1u: OCC.wrapper.gp.gp_Vec
    :type D1v: OCC.wrapper.gp.gp_Vec

    """
    return _HLRBRep.HLRBRep_SurfaceTool_D1(*args)

def HLRBRep_SurfaceTool_D2(*args):
    """
    HLRBRep_SurfaceTool_D2(Standard_Address const S, Standard_Real const u, Standard_Real const v, gp_Pnt P, gp_Vec D1U, gp_Vec D1V, gp_Vec D2U, gp_Vec D2V, gp_Vec D2UV)

    :type S: OCC.wrapper.Standard.Standard_Address
    :type u: float
    :type v: float
    :type P: OCC.wrapper.gp.gp_Pnt
    :type D1U: OCC.wrapper.gp.gp_Vec
    :type D1V: OCC.wrapper.gp.gp_Vec
    :type D2U: OCC.wrapper.gp.gp_Vec
    :type D2V: OCC.wrapper.gp.gp_Vec
    :type D2UV: OCC.wrapper.gp.gp_Vec

    """
    return _HLRBRep.HLRBRep_SurfaceTool_D2(*args)

def HLRBRep_SurfaceTool_D3(*args):
    """
    HLRBRep_SurfaceTool_D3(Standard_Address const S, Standard_Real const u, Standard_Real const v, gp_Pnt P, gp_Vec D1U, gp_Vec D1V, gp_Vec D2U, gp_Vec D2V, gp_Vec D2UV, gp_Vec D3U, gp_Vec D3V, gp_Vec D3UUV, gp_Vec D3UVV)

    :type S: OCC.wrapper.Standard.Standard_Address
    :type u: float
    :type v: float
    :type P: OCC.wrapper.gp.gp_Pnt
    :type D1U: OCC.wrapper.gp.gp_Vec
    :type D1V: OCC.wrapper.gp.gp_Vec
    :type D2U: OCC.wrapper.gp.gp_Vec
    :type D2V: OCC.wrapper.gp.gp_Vec
    :type D2UV: OCC.wrapper.gp.gp_Vec
    :type D3U: OCC.wrapper.gp.gp_Vec
    :type D3V: OCC.wrapper.gp.gp_Vec
    :type D3UUV: OCC.wrapper.gp.gp_Vec
    :type D3UVV: OCC.wrapper.gp.gp_Vec

    """
    return _HLRBRep.HLRBRep_SurfaceTool_D3(*args)

def HLRBRep_SurfaceTool_DN(*args):
    """
    HLRBRep_SurfaceTool_DN(Standard_Address const S, Standard_Real const u, Standard_Real const v, Standard_Integer const Nu, Standard_Integer const Nv) -> gp_Vec

    :type S: OCC.wrapper.Standard.Standard_Address
    :type u: float
    :type v: float
    :type Nu: int
    :type Nv: int
    :rtype: OCC.wrapper.gp.gp_Vec

    """
    return _HLRBRep.HLRBRep_SurfaceTool_DN(*args)

def HLRBRep_SurfaceTool_UResolution(*args):
    """
    HLRBRep_SurfaceTool_UResolution(Standard_Address const S, Standard_Real const R3d) -> Standard_Real

    :type S: OCC.wrapper.Standard.Standard_Address
    :type R3d: float
    :rtype: OCC.wrapper.Standard.Standard_Real

    """
    return _HLRBRep.HLRBRep_SurfaceTool_UResolution(*args)

def HLRBRep_SurfaceTool_VResolution(*args):
    """
    HLRBRep_SurfaceTool_VResolution(Standard_Address const S, Standard_Real const R3d) -> Standard_Real

    :type S: OCC.wrapper.Standard.Standard_Address
    :type R3d: float
    :rtype: OCC.wrapper.Standard.Standard_Real

    """
    return _HLRBRep.HLRBRep_SurfaceTool_VResolution(*args)

def HLRBRep_SurfaceTool_GetType(*args):
    """
    HLRBRep_SurfaceTool_GetType(Standard_Address const S) -> GeomAbs_SurfaceType

    :type S: OCC.wrapper.Standard.Standard_Address
    :rtype: OCC.wrapper.GeomAbs.GeomAbs_SurfaceType

    """
    return _HLRBRep.HLRBRep_SurfaceTool_GetType(*args)

def HLRBRep_SurfaceTool_Plane(*args):
    """
    HLRBRep_SurfaceTool_Plane(Standard_Address const S) -> gp_Pln

    :type S: OCC.wrapper.Standard.Standard_Address
    :rtype: OCC.wrapper.gp.gp_Pln

    """
    return _HLRBRep.HLRBRep_SurfaceTool_Plane(*args)

def HLRBRep_SurfaceTool_Cylinder(*args):
    """
    HLRBRep_SurfaceTool_Cylinder(Standard_Address const S) -> gp_Cylinder

    :type S: OCC.wrapper.Standard.Standard_Address
    :rtype: OCC.wrapper.gp.gp_Cylinder

    """
    return _HLRBRep.HLRBRep_SurfaceTool_Cylinder(*args)

def HLRBRep_SurfaceTool_Cone(*args):
    """
    HLRBRep_SurfaceTool_Cone(Standard_Address const S) -> gp_Cone

    :type S: OCC.wrapper.Standard.Standard_Address
    :rtype: OCC.wrapper.gp.gp_Cone

    """
    return _HLRBRep.HLRBRep_SurfaceTool_Cone(*args)

def HLRBRep_SurfaceTool_Torus(*args):
    """
    HLRBRep_SurfaceTool_Torus(Standard_Address const S) -> gp_Torus

    :type S: OCC.wrapper.Standard.Standard_Address
    :rtype: OCC.wrapper.gp.gp_Torus

    """
    return _HLRBRep.HLRBRep_SurfaceTool_Torus(*args)

def HLRBRep_SurfaceTool_Sphere(*args):
    """
    HLRBRep_SurfaceTool_Sphere(Standard_Address const S) -> gp_Sphere

    :type S: OCC.wrapper.Standard.Standard_Address
    :rtype: OCC.wrapper.gp.gp_Sphere

    """
    return _HLRBRep.HLRBRep_SurfaceTool_Sphere(*args)

def HLRBRep_SurfaceTool_Bezier(*args):
    """
    HLRBRep_SurfaceTool_Bezier(Standard_Address const S) -> Handle_Geom_BezierSurface

    :type S: OCC.wrapper.Standard.Standard_Address
    :rtype: OCC.wrapper.Geom.Handle_Geom_BezierSurface

    """
    return _HLRBRep.HLRBRep_SurfaceTool_Bezier(*args)

def HLRBRep_SurfaceTool_BSpline(*args):
    """
    HLRBRep_SurfaceTool_BSpline(Standard_Address const S) -> Handle_Geom_BSplineSurface

    :type S: OCC.wrapper.Standard.Standard_Address
    :rtype: OCC.wrapper.Geom.Handle_Geom_BSplineSurface

    """
    return _HLRBRep.HLRBRep_SurfaceTool_BSpline(*args)

def HLRBRep_SurfaceTool_AxeOfRevolution(*args):
    """
    HLRBRep_SurfaceTool_AxeOfRevolution(Standard_Address const S) -> gp_Ax1

    :type S: OCC.wrapper.Standard.Standard_Address
    :rtype: OCC.wrapper.gp.gp_Ax1

    """
    return _HLRBRep.HLRBRep_SurfaceTool_AxeOfRevolution(*args)

def HLRBRep_SurfaceTool_Direction(*args):
    """
    HLRBRep_SurfaceTool_Direction(Standard_Address const S) -> gp_Dir

    :type S: OCC.wrapper.Standard.Standard_Address
    :rtype: OCC.wrapper.gp.gp_Dir

    """
    return _HLRBRep.HLRBRep_SurfaceTool_Direction(*args)

def HLRBRep_SurfaceTool_BasisCurve(*args):
    """
    HLRBRep_SurfaceTool_BasisCurve(Standard_Address const S) -> Handle_Adaptor3d_HCurve

    :type S: OCC.wrapper.Standard.Standard_Address
    :rtype: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HCurve

    """
    return _HLRBRep.HLRBRep_SurfaceTool_BasisCurve(*args)

def HLRBRep_SurfaceTool_BasisSurface(*args):
    """
    HLRBRep_SurfaceTool_BasisSurface(Standard_Address const S) -> Handle_Adaptor3d_HSurface

    :type S: OCC.wrapper.Standard.Standard_Address
    :rtype: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface

    """
    return _HLRBRep.HLRBRep_SurfaceTool_BasisSurface(*args)

def HLRBRep_SurfaceTool_OffsetValue(*args):
    """
    HLRBRep_SurfaceTool_OffsetValue(Standard_Address const S) -> Standard_Real

    :type S: OCC.wrapper.Standard.Standard_Address
    :rtype: OCC.wrapper.Standard.Standard_Real

    """
    return _HLRBRep.HLRBRep_SurfaceTool_OffsetValue(*args)

def HLRBRep_SurfaceTool_NbSamplesU(*args):
    """
    NbSamplesU(Standard_Address const S) -> Standard_Integer
    HLRBRep_SurfaceTool_NbSamplesU(Standard_Address const S, Standard_Real const u1, Standard_Real const u2) -> Standard_Integer

    :type S: OCC.wrapper.Standard.Standard_Address
    :type u1: float
    :type u2: float
    :rtype: OCC.wrapper.Standard.Standard_Integer

    """
    return _HLRBRep.HLRBRep_SurfaceTool_NbSamplesU(*args)

def HLRBRep_SurfaceTool_NbSamplesV(*args):
    """
    NbSamplesV(Standard_Address const S) -> Standard_Integer
    HLRBRep_SurfaceTool_NbSamplesV(Standard_Address const S, Standard_Real const v1, Standard_Real const v2) -> Standard_Integer

    :type S: OCC.wrapper.Standard.Standard_Address
    :type v1: float
    :type v2: float
    :rtype: OCC.wrapper.Standard.Standard_Integer

    """
    return _HLRBRep.HLRBRep_SurfaceTool_NbSamplesV(*args)

class HLRBRep_TheExactInterCSurf(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(HLRBRep_TheExactInterCSurf self, Standard_Real const U, Standard_Real const V, Standard_Real const W, HLRBRep_TheCSFunctionOfInterCSurf F, Standard_Real const TolTangency, Standard_Real const MarginCoef=0.0) -> HLRBRep_TheExactInterCSurf
        __init__(HLRBRep_TheExactInterCSurf self, HLRBRep_TheCSFunctionOfInterCSurf F, Standard_Real const TolTangency) -> HLRBRep_TheExactInterCSurf

        initialize the parameters to compute the solution

        :type F: OCC.wrapper.HLRBRep.HLRBRep_TheCSFunctionOfInterCSurf
        :type TolTangency: float

        """
        this = _HLRBRep.new_HLRBRep_TheExactInterCSurf(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Perform(self, *args):
        """
        Perform(HLRBRep_TheExactInterCSurf self, Standard_Real const U, Standard_Real const V, Standard_Real const W, math_FunctionSetRoot Rsnld, Standard_Real const u0, Standard_Real const v0, Standard_Real const u1, Standard_Real const v1, Standard_Real const w0, Standard_Real const w1)

        compute the solution
        it's possible to write to optimize:
        IntImp_IntCS inter(S1,C1,Toltangency)
        math_FunctionSetRoot rsnld(Inter.function())
        while ...{
        u=...
        v=...
        w=...
        inter.Perform(u,v,w,rsnld)
        }
        or
        IntImp_IntCS inter(Toltangency)
        inter.SetSurface(S);
        math_FunctionSetRoot rsnld(Inter.function())
        while ...{
        C=...
        inter.SetCurve(C);
        u=...
        v=...
        w=...
        inter.Perform(u,v,w,rsnld)
        }

        :type U: float
        :type V: float
        :type W: float
        :type Rsnld: OCC.wrapper.math.math_FunctionSetRoot
        :type u0: float
        :type v0: float
        :type u1: float
        :type v1: float
        :type w0: float
        :type w1: float

        """
        return _HLRBRep.HLRBRep_TheExactInterCSurf_Perform(self, *args)


    def IsDone(self, *args):
        """
        IsDone(HLRBRep_TheExactInterCSurf self) -> Standard_Boolean

        Returns TRUE if the creation completed without failure.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _HLRBRep.HLRBRep_TheExactInterCSurf_IsDone(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(HLRBRep_TheExactInterCSurf self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _HLRBRep.HLRBRep_TheExactInterCSurf_IsEmpty(self, *args)


    def Point(self, *args):
        """
        returns the intersection point
        The exception NotDone is raised if IsDone is false.
        The exception DomainError is raised if IsEmpty is true.

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        res = _HLRBRep.HLRBRep_TheExactInterCSurf_Point(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ParameterOnCurve(self, *args):
        """
        ParameterOnCurve(HLRBRep_TheExactInterCSurf self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _HLRBRep.HLRBRep_TheExactInterCSurf_ParameterOnCurve(self, *args)


    def ParameterOnSurface(self, *args):
        """
        ParameterOnSurface(HLRBRep_TheExactInterCSurf self)

        :type U: float
        :type V: float

        """
        return _HLRBRep.HLRBRep_TheExactInterCSurf_ParameterOnSurface(self, *args)


    def Function(self, *args):
        """
        Function(HLRBRep_TheExactInterCSurf self) -> HLRBRep_TheCSFunctionOfInterCSurf

        return the math function which
        is used to compute the intersection

        :rtype: OCC.wrapper.HLRBRep.HLRBRep_TheCSFunctionOfInterCSurf

        """
        return _HLRBRep.HLRBRep_TheExactInterCSurf_Function(self, *args)

    __swig_destroy__ = _HLRBRep.delete_HLRBRep_TheExactInterCSurf
HLRBRep_TheExactInterCSurf_swigregister = _HLRBRep.HLRBRep_TheExactInterCSurf_swigregister
HLRBRep_TheExactInterCSurf_swigregister(HLRBRep_TheExactInterCSurf)

class HLRBRep_CLProps(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(HLRBRep_CLProps self, HLRBRep_Curve const *& C, Standard_Integer const N, Standard_Real const Resolution) -> HLRBRep_CLProps
        __init__(HLRBRep_CLProps self, HLRBRep_Curve const *& C, Standard_Real const U, Standard_Integer const N, Standard_Real const Resolution) -> HLRBRep_CLProps
        __init__(HLRBRep_CLProps self, Standard_Integer const N, Standard_Real const Resolution) -> HLRBRep_CLProps

        Same as previous constructor but here the parameter is
        set to the value <U> and the curve is set
        with SetCurve.
        the curve can have a empty constructor
        All the computations done will be related to <C> and <U>
        when the functions "set" will be done.

        :type N: int
        :type Resolution: float

        """
        this = _HLRBRep.new_HLRBRep_CLProps(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def SetParameter(self, *args):
        """
        SetParameter(HLRBRep_CLProps self, Standard_Real const U)

        Initializes the local properties of the curve
        for the parameter value <U>.

        :type U: float

        """
        return _HLRBRep.HLRBRep_CLProps_SetParameter(self, *args)


    def SetCurve(self, *args):
        """
        SetCurve(HLRBRep_CLProps self, HLRBRep_Curve const *& C)

        Initializes the local properties of the curve
        for the new curve.

        :type C: OCC.wrapper.HLRBRep.HLRBRep_Curve

        """
        return _HLRBRep.HLRBRep_CLProps_SetCurve(self, *args)


    def Value(self, *args):
        """
        Returns the Point.

        :rtype: OCC.wrapper.gp.gp_Pnt2d

        """
        res = _HLRBRep.HLRBRep_CLProps_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def D1(self, *args):
        """
        Returns the first derivative.
        The derivative is computed if it has not been yet.

        :rtype: OCC.wrapper.gp.gp_Vec2d

        """
        res = _HLRBRep.HLRBRep_CLProps_D1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def D2(self, *args):
        """
        Returns the second derivative.
        The derivative is computed if it has not been yet.

        :rtype: OCC.wrapper.gp.gp_Vec2d

        """
        res = _HLRBRep.HLRBRep_CLProps_D2(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def D3(self, *args):
        """
        Returns the third derivative.
        The derivative is computed if it has not been yet.

        :rtype: OCC.wrapper.gp.gp_Vec2d

        """
        res = _HLRBRep.HLRBRep_CLProps_D3(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def IsTangentDefined(self, *args):
        """
        IsTangentDefined(HLRBRep_CLProps self) -> Standard_Boolean

        Returns True if the tangent is defined.
        For example, the tangent is not defined if the
        three first derivatives are all null.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _HLRBRep.HLRBRep_CLProps_IsTangentDefined(self, *args)


    def Tangent(self, *args):
        """
        Tangent(HLRBRep_CLProps self, gp_Dir2d D)

        output  the tangent direction <D>

        :type D: OCC.wrapper.gp.gp_Dir2d

        """
        return _HLRBRep.HLRBRep_CLProps_Tangent(self, *args)


    def Curvature(self, *args):
        """
        Curvature(HLRBRep_CLProps self) -> Standard_Real

        Returns the curvature.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _HLRBRep.HLRBRep_CLProps_Curvature(self, *args)


    def Normal(self, *args):
        """
        Normal(HLRBRep_CLProps self, gp_Dir2d N)

        Returns the normal direction <N>.

        :type N: OCC.wrapper.gp.gp_Dir2d

        """
        return _HLRBRep.HLRBRep_CLProps_Normal(self, *args)


    def CentreOfCurvature(self, *args):
        """
        CentreOfCurvature(HLRBRep_CLProps self, gp_Pnt2d P)

        Returns the centre of curvature <P>.

        :type P: OCC.wrapper.gp.gp_Pnt2d

        """
        return _HLRBRep.HLRBRep_CLProps_CentreOfCurvature(self, *args)

    __swig_destroy__ = _HLRBRep.delete_HLRBRep_CLProps
HLRBRep_CLProps_swigregister = _HLRBRep.HLRBRep_CLProps_swigregister
HLRBRep_CLProps_swigregister(HLRBRep_CLProps)

class Handle_HLRBRep_Algo(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_HLRBRep_Algo self)

        Nullify the handle


        """
        return _HLRBRep.Handle_HLRBRep_Algo_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_HLRBRep_Algo self) -> bool

        Check for being null

        :rtype: bool

        """
        return _HLRBRep.Handle_HLRBRep_Algo_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_HLRBRep_Algo self, HLRBRep_Algo thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _HLRBRep.Handle_HLRBRep_Algo_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_HLRBRep_Algo self, Handle_HLRBRep_Algo theHandle) -> Handle_HLRBRep_Algo
        assign(Handle_HLRBRep_Algo self, HLRBRep_Algo thePtr) -> Handle_HLRBRep_Algo
        assign(Handle_HLRBRep_Algo self, Handle_HLRBRep_Algo theHandle) -> Handle_HLRBRep_Algo

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _HLRBRep.Handle_HLRBRep_Algo_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_HLRBRep_Algo self) -> HLRBRep_Algo

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _HLRBRep.Handle_HLRBRep_Algo_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_HLRBRep_Algo self) -> HLRBRep_Algo

        Member access operator (note non-const)

        :rtype: T *

        """
        return _HLRBRep.Handle_HLRBRep_Algo___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_HLRBRep_Algo self) -> HLRBRep_Algo

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _HLRBRep.Handle_HLRBRep_Algo___ref__(self, *args)


    def __hash__(self):
        return _HLRBRep.Handle_HLRBRep_Algo___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _HLRBRep.Handle_HLRBRep_Algo___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _HLRBRep.new_Handle_HLRBRep_Algo(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_HLRBRep.Handle_HLRBRep_Algo_DownCast)
    __swig_destroy__ = _HLRBRep.delete_Handle_HLRBRep_Algo

    def Add(self, *args):
        """
        Add(Handle_HLRBRep_Algo self, TopoDS_Shape S, Handle_Standard_Transient SData, Standard_Integer const nbIso=0)
        Add(Handle_HLRBRep_Algo self, TopoDS_Shape S, Standard_Integer const nbIso=0)

        Adds the shape S to this framework, and
        specifies the number of isoparameters nbiso desired in visualizing S.
        You may add as many shapes as you wish. Use the function Add once for each shape.

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :type nbIso: int

        """
        return _HLRBRep.Handle_HLRBRep_Algo_Add(self, *args)


    def Index(self, *args):
        """
        Index(Handle_HLRBRep_Algo self, TopoDS_Shape S) -> Standard_Integer

        return  the index  of  the  Shape <S>  and
        return 0 if the Shape <S> is not found.

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _HLRBRep.Handle_HLRBRep_Algo_Index(self, *args)


    def OutLinedShapeNullify(self, *args):
        """
        OutLinedShapeNullify(Handle_HLRBRep_Algo self)

        nullify all the results of OutLiner from HLRTopoBRep.


        """
        return _HLRBRep.Handle_HLRBRep_Algo_OutLinedShapeNullify(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_HLRBRep_Algo self) -> char const *

        :rtype: const char *

        """
        return _HLRBRep.Handle_HLRBRep_Algo_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _HLRBRep.Handle_HLRBRep_Algo_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _HLRBRep.Handle_HLRBRep_Algo_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Projector(self, *args):
        """
        Projector(Handle_HLRBRep_Algo self, HLRAlgo_Projector P)
        Projector(Handle_HLRBRep_Algo self) -> HLRAlgo_Projector

        set the projector.

        :rtype: OCC.wrapper.HLRAlgo.HLRAlgo_Projector

        """
        return _HLRBRep.Handle_HLRBRep_Algo_Projector(self, *args)


    def Update(self, *args):
        """
        Update(Handle_HLRBRep_Algo self)

        update the DataStructure.


        """
        return _HLRBRep.Handle_HLRBRep_Algo_Update(self, *args)


    def Load(self, *args):
        """
        Load(Handle_HLRBRep_Algo self, Handle_HLRTopoBRep_OutLiner S, Handle_Standard_Transient SData, Standard_Integer const nbIso=0)
        Load(Handle_HLRBRep_Algo self, Handle_HLRTopoBRep_OutLiner S, Standard_Integer const nbIso=0)

        add the shape <S>.

        :type S: OCC.wrapper.HLRTopoBRep.Handle_HLRTopoBRep_OutLiner
        :type nbIso: int

        """
        return _HLRBRep.Handle_HLRBRep_Algo_Load(self, *args)


    def Remove(self, *args):
        """
        Remove(Handle_HLRBRep_Algo self, Standard_Integer const I)

        remove the Shape of Index <I>.

        :type I: int

        """
        return _HLRBRep.Handle_HLRBRep_Algo_Remove(self, *args)


    def ShapeData(self, *args):
        """
        ShapeData(Handle_HLRBRep_Algo self, Standard_Integer const I, Handle_Standard_Transient SData)

        Change the Shape Data of the Shape of index <I>.

        :type I: int
        :type SData: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _HLRBRep.Handle_HLRBRep_Algo_ShapeData(self, *args)


    def SeqOfShapeBounds(self, *args):
        """
        SeqOfShapeBounds(Handle_HLRBRep_Algo self) -> NCollection_Sequence_HLRBRep_ShapeBounds

        :rtype: OCC.wrapper.HLRBRep.HLRBRep_SeqOfShapeBounds

        """
        return _HLRBRep.Handle_HLRBRep_Algo_SeqOfShapeBounds(self, *args)


    def NbShapes(self, *args):
        """
        NbShapes(Handle_HLRBRep_Algo self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _HLRBRep.Handle_HLRBRep_Algo_NbShapes(self, *args)


    def ShapeBounds(self, *args):
        """
        ShapeBounds(Handle_HLRBRep_Algo self, Standard_Integer const I) -> HLRBRep_ShapeBounds

        :type I: int
        :rtype: OCC.wrapper.HLRBRep.HLRBRep_ShapeBounds

        """
        return _HLRBRep.Handle_HLRBRep_Algo_ShapeBounds(self, *args)


    def InitEdgeStatus(self, *args):
        """
        InitEdgeStatus(Handle_HLRBRep_Algo self)

        init the status of the selected edges depending of
        the back faces of a closed shell.


        """
        return _HLRBRep.Handle_HLRBRep_Algo_InitEdgeStatus(self, *args)


    def Select(self, *args):
        """
        Select(Handle_HLRBRep_Algo self)
        Select(Handle_HLRBRep_Algo self, Standard_Integer const I)

        select  only   the Shape of index <I>.

        :type I: int

        """
        return _HLRBRep.Handle_HLRBRep_Algo_Select(self, *args)


    def SelectEdge(self, *args):
        """
        SelectEdge(Handle_HLRBRep_Algo self, Standard_Integer const I)

        select only the edges of the Shape <S>.

        :type I: int

        """
        return _HLRBRep.Handle_HLRBRep_Algo_SelectEdge(self, *args)


    def SelectFace(self, *args):
        """
        SelectFace(Handle_HLRBRep_Algo self, Standard_Integer const I)

        select only the faces of the Shape <S>.

        :type I: int

        """
        return _HLRBRep.Handle_HLRBRep_Algo_SelectFace(self, *args)


    def ShowAll(self, *args):
        """
        ShowAll(Handle_HLRBRep_Algo self)
        ShowAll(Handle_HLRBRep_Algo self, Standard_Integer const I)

        set to visible all the edges of the Shape <S>.

        :type I: int

        """
        return _HLRBRep.Handle_HLRBRep_Algo_ShowAll(self, *args)


    def HideAll(self, *args):
        """
        HideAll(Handle_HLRBRep_Algo self)
        HideAll(Handle_HLRBRep_Algo self, Standard_Integer const I)

        set to  hide all the  edges of the  Shape <S>.

        :type I: int

        """
        return _HLRBRep.Handle_HLRBRep_Algo_HideAll(self, *args)


    def PartialHide(self, *args):
        """
        PartialHide(Handle_HLRBRep_Algo self)

        own hiding  of all the shapes of the DataStructure
        without hiding by each other.


        """
        return _HLRBRep.Handle_HLRBRep_Algo_PartialHide(self, *args)


    def Hide(self, *args):
        """
        Hide(Handle_HLRBRep_Algo self)
        Hide(Handle_HLRBRep_Algo self, Standard_Integer const I)
        Hide(Handle_HLRBRep_Algo self, Standard_Integer const I, Standard_Integer const J)

        hide the Shape <S1> by the shape <S2>.

        :type I: int
        :type J: int

        """
        return _HLRBRep.Handle_HLRBRep_Algo_Hide(self, *args)


    def Debug(self, *args):
        """
        Debug(Handle_HLRBRep_Algo self, Standard_Boolean const deb)
        Debug(Handle_HLRBRep_Algo self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _HLRBRep.Handle_HLRBRep_Algo_Debug(self, *args)


    def DataStructure(self, *args):
        """
        DataStructure(Handle_HLRBRep_Algo self) -> Handle_HLRBRep_Data

        :rtype: OCC.wrapper.HLRBRep.Handle_HLRBRep_Data

        """
        return _HLRBRep.Handle_HLRBRep_Algo_DataStructure(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_HLRBRep_Algo self)

        Memory deallocator for transient classes


        """
        return _HLRBRep.Handle_HLRBRep_Algo_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_HLRBRep_Algo self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_HLRBRep_Algo self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _HLRBRep.Handle_HLRBRep_Algo_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_HLRBRep_Algo self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_HLRBRep_Algo self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _HLRBRep.Handle_HLRBRep_Algo_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_HLRBRep_Algo self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _HLRBRep.Handle_HLRBRep_Algo_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_HLRBRep_Algo self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _HLRBRep.Handle_HLRBRep_Algo_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_HLRBRep_Algo self)

        Increments the reference counter of this object


        """
        return _HLRBRep.Handle_HLRBRep_Algo_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_HLRBRep_Algo self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _HLRBRep.Handle_HLRBRep_Algo_DecrementRefCounter(self, *args)

Handle_HLRBRep_Algo_swigregister = _HLRBRep.Handle_HLRBRep_Algo_swigregister
Handle_HLRBRep_Algo_swigregister(Handle_HLRBRep_Algo)

def Handle_HLRBRep_Algo_DownCast(thing):
    return _HLRBRep.Handle_HLRBRep_Algo_DownCast(thing)
Handle_HLRBRep_Algo_DownCast = _HLRBRep.Handle_HLRBRep_Algo_DownCast

class HLRBRep_MyImpParToolOfTheIntersectorOfTheIntConicCurveOfCInter(math.math_FunctionWithDerivative):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(HLRBRep_MyImpParToolOfTheIntersectorOfTheIntConicCurveOfCInter self, IntCurve_IConicTool IT, Standard_Address const & PC) -> HLRBRep_MyImpParToolOfTheIntersectorOfTheIntConicCurveOfCInter

        Constructor of the class.

        :type IT: OCC.wrapper.IntCurve.IntCurve_IConicTool
        :type PC: OCC.wrapper.Standard.Standard_Address

        """
        this = _HLRBRep.new_HLRBRep_MyImpParToolOfTheIntersectorOfTheIntConicCurveOfCInter(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Value(self, *args):
        """
        Value(HLRBRep_MyImpParToolOfTheIntersectorOfTheIntConicCurveOfCInter self, Standard_Real const Param) -> Standard_Boolean

        Computes the value of the signed distance between
        the implicit curve and the point at parameter Param
        on the parametrised curve.

        :type Param: float
        :type F: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _HLRBRep.HLRBRep_MyImpParToolOfTheIntersectorOfTheIntConicCurveOfCInter_Value(self, *args)


    def Derivative(self, *args):
        """
        Derivative(HLRBRep_MyImpParToolOfTheIntersectorOfTheIntConicCurveOfCInter self, Standard_Real const Param) -> Standard_Boolean

        Computes the derivative of the previous function at
        parameter Param.

        :type Param: float
        :type D: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _HLRBRep.HLRBRep_MyImpParToolOfTheIntersectorOfTheIntConicCurveOfCInter_Derivative(self, *args)


    def Values(self, *args):
        """
        Values(HLRBRep_MyImpParToolOfTheIntersectorOfTheIntConicCurveOfCInter self, Standard_Real const Param) -> Standard_Boolean

        Computes the value and the derivative of the function.

        :type Param: float
        :type F: float
        :type D: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _HLRBRep.HLRBRep_MyImpParToolOfTheIntersectorOfTheIntConicCurveOfCInter_Values(self, *args)

    __swig_destroy__ = _HLRBRep.delete_HLRBRep_MyImpParToolOfTheIntersectorOfTheIntConicCurveOfCInter
HLRBRep_MyImpParToolOfTheIntersectorOfTheIntConicCurveOfCInter_swigregister = _HLRBRep.HLRBRep_MyImpParToolOfTheIntersectorOfTheIntConicCurveOfCInter_swigregister
HLRBRep_MyImpParToolOfTheIntersectorOfTheIntConicCurveOfCInter_swigregister(HLRBRep_MyImpParToolOfTheIntersectorOfTheIntConicCurveOfCInter)

class HLRBRep_EdgeIList(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def AddInterference(*args):
        """
        AddInterference(HLRAlgo_InterferenceList & IL, HLRAlgo_Interference I, HLRBRep_EdgeInterferenceTool T)

        Add the interference <I> to the list <IL>.

        :type IL: OCC.wrapper.HLRAlgo.HLRAlgo_InterferenceList
        :type I: OCC.wrapper.HLRAlgo.HLRAlgo_Interference
        :type T: OCC.wrapper.HLRBRep.HLRBRep_EdgeInterferenceTool

        """
        return _HLRBRep.HLRBRep_EdgeIList_AddInterference(*args)

    AddInterference = staticmethod(AddInterference)

    def ProcessComplex(*args):
        """
        ProcessComplex(HLRAlgo_InterferenceList & IL, HLRBRep_EdgeInterferenceTool T)

        Process complex transitions on the list IL.

        :type IL: OCC.wrapper.HLRAlgo.HLRAlgo_InterferenceList
        :type T: OCC.wrapper.HLRBRep.HLRBRep_EdgeInterferenceTool

        """
        return _HLRBRep.HLRBRep_EdgeIList_ProcessComplex(*args)

    ProcessComplex = staticmethod(ProcessComplex)

    def __init__(self):
        this = _HLRBRep.new_HLRBRep_EdgeIList()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _HLRBRep.delete_HLRBRep_EdgeIList
HLRBRep_EdgeIList_swigregister = _HLRBRep.HLRBRep_EdgeIList_swigregister
HLRBRep_EdgeIList_swigregister(HLRBRep_EdgeIList)

def HLRBRep_EdgeIList_AddInterference(*args):
    """
    HLRBRep_EdgeIList_AddInterference(HLRAlgo_InterferenceList & IL, HLRAlgo_Interference I, HLRBRep_EdgeInterferenceTool T)

    Add the interference <I> to the list <IL>.

    :type IL: OCC.wrapper.HLRAlgo.HLRAlgo_InterferenceList
    :type I: OCC.wrapper.HLRAlgo.HLRAlgo_Interference
    :type T: OCC.wrapper.HLRBRep.HLRBRep_EdgeInterferenceTool

    """
    return _HLRBRep.HLRBRep_EdgeIList_AddInterference(*args)

def HLRBRep_EdgeIList_ProcessComplex(*args):
    """
    HLRBRep_EdgeIList_ProcessComplex(HLRAlgo_InterferenceList & IL, HLRBRep_EdgeInterferenceTool T)

    Process complex transitions on the list IL.

    :type IL: OCC.wrapper.HLRAlgo.HLRAlgo_InterferenceList
    :type T: OCC.wrapper.HLRBRep.HLRBRep_EdgeInterferenceTool

    """
    return _HLRBRep.HLRBRep_EdgeIList_ProcessComplex(*args)

class HLRBRep_TheProjPCurOfCInter(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def FindParameter(*args):
        """
        FindParameter(Standard_Address const & C, gp_Pnt2d Pnt, Standard_Real const Tol) -> Standard_Real
        FindParameter(Standard_Address const & C, gp_Pnt2d Pnt, Standard_Real const LowParameter, Standard_Real const HighParameter, Standard_Real const Tol) -> Standard_Real

        Returns the parameter V of the point on the
        parametric curve corresponding to the Point Pnt.
        The Correspondance between Pnt and the point P(V)
        on the parametric curve must be coherent with the
        way of determination of the signed distance
        between a point and the implicit curve.
        Tol is the tolerance on the distance between a point
        and the parametrised curve.
        LowParameter and HighParameter give the
        boundaries of the interval in wich the parameter
        certainly lies. These parameters are given to
        implement a more efficient algoritm. So, it is not
        necessary to check that the returned value verifies
        LowParameter <= Value <= HighParameter.

        :type C: OCC.wrapper.Standard.Standard_Address
        :type Pnt: OCC.wrapper.gp.gp_Pnt2d
        :type LowParameter: float
        :type HighParameter: float
        :type Tol: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _HLRBRep.HLRBRep_TheProjPCurOfCInter_FindParameter(*args)

    FindParameter = staticmethod(FindParameter)

    def __init__(self):
        this = _HLRBRep.new_HLRBRep_TheProjPCurOfCInter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _HLRBRep.delete_HLRBRep_TheProjPCurOfCInter
HLRBRep_TheProjPCurOfCInter_swigregister = _HLRBRep.HLRBRep_TheProjPCurOfCInter_swigregister
HLRBRep_TheProjPCurOfCInter_swigregister(HLRBRep_TheProjPCurOfCInter)

def HLRBRep_TheProjPCurOfCInter_FindParameter(*args):
    """
    FindParameter(Standard_Address const & C, gp_Pnt2d Pnt, Standard_Real const Tol) -> Standard_Real
    HLRBRep_TheProjPCurOfCInter_FindParameter(Standard_Address const & C, gp_Pnt2d Pnt, Standard_Real const LowParameter, Standard_Real const HighParameter, Standard_Real const Tol) -> Standard_Real

    Returns the parameter V of the point on the
    parametric curve corresponding to the Point Pnt.
    The Correspondance between Pnt and the point P(V)
    on the parametric curve must be coherent with the
    way of determination of the signed distance
    between a point and the implicit curve.
    Tol is the tolerance on the distance between a point
    and the parametrised curve.
    LowParameter and HighParameter give the
    boundaries of the interval in wich the parameter
    certainly lies. These parameters are given to
    implement a more efficient algoritm. So, it is not
    necessary to check that the returned value verifies
    LowParameter <= Value <= HighParameter.

    :type C: OCC.wrapper.Standard.Standard_Address
    :type Pnt: OCC.wrapper.gp.gp_Pnt2d
    :type LowParameter: float
    :type HighParameter: float
    :type Tol: float
    :rtype: OCC.wrapper.Standard.Standard_Real

    """
    return _HLRBRep.HLRBRep_TheProjPCurOfCInter_FindParameter(*args)

class HLRBRep_TheQuadCurvFuncOfTheQuadCurvExactInterCSurf(math.math_FunctionWithDerivative):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(HLRBRep_TheQuadCurvFuncOfTheQuadCurvExactInterCSurf self, IntSurf_Quadric Q, gp_Lin C) -> HLRBRep_TheQuadCurvFuncOfTheQuadCurvExactInterCSurf

        Create the function.

        :type Q: OCC.wrapper.IntSurf.IntSurf_Quadric
        :type C: OCC.wrapper.gp.gp_Lin

        """
        this = _HLRBRep.new_HLRBRep_TheQuadCurvFuncOfTheQuadCurvExactInterCSurf(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Value(self, *args):
        """
        Value(HLRBRep_TheQuadCurvFuncOfTheQuadCurvExactInterCSurf self, Standard_Real const Param) -> Standard_Boolean

        Computes the value of the signed  distance between
        the  implicit surface and  the point  at parameter
        Param on the parametrised curve.
        Value always returns True.

        :type Param: float
        :type F: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _HLRBRep.HLRBRep_TheQuadCurvFuncOfTheQuadCurvExactInterCSurf_Value(self, *args)


    def Derivative(self, *args):
        """
        Derivative(HLRBRep_TheQuadCurvFuncOfTheQuadCurvExactInterCSurf self, Standard_Real const Param) -> Standard_Boolean

        Computes the derivative of the previous function at
        parameter Param.
        Derivative always returns True.

        :type Param: float
        :type D: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _HLRBRep.HLRBRep_TheQuadCurvFuncOfTheQuadCurvExactInterCSurf_Derivative(self, *args)


    def Values(self, *args):
        """
        Values(HLRBRep_TheQuadCurvFuncOfTheQuadCurvExactInterCSurf self, Standard_Real const Param) -> Standard_Boolean

        Computes the value and the derivative of the function.
        returns True.

        :type Param: float
        :type F: float
        :type D: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _HLRBRep.HLRBRep_TheQuadCurvFuncOfTheQuadCurvExactInterCSurf_Values(self, *args)

    __swig_destroy__ = _HLRBRep.delete_HLRBRep_TheQuadCurvFuncOfTheQuadCurvExactInterCSurf
HLRBRep_TheQuadCurvFuncOfTheQuadCurvExactInterCSurf_swigregister = _HLRBRep.HLRBRep_TheQuadCurvFuncOfTheQuadCurvExactInterCSurf_swigregister
HLRBRep_TheQuadCurvFuncOfTheQuadCurvExactInterCSurf_swigregister(HLRBRep_TheQuadCurvFuncOfTheQuadCurvExactInterCSurf)

class HLRBRep_SLPropsATool(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Value(*args):
        """
        Value(Standard_Address const A, Standard_Real const U, Standard_Real const V, gp_Pnt P)

        Computes the point  <P> of 	parameter <U> and <V>
        on the Surface <A>.

        :type A: OCC.wrapper.Standard.Standard_Address
        :type U: float
        :type V: float
        :type P: OCC.wrapper.gp.gp_Pnt

        """
        return _HLRBRep.HLRBRep_SLPropsATool_Value(*args)

    Value = staticmethod(Value)

    def D1(*args):
        """
        D1(Standard_Address const A, Standard_Real const U, Standard_Real const V, gp_Pnt P, gp_Vec D1U, gp_Vec D1V)

        Computes the point <P>  and first derivative <D1*>
        of parameter <U> and <V> on the Surface <A>.

        :type A: OCC.wrapper.Standard.Standard_Address
        :type U: float
        :type V: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type D1U: OCC.wrapper.gp.gp_Vec
        :type D1V: OCC.wrapper.gp.gp_Vec

        """
        return _HLRBRep.HLRBRep_SLPropsATool_D1(*args)

    D1 = staticmethod(D1)

    def D2(*args):
        """
        D2(Standard_Address const A, Standard_Real const U, Standard_Real const V, gp_Pnt P, gp_Vec D1U, gp_Vec D1V, gp_Vec D2U, gp_Vec D2V, gp_Vec DUV)

        Computes the point <P>, the first derivative <D1*>
        and second  derivative <D2*> of parameter  <U> and
        <V> on the Surface <A>.

        :type A: OCC.wrapper.Standard.Standard_Address
        :type U: float
        :type V: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type D1U: OCC.wrapper.gp.gp_Vec
        :type D1V: OCC.wrapper.gp.gp_Vec
        :type D2U: OCC.wrapper.gp.gp_Vec
        :type D2V: OCC.wrapper.gp.gp_Vec
        :type DUV: OCC.wrapper.gp.gp_Vec

        """
        return _HLRBRep.HLRBRep_SLPropsATool_D2(*args)

    D2 = staticmethod(D2)

    def DN(*args):
        """
        DN(Standard_Address const A, Standard_Real const U, Standard_Real const V, Standard_Integer const Nu, Standard_Integer const Nv) -> gp_Vec

        :type A: OCC.wrapper.Standard.Standard_Address
        :type U: float
        :type V: float
        :type Nu: int
        :type Nv: int
        :rtype: OCC.wrapper.gp.gp_Vec

        """
        return _HLRBRep.HLRBRep_SLPropsATool_DN(*args)

    DN = staticmethod(DN)

    def Continuity(*args):
        """
        Continuity(Standard_Address const A) -> Standard_Integer

        returns the order of   continuity of the   Surface
        <A>.  returns  1   :  first  derivative    only is
        computable returns 2 : first and second derivative
        only are computable.

        :type A: OCC.wrapper.Standard.Standard_Address
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _HLRBRep.HLRBRep_SLPropsATool_Continuity(*args)

    Continuity = staticmethod(Continuity)

    def Bounds(*args):
        """
        Bounds(Standard_Address const A)

        returns the bounds of the Surface.

        :type A: OCC.wrapper.Standard.Standard_Address
        :type U1: float
        :type V1: float
        :type U2: float
        :type V2: float

        """
        return _HLRBRep.HLRBRep_SLPropsATool_Bounds(*args)

    Bounds = staticmethod(Bounds)

    def __init__(self):
        this = _HLRBRep.new_HLRBRep_SLPropsATool()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _HLRBRep.delete_HLRBRep_SLPropsATool
HLRBRep_SLPropsATool_swigregister = _HLRBRep.HLRBRep_SLPropsATool_swigregister
HLRBRep_SLPropsATool_swigregister(HLRBRep_SLPropsATool)

def HLRBRep_SLPropsATool_Value(*args):
    """
    HLRBRep_SLPropsATool_Value(Standard_Address const A, Standard_Real const U, Standard_Real const V, gp_Pnt P)

    Computes the point  <P> of 	parameter <U> and <V>
    on the Surface <A>.

    :type A: OCC.wrapper.Standard.Standard_Address
    :type U: float
    :type V: float
    :type P: OCC.wrapper.gp.gp_Pnt

    """
    return _HLRBRep.HLRBRep_SLPropsATool_Value(*args)

def HLRBRep_SLPropsATool_D1(*args):
    """
    HLRBRep_SLPropsATool_D1(Standard_Address const A, Standard_Real const U, Standard_Real const V, gp_Pnt P, gp_Vec D1U, gp_Vec D1V)

    Computes the point <P>  and first derivative <D1*>
    of parameter <U> and <V> on the Surface <A>.

    :type A: OCC.wrapper.Standard.Standard_Address
    :type U: float
    :type V: float
    :type P: OCC.wrapper.gp.gp_Pnt
    :type D1U: OCC.wrapper.gp.gp_Vec
    :type D1V: OCC.wrapper.gp.gp_Vec

    """
    return _HLRBRep.HLRBRep_SLPropsATool_D1(*args)

def HLRBRep_SLPropsATool_D2(*args):
    """
    HLRBRep_SLPropsATool_D2(Standard_Address const A, Standard_Real const U, Standard_Real const V, gp_Pnt P, gp_Vec D1U, gp_Vec D1V, gp_Vec D2U, gp_Vec D2V, gp_Vec DUV)

    Computes the point <P>, the first derivative <D1*>
    and second  derivative <D2*> of parameter  <U> and
    <V> on the Surface <A>.

    :type A: OCC.wrapper.Standard.Standard_Address
    :type U: float
    :type V: float
    :type P: OCC.wrapper.gp.gp_Pnt
    :type D1U: OCC.wrapper.gp.gp_Vec
    :type D1V: OCC.wrapper.gp.gp_Vec
    :type D2U: OCC.wrapper.gp.gp_Vec
    :type D2V: OCC.wrapper.gp.gp_Vec
    :type DUV: OCC.wrapper.gp.gp_Vec

    """
    return _HLRBRep.HLRBRep_SLPropsATool_D2(*args)

def HLRBRep_SLPropsATool_DN(*args):
    """
    HLRBRep_SLPropsATool_DN(Standard_Address const A, Standard_Real const U, Standard_Real const V, Standard_Integer const Nu, Standard_Integer const Nv) -> gp_Vec

    :type A: OCC.wrapper.Standard.Standard_Address
    :type U: float
    :type V: float
    :type Nu: int
    :type Nv: int
    :rtype: OCC.wrapper.gp.gp_Vec

    """
    return _HLRBRep.HLRBRep_SLPropsATool_DN(*args)

def HLRBRep_SLPropsATool_Continuity(*args):
    """
    HLRBRep_SLPropsATool_Continuity(Standard_Address const A) -> Standard_Integer

    returns the order of   continuity of the   Surface
    <A>.  returns  1   :  first  derivative    only is
    computable returns 2 : first and second derivative
    only are computable.

    :type A: OCC.wrapper.Standard.Standard_Address
    :rtype: OCC.wrapper.Standard.Standard_Integer

    """
    return _HLRBRep.HLRBRep_SLPropsATool_Continuity(*args)

def HLRBRep_SLPropsATool_Bounds(*args):
    """
    HLRBRep_SLPropsATool_Bounds(Standard_Address const A)

    returns the bounds of the Surface.

    :type A: OCC.wrapper.Standard.Standard_Address
    :type U1: float
    :type V1: float
    :type U2: float
    :type V2: float

    """
    return _HLRBRep.HLRBRep_SLPropsATool_Bounds(*args)

class NCollection_Array1_HLRBRep_EdgeData(object):
    """
    Purpose:     The class Array1 represents unidimensional arrays 
    of fixed size known at run time. 
    The range of the index is user defined.
    An array1 can be constructed with a "C array".
    This functionality is useful to call methods expecting
    an Array1. It allows to carry the bounds inside the arrays.

    Examples:    Item tab[100]; //  An example with a C array
    Array1OfItem ttab (tab[0],1,100);

    Array1OfItem tttab (ttab(10),10,20); // a slice of ttab

    If you want to reindex an array from 1 to Length do :

    Array1 tab1(tab(tab.Lower()),1,tab.Length());

    Warning:     Programs client of such a class must be independant
    of the range of the first element. Then, a C++ for
    loop must be written like this

    for (i = A.Lower(); i <= A.Upper(); i++)

    Changes:     In  comparison  to  TCollection  the  flag  isAllocated  was
    renamed into myDeletable (alike in  the Array2).  For naming
    compatibility the method IsAllocated remained in class along
    with IsDeletable.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Array1_HLRBRep_EdgeData self) -> NCollection_Array1< HLRBRep_EdgeData >::iterator

        Returns an iterator pointing to the first element in the array.

        :rtype: iterator

        """
        return _HLRBRep.NCollection_Array1_HLRBRep_EdgeData_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Array1_HLRBRep_EdgeData self) -> NCollection_Array1< HLRBRep_EdgeData >::iterator

        Returns an iterator referring to the past-the-end element in the array.

        :rtype: iterator

        """
        return _HLRBRep.NCollection_Array1_HLRBRep_EdgeData_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Array1_HLRBRep_EdgeData self) -> NCollection_Array1< HLRBRep_EdgeData >::const_iterator

        Returns a const iterator pointing to the first element in the array.

        :rtype: const_iterator

        """
        return _HLRBRep.NCollection_Array1_HLRBRep_EdgeData_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Array1_HLRBRep_EdgeData self) -> NCollection_Array1< HLRBRep_EdgeData >::const_iterator

        Returns a const iterator referring to the past-the-end element in the array.

        :rtype: const_iterator

        """
        return _HLRBRep.NCollection_Array1_HLRBRep_EdgeData_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     The class Array1 represents unidimensional arrays 
        of fixed size known at run time. 
        The range of the index is user defined.
        An array1 can be constructed with a "C array".
        This functionality is useful to call methods expecting
        an Array1. It allows to carry the bounds inside the arrays.

        Examples:    Item tab[100]; //  An example with a C array
        Array1OfItem ttab (tab[0],1,100);

        Array1OfItem tttab (ttab(10),10,20); // a slice of ttab

        If you want to reindex an array from 1 to Length do :

        Array1 tab1(tab(tab.Lower()),1,tab.Length());

        Warning:     Programs client of such a class must be independant
        of the range of the first element. Then, a C++ for
        loop must be written like this

        for (i = A.Lower(); i <= A.Upper(); i++)

        Changes:     In  comparison  to  TCollection  the  flag  isAllocated  was
        renamed into myDeletable (alike in  the Array2).  For naming
        compatibility the method IsAllocated remained in class along
        with IsDeletable.
        """
        this = _HLRBRep.new_NCollection_Array1_HLRBRep_EdgeData(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(NCollection_Array1_HLRBRep_EdgeData self, HLRBRep_EdgeData theValue)

        Initialise the items with theValue

        :type theValue: const TheItemType &

        """
        return _HLRBRep.NCollection_Array1_HLRBRep_EdgeData_Init(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_Array1_HLRBRep_EdgeData self) -> Standard_Integer

        Size query

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _HLRBRep.NCollection_Array1_HLRBRep_EdgeData_Size(self, *args)


    def Length(self, *args):
        """
        Length(NCollection_Array1_HLRBRep_EdgeData self) -> Standard_Integer

        Length query (the same)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _HLRBRep.NCollection_Array1_HLRBRep_EdgeData_Length(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Array1_HLRBRep_EdgeData self) -> Standard_Boolean

        Return TRUE if array has zero length.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _HLRBRep.NCollection_Array1_HLRBRep_EdgeData_IsEmpty(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Array1_HLRBRep_EdgeData self) -> Standard_Integer

        Lower bound

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _HLRBRep.NCollection_Array1_HLRBRep_EdgeData_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Array1_HLRBRep_EdgeData self) -> Standard_Integer

        Upper bound

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _HLRBRep.NCollection_Array1_HLRBRep_EdgeData_Upper(self, *args)


    def IsDeletable(self, *args):
        """
        IsDeletable(NCollection_Array1_HLRBRep_EdgeData self) -> Standard_Boolean

        myDeletable flag

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _HLRBRep.NCollection_Array1_HLRBRep_EdgeData_IsDeletable(self, *args)


    def IsAllocated(self, *args):
        """
        IsAllocated(NCollection_Array1_HLRBRep_EdgeData self) -> Standard_Boolean

        IsAllocated flag - for naming compatibility

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _HLRBRep.NCollection_Array1_HLRBRep_EdgeData_IsAllocated(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Array1_HLRBRep_EdgeData self, NCollection_Array1_HLRBRep_EdgeData theOther) -> NCollection_Array1_HLRBRep_EdgeData

        Copies data of theOther array to this.
        This array should be pre-allocated and have the same length as theOther;
        otherwise exception Standard_DimensionMismatch is thrown.

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _HLRBRep.NCollection_Array1_HLRBRep_EdgeData_Assign(self, *args)


    def Move(self, *args):
        """
        Move(NCollection_Array1_HLRBRep_EdgeData self, NCollection_Array1_HLRBRep_EdgeData theOther) -> NCollection_Array1_HLRBRep_EdgeData

        Move assignment.
        This array will borrow all the data from theOther.
        The moved object will keep pointer to the memory buffer and
        range, but it will not free the buffer on destruction.

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _HLRBRep.NCollection_Array1_HLRBRep_EdgeData_Move(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Array1_HLRBRep_EdgeData self, NCollection_Array1_HLRBRep_EdgeData theOther) -> NCollection_Array1_HLRBRep_EdgeData
        assign(NCollection_Array1_HLRBRep_EdgeData self, NCollection_Array1_HLRBRep_EdgeData theOther) -> NCollection_Array1_HLRBRep_EdgeData

        Move assignment operator; @sa Move()

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1<TheItemType> &&
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _HLRBRep.NCollection_Array1_HLRBRep_EdgeData_assign(self, *args)


    def First(self, *args):
        """
        @return first element

        :rtype: const TheItemType &

        """
        res = _HLRBRep.NCollection_Array1_HLRBRep_EdgeData_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Array1_HLRBRep_EdgeData self) -> HLRBRep_EdgeData

        @return first element

        :rtype: TheItemType &

        """
        return _HLRBRep.NCollection_Array1_HLRBRep_EdgeData_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        @return last element

        :rtype: const TheItemType &

        """
        res = _HLRBRep.NCollection_Array1_HLRBRep_EdgeData_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Array1_HLRBRep_EdgeData self) -> HLRBRep_EdgeData

        @return last element

        :rtype: TheItemType &

        """
        return _HLRBRep.NCollection_Array1_HLRBRep_EdgeData_ChangeLast(self, *args)


    def Value(self, *args):
        """
        Constant value access

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _HLRBRep.NCollection_Array1_HLRBRep_EdgeData_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Array1_HLRBRep_EdgeData self, Standard_Integer const theIndex) -> HLRBRep_EdgeData

        Variable value access

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _HLRBRep.NCollection_Array1_HLRBRep_EdgeData_ChangeValue(self, *args)


    def __call__(self, *args):
        """
        operator() - alias to Value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _HLRBRep.NCollection_Array1_HLRBRep_EdgeData___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __getitem__(self, *args):
        """
        operator[] - alias to Value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _HLRBRep.NCollection_Array1_HLRBRep_EdgeData_at(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetValue(self, *args):
        """
        SetValue(NCollection_Array1_HLRBRep_EdgeData self, Standard_Integer const theIndex, HLRBRep_EdgeData theItem)

        Set value 

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _HLRBRep.NCollection_Array1_HLRBRep_EdgeData_SetValue(self, *args)


    def Resize(self, *args):
        """
        Resize(NCollection_Array1_HLRBRep_EdgeData self, Standard_Integer const theLower, Standard_Integer const theUpper, Standard_Boolean const theToCopyData)

        Resizes the array to specified bounds.
        No re-allocation will be done if length of array does not change,
        but existing values will not be discarded if theToCopyData set to FALSE.
        @param theLower new lower bound of array
        @param theUpper new upper bound of array
        @param theToCopyData flag to copy existing data into new array

        :type theLower: int
        :type theUpper: int
        :type theToCopyData: bool

        """
        return _HLRBRep.NCollection_Array1_HLRBRep_EdgeData_Resize(self, *args)

    __swig_destroy__ = _HLRBRep.delete_NCollection_Array1_HLRBRep_EdgeData
NCollection_Array1_HLRBRep_EdgeData_swigregister = _HLRBRep.NCollection_Array1_HLRBRep_EdgeData_swigregister
NCollection_Array1_HLRBRep_EdgeData_swigregister(NCollection_Array1_HLRBRep_EdgeData)


try:
	HLRBRep_Array1OfEData = NCollection_Array1_HLRBRep_EdgeData
except NameError:
	pass # does not exist, probably ignored

class HLRBRep_LineTool(object):
    """
    The  LineTool  class  provides  class  methods to
    access the methodes of the Line.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def FirstParameter(*args):
        """
        FirstParameter(gp_Lin C) -> Standard_Real

        :type C: OCC.wrapper.gp.gp_Lin
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _HLRBRep.HLRBRep_LineTool_FirstParameter(*args)

    FirstParameter = staticmethod(FirstParameter)

    def LastParameter(*args):
        """
        LastParameter(gp_Lin C) -> Standard_Real

        :type C: OCC.wrapper.gp.gp_Lin
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _HLRBRep.HLRBRep_LineTool_LastParameter(*args)

    LastParameter = staticmethod(LastParameter)

    def Continuity(*args):
        """
        Continuity(gp_Lin C) -> GeomAbs_Shape

        :type C: OCC.wrapper.gp.gp_Lin
        :rtype: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _HLRBRep.HLRBRep_LineTool_Continuity(*args)

    Continuity = staticmethod(Continuity)

    def NbIntervals(*args):
        """
        NbIntervals(gp_Lin C, GeomAbs_Shape const S) -> Standard_Integer

        If necessary,   breaks the line  in  intervals of
        continuity <S>.     And   returns  the  number  of
        intervals.

        :type C: OCC.wrapper.gp.gp_Lin
        :type S: OCC.wrapper.GeomAbs.GeomAbs_Shape
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _HLRBRep.HLRBRep_LineTool_NbIntervals(*args)

    NbIntervals = staticmethod(NbIntervals)

    def Intervals(*args):
        """
        Intervals(gp_Lin C, NCollection_Array1_Standard_Real T, GeomAbs_Shape const Sh)

        Sets the current working interval.

        :type C: OCC.wrapper.gp.gp_Lin
        :type T: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type Sh: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _HLRBRep.HLRBRep_LineTool_Intervals(*args)

    Intervals = staticmethod(Intervals)

    def IntervalFirst(*args):
        """
        IntervalFirst(gp_Lin C) -> Standard_Real

        Returns  the  first  parameter    of  the  current
        interval.

        :type C: OCC.wrapper.gp.gp_Lin
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _HLRBRep.HLRBRep_LineTool_IntervalFirst(*args)

    IntervalFirst = staticmethod(IntervalFirst)

    def IntervalLast(*args):
        """
        IntervalLast(gp_Lin C) -> Standard_Real

        Returns  the  last  parameter    of  the  current
        interval.

        :type C: OCC.wrapper.gp.gp_Lin
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _HLRBRep.HLRBRep_LineTool_IntervalLast(*args)

    IntervalLast = staticmethod(IntervalLast)

    def IntervalContinuity(*args):
        """
        IntervalContinuity(gp_Lin C) -> GeomAbs_Shape

        :type C: OCC.wrapper.gp.gp_Lin
        :rtype: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _HLRBRep.HLRBRep_LineTool_IntervalContinuity(*args)

    IntervalContinuity = staticmethod(IntervalContinuity)

    def IsClosed(*args):
        """
        IsClosed(gp_Lin C) -> Standard_Boolean

        :type C: OCC.wrapper.gp.gp_Lin
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _HLRBRep.HLRBRep_LineTool_IsClosed(*args)

    IsClosed = staticmethod(IsClosed)

    def IsPeriodic(*args):
        """
        IsPeriodic(gp_Lin C) -> Standard_Boolean

        :type C: OCC.wrapper.gp.gp_Lin
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _HLRBRep.HLRBRep_LineTool_IsPeriodic(*args)

    IsPeriodic = staticmethod(IsPeriodic)

    def Period(*args):
        """
        Period(gp_Lin C) -> Standard_Real

        :type C: OCC.wrapper.gp.gp_Lin
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _HLRBRep.HLRBRep_LineTool_Period(*args)

    Period = staticmethod(Period)

    def Value(*args):
        """
        Value(gp_Lin C, Standard_Real const U) -> gp_Pnt

        Computes the point of parameter U on the line.

        :type C: OCC.wrapper.gp.gp_Lin
        :type U: float
        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _HLRBRep.HLRBRep_LineTool_Value(*args)

    Value = staticmethod(Value)

    def D0(*args):
        """
        D0(gp_Lin C, Standard_Real const U, gp_Pnt P)

        Computes the point of parameter U on the line.

        :type C: OCC.wrapper.gp.gp_Lin
        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt

        """
        return _HLRBRep.HLRBRep_LineTool_D0(*args)

    D0 = staticmethod(D0)

    def D1(*args):
        """
        D1(gp_Lin C, Standard_Real const U, gp_Pnt P, gp_Vec V)

        Computes the point of parameter U on the line with its
        first derivative.
        Raised if the continuity of the current interval
        is not C1.

        :type C: OCC.wrapper.gp.gp_Lin
        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type V: OCC.wrapper.gp.gp_Vec

        """
        return _HLRBRep.HLRBRep_LineTool_D1(*args)

    D1 = staticmethod(D1)

    def D2(*args):
        """
        D2(gp_Lin C, Standard_Real const U, gp_Pnt P, gp_Vec V1, gp_Vec V2)

        Returns the point P of parameter U, the first and second
        derivatives V1 and V2.
        Raised if the continuity of the current interval
        is not C2.

        :type C: OCC.wrapper.gp.gp_Lin
        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type V1: OCC.wrapper.gp.gp_Vec
        :type V2: OCC.wrapper.gp.gp_Vec

        """
        return _HLRBRep.HLRBRep_LineTool_D2(*args)

    D2 = staticmethod(D2)

    def D3(*args):
        """
        D3(gp_Lin C, Standard_Real const U, gp_Pnt P, gp_Vec V1, gp_Vec V2, gp_Vec V3)

        Returns the point P of parameter U, the first, the second
        and the third derivative.
        Raised if the continuity of the current interval
        is not C3.

        :type C: OCC.wrapper.gp.gp_Lin
        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type V1: OCC.wrapper.gp.gp_Vec
        :type V2: OCC.wrapper.gp.gp_Vec
        :type V3: OCC.wrapper.gp.gp_Vec

        """
        return _HLRBRep.HLRBRep_LineTool_D3(*args)

    D3 = staticmethod(D3)

    def DN(*args):
        """
        DN(gp_Lin C, Standard_Real const U, Standard_Integer const N) -> gp_Vec

        The returned vector gives the value of the derivative for the
        order of derivation N.
        Raised if the continuity of the current interval
        is not CN.
        Raised if N < 1.

        :type C: OCC.wrapper.gp.gp_Lin
        :type U: float
        :type N: int
        :rtype: OCC.wrapper.gp.gp_Vec

        """
        return _HLRBRep.HLRBRep_LineTool_DN(*args)

    DN = staticmethod(DN)

    def Resolution(*args):
        """
        Resolution(gp_Lin C, Standard_Real const R3d) -> Standard_Real

        Returns the parametric  resolution corresponding
        to the real space resolution <R3d>.

        :type C: OCC.wrapper.gp.gp_Lin
        :type R3d: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _HLRBRep.HLRBRep_LineTool_Resolution(*args)

    Resolution = staticmethod(Resolution)

    def GetType(*args):
        """
        GetType(gp_Lin C) -> GeomAbs_CurveType

        Returns  the  type of the   line  in the  current
        interval :   Line,   Circle,   Ellipse, Hyperbola,
        Parabola, BezierCurve, BSplineCurve, OtherCurve.

        :type C: OCC.wrapper.gp.gp_Lin
        :rtype: OCC.wrapper.GeomAbs.GeomAbs_CurveType

        """
        return _HLRBRep.HLRBRep_LineTool_GetType(*args)

    GetType = staticmethod(GetType)

    def Line(*args):
        """
        Line(gp_Lin C) -> gp_Lin

        :type C: OCC.wrapper.gp.gp_Lin
        :rtype: OCC.wrapper.gp.gp_Lin

        """
        return _HLRBRep.HLRBRep_LineTool_Line(*args)

    Line = staticmethod(Line)

    def Circle(*args):
        """
        Circle(gp_Lin C) -> gp_Circ

        :type C: OCC.wrapper.gp.gp_Lin
        :rtype: OCC.wrapper.gp.gp_Circ

        """
        return _HLRBRep.HLRBRep_LineTool_Circle(*args)

    Circle = staticmethod(Circle)

    def Ellipse(*args):
        """
        Ellipse(gp_Lin C) -> gp_Elips

        :type C: OCC.wrapper.gp.gp_Lin
        :rtype: OCC.wrapper.gp.gp_Elips

        """
        return _HLRBRep.HLRBRep_LineTool_Ellipse(*args)

    Ellipse = staticmethod(Ellipse)

    def Hyperbola(*args):
        """
        Hyperbola(gp_Lin C) -> gp_Hypr

        :type C: OCC.wrapper.gp.gp_Lin
        :rtype: OCC.wrapper.gp.gp_Hypr

        """
        return _HLRBRep.HLRBRep_LineTool_Hyperbola(*args)

    Hyperbola = staticmethod(Hyperbola)

    def Parabola(*args):
        """
        Parabola(gp_Lin C) -> gp_Parab

        :type C: OCC.wrapper.gp.gp_Lin
        :rtype: OCC.wrapper.gp.gp_Parab

        """
        return _HLRBRep.HLRBRep_LineTool_Parabola(*args)

    Parabola = staticmethod(Parabola)

    def Bezier(*args):
        """
        Bezier(gp_Lin C) -> Handle_Geom_BezierCurve

        :type C: OCC.wrapper.gp.gp_Lin
        :rtype: OCC.wrapper.Geom.Handle_Geom_BezierCurve

        """
        return _HLRBRep.HLRBRep_LineTool_Bezier(*args)

    Bezier = staticmethod(Bezier)

    def BSpline(*args):
        """
        BSpline(gp_Lin C) -> Handle_Geom_BSplineCurve

        :type C: OCC.wrapper.gp.gp_Lin
        :rtype: OCC.wrapper.Geom.Handle_Geom_BSplineCurve

        """
        return _HLRBRep.HLRBRep_LineTool_BSpline(*args)

    BSpline = staticmethod(BSpline)

    def Degree(*args):
        """
        Degree(gp_Lin C) -> Standard_Integer

        :type C: OCC.wrapper.gp.gp_Lin
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _HLRBRep.HLRBRep_LineTool_Degree(*args)

    Degree = staticmethod(Degree)

    def NbPoles(*args):
        """
        NbPoles(gp_Lin C) -> Standard_Integer

        :type C: OCC.wrapper.gp.gp_Lin
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _HLRBRep.HLRBRep_LineTool_NbPoles(*args)

    NbPoles = staticmethod(NbPoles)

    def Poles(*args):
        """
        Poles(gp_Lin C, NCollection_Array1_gp_Pnt TP)

        :type C: OCC.wrapper.gp.gp_Lin
        :type TP: OCC.wrapper.TColgp.TColgp_Array1OfPnt

        """
        return _HLRBRep.HLRBRep_LineTool_Poles(*args)

    Poles = staticmethod(Poles)

    def IsRational(*args):
        """
        IsRational(gp_Lin C) -> Standard_Boolean

        :type C: OCC.wrapper.gp.gp_Lin
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _HLRBRep.HLRBRep_LineTool_IsRational(*args)

    IsRational = staticmethod(IsRational)

    def PolesAndWeights(*args):
        """
        PolesAndWeights(gp_Lin C, NCollection_Array1_gp_Pnt TP, NCollection_Array1_Standard_Real TW)

        :type C: OCC.wrapper.gp.gp_Lin
        :type TP: OCC.wrapper.TColgp.TColgp_Array1OfPnt
        :type TW: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        return _HLRBRep.HLRBRep_LineTool_PolesAndWeights(*args)

    PolesAndWeights = staticmethod(PolesAndWeights)

    def NbKnots(*args):
        """
        NbKnots(gp_Lin C) -> Standard_Integer

        :type C: OCC.wrapper.gp.gp_Lin
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _HLRBRep.HLRBRep_LineTool_NbKnots(*args)

    NbKnots = staticmethod(NbKnots)

    def KnotsAndMultiplicities(*args):
        """
        KnotsAndMultiplicities(gp_Lin C, NCollection_Array1_Standard_Real TK, NCollection_Array1_Standard_Integer TM)

        :type C: OCC.wrapper.gp.gp_Lin
        :type TK: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type TM: OCC.wrapper.TColStd.TColStd_Array1OfInteger

        """
        return _HLRBRep.HLRBRep_LineTool_KnotsAndMultiplicities(*args)

    KnotsAndMultiplicities = staticmethod(KnotsAndMultiplicities)

    def NbSamples(*args):
        """
        NbSamples(gp_Lin C, Standard_Real const U0, Standard_Real const U1) -> Standard_Integer

        :type C: OCC.wrapper.gp.gp_Lin
        :type U0: float
        :type U1: float
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _HLRBRep.HLRBRep_LineTool_NbSamples(*args)

    NbSamples = staticmethod(NbSamples)

    def SamplePars(*args):
        """
        SamplePars(gp_Lin C, Standard_Real const U0, Standard_Real const U1, Standard_Real const Defl, Standard_Integer const NbMin, Handle_TColStd_HArray1OfReal Pars)

        :type C: OCC.wrapper.gp.gp_Lin
        :type U0: float
        :type U1: float
        :type Defl: float
        :type NbMin: int
        :type Pars: OCC.wrapper.TColStd.Handle_TColStd_HArray1OfReal

        """
        return _HLRBRep.HLRBRep_LineTool_SamplePars(*args)

    SamplePars = staticmethod(SamplePars)

    def __init__(self):
        """
        The  LineTool  class  provides  class  methods to
        access the methodes of the Line.
        """
        this = _HLRBRep.new_HLRBRep_LineTool()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _HLRBRep.delete_HLRBRep_LineTool
HLRBRep_LineTool_swigregister = _HLRBRep.HLRBRep_LineTool_swigregister
HLRBRep_LineTool_swigregister(HLRBRep_LineTool)

def HLRBRep_LineTool_FirstParameter(*args):
    """
    HLRBRep_LineTool_FirstParameter(gp_Lin C) -> Standard_Real

    :type C: OCC.wrapper.gp.gp_Lin
    :rtype: OCC.wrapper.Standard.Standard_Real

    """
    return _HLRBRep.HLRBRep_LineTool_FirstParameter(*args)

def HLRBRep_LineTool_LastParameter(*args):
    """
    HLRBRep_LineTool_LastParameter(gp_Lin C) -> Standard_Real

    :type C: OCC.wrapper.gp.gp_Lin
    :rtype: OCC.wrapper.Standard.Standard_Real

    """
    return _HLRBRep.HLRBRep_LineTool_LastParameter(*args)

def HLRBRep_LineTool_Continuity(*args):
    """
    HLRBRep_LineTool_Continuity(gp_Lin C) -> GeomAbs_Shape

    :type C: OCC.wrapper.gp.gp_Lin
    :rtype: OCC.wrapper.GeomAbs.GeomAbs_Shape

    """
    return _HLRBRep.HLRBRep_LineTool_Continuity(*args)

def HLRBRep_LineTool_NbIntervals(*args):
    """
    HLRBRep_LineTool_NbIntervals(gp_Lin C, GeomAbs_Shape const S) -> Standard_Integer

    If necessary,   breaks the line  in  intervals of
    continuity <S>.     And   returns  the  number  of
    intervals.

    :type C: OCC.wrapper.gp.gp_Lin
    :type S: OCC.wrapper.GeomAbs.GeomAbs_Shape
    :rtype: OCC.wrapper.Standard.Standard_Integer

    """
    return _HLRBRep.HLRBRep_LineTool_NbIntervals(*args)

def HLRBRep_LineTool_Intervals(*args):
    """
    HLRBRep_LineTool_Intervals(gp_Lin C, NCollection_Array1_Standard_Real T, GeomAbs_Shape const Sh)

    Sets the current working interval.

    :type C: OCC.wrapper.gp.gp_Lin
    :type T: OCC.wrapper.TColStd.TColStd_Array1OfReal
    :type Sh: OCC.wrapper.GeomAbs.GeomAbs_Shape

    """
    return _HLRBRep.HLRBRep_LineTool_Intervals(*args)

def HLRBRep_LineTool_IntervalFirst(*args):
    """
    HLRBRep_LineTool_IntervalFirst(gp_Lin C) -> Standard_Real

    Returns  the  first  parameter    of  the  current
    interval.

    :type C: OCC.wrapper.gp.gp_Lin
    :rtype: OCC.wrapper.Standard.Standard_Real

    """
    return _HLRBRep.HLRBRep_LineTool_IntervalFirst(*args)

def HLRBRep_LineTool_IntervalLast(*args):
    """
    HLRBRep_LineTool_IntervalLast(gp_Lin C) -> Standard_Real

    Returns  the  last  parameter    of  the  current
    interval.

    :type C: OCC.wrapper.gp.gp_Lin
    :rtype: OCC.wrapper.Standard.Standard_Real

    """
    return _HLRBRep.HLRBRep_LineTool_IntervalLast(*args)

def HLRBRep_LineTool_IntervalContinuity(*args):
    """
    HLRBRep_LineTool_IntervalContinuity(gp_Lin C) -> GeomAbs_Shape

    :type C: OCC.wrapper.gp.gp_Lin
    :rtype: OCC.wrapper.GeomAbs.GeomAbs_Shape

    """
    return _HLRBRep.HLRBRep_LineTool_IntervalContinuity(*args)

def HLRBRep_LineTool_IsClosed(*args):
    """
    HLRBRep_LineTool_IsClosed(gp_Lin C) -> Standard_Boolean

    :type C: OCC.wrapper.gp.gp_Lin
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _HLRBRep.HLRBRep_LineTool_IsClosed(*args)

def HLRBRep_LineTool_IsPeriodic(*args):
    """
    HLRBRep_LineTool_IsPeriodic(gp_Lin C) -> Standard_Boolean

    :type C: OCC.wrapper.gp.gp_Lin
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _HLRBRep.HLRBRep_LineTool_IsPeriodic(*args)

def HLRBRep_LineTool_Period(*args):
    """
    HLRBRep_LineTool_Period(gp_Lin C) -> Standard_Real

    :type C: OCC.wrapper.gp.gp_Lin
    :rtype: OCC.wrapper.Standard.Standard_Real

    """
    return _HLRBRep.HLRBRep_LineTool_Period(*args)

def HLRBRep_LineTool_Value(*args):
    """
    HLRBRep_LineTool_Value(gp_Lin C, Standard_Real const U) -> gp_Pnt

    Computes the point of parameter U on the line.

    :type C: OCC.wrapper.gp.gp_Lin
    :type U: float
    :rtype: OCC.wrapper.gp.gp_Pnt

    """
    return _HLRBRep.HLRBRep_LineTool_Value(*args)

def HLRBRep_LineTool_D0(*args):
    """
    HLRBRep_LineTool_D0(gp_Lin C, Standard_Real const U, gp_Pnt P)

    Computes the point of parameter U on the line.

    :type C: OCC.wrapper.gp.gp_Lin
    :type U: float
    :type P: OCC.wrapper.gp.gp_Pnt

    """
    return _HLRBRep.HLRBRep_LineTool_D0(*args)

def HLRBRep_LineTool_D1(*args):
    """
    HLRBRep_LineTool_D1(gp_Lin C, Standard_Real const U, gp_Pnt P, gp_Vec V)

    Computes the point of parameter U on the line with its
    first derivative.
    Raised if the continuity of the current interval
    is not C1.

    :type C: OCC.wrapper.gp.gp_Lin
    :type U: float
    :type P: OCC.wrapper.gp.gp_Pnt
    :type V: OCC.wrapper.gp.gp_Vec

    """
    return _HLRBRep.HLRBRep_LineTool_D1(*args)

def HLRBRep_LineTool_D2(*args):
    """
    HLRBRep_LineTool_D2(gp_Lin C, Standard_Real const U, gp_Pnt P, gp_Vec V1, gp_Vec V2)

    Returns the point P of parameter U, the first and second
    derivatives V1 and V2.
    Raised if the continuity of the current interval
    is not C2.

    :type C: OCC.wrapper.gp.gp_Lin
    :type U: float
    :type P: OCC.wrapper.gp.gp_Pnt
    :type V1: OCC.wrapper.gp.gp_Vec
    :type V2: OCC.wrapper.gp.gp_Vec

    """
    return _HLRBRep.HLRBRep_LineTool_D2(*args)

def HLRBRep_LineTool_D3(*args):
    """
    HLRBRep_LineTool_D3(gp_Lin C, Standard_Real const U, gp_Pnt P, gp_Vec V1, gp_Vec V2, gp_Vec V3)

    Returns the point P of parameter U, the first, the second
    and the third derivative.
    Raised if the continuity of the current interval
    is not C3.

    :type C: OCC.wrapper.gp.gp_Lin
    :type U: float
    :type P: OCC.wrapper.gp.gp_Pnt
    :type V1: OCC.wrapper.gp.gp_Vec
    :type V2: OCC.wrapper.gp.gp_Vec
    :type V3: OCC.wrapper.gp.gp_Vec

    """
    return _HLRBRep.HLRBRep_LineTool_D3(*args)

def HLRBRep_LineTool_DN(*args):
    """
    HLRBRep_LineTool_DN(gp_Lin C, Standard_Real const U, Standard_Integer const N) -> gp_Vec

    The returned vector gives the value of the derivative for the
    order of derivation N.
    Raised if the continuity of the current interval
    is not CN.
    Raised if N < 1.

    :type C: OCC.wrapper.gp.gp_Lin
    :type U: float
    :type N: int
    :rtype: OCC.wrapper.gp.gp_Vec

    """
    return _HLRBRep.HLRBRep_LineTool_DN(*args)

def HLRBRep_LineTool_Resolution(*args):
    """
    HLRBRep_LineTool_Resolution(gp_Lin C, Standard_Real const R3d) -> Standard_Real

    Returns the parametric  resolution corresponding
    to the real space resolution <R3d>.

    :type C: OCC.wrapper.gp.gp_Lin
    :type R3d: float
    :rtype: OCC.wrapper.Standard.Standard_Real

    """
    return _HLRBRep.HLRBRep_LineTool_Resolution(*args)

def HLRBRep_LineTool_GetType(*args):
    """
    HLRBRep_LineTool_GetType(gp_Lin C) -> GeomAbs_CurveType

    Returns  the  type of the   line  in the  current
    interval :   Line,   Circle,   Ellipse, Hyperbola,
    Parabola, BezierCurve, BSplineCurve, OtherCurve.

    :type C: OCC.wrapper.gp.gp_Lin
    :rtype: OCC.wrapper.GeomAbs.GeomAbs_CurveType

    """
    return _HLRBRep.HLRBRep_LineTool_GetType(*args)

def HLRBRep_LineTool_Line(*args):
    """
    HLRBRep_LineTool_Line(gp_Lin C) -> gp_Lin

    :type C: OCC.wrapper.gp.gp_Lin
    :rtype: OCC.wrapper.gp.gp_Lin

    """
    return _HLRBRep.HLRBRep_LineTool_Line(*args)

def HLRBRep_LineTool_Circle(*args):
    """
    HLRBRep_LineTool_Circle(gp_Lin C) -> gp_Circ

    :type C: OCC.wrapper.gp.gp_Lin
    :rtype: OCC.wrapper.gp.gp_Circ

    """
    return _HLRBRep.HLRBRep_LineTool_Circle(*args)

def HLRBRep_LineTool_Ellipse(*args):
    """
    HLRBRep_LineTool_Ellipse(gp_Lin C) -> gp_Elips

    :type C: OCC.wrapper.gp.gp_Lin
    :rtype: OCC.wrapper.gp.gp_Elips

    """
    return _HLRBRep.HLRBRep_LineTool_Ellipse(*args)

def HLRBRep_LineTool_Hyperbola(*args):
    """
    HLRBRep_LineTool_Hyperbola(gp_Lin C) -> gp_Hypr

    :type C: OCC.wrapper.gp.gp_Lin
    :rtype: OCC.wrapper.gp.gp_Hypr

    """
    return _HLRBRep.HLRBRep_LineTool_Hyperbola(*args)

def HLRBRep_LineTool_Parabola(*args):
    """
    HLRBRep_LineTool_Parabola(gp_Lin C) -> gp_Parab

    :type C: OCC.wrapper.gp.gp_Lin
    :rtype: OCC.wrapper.gp.gp_Parab

    """
    return _HLRBRep.HLRBRep_LineTool_Parabola(*args)

def HLRBRep_LineTool_Bezier(*args):
    """
    HLRBRep_LineTool_Bezier(gp_Lin C) -> Handle_Geom_BezierCurve

    :type C: OCC.wrapper.gp.gp_Lin
    :rtype: OCC.wrapper.Geom.Handle_Geom_BezierCurve

    """
    return _HLRBRep.HLRBRep_LineTool_Bezier(*args)

def HLRBRep_LineTool_BSpline(*args):
    """
    HLRBRep_LineTool_BSpline(gp_Lin C) -> Handle_Geom_BSplineCurve

    :type C: OCC.wrapper.gp.gp_Lin
    :rtype: OCC.wrapper.Geom.Handle_Geom_BSplineCurve

    """
    return _HLRBRep.HLRBRep_LineTool_BSpline(*args)

def HLRBRep_LineTool_Degree(*args):
    """
    HLRBRep_LineTool_Degree(gp_Lin C) -> Standard_Integer

    :type C: OCC.wrapper.gp.gp_Lin
    :rtype: OCC.wrapper.Standard.Standard_Integer

    """
    return _HLRBRep.HLRBRep_LineTool_Degree(*args)

def HLRBRep_LineTool_NbPoles(*args):
    """
    HLRBRep_LineTool_NbPoles(gp_Lin C) -> Standard_Integer

    :type C: OCC.wrapper.gp.gp_Lin
    :rtype: OCC.wrapper.Standard.Standard_Integer

    """
    return _HLRBRep.HLRBRep_LineTool_NbPoles(*args)

def HLRBRep_LineTool_Poles(*args):
    """
    HLRBRep_LineTool_Poles(gp_Lin C, NCollection_Array1_gp_Pnt TP)

    :type C: OCC.wrapper.gp.gp_Lin
    :type TP: OCC.wrapper.TColgp.TColgp_Array1OfPnt

    """
    return _HLRBRep.HLRBRep_LineTool_Poles(*args)

def HLRBRep_LineTool_IsRational(*args):
    """
    HLRBRep_LineTool_IsRational(gp_Lin C) -> Standard_Boolean

    :type C: OCC.wrapper.gp.gp_Lin
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _HLRBRep.HLRBRep_LineTool_IsRational(*args)

def HLRBRep_LineTool_PolesAndWeights(*args):
    """
    HLRBRep_LineTool_PolesAndWeights(gp_Lin C, NCollection_Array1_gp_Pnt TP, NCollection_Array1_Standard_Real TW)

    :type C: OCC.wrapper.gp.gp_Lin
    :type TP: OCC.wrapper.TColgp.TColgp_Array1OfPnt
    :type TW: OCC.wrapper.TColStd.TColStd_Array1OfReal

    """
    return _HLRBRep.HLRBRep_LineTool_PolesAndWeights(*args)

def HLRBRep_LineTool_NbKnots(*args):
    """
    HLRBRep_LineTool_NbKnots(gp_Lin C) -> Standard_Integer

    :type C: OCC.wrapper.gp.gp_Lin
    :rtype: OCC.wrapper.Standard.Standard_Integer

    """
    return _HLRBRep.HLRBRep_LineTool_NbKnots(*args)

def HLRBRep_LineTool_KnotsAndMultiplicities(*args):
    """
    HLRBRep_LineTool_KnotsAndMultiplicities(gp_Lin C, NCollection_Array1_Standard_Real TK, NCollection_Array1_Standard_Integer TM)

    :type C: OCC.wrapper.gp.gp_Lin
    :type TK: OCC.wrapper.TColStd.TColStd_Array1OfReal
    :type TM: OCC.wrapper.TColStd.TColStd_Array1OfInteger

    """
    return _HLRBRep.HLRBRep_LineTool_KnotsAndMultiplicities(*args)

def HLRBRep_LineTool_NbSamples(*args):
    """
    HLRBRep_LineTool_NbSamples(gp_Lin C, Standard_Real const U0, Standard_Real const U1) -> Standard_Integer

    :type C: OCC.wrapper.gp.gp_Lin
    :type U0: float
    :type U1: float
    :rtype: OCC.wrapper.Standard.Standard_Integer

    """
    return _HLRBRep.HLRBRep_LineTool_NbSamples(*args)

def HLRBRep_LineTool_SamplePars(*args):
    """
    HLRBRep_LineTool_SamplePars(gp_Lin C, Standard_Real const U0, Standard_Real const U1, Standard_Real const Defl, Standard_Integer const NbMin, Handle_TColStd_HArray1OfReal Pars)

    :type C: OCC.wrapper.gp.gp_Lin
    :type U0: float
    :type U1: float
    :type Defl: float
    :type NbMin: int
    :type Pars: OCC.wrapper.TColStd.Handle_TColStd_HArray1OfReal

    """
    return _HLRBRep.HLRBRep_LineTool_SamplePars(*args)

class HLRBRep_VertexList(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(HLRBRep_VertexList self, HLRBRep_EdgeInterferenceTool T, HLRAlgo_ListIteratorOfInterferenceList const & I) -> HLRBRep_VertexList

        :type T: OCC.wrapper.HLRBRep.HLRBRep_EdgeInterferenceTool
        :type I: OCC.wrapper.HLRAlgo.HLRAlgo_ListIteratorOfInterferenceList

        """
        this = _HLRBRep.new_HLRBRep_VertexList(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def IsPeriodic(self, *args):
        """
        IsPeriodic(HLRBRep_VertexList self) -> Standard_Boolean

        Returns True when the curve is periodic.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _HLRBRep.HLRBRep_VertexList_IsPeriodic(self, *args)


    def More(self, *args):
        """
        More(HLRBRep_VertexList self) -> Standard_Boolean

        Returns True when there are more vertices.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _HLRBRep.HLRBRep_VertexList_More(self, *args)


    def Next(self, *args):
        """
        Next(HLRBRep_VertexList self)

        Proceeds to the next vertex.


        """
        return _HLRBRep.HLRBRep_VertexList_Next(self, *args)


    def Current(self, *args):
        """
        Returns the current vertex

        :rtype: OCC.wrapper.HLRAlgo.HLRAlgo_Intersection

        """
        res = _HLRBRep.HLRBRep_VertexList_Current(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def IsBoundary(self, *args):
        """
        IsBoundary(HLRBRep_VertexList self) -> Standard_Boolean

        Returns True  if the current  vertex  is is on the
        boundary of the edge.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _HLRBRep.HLRBRep_VertexList_IsBoundary(self, *args)


    def IsInterference(self, *args):
        """
        IsInterference(HLRBRep_VertexList self) -> Standard_Boolean

        Returns  True   if   the current    vertex  is  an
        interference.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _HLRBRep.HLRBRep_VertexList_IsInterference(self, *args)


    def Orientation(self, *args):
        """
        Orientation(HLRBRep_VertexList self) -> TopAbs_Orientation

        Returns the  orientation of the  current vertex if
        it is on the boundary of the edge.

        :rtype: OCC.wrapper.TopAbs.TopAbs_Orientation

        """
        return _HLRBRep.HLRBRep_VertexList_Orientation(self, *args)


    def Transition(self, *args):
        """
        Transition(HLRBRep_VertexList self) -> TopAbs_Orientation

        Returns  the transition  of the  current vertex if
        it is an interference.

        :rtype: OCC.wrapper.TopAbs.TopAbs_Orientation

        """
        return _HLRBRep.HLRBRep_VertexList_Transition(self, *args)


    def BoundaryTransition(self, *args):
        """
        BoundaryTransition(HLRBRep_VertexList self) -> TopAbs_Orientation

        Returns  the  transition  of  the  current  vertex
        relative to the boundary if it is an interference.

        :rtype: OCC.wrapper.TopAbs.TopAbs_Orientation

        """
        return _HLRBRep.HLRBRep_VertexList_BoundaryTransition(self, *args)

    __swig_destroy__ = _HLRBRep.delete_HLRBRep_VertexList
HLRBRep_VertexList_swigregister = _HLRBRep.HLRBRep_VertexList_swigregister
HLRBRep_VertexList_swigregister(HLRBRep_VertexList)

class HLRBRep_CInter(IntRes2d.IntRes2d_Intersection):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(HLRBRep_CInter self) -> HLRBRep_CInter
        __init__(HLRBRep_CInter self, Standard_Address const & C, Standard_Real const TolConf, Standard_Real const Tol) -> HLRBRep_CInter
        __init__(HLRBRep_CInter self, Standard_Address const & C, IntRes2d_Domain D, Standard_Real const TolConf, Standard_Real const Tol) -> HLRBRep_CInter
        __init__(HLRBRep_CInter self, Standard_Address const & C1, Standard_Address const & C2, Standard_Real const TolConf, Standard_Real const Tol) -> HLRBRep_CInter
        __init__(HLRBRep_CInter self, Standard_Address const & C1, IntRes2d_Domain D1, Standard_Address const & C2, Standard_Real const TolConf, Standard_Real const Tol) -> HLRBRep_CInter
        __init__(HLRBRep_CInter self, Standard_Address const & C1, Standard_Address const & C2, IntRes2d_Domain D2, Standard_Real const TolConf, Standard_Real const Tol) -> HLRBRep_CInter
        __init__(HLRBRep_CInter self, Standard_Address const & C1, IntRes2d_Domain D1, Standard_Address const & C2, IntRes2d_Domain D2, Standard_Real const TolConf, Standard_Real const Tol) -> HLRBRep_CInter

        Intersection between 2 curves.

        :type C1: OCC.wrapper.Standard.Standard_Address
        :type D1: OCC.wrapper.IntRes2d.IntRes2d_Domain
        :type C2: OCC.wrapper.Standard.Standard_Address
        :type D2: OCC.wrapper.IntRes2d.IntRes2d_Domain
        :type TolConf: float
        :type Tol: float

        """
        this = _HLRBRep.new_HLRBRep_CInter(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Perform(self, *args):
        """
        Perform(HLRBRep_CInter self, Standard_Address const & C1, IntRes2d_Domain D1, Standard_Address const & C2, IntRes2d_Domain D2, Standard_Real const TolConf, Standard_Real const Tol)
        Perform(HLRBRep_CInter self, Standard_Address const & C1, Standard_Address const & C2, Standard_Real const TolConf, Standard_Real const Tol)
        Perform(HLRBRep_CInter self, Standard_Address const & C1, IntRes2d_Domain D1, Standard_Real const TolConf, Standard_Real const Tol)
        Perform(HLRBRep_CInter self, Standard_Address const & C1, Standard_Real const TolConf, Standard_Real const Tol)
        Perform(HLRBRep_CInter self, Standard_Address const & C1, IntRes2d_Domain D1, Standard_Address const & C2, Standard_Real const TolConf, Standard_Real const Tol)
        Perform(HLRBRep_CInter self, Standard_Address const & C1, Standard_Address const & C2, IntRes2d_Domain D2, Standard_Real const TolConf, Standard_Real const Tol)

        Intersection between 2 curves.

        :type C1: OCC.wrapper.Standard.Standard_Address
        :type C2: OCC.wrapper.Standard.Standard_Address
        :type D2: OCC.wrapper.IntRes2d.IntRes2d_Domain
        :type TolConf: float
        :type Tol: float

        """
        return _HLRBRep.HLRBRep_CInter_Perform(self, *args)


    def ComputeDomain(self, *args):
        """
        ComputeDomain(HLRBRep_CInter self, Standard_Address const & C1, Standard_Real const TolDomain) -> IntRes2d_Domain

        Create a domain from a curve

        :type C1: OCC.wrapper.Standard.Standard_Address
        :type TolDomain: float
        :rtype: OCC.wrapper.IntRes2d.IntRes2d_Domain

        """
        return _HLRBRep.HLRBRep_CInter_ComputeDomain(self, *args)


    def SetMinNbSamples(self, *args):
        """
        SetMinNbSamples(HLRBRep_CInter self, Standard_Integer const theMinNbSamples)

        Set / get minimum number of points in polygon intersection.

        :type theMinNbSamples: int

        """
        return _HLRBRep.HLRBRep_CInter_SetMinNbSamples(self, *args)


    def GetMinNbSamples(self, *args):
        """
        GetMinNbSamples(HLRBRep_CInter self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _HLRBRep.HLRBRep_CInter_GetMinNbSamples(self, *args)

    __swig_destroy__ = _HLRBRep.delete_HLRBRep_CInter
HLRBRep_CInter_swigregister = _HLRBRep.HLRBRep_CInter_swigregister
HLRBRep_CInter_swigregister(HLRBRep_CInter)

class HLRBRep_ThePolygonToolOfInterCSurf(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Bounding(*args):
        """
        Bounding(HLRBRep_ThePolygonOfInterCSurf thePolygon) -> Bnd_Box

        Give the bounding box of the polygon.

        :type thePolygon: OCC.wrapper.HLRBRep.HLRBRep_ThePolygonOfInterCSurf
        :rtype: OCC.wrapper.Bnd.Bnd_Box

        """
        return _HLRBRep.HLRBRep_ThePolygonToolOfInterCSurf_Bounding(*args)

    Bounding = staticmethod(Bounding)

    def DeflectionOverEstimation(*args):
        """
        DeflectionOverEstimation(HLRBRep_ThePolygonOfInterCSurf thePolygon) -> Standard_Real

        :type thePolygon: OCC.wrapper.HLRBRep.HLRBRep_ThePolygonOfInterCSurf
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _HLRBRep.HLRBRep_ThePolygonToolOfInterCSurf_DeflectionOverEstimation(*args)

    DeflectionOverEstimation = staticmethod(DeflectionOverEstimation)

    def Closed(*args):
        """
        Closed(HLRBRep_ThePolygonOfInterCSurf thePolygon) -> Standard_Boolean

        :type thePolygon: OCC.wrapper.HLRBRep.HLRBRep_ThePolygonOfInterCSurf
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _HLRBRep.HLRBRep_ThePolygonToolOfInterCSurf_Closed(*args)

    Closed = staticmethod(Closed)

    def NbSegments(*args):
        """
        NbSegments(HLRBRep_ThePolygonOfInterCSurf thePolygon) -> Standard_Integer

        :type thePolygon: OCC.wrapper.HLRBRep.HLRBRep_ThePolygonOfInterCSurf
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _HLRBRep.HLRBRep_ThePolygonToolOfInterCSurf_NbSegments(*args)

    NbSegments = staticmethod(NbSegments)

    def BeginOfSeg(*args):
        """
        BeginOfSeg(HLRBRep_ThePolygonOfInterCSurf thePolygon, Standard_Integer const Index) -> gp_Pnt

        Give the point of range Index in the Polygon.

        :type thePolygon: OCC.wrapper.HLRBRep.HLRBRep_ThePolygonOfInterCSurf
        :type Index: int
        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _HLRBRep.HLRBRep_ThePolygonToolOfInterCSurf_BeginOfSeg(*args)

    BeginOfSeg = staticmethod(BeginOfSeg)

    def EndOfSeg(*args):
        """
        EndOfSeg(HLRBRep_ThePolygonOfInterCSurf thePolygon, Standard_Integer const Index) -> gp_Pnt

        Give the point of range Index in the Polygon.

        :type thePolygon: OCC.wrapper.HLRBRep.HLRBRep_ThePolygonOfInterCSurf
        :type Index: int
        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _HLRBRep.HLRBRep_ThePolygonToolOfInterCSurf_EndOfSeg(*args)

    EndOfSeg = staticmethod(EndOfSeg)

    def Dump(*args):
        """
        Dump(HLRBRep_ThePolygonOfInterCSurf thePolygon)

        :type thePolygon: OCC.wrapper.HLRBRep.HLRBRep_ThePolygonOfInterCSurf

        """
        return _HLRBRep.HLRBRep_ThePolygonToolOfInterCSurf_Dump(*args)

    Dump = staticmethod(Dump)

    def __init__(self):
        this = _HLRBRep.new_HLRBRep_ThePolygonToolOfInterCSurf()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _HLRBRep.delete_HLRBRep_ThePolygonToolOfInterCSurf
HLRBRep_ThePolygonToolOfInterCSurf_swigregister = _HLRBRep.HLRBRep_ThePolygonToolOfInterCSurf_swigregister
HLRBRep_ThePolygonToolOfInterCSurf_swigregister(HLRBRep_ThePolygonToolOfInterCSurf)

def HLRBRep_ThePolygonToolOfInterCSurf_Bounding(*args):
    """
    HLRBRep_ThePolygonToolOfInterCSurf_Bounding(HLRBRep_ThePolygonOfInterCSurf thePolygon) -> Bnd_Box

    Give the bounding box of the polygon.

    :type thePolygon: OCC.wrapper.HLRBRep.HLRBRep_ThePolygonOfInterCSurf
    :rtype: OCC.wrapper.Bnd.Bnd_Box

    """
    return _HLRBRep.HLRBRep_ThePolygonToolOfInterCSurf_Bounding(*args)

def HLRBRep_ThePolygonToolOfInterCSurf_DeflectionOverEstimation(*args):
    """
    HLRBRep_ThePolygonToolOfInterCSurf_DeflectionOverEstimation(HLRBRep_ThePolygonOfInterCSurf thePolygon) -> Standard_Real

    :type thePolygon: OCC.wrapper.HLRBRep.HLRBRep_ThePolygonOfInterCSurf
    :rtype: OCC.wrapper.Standard.Standard_Real

    """
    return _HLRBRep.HLRBRep_ThePolygonToolOfInterCSurf_DeflectionOverEstimation(*args)

def HLRBRep_ThePolygonToolOfInterCSurf_Closed(*args):
    """
    HLRBRep_ThePolygonToolOfInterCSurf_Closed(HLRBRep_ThePolygonOfInterCSurf thePolygon) -> Standard_Boolean

    :type thePolygon: OCC.wrapper.HLRBRep.HLRBRep_ThePolygonOfInterCSurf
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _HLRBRep.HLRBRep_ThePolygonToolOfInterCSurf_Closed(*args)

def HLRBRep_ThePolygonToolOfInterCSurf_NbSegments(*args):
    """
    HLRBRep_ThePolygonToolOfInterCSurf_NbSegments(HLRBRep_ThePolygonOfInterCSurf thePolygon) -> Standard_Integer

    :type thePolygon: OCC.wrapper.HLRBRep.HLRBRep_ThePolygonOfInterCSurf
    :rtype: OCC.wrapper.Standard.Standard_Integer

    """
    return _HLRBRep.HLRBRep_ThePolygonToolOfInterCSurf_NbSegments(*args)

def HLRBRep_ThePolygonToolOfInterCSurf_BeginOfSeg(*args):
    """
    HLRBRep_ThePolygonToolOfInterCSurf_BeginOfSeg(HLRBRep_ThePolygonOfInterCSurf thePolygon, Standard_Integer const Index) -> gp_Pnt

    Give the point of range Index in the Polygon.

    :type thePolygon: OCC.wrapper.HLRBRep.HLRBRep_ThePolygonOfInterCSurf
    :type Index: int
    :rtype: OCC.wrapper.gp.gp_Pnt

    """
    return _HLRBRep.HLRBRep_ThePolygonToolOfInterCSurf_BeginOfSeg(*args)

def HLRBRep_ThePolygonToolOfInterCSurf_EndOfSeg(*args):
    """
    HLRBRep_ThePolygonToolOfInterCSurf_EndOfSeg(HLRBRep_ThePolygonOfInterCSurf thePolygon, Standard_Integer const Index) -> gp_Pnt

    Give the point of range Index in the Polygon.

    :type thePolygon: OCC.wrapper.HLRBRep.HLRBRep_ThePolygonOfInterCSurf
    :type Index: int
    :rtype: OCC.wrapper.gp.gp_Pnt

    """
    return _HLRBRep.HLRBRep_ThePolygonToolOfInterCSurf_EndOfSeg(*args)

def HLRBRep_ThePolygonToolOfInterCSurf_Dump(*args):
    """
    HLRBRep_ThePolygonToolOfInterCSurf_Dump(HLRBRep_ThePolygonOfInterCSurf thePolygon)

    :type thePolygon: OCC.wrapper.HLRBRep.HLRBRep_ThePolygonOfInterCSurf

    """
    return _HLRBRep.HLRBRep_ThePolygonToolOfInterCSurf_Dump(*args)

class Handle_HLRBRep_AreaLimit(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_HLRBRep_AreaLimit self)

        Nullify the handle


        """
        return _HLRBRep.Handle_HLRBRep_AreaLimit_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_HLRBRep_AreaLimit self) -> bool

        Check for being null

        :rtype: bool

        """
        return _HLRBRep.Handle_HLRBRep_AreaLimit_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_HLRBRep_AreaLimit self, HLRBRep_AreaLimit thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _HLRBRep.Handle_HLRBRep_AreaLimit_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_HLRBRep_AreaLimit self, Handle_HLRBRep_AreaLimit theHandle) -> Handle_HLRBRep_AreaLimit
        assign(Handle_HLRBRep_AreaLimit self, HLRBRep_AreaLimit thePtr) -> Handle_HLRBRep_AreaLimit
        assign(Handle_HLRBRep_AreaLimit self, Handle_HLRBRep_AreaLimit theHandle) -> Handle_HLRBRep_AreaLimit

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _HLRBRep.Handle_HLRBRep_AreaLimit_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_HLRBRep_AreaLimit self) -> HLRBRep_AreaLimit

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _HLRBRep.Handle_HLRBRep_AreaLimit_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_HLRBRep_AreaLimit self) -> HLRBRep_AreaLimit

        Member access operator (note non-const)

        :rtype: T *

        """
        return _HLRBRep.Handle_HLRBRep_AreaLimit___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_HLRBRep_AreaLimit self) -> HLRBRep_AreaLimit

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _HLRBRep.Handle_HLRBRep_AreaLimit___ref__(self, *args)


    def __hash__(self):
        return _HLRBRep.Handle_HLRBRep_AreaLimit___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _HLRBRep.Handle_HLRBRep_AreaLimit___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _HLRBRep.new_Handle_HLRBRep_AreaLimit(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_HLRBRep.Handle_HLRBRep_AreaLimit_DownCast)
    __swig_destroy__ = _HLRBRep.delete_Handle_HLRBRep_AreaLimit

    def StateBefore(self, *args):
        """
        StateBefore(Handle_HLRBRep_AreaLimit self, TopAbs_State const St)
        StateBefore(Handle_HLRBRep_AreaLimit self) -> TopAbs_State

        :rtype: OCC.wrapper.TopAbs.TopAbs_State

        """
        return _HLRBRep.Handle_HLRBRep_AreaLimit_StateBefore(self, *args)


    def StateAfter(self, *args):
        """
        StateAfter(Handle_HLRBRep_AreaLimit self, TopAbs_State const St)
        StateAfter(Handle_HLRBRep_AreaLimit self) -> TopAbs_State

        :rtype: OCC.wrapper.TopAbs.TopAbs_State

        """
        return _HLRBRep.Handle_HLRBRep_AreaLimit_StateAfter(self, *args)


    def EdgeBefore(self, *args):
        """
        EdgeBefore(Handle_HLRBRep_AreaLimit self, TopAbs_State const St)
        EdgeBefore(Handle_HLRBRep_AreaLimit self) -> TopAbs_State

        :rtype: OCC.wrapper.TopAbs.TopAbs_State

        """
        return _HLRBRep.Handle_HLRBRep_AreaLimit_EdgeBefore(self, *args)


    def EdgeAfter(self, *args):
        """
        EdgeAfter(Handle_HLRBRep_AreaLimit self, TopAbs_State const St)
        EdgeAfter(Handle_HLRBRep_AreaLimit self) -> TopAbs_State

        :rtype: OCC.wrapper.TopAbs.TopAbs_State

        """
        return _HLRBRep.Handle_HLRBRep_AreaLimit_EdgeAfter(self, *args)


    def Previous(self, *args):
        """
        Previous(Handle_HLRBRep_AreaLimit self, Handle_HLRBRep_AreaLimit P)
        Previous(Handle_HLRBRep_AreaLimit self) -> Handle_HLRBRep_AreaLimit

        :rtype: OCC.wrapper.HLRBRep.Handle_HLRBRep_AreaLimit

        """
        return _HLRBRep.Handle_HLRBRep_AreaLimit_Previous(self, *args)


    def Next(self, *args):
        """
        Next(Handle_HLRBRep_AreaLimit self, Handle_HLRBRep_AreaLimit N)
        Next(Handle_HLRBRep_AreaLimit self) -> Handle_HLRBRep_AreaLimit

        :rtype: OCC.wrapper.HLRBRep.Handle_HLRBRep_AreaLimit

        """
        return _HLRBRep.Handle_HLRBRep_AreaLimit_Next(self, *args)


    def Vertex(self, *args):
        """
        :rtype: OCC.wrapper.HLRAlgo.HLRAlgo_Intersection

        """
        res = _HLRBRep.Handle_HLRBRep_AreaLimit_Vertex(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def IsBoundary(self, *args):
        """
        IsBoundary(Handle_HLRBRep_AreaLimit self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _HLRBRep.Handle_HLRBRep_AreaLimit_IsBoundary(self, *args)


    def IsInterference(self, *args):
        """
        IsInterference(Handle_HLRBRep_AreaLimit self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _HLRBRep.Handle_HLRBRep_AreaLimit_IsInterference(self, *args)


    def Clear(self, *args):
        """Clear(Handle_HLRBRep_AreaLimit self)"""
        return _HLRBRep.Handle_HLRBRep_AreaLimit_Clear(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_HLRBRep_AreaLimit self) -> char const *

        :rtype: const char *

        """
        return _HLRBRep.Handle_HLRBRep_AreaLimit_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _HLRBRep.Handle_HLRBRep_AreaLimit_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _HLRBRep.Handle_HLRBRep_AreaLimit_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_HLRBRep_AreaLimit self)

        Memory deallocator for transient classes


        """
        return _HLRBRep.Handle_HLRBRep_AreaLimit_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_HLRBRep_AreaLimit self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_HLRBRep_AreaLimit self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _HLRBRep.Handle_HLRBRep_AreaLimit_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_HLRBRep_AreaLimit self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_HLRBRep_AreaLimit self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _HLRBRep.Handle_HLRBRep_AreaLimit_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_HLRBRep_AreaLimit self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _HLRBRep.Handle_HLRBRep_AreaLimit_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_HLRBRep_AreaLimit self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _HLRBRep.Handle_HLRBRep_AreaLimit_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_HLRBRep_AreaLimit self)

        Increments the reference counter of this object


        """
        return _HLRBRep.Handle_HLRBRep_AreaLimit_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_HLRBRep_AreaLimit self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _HLRBRep.Handle_HLRBRep_AreaLimit_DecrementRefCounter(self, *args)

Handle_HLRBRep_AreaLimit_swigregister = _HLRBRep.Handle_HLRBRep_AreaLimit_swigregister
Handle_HLRBRep_AreaLimit_swigregister(Handle_HLRBRep_AreaLimit)

def Handle_HLRBRep_AreaLimit_DownCast(thing):
    return _HLRBRep.Handle_HLRBRep_AreaLimit_DownCast(thing)
Handle_HLRBRep_AreaLimit_DownCast = _HLRBRep.Handle_HLRBRep_AreaLimit_DownCast

class NCollection_Sequence_HLRBRep_ShapeBounds(NCollection.NCollection_BaseSequence):
    """
    Purpose:     Definition of a sequence of elements indexed by
    an Integer in range of 1..n
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Sequence_HLRBRep_ShapeBounds self) -> NCollection_Sequence< HLRBRep_ShapeBounds >::iterator

        Returns an iterator pointing to the first element in the sequence.

        :rtype: iterator

        """
        return _HLRBRep.NCollection_Sequence_HLRBRep_ShapeBounds_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Sequence_HLRBRep_ShapeBounds self) -> NCollection_Sequence< HLRBRep_ShapeBounds >::iterator

        Returns an iterator referring to the past-the-end element in the sequence.

        :rtype: iterator

        """
        return _HLRBRep.NCollection_Sequence_HLRBRep_ShapeBounds_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Sequence_HLRBRep_ShapeBounds self) -> NCollection_Sequence< HLRBRep_ShapeBounds >::const_iterator

        Returns a const iterator pointing to the first element in the sequence.

        :rtype: const_iterator

        """
        return _HLRBRep.NCollection_Sequence_HLRBRep_ShapeBounds_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Sequence_HLRBRep_ShapeBounds self) -> NCollection_Sequence< HLRBRep_ShapeBounds >::const_iterator

        Returns a const iterator referring to the past-the-end element in the sequence.

        :rtype: const_iterator

        """
        return _HLRBRep.NCollection_Sequence_HLRBRep_ShapeBounds_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     Definition of a sequence of elements indexed by
        an Integer in range of 1..n
        """
        this = _HLRBRep.new_NCollection_Sequence_HLRBRep_ShapeBounds(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Size(self, *args):
        """
        Size(NCollection_Sequence_HLRBRep_ShapeBounds self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _HLRBRep.NCollection_Sequence_HLRBRep_ShapeBounds_Size(self, *args)


    def Length(self, *args):
        """
        Length(NCollection_Sequence_HLRBRep_ShapeBounds self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _HLRBRep.NCollection_Sequence_HLRBRep_ShapeBounds_Length(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Sequence_HLRBRep_ShapeBounds self) -> Standard_Integer

        Method for consistency with other collections.
        @return Lower bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _HLRBRep.NCollection_Sequence_HLRBRep_ShapeBounds_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Sequence_HLRBRep_ShapeBounds self) -> Standard_Integer

        Method for consistency with other collections.
        @return Upper bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _HLRBRep.NCollection_Sequence_HLRBRep_ShapeBounds_Upper(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Sequence_HLRBRep_ShapeBounds self) -> Standard_Boolean

        Empty query

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _HLRBRep.NCollection_Sequence_HLRBRep_ShapeBounds_IsEmpty(self, *args)


    def Reverse(self, *args):
        """
        Reverse(NCollection_Sequence_HLRBRep_ShapeBounds self)

        Reverse sequence


        """
        return _HLRBRep.NCollection_Sequence_HLRBRep_ShapeBounds_Reverse(self, *args)


    def Exchange(self, *args):
        """
        Exchange(NCollection_Sequence_HLRBRep_ShapeBounds self, Standard_Integer const I, Standard_Integer const J)

        Exchange two members

        :type I: int
        :type J: int

        """
        return _HLRBRep.NCollection_Sequence_HLRBRep_ShapeBounds_Exchange(self, *args)


    def delNode(*args):
        """
        delNode(NCollection_SeqNode theNode, Handle_NCollection_BaseAllocator theAl)

        Static deleter to be passed to BaseSequence

        :type theNode: OCC.wrapper.NCollection.NCollection_SeqNode
        :type theAl: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _HLRBRep.NCollection_Sequence_HLRBRep_ShapeBounds_delNode(*args)

    delNode = staticmethod(delNode)

    def Clear(self, *args):
        """
        Clear(NCollection_Sequence_HLRBRep_ShapeBounds self, Handle_NCollection_BaseAllocator theAllocator=0)

        Clear the items out, take a new allocator if non null

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _HLRBRep.NCollection_Sequence_HLRBRep_ShapeBounds_Clear(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Sequence_HLRBRep_ShapeBounds self, NCollection_Sequence_HLRBRep_ShapeBounds theOther) -> NCollection_Sequence_HLRBRep_ShapeBounds

        Replace this sequence by the items of theOther.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_Sequence
        :rtype: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _HLRBRep.NCollection_Sequence_HLRBRep_ShapeBounds_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Sequence_HLRBRep_ShapeBounds self, NCollection_Sequence_HLRBRep_ShapeBounds theOther) -> NCollection_Sequence_HLRBRep_ShapeBounds

        Replacement operator

        :type theOther: OCC.wrapper.NCollection.NCollection_Sequence
        :rtype: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _HLRBRep.NCollection_Sequence_HLRBRep_ShapeBounds_assign(self, *args)


    def Remove(self, *args):
        """
        Remove(NCollection_Sequence_HLRBRep_ShapeBounds self, NCollection_Sequence< HLRBRep_ShapeBounds >::Iterator & thePosition)
        Remove(NCollection_Sequence_HLRBRep_ShapeBounds self, Standard_Integer const theIndex)
        Remove(NCollection_Sequence_HLRBRep_ShapeBounds self, Standard_Integer const theFromIndex, Standard_Integer const theToIndex)

        Remove range of items

        :type theFromIndex: int
        :type theToIndex: int

        """
        return _HLRBRep.NCollection_Sequence_HLRBRep_ShapeBounds_Remove(self, *args)


    def Append(self, *args):
        """
        Append(NCollection_Sequence_HLRBRep_ShapeBounds self, HLRBRep_ShapeBounds theItem)
        Append(NCollection_Sequence_HLRBRep_ShapeBounds self, NCollection_Sequence_HLRBRep_ShapeBounds theSeq)

        Append another sequence (making it empty)

        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _HLRBRep.NCollection_Sequence_HLRBRep_ShapeBounds_Append(self, *args)


    def Prepend(self, *args):
        """
        Prepend(NCollection_Sequence_HLRBRep_ShapeBounds self, HLRBRep_ShapeBounds theItem)
        Prepend(NCollection_Sequence_HLRBRep_ShapeBounds self, NCollection_Sequence_HLRBRep_ShapeBounds theSeq)

        Prepend another sequence (making it empty)

        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _HLRBRep.NCollection_Sequence_HLRBRep_ShapeBounds_Prepend(self, *args)


    def InsertBefore(self, *args):
        """
        InsertBefore(NCollection_Sequence_HLRBRep_ShapeBounds self, Standard_Integer const theIndex, HLRBRep_ShapeBounds theItem)
        InsertBefore(NCollection_Sequence_HLRBRep_ShapeBounds self, Standard_Integer const theIndex, NCollection_Sequence_HLRBRep_ShapeBounds theSeq)

        InsertBefore theIndex another sequence

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _HLRBRep.NCollection_Sequence_HLRBRep_ShapeBounds_InsertBefore(self, *args)


    def InsertAfter(self, *args):
        """
        InsertAfter(NCollection_Sequence_HLRBRep_ShapeBounds self, NCollection_Sequence< HLRBRep_ShapeBounds >::Iterator & thePosition, HLRBRep_ShapeBounds theItem)
        InsertAfter(NCollection_Sequence_HLRBRep_ShapeBounds self, Standard_Integer const theIndex, NCollection_Sequence_HLRBRep_ShapeBounds theSeq)
        InsertAfter(NCollection_Sequence_HLRBRep_ShapeBounds self, Standard_Integer const theIndex, HLRBRep_ShapeBounds theItem)

        InsertAfter theIndex another sequence

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _HLRBRep.NCollection_Sequence_HLRBRep_ShapeBounds_InsertAfter(self, *args)


    def Split(self, *args):
        """
        Split(NCollection_Sequence_HLRBRep_ShapeBounds self, Standard_Integer const theIndex, NCollection_Sequence_HLRBRep_ShapeBounds theSeq)

        Split in two sequences

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _HLRBRep.NCollection_Sequence_HLRBRep_ShapeBounds_Split(self, *args)


    def First(self, *args):
        """
        First item access

        :rtype: const TheItemType &

        """
        res = _HLRBRep.NCollection_Sequence_HLRBRep_ShapeBounds_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Sequence_HLRBRep_ShapeBounds self) -> HLRBRep_ShapeBounds

        First item access

        :rtype: TheItemType &

        """
        return _HLRBRep.NCollection_Sequence_HLRBRep_ShapeBounds_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        Last item access

        :rtype: const TheItemType &

        """
        res = _HLRBRep.NCollection_Sequence_HLRBRep_ShapeBounds_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Sequence_HLRBRep_ShapeBounds self) -> HLRBRep_ShapeBounds

        Last item access

        :rtype: TheItemType &

        """
        return _HLRBRep.NCollection_Sequence_HLRBRep_ShapeBounds_ChangeLast(self, *args)


    def Value(self, *args):
        """
        Constant item access by theIndex

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _HLRBRep.NCollection_Sequence_HLRBRep_ShapeBounds_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Sequence_HLRBRep_ShapeBounds self, Standard_Integer const theIndex) -> HLRBRep_ShapeBounds

        Variable item access by theIndex

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _HLRBRep.NCollection_Sequence_HLRBRep_ShapeBounds_ChangeValue(self, *args)


    def __call__(self, *args):
        """
        Constant operator()

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _HLRBRep.NCollection_Sequence_HLRBRep_ShapeBounds___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetValue(self, *args):
        """
        SetValue(NCollection_Sequence_HLRBRep_ShapeBounds self, Standard_Integer const theIndex, HLRBRep_ShapeBounds theItem)

        Set item value by theIndex

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _HLRBRep.NCollection_Sequence_HLRBRep_ShapeBounds_SetValue(self, *args)


    def __iter__(self):
        return _HLRBRep.NCollection_Sequence_HLRBRep_ShapeBounds___iter__(self)
    __swig_destroy__ = _HLRBRep.delete_NCollection_Sequence_HLRBRep_ShapeBounds
NCollection_Sequence_HLRBRep_ShapeBounds_swigregister = _HLRBRep.NCollection_Sequence_HLRBRep_ShapeBounds_swigregister
NCollection_Sequence_HLRBRep_ShapeBounds_swigregister(NCollection_Sequence_HLRBRep_ShapeBounds)

def NCollection_Sequence_HLRBRep_ShapeBounds_delNode(*args):
    """
    NCollection_Sequence_HLRBRep_ShapeBounds_delNode(NCollection_SeqNode theNode, Handle_NCollection_BaseAllocator theAl)

    Static deleter to be passed to BaseSequence

    :type theNode: OCC.wrapper.NCollection.NCollection_SeqNode
    :type theAl: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

    """
    return _HLRBRep.NCollection_Sequence_HLRBRep_ShapeBounds_delNode(*args)

class NCollection_Sequence_HLRBRep_ShapeBounds_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _HLRBRep.new_NCollection_Sequence_HLRBRep_ShapeBounds_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _HLRBRep.delete_NCollection_Sequence_HLRBRep_ShapeBounds_IteratorHelper

    def __next__(self):
        return _HLRBRep.NCollection_Sequence_HLRBRep_ShapeBounds_IteratorHelper___next__(self)
NCollection_Sequence_HLRBRep_ShapeBounds_IteratorHelper_swigregister = _HLRBRep.NCollection_Sequence_HLRBRep_ShapeBounds_IteratorHelper_swigregister
NCollection_Sequence_HLRBRep_ShapeBounds_IteratorHelper_swigregister(NCollection_Sequence_HLRBRep_ShapeBounds_IteratorHelper)


try:
	HLRBRep_SeqOfShapeBounds = NCollection_Sequence_HLRBRep_ShapeBounds
except NameError:
	pass # does not exist, probably ignored

class HLRBRep_ExactIntersectionPointOfTheIntPCurvePCurveOfCInter(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(HLRBRep_ExactIntersectionPointOfTheIntPCurvePCurveOfCInter self, Standard_Address const & C1, Standard_Address const & C2, Standard_Real const Tol) -> HLRBRep_ExactIntersectionPointOfTheIntPCurvePCurveOfCInter

        :type C1: OCC.wrapper.Standard.Standard_Address
        :type C2: OCC.wrapper.Standard.Standard_Address
        :type Tol: float

        """
        this = _HLRBRep.new_HLRBRep_ExactIntersectionPointOfTheIntPCurvePCurveOfCInter(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Perform(self, *args):
        """
        Perform(HLRBRep_ExactIntersectionPointOfTheIntPCurvePCurveOfCInter self, HLRBRep_ThePolygon2dOfTheIntPCurvePCurveOfCInter Poly1, HLRBRep_ThePolygon2dOfTheIntPCurvePCurveOfCInter Poly2)
        Perform(HLRBRep_ExactIntersectionPointOfTheIntPCurvePCurveOfCInter self, Standard_Real const Uo, Standard_Real const Vo, Standard_Real const UInf, Standard_Real const VInf, Standard_Real const USup, Standard_Real const VSup)

        :type Uo: float
        :type Vo: float
        :type UInf: float
        :type VInf: float
        :type USup: float
        :type VSup: float

        """
        return _HLRBRep.HLRBRep_ExactIntersectionPointOfTheIntPCurvePCurveOfCInter_Perform(self, *args)


    def NbRoots(self, *args):
        """
        NbRoots(HLRBRep_ExactIntersectionPointOfTheIntPCurvePCurveOfCInter self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _HLRBRep.HLRBRep_ExactIntersectionPointOfTheIntPCurvePCurveOfCInter_NbRoots(self, *args)


    def Roots(self, *args):
        """
        Roots(HLRBRep_ExactIntersectionPointOfTheIntPCurvePCurveOfCInter self)

        :type U: float
        :type V: float

        """
        return _HLRBRep.HLRBRep_ExactIntersectionPointOfTheIntPCurvePCurveOfCInter_Roots(self, *args)


    def AnErrorOccurred(self, *args):
        """
        AnErrorOccurred(HLRBRep_ExactIntersectionPointOfTheIntPCurvePCurveOfCInter self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _HLRBRep.HLRBRep_ExactIntersectionPointOfTheIntPCurvePCurveOfCInter_AnErrorOccurred(self, *args)

    __swig_destroy__ = _HLRBRep.delete_HLRBRep_ExactIntersectionPointOfTheIntPCurvePCurveOfCInter
HLRBRep_ExactIntersectionPointOfTheIntPCurvePCurveOfCInter_swigregister = _HLRBRep.HLRBRep_ExactIntersectionPointOfTheIntPCurvePCurveOfCInter_swigregister
HLRBRep_ExactIntersectionPointOfTheIntPCurvePCurveOfCInter_swigregister(HLRBRep_ExactIntersectionPointOfTheIntPCurvePCurveOfCInter)

class Handle_HLRBRep_InternalAlgo(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_HLRBRep_InternalAlgo self)

        Nullify the handle


        """
        return _HLRBRep.Handle_HLRBRep_InternalAlgo_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_HLRBRep_InternalAlgo self) -> bool

        Check for being null

        :rtype: bool

        """
        return _HLRBRep.Handle_HLRBRep_InternalAlgo_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_HLRBRep_InternalAlgo self, HLRBRep_InternalAlgo thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _HLRBRep.Handle_HLRBRep_InternalAlgo_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_HLRBRep_InternalAlgo self, Handle_HLRBRep_InternalAlgo theHandle) -> Handle_HLRBRep_InternalAlgo
        assign(Handle_HLRBRep_InternalAlgo self, HLRBRep_InternalAlgo thePtr) -> Handle_HLRBRep_InternalAlgo
        assign(Handle_HLRBRep_InternalAlgo self, Handle_HLRBRep_InternalAlgo theHandle) -> Handle_HLRBRep_InternalAlgo

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _HLRBRep.Handle_HLRBRep_InternalAlgo_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_HLRBRep_InternalAlgo self) -> HLRBRep_InternalAlgo

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _HLRBRep.Handle_HLRBRep_InternalAlgo_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_HLRBRep_InternalAlgo self) -> HLRBRep_InternalAlgo

        Member access operator (note non-const)

        :rtype: T *

        """
        return _HLRBRep.Handle_HLRBRep_InternalAlgo___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_HLRBRep_InternalAlgo self) -> HLRBRep_InternalAlgo

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _HLRBRep.Handle_HLRBRep_InternalAlgo___ref__(self, *args)


    def __hash__(self):
        return _HLRBRep.Handle_HLRBRep_InternalAlgo___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _HLRBRep.Handle_HLRBRep_InternalAlgo___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _HLRBRep.new_Handle_HLRBRep_InternalAlgo(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_HLRBRep.Handle_HLRBRep_InternalAlgo_DownCast)
    __swig_destroy__ = _HLRBRep.delete_Handle_HLRBRep_InternalAlgo

    def Projector(self, *args):
        """
        Projector(Handle_HLRBRep_InternalAlgo self, HLRAlgo_Projector P)
        Projector(Handle_HLRBRep_InternalAlgo self) -> HLRAlgo_Projector

        set the projector.

        :rtype: OCC.wrapper.HLRAlgo.HLRAlgo_Projector

        """
        return _HLRBRep.Handle_HLRBRep_InternalAlgo_Projector(self, *args)


    def Update(self, *args):
        """
        Update(Handle_HLRBRep_InternalAlgo self)

        update the DataStructure.


        """
        return _HLRBRep.Handle_HLRBRep_InternalAlgo_Update(self, *args)


    def Load(self, *args):
        """
        Load(Handle_HLRBRep_InternalAlgo self, Handle_HLRTopoBRep_OutLiner S, Handle_Standard_Transient SData, Standard_Integer const nbIso=0)
        Load(Handle_HLRBRep_InternalAlgo self, Handle_HLRTopoBRep_OutLiner S, Standard_Integer const nbIso=0)

        add the shape <S>.

        :type S: OCC.wrapper.HLRTopoBRep.Handle_HLRTopoBRep_OutLiner
        :type nbIso: int

        """
        return _HLRBRep.Handle_HLRBRep_InternalAlgo_Load(self, *args)


    def Index(self, *args):
        """
        Index(Handle_HLRBRep_InternalAlgo self, Handle_HLRTopoBRep_OutLiner S) -> Standard_Integer

        return the index of the Shape <S> and  return 0 if
        the Shape <S> is not found.

        :type S: OCC.wrapper.HLRTopoBRep.Handle_HLRTopoBRep_OutLiner
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _HLRBRep.Handle_HLRBRep_InternalAlgo_Index(self, *args)


    def Remove(self, *args):
        """
        Remove(Handle_HLRBRep_InternalAlgo self, Standard_Integer const I)

        remove the Shape of Index <I>.

        :type I: int

        """
        return _HLRBRep.Handle_HLRBRep_InternalAlgo_Remove(self, *args)


    def ShapeData(self, *args):
        """
        ShapeData(Handle_HLRBRep_InternalAlgo self, Standard_Integer const I, Handle_Standard_Transient SData)

        Change the Shape Data of the Shape of index <I>.

        :type I: int
        :type SData: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _HLRBRep.Handle_HLRBRep_InternalAlgo_ShapeData(self, *args)


    def SeqOfShapeBounds(self, *args):
        """
        SeqOfShapeBounds(Handle_HLRBRep_InternalAlgo self) -> NCollection_Sequence_HLRBRep_ShapeBounds

        :rtype: OCC.wrapper.HLRBRep.HLRBRep_SeqOfShapeBounds

        """
        return _HLRBRep.Handle_HLRBRep_InternalAlgo_SeqOfShapeBounds(self, *args)


    def NbShapes(self, *args):
        """
        NbShapes(Handle_HLRBRep_InternalAlgo self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _HLRBRep.Handle_HLRBRep_InternalAlgo_NbShapes(self, *args)


    def ShapeBounds(self, *args):
        """
        ShapeBounds(Handle_HLRBRep_InternalAlgo self, Standard_Integer const I) -> HLRBRep_ShapeBounds

        :type I: int
        :rtype: OCC.wrapper.HLRBRep.HLRBRep_ShapeBounds

        """
        return _HLRBRep.Handle_HLRBRep_InternalAlgo_ShapeBounds(self, *args)


    def InitEdgeStatus(self, *args):
        """
        InitEdgeStatus(Handle_HLRBRep_InternalAlgo self)

        init the status of the selected edges depending of
        the back faces of a closed shell.


        """
        return _HLRBRep.Handle_HLRBRep_InternalAlgo_InitEdgeStatus(self, *args)


    def Select(self, *args):
        """
        Select(Handle_HLRBRep_InternalAlgo self)
        Select(Handle_HLRBRep_InternalAlgo self, Standard_Integer const I)

        select  only   the Shape of index <I>.

        :type I: int

        """
        return _HLRBRep.Handle_HLRBRep_InternalAlgo_Select(self, *args)


    def SelectEdge(self, *args):
        """
        SelectEdge(Handle_HLRBRep_InternalAlgo self, Standard_Integer const I)

        select only the edges of the Shape <S>.

        :type I: int

        """
        return _HLRBRep.Handle_HLRBRep_InternalAlgo_SelectEdge(self, *args)


    def SelectFace(self, *args):
        """
        SelectFace(Handle_HLRBRep_InternalAlgo self, Standard_Integer const I)

        select only the faces of the Shape <S>.

        :type I: int

        """
        return _HLRBRep.Handle_HLRBRep_InternalAlgo_SelectFace(self, *args)


    def ShowAll(self, *args):
        """
        ShowAll(Handle_HLRBRep_InternalAlgo self)
        ShowAll(Handle_HLRBRep_InternalAlgo self, Standard_Integer const I)

        set to visible all the edges of the Shape <S>.

        :type I: int

        """
        return _HLRBRep.Handle_HLRBRep_InternalAlgo_ShowAll(self, *args)


    def HideAll(self, *args):
        """
        HideAll(Handle_HLRBRep_InternalAlgo self)
        HideAll(Handle_HLRBRep_InternalAlgo self, Standard_Integer const I)

        set to  hide all the  edges of the  Shape <S>.

        :type I: int

        """
        return _HLRBRep.Handle_HLRBRep_InternalAlgo_HideAll(self, *args)


    def PartialHide(self, *args):
        """
        PartialHide(Handle_HLRBRep_InternalAlgo self)

        own hiding  of all the shapes of the DataStructure
        without hiding by each other.


        """
        return _HLRBRep.Handle_HLRBRep_InternalAlgo_PartialHide(self, *args)


    def Hide(self, *args):
        """
        Hide(Handle_HLRBRep_InternalAlgo self)
        Hide(Handle_HLRBRep_InternalAlgo self, Standard_Integer const I)
        Hide(Handle_HLRBRep_InternalAlgo self, Standard_Integer const I, Standard_Integer const J)

        hide the Shape <S1> by the shape <S2>.

        :type I: int
        :type J: int

        """
        return _HLRBRep.Handle_HLRBRep_InternalAlgo_Hide(self, *args)


    def Debug(self, *args):
        """
        Debug(Handle_HLRBRep_InternalAlgo self, Standard_Boolean const deb)
        Debug(Handle_HLRBRep_InternalAlgo self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _HLRBRep.Handle_HLRBRep_InternalAlgo_Debug(self, *args)


    def DataStructure(self, *args):
        """
        DataStructure(Handle_HLRBRep_InternalAlgo self) -> Handle_HLRBRep_Data

        :rtype: OCC.wrapper.HLRBRep.Handle_HLRBRep_Data

        """
        return _HLRBRep.Handle_HLRBRep_InternalAlgo_DataStructure(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_HLRBRep_InternalAlgo self) -> char const *

        :rtype: const char *

        """
        return _HLRBRep.Handle_HLRBRep_InternalAlgo_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _HLRBRep.Handle_HLRBRep_InternalAlgo_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _HLRBRep.Handle_HLRBRep_InternalAlgo_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_HLRBRep_InternalAlgo self)

        Memory deallocator for transient classes


        """
        return _HLRBRep.Handle_HLRBRep_InternalAlgo_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_HLRBRep_InternalAlgo self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_HLRBRep_InternalAlgo self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _HLRBRep.Handle_HLRBRep_InternalAlgo_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_HLRBRep_InternalAlgo self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_HLRBRep_InternalAlgo self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _HLRBRep.Handle_HLRBRep_InternalAlgo_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_HLRBRep_InternalAlgo self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _HLRBRep.Handle_HLRBRep_InternalAlgo_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_HLRBRep_InternalAlgo self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _HLRBRep.Handle_HLRBRep_InternalAlgo_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_HLRBRep_InternalAlgo self)

        Increments the reference counter of this object


        """
        return _HLRBRep.Handle_HLRBRep_InternalAlgo_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_HLRBRep_InternalAlgo self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _HLRBRep.Handle_HLRBRep_InternalAlgo_DecrementRefCounter(self, *args)

Handle_HLRBRep_InternalAlgo_swigregister = _HLRBRep.Handle_HLRBRep_InternalAlgo_swigregister
Handle_HLRBRep_InternalAlgo_swigregister(Handle_HLRBRep_InternalAlgo)

def Handle_HLRBRep_InternalAlgo_DownCast(thing):
    return _HLRBRep.Handle_HLRBRep_InternalAlgo_DownCast(thing)
Handle_HLRBRep_InternalAlgo_DownCast = _HLRBRep.Handle_HLRBRep_InternalAlgo_DownCast

class HLRBRep_Hider(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(HLRBRep_Hider self, Handle_HLRBRep_Data DS) -> HLRBRep_Hider

        Creates a Hider processing  the set  of  Edges and
        hiding faces described by <DS>.  Stores the hidden
        parts in <DS>.

        :type DS: OCC.wrapper.HLRBRep.Handle_HLRBRep_Data

        """
        this = _HLRBRep.new_HLRBRep_Hider(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def OwnHiding(self, *args):
        """
        OwnHiding(HLRBRep_Hider self, Standard_Integer const FI)

        own hiding the side face number <FI>.

        :type FI: int

        """
        return _HLRBRep.HLRBRep_Hider_OwnHiding(self, *args)


    def Hide(self, *args):
        """
        Hide(HLRBRep_Hider self, Standard_Integer const FI, NCollection_DataMap_TopoDS_Shape_BRepTopAdaptor_Tool_TopTools_ShapeMapHasher MST)

        Removes from the edges,   the parts hidden by  the
        hiding face number <FI>.

        :type FI: int
        :type MST: OCC.wrapper.BRepTopAdaptor.BRepTopAdaptor_MapOfShapeTool

        """
        return _HLRBRep.HLRBRep_Hider_Hide(self, *args)

    __swig_destroy__ = _HLRBRep.delete_HLRBRep_Hider
HLRBRep_Hider_swigregister = _HLRBRep.HLRBRep_Hider_swigregister
HLRBRep_Hider_swigregister(HLRBRep_Hider)

class HLRBRep_CLPropsATool(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Value(*args):
        """
        Value(HLRBRep_Curve A, Standard_Real const U, gp_Pnt2d P)

        Computes the  point <P> of  parameter <U>   on the
        Curve from HLRBRep <C>.

        :type A: OCC.wrapper.HLRBRep.HLRBRep_Curve
        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt2d

        """
        return _HLRBRep.HLRBRep_CLPropsATool_Value(*args)

    Value = staticmethod(Value)

    def D1(*args):
        """
        D1(HLRBRep_Curve A, Standard_Real const U, gp_Pnt2d P, gp_Vec2d V1)

        Computes the point <P>  and  first derivative <V1>
        of parameter <U> on the curve <C>.

        :type A: OCC.wrapper.HLRBRep.HLRBRep_Curve
        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type V1: OCC.wrapper.gp.gp_Vec2d

        """
        return _HLRBRep.HLRBRep_CLPropsATool_D1(*args)

    D1 = staticmethod(D1)

    def D2(*args):
        """
        D2(HLRBRep_Curve A, Standard_Real const U, gp_Pnt2d P, gp_Vec2d V1, gp_Vec2d V2)

        Computes the point <P>,  the first derivative <V1>
        and second derivative <V2> of parameter <U> on the
        curve <C>.

        :type A: OCC.wrapper.HLRBRep.HLRBRep_Curve
        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type V1: OCC.wrapper.gp.gp_Vec2d
        :type V2: OCC.wrapper.gp.gp_Vec2d

        """
        return _HLRBRep.HLRBRep_CLPropsATool_D2(*args)

    D2 = staticmethod(D2)

    def D3(*args):
        """
        D3(HLRBRep_Curve A, Standard_Real const U, gp_Pnt2d P, gp_Vec2d V1, gp_Vec2d V2, gp_Vec2d V3)

        Computes the point <P>, the first derivative <V1>,
        the second derivative  <V2>   and third derivative
        <V3> of parameter <U> on the curve <C>.

        :type A: OCC.wrapper.HLRBRep.HLRBRep_Curve
        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type V1: OCC.wrapper.gp.gp_Vec2d
        :type V2: OCC.wrapper.gp.gp_Vec2d
        :type V3: OCC.wrapper.gp.gp_Vec2d

        """
        return _HLRBRep.HLRBRep_CLPropsATool_D3(*args)

    D3 = staticmethod(D3)

    def Continuity(*args):
        """
        Continuity(HLRBRep_Curve A) -> Standard_Integer

        returns the order  of continuity of the curve <C>.
        returns 1 :  first  derivative only is  computable
        returns 2  : first and  second derivative only are
        computable.  returns  3 : first,  second and third
        are computable.

        :type A: OCC.wrapper.HLRBRep.HLRBRep_Curve
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _HLRBRep.HLRBRep_CLPropsATool_Continuity(*args)

    Continuity = staticmethod(Continuity)

    def FirstParameter(*args):
        """
        FirstParameter(HLRBRep_Curve A) -> Standard_Real

        returns the first parameter bound of the curve.

        :type A: OCC.wrapper.HLRBRep.HLRBRep_Curve
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _HLRBRep.HLRBRep_CLPropsATool_FirstParameter(*args)

    FirstParameter = staticmethod(FirstParameter)

    def LastParameter(*args):
        """
        LastParameter(HLRBRep_Curve A) -> Standard_Real

        returns the  last  parameter bound  of  the curve.
        FirstParameter must be less than LastParamenter.

        :type A: OCC.wrapper.HLRBRep.HLRBRep_Curve
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _HLRBRep.HLRBRep_CLPropsATool_LastParameter(*args)

    LastParameter = staticmethod(LastParameter)

    def __init__(self):
        this = _HLRBRep.new_HLRBRep_CLPropsATool()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _HLRBRep.delete_HLRBRep_CLPropsATool
HLRBRep_CLPropsATool_swigregister = _HLRBRep.HLRBRep_CLPropsATool_swigregister
HLRBRep_CLPropsATool_swigregister(HLRBRep_CLPropsATool)

def HLRBRep_CLPropsATool_Value(*args):
    """
    HLRBRep_CLPropsATool_Value(HLRBRep_Curve A, Standard_Real const U, gp_Pnt2d P)

    Computes the  point <P> of  parameter <U>   on the
    Curve from HLRBRep <C>.

    :type A: OCC.wrapper.HLRBRep.HLRBRep_Curve
    :type U: float
    :type P: OCC.wrapper.gp.gp_Pnt2d

    """
    return _HLRBRep.HLRBRep_CLPropsATool_Value(*args)

def HLRBRep_CLPropsATool_D1(*args):
    """
    HLRBRep_CLPropsATool_D1(HLRBRep_Curve A, Standard_Real const U, gp_Pnt2d P, gp_Vec2d V1)

    Computes the point <P>  and  first derivative <V1>
    of parameter <U> on the curve <C>.

    :type A: OCC.wrapper.HLRBRep.HLRBRep_Curve
    :type U: float
    :type P: OCC.wrapper.gp.gp_Pnt2d
    :type V1: OCC.wrapper.gp.gp_Vec2d

    """
    return _HLRBRep.HLRBRep_CLPropsATool_D1(*args)

def HLRBRep_CLPropsATool_D2(*args):
    """
    HLRBRep_CLPropsATool_D2(HLRBRep_Curve A, Standard_Real const U, gp_Pnt2d P, gp_Vec2d V1, gp_Vec2d V2)

    Computes the point <P>,  the first derivative <V1>
    and second derivative <V2> of parameter <U> on the
    curve <C>.

    :type A: OCC.wrapper.HLRBRep.HLRBRep_Curve
    :type U: float
    :type P: OCC.wrapper.gp.gp_Pnt2d
    :type V1: OCC.wrapper.gp.gp_Vec2d
    :type V2: OCC.wrapper.gp.gp_Vec2d

    """
    return _HLRBRep.HLRBRep_CLPropsATool_D2(*args)

def HLRBRep_CLPropsATool_D3(*args):
    """
    HLRBRep_CLPropsATool_D3(HLRBRep_Curve A, Standard_Real const U, gp_Pnt2d P, gp_Vec2d V1, gp_Vec2d V2, gp_Vec2d V3)

    Computes the point <P>, the first derivative <V1>,
    the second derivative  <V2>   and third derivative
    <V3> of parameter <U> on the curve <C>.

    :type A: OCC.wrapper.HLRBRep.HLRBRep_Curve
    :type U: float
    :type P: OCC.wrapper.gp.gp_Pnt2d
    :type V1: OCC.wrapper.gp.gp_Vec2d
    :type V2: OCC.wrapper.gp.gp_Vec2d
    :type V3: OCC.wrapper.gp.gp_Vec2d

    """
    return _HLRBRep.HLRBRep_CLPropsATool_D3(*args)

def HLRBRep_CLPropsATool_Continuity(*args):
    """
    HLRBRep_CLPropsATool_Continuity(HLRBRep_Curve A) -> Standard_Integer

    returns the order  of continuity of the curve <C>.
    returns 1 :  first  derivative only is  computable
    returns 2  : first and  second derivative only are
    computable.  returns  3 : first,  second and third
    are computable.

    :type A: OCC.wrapper.HLRBRep.HLRBRep_Curve
    :rtype: OCC.wrapper.Standard.Standard_Integer

    """
    return _HLRBRep.HLRBRep_CLPropsATool_Continuity(*args)

def HLRBRep_CLPropsATool_FirstParameter(*args):
    """
    HLRBRep_CLPropsATool_FirstParameter(HLRBRep_Curve A) -> Standard_Real

    returns the first parameter bound of the curve.

    :type A: OCC.wrapper.HLRBRep.HLRBRep_Curve
    :rtype: OCC.wrapper.Standard.Standard_Real

    """
    return _HLRBRep.HLRBRep_CLPropsATool_FirstParameter(*args)

def HLRBRep_CLPropsATool_LastParameter(*args):
    """
    HLRBRep_CLPropsATool_LastParameter(HLRBRep_Curve A) -> Standard_Real

    returns the  last  parameter bound  of  the curve.
    FirstParameter must be less than LastParamenter.

    :type A: OCC.wrapper.HLRBRep.HLRBRep_Curve
    :rtype: OCC.wrapper.Standard.Standard_Real

    """
    return _HLRBRep.HLRBRep_CLPropsATool_LastParameter(*args)

class HLRBRep_BSurfaceTool(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def FirstUParameter(*args):
        """
        FirstUParameter(BRepAdaptor_Surface S) -> Standard_Real

        :type S: OCC.wrapper.BRepAdaptor.BRepAdaptor_Surface
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _HLRBRep.HLRBRep_BSurfaceTool_FirstUParameter(*args)

    FirstUParameter = staticmethod(FirstUParameter)

    def FirstVParameter(*args):
        """
        FirstVParameter(BRepAdaptor_Surface S) -> Standard_Real

        :type S: OCC.wrapper.BRepAdaptor.BRepAdaptor_Surface
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _HLRBRep.HLRBRep_BSurfaceTool_FirstVParameter(*args)

    FirstVParameter = staticmethod(FirstVParameter)

    def LastUParameter(*args):
        """
        LastUParameter(BRepAdaptor_Surface S) -> Standard_Real

        :type S: OCC.wrapper.BRepAdaptor.BRepAdaptor_Surface
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _HLRBRep.HLRBRep_BSurfaceTool_LastUParameter(*args)

    LastUParameter = staticmethod(LastUParameter)

    def LastVParameter(*args):
        """
        LastVParameter(BRepAdaptor_Surface S) -> Standard_Real

        :type S: OCC.wrapper.BRepAdaptor.BRepAdaptor_Surface
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _HLRBRep.HLRBRep_BSurfaceTool_LastVParameter(*args)

    LastVParameter = staticmethod(LastVParameter)

    def NbUIntervals(*args):
        """
        NbUIntervals(BRepAdaptor_Surface S, GeomAbs_Shape const Sh) -> Standard_Integer

        :type S: OCC.wrapper.BRepAdaptor.BRepAdaptor_Surface
        :type Sh: OCC.wrapper.GeomAbs.GeomAbs_Shape
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _HLRBRep.HLRBRep_BSurfaceTool_NbUIntervals(*args)

    NbUIntervals = staticmethod(NbUIntervals)

    def NbVIntervals(*args):
        """
        NbVIntervals(BRepAdaptor_Surface S, GeomAbs_Shape const Sh) -> Standard_Integer

        :type S: OCC.wrapper.BRepAdaptor.BRepAdaptor_Surface
        :type Sh: OCC.wrapper.GeomAbs.GeomAbs_Shape
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _HLRBRep.HLRBRep_BSurfaceTool_NbVIntervals(*args)

    NbVIntervals = staticmethod(NbVIntervals)

    def UIntervals(*args):
        """
        UIntervals(BRepAdaptor_Surface S, NCollection_Array1_Standard_Real T, GeomAbs_Shape const Sh)

        :type S: OCC.wrapper.BRepAdaptor.BRepAdaptor_Surface
        :type T: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type Sh: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _HLRBRep.HLRBRep_BSurfaceTool_UIntervals(*args)

    UIntervals = staticmethod(UIntervals)

    def VIntervals(*args):
        """
        VIntervals(BRepAdaptor_Surface S, NCollection_Array1_Standard_Real T, GeomAbs_Shape const Sh)

        :type S: OCC.wrapper.BRepAdaptor.BRepAdaptor_Surface
        :type T: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type Sh: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _HLRBRep.HLRBRep_BSurfaceTool_VIntervals(*args)

    VIntervals = staticmethod(VIntervals)

    def UTrim(*args):
        """
        UTrim(BRepAdaptor_Surface S, Standard_Real const First, Standard_Real const Last, Standard_Real const Tol) -> Handle_Adaptor3d_HSurface

        If <First> >= <Last>

        :type S: OCC.wrapper.BRepAdaptor.BRepAdaptor_Surface
        :type First: float
        :type Last: float
        :type Tol: float
        :rtype: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface

        """
        return _HLRBRep.HLRBRep_BSurfaceTool_UTrim(*args)

    UTrim = staticmethod(UTrim)

    def VTrim(*args):
        """
        VTrim(BRepAdaptor_Surface S, Standard_Real const First, Standard_Real const Last, Standard_Real const Tol) -> Handle_Adaptor3d_HSurface

        If <First> >= <Last>

        :type S: OCC.wrapper.BRepAdaptor.BRepAdaptor_Surface
        :type First: float
        :type Last: float
        :type Tol: float
        :rtype: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface

        """
        return _HLRBRep.HLRBRep_BSurfaceTool_VTrim(*args)

    VTrim = staticmethod(VTrim)

    def IsUClosed(*args):
        """
        IsUClosed(BRepAdaptor_Surface S) -> Standard_Boolean

        :type S: OCC.wrapper.BRepAdaptor.BRepAdaptor_Surface
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _HLRBRep.HLRBRep_BSurfaceTool_IsUClosed(*args)

    IsUClosed = staticmethod(IsUClosed)

    def IsVClosed(*args):
        """
        IsVClosed(BRepAdaptor_Surface S) -> Standard_Boolean

        :type S: OCC.wrapper.BRepAdaptor.BRepAdaptor_Surface
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _HLRBRep.HLRBRep_BSurfaceTool_IsVClosed(*args)

    IsVClosed = staticmethod(IsVClosed)

    def IsUPeriodic(*args):
        """
        IsUPeriodic(BRepAdaptor_Surface S) -> Standard_Boolean

        :type S: OCC.wrapper.BRepAdaptor.BRepAdaptor_Surface
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _HLRBRep.HLRBRep_BSurfaceTool_IsUPeriodic(*args)

    IsUPeriodic = staticmethod(IsUPeriodic)

    def UPeriod(*args):
        """
        UPeriod(BRepAdaptor_Surface S) -> Standard_Real

        :type S: OCC.wrapper.BRepAdaptor.BRepAdaptor_Surface
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _HLRBRep.HLRBRep_BSurfaceTool_UPeriod(*args)

    UPeriod = staticmethod(UPeriod)

    def IsVPeriodic(*args):
        """
        IsVPeriodic(BRepAdaptor_Surface S) -> Standard_Boolean

        :type S: OCC.wrapper.BRepAdaptor.BRepAdaptor_Surface
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _HLRBRep.HLRBRep_BSurfaceTool_IsVPeriodic(*args)

    IsVPeriodic = staticmethod(IsVPeriodic)

    def VPeriod(*args):
        """
        VPeriod(BRepAdaptor_Surface S) -> Standard_Real

        :type S: OCC.wrapper.BRepAdaptor.BRepAdaptor_Surface
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _HLRBRep.HLRBRep_BSurfaceTool_VPeriod(*args)

    VPeriod = staticmethod(VPeriod)

    def Value(*args):
        """
        Value(BRepAdaptor_Surface S, Standard_Real const u, Standard_Real const v) -> gp_Pnt

        :type S: OCC.wrapper.BRepAdaptor.BRepAdaptor_Surface
        :type u: float
        :type v: float
        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _HLRBRep.HLRBRep_BSurfaceTool_Value(*args)

    Value = staticmethod(Value)

    def D0(*args):
        """
        D0(BRepAdaptor_Surface S, Standard_Real const u, Standard_Real const v, gp_Pnt P)

        :type S: OCC.wrapper.BRepAdaptor.BRepAdaptor_Surface
        :type u: float
        :type v: float
        :type P: OCC.wrapper.gp.gp_Pnt

        """
        return _HLRBRep.HLRBRep_BSurfaceTool_D0(*args)

    D0 = staticmethod(D0)

    def D1(*args):
        """
        D1(BRepAdaptor_Surface S, Standard_Real const u, Standard_Real const v, gp_Pnt P, gp_Vec D1u, gp_Vec D1v)

        :type S: OCC.wrapper.BRepAdaptor.BRepAdaptor_Surface
        :type u: float
        :type v: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type D1u: OCC.wrapper.gp.gp_Vec
        :type D1v: OCC.wrapper.gp.gp_Vec

        """
        return _HLRBRep.HLRBRep_BSurfaceTool_D1(*args)

    D1 = staticmethod(D1)

    def D2(*args):
        """
        D2(BRepAdaptor_Surface S, Standard_Real const u, Standard_Real const v, gp_Pnt P, gp_Vec D1U, gp_Vec D1V, gp_Vec D2U, gp_Vec D2V, gp_Vec D2UV)

        :type S: OCC.wrapper.BRepAdaptor.BRepAdaptor_Surface
        :type u: float
        :type v: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type D1U: OCC.wrapper.gp.gp_Vec
        :type D1V: OCC.wrapper.gp.gp_Vec
        :type D2U: OCC.wrapper.gp.gp_Vec
        :type D2V: OCC.wrapper.gp.gp_Vec
        :type D2UV: OCC.wrapper.gp.gp_Vec

        """
        return _HLRBRep.HLRBRep_BSurfaceTool_D2(*args)

    D2 = staticmethod(D2)

    def D3(*args):
        """
        D3(BRepAdaptor_Surface S, Standard_Real const u, Standard_Real const v, gp_Pnt P, gp_Vec D1U, gp_Vec D1V, gp_Vec D2U, gp_Vec D2V, gp_Vec D2UV, gp_Vec D3U, gp_Vec D3V, gp_Vec D3UUV, gp_Vec D3UVV)

        :type S: OCC.wrapper.BRepAdaptor.BRepAdaptor_Surface
        :type u: float
        :type v: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type D1U: OCC.wrapper.gp.gp_Vec
        :type D1V: OCC.wrapper.gp.gp_Vec
        :type D2U: OCC.wrapper.gp.gp_Vec
        :type D2V: OCC.wrapper.gp.gp_Vec
        :type D2UV: OCC.wrapper.gp.gp_Vec
        :type D3U: OCC.wrapper.gp.gp_Vec
        :type D3V: OCC.wrapper.gp.gp_Vec
        :type D3UUV: OCC.wrapper.gp.gp_Vec
        :type D3UVV: OCC.wrapper.gp.gp_Vec

        """
        return _HLRBRep.HLRBRep_BSurfaceTool_D3(*args)

    D3 = staticmethod(D3)

    def DN(*args):
        """
        DN(BRepAdaptor_Surface S, Standard_Real const u, Standard_Real const v, Standard_Integer const Nu, Standard_Integer const Nv) -> gp_Vec

        :type S: OCC.wrapper.BRepAdaptor.BRepAdaptor_Surface
        :type u: float
        :type v: float
        :type Nu: int
        :type Nv: int
        :rtype: OCC.wrapper.gp.gp_Vec

        """
        return _HLRBRep.HLRBRep_BSurfaceTool_DN(*args)

    DN = staticmethod(DN)

    def UContinuity(*args):
        """
        UContinuity(BRepAdaptor_Surface S) -> GeomAbs_Shape

        :type S: OCC.wrapper.BRepAdaptor.BRepAdaptor_Surface
        :rtype: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _HLRBRep.HLRBRep_BSurfaceTool_UContinuity(*args)

    UContinuity = staticmethod(UContinuity)

    def VContinuity(*args):
        """
        VContinuity(BRepAdaptor_Surface S) -> GeomAbs_Shape

        :type S: OCC.wrapper.BRepAdaptor.BRepAdaptor_Surface
        :rtype: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _HLRBRep.HLRBRep_BSurfaceTool_VContinuity(*args)

    VContinuity = staticmethod(VContinuity)

    def UDegree(*args):
        """
        UDegree(BRepAdaptor_Surface S) -> Standard_Integer

        :type S: OCC.wrapper.BRepAdaptor.BRepAdaptor_Surface
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _HLRBRep.HLRBRep_BSurfaceTool_UDegree(*args)

    UDegree = staticmethod(UDegree)

    def NbUPoles(*args):
        """
        NbUPoles(BRepAdaptor_Surface S) -> Standard_Integer

        :type S: OCC.wrapper.BRepAdaptor.BRepAdaptor_Surface
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _HLRBRep.HLRBRep_BSurfaceTool_NbUPoles(*args)

    NbUPoles = staticmethod(NbUPoles)

    def NbUKnots(*args):
        """
        NbUKnots(BRepAdaptor_Surface S) -> Standard_Integer

        :type S: OCC.wrapper.BRepAdaptor.BRepAdaptor_Surface
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _HLRBRep.HLRBRep_BSurfaceTool_NbUKnots(*args)

    NbUKnots = staticmethod(NbUKnots)

    def IsURational(*args):
        """
        IsURational(BRepAdaptor_Surface S) -> Standard_Boolean

        :type S: OCC.wrapper.BRepAdaptor.BRepAdaptor_Surface
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _HLRBRep.HLRBRep_BSurfaceTool_IsURational(*args)

    IsURational = staticmethod(IsURational)

    def VDegree(*args):
        """
        VDegree(BRepAdaptor_Surface S) -> Standard_Integer

        :type S: OCC.wrapper.BRepAdaptor.BRepAdaptor_Surface
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _HLRBRep.HLRBRep_BSurfaceTool_VDegree(*args)

    VDegree = staticmethod(VDegree)

    def NbVPoles(*args):
        """
        NbVPoles(BRepAdaptor_Surface S) -> Standard_Integer

        :type S: OCC.wrapper.BRepAdaptor.BRepAdaptor_Surface
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _HLRBRep.HLRBRep_BSurfaceTool_NbVPoles(*args)

    NbVPoles = staticmethod(NbVPoles)

    def NbVKnots(*args):
        """
        NbVKnots(BRepAdaptor_Surface S) -> Standard_Integer

        :type S: OCC.wrapper.BRepAdaptor.BRepAdaptor_Surface
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _HLRBRep.HLRBRep_BSurfaceTool_NbVKnots(*args)

    NbVKnots = staticmethod(NbVKnots)

    def IsVRational(*args):
        """
        IsVRational(BRepAdaptor_Surface S) -> Standard_Boolean

        :type S: OCC.wrapper.BRepAdaptor.BRepAdaptor_Surface
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _HLRBRep.HLRBRep_BSurfaceTool_IsVRational(*args)

    IsVRational = staticmethod(IsVRational)

    def UResolution(*args):
        """
        UResolution(BRepAdaptor_Surface S, Standard_Real const R3d) -> Standard_Real

        :type S: OCC.wrapper.BRepAdaptor.BRepAdaptor_Surface
        :type R3d: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _HLRBRep.HLRBRep_BSurfaceTool_UResolution(*args)

    UResolution = staticmethod(UResolution)

    def VResolution(*args):
        """
        VResolution(BRepAdaptor_Surface S, Standard_Real const R3d) -> Standard_Real

        :type S: OCC.wrapper.BRepAdaptor.BRepAdaptor_Surface
        :type R3d: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _HLRBRep.HLRBRep_BSurfaceTool_VResolution(*args)

    VResolution = staticmethod(VResolution)

    def GetType(*args):
        """
        GetType(BRepAdaptor_Surface S) -> GeomAbs_SurfaceType

        :type S: OCC.wrapper.BRepAdaptor.BRepAdaptor_Surface
        :rtype: OCC.wrapper.GeomAbs.GeomAbs_SurfaceType

        """
        return _HLRBRep.HLRBRep_BSurfaceTool_GetType(*args)

    GetType = staticmethod(GetType)

    def Plane(*args):
        """
        Plane(BRepAdaptor_Surface S) -> gp_Pln

        :type S: OCC.wrapper.BRepAdaptor.BRepAdaptor_Surface
        :rtype: OCC.wrapper.gp.gp_Pln

        """
        return _HLRBRep.HLRBRep_BSurfaceTool_Plane(*args)

    Plane = staticmethod(Plane)

    def Cylinder(*args):
        """
        Cylinder(BRepAdaptor_Surface S) -> gp_Cylinder

        :type S: OCC.wrapper.BRepAdaptor.BRepAdaptor_Surface
        :rtype: OCC.wrapper.gp.gp_Cylinder

        """
        return _HLRBRep.HLRBRep_BSurfaceTool_Cylinder(*args)

    Cylinder = staticmethod(Cylinder)

    def Cone(*args):
        """
        Cone(BRepAdaptor_Surface S) -> gp_Cone

        :type S: OCC.wrapper.BRepAdaptor.BRepAdaptor_Surface
        :rtype: OCC.wrapper.gp.gp_Cone

        """
        return _HLRBRep.HLRBRep_BSurfaceTool_Cone(*args)

    Cone = staticmethod(Cone)

    def Torus(*args):
        """
        Torus(BRepAdaptor_Surface S) -> gp_Torus

        :type S: OCC.wrapper.BRepAdaptor.BRepAdaptor_Surface
        :rtype: OCC.wrapper.gp.gp_Torus

        """
        return _HLRBRep.HLRBRep_BSurfaceTool_Torus(*args)

    Torus = staticmethod(Torus)

    def Sphere(*args):
        """
        Sphere(BRepAdaptor_Surface S) -> gp_Sphere

        :type S: OCC.wrapper.BRepAdaptor.BRepAdaptor_Surface
        :rtype: OCC.wrapper.gp.gp_Sphere

        """
        return _HLRBRep.HLRBRep_BSurfaceTool_Sphere(*args)

    Sphere = staticmethod(Sphere)

    def Bezier(*args):
        """
        Bezier(BRepAdaptor_Surface S) -> Handle_Geom_BezierSurface

        :type S: OCC.wrapper.BRepAdaptor.BRepAdaptor_Surface
        :rtype: OCC.wrapper.Geom.Handle_Geom_BezierSurface

        """
        return _HLRBRep.HLRBRep_BSurfaceTool_Bezier(*args)

    Bezier = staticmethod(Bezier)

    def BSpline(*args):
        """
        BSpline(BRepAdaptor_Surface S) -> Handle_Geom_BSplineSurface

        :type S: OCC.wrapper.BRepAdaptor.BRepAdaptor_Surface
        :rtype: OCC.wrapper.Geom.Handle_Geom_BSplineSurface

        """
        return _HLRBRep.HLRBRep_BSurfaceTool_BSpline(*args)

    BSpline = staticmethod(BSpline)

    def AxeOfRevolution(*args):
        """
        AxeOfRevolution(BRepAdaptor_Surface S) -> gp_Ax1

        :type S: OCC.wrapper.BRepAdaptor.BRepAdaptor_Surface
        :rtype: OCC.wrapper.gp.gp_Ax1

        """
        return _HLRBRep.HLRBRep_BSurfaceTool_AxeOfRevolution(*args)

    AxeOfRevolution = staticmethod(AxeOfRevolution)

    def Direction(*args):
        """
        Direction(BRepAdaptor_Surface S) -> gp_Dir

        :type S: OCC.wrapper.BRepAdaptor.BRepAdaptor_Surface
        :rtype: OCC.wrapper.gp.gp_Dir

        """
        return _HLRBRep.HLRBRep_BSurfaceTool_Direction(*args)

    Direction = staticmethod(Direction)

    def BasisCurve(*args):
        """
        BasisCurve(BRepAdaptor_Surface S) -> Handle_Adaptor3d_HCurve

        :type S: OCC.wrapper.BRepAdaptor.BRepAdaptor_Surface
        :rtype: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HCurve

        """
        return _HLRBRep.HLRBRep_BSurfaceTool_BasisCurve(*args)

    BasisCurve = staticmethod(BasisCurve)

    def NbSamplesU(*args):
        """
        NbSamplesU(BRepAdaptor_Surface S) -> Standard_Integer
        NbSamplesU(BRepAdaptor_Surface S, Standard_Real const u1, Standard_Real const u2) -> Standard_Integer

        :type S: OCC.wrapper.BRepAdaptor.BRepAdaptor_Surface
        :type u1: float
        :type u2: float
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _HLRBRep.HLRBRep_BSurfaceTool_NbSamplesU(*args)

    NbSamplesU = staticmethod(NbSamplesU)

    def NbSamplesV(*args):
        """
        NbSamplesV(BRepAdaptor_Surface S) -> Standard_Integer
        NbSamplesV(BRepAdaptor_Surface S, Standard_Real const v1, Standard_Real const v2) -> Standard_Integer

        :type S: OCC.wrapper.BRepAdaptor.BRepAdaptor_Surface
        :type v1: float
        :type v2: float
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _HLRBRep.HLRBRep_BSurfaceTool_NbSamplesV(*args)

    NbSamplesV = staticmethod(NbSamplesV)

    def __init__(self):
        this = _HLRBRep.new_HLRBRep_BSurfaceTool()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _HLRBRep.delete_HLRBRep_BSurfaceTool
HLRBRep_BSurfaceTool_swigregister = _HLRBRep.HLRBRep_BSurfaceTool_swigregister
HLRBRep_BSurfaceTool_swigregister(HLRBRep_BSurfaceTool)

def HLRBRep_BSurfaceTool_FirstUParameter(*args):
    """
    HLRBRep_BSurfaceTool_FirstUParameter(BRepAdaptor_Surface S) -> Standard_Real

    :type S: OCC.wrapper.BRepAdaptor.BRepAdaptor_Surface
    :rtype: OCC.wrapper.Standard.Standard_Real

    """
    return _HLRBRep.HLRBRep_BSurfaceTool_FirstUParameter(*args)

def HLRBRep_BSurfaceTool_FirstVParameter(*args):
    """
    HLRBRep_BSurfaceTool_FirstVParameter(BRepAdaptor_Surface S) -> Standard_Real

    :type S: OCC.wrapper.BRepAdaptor.BRepAdaptor_Surface
    :rtype: OCC.wrapper.Standard.Standard_Real

    """
    return _HLRBRep.HLRBRep_BSurfaceTool_FirstVParameter(*args)

def HLRBRep_BSurfaceTool_LastUParameter(*args):
    """
    HLRBRep_BSurfaceTool_LastUParameter(BRepAdaptor_Surface S) -> Standard_Real

    :type S: OCC.wrapper.BRepAdaptor.BRepAdaptor_Surface
    :rtype: OCC.wrapper.Standard.Standard_Real

    """
    return _HLRBRep.HLRBRep_BSurfaceTool_LastUParameter(*args)

def HLRBRep_BSurfaceTool_LastVParameter(*args):
    """
    HLRBRep_BSurfaceTool_LastVParameter(BRepAdaptor_Surface S) -> Standard_Real

    :type S: OCC.wrapper.BRepAdaptor.BRepAdaptor_Surface
    :rtype: OCC.wrapper.Standard.Standard_Real

    """
    return _HLRBRep.HLRBRep_BSurfaceTool_LastVParameter(*args)

def HLRBRep_BSurfaceTool_NbUIntervals(*args):
    """
    HLRBRep_BSurfaceTool_NbUIntervals(BRepAdaptor_Surface S, GeomAbs_Shape const Sh) -> Standard_Integer

    :type S: OCC.wrapper.BRepAdaptor.BRepAdaptor_Surface
    :type Sh: OCC.wrapper.GeomAbs.GeomAbs_Shape
    :rtype: OCC.wrapper.Standard.Standard_Integer

    """
    return _HLRBRep.HLRBRep_BSurfaceTool_NbUIntervals(*args)

def HLRBRep_BSurfaceTool_NbVIntervals(*args):
    """
    HLRBRep_BSurfaceTool_NbVIntervals(BRepAdaptor_Surface S, GeomAbs_Shape const Sh) -> Standard_Integer

    :type S: OCC.wrapper.BRepAdaptor.BRepAdaptor_Surface
    :type Sh: OCC.wrapper.GeomAbs.GeomAbs_Shape
    :rtype: OCC.wrapper.Standard.Standard_Integer

    """
    return _HLRBRep.HLRBRep_BSurfaceTool_NbVIntervals(*args)

def HLRBRep_BSurfaceTool_UIntervals(*args):
    """
    HLRBRep_BSurfaceTool_UIntervals(BRepAdaptor_Surface S, NCollection_Array1_Standard_Real T, GeomAbs_Shape const Sh)

    :type S: OCC.wrapper.BRepAdaptor.BRepAdaptor_Surface
    :type T: OCC.wrapper.TColStd.TColStd_Array1OfReal
    :type Sh: OCC.wrapper.GeomAbs.GeomAbs_Shape

    """
    return _HLRBRep.HLRBRep_BSurfaceTool_UIntervals(*args)

def HLRBRep_BSurfaceTool_VIntervals(*args):
    """
    HLRBRep_BSurfaceTool_VIntervals(BRepAdaptor_Surface S, NCollection_Array1_Standard_Real T, GeomAbs_Shape const Sh)

    :type S: OCC.wrapper.BRepAdaptor.BRepAdaptor_Surface
    :type T: OCC.wrapper.TColStd.TColStd_Array1OfReal
    :type Sh: OCC.wrapper.GeomAbs.GeomAbs_Shape

    """
    return _HLRBRep.HLRBRep_BSurfaceTool_VIntervals(*args)

def HLRBRep_BSurfaceTool_UTrim(*args):
    """
    HLRBRep_BSurfaceTool_UTrim(BRepAdaptor_Surface S, Standard_Real const First, Standard_Real const Last, Standard_Real const Tol) -> Handle_Adaptor3d_HSurface

    If <First> >= <Last>

    :type S: OCC.wrapper.BRepAdaptor.BRepAdaptor_Surface
    :type First: float
    :type Last: float
    :type Tol: float
    :rtype: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface

    """
    return _HLRBRep.HLRBRep_BSurfaceTool_UTrim(*args)

def HLRBRep_BSurfaceTool_VTrim(*args):
    """
    HLRBRep_BSurfaceTool_VTrim(BRepAdaptor_Surface S, Standard_Real const First, Standard_Real const Last, Standard_Real const Tol) -> Handle_Adaptor3d_HSurface

    If <First> >= <Last>

    :type S: OCC.wrapper.BRepAdaptor.BRepAdaptor_Surface
    :type First: float
    :type Last: float
    :type Tol: float
    :rtype: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface

    """
    return _HLRBRep.HLRBRep_BSurfaceTool_VTrim(*args)

def HLRBRep_BSurfaceTool_IsUClosed(*args):
    """
    HLRBRep_BSurfaceTool_IsUClosed(BRepAdaptor_Surface S) -> Standard_Boolean

    :type S: OCC.wrapper.BRepAdaptor.BRepAdaptor_Surface
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _HLRBRep.HLRBRep_BSurfaceTool_IsUClosed(*args)

def HLRBRep_BSurfaceTool_IsVClosed(*args):
    """
    HLRBRep_BSurfaceTool_IsVClosed(BRepAdaptor_Surface S) -> Standard_Boolean

    :type S: OCC.wrapper.BRepAdaptor.BRepAdaptor_Surface
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _HLRBRep.HLRBRep_BSurfaceTool_IsVClosed(*args)

def HLRBRep_BSurfaceTool_IsUPeriodic(*args):
    """
    HLRBRep_BSurfaceTool_IsUPeriodic(BRepAdaptor_Surface S) -> Standard_Boolean

    :type S: OCC.wrapper.BRepAdaptor.BRepAdaptor_Surface
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _HLRBRep.HLRBRep_BSurfaceTool_IsUPeriodic(*args)

def HLRBRep_BSurfaceTool_UPeriod(*args):
    """
    HLRBRep_BSurfaceTool_UPeriod(BRepAdaptor_Surface S) -> Standard_Real

    :type S: OCC.wrapper.BRepAdaptor.BRepAdaptor_Surface
    :rtype: OCC.wrapper.Standard.Standard_Real

    """
    return _HLRBRep.HLRBRep_BSurfaceTool_UPeriod(*args)

def HLRBRep_BSurfaceTool_IsVPeriodic(*args):
    """
    HLRBRep_BSurfaceTool_IsVPeriodic(BRepAdaptor_Surface S) -> Standard_Boolean

    :type S: OCC.wrapper.BRepAdaptor.BRepAdaptor_Surface
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _HLRBRep.HLRBRep_BSurfaceTool_IsVPeriodic(*args)

def HLRBRep_BSurfaceTool_VPeriod(*args):
    """
    HLRBRep_BSurfaceTool_VPeriod(BRepAdaptor_Surface S) -> Standard_Real

    :type S: OCC.wrapper.BRepAdaptor.BRepAdaptor_Surface
    :rtype: OCC.wrapper.Standard.Standard_Real

    """
    return _HLRBRep.HLRBRep_BSurfaceTool_VPeriod(*args)

def HLRBRep_BSurfaceTool_Value(*args):
    """
    HLRBRep_BSurfaceTool_Value(BRepAdaptor_Surface S, Standard_Real const u, Standard_Real const v) -> gp_Pnt

    :type S: OCC.wrapper.BRepAdaptor.BRepAdaptor_Surface
    :type u: float
    :type v: float
    :rtype: OCC.wrapper.gp.gp_Pnt

    """
    return _HLRBRep.HLRBRep_BSurfaceTool_Value(*args)

def HLRBRep_BSurfaceTool_D0(*args):
    """
    HLRBRep_BSurfaceTool_D0(BRepAdaptor_Surface S, Standard_Real const u, Standard_Real const v, gp_Pnt P)

    :type S: OCC.wrapper.BRepAdaptor.BRepAdaptor_Surface
    :type u: float
    :type v: float
    :type P: OCC.wrapper.gp.gp_Pnt

    """
    return _HLRBRep.HLRBRep_BSurfaceTool_D0(*args)

def HLRBRep_BSurfaceTool_D1(*args):
    """
    HLRBRep_BSurfaceTool_D1(BRepAdaptor_Surface S, Standard_Real const u, Standard_Real const v, gp_Pnt P, gp_Vec D1u, gp_Vec D1v)

    :type S: OCC.wrapper.BRepAdaptor.BRepAdaptor_Surface
    :type u: float
    :type v: float
    :type P: OCC.wrapper.gp.gp_Pnt
    :type D1u: OCC.wrapper.gp.gp_Vec
    :type D1v: OCC.wrapper.gp.gp_Vec

    """
    return _HLRBRep.HLRBRep_BSurfaceTool_D1(*args)

def HLRBRep_BSurfaceTool_D2(*args):
    """
    HLRBRep_BSurfaceTool_D2(BRepAdaptor_Surface S, Standard_Real const u, Standard_Real const v, gp_Pnt P, gp_Vec D1U, gp_Vec D1V, gp_Vec D2U, gp_Vec D2V, gp_Vec D2UV)

    :type S: OCC.wrapper.BRepAdaptor.BRepAdaptor_Surface
    :type u: float
    :type v: float
    :type P: OCC.wrapper.gp.gp_Pnt
    :type D1U: OCC.wrapper.gp.gp_Vec
    :type D1V: OCC.wrapper.gp.gp_Vec
    :type D2U: OCC.wrapper.gp.gp_Vec
    :type D2V: OCC.wrapper.gp.gp_Vec
    :type D2UV: OCC.wrapper.gp.gp_Vec

    """
    return _HLRBRep.HLRBRep_BSurfaceTool_D2(*args)

def HLRBRep_BSurfaceTool_D3(*args):
    """
    HLRBRep_BSurfaceTool_D3(BRepAdaptor_Surface S, Standard_Real const u, Standard_Real const v, gp_Pnt P, gp_Vec D1U, gp_Vec D1V, gp_Vec D2U, gp_Vec D2V, gp_Vec D2UV, gp_Vec D3U, gp_Vec D3V, gp_Vec D3UUV, gp_Vec D3UVV)

    :type S: OCC.wrapper.BRepAdaptor.BRepAdaptor_Surface
    :type u: float
    :type v: float
    :type P: OCC.wrapper.gp.gp_Pnt
    :type D1U: OCC.wrapper.gp.gp_Vec
    :type D1V: OCC.wrapper.gp.gp_Vec
    :type D2U: OCC.wrapper.gp.gp_Vec
    :type D2V: OCC.wrapper.gp.gp_Vec
    :type D2UV: OCC.wrapper.gp.gp_Vec
    :type D3U: OCC.wrapper.gp.gp_Vec
    :type D3V: OCC.wrapper.gp.gp_Vec
    :type D3UUV: OCC.wrapper.gp.gp_Vec
    :type D3UVV: OCC.wrapper.gp.gp_Vec

    """
    return _HLRBRep.HLRBRep_BSurfaceTool_D3(*args)

def HLRBRep_BSurfaceTool_DN(*args):
    """
    HLRBRep_BSurfaceTool_DN(BRepAdaptor_Surface S, Standard_Real const u, Standard_Real const v, Standard_Integer const Nu, Standard_Integer const Nv) -> gp_Vec

    :type S: OCC.wrapper.BRepAdaptor.BRepAdaptor_Surface
    :type u: float
    :type v: float
    :type Nu: int
    :type Nv: int
    :rtype: OCC.wrapper.gp.gp_Vec

    """
    return _HLRBRep.HLRBRep_BSurfaceTool_DN(*args)

def HLRBRep_BSurfaceTool_UContinuity(*args):
    """
    HLRBRep_BSurfaceTool_UContinuity(BRepAdaptor_Surface S) -> GeomAbs_Shape

    :type S: OCC.wrapper.BRepAdaptor.BRepAdaptor_Surface
    :rtype: OCC.wrapper.GeomAbs.GeomAbs_Shape

    """
    return _HLRBRep.HLRBRep_BSurfaceTool_UContinuity(*args)

def HLRBRep_BSurfaceTool_VContinuity(*args):
    """
    HLRBRep_BSurfaceTool_VContinuity(BRepAdaptor_Surface S) -> GeomAbs_Shape

    :type S: OCC.wrapper.BRepAdaptor.BRepAdaptor_Surface
    :rtype: OCC.wrapper.GeomAbs.GeomAbs_Shape

    """
    return _HLRBRep.HLRBRep_BSurfaceTool_VContinuity(*args)

def HLRBRep_BSurfaceTool_UDegree(*args):
    """
    HLRBRep_BSurfaceTool_UDegree(BRepAdaptor_Surface S) -> Standard_Integer

    :type S: OCC.wrapper.BRepAdaptor.BRepAdaptor_Surface
    :rtype: OCC.wrapper.Standard.Standard_Integer

    """
    return _HLRBRep.HLRBRep_BSurfaceTool_UDegree(*args)

def HLRBRep_BSurfaceTool_NbUPoles(*args):
    """
    HLRBRep_BSurfaceTool_NbUPoles(BRepAdaptor_Surface S) -> Standard_Integer

    :type S: OCC.wrapper.BRepAdaptor.BRepAdaptor_Surface
    :rtype: OCC.wrapper.Standard.Standard_Integer

    """
    return _HLRBRep.HLRBRep_BSurfaceTool_NbUPoles(*args)

def HLRBRep_BSurfaceTool_NbUKnots(*args):
    """
    HLRBRep_BSurfaceTool_NbUKnots(BRepAdaptor_Surface S) -> Standard_Integer

    :type S: OCC.wrapper.BRepAdaptor.BRepAdaptor_Surface
    :rtype: OCC.wrapper.Standard.Standard_Integer

    """
    return _HLRBRep.HLRBRep_BSurfaceTool_NbUKnots(*args)

def HLRBRep_BSurfaceTool_IsURational(*args):
    """
    HLRBRep_BSurfaceTool_IsURational(BRepAdaptor_Surface S) -> Standard_Boolean

    :type S: OCC.wrapper.BRepAdaptor.BRepAdaptor_Surface
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _HLRBRep.HLRBRep_BSurfaceTool_IsURational(*args)

def HLRBRep_BSurfaceTool_VDegree(*args):
    """
    HLRBRep_BSurfaceTool_VDegree(BRepAdaptor_Surface S) -> Standard_Integer

    :type S: OCC.wrapper.BRepAdaptor.BRepAdaptor_Surface
    :rtype: OCC.wrapper.Standard.Standard_Integer

    """
    return _HLRBRep.HLRBRep_BSurfaceTool_VDegree(*args)

def HLRBRep_BSurfaceTool_NbVPoles(*args):
    """
    HLRBRep_BSurfaceTool_NbVPoles(BRepAdaptor_Surface S) -> Standard_Integer

    :type S: OCC.wrapper.BRepAdaptor.BRepAdaptor_Surface
    :rtype: OCC.wrapper.Standard.Standard_Integer

    """
    return _HLRBRep.HLRBRep_BSurfaceTool_NbVPoles(*args)

def HLRBRep_BSurfaceTool_NbVKnots(*args):
    """
    HLRBRep_BSurfaceTool_NbVKnots(BRepAdaptor_Surface S) -> Standard_Integer

    :type S: OCC.wrapper.BRepAdaptor.BRepAdaptor_Surface
    :rtype: OCC.wrapper.Standard.Standard_Integer

    """
    return _HLRBRep.HLRBRep_BSurfaceTool_NbVKnots(*args)

def HLRBRep_BSurfaceTool_IsVRational(*args):
    """
    HLRBRep_BSurfaceTool_IsVRational(BRepAdaptor_Surface S) -> Standard_Boolean

    :type S: OCC.wrapper.BRepAdaptor.BRepAdaptor_Surface
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _HLRBRep.HLRBRep_BSurfaceTool_IsVRational(*args)

def HLRBRep_BSurfaceTool_UResolution(*args):
    """
    HLRBRep_BSurfaceTool_UResolution(BRepAdaptor_Surface S, Standard_Real const R3d) -> Standard_Real

    :type S: OCC.wrapper.BRepAdaptor.BRepAdaptor_Surface
    :type R3d: float
    :rtype: OCC.wrapper.Standard.Standard_Real

    """
    return _HLRBRep.HLRBRep_BSurfaceTool_UResolution(*args)

def HLRBRep_BSurfaceTool_VResolution(*args):
    """
    HLRBRep_BSurfaceTool_VResolution(BRepAdaptor_Surface S, Standard_Real const R3d) -> Standard_Real

    :type S: OCC.wrapper.BRepAdaptor.BRepAdaptor_Surface
    :type R3d: float
    :rtype: OCC.wrapper.Standard.Standard_Real

    """
    return _HLRBRep.HLRBRep_BSurfaceTool_VResolution(*args)

def HLRBRep_BSurfaceTool_GetType(*args):
    """
    HLRBRep_BSurfaceTool_GetType(BRepAdaptor_Surface S) -> GeomAbs_SurfaceType

    :type S: OCC.wrapper.BRepAdaptor.BRepAdaptor_Surface
    :rtype: OCC.wrapper.GeomAbs.GeomAbs_SurfaceType

    """
    return _HLRBRep.HLRBRep_BSurfaceTool_GetType(*args)

def HLRBRep_BSurfaceTool_Plane(*args):
    """
    HLRBRep_BSurfaceTool_Plane(BRepAdaptor_Surface S) -> gp_Pln

    :type S: OCC.wrapper.BRepAdaptor.BRepAdaptor_Surface
    :rtype: OCC.wrapper.gp.gp_Pln

    """
    return _HLRBRep.HLRBRep_BSurfaceTool_Plane(*args)

def HLRBRep_BSurfaceTool_Cylinder(*args):
    """
    HLRBRep_BSurfaceTool_Cylinder(BRepAdaptor_Surface S) -> gp_Cylinder

    :type S: OCC.wrapper.BRepAdaptor.BRepAdaptor_Surface
    :rtype: OCC.wrapper.gp.gp_Cylinder

    """
    return _HLRBRep.HLRBRep_BSurfaceTool_Cylinder(*args)

def HLRBRep_BSurfaceTool_Cone(*args):
    """
    HLRBRep_BSurfaceTool_Cone(BRepAdaptor_Surface S) -> gp_Cone

    :type S: OCC.wrapper.BRepAdaptor.BRepAdaptor_Surface
    :rtype: OCC.wrapper.gp.gp_Cone

    """
    return _HLRBRep.HLRBRep_BSurfaceTool_Cone(*args)

def HLRBRep_BSurfaceTool_Torus(*args):
    """
    HLRBRep_BSurfaceTool_Torus(BRepAdaptor_Surface S) -> gp_Torus

    :type S: OCC.wrapper.BRepAdaptor.BRepAdaptor_Surface
    :rtype: OCC.wrapper.gp.gp_Torus

    """
    return _HLRBRep.HLRBRep_BSurfaceTool_Torus(*args)

def HLRBRep_BSurfaceTool_Sphere(*args):
    """
    HLRBRep_BSurfaceTool_Sphere(BRepAdaptor_Surface S) -> gp_Sphere

    :type S: OCC.wrapper.BRepAdaptor.BRepAdaptor_Surface
    :rtype: OCC.wrapper.gp.gp_Sphere

    """
    return _HLRBRep.HLRBRep_BSurfaceTool_Sphere(*args)

def HLRBRep_BSurfaceTool_Bezier(*args):
    """
    HLRBRep_BSurfaceTool_Bezier(BRepAdaptor_Surface S) -> Handle_Geom_BezierSurface

    :type S: OCC.wrapper.BRepAdaptor.BRepAdaptor_Surface
    :rtype: OCC.wrapper.Geom.Handle_Geom_BezierSurface

    """
    return _HLRBRep.HLRBRep_BSurfaceTool_Bezier(*args)

def HLRBRep_BSurfaceTool_BSpline(*args):
    """
    HLRBRep_BSurfaceTool_BSpline(BRepAdaptor_Surface S) -> Handle_Geom_BSplineSurface

    :type S: OCC.wrapper.BRepAdaptor.BRepAdaptor_Surface
    :rtype: OCC.wrapper.Geom.Handle_Geom_BSplineSurface

    """
    return _HLRBRep.HLRBRep_BSurfaceTool_BSpline(*args)

def HLRBRep_BSurfaceTool_AxeOfRevolution(*args):
    """
    HLRBRep_BSurfaceTool_AxeOfRevolution(BRepAdaptor_Surface S) -> gp_Ax1

    :type S: OCC.wrapper.BRepAdaptor.BRepAdaptor_Surface
    :rtype: OCC.wrapper.gp.gp_Ax1

    """
    return _HLRBRep.HLRBRep_BSurfaceTool_AxeOfRevolution(*args)

def HLRBRep_BSurfaceTool_Direction(*args):
    """
    HLRBRep_BSurfaceTool_Direction(BRepAdaptor_Surface S) -> gp_Dir

    :type S: OCC.wrapper.BRepAdaptor.BRepAdaptor_Surface
    :rtype: OCC.wrapper.gp.gp_Dir

    """
    return _HLRBRep.HLRBRep_BSurfaceTool_Direction(*args)

def HLRBRep_BSurfaceTool_BasisCurve(*args):
    """
    HLRBRep_BSurfaceTool_BasisCurve(BRepAdaptor_Surface S) -> Handle_Adaptor3d_HCurve

    :type S: OCC.wrapper.BRepAdaptor.BRepAdaptor_Surface
    :rtype: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HCurve

    """
    return _HLRBRep.HLRBRep_BSurfaceTool_BasisCurve(*args)

def HLRBRep_BSurfaceTool_NbSamplesU(*args):
    """
    NbSamplesU(BRepAdaptor_Surface S) -> Standard_Integer
    HLRBRep_BSurfaceTool_NbSamplesU(BRepAdaptor_Surface S, Standard_Real const u1, Standard_Real const u2) -> Standard_Integer

    :type S: OCC.wrapper.BRepAdaptor.BRepAdaptor_Surface
    :type u1: float
    :type u2: float
    :rtype: OCC.wrapper.Standard.Standard_Integer

    """
    return _HLRBRep.HLRBRep_BSurfaceTool_NbSamplesU(*args)

def HLRBRep_BSurfaceTool_NbSamplesV(*args):
    """
    NbSamplesV(BRepAdaptor_Surface S) -> Standard_Integer
    HLRBRep_BSurfaceTool_NbSamplesV(BRepAdaptor_Surface S, Standard_Real const v1, Standard_Real const v2) -> Standard_Integer

    :type S: OCC.wrapper.BRepAdaptor.BRepAdaptor_Surface
    :type v1: float
    :type v2: float
    :rtype: OCC.wrapper.Standard.Standard_Integer

    """
    return _HLRBRep.HLRBRep_BSurfaceTool_NbSamplesV(*args)

class Handle_HLRBRep_PolyAlgo(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_HLRBRep_PolyAlgo self)

        Nullify the handle


        """
        return _HLRBRep.Handle_HLRBRep_PolyAlgo_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_HLRBRep_PolyAlgo self) -> bool

        Check for being null

        :rtype: bool

        """
        return _HLRBRep.Handle_HLRBRep_PolyAlgo_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_HLRBRep_PolyAlgo self, HLRBRep_PolyAlgo thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _HLRBRep.Handle_HLRBRep_PolyAlgo_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_HLRBRep_PolyAlgo self, Handle_HLRBRep_PolyAlgo theHandle) -> Handle_HLRBRep_PolyAlgo
        assign(Handle_HLRBRep_PolyAlgo self, HLRBRep_PolyAlgo thePtr) -> Handle_HLRBRep_PolyAlgo
        assign(Handle_HLRBRep_PolyAlgo self, Handle_HLRBRep_PolyAlgo theHandle) -> Handle_HLRBRep_PolyAlgo

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _HLRBRep.Handle_HLRBRep_PolyAlgo_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_HLRBRep_PolyAlgo self) -> HLRBRep_PolyAlgo

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _HLRBRep.Handle_HLRBRep_PolyAlgo_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_HLRBRep_PolyAlgo self) -> HLRBRep_PolyAlgo

        Member access operator (note non-const)

        :rtype: T *

        """
        return _HLRBRep.Handle_HLRBRep_PolyAlgo___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_HLRBRep_PolyAlgo self) -> HLRBRep_PolyAlgo

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _HLRBRep.Handle_HLRBRep_PolyAlgo___ref__(self, *args)


    def __hash__(self):
        return _HLRBRep.Handle_HLRBRep_PolyAlgo___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _HLRBRep.Handle_HLRBRep_PolyAlgo___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _HLRBRep.new_Handle_HLRBRep_PolyAlgo(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_HLRBRep.Handle_HLRBRep_PolyAlgo_DownCast)
    __swig_destroy__ = _HLRBRep.delete_Handle_HLRBRep_PolyAlgo

    def NbShapes(self, *args):
        """
        NbShapes(Handle_HLRBRep_PolyAlgo self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _HLRBRep.Handle_HLRBRep_PolyAlgo_NbShapes(self, *args)


    def Shape(self, *args):
        """
        Shape(Handle_HLRBRep_PolyAlgo self, Standard_Integer const I) -> TopoDS_Shape

        :type I: int
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _HLRBRep.Handle_HLRBRep_PolyAlgo_Shape(self, *args)


    def Remove(self, *args):
        """
        Remove(Handle_HLRBRep_PolyAlgo self, Standard_Integer const I)

        remove the Shape of Index <I>.

        :type I: int

        """
        return _HLRBRep.Handle_HLRBRep_PolyAlgo_Remove(self, *args)


    def Index(self, *args):
        """
        Index(Handle_HLRBRep_PolyAlgo self, TopoDS_Shape S) -> Standard_Integer

        return the index of the Shape <S> and  return 0 if
        the Shape <S> is not found.

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _HLRBRep.Handle_HLRBRep_PolyAlgo_Index(self, *args)


    def Load(self, *args):
        """
        Load(Handle_HLRBRep_PolyAlgo self, TopoDS_Shape S)

        Loads the shape S into this framework.
        Warning S must have already been triangulated.

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _HLRBRep.Handle_HLRBRep_PolyAlgo_Load(self, *args)


    def Algo(self, *args):
        """
        Algo(Handle_HLRBRep_PolyAlgo self) -> Handle_HLRAlgo_PolyAlgo

        :rtype: OCC.wrapper.HLRAlgo.Handle_HLRAlgo_PolyAlgo

        """
        return _HLRBRep.Handle_HLRBRep_PolyAlgo_Algo(self, *args)


    def Projector(self, *args):
        """
        Sets the parameters of the view for this framework.
        These parameters are defined by an HLRAlgo_Projector object,
        which is returned by the Projector function on a Prs3d_Projector object.

        :rtype: OCC.wrapper.HLRAlgo.HLRAlgo_Projector

        """
        res = _HLRBRep.Handle_HLRBRep_PolyAlgo_Projector(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Angle(self, *args):
        """
        Angle(Handle_HLRBRep_PolyAlgo self) -> Standard_Real
        Angle(Handle_HLRBRep_PolyAlgo self, Standard_Real const Ang)

        :type Ang: float

        """
        return _HLRBRep.Handle_HLRBRep_PolyAlgo_Angle(self, *args)


    def TolAngular(self, *args):
        """
        TolAngular(Handle_HLRBRep_PolyAlgo self) -> Standard_Real
        TolAngular(Handle_HLRBRep_PolyAlgo self, Standard_Real const Tol)

        :type Tol: float

        """
        return _HLRBRep.Handle_HLRBRep_PolyAlgo_TolAngular(self, *args)


    def TolCoef(self, *args):
        """
        TolCoef(Handle_HLRBRep_PolyAlgo self) -> Standard_Real
        TolCoef(Handle_HLRBRep_PolyAlgo self, Standard_Real const Tol)

        :type Tol: float

        """
        return _HLRBRep.Handle_HLRBRep_PolyAlgo_TolCoef(self, *args)


    def Update(self, *args):
        """
        Update(Handle_HLRBRep_PolyAlgo self)

        Launches calculation of outlines of the shape
        visualized by this framework. Used after setting the point of view and
        defining the shape or shapes to be visualized.


        """
        return _HLRBRep.Handle_HLRBRep_PolyAlgo_Update(self, *args)


    def InitHide(self, *args):
        """InitHide(Handle_HLRBRep_PolyAlgo self)"""
        return _HLRBRep.Handle_HLRBRep_PolyAlgo_InitHide(self, *args)


    def MoreHide(self, *args):
        """
        MoreHide(Handle_HLRBRep_PolyAlgo self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _HLRBRep.Handle_HLRBRep_PolyAlgo_MoreHide(self, *args)


    def NextHide(self, *args):
        """NextHide(Handle_HLRBRep_PolyAlgo self)"""
        return _HLRBRep.Handle_HLRBRep_PolyAlgo_NextHide(self, *args)


    def Hide(self, *args):
        """
        Hide(Handle_HLRBRep_PolyAlgo self, HLRAlgo_EdgeStatus status, TopoDS_Shape S) -> HLRAlgo_BiPoint::PointsT &

        :type status: OCC.wrapper.HLRAlgo.HLRAlgo_EdgeStatus
        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :type reg1: bool
        :type regn: bool
        :type outl: bool
        :type intl: bool
        :rtype: PointsT

        """
        return _HLRBRep.Handle_HLRBRep_PolyAlgo_Hide(self, *args)


    def InitShow(self, *args):
        """InitShow(Handle_HLRBRep_PolyAlgo self)"""
        return _HLRBRep.Handle_HLRBRep_PolyAlgo_InitShow(self, *args)


    def MoreShow(self, *args):
        """
        MoreShow(Handle_HLRBRep_PolyAlgo self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _HLRBRep.Handle_HLRBRep_PolyAlgo_MoreShow(self, *args)


    def NextShow(self, *args):
        """NextShow(Handle_HLRBRep_PolyAlgo self)"""
        return _HLRBRep.Handle_HLRBRep_PolyAlgo_NextShow(self, *args)


    def Show(self, *args):
        """
        Show(Handle_HLRBRep_PolyAlgo self, TopoDS_Shape S) -> HLRAlgo_BiPoint::PointsT &

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :type reg1: bool
        :type regn: bool
        :type outl: bool
        :type intl: bool
        :rtype: PointsT

        """
        return _HLRBRep.Handle_HLRBRep_PolyAlgo_Show(self, *args)


    def OutLinedShape(self, *args):
        """
        OutLinedShape(Handle_HLRBRep_PolyAlgo self, TopoDS_Shape S) -> TopoDS_Shape

        Make a shape  with  the internal outlines in  each
        face.

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _HLRBRep.Handle_HLRBRep_PolyAlgo_OutLinedShape(self, *args)


    def Debug(self, *args):
        """
        Debug(Handle_HLRBRep_PolyAlgo self) -> Standard_Boolean
        Debug(Handle_HLRBRep_PolyAlgo self, Standard_Boolean const B)

        :type B: bool

        """
        return _HLRBRep.Handle_HLRBRep_PolyAlgo_Debug(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_HLRBRep_PolyAlgo self) -> char const *

        :rtype: const char *

        """
        return _HLRBRep.Handle_HLRBRep_PolyAlgo_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _HLRBRep.Handle_HLRBRep_PolyAlgo_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _HLRBRep.Handle_HLRBRep_PolyAlgo_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_HLRBRep_PolyAlgo self)

        Memory deallocator for transient classes


        """
        return _HLRBRep.Handle_HLRBRep_PolyAlgo_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_HLRBRep_PolyAlgo self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_HLRBRep_PolyAlgo self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _HLRBRep.Handle_HLRBRep_PolyAlgo_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_HLRBRep_PolyAlgo self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_HLRBRep_PolyAlgo self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _HLRBRep.Handle_HLRBRep_PolyAlgo_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_HLRBRep_PolyAlgo self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _HLRBRep.Handle_HLRBRep_PolyAlgo_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_HLRBRep_PolyAlgo self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _HLRBRep.Handle_HLRBRep_PolyAlgo_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_HLRBRep_PolyAlgo self)

        Increments the reference counter of this object


        """
        return _HLRBRep.Handle_HLRBRep_PolyAlgo_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_HLRBRep_PolyAlgo self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _HLRBRep.Handle_HLRBRep_PolyAlgo_DecrementRefCounter(self, *args)

Handle_HLRBRep_PolyAlgo_swigregister = _HLRBRep.Handle_HLRBRep_PolyAlgo_swigregister
Handle_HLRBRep_PolyAlgo_swigregister(Handle_HLRBRep_PolyAlgo)

def Handle_HLRBRep_PolyAlgo_DownCast(thing):
    return _HLRBRep.Handle_HLRBRep_PolyAlgo_DownCast(thing)
Handle_HLRBRep_PolyAlgo_DownCast = _HLRBRep.Handle_HLRBRep_PolyAlgo_DownCast

class HLRBRep_EdgeBuilder(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(HLRBRep_EdgeBuilder self, HLRBRep_VertexList VList) -> HLRBRep_EdgeBuilder

        Creates  an   EdgeBuilder    algorithm.    <VList>
        describes   the edge    and  the    interferences.
        AreaLimits   are   created  from   the   vertices.
        Builds(IN) is automatically called.

        :type VList: OCC.wrapper.HLRBRep.HLRBRep_VertexList

        """
        this = _HLRBRep.new_HLRBRep_EdgeBuilder(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def InitAreas(self, *args):
        """
        InitAreas(HLRBRep_EdgeBuilder self)

        Initialize an iteration on the areas.


        """
        return _HLRBRep.HLRBRep_EdgeBuilder_InitAreas(self, *args)


    def NextArea(self, *args):
        """
        NextArea(HLRBRep_EdgeBuilder self)

        Set the current area to the next area.


        """
        return _HLRBRep.HLRBRep_EdgeBuilder_NextArea(self, *args)


    def PreviousArea(self, *args):
        """
        PreviousArea(HLRBRep_EdgeBuilder self)

        Set the current area to the previous area.


        """
        return _HLRBRep.HLRBRep_EdgeBuilder_PreviousArea(self, *args)


    def HasArea(self, *args):
        """
        HasArea(HLRBRep_EdgeBuilder self) -> Standard_Boolean

        Returns True if there is a current area.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _HLRBRep.HLRBRep_EdgeBuilder_HasArea(self, *args)


    def AreaState(self, *args):
        """
        AreaState(HLRBRep_EdgeBuilder self) -> TopAbs_State

        Returns the state of the current area.

        :rtype: OCC.wrapper.TopAbs.TopAbs_State

        """
        return _HLRBRep.HLRBRep_EdgeBuilder_AreaState(self, *args)


    def AreaEdgeState(self, *args):
        """
        AreaEdgeState(HLRBRep_EdgeBuilder self) -> TopAbs_State

        Returns the edge state of the current area.

        :rtype: OCC.wrapper.TopAbs.TopAbs_State

        """
        return _HLRBRep.HLRBRep_EdgeBuilder_AreaEdgeState(self, *args)


    def LeftLimit(self, *args):
        """
        LeftLimit(HLRBRep_EdgeBuilder self) -> Handle_HLRBRep_AreaLimit

        Returns the  AreaLimit beginning the current area.
        This is a NULL handle when the area is infinite on
        the left.

        :rtype: OCC.wrapper.HLRBRep.Handle_HLRBRep_AreaLimit

        """
        return _HLRBRep.HLRBRep_EdgeBuilder_LeftLimit(self, *args)


    def RightLimit(self, *args):
        """
        RightLimit(HLRBRep_EdgeBuilder self) -> Handle_HLRBRep_AreaLimit

        Returns the  AreaLimit   ending  the current area.
        This is a NULL handle when the area is infinite on
        the right.

        :rtype: OCC.wrapper.HLRBRep.Handle_HLRBRep_AreaLimit

        """
        return _HLRBRep.HLRBRep_EdgeBuilder_RightLimit(self, *args)


    def Builds(self, *args):
        """
        Builds(HLRBRep_EdgeBuilder self, TopAbs_State const ToBuild)

        Reinitialize  the results  iteration  to the parts
        with State <ToBuild>. If this method is not called
        after construction the default is <ToBuild> = IN.

        :type ToBuild: OCC.wrapper.TopAbs.TopAbs_State

        """
        return _HLRBRep.HLRBRep_EdgeBuilder_Builds(self, *args)


    def MoreEdges(self, *args):
        """
        MoreEdges(HLRBRep_EdgeBuilder self) -> Standard_Boolean

        Returns True if there are more new edges to build.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _HLRBRep.HLRBRep_EdgeBuilder_MoreEdges(self, *args)


    def NextEdge(self, *args):
        """
        NextEdge(HLRBRep_EdgeBuilder self)

        Proceeds  to  the  next  edge to  build.  Skip all
        remaining vertices on the current edge.


        """
        return _HLRBRep.HLRBRep_EdgeBuilder_NextEdge(self, *args)


    def MoreVertices(self, *args):
        """
        MoreVertices(HLRBRep_EdgeBuilder self) -> Standard_Boolean

        True if there are more vertices in the current new
        edge.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _HLRBRep.HLRBRep_EdgeBuilder_MoreVertices(self, *args)


    def NextVertex(self, *args):
        """
        NextVertex(HLRBRep_EdgeBuilder self)

        Proceeds to the next vertex of the current edge.


        """
        return _HLRBRep.HLRBRep_EdgeBuilder_NextVertex(self, *args)


    def Current(self, *args):
        """
        Returns the current vertex of the current edge.

        :rtype: OCC.wrapper.HLRAlgo.HLRAlgo_Intersection

        """
        res = _HLRBRep.HLRBRep_EdgeBuilder_Current(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def IsBoundary(self, *args):
        """
        IsBoundary(HLRBRep_EdgeBuilder self) -> Standard_Boolean

        Returns True if the  current vertex comes from the
        boundary of the edge.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _HLRBRep.HLRBRep_EdgeBuilder_IsBoundary(self, *args)


    def IsInterference(self, *args):
        """
        IsInterference(HLRBRep_EdgeBuilder self) -> Standard_Boolean

        Returns  True if    the  current  vertex  was   an
        interference.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _HLRBRep.HLRBRep_EdgeBuilder_IsInterference(self, *args)


    def Orientation(self, *args):
        """
        Orientation(HLRBRep_EdgeBuilder self) -> TopAbs_Orientation

        Returns the new orientation of the current vertex.

        :rtype: OCC.wrapper.TopAbs.TopAbs_Orientation

        """
        return _HLRBRep.HLRBRep_EdgeBuilder_Orientation(self, *args)


    def Destroy(self, *args):
        """Destroy(HLRBRep_EdgeBuilder self)"""
        return _HLRBRep.HLRBRep_EdgeBuilder_Destroy(self, *args)

    __swig_destroy__ = _HLRBRep.delete_HLRBRep_EdgeBuilder
HLRBRep_EdgeBuilder_swigregister = _HLRBRep.HLRBRep_EdgeBuilder_swigregister
HLRBRep_EdgeBuilder_swigregister(HLRBRep_EdgeBuilder)

class HLRBRep_TheLocateExtPCOfTheProjPCurOfCInter(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(HLRBRep_TheLocateExtPCOfTheProjPCurOfCInter self) -> HLRBRep_TheLocateExtPCOfTheProjPCurOfCInter
        __init__(HLRBRep_TheLocateExtPCOfTheProjPCurOfCInter self, gp_Pnt2d P, Standard_Address const & C, Standard_Real const U0, Standard_Real const TolU) -> HLRBRep_TheLocateExtPCOfTheProjPCurOfCInter
        __init__(HLRBRep_TheLocateExtPCOfTheProjPCurOfCInter self, gp_Pnt2d P, Standard_Address const & C, Standard_Real const U0, Standard_Real const Umin, Standard_Real const Usup, Standard_Real const TolU) -> HLRBRep_TheLocateExtPCOfTheProjPCurOfCInter

        Calculates the distance with a close point.
        The close point is defined by the parameter value
        U0.
        The function F(u)=distance(P,C(u)) has an extremum
        when g(u)=dF/du=0. The algorithm searchs a zero
        near the close point.
        Zeros are searched between Umin et Usup.
        TolU is used to decide to stop the iterations.
        At the nth iteration, the criteria is:
        abs(Un - Un-1) < TolU.

        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type C: OCC.wrapper.Standard.Standard_Address
        :type U0: float
        :type Umin: float
        :type Usup: float
        :type TolU: float

        """
        this = _HLRBRep.new_HLRBRep_TheLocateExtPCOfTheProjPCurOfCInter(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Initialize(self, *args):
        """
        Initialize(HLRBRep_TheLocateExtPCOfTheProjPCurOfCInter self, Standard_Address const & C, Standard_Real const Umin, Standard_Real const Usup, Standard_Real const TolU)

        sets the fields of the algorithm.

        :type C: OCC.wrapper.Standard.Standard_Address
        :type Umin: float
        :type Usup: float
        :type TolU: float

        """
        return _HLRBRep.HLRBRep_TheLocateExtPCOfTheProjPCurOfCInter_Initialize(self, *args)


    def Perform(self, *args):
        """
        Perform(HLRBRep_TheLocateExtPCOfTheProjPCurOfCInter self, gp_Pnt2d P, Standard_Real const U0)

        the algorithm is done with the point P.
        An exception is raised if the fields have not
        been initialized.

        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type U0: float

        """
        return _HLRBRep.HLRBRep_TheLocateExtPCOfTheProjPCurOfCInter_Perform(self, *args)


    def IsDone(self, *args):
        """
        IsDone(HLRBRep_TheLocateExtPCOfTheProjPCurOfCInter self) -> Standard_Boolean

        Returns True if the distance is found.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _HLRBRep.HLRBRep_TheLocateExtPCOfTheProjPCurOfCInter_IsDone(self, *args)


    def SquareDistance(self, *args):
        """
        SquareDistance(HLRBRep_TheLocateExtPCOfTheProjPCurOfCInter self) -> Standard_Real

        Returns the value of the extremum square distance.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _HLRBRep.HLRBRep_TheLocateExtPCOfTheProjPCurOfCInter_SquareDistance(self, *args)


    def IsMin(self, *args):
        """
        IsMin(HLRBRep_TheLocateExtPCOfTheProjPCurOfCInter self) -> Standard_Boolean

        Returns True if the extremum distance is a minimum.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _HLRBRep.HLRBRep_TheLocateExtPCOfTheProjPCurOfCInter_IsMin(self, *args)


    def Point(self, *args):
        """
        Returns the point of the extremum distance.

        :rtype: OCC.wrapper.Extrema.Extrema_POnCurv2d

        """
        res = _HLRBRep.HLRBRep_TheLocateExtPCOfTheProjPCurOfCInter_Point(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _HLRBRep.delete_HLRBRep_TheLocateExtPCOfTheProjPCurOfCInter
HLRBRep_TheLocateExtPCOfTheProjPCurOfCInter_swigregister = _HLRBRep.HLRBRep_TheLocateExtPCOfTheProjPCurOfCInter_swigregister
HLRBRep_TheLocateExtPCOfTheProjPCurOfCInter_swigregister(HLRBRep_TheLocateExtPCOfTheProjPCurOfCInter)

class HLRBRep_ThePolyhedronToolOfInterCSurf(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Bounding(*args):
        """
        Bounding(HLRBRep_ThePolyhedronOfInterCSurf thePolyh) -> Bnd_Box

        Give the bounding box of the PolyhedronTool.

        :type thePolyh: OCC.wrapper.HLRBRep.HLRBRep_ThePolyhedronOfInterCSurf
        :rtype: OCC.wrapper.Bnd.Bnd_Box

        """
        return _HLRBRep.HLRBRep_ThePolyhedronToolOfInterCSurf_Bounding(*args)

    Bounding = staticmethod(Bounding)

    def ComponentsBounding(*args):
        """
        ComponentsBounding(HLRBRep_ThePolyhedronOfInterCSurf thePolyh) -> Handle_Bnd_HArray1OfBox

        Give the array of boxes. The box <n> corresponding
        to the triangle <n>.

        :type thePolyh: OCC.wrapper.HLRBRep.HLRBRep_ThePolyhedronOfInterCSurf
        :rtype: OCC.wrapper.Bnd.Handle_Bnd_HArray1OfBox

        """
        return _HLRBRep.HLRBRep_ThePolyhedronToolOfInterCSurf_ComponentsBounding(*args)

    ComponentsBounding = staticmethod(ComponentsBounding)

    def DeflectionOverEstimation(*args):
        """
        DeflectionOverEstimation(HLRBRep_ThePolyhedronOfInterCSurf thePolyh) -> Standard_Real

        Give the tolerance of the polygon.

        :type thePolyh: OCC.wrapper.HLRBRep.HLRBRep_ThePolyhedronOfInterCSurf
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _HLRBRep.HLRBRep_ThePolyhedronToolOfInterCSurf_DeflectionOverEstimation(*args)

    DeflectionOverEstimation = staticmethod(DeflectionOverEstimation)

    def NbTriangles(*args):
        """
        NbTriangles(HLRBRep_ThePolyhedronOfInterCSurf thePolyh) -> Standard_Integer

        Give the number of triangles in this polyedral surface.

        :type thePolyh: OCC.wrapper.HLRBRep.HLRBRep_ThePolyhedronOfInterCSurf
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _HLRBRep.HLRBRep_ThePolyhedronToolOfInterCSurf_NbTriangles(*args)

    NbTriangles = staticmethod(NbTriangles)

    def Triangle(*args):
        """
        Triangle(HLRBRep_ThePolyhedronOfInterCSurf thePolyh, Standard_Integer const Index)

        Give the indices  of  the 3 points of  the triangle of
        address Index in the PolyhedronTool.

        :type thePolyh: OCC.wrapper.HLRBRep.HLRBRep_ThePolyhedronOfInterCSurf
        :type Index: int
        :type P1: int
        :type P2: int
        :type P3: int

        """
        return _HLRBRep.HLRBRep_ThePolyhedronToolOfInterCSurf_Triangle(*args)

    Triangle = staticmethod(Triangle)

    def Point(*args):
        """
        Point(HLRBRep_ThePolyhedronOfInterCSurf thePolyh, Standard_Integer const Index) -> gp_Pnt

        Give the point of index i in the polyedral surface.

        :type thePolyh: OCC.wrapper.HLRBRep.HLRBRep_ThePolyhedronOfInterCSurf
        :type Index: int
        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _HLRBRep.HLRBRep_ThePolyhedronToolOfInterCSurf_Point(*args)

    Point = staticmethod(Point)

    def TriConnex(*args):
        """
        TriConnex(HLRBRep_ThePolyhedronOfInterCSurf thePolyh, Standard_Integer const Triang, Standard_Integer const Pivot, Standard_Integer const Pedge) -> Standard_Integer

        Give the  addresse Tricon of   the triangle connexe to
        the triangle of address Triang by the edge Pivot Pedge
        and the third point of this  connexe triangle. When we
        are on  a free edge TriCon==0  but the function return
        the value of  the triangle in the  other side of Pivot
        on the free edge.  Used to turn around a vertex.

        :type thePolyh: OCC.wrapper.HLRBRep.HLRBRep_ThePolyhedronOfInterCSurf
        :type Triang: int
        :type Pivot: int
        :type Pedge: int
        :type TriCon: int
        :type OtherP: int
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _HLRBRep.HLRBRep_ThePolyhedronToolOfInterCSurf_TriConnex(*args)

    TriConnex = staticmethod(TriConnex)

    def IsOnBound(*args):
        """
        IsOnBound(HLRBRep_ThePolyhedronOfInterCSurf thePolyh, Standard_Integer const Index1, Standard_Integer const Index2) -> Standard_Boolean

        This method returns true if the edge based on points with
        indices Index1 and Index2 represents a boundary edge. It is
        necessary to take into account the boundary deflection for
        this edge.

        :type thePolyh: OCC.wrapper.HLRBRep.HLRBRep_ThePolyhedronOfInterCSurf
        :type Index1: int
        :type Index2: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _HLRBRep.HLRBRep_ThePolyhedronToolOfInterCSurf_IsOnBound(*args)

    IsOnBound = staticmethod(IsOnBound)

    def GetBorderDeflection(*args):
        """
        GetBorderDeflection(HLRBRep_ThePolyhedronOfInterCSurf thePolyh) -> Standard_Real

        This method returns a border deflection of the polyhedron.

        :type thePolyh: OCC.wrapper.HLRBRep.HLRBRep_ThePolyhedronOfInterCSurf
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _HLRBRep.HLRBRep_ThePolyhedronToolOfInterCSurf_GetBorderDeflection(*args)

    GetBorderDeflection = staticmethod(GetBorderDeflection)

    def Dump(*args):
        """
        Dump(HLRBRep_ThePolyhedronOfInterCSurf thePolyh)

        :type thePolyh: OCC.wrapper.HLRBRep.HLRBRep_ThePolyhedronOfInterCSurf

        """
        return _HLRBRep.HLRBRep_ThePolyhedronToolOfInterCSurf_Dump(*args)

    Dump = staticmethod(Dump)

    def __init__(self):
        this = _HLRBRep.new_HLRBRep_ThePolyhedronToolOfInterCSurf()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _HLRBRep.delete_HLRBRep_ThePolyhedronToolOfInterCSurf
HLRBRep_ThePolyhedronToolOfInterCSurf_swigregister = _HLRBRep.HLRBRep_ThePolyhedronToolOfInterCSurf_swigregister
HLRBRep_ThePolyhedronToolOfInterCSurf_swigregister(HLRBRep_ThePolyhedronToolOfInterCSurf)

def HLRBRep_ThePolyhedronToolOfInterCSurf_Bounding(*args):
    """
    HLRBRep_ThePolyhedronToolOfInterCSurf_Bounding(HLRBRep_ThePolyhedronOfInterCSurf thePolyh) -> Bnd_Box

    Give the bounding box of the PolyhedronTool.

    :type thePolyh: OCC.wrapper.HLRBRep.HLRBRep_ThePolyhedronOfInterCSurf
    :rtype: OCC.wrapper.Bnd.Bnd_Box

    """
    return _HLRBRep.HLRBRep_ThePolyhedronToolOfInterCSurf_Bounding(*args)

def HLRBRep_ThePolyhedronToolOfInterCSurf_ComponentsBounding(*args):
    """
    HLRBRep_ThePolyhedronToolOfInterCSurf_ComponentsBounding(HLRBRep_ThePolyhedronOfInterCSurf thePolyh) -> Handle_Bnd_HArray1OfBox

    Give the array of boxes. The box <n> corresponding
    to the triangle <n>.

    :type thePolyh: OCC.wrapper.HLRBRep.HLRBRep_ThePolyhedronOfInterCSurf
    :rtype: OCC.wrapper.Bnd.Handle_Bnd_HArray1OfBox

    """
    return _HLRBRep.HLRBRep_ThePolyhedronToolOfInterCSurf_ComponentsBounding(*args)

def HLRBRep_ThePolyhedronToolOfInterCSurf_DeflectionOverEstimation(*args):
    """
    HLRBRep_ThePolyhedronToolOfInterCSurf_DeflectionOverEstimation(HLRBRep_ThePolyhedronOfInterCSurf thePolyh) -> Standard_Real

    Give the tolerance of the polygon.

    :type thePolyh: OCC.wrapper.HLRBRep.HLRBRep_ThePolyhedronOfInterCSurf
    :rtype: OCC.wrapper.Standard.Standard_Real

    """
    return _HLRBRep.HLRBRep_ThePolyhedronToolOfInterCSurf_DeflectionOverEstimation(*args)

def HLRBRep_ThePolyhedronToolOfInterCSurf_NbTriangles(*args):
    """
    HLRBRep_ThePolyhedronToolOfInterCSurf_NbTriangles(HLRBRep_ThePolyhedronOfInterCSurf thePolyh) -> Standard_Integer

    Give the number of triangles in this polyedral surface.

    :type thePolyh: OCC.wrapper.HLRBRep.HLRBRep_ThePolyhedronOfInterCSurf
    :rtype: OCC.wrapper.Standard.Standard_Integer

    """
    return _HLRBRep.HLRBRep_ThePolyhedronToolOfInterCSurf_NbTriangles(*args)

def HLRBRep_ThePolyhedronToolOfInterCSurf_Triangle(*args):
    """
    HLRBRep_ThePolyhedronToolOfInterCSurf_Triangle(HLRBRep_ThePolyhedronOfInterCSurf thePolyh, Standard_Integer const Index)

    Give the indices  of  the 3 points of  the triangle of
    address Index in the PolyhedronTool.

    :type thePolyh: OCC.wrapper.HLRBRep.HLRBRep_ThePolyhedronOfInterCSurf
    :type Index: int
    :type P1: int
    :type P2: int
    :type P3: int

    """
    return _HLRBRep.HLRBRep_ThePolyhedronToolOfInterCSurf_Triangle(*args)

def HLRBRep_ThePolyhedronToolOfInterCSurf_Point(*args):
    """
    HLRBRep_ThePolyhedronToolOfInterCSurf_Point(HLRBRep_ThePolyhedronOfInterCSurf thePolyh, Standard_Integer const Index) -> gp_Pnt

    Give the point of index i in the polyedral surface.

    :type thePolyh: OCC.wrapper.HLRBRep.HLRBRep_ThePolyhedronOfInterCSurf
    :type Index: int
    :rtype: OCC.wrapper.gp.gp_Pnt

    """
    return _HLRBRep.HLRBRep_ThePolyhedronToolOfInterCSurf_Point(*args)

def HLRBRep_ThePolyhedronToolOfInterCSurf_TriConnex(*args):
    """
    HLRBRep_ThePolyhedronToolOfInterCSurf_TriConnex(HLRBRep_ThePolyhedronOfInterCSurf thePolyh, Standard_Integer const Triang, Standard_Integer const Pivot, Standard_Integer const Pedge) -> Standard_Integer

    Give the  addresse Tricon of   the triangle connexe to
    the triangle of address Triang by the edge Pivot Pedge
    and the third point of this  connexe triangle. When we
    are on  a free edge TriCon==0  but the function return
    the value of  the triangle in the  other side of Pivot
    on the free edge.  Used to turn around a vertex.

    :type thePolyh: OCC.wrapper.HLRBRep.HLRBRep_ThePolyhedronOfInterCSurf
    :type Triang: int
    :type Pivot: int
    :type Pedge: int
    :type TriCon: int
    :type OtherP: int
    :rtype: OCC.wrapper.Standard.Standard_Integer

    """
    return _HLRBRep.HLRBRep_ThePolyhedronToolOfInterCSurf_TriConnex(*args)

def HLRBRep_ThePolyhedronToolOfInterCSurf_IsOnBound(*args):
    """
    HLRBRep_ThePolyhedronToolOfInterCSurf_IsOnBound(HLRBRep_ThePolyhedronOfInterCSurf thePolyh, Standard_Integer const Index1, Standard_Integer const Index2) -> Standard_Boolean

    This method returns true if the edge based on points with
    indices Index1 and Index2 represents a boundary edge. It is
    necessary to take into account the boundary deflection for
    this edge.

    :type thePolyh: OCC.wrapper.HLRBRep.HLRBRep_ThePolyhedronOfInterCSurf
    :type Index1: int
    :type Index2: int
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _HLRBRep.HLRBRep_ThePolyhedronToolOfInterCSurf_IsOnBound(*args)

def HLRBRep_ThePolyhedronToolOfInterCSurf_GetBorderDeflection(*args):
    """
    HLRBRep_ThePolyhedronToolOfInterCSurf_GetBorderDeflection(HLRBRep_ThePolyhedronOfInterCSurf thePolyh) -> Standard_Real

    This method returns a border deflection of the polyhedron.

    :type thePolyh: OCC.wrapper.HLRBRep.HLRBRep_ThePolyhedronOfInterCSurf
    :rtype: OCC.wrapper.Standard.Standard_Real

    """
    return _HLRBRep.HLRBRep_ThePolyhedronToolOfInterCSurf_GetBorderDeflection(*args)

def HLRBRep_ThePolyhedronToolOfInterCSurf_Dump(*args):
    """
    HLRBRep_ThePolyhedronToolOfInterCSurf_Dump(HLRBRep_ThePolyhedronOfInterCSurf thePolyh)

    :type thePolyh: OCC.wrapper.HLRBRep.HLRBRep_ThePolyhedronOfInterCSurf

    """
    return _HLRBRep.HLRBRep_ThePolyhedronToolOfInterCSurf_Dump(*args)

class HLRBRep_TheQuadCurvExactInterCSurf(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(HLRBRep_TheQuadCurvExactInterCSurf self, Standard_Address const & S, gp_Lin C) -> HLRBRep_TheQuadCurvExactInterCSurf

        Provides the signed distance function : Q(w)
        and its first derivative dQ(w)/dw

        :type S: OCC.wrapper.Standard.Standard_Address
        :type C: OCC.wrapper.gp.gp_Lin

        """
        this = _HLRBRep.new_HLRBRep_TheQuadCurvExactInterCSurf(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def IsDone(self, *args):
        """
        IsDone(HLRBRep_TheQuadCurvExactInterCSurf self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _HLRBRep.HLRBRep_TheQuadCurvExactInterCSurf_IsDone(self, *args)


    def NbRoots(self, *args):
        """
        NbRoots(HLRBRep_TheQuadCurvExactInterCSurf self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _HLRBRep.HLRBRep_TheQuadCurvExactInterCSurf_NbRoots(self, *args)


    def Root(self, *args):
        """
        Root(HLRBRep_TheQuadCurvExactInterCSurf self, Standard_Integer const Index) -> Standard_Real

        :type Index: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _HLRBRep.HLRBRep_TheQuadCurvExactInterCSurf_Root(self, *args)


    def NbIntervals(self, *args):
        """
        NbIntervals(HLRBRep_TheQuadCurvExactInterCSurf self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _HLRBRep.HLRBRep_TheQuadCurvExactInterCSurf_NbIntervals(self, *args)


    def Intervals(self, *args):
        """
        Intervals(HLRBRep_TheQuadCurvExactInterCSurf self, Standard_Integer const Index)

        U1 and U2 are the parameters of
        a segment on the curve.

        :type Index: int
        :type U1: float
        :type U2: float

        """
        return _HLRBRep.HLRBRep_TheQuadCurvExactInterCSurf_Intervals(self, *args)

    __swig_destroy__ = _HLRBRep.delete_HLRBRep_TheQuadCurvExactInterCSurf
HLRBRep_TheQuadCurvExactInterCSurf_swigregister = _HLRBRep.HLRBRep_TheQuadCurvExactInterCSurf_swigregister
HLRBRep_TheQuadCurvExactInterCSurf_swigregister(HLRBRep_TheQuadCurvExactInterCSurf)

class HLRBRep_TheDistBetweenPCurvesOfTheIntPCurvePCurveOfCInter(math.math_FunctionSetWithDerivatives):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(HLRBRep_TheDistBetweenPCurvesOfTheIntPCurvePCurveOfCInter self, Standard_Address const & curve1, Standard_Address const & curve2) -> HLRBRep_TheDistBetweenPCurvesOfTheIntPCurvePCurveOfCInter

        :type curve1: OCC.wrapper.Standard.Standard_Address
        :type curve2: OCC.wrapper.Standard.Standard_Address

        """
        this = _HLRBRep.new_HLRBRep_TheDistBetweenPCurvesOfTheIntPCurvePCurveOfCInter(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def NbVariables(self, *args):
        """
        NbVariables(HLRBRep_TheDistBetweenPCurvesOfTheIntPCurvePCurveOfCInter self) -> Standard_Integer

        returns 2.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _HLRBRep.HLRBRep_TheDistBetweenPCurvesOfTheIntPCurvePCurveOfCInter_NbVariables(self, *args)


    def NbEquations(self, *args):
        """
        NbEquations(HLRBRep_TheDistBetweenPCurvesOfTheIntPCurvePCurveOfCInter self) -> Standard_Integer

        returns 2.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _HLRBRep.HLRBRep_TheDistBetweenPCurvesOfTheIntPCurvePCurveOfCInter_NbEquations(self, *args)


    def Value(self, *args):
        """
        Value(HLRBRep_TheDistBetweenPCurvesOfTheIntPCurvePCurveOfCInter self, math_Vector X, math_Vector F) -> Standard_Boolean

        computes the values <F> of the Functions for the
        variable <X>.
        returns True if the computation was done successfully,
        False otherwise.

        :type X: OCC.wrapper.math.math_Vector
        :type F: OCC.wrapper.math.math_Vector
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _HLRBRep.HLRBRep_TheDistBetweenPCurvesOfTheIntPCurvePCurveOfCInter_Value(self, *args)


    def Derivatives(self, *args):
        """
        Derivatives(HLRBRep_TheDistBetweenPCurvesOfTheIntPCurvePCurveOfCInter self, math_Vector X, math_Matrix D) -> Standard_Boolean

        returns the values <D> of the derivatives for the
        variable <X>.
        returns True if the computation was done successfully,
        False otherwise.

        :type X: OCC.wrapper.math.math_Vector
        :type D: OCC.wrapper.math.math_Matrix
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _HLRBRep.HLRBRep_TheDistBetweenPCurvesOfTheIntPCurvePCurveOfCInter_Derivatives(self, *args)


    def Values(self, *args):
        """
        Values(HLRBRep_TheDistBetweenPCurvesOfTheIntPCurvePCurveOfCInter self, math_Vector X, math_Vector F, math_Matrix D) -> Standard_Boolean

        returns the values <F> of the functions and the derivatives
        <D> for the variable <X>.
        returns True if the computation was done successfully,
        False otherwise.

        :type X: OCC.wrapper.math.math_Vector
        :type F: OCC.wrapper.math.math_Vector
        :type D: OCC.wrapper.math.math_Matrix
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _HLRBRep.HLRBRep_TheDistBetweenPCurvesOfTheIntPCurvePCurveOfCInter_Values(self, *args)

    __swig_destroy__ = _HLRBRep.delete_HLRBRep_TheDistBetweenPCurvesOfTheIntPCurvePCurveOfCInter
HLRBRep_TheDistBetweenPCurvesOfTheIntPCurvePCurveOfCInter_swigregister = _HLRBRep.HLRBRep_TheDistBetweenPCurvesOfTheIntPCurvePCurveOfCInter_swigregister
HLRBRep_TheDistBetweenPCurvesOfTheIntPCurvePCurveOfCInter_swigregister(HLRBRep_TheDistBetweenPCurvesOfTheIntPCurvePCurveOfCInter)

class HLRBRep_CurveTool(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def FirstParameter(*args):
        """
        FirstParameter(Standard_Address const C) -> Standard_Real

        :type C: OCC.wrapper.Standard.Standard_Address
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _HLRBRep.HLRBRep_CurveTool_FirstParameter(*args)

    FirstParameter = staticmethod(FirstParameter)

    def LastParameter(*args):
        """
        LastParameter(Standard_Address const C) -> Standard_Real

        :type C: OCC.wrapper.Standard.Standard_Address
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _HLRBRep.HLRBRep_CurveTool_LastParameter(*args)

    LastParameter = staticmethod(LastParameter)

    def Continuity(*args):
        """
        Continuity(Standard_Address const C) -> GeomAbs_Shape

        :type C: OCC.wrapper.Standard.Standard_Address
        :rtype: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _HLRBRep.HLRBRep_CurveTool_Continuity(*args)

    Continuity = staticmethod(Continuity)

    def NbIntervals(*args):
        """
        NbIntervals(Standard_Address const C) -> Standard_Integer

        Returns  the number  of  intervals for  continuity
        <S>. May be one if Continuity(myclass) >= <S>

        :type C: OCC.wrapper.Standard.Standard_Address
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _HLRBRep.HLRBRep_CurveTool_NbIntervals(*args)

    NbIntervals = staticmethod(NbIntervals)

    def Intervals(*args):
        """
        Intervals(Standard_Address const C, NCollection_Array1_Standard_Real T)

        Stores in <T> the  parameters bounding the intervals
        of continuity <S>.

        The array must provide  enough room to  accomodate
        for the parameters. i.e. T.Length() > NbIntervals()

        :type C: OCC.wrapper.Standard.Standard_Address
        :type T: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        return _HLRBRep.HLRBRep_CurveTool_Intervals(*args)

    Intervals = staticmethod(Intervals)

    def GetInterval(*args):
        """
        GetInterval(Standard_Address const C, Standard_Integer const Index, NCollection_Array1_Standard_Real Tab)

        output the bounds of interval of index <Index>
        used if Type == Composite.

        :type C: OCC.wrapper.Standard.Standard_Address
        :type Index: int
        :type Tab: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type U1: float
        :type U2: float

        """
        return _HLRBRep.HLRBRep_CurveTool_GetInterval(*args)

    GetInterval = staticmethod(GetInterval)

    def IsClosed(*args):
        """
        IsClosed(Standard_Address const C) -> Standard_Boolean

        :type C: OCC.wrapper.Standard.Standard_Address
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _HLRBRep.HLRBRep_CurveTool_IsClosed(*args)

    IsClosed = staticmethod(IsClosed)

    def IsPeriodic(*args):
        """
        IsPeriodic(Standard_Address const C) -> Standard_Boolean

        :type C: OCC.wrapper.Standard.Standard_Address
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _HLRBRep.HLRBRep_CurveTool_IsPeriodic(*args)

    IsPeriodic = staticmethod(IsPeriodic)

    def Period(*args):
        """
        Period(Standard_Address const C) -> Standard_Real

        :type C: OCC.wrapper.Standard.Standard_Address
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _HLRBRep.HLRBRep_CurveTool_Period(*args)

    Period = staticmethod(Period)

    def Value(*args):
        """
        Value(Standard_Address const C, Standard_Real const U) -> gp_Pnt2d

        Computes the point of parameter U on the curve.

        :type C: OCC.wrapper.Standard.Standard_Address
        :type U: float
        :rtype: OCC.wrapper.gp.gp_Pnt2d

        """
        return _HLRBRep.HLRBRep_CurveTool_Value(*args)

    Value = staticmethod(Value)

    def D0(*args):
        """
        D0(Standard_Address const C, Standard_Real const U, gp_Pnt2d P)

        Computes the point of parameter U on the curve.

        :type C: OCC.wrapper.Standard.Standard_Address
        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt2d

        """
        return _HLRBRep.HLRBRep_CurveTool_D0(*args)

    D0 = staticmethod(D0)

    def D1(*args):
        """
        D1(Standard_Address const C, Standard_Real const U, gp_Pnt2d P, gp_Vec2d V)

        Computes the point  of parameter U on the curve
        with its first derivative.
        Raised if the continuity of the current interval
        is not C1.

        :type C: OCC.wrapper.Standard.Standard_Address
        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type V: OCC.wrapper.gp.gp_Vec2d

        """
        return _HLRBRep.HLRBRep_CurveTool_D1(*args)

    D1 = staticmethod(D1)

    def D2(*args):
        """
        D2(Standard_Address const C, Standard_Real const U, gp_Pnt2d P, gp_Vec2d V1, gp_Vec2d V2)

        Returns the point P of parameter U, the first and second
        derivatives V1 and V2.
        Raised if the continuity of the current interval
        is not C2.

        :type C: OCC.wrapper.Standard.Standard_Address
        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type V1: OCC.wrapper.gp.gp_Vec2d
        :type V2: OCC.wrapper.gp.gp_Vec2d

        """
        return _HLRBRep.HLRBRep_CurveTool_D2(*args)

    D2 = staticmethod(D2)

    def D3(*args):
        """
        D3(Standard_Address const C, Standard_Real const U, gp_Pnt2d P, gp_Vec2d V1, gp_Vec2d V2, gp_Vec2d V3)

        Returns the point P of parameter U, the first, the second
        and the third derivative.
        Raised if the continuity of the current interval
        is not C3.

        :type C: OCC.wrapper.Standard.Standard_Address
        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type V1: OCC.wrapper.gp.gp_Vec2d
        :type V2: OCC.wrapper.gp.gp_Vec2d
        :type V3: OCC.wrapper.gp.gp_Vec2d

        """
        return _HLRBRep.HLRBRep_CurveTool_D3(*args)

    D3 = staticmethod(D3)

    def DN(*args):
        """
        DN(Standard_Address const C, Standard_Real const U, Standard_Integer const N) -> gp_Vec2d

        The returned vector gives the value of the derivative for the
        order of derivation N.
        Raised if the continuity of the current interval
        is not CN.
        Raised if N < 1.

        :type C: OCC.wrapper.Standard.Standard_Address
        :type U: float
        :type N: int
        :rtype: OCC.wrapper.gp.gp_Vec2d

        """
        return _HLRBRep.HLRBRep_CurveTool_DN(*args)

    DN = staticmethod(DN)

    def Resolution(*args):
        """
        Resolution(Standard_Address const C, Standard_Real const R3d) -> Standard_Real

        Returns the parametric  resolution corresponding
        to the real space resolution <R3d>.

        :type C: OCC.wrapper.Standard.Standard_Address
        :type R3d: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _HLRBRep.HLRBRep_CurveTool_Resolution(*args)

    Resolution = staticmethod(Resolution)

    def GetType(*args):
        """
        GetType(Standard_Address const C) -> GeomAbs_CurveType

        Returns  the  type of the   curve  in the  current
        interval :   Line,   Circle,   Ellipse, Hyperbola,
        Parabola, BezierCurve, BSplineCurve, OtherCurve.

        :type C: OCC.wrapper.Standard.Standard_Address
        :rtype: OCC.wrapper.GeomAbs.GeomAbs_CurveType

        """
        return _HLRBRep.HLRBRep_CurveTool_GetType(*args)

    GetType = staticmethod(GetType)

    def TheType(*args):
        """
        TheType(Standard_Address const C) -> GeomAbs_CurveType

        Returns  the  type of the   curve  in the  current
        interval :   Line,   Circle,   Ellipse, Hyperbola,
        Parabola, BezierCurve, BSplineCurve, OtherCurve.

        :type C: OCC.wrapper.Standard.Standard_Address
        :rtype: OCC.wrapper.GeomAbs.GeomAbs_CurveType

        """
        return _HLRBRep.HLRBRep_CurveTool_TheType(*args)

    TheType = staticmethod(TheType)

    def Line(*args):
        """
        Line(Standard_Address const C) -> gp_Lin2d

        :type C: OCC.wrapper.Standard.Standard_Address
        :rtype: OCC.wrapper.gp.gp_Lin2d

        """
        return _HLRBRep.HLRBRep_CurveTool_Line(*args)

    Line = staticmethod(Line)

    def Circle(*args):
        """
        Circle(Standard_Address const C) -> gp_Circ2d

        :type C: OCC.wrapper.Standard.Standard_Address
        :rtype: OCC.wrapper.gp.gp_Circ2d

        """
        return _HLRBRep.HLRBRep_CurveTool_Circle(*args)

    Circle = staticmethod(Circle)

    def Ellipse(*args):
        """
        Ellipse(Standard_Address const C) -> gp_Elips2d

        :type C: OCC.wrapper.Standard.Standard_Address
        :rtype: OCC.wrapper.gp.gp_Elips2d

        """
        return _HLRBRep.HLRBRep_CurveTool_Ellipse(*args)

    Ellipse = staticmethod(Ellipse)

    def Hyperbola(*args):
        """
        Hyperbola(Standard_Address const C) -> gp_Hypr2d

        :type C: OCC.wrapper.Standard.Standard_Address
        :rtype: OCC.wrapper.gp.gp_Hypr2d

        """
        return _HLRBRep.HLRBRep_CurveTool_Hyperbola(*args)

    Hyperbola = staticmethod(Hyperbola)

    def Parabola(*args):
        """
        Parabola(Standard_Address const C) -> gp_Parab2d

        :type C: OCC.wrapper.Standard.Standard_Address
        :rtype: OCC.wrapper.gp.gp_Parab2d

        """
        return _HLRBRep.HLRBRep_CurveTool_Parabola(*args)

    Parabola = staticmethod(Parabola)

    def Bezier(*args):
        """
        Bezier(Standard_Address const C) -> Handle_Geom2d_BezierCurve

        :type C: OCC.wrapper.Standard.Standard_Address
        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_BezierCurve

        """
        return _HLRBRep.HLRBRep_CurveTool_Bezier(*args)

    Bezier = staticmethod(Bezier)

    def BSpline(*args):
        """
        BSpline(Standard_Address const C) -> Handle_Geom2d_BSplineCurve

        :type C: OCC.wrapper.Standard.Standard_Address
        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_BSplineCurve

        """
        return _HLRBRep.HLRBRep_CurveTool_BSpline(*args)

    BSpline = staticmethod(BSpline)

    def EpsX(*args):
        """
        EpsX(Standard_Address const C) -> Standard_Real

        :type C: OCC.wrapper.Standard.Standard_Address
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _HLRBRep.HLRBRep_CurveTool_EpsX(*args)

    EpsX = staticmethod(EpsX)

    def NbSamples(*args):
        """
        NbSamples(Standard_Address const C, Standard_Real const U0, Standard_Real const U1) -> Standard_Integer
        NbSamples(Standard_Address const C) -> Standard_Integer

        :type C: OCC.wrapper.Standard.Standard_Address
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _HLRBRep.HLRBRep_CurveTool_NbSamples(*args)

    NbSamples = staticmethod(NbSamples)

    def Degree(*args):
        """
        Degree(Standard_Address const C) -> Standard_Integer

        :type C: OCC.wrapper.Standard.Standard_Address
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _HLRBRep.HLRBRep_CurveTool_Degree(*args)

    Degree = staticmethod(Degree)

    def __init__(self):
        this = _HLRBRep.new_HLRBRep_CurveTool()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _HLRBRep.delete_HLRBRep_CurveTool
HLRBRep_CurveTool_swigregister = _HLRBRep.HLRBRep_CurveTool_swigregister
HLRBRep_CurveTool_swigregister(HLRBRep_CurveTool)

def HLRBRep_CurveTool_FirstParameter(*args):
    """
    HLRBRep_CurveTool_FirstParameter(Standard_Address const C) -> Standard_Real

    :type C: OCC.wrapper.Standard.Standard_Address
    :rtype: OCC.wrapper.Standard.Standard_Real

    """
    return _HLRBRep.HLRBRep_CurveTool_FirstParameter(*args)

def HLRBRep_CurveTool_LastParameter(*args):
    """
    HLRBRep_CurveTool_LastParameter(Standard_Address const C) -> Standard_Real

    :type C: OCC.wrapper.Standard.Standard_Address
    :rtype: OCC.wrapper.Standard.Standard_Real

    """
    return _HLRBRep.HLRBRep_CurveTool_LastParameter(*args)

def HLRBRep_CurveTool_Continuity(*args):
    """
    HLRBRep_CurveTool_Continuity(Standard_Address const C) -> GeomAbs_Shape

    :type C: OCC.wrapper.Standard.Standard_Address
    :rtype: OCC.wrapper.GeomAbs.GeomAbs_Shape

    """
    return _HLRBRep.HLRBRep_CurveTool_Continuity(*args)

def HLRBRep_CurveTool_NbIntervals(*args):
    """
    HLRBRep_CurveTool_NbIntervals(Standard_Address const C) -> Standard_Integer

    Returns  the number  of  intervals for  continuity
    <S>. May be one if Continuity(myclass) >= <S>

    :type C: OCC.wrapper.Standard.Standard_Address
    :rtype: OCC.wrapper.Standard.Standard_Integer

    """
    return _HLRBRep.HLRBRep_CurveTool_NbIntervals(*args)

def HLRBRep_CurveTool_Intervals(*args):
    """
    HLRBRep_CurveTool_Intervals(Standard_Address const C, NCollection_Array1_Standard_Real T)

    Stores in <T> the  parameters bounding the intervals
    of continuity <S>.

    The array must provide  enough room to  accomodate
    for the parameters. i.e. T.Length() > NbIntervals()

    :type C: OCC.wrapper.Standard.Standard_Address
    :type T: OCC.wrapper.TColStd.TColStd_Array1OfReal

    """
    return _HLRBRep.HLRBRep_CurveTool_Intervals(*args)

def HLRBRep_CurveTool_GetInterval(*args):
    """
    HLRBRep_CurveTool_GetInterval(Standard_Address const C, Standard_Integer const Index, NCollection_Array1_Standard_Real Tab)

    output the bounds of interval of index <Index>
    used if Type == Composite.

    :type C: OCC.wrapper.Standard.Standard_Address
    :type Index: int
    :type Tab: OCC.wrapper.TColStd.TColStd_Array1OfReal
    :type U1: float
    :type U2: float

    """
    return _HLRBRep.HLRBRep_CurveTool_GetInterval(*args)

def HLRBRep_CurveTool_IsClosed(*args):
    """
    HLRBRep_CurveTool_IsClosed(Standard_Address const C) -> Standard_Boolean

    :type C: OCC.wrapper.Standard.Standard_Address
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _HLRBRep.HLRBRep_CurveTool_IsClosed(*args)

def HLRBRep_CurveTool_IsPeriodic(*args):
    """
    HLRBRep_CurveTool_IsPeriodic(Standard_Address const C) -> Standard_Boolean

    :type C: OCC.wrapper.Standard.Standard_Address
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _HLRBRep.HLRBRep_CurveTool_IsPeriodic(*args)

def HLRBRep_CurveTool_Period(*args):
    """
    HLRBRep_CurveTool_Period(Standard_Address const C) -> Standard_Real

    :type C: OCC.wrapper.Standard.Standard_Address
    :rtype: OCC.wrapper.Standard.Standard_Real

    """
    return _HLRBRep.HLRBRep_CurveTool_Period(*args)

def HLRBRep_CurveTool_Value(*args):
    """
    HLRBRep_CurveTool_Value(Standard_Address const C, Standard_Real const U) -> gp_Pnt2d

    Computes the point of parameter U on the curve.

    :type C: OCC.wrapper.Standard.Standard_Address
    :type U: float
    :rtype: OCC.wrapper.gp.gp_Pnt2d

    """
    return _HLRBRep.HLRBRep_CurveTool_Value(*args)

def HLRBRep_CurveTool_D0(*args):
    """
    HLRBRep_CurveTool_D0(Standard_Address const C, Standard_Real const U, gp_Pnt2d P)

    Computes the point of parameter U on the curve.

    :type C: OCC.wrapper.Standard.Standard_Address
    :type U: float
    :type P: OCC.wrapper.gp.gp_Pnt2d

    """
    return _HLRBRep.HLRBRep_CurveTool_D0(*args)

def HLRBRep_CurveTool_D1(*args):
    """
    HLRBRep_CurveTool_D1(Standard_Address const C, Standard_Real const U, gp_Pnt2d P, gp_Vec2d V)

    Computes the point  of parameter U on the curve
    with its first derivative.
    Raised if the continuity of the current interval
    is not C1.

    :type C: OCC.wrapper.Standard.Standard_Address
    :type U: float
    :type P: OCC.wrapper.gp.gp_Pnt2d
    :type V: OCC.wrapper.gp.gp_Vec2d

    """
    return _HLRBRep.HLRBRep_CurveTool_D1(*args)

def HLRBRep_CurveTool_D2(*args):
    """
    HLRBRep_CurveTool_D2(Standard_Address const C, Standard_Real const U, gp_Pnt2d P, gp_Vec2d V1, gp_Vec2d V2)

    Returns the point P of parameter U, the first and second
    derivatives V1 and V2.
    Raised if the continuity of the current interval
    is not C2.

    :type C: OCC.wrapper.Standard.Standard_Address
    :type U: float
    :type P: OCC.wrapper.gp.gp_Pnt2d
    :type V1: OCC.wrapper.gp.gp_Vec2d
    :type V2: OCC.wrapper.gp.gp_Vec2d

    """
    return _HLRBRep.HLRBRep_CurveTool_D2(*args)

def HLRBRep_CurveTool_D3(*args):
    """
    HLRBRep_CurveTool_D3(Standard_Address const C, Standard_Real const U, gp_Pnt2d P, gp_Vec2d V1, gp_Vec2d V2, gp_Vec2d V3)

    Returns the point P of parameter U, the first, the second
    and the third derivative.
    Raised if the continuity of the current interval
    is not C3.

    :type C: OCC.wrapper.Standard.Standard_Address
    :type U: float
    :type P: OCC.wrapper.gp.gp_Pnt2d
    :type V1: OCC.wrapper.gp.gp_Vec2d
    :type V2: OCC.wrapper.gp.gp_Vec2d
    :type V3: OCC.wrapper.gp.gp_Vec2d

    """
    return _HLRBRep.HLRBRep_CurveTool_D3(*args)

def HLRBRep_CurveTool_DN(*args):
    """
    HLRBRep_CurveTool_DN(Standard_Address const C, Standard_Real const U, Standard_Integer const N) -> gp_Vec2d

    The returned vector gives the value of the derivative for the
    order of derivation N.
    Raised if the continuity of the current interval
    is not CN.
    Raised if N < 1.

    :type C: OCC.wrapper.Standard.Standard_Address
    :type U: float
    :type N: int
    :rtype: OCC.wrapper.gp.gp_Vec2d

    """
    return _HLRBRep.HLRBRep_CurveTool_DN(*args)

def HLRBRep_CurveTool_Resolution(*args):
    """
    HLRBRep_CurveTool_Resolution(Standard_Address const C, Standard_Real const R3d) -> Standard_Real

    Returns the parametric  resolution corresponding
    to the real space resolution <R3d>.

    :type C: OCC.wrapper.Standard.Standard_Address
    :type R3d: float
    :rtype: OCC.wrapper.Standard.Standard_Real

    """
    return _HLRBRep.HLRBRep_CurveTool_Resolution(*args)

def HLRBRep_CurveTool_GetType(*args):
    """
    HLRBRep_CurveTool_GetType(Standard_Address const C) -> GeomAbs_CurveType

    Returns  the  type of the   curve  in the  current
    interval :   Line,   Circle,   Ellipse, Hyperbola,
    Parabola, BezierCurve, BSplineCurve, OtherCurve.

    :type C: OCC.wrapper.Standard.Standard_Address
    :rtype: OCC.wrapper.GeomAbs.GeomAbs_CurveType

    """
    return _HLRBRep.HLRBRep_CurveTool_GetType(*args)

def HLRBRep_CurveTool_TheType(*args):
    """
    HLRBRep_CurveTool_TheType(Standard_Address const C) -> GeomAbs_CurveType

    Returns  the  type of the   curve  in the  current
    interval :   Line,   Circle,   Ellipse, Hyperbola,
    Parabola, BezierCurve, BSplineCurve, OtherCurve.

    :type C: OCC.wrapper.Standard.Standard_Address
    :rtype: OCC.wrapper.GeomAbs.GeomAbs_CurveType

    """
    return _HLRBRep.HLRBRep_CurveTool_TheType(*args)

def HLRBRep_CurveTool_Line(*args):
    """
    HLRBRep_CurveTool_Line(Standard_Address const C) -> gp_Lin2d

    :type C: OCC.wrapper.Standard.Standard_Address
    :rtype: OCC.wrapper.gp.gp_Lin2d

    """
    return _HLRBRep.HLRBRep_CurveTool_Line(*args)

def HLRBRep_CurveTool_Circle(*args):
    """
    HLRBRep_CurveTool_Circle(Standard_Address const C) -> gp_Circ2d

    :type C: OCC.wrapper.Standard.Standard_Address
    :rtype: OCC.wrapper.gp.gp_Circ2d

    """
    return _HLRBRep.HLRBRep_CurveTool_Circle(*args)

def HLRBRep_CurveTool_Ellipse(*args):
    """
    HLRBRep_CurveTool_Ellipse(Standard_Address const C) -> gp_Elips2d

    :type C: OCC.wrapper.Standard.Standard_Address
    :rtype: OCC.wrapper.gp.gp_Elips2d

    """
    return _HLRBRep.HLRBRep_CurveTool_Ellipse(*args)

def HLRBRep_CurveTool_Hyperbola(*args):
    """
    HLRBRep_CurveTool_Hyperbola(Standard_Address const C) -> gp_Hypr2d

    :type C: OCC.wrapper.Standard.Standard_Address
    :rtype: OCC.wrapper.gp.gp_Hypr2d

    """
    return _HLRBRep.HLRBRep_CurveTool_Hyperbola(*args)

def HLRBRep_CurveTool_Parabola(*args):
    """
    HLRBRep_CurveTool_Parabola(Standard_Address const C) -> gp_Parab2d

    :type C: OCC.wrapper.Standard.Standard_Address
    :rtype: OCC.wrapper.gp.gp_Parab2d

    """
    return _HLRBRep.HLRBRep_CurveTool_Parabola(*args)

def HLRBRep_CurveTool_Bezier(*args):
    """
    HLRBRep_CurveTool_Bezier(Standard_Address const C) -> Handle_Geom2d_BezierCurve

    :type C: OCC.wrapper.Standard.Standard_Address
    :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_BezierCurve

    """
    return _HLRBRep.HLRBRep_CurveTool_Bezier(*args)

def HLRBRep_CurveTool_BSpline(*args):
    """
    HLRBRep_CurveTool_BSpline(Standard_Address const C) -> Handle_Geom2d_BSplineCurve

    :type C: OCC.wrapper.Standard.Standard_Address
    :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_BSplineCurve

    """
    return _HLRBRep.HLRBRep_CurveTool_BSpline(*args)

def HLRBRep_CurveTool_EpsX(*args):
    """
    HLRBRep_CurveTool_EpsX(Standard_Address const C) -> Standard_Real

    :type C: OCC.wrapper.Standard.Standard_Address
    :rtype: OCC.wrapper.Standard.Standard_Real

    """
    return _HLRBRep.HLRBRep_CurveTool_EpsX(*args)

def HLRBRep_CurveTool_NbSamples(*args):
    """
    NbSamples(Standard_Address const C, Standard_Real const U0, Standard_Real const U1) -> Standard_Integer
    HLRBRep_CurveTool_NbSamples(Standard_Address const C) -> Standard_Integer

    :type C: OCC.wrapper.Standard.Standard_Address
    :rtype: OCC.wrapper.Standard.Standard_Integer

    """
    return _HLRBRep.HLRBRep_CurveTool_NbSamples(*args)

def HLRBRep_CurveTool_Degree(*args):
    """
    HLRBRep_CurveTool_Degree(Standard_Address const C) -> Standard_Integer

    :type C: OCC.wrapper.Standard.Standard_Address
    :rtype: OCC.wrapper.Standard.Standard_Integer

    """
    return _HLRBRep.HLRBRep_CurveTool_Degree(*args)

class HLRBRep_Data(Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_HLRBRep_Data
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_HLRBRep_Data(self) 
            return h


    def __init__(self, *args):
        """
        __init__(HLRBRep_Data self, Standard_Integer const NV, Standard_Integer const NE, Standard_Integer const NF) -> HLRBRep_Data

        Create an  empty data structure  of <NV> vertices,
        <NE> edges and <NF> faces.

        :type NV: int
        :type NE: int
        :type NF: int

        """
        this = _HLRBRep.new_HLRBRep_Data(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Write(self, *args):
        """
        Write(HLRBRep_Data self, Handle_HLRBRep_Data DS, Standard_Integer const dv, Standard_Integer const de, Standard_Integer const df)

        Write <DS>    in   me  with   a     translation of
        <dv>,<de>,<df>.

        :type DS: OCC.wrapper.HLRBRep.Handle_HLRBRep_Data
        :type dv: int
        :type de: int
        :type df: int

        """
        return _HLRBRep.HLRBRep_Data_Write(self, *args)


    def EDataArray(self, *args):
        """
        EDataArray(HLRBRep_Data self) -> NCollection_Array1_HLRBRep_EdgeData

        :rtype: OCC.wrapper.HLRBRep.HLRBRep_Array1OfEData

        """
        return _HLRBRep.HLRBRep_Data_EDataArray(self, *args)


    def FDataArray(self, *args):
        """
        FDataArray(HLRBRep_Data self) -> NCollection_Array1_HLRBRep_FaceData

        :rtype: OCC.wrapper.HLRBRep.HLRBRep_Array1OfFData

        """
        return _HLRBRep.HLRBRep_Data_FDataArray(self, *args)


    def Tolerance(self, *args):
        """
        Tolerance(HLRBRep_Data self, Standard_ShortReal const tol)
        Tolerance(HLRBRep_Data self) -> Standard_ShortReal

        returns  the tolerance for the  rejections  during
        the exploration

        :rtype: OCC.wrapper.Standard.Standard_ShortReal

        """
        return _HLRBRep.HLRBRep_Data_Tolerance(self, *args)


    def Update(self, *args):
        """
        Update(HLRBRep_Data self, HLRAlgo_Projector P)

        end of building  of the Data and updating
        all the informations linked to the projection.

        :type P: OCC.wrapper.HLRAlgo.HLRAlgo_Projector

        """
        return _HLRBRep.HLRBRep_Data_Update(self, *args)


    def Projector(self, *args):
        """
        Projector(HLRBRep_Data self) -> HLRAlgo_Projector

        :rtype: OCC.wrapper.HLRAlgo.HLRAlgo_Projector

        """
        return _HLRBRep.HLRBRep_Data_Projector(self, *args)


    def NbVertices(self, *args):
        """
        NbVertices(HLRBRep_Data self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _HLRBRep.HLRBRep_Data_NbVertices(self, *args)


    def NbEdges(self, *args):
        """
        NbEdges(HLRBRep_Data self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _HLRBRep.HLRBRep_Data_NbEdges(self, *args)


    def NbFaces(self, *args):
        """
        NbFaces(HLRBRep_Data self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _HLRBRep.HLRBRep_Data_NbFaces(self, *args)


    def EdgeMap(self, *args):
        """
        EdgeMap(HLRBRep_Data self) -> NCollection_IndexedMap_TopoDS_Shape_TopTools_ShapeMapHasher

        :rtype: OCC.wrapper.TopTools.TopTools_IndexedMapOfShape

        """
        return _HLRBRep.HLRBRep_Data_EdgeMap(self, *args)


    def FaceMap(self, *args):
        """
        FaceMap(HLRBRep_Data self) -> NCollection_IndexedMap_TopoDS_Shape_TopTools_ShapeMapHasher

        :rtype: OCC.wrapper.TopTools.TopTools_IndexedMapOfShape

        """
        return _HLRBRep.HLRBRep_Data_FaceMap(self, *args)


    def InitBoundSort(self, *args):
        """
        InitBoundSort(HLRBRep_Data self, HLRAlgo_EdgesBlock::MinMaxIndices const & MinMaxTot, Standard_Integer const e1, Standard_Integer const e2)

        to compare with only non rejected edges.

        :type MinMaxTot: MinMaxIndices
        :type e1: int
        :type e2: int

        """
        return _HLRBRep.HLRBRep_Data_InitBoundSort(self, *args)


    def InitEdge(self, *args):
        """
        InitEdge(HLRBRep_Data self, Standard_Integer const FI, NCollection_DataMap_TopoDS_Shape_BRepTopAdaptor_Tool_TopTools_ShapeMapHasher MST)

        Begin an iteration only  on visible Edges
        crossing the face number <FI>.

        :type FI: int
        :type MST: OCC.wrapper.BRepTopAdaptor.BRepTopAdaptor_MapOfShapeTool

        """
        return _HLRBRep.HLRBRep_Data_InitEdge(self, *args)


    def MoreEdge(self, *args):
        """
        MoreEdge(HLRBRep_Data self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _HLRBRep.HLRBRep_Data_MoreEdge(self, *args)


    def NextEdge(self, *args):
        """
        NextEdge(HLRBRep_Data self, Standard_Boolean const skip)

        :type skip: bool

        """
        return _HLRBRep.HLRBRep_Data_NextEdge(self, *args)


    def Edge(self, *args):
        """
        Edge(HLRBRep_Data self) -> Standard_Integer

        Returns the  current Edge

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _HLRBRep.HLRBRep_Data_Edge(self, *args)


    def HidingTheFace(self, *args):
        """
        HidingTheFace(HLRBRep_Data self) -> Standard_Boolean

        Returns true if   the  current edge to   be hidden
        belongs to the hiding face.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _HLRBRep.HLRBRep_Data_HidingTheFace(self, *args)


    def SimpleHidingFace(self, *args):
        """
        SimpleHidingFace(HLRBRep_Data self) -> Standard_Boolean

        Returns true if the current hiding face is not  an
        auto-intersected one.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _HLRBRep.HLRBRep_Data_SimpleHidingFace(self, *args)


    def InitInterference(self, *args):
        """
        InitInterference(HLRBRep_Data self)

        Intersect  the current  Edge  with the boundary of
        the hiding  face.   The interferences are given by
        the More, Next, and Value methods.


        """
        return _HLRBRep.HLRBRep_Data_InitInterference(self, *args)


    def MoreInterference(self, *args):
        """
        MoreInterference(HLRBRep_Data self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _HLRBRep.HLRBRep_Data_MoreInterference(self, *args)


    def NextInterference(self, *args):
        """NextInterference(HLRBRep_Data self)"""
        return _HLRBRep.HLRBRep_Data_NextInterference(self, *args)


    def RejectedInterference(self, *args):
        """
        RejectedInterference(HLRBRep_Data self) -> Standard_Boolean

        Returns  True if the  interference is rejected.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _HLRBRep.HLRBRep_Data_RejectedInterference(self, *args)


    def AboveInterference(self, *args):
        """
        AboveInterference(HLRBRep_Data self) -> Standard_Boolean

        Returns True if the rejected interference is above
        the face.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _HLRBRep.HLRBRep_Data_AboveInterference(self, *args)


    def Interference(self, *args):
        """
        Interference(HLRBRep_Data self) -> HLRAlgo_Interference

        :rtype: OCC.wrapper.HLRAlgo.HLRAlgo_Interference

        """
        return _HLRBRep.HLRBRep_Data_Interference(self, *args)


    def LocalLEGeometry2D(self, *args):
        """
        LocalLEGeometry2D(HLRBRep_Data self, Standard_Real const Param, gp_Dir2d Tg, gp_Dir2d Nm)

        Returns the local description of the projection of
        the current LEdge  at parameter  <Param>.

        :type Param: float
        :type Tg: OCC.wrapper.gp.gp_Dir2d
        :type Nm: OCC.wrapper.gp.gp_Dir2d
        :type Cu: float

        """
        return _HLRBRep.HLRBRep_Data_LocalLEGeometry2D(self, *args)


    def LocalFEGeometry2D(self, *args):
        """
        LocalFEGeometry2D(HLRBRep_Data self, Standard_Integer const FE, Standard_Real const Param, gp_Dir2d Tg, gp_Dir2d Nm)

        Returns the local description of the projection of
        the current FEdge  at parameter  <Param>.

        :type FE: int
        :type Param: float
        :type Tg: OCC.wrapper.gp.gp_Dir2d
        :type Nm: OCC.wrapper.gp.gp_Dir2d
        :type Cu: float

        """
        return _HLRBRep.HLRBRep_Data_LocalFEGeometry2D(self, *args)


    def EdgeState(self, *args):
        """
        EdgeState(HLRBRep_Data self, Standard_Real const p1, Standard_Real const p2)

        Returns the local  3D   state of the  intersection
        between the current edge and the current face at the
        <p1> and <p2> parameters.

        :type p1: float
        :type p2: float
        :type stbef: OCC.wrapper.TopAbs.TopAbs_State
        :type staf: OCC.wrapper.TopAbs.TopAbs_State

        """
        return _HLRBRep.HLRBRep_Data_EdgeState(self, *args)


    def EdgeOfTheHidingFace(self, *args):
        """
        EdgeOfTheHidingFace(HLRBRep_Data self, Standard_Integer const E, HLRBRep_EdgeData ED) -> Standard_Boolean

        Returns the  true if the  Edge <ED> belongs to the
        Hiding Face.

        :type E: int
        :type ED: OCC.wrapper.HLRBRep.HLRBRep_EdgeData
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _HLRBRep.HLRBRep_Data_EdgeOfTheHidingFace(self, *args)


    def HidingStartLevel(self, *args):
        """
        HidingStartLevel(HLRBRep_Data self, Standard_Integer const E, HLRBRep_EdgeData ED, HLRAlgo_InterferenceList const & IL) -> Standard_Integer

        Returns the number of  levels of hiding face above
        the   first  point  of   the    edge <ED>.     The
        InterferenceList is  given to  compute far away of
        the Interferences and then come back.

        :type E: int
        :type ED: OCC.wrapper.HLRBRep.HLRBRep_EdgeData
        :type IL: OCC.wrapper.HLRAlgo.HLRAlgo_InterferenceList
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _HLRBRep.HLRBRep_Data_HidingStartLevel(self, *args)


    def Compare(self, *args):
        """
        Compare(HLRBRep_Data self, Standard_Integer const E, HLRBRep_EdgeData ED) -> TopAbs_State

        Returns   the  state   of  the   Edge  <ED>  after
        classification.

        :type E: int
        :type ED: OCC.wrapper.HLRBRep.HLRBRep_EdgeData
        :rtype: OCC.wrapper.TopAbs.TopAbs_State

        """
        return _HLRBRep.HLRBRep_Data_Compare(self, *args)


    def SimplClassify(self, *args):
        """
        SimplClassify(HLRBRep_Data self, Standard_Integer const E, HLRBRep_EdgeData ED, Standard_Integer const Nbp, Standard_Real const p1, Standard_Real const p2) -> TopAbs_State

        Simple classification of part of edge  [p1,  p2]
        returns  OUT  if  at  least  1 of  Nbp  points  of  edge  is  out
        othewise  returns  IN
        It  is  used  to  check  "suspision"  hided  part  of  edge.

        :type E: int
        :type ED: OCC.wrapper.HLRBRep.HLRBRep_EdgeData
        :type Nbp: int
        :type p1: float
        :type p2: float
        :rtype: OCC.wrapper.TopAbs.TopAbs_State

        """
        return _HLRBRep.HLRBRep_Data_SimplClassify(self, *args)


    def Classify(self, *args):
        """
        Classify(HLRBRep_Data self, Standard_Integer const E, HLRBRep_EdgeData ED, Standard_Boolean const LevelFlag, Standard_Real const param) -> TopAbs_State

        Classification of an edge.

        :type E: int
        :type ED: OCC.wrapper.HLRBRep.HLRBRep_EdgeData
        :type LevelFlag: bool
        :type Level: int
        :type param: float
        :rtype: OCC.wrapper.TopAbs.TopAbs_State

        """
        return _HLRBRep.HLRBRep_Data_Classify(self, *args)


    def IsBadFace(self, *args):
        """
        IsBadFace(HLRBRep_Data self) -> Standard_Boolean

        Returns true if the current face is bad.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _HLRBRep.HLRBRep_Data_IsBadFace(self, *args)


    def Destroy(self, *args):
        """Destroy(HLRBRep_Data self)"""
        return _HLRBRep.HLRBRep_Data_Destroy(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _HLRBRep.HLRBRep_Data_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _HLRBRep.HLRBRep_Data_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _HLRBRep.HLRBRep_Data_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _HLRBRep.delete_HLRBRep_Data
HLRBRep_Data_swigregister = _HLRBRep.HLRBRep_Data_swigregister
HLRBRep_Data_swigregister(HLRBRep_Data)

def HLRBRep_Data_get_type_name(*args):
    """
    HLRBRep_Data_get_type_name() -> char const *

    :rtype: const char *

    """
    return _HLRBRep.HLRBRep_Data_get_type_name(*args)

def HLRBRep_Data_get_type_descriptor(*args):
    """
    HLRBRep_Data_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _HLRBRep.HLRBRep_Data_get_type_descriptor(*args)

class HLRBRep_HLRToShape(object):
    """
    A framework for filtering the computation
    results of an HLRBRep_Algo algorithm by extraction.
    From the results calculated by the algorithm on
    a shape, a filter returns the type of edge you
    want to identify. You can choose any of the following types of output:
    -   visible sharp edges
    -   hidden sharp edges
    -   visible smooth edges
    -   hidden smooth edges
    -   visible sewn edges
    -   hidden sewn edges
    -   visible outline edges
    -   hidden outline edges.
    -   visible isoparameters and
    -   hidden isoparameters.
    Sharp edges present a C0 continuity (non G1).
    Smooth edges present a G1 continuity (non G2).
    Sewn edges present a C2 continuity.
    The result is composed of 2D edges in the
    projection plane of the view which the
    algorithm has worked with. These 2D edges
    are not included in the data structure of the visualized shape.
    In order to obtain a complete image, you must
    combine the shapes given by each of the chosen filters.
    The construction of the shape does not call a
    new computation of the algorithm, but only
    reads its internal results.
    The methods of this shape are almost identic to those of the HLRBrep_PolyHLRToShape class.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(HLRBRep_HLRToShape self, Handle_HLRBRep_Algo A) -> HLRBRep_HLRToShape

        Constructs a framework for filtering the
        results of the HLRBRep_Algo algorithm, A.
        Use the extraction filters to obtain the results you want for A.

        :type A: OCC.wrapper.HLRBRep.Handle_HLRBRep_Algo

        """
        this = _HLRBRep.new_HLRBRep_HLRToShape(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def VCompound(self, *args):
        """
        VCompound(HLRBRep_HLRToShape self) -> TopoDS_Shape
        VCompound(HLRBRep_HLRToShape self, TopoDS_Shape S) -> TopoDS_Shape

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _HLRBRep.HLRBRep_HLRToShape_VCompound(self, *args)


    def Rg1LineVCompound(self, *args):
        """
        Rg1LineVCompound(HLRBRep_HLRToShape self) -> TopoDS_Shape
        Rg1LineVCompound(HLRBRep_HLRToShape self, TopoDS_Shape S) -> TopoDS_Shape

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _HLRBRep.HLRBRep_HLRToShape_Rg1LineVCompound(self, *args)


    def RgNLineVCompound(self, *args):
        """
        RgNLineVCompound(HLRBRep_HLRToShape self) -> TopoDS_Shape
        RgNLineVCompound(HLRBRep_HLRToShape self, TopoDS_Shape S) -> TopoDS_Shape

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _HLRBRep.HLRBRep_HLRToShape_RgNLineVCompound(self, *args)


    def OutLineVCompound3d(self, *args):
        """
        OutLineVCompound3d(HLRBRep_HLRToShape self) -> TopoDS_Shape

        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _HLRBRep.HLRBRep_HLRToShape_OutLineVCompound3d(self, *args)


    def OutLineVCompound(self, *args):
        """
        OutLineVCompound(HLRBRep_HLRToShape self) -> TopoDS_Shape
        OutLineVCompound(HLRBRep_HLRToShape self, TopoDS_Shape S) -> TopoDS_Shape

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _HLRBRep.HLRBRep_HLRToShape_OutLineVCompound(self, *args)


    def IsoLineVCompound(self, *args):
        """
        IsoLineVCompound(HLRBRep_HLRToShape self) -> TopoDS_Shape
        IsoLineVCompound(HLRBRep_HLRToShape self, TopoDS_Shape S) -> TopoDS_Shape

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _HLRBRep.HLRBRep_HLRToShape_IsoLineVCompound(self, *args)


    def HCompound(self, *args):
        """
        HCompound(HLRBRep_HLRToShape self) -> TopoDS_Shape
        HCompound(HLRBRep_HLRToShape self, TopoDS_Shape S) -> TopoDS_Shape

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _HLRBRep.HLRBRep_HLRToShape_HCompound(self, *args)


    def Rg1LineHCompound(self, *args):
        """
        Rg1LineHCompound(HLRBRep_HLRToShape self) -> TopoDS_Shape
        Rg1LineHCompound(HLRBRep_HLRToShape self, TopoDS_Shape S) -> TopoDS_Shape

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _HLRBRep.HLRBRep_HLRToShape_Rg1LineHCompound(self, *args)


    def RgNLineHCompound(self, *args):
        """
        RgNLineHCompound(HLRBRep_HLRToShape self) -> TopoDS_Shape
        RgNLineHCompound(HLRBRep_HLRToShape self, TopoDS_Shape S) -> TopoDS_Shape

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _HLRBRep.HLRBRep_HLRToShape_RgNLineHCompound(self, *args)


    def OutLineHCompound(self, *args):
        """
        OutLineHCompound(HLRBRep_HLRToShape self) -> TopoDS_Shape
        OutLineHCompound(HLRBRep_HLRToShape self, TopoDS_Shape S) -> TopoDS_Shape

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _HLRBRep.HLRBRep_HLRToShape_OutLineHCompound(self, *args)


    def IsoLineHCompound(self, *args):
        """
        IsoLineHCompound(HLRBRep_HLRToShape self) -> TopoDS_Shape
        IsoLineHCompound(HLRBRep_HLRToShape self, TopoDS_Shape S) -> TopoDS_Shape

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _HLRBRep.HLRBRep_HLRToShape_IsoLineHCompound(self, *args)


    def CompoundOfEdges(self, *args):
        """
        CompoundOfEdges(HLRBRep_HLRToShape self, HLRBRep_TypeOfResultingEdge const type, Standard_Boolean const visible, Standard_Boolean const In3d) -> TopoDS_Shape
        CompoundOfEdges(HLRBRep_HLRToShape self, TopoDS_Shape S, HLRBRep_TypeOfResultingEdge const type, Standard_Boolean const visible, Standard_Boolean const In3d) -> TopoDS_Shape

        For specified shape 
        returns compound of resulting edges
        of required type and visibility,
        taking into account the kind of space
        (2d or 3d)

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :type type: OCC.wrapper.HLRBRep.HLRBRep_TypeOfResultingEdge
        :type visible: bool
        :type In3d: bool
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _HLRBRep.HLRBRep_HLRToShape_CompoundOfEdges(self, *args)

    __swig_destroy__ = _HLRBRep.delete_HLRBRep_HLRToShape
HLRBRep_HLRToShape_swigregister = _HLRBRep.HLRBRep_HLRToShape_swigregister
HLRBRep_HLRToShape_swigregister(HLRBRep_HLRToShape)

class HLRBRep_TheIntConicCurveOfCInter(IntRes2d.IntRes2d_Intersection):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(HLRBRep_TheIntConicCurveOfCInter self) -> HLRBRep_TheIntConicCurveOfCInter
        __init__(HLRBRep_TheIntConicCurveOfCInter self, gp_Lin2d L, IntRes2d_Domain D1, Standard_Address const & PCurve, IntRes2d_Domain D2, Standard_Real const TolConf, Standard_Real const Tol) -> HLRBRep_TheIntConicCurveOfCInter
        __init__(HLRBRep_TheIntConicCurveOfCInter self, gp_Circ2d C, IntRes2d_Domain D1, Standard_Address const & PCurve, IntRes2d_Domain D2, Standard_Real const TolConf, Standard_Real const Tol) -> HLRBRep_TheIntConicCurveOfCInter
        __init__(HLRBRep_TheIntConicCurveOfCInter self, gp_Elips2d E, IntRes2d_Domain D1, Standard_Address const & PCurve, IntRes2d_Domain D2, Standard_Real const TolConf, Standard_Real const Tol) -> HLRBRep_TheIntConicCurveOfCInter
        __init__(HLRBRep_TheIntConicCurveOfCInter self, gp_Parab2d Prb, IntRes2d_Domain D1, Standard_Address const & PCurve, IntRes2d_Domain D2, Standard_Real const TolConf, Standard_Real const Tol) -> HLRBRep_TheIntConicCurveOfCInter
        __init__(HLRBRep_TheIntConicCurveOfCInter self, gp_Hypr2d H, IntRes2d_Domain D1, Standard_Address const & PCurve, IntRes2d_Domain D2, Standard_Real const TolConf, Standard_Real const Tol) -> HLRBRep_TheIntConicCurveOfCInter

        Intersection between the main branch of an hyperbola
        and a parametric curve.

        :type H: OCC.wrapper.gp.gp_Hypr2d
        :type D1: OCC.wrapper.IntRes2d.IntRes2d_Domain
        :type PCurve: OCC.wrapper.Standard.Standard_Address
        :type D2: OCC.wrapper.IntRes2d.IntRes2d_Domain
        :type TolConf: float
        :type Tol: float

        """
        this = _HLRBRep.new_HLRBRep_TheIntConicCurveOfCInter(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Perform(self, *args):
        """
        Perform(HLRBRep_TheIntConicCurveOfCInter self, gp_Lin2d L, IntRes2d_Domain D1, Standard_Address const & PCurve, IntRes2d_Domain D2, Standard_Real const TolConf, Standard_Real const Tol)
        Perform(HLRBRep_TheIntConicCurveOfCInter self, gp_Circ2d C, IntRes2d_Domain D1, Standard_Address const & PCurve, IntRes2d_Domain D2, Standard_Real const TolConf, Standard_Real const Tol)
        Perform(HLRBRep_TheIntConicCurveOfCInter self, gp_Elips2d E, IntRes2d_Domain D1, Standard_Address const & PCurve, IntRes2d_Domain D2, Standard_Real const TolConf, Standard_Real const Tol)
        Perform(HLRBRep_TheIntConicCurveOfCInter self, gp_Parab2d Prb, IntRes2d_Domain D1, Standard_Address const & PCurve, IntRes2d_Domain D2, Standard_Real const TolConf, Standard_Real const Tol)
        Perform(HLRBRep_TheIntConicCurveOfCInter self, gp_Hypr2d H, IntRes2d_Domain D1, Standard_Address const & PCurve, IntRes2d_Domain D2, Standard_Real const TolConf, Standard_Real const Tol)

        Intersection between the main branch of an hyperbola
        and a parametric curve.

        :type H: OCC.wrapper.gp.gp_Hypr2d
        :type D1: OCC.wrapper.IntRes2d.IntRes2d_Domain
        :type PCurve: OCC.wrapper.Standard.Standard_Address
        :type D2: OCC.wrapper.IntRes2d.IntRes2d_Domain
        :type TolConf: float
        :type Tol: float

        """
        return _HLRBRep.HLRBRep_TheIntConicCurveOfCInter_Perform(self, *args)

    __swig_destroy__ = _HLRBRep.delete_HLRBRep_TheIntConicCurveOfCInter
HLRBRep_TheIntConicCurveOfCInter_swigregister = _HLRBRep.HLRBRep_TheIntConicCurveOfCInter_swigregister
HLRBRep_TheIntConicCurveOfCInter_swigregister(HLRBRep_TheIntConicCurveOfCInter)

class HLRBRep_ThePolyhedronOfInterCSurf(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(HLRBRep_ThePolyhedronOfInterCSurf self, Standard_Address const & Surface, Standard_Integer const nbdU, Standard_Integer const nbdV, Standard_Real const U1, Standard_Real const V1, Standard_Real const U2, Standard_Real const V2) -> HLRBRep_ThePolyhedronOfInterCSurf
        __init__(HLRBRep_ThePolyhedronOfInterCSurf self, Standard_Address const & Surface, NCollection_Array1_Standard_Real Upars, NCollection_Array1_Standard_Real Vpars) -> HLRBRep_ThePolyhedronOfInterCSurf

        :type Surface: OCC.wrapper.Standard.Standard_Address
        :type Upars: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type Vpars: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        this = _HLRBRep.new_HLRBRep_ThePolyhedronOfInterCSurf(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Destroy(self, *args):
        """Destroy(HLRBRep_ThePolyhedronOfInterCSurf self)"""
        return _HLRBRep.HLRBRep_ThePolyhedronOfInterCSurf_Destroy(self, *args)


    def DeflectionOnTriangle(self, *args):
        """
        DeflectionOnTriangle(HLRBRep_ThePolyhedronOfInterCSurf self, Standard_Address const & Surface, Standard_Integer const Index) -> Standard_Real

        :type Surface: OCC.wrapper.Standard.Standard_Address
        :type Index: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _HLRBRep.HLRBRep_ThePolyhedronOfInterCSurf_DeflectionOnTriangle(self, *args)


    def Size(self, *args):
        """
        Size(HLRBRep_ThePolyhedronOfInterCSurf self)

        get the size of the discretization.

        :type nbdu: int
        :type nbdv: int

        """
        return _HLRBRep.HLRBRep_ThePolyhedronOfInterCSurf_Size(self, *args)


    def NbTriangles(self, *args):
        """
        NbTriangles(HLRBRep_ThePolyhedronOfInterCSurf self) -> Standard_Integer

        Give the number of triangles in this double array of

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _HLRBRep.HLRBRep_ThePolyhedronOfInterCSurf_NbTriangles(self, *args)


    def Triangle(self, *args):
        """
        Triangle(HLRBRep_ThePolyhedronOfInterCSurf self, Standard_Integer const Index)

        Give the 3 points of the triangle of addresse Index in
        the double array of triangles.

        :type Index: int
        :type P1: int
        :type P2: int
        :type P3: int

        """
        return _HLRBRep.HLRBRep_ThePolyhedronOfInterCSurf_Triangle(self, *args)


    def TriConnex(self, *args):
        """
        TriConnex(HLRBRep_ThePolyhedronOfInterCSurf self, Standard_Integer const Triang, Standard_Integer const Pivot, Standard_Integer const Pedge) -> Standard_Integer

        Give the addresse Tricon of the triangle connexe to the
        triangle of address Triang by the edge Pivot Pedge and
        the third point of this connexe triangle. When we are
        on a free edge TriCon==0 but the function return the
        value of the triangle in the other side of Pivot on
        the free edge. Used to turn around a vertex.

        :type Triang: int
        :type Pivot: int
        :type Pedge: int
        :type TriCon: int
        :type OtherP: int
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _HLRBRep.HLRBRep_ThePolyhedronOfInterCSurf_TriConnex(self, *args)


    def NbPoints(self, *args):
        """
        NbPoints(HLRBRep_ThePolyhedronOfInterCSurf self) -> Standard_Integer

        Give the number of point in the double array of
        triangles ((nbdu+1)*(nbdv+1)).

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _HLRBRep.HLRBRep_ThePolyhedronOfInterCSurf_NbPoints(self, *args)


    def Point(self, *args):
        """
        Give the point of index i in the MaTriangle.

        :type Index: int
        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        res = _HLRBRep.HLRBRep_ThePolyhedronOfInterCSurf_Point(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Bounding(self, *args):
        """
        Give the bounding box of the MaTriangle.

        :rtype: OCC.wrapper.Bnd.Bnd_Box

        """
        res = _HLRBRep.HLRBRep_ThePolyhedronOfInterCSurf_Bounding(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def FillBounding(self, *args):
        """
        FillBounding(HLRBRep_ThePolyhedronOfInterCSurf self)

        Compute the array of boxes. The box <n> corresponding
        to the triangle <n>.


        """
        return _HLRBRep.HLRBRep_ThePolyhedronOfInterCSurf_FillBounding(self, *args)


    def ComponentsBounding(self, *args):
        """
        Give the array of boxes. The box <n> corresponding
        to the triangle <n>.

        :rtype: OCC.wrapper.Bnd.Handle_Bnd_HArray1OfBox

        """
        res = _HLRBRep.HLRBRep_ThePolyhedronOfInterCSurf_ComponentsBounding(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DeflectionOverEstimation(self, *args):
        """
        DeflectionOverEstimation(HLRBRep_ThePolyhedronOfInterCSurf self, Standard_Real const flec)
        DeflectionOverEstimation(HLRBRep_ThePolyhedronOfInterCSurf self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _HLRBRep.HLRBRep_ThePolyhedronOfInterCSurf_DeflectionOverEstimation(self, *args)


    def PlaneEquation(self, *args):
        """
        PlaneEquation(HLRBRep_ThePolyhedronOfInterCSurf self, Standard_Integer const Triang, gp_XYZ NormalVector)

        Give the plane equation of the triangle of addresse Triang.

        :type Triang: int
        :type NormalVector: OCC.wrapper.gp.gp_XYZ
        :type PolarDistance: float

        """
        return _HLRBRep.HLRBRep_ThePolyhedronOfInterCSurf_PlaneEquation(self, *args)


    def Contain(self, *args):
        """
        Contain(HLRBRep_ThePolyhedronOfInterCSurf self, Standard_Integer const Triang, gp_Pnt ThePnt) -> Standard_Boolean

        Give the plane equation of the triangle of addresse Triang.

        :type Triang: int
        :type ThePnt: OCC.wrapper.gp.gp_Pnt
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _HLRBRep.HLRBRep_ThePolyhedronOfInterCSurf_Contain(self, *args)


    def Parameters(self, *args):
        """
        Parameters(HLRBRep_ThePolyhedronOfInterCSurf self, Standard_Integer const Index)

        :type Index: int
        :type U: float
        :type V: float

        """
        return _HLRBRep.HLRBRep_ThePolyhedronOfInterCSurf_Parameters(self, *args)


    def IsOnBound(self, *args):
        """
        IsOnBound(HLRBRep_ThePolyhedronOfInterCSurf self, Standard_Integer const Index1, Standard_Integer const Index2) -> Standard_Boolean

        This method returns true if the edge based on points with
        indices Index1 and Index2 represents a boundary edge. It is
        necessary to take into account the boundary deflection for
        this edge.

        :type Index1: int
        :type Index2: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _HLRBRep.HLRBRep_ThePolyhedronOfInterCSurf_IsOnBound(self, *args)


    def GetBorderDeflection(self, *args):
        """
        GetBorderDeflection(HLRBRep_ThePolyhedronOfInterCSurf self) -> Standard_Real

        This method returns a border deflection.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _HLRBRep.HLRBRep_ThePolyhedronOfInterCSurf_GetBorderDeflection(self, *args)


    def Dump(self, *args):
        """Dump(HLRBRep_ThePolyhedronOfInterCSurf self)"""
        return _HLRBRep.HLRBRep_ThePolyhedronOfInterCSurf_Dump(self, *args)

    __swig_destroy__ = _HLRBRep.delete_HLRBRep_ThePolyhedronOfInterCSurf
HLRBRep_ThePolyhedronOfInterCSurf_swigregister = _HLRBRep.HLRBRep_ThePolyhedronOfInterCSurf_swigregister
HLRBRep_ThePolyhedronOfInterCSurf_swigregister(HLRBRep_ThePolyhedronOfInterCSurf)

class HLRBRep_ShapeToHLR(object):
    """
    compute  the   OutLinedShape  of  a Shape with  an
    OutLiner,    a  Projector  and   create  the  Data
    Structure of a Shape.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Load(*args):
        """
        Load(Handle_HLRTopoBRep_OutLiner S, HLRAlgo_Projector P, NCollection_DataMap_TopoDS_Shape_BRepTopAdaptor_Tool_TopTools_ShapeMapHasher MST, Standard_Integer const nbIso=0) -> Handle_HLRBRep_Data

        Creates  a DataStructure   containing the OutLiner
        <S> depending on the projector <P> and nbIso.

        :type S: OCC.wrapper.HLRTopoBRep.Handle_HLRTopoBRep_OutLiner
        :type P: OCC.wrapper.HLRAlgo.HLRAlgo_Projector
        :type MST: OCC.wrapper.BRepTopAdaptor.BRepTopAdaptor_MapOfShapeTool
        :type nbIso: int
        :rtype: OCC.wrapper.HLRBRep.Handle_HLRBRep_Data

        """
        return _HLRBRep.HLRBRep_ShapeToHLR_Load(*args)

    Load = staticmethod(Load)

    def __init__(self):
        """
        compute  the   OutLinedShape  of  a Shape with  an
        OutLiner,    a  Projector  and   create  the  Data
        Structure of a Shape.
        """
        this = _HLRBRep.new_HLRBRep_ShapeToHLR()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _HLRBRep.delete_HLRBRep_ShapeToHLR
HLRBRep_ShapeToHLR_swigregister = _HLRBRep.HLRBRep_ShapeToHLR_swigregister
HLRBRep_ShapeToHLR_swigregister(HLRBRep_ShapeToHLR)

def HLRBRep_ShapeToHLR_Load(*args):
    """
    HLRBRep_ShapeToHLR_Load(Handle_HLRTopoBRep_OutLiner S, HLRAlgo_Projector P, NCollection_DataMap_TopoDS_Shape_BRepTopAdaptor_Tool_TopTools_ShapeMapHasher MST, Standard_Integer const nbIso=0) -> Handle_HLRBRep_Data

    Creates  a DataStructure   containing the OutLiner
    <S> depending on the projector <P> and nbIso.

    :type S: OCC.wrapper.HLRTopoBRep.Handle_HLRTopoBRep_OutLiner
    :type P: OCC.wrapper.HLRAlgo.HLRAlgo_Projector
    :type MST: OCC.wrapper.BRepTopAdaptor.BRepTopAdaptor_MapOfShapeTool
    :type nbIso: int
    :rtype: OCC.wrapper.HLRBRep.Handle_HLRBRep_Data

    """
    return _HLRBRep.HLRBRep_ShapeToHLR_Load(*args)

class HLRBRep_Curve(object):
    """
    Defines a 2d curve by projection of  a 3D curve on
    a    plane     with  an     optional   perspective
    transformation.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(HLRBRep_Curve self) -> HLRBRep_Curve

        Creates an undefined Curve.


        """
        this = _HLRBRep.new_HLRBRep_Curve(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Projector(self, *args):
        """
        Projector(HLRBRep_Curve self, HLRAlgo_Projector Proj)

        :type Proj: OCC.wrapper.HLRAlgo.HLRAlgo_Projector

        """
        return _HLRBRep.HLRBRep_Curve_Projector(self, *args)


    def Curve(self, *args):
        """
        Curve(HLRBRep_Curve self) -> BRepAdaptor_Curve
        Curve(HLRBRep_Curve self, TopoDS_Edge E)

        Sets the 3D curve to be projected.

        :type E: OCC.wrapper.TopoDS.TopoDS_Edge

        """
        return _HLRBRep.HLRBRep_Curve_Curve(self, *args)


    def GetCurve(self, *args):
        """
        Returns the 3D curve.

        :rtype: OCC.wrapper.BRepAdaptor.BRepAdaptor_Curve

        """
        res = _HLRBRep.HLRBRep_Curve_GetCurve(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Parameter2d(self, *args):
        """
        Parameter2d(HLRBRep_Curve self, Standard_Real const P3d) -> Standard_Real

        Returns the parameter   on the 2d  curve  from the
        parameter on the 3d curve.

        :type P3d: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _HLRBRep.HLRBRep_Curve_Parameter2d(self, *args)


    def Parameter3d(self, *args):
        """
        Parameter3d(HLRBRep_Curve self, Standard_Real const P2d) -> Standard_Real

        Returns the parameter   on the 3d  curve  from the
        parameter on the 2d curve.

        :type P2d: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _HLRBRep.HLRBRep_Curve_Parameter3d(self, *args)


    def Update(self, *args):
        """
        Update(HLRBRep_Curve self, Standard_Real * TotMin, Standard_Real * TotMax) -> Standard_Real

        Update the minmax and the internal data

        :type TotMin: OCC.wrapper.Standard.Standard_Real [16]
        :type TotMax: OCC.wrapper.Standard.Standard_Real [16]
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _HLRBRep.HLRBRep_Curve_Update(self, *args)


    def UpdateMinMax(self, *args):
        """
        UpdateMinMax(HLRBRep_Curve self, Standard_Real * TotMin, Standard_Real * TotMax) -> Standard_Real

        Update the minmax returns tol for enlarge;

        :type TotMin: OCC.wrapper.Standard.Standard_Real [16]
        :type TotMax: OCC.wrapper.Standard.Standard_Real [16]
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _HLRBRep.HLRBRep_Curve_UpdateMinMax(self, *args)


    def Z(self, *args):
        """
        Z(HLRBRep_Curve self, Standard_Real const U) -> Standard_Real

        Computes the Z    coordinate  of the  point  of
        parameter U on the curve in the viewing coordinate system

        :type U: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _HLRBRep.HLRBRep_Curve_Z(self, *args)


    def Value3D(self, *args):
        """
        Value3D(HLRBRep_Curve self, Standard_Real const U) -> gp_Pnt

        Computes the 3D point   of parameter U  on the
        curve.

        :type U: float
        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _HLRBRep.HLRBRep_Curve_Value3D(self, *args)


    def Tangent(self, *args):
        """
        Tangent(HLRBRep_Curve self, Standard_Boolean const AtStart, gp_Pnt2d P, gp_Dir2d D)

        Depending on <AtStart> computes the 2D point and
        tangent on the curve  at sart (or at  end).  If the  first
        derivative is null look after  at start (or before at end)
        with the second derivative.

        :type AtStart: bool
        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type D: OCC.wrapper.gp.gp_Dir2d

        """
        return _HLRBRep.HLRBRep_Curve_Tangent(self, *args)


    def FirstParameter(self, *args):
        """
        FirstParameter(HLRBRep_Curve self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _HLRBRep.HLRBRep_Curve_FirstParameter(self, *args)


    def LastParameter(self, *args):
        """
        LastParameter(HLRBRep_Curve self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _HLRBRep.HLRBRep_Curve_LastParameter(self, *args)


    def Continuity(self, *args):
        """
        Continuity(HLRBRep_Curve self) -> GeomAbs_Shape

        :rtype: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _HLRBRep.HLRBRep_Curve_Continuity(self, *args)


    def NbIntervals(self, *args):
        """
        NbIntervals(HLRBRep_Curve self, GeomAbs_Shape const S) -> Standard_Integer

        If necessary,  breaks the  curve in  intervals  of
        continuity  <S>.    And  returns   the number   of
        intervals.

        :type S: OCC.wrapper.GeomAbs.GeomAbs_Shape
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _HLRBRep.HLRBRep_Curve_NbIntervals(self, *args)


    def Intervals(self, *args):
        """
        Intervals(HLRBRep_Curve self, NCollection_Array1_Standard_Real T, GeomAbs_Shape const S)

        Stores in <T> the  parameters bounding the intervals
        of continuity <S>.

        The array must provide  enough room to  accomodate
        for the parameters. i.e. T.Length() > NbIntervals()

        :type T: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type S: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _HLRBRep.HLRBRep_Curve_Intervals(self, *args)


    def IsClosed(self, *args):
        """
        IsClosed(HLRBRep_Curve self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _HLRBRep.HLRBRep_Curve_IsClosed(self, *args)


    def IsPeriodic(self, *args):
        """
        IsPeriodic(HLRBRep_Curve self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _HLRBRep.HLRBRep_Curve_IsPeriodic(self, *args)


    def Period(self, *args):
        """
        Period(HLRBRep_Curve self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _HLRBRep.HLRBRep_Curve_Period(self, *args)


    def Value(self, *args):
        """
        Value(HLRBRep_Curve self, Standard_Real const U) -> gp_Pnt2d

        Computes the point of parameter U on the curve.

        :type U: float
        :rtype: OCC.wrapper.gp.gp_Pnt2d

        """
        return _HLRBRep.HLRBRep_Curve_Value(self, *args)


    def D0(self, *args):
        """
        D0(HLRBRep_Curve self, Standard_Real const U, gp_Pnt P)
        D0(HLRBRep_Curve self, Standard_Real const U, gp_Pnt2d P)

        Computes the point of parameter U on the curve.

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt2d

        """
        return _HLRBRep.HLRBRep_Curve_D0(self, *args)


    def D1(self, *args):
        """
        D1(HLRBRep_Curve self, Standard_Real const U, gp_Pnt P, gp_Vec V)
        D1(HLRBRep_Curve self, Standard_Real const U, gp_Pnt2d P, gp_Vec2d V)

        Computes the point  of  parameter U on the curve
        with its first derivative.
        Raised if the continuity of the current interval
        is not C1.

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type V: OCC.wrapper.gp.gp_Vec2d

        """
        return _HLRBRep.HLRBRep_Curve_D1(self, *args)


    def D2(self, *args):
        """
        D2(HLRBRep_Curve self, Standard_Real const U, gp_Pnt2d P, gp_Vec2d V1, gp_Vec2d V2)

        Raised if the continuity of the current interval
        is not C2.

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type V1: OCC.wrapper.gp.gp_Vec2d
        :type V2: OCC.wrapper.gp.gp_Vec2d

        """
        return _HLRBRep.HLRBRep_Curve_D2(self, *args)


    def D3(self, *args):
        """
        D3(HLRBRep_Curve self, Standard_Real const U, gp_Pnt2d P, gp_Vec2d V1, gp_Vec2d V2, gp_Vec2d V3)

        Returns the point P of parameter U, the first, the second
        and the third derivative.
        Raised if the continuity of the current interval
        is not C3.

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type V1: OCC.wrapper.gp.gp_Vec2d
        :type V2: OCC.wrapper.gp.gp_Vec2d
        :type V3: OCC.wrapper.gp.gp_Vec2d

        """
        return _HLRBRep.HLRBRep_Curve_D3(self, *args)


    def DN(self, *args):
        """
        DN(HLRBRep_Curve self, Standard_Real const U, Standard_Integer const N) -> gp_Vec2d

        The returned vector gives the value of the derivative for the
        order of derivation N.
        Raised if the continuity of the current interval
        is not CN.
        Raised if N < 1.

        :type U: float
        :type N: int
        :rtype: OCC.wrapper.gp.gp_Vec2d

        """
        return _HLRBRep.HLRBRep_Curve_DN(self, *args)


    def Resolution(self, *args):
        """
        Resolution(HLRBRep_Curve self, Standard_Real const R3d) -> Standard_Real

        Returns the parametric  resolution corresponding
        to the real space resolution <R3d>.

        :type R3d: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _HLRBRep.HLRBRep_Curve_Resolution(self, *args)


    def GetType(self, *args):
        """
        GetType(HLRBRep_Curve self) -> GeomAbs_CurveType

        Returns  the  type of the   curve  in the  current
        interval :   Line,   Circle,   Ellipse, Hyperbola,
        Parabola, BezierCurve, BSplineCurve, OtherCurve.

        :rtype: OCC.wrapper.GeomAbs.GeomAbs_CurveType

        """
        return _HLRBRep.HLRBRep_Curve_GetType(self, *args)


    def Line(self, *args):
        """
        Line(HLRBRep_Curve self) -> gp_Lin2d

        :rtype: OCC.wrapper.gp.gp_Lin2d

        """
        return _HLRBRep.HLRBRep_Curve_Line(self, *args)


    def Circle(self, *args):
        """
        Circle(HLRBRep_Curve self) -> gp_Circ2d

        :rtype: OCC.wrapper.gp.gp_Circ2d

        """
        return _HLRBRep.HLRBRep_Curve_Circle(self, *args)


    def Ellipse(self, *args):
        """
        Ellipse(HLRBRep_Curve self) -> gp_Elips2d

        :rtype: OCC.wrapper.gp.gp_Elips2d

        """
        return _HLRBRep.HLRBRep_Curve_Ellipse(self, *args)


    def Hyperbola(self, *args):
        """
        Hyperbola(HLRBRep_Curve self) -> gp_Hypr2d

        :rtype: OCC.wrapper.gp.gp_Hypr2d

        """
        return _HLRBRep.HLRBRep_Curve_Hyperbola(self, *args)


    def Parabola(self, *args):
        """
        Parabola(HLRBRep_Curve self) -> gp_Parab2d

        :rtype: OCC.wrapper.gp.gp_Parab2d

        """
        return _HLRBRep.HLRBRep_Curve_Parabola(self, *args)


    def IsRational(self, *args):
        """
        IsRational(HLRBRep_Curve self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _HLRBRep.HLRBRep_Curve_IsRational(self, *args)


    def Degree(self, *args):
        """
        Degree(HLRBRep_Curve self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _HLRBRep.HLRBRep_Curve_Degree(self, *args)


    def NbPoles(self, *args):
        """
        NbPoles(HLRBRep_Curve self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _HLRBRep.HLRBRep_Curve_NbPoles(self, *args)


    def Poles(self, *args):
        """
        Poles(HLRBRep_Curve self, NCollection_Array1_gp_Pnt2d TP)
        Poles(HLRBRep_Curve self, Handle_Geom_BSplineCurve aCurve, NCollection_Array1_gp_Pnt2d TP)

        :type aCurve: OCC.wrapper.Geom.Handle_Geom_BSplineCurve
        :type TP: OCC.wrapper.TColgp.TColgp_Array1OfPnt2d

        """
        return _HLRBRep.HLRBRep_Curve_Poles(self, *args)


    def PolesAndWeights(self, *args):
        """
        PolesAndWeights(HLRBRep_Curve self, NCollection_Array1_gp_Pnt2d TP, NCollection_Array1_Standard_Real TW)
        PolesAndWeights(HLRBRep_Curve self, Handle_Geom_BSplineCurve aCurve, NCollection_Array1_gp_Pnt2d TP, NCollection_Array1_Standard_Real TW)

        :type aCurve: OCC.wrapper.Geom.Handle_Geom_BSplineCurve
        :type TP: OCC.wrapper.TColgp.TColgp_Array1OfPnt2d
        :type TW: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        return _HLRBRep.HLRBRep_Curve_PolesAndWeights(self, *args)


    def NbKnots(self, *args):
        """
        NbKnots(HLRBRep_Curve self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _HLRBRep.HLRBRep_Curve_NbKnots(self, *args)


    def Knots(self, *args):
        """
        Knots(HLRBRep_Curve self, NCollection_Array1_Standard_Real kn)

        :type kn: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        return _HLRBRep.HLRBRep_Curve_Knots(self, *args)


    def Multiplicities(self, *args):
        """
        Multiplicities(HLRBRep_Curve self, NCollection_Array1_Standard_Integer mu)

        :type mu: OCC.wrapper.TColStd.TColStd_Array1OfInteger

        """
        return _HLRBRep.HLRBRep_Curve_Multiplicities(self, *args)

    __swig_destroy__ = _HLRBRep.delete_HLRBRep_Curve
HLRBRep_Curve_swigregister = _HLRBRep.HLRBRep_Curve_swigregister
HLRBRep_Curve_swigregister(HLRBRep_Curve)

class HLRBRep_FaceIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """__init__(HLRBRep_FaceIterator self) -> HLRBRep_FaceIterator"""
        this = _HLRBRep.new_HLRBRep_FaceIterator(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def InitEdge(self, *args):
        """
        InitEdge(HLRBRep_FaceIterator self, HLRBRep_FaceData fd)

        Begin an exploration of the edges of the face <fd>

        :type fd: OCC.wrapper.HLRBRep.HLRBRep_FaceData

        """
        return _HLRBRep.HLRBRep_FaceIterator_InitEdge(self, *args)


    def MoreEdge(self, *args):
        """
        MoreEdge(HLRBRep_FaceIterator self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _HLRBRep.HLRBRep_FaceIterator_MoreEdge(self, *args)


    def NextEdge(self, *args):
        """NextEdge(HLRBRep_FaceIterator self)"""
        return _HLRBRep.HLRBRep_FaceIterator_NextEdge(self, *args)


    def BeginningOfWire(self, *args):
        """
        BeginningOfWire(HLRBRep_FaceIterator self) -> Standard_Boolean

        Returns True if the current edge is the first of a
        wire.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _HLRBRep.HLRBRep_FaceIterator_BeginningOfWire(self, *args)


    def EndOfWire(self, *args):
        """
        EndOfWire(HLRBRep_FaceIterator self) -> Standard_Boolean

        Returns True if the current edge is the  last of a
        wire.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _HLRBRep.HLRBRep_FaceIterator_EndOfWire(self, *args)


    def SkipWire(self, *args):
        """
        SkipWire(HLRBRep_FaceIterator self)

        Skip the current wire in the exploration.


        """
        return _HLRBRep.HLRBRep_FaceIterator_SkipWire(self, *args)


    def Wire(self, *args):
        """
        Wire(HLRBRep_FaceIterator self) -> Handle_HLRAlgo_EdgesBlock

        Returns the edges of the current wire.

        :rtype: OCC.wrapper.HLRAlgo.Handle_HLRAlgo_EdgesBlock

        """
        return _HLRBRep.HLRBRep_FaceIterator_Wire(self, *args)


    def Edge(self, *args):
        """
        Edge(HLRBRep_FaceIterator self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _HLRBRep.HLRBRep_FaceIterator_Edge(self, *args)


    def Orientation(self, *args):
        """
        Orientation(HLRBRep_FaceIterator self) -> TopAbs_Orientation

        :rtype: OCC.wrapper.TopAbs.TopAbs_Orientation

        """
        return _HLRBRep.HLRBRep_FaceIterator_Orientation(self, *args)


    def OutLine(self, *args):
        """
        OutLine(HLRBRep_FaceIterator self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _HLRBRep.HLRBRep_FaceIterator_OutLine(self, *args)


    def Internal(self, *args):
        """
        Internal(HLRBRep_FaceIterator self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _HLRBRep.HLRBRep_FaceIterator_Internal(self, *args)


    def Double(self, *args):
        """
        Double(HLRBRep_FaceIterator self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _HLRBRep.HLRBRep_FaceIterator_Double(self, *args)


    def IsoLine(self, *args):
        """
        IsoLine(HLRBRep_FaceIterator self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _HLRBRep.HLRBRep_FaceIterator_IsoLine(self, *args)

    __swig_destroy__ = _HLRBRep.delete_HLRBRep_FaceIterator
HLRBRep_FaceIterator_swigregister = _HLRBRep.HLRBRep_FaceIterator_swigregister
HLRBRep_FaceIterator_swigregister(HLRBRep_FaceIterator)

class HLRBRep_Intersector(object):
    """
    The Intersector  computes 2D  intersections of the
    projections of 3D curves.

    It can also computes the intersection of a 3D line
    and a surface.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(HLRBRep_Intersector self) -> HLRBRep_Intersector

        The Intersector  computes 2D  intersections of the
        projections of 3D curves.

        It can also computes the intersection of a 3D line
        and a surface.
        """
        this = _HLRBRep.new_HLRBRep_Intersector(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def SimulateOnePoint(self, *args):
        """
        SimulateOnePoint(HLRBRep_Intersector self, Standard_Address const A1, Standard_Real const U, Standard_Address const A2, Standard_Real const V)

        Create a single IntersectionPoint (U on A1) (V on A2)
        The point is middle on both curves.

        :type A1: OCC.wrapper.Standard.Standard_Address
        :type U: float
        :type A2: OCC.wrapper.Standard.Standard_Address
        :type V: float

        """
        return _HLRBRep.HLRBRep_Intersector_SimulateOnePoint(self, *args)


    def Load(self, *args):
        """
        Load(HLRBRep_Intersector self, Standard_Address & A)

        :type A: OCC.wrapper.Standard.Standard_Address

        """
        return _HLRBRep.HLRBRep_Intersector_Load(self, *args)


    def Perform(self, *args):
        """
        Perform(HLRBRep_Intersector self, Standard_Address const A1, Standard_Real const da1, Standard_Real const db1)
        Perform(HLRBRep_Intersector self, Standard_Integer const nA, Standard_Address const A1, Standard_Real const da1, Standard_Real const db1, Standard_Integer const nB, Standard_Address const A2, Standard_Real const da2, Standard_Real const db2, Standard_Boolean const NoBound)
        Perform(HLRBRep_Intersector self, gp_Lin L, Standard_Real const P)

        :type L: OCC.wrapper.gp.gp_Lin
        :type P: float

        """
        return _HLRBRep.HLRBRep_Intersector_Perform(self, *args)


    def IsDone(self, *args):
        """
        IsDone(HLRBRep_Intersector self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _HLRBRep.HLRBRep_Intersector_IsDone(self, *args)


    def NbPoints(self, *args):
        """
        NbPoints(HLRBRep_Intersector self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _HLRBRep.HLRBRep_Intersector_NbPoints(self, *args)


    def Point(self, *args):
        """
        :type N: int
        :rtype: OCC.wrapper.IntRes2d.IntRes2d_IntersectionPoint

        """
        res = _HLRBRep.HLRBRep_Intersector_Point(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def CSPoint(self, *args):
        """
        :type N: int
        :rtype: OCC.wrapper.IntCurveSurface.IntCurveSurface_IntersectionPoint

        """
        res = _HLRBRep.HLRBRep_Intersector_CSPoint(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def NbSegments(self, *args):
        """
        NbSegments(HLRBRep_Intersector self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _HLRBRep.HLRBRep_Intersector_NbSegments(self, *args)


    def Segment(self, *args):
        """
        :type N: int
        :rtype: OCC.wrapper.IntRes2d.IntRes2d_IntersectionSegment

        """
        res = _HLRBRep.HLRBRep_Intersector_Segment(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def CSSegment(self, *args):
        """
        :type N: int
        :rtype: OCC.wrapper.IntCurveSurface.IntCurveSurface_IntersectionSegment

        """
        res = _HLRBRep.HLRBRep_Intersector_CSSegment(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Destroy(self, *args):
        """Destroy(HLRBRep_Intersector self)"""
        return _HLRBRep.HLRBRep_Intersector_Destroy(self, *args)

    __swig_destroy__ = _HLRBRep.delete_HLRBRep_Intersector
HLRBRep_Intersector_swigregister = _HLRBRep.HLRBRep_Intersector_swigregister
HLRBRep_Intersector_swigregister(HLRBRep_Intersector)

class HLRBRep_PolyHLRToShape(object):
    """
    A framework for filtering the computation
    results of an HLRBRep_Algo algorithm by extraction.
    From the results calculated by the algorithm on
    a shape, a filter returns the type of edge you
    want to identify. You can choose any of the following types of output:
    -   visible sharp edges
    -   hidden sharp edges
    -   visible smooth edges
    -   hidden smooth edges
    -   visible sewn edges
    -   hidden sewn edges
    -   visible outline edges
    -   hidden outline edges.
    -   visible isoparameters and
    -   hidden isoparameters.
    Sharp edges present a C0 continuity (non G1).
    Smooth edges present a G1 continuity (non G2).
    Sewn edges present a C2 continuity.
    The result is composed of 2D edges in the
    projection plane of the view which the
    algorithm has worked with. These 2D edges
    are not included in the data structure of the visualized shape.
    In order to obtain a complete image, you must
    combine the shapes given by each of the chosen filters.
    The construction of the shape does not call a
    new computation of the algorithm, but only
    reads its internal results.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(HLRBRep_PolyHLRToShape self) -> HLRBRep_PolyHLRToShape

        Constructs a framework for filtering the results
        of the HLRBRep_Algo algorithm, A.
        Use the extraction filters to obtain the results you want for A.


        """
        this = _HLRBRep.new_HLRBRep_PolyHLRToShape(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Update(self, *args):
        """
        Update(HLRBRep_PolyHLRToShape self, Handle_HLRBRep_PolyAlgo A)

        :type A: OCC.wrapper.HLRBRep.Handle_HLRBRep_PolyAlgo

        """
        return _HLRBRep.HLRBRep_PolyHLRToShape_Update(self, *args)


    def Show(self, *args):
        """Show(HLRBRep_PolyHLRToShape self)"""
        return _HLRBRep.HLRBRep_PolyHLRToShape_Show(self, *args)


    def Hide(self, *args):
        """Hide(HLRBRep_PolyHLRToShape self)"""
        return _HLRBRep.HLRBRep_PolyHLRToShape_Hide(self, *args)


    def VCompound(self, *args):
        """
        VCompound(HLRBRep_PolyHLRToShape self) -> TopoDS_Shape
        VCompound(HLRBRep_PolyHLRToShape self, TopoDS_Shape S) -> TopoDS_Shape

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _HLRBRep.HLRBRep_PolyHLRToShape_VCompound(self, *args)


    def Rg1LineVCompound(self, *args):
        """
        Rg1LineVCompound(HLRBRep_PolyHLRToShape self) -> TopoDS_Shape
        Rg1LineVCompound(HLRBRep_PolyHLRToShape self, TopoDS_Shape S) -> TopoDS_Shape

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _HLRBRep.HLRBRep_PolyHLRToShape_Rg1LineVCompound(self, *args)


    def RgNLineVCompound(self, *args):
        """
        RgNLineVCompound(HLRBRep_PolyHLRToShape self) -> TopoDS_Shape
        RgNLineVCompound(HLRBRep_PolyHLRToShape self, TopoDS_Shape S) -> TopoDS_Shape

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _HLRBRep.HLRBRep_PolyHLRToShape_RgNLineVCompound(self, *args)


    def OutLineVCompound(self, *args):
        """
        OutLineVCompound(HLRBRep_PolyHLRToShape self) -> TopoDS_Shape
        OutLineVCompound(HLRBRep_PolyHLRToShape self, TopoDS_Shape S) -> TopoDS_Shape

        Sets the extraction filter for visible outlines.

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _HLRBRep.HLRBRep_PolyHLRToShape_OutLineVCompound(self, *args)


    def HCompound(self, *args):
        """
        HCompound(HLRBRep_PolyHLRToShape self) -> TopoDS_Shape
        HCompound(HLRBRep_PolyHLRToShape self, TopoDS_Shape S) -> TopoDS_Shape

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _HLRBRep.HLRBRep_PolyHLRToShape_HCompound(self, *args)


    def Rg1LineHCompound(self, *args):
        """
        Rg1LineHCompound(HLRBRep_PolyHLRToShape self) -> TopoDS_Shape
        Rg1LineHCompound(HLRBRep_PolyHLRToShape self, TopoDS_Shape S) -> TopoDS_Shape

        Sets the extraction filter for hidden smooth edges.

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _HLRBRep.HLRBRep_PolyHLRToShape_Rg1LineHCompound(self, *args)


    def RgNLineHCompound(self, *args):
        """
        RgNLineHCompound(HLRBRep_PolyHLRToShape self) -> TopoDS_Shape
        RgNLineHCompound(HLRBRep_PolyHLRToShape self, TopoDS_Shape S) -> TopoDS_Shape

        Sets the extraction filter for hidden sewn edges.

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _HLRBRep.HLRBRep_PolyHLRToShape_RgNLineHCompound(self, *args)


    def OutLineHCompound(self, *args):
        """
        OutLineHCompound(HLRBRep_PolyHLRToShape self) -> TopoDS_Shape
        OutLineHCompound(HLRBRep_PolyHLRToShape self, TopoDS_Shape S) -> TopoDS_Shape

        Sets the extraction filter for hidden outlines.
        Hidden outlines occur, for instance, in tori. In
        this case, the inner outlines of the torus seen on its side are hidden.

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _HLRBRep.HLRBRep_PolyHLRToShape_OutLineHCompound(self, *args)

    __swig_destroy__ = _HLRBRep.delete_HLRBRep_PolyHLRToShape
HLRBRep_PolyHLRToShape_swigregister = _HLRBRep.HLRBRep_PolyHLRToShape_swigregister
HLRBRep_PolyHLRToShape_swigregister(HLRBRep_PolyHLRToShape)

class HLRBRep_BiPnt2D(object):
    """Contains the colors of a shape."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(HLRBRep_BiPnt2D self) -> HLRBRep_BiPnt2D
        __init__(HLRBRep_BiPnt2D self, Standard_Real const x1, Standard_Real const y1, Standard_Real const x2, Standard_Real const y2, TopoDS_Shape S, Standard_Boolean const reg1, Standard_Boolean const regn, Standard_Boolean const outl, Standard_Boolean const intl) -> HLRBRep_BiPnt2D
        __init__(HLRBRep_BiPnt2D self, gp_XY thePoint1, gp_XY thePoint2, TopoDS_Shape S, Standard_Boolean const reg1, Standard_Boolean const regn, Standard_Boolean const outl, Standard_Boolean const intl) -> HLRBRep_BiPnt2D

        :type thePoint1: OCC.wrapper.gp.gp_XY
        :type thePoint2: OCC.wrapper.gp.gp_XY
        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :type reg1: bool
        :type regn: bool
        :type outl: bool
        :type intl: bool

        """
        this = _HLRBRep.new_HLRBRep_BiPnt2D(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def P1(self, *args):
        """
        :rtype: OCC.wrapper.gp.gp_Pnt2d

        """
        res = _HLRBRep.HLRBRep_BiPnt2D_P1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def P2(self, *args):
        """
        :rtype: OCC.wrapper.gp.gp_Pnt2d

        """
        res = _HLRBRep.HLRBRep_BiPnt2D_P2(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Shape(self, *args):
        """
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _HLRBRep.HLRBRep_BiPnt2D_Shape(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Rg1Line(self, *args):
        """
        Rg1Line(HLRBRep_BiPnt2D self) -> Standard_Boolean
        Rg1Line(HLRBRep_BiPnt2D self, Standard_Boolean const B)

        :type B: bool

        """
        return _HLRBRep.HLRBRep_BiPnt2D_Rg1Line(self, *args)


    def RgNLine(self, *args):
        """
        RgNLine(HLRBRep_BiPnt2D self) -> Standard_Boolean
        RgNLine(HLRBRep_BiPnt2D self, Standard_Boolean const B)

        :type B: bool

        """
        return _HLRBRep.HLRBRep_BiPnt2D_RgNLine(self, *args)


    def OutLine(self, *args):
        """
        OutLine(HLRBRep_BiPnt2D self) -> Standard_Boolean
        OutLine(HLRBRep_BiPnt2D self, Standard_Boolean const B)

        :type B: bool

        """
        return _HLRBRep.HLRBRep_BiPnt2D_OutLine(self, *args)


    def IntLine(self, *args):
        """
        IntLine(HLRBRep_BiPnt2D self) -> Standard_Boolean
        IntLine(HLRBRep_BiPnt2D self, Standard_Boolean const B)

        :type B: bool

        """
        return _HLRBRep.HLRBRep_BiPnt2D_IntLine(self, *args)

    __swig_destroy__ = _HLRBRep.delete_HLRBRep_BiPnt2D
HLRBRep_BiPnt2D_swigregister = _HLRBRep.HLRBRep_BiPnt2D_swigregister
HLRBRep_BiPnt2D_swigregister(HLRBRep_BiPnt2D)

class HLRBRep_ThePolygon2dOfTheIntPCurvePCurveOfCInter(Intf.Intf_Polygon2d):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(HLRBRep_ThePolygon2dOfTheIntPCurvePCurveOfCInter self, Standard_Address const & Curve, Standard_Integer const NbPnt, IntRes2d_Domain Domain, Standard_Real const Tol) -> HLRBRep_ThePolygon2dOfTheIntPCurvePCurveOfCInter

        Compute a polygon on the domain of the curve.

        :type Curve: OCC.wrapper.Standard.Standard_Address
        :type NbPnt: int
        :type Domain: OCC.wrapper.IntRes2d.IntRes2d_Domain
        :type Tol: float

        """
        this = _HLRBRep.new_HLRBRep_ThePolygon2dOfTheIntPCurvePCurveOfCInter(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def ComputeWithBox(self, *args):
        """
        ComputeWithBox(HLRBRep_ThePolygon2dOfTheIntPCurvePCurveOfCInter self, Standard_Address const & Curve, Bnd_Box2d OtherBox)

        The current polygon is modified if most
        of the  points of the  polygon  are are
        outside  the  box  <OtherBox>.  In this
        situation, bounds are computed to build
        a polygon inside or near the OtherBox.

        :type Curve: OCC.wrapper.Standard.Standard_Address
        :type OtherBox: OCC.wrapper.Bnd.Bnd_Box2d

        """
        return _HLRBRep.HLRBRep_ThePolygon2dOfTheIntPCurvePCurveOfCInter_ComputeWithBox(self, *args)


    def DeflectionOverEstimation(self, *args):
        """
        DeflectionOverEstimation(HLRBRep_ThePolygon2dOfTheIntPCurvePCurveOfCInter self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _HLRBRep.HLRBRep_ThePolygon2dOfTheIntPCurvePCurveOfCInter_DeflectionOverEstimation(self, *args)


    def SetDeflectionOverEstimation(self, *args):
        """
        SetDeflectionOverEstimation(HLRBRep_ThePolygon2dOfTheIntPCurvePCurveOfCInter self, Standard_Real const x)

        :type x: float

        """
        return _HLRBRep.HLRBRep_ThePolygon2dOfTheIntPCurvePCurveOfCInter_SetDeflectionOverEstimation(self, *args)


    def Closed(self, *args):
        """
        Closed(HLRBRep_ThePolygon2dOfTheIntPCurvePCurveOfCInter self, Standard_Boolean const clos)
        Closed(HLRBRep_ThePolygon2dOfTheIntPCurvePCurveOfCInter self) -> Standard_Boolean

        Returns True if the polyline is closed.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _HLRBRep.HLRBRep_ThePolygon2dOfTheIntPCurvePCurveOfCInter_Closed(self, *args)


    def NbSegments(self, *args):
        """
        NbSegments(HLRBRep_ThePolygon2dOfTheIntPCurvePCurveOfCInter self) -> Standard_Integer

        Give the number of Segments in the polyline.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _HLRBRep.HLRBRep_ThePolygon2dOfTheIntPCurvePCurveOfCInter_NbSegments(self, *args)


    def Segment(self, *args):
        """
        Segment(HLRBRep_ThePolygon2dOfTheIntPCurvePCurveOfCInter self, Standard_Integer const theIndex, gp_Pnt2d theBegin, gp_Pnt2d theEnd)

        Returns the points of the segment <Index> in the Polygon.

        :type theIndex: int
        :type theBegin: OCC.wrapper.gp.gp_Pnt2d
        :type theEnd: OCC.wrapper.gp.gp_Pnt2d

        """
        return _HLRBRep.HLRBRep_ThePolygon2dOfTheIntPCurvePCurveOfCInter_Segment(self, *args)


    def InfParameter(self, *args):
        """
        InfParameter(HLRBRep_ThePolygon2dOfTheIntPCurvePCurveOfCInter self) -> Standard_Real

        Returns the parameter (On the curve)
        of the first point of the Polygon

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _HLRBRep.HLRBRep_ThePolygon2dOfTheIntPCurvePCurveOfCInter_InfParameter(self, *args)


    def SupParameter(self, *args):
        """
        SupParameter(HLRBRep_ThePolygon2dOfTheIntPCurvePCurveOfCInter self) -> Standard_Real

        Returns the parameter (On the curve)
        of the last point of the Polygon

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _HLRBRep.HLRBRep_ThePolygon2dOfTheIntPCurvePCurveOfCInter_SupParameter(self, *args)


    def AutoIntersectionIsPossible(self, *args):
        """
        AutoIntersectionIsPossible(HLRBRep_ThePolygon2dOfTheIntPCurvePCurveOfCInter self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _HLRBRep.HLRBRep_ThePolygon2dOfTheIntPCurvePCurveOfCInter_AutoIntersectionIsPossible(self, *args)


    def ApproxParamOnCurve(self, *args):
        """
        ApproxParamOnCurve(HLRBRep_ThePolygon2dOfTheIntPCurvePCurveOfCInter self, Standard_Integer const Index, Standard_Real const ParamOnLine) -> Standard_Real

        Give an approximation of the parameter on the curve
        according to the discretization of the Curve.

        :type Index: int
        :type ParamOnLine: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _HLRBRep.HLRBRep_ThePolygon2dOfTheIntPCurvePCurveOfCInter_ApproxParamOnCurve(self, *args)


    def CalculRegion(self, *args):
        """
        CalculRegion(HLRBRep_ThePolygon2dOfTheIntPCurvePCurveOfCInter self, Standard_Real const x, Standard_Real const y, Standard_Real const x1, Standard_Real const x2, Standard_Real const y1, Standard_Real const y2) -> Standard_Integer

        :type x: float
        :type y: float
        :type x1: float
        :type x2: float
        :type y1: float
        :type y2: float
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _HLRBRep.HLRBRep_ThePolygon2dOfTheIntPCurvePCurveOfCInter_CalculRegion(self, *args)


    def Dump(self, *args):
        """Dump(HLRBRep_ThePolygon2dOfTheIntPCurvePCurveOfCInter self)"""
        return _HLRBRep.HLRBRep_ThePolygon2dOfTheIntPCurvePCurveOfCInter_Dump(self, *args)

    __swig_destroy__ = _HLRBRep.delete_HLRBRep_ThePolygon2dOfTheIntPCurvePCurveOfCInter
HLRBRep_ThePolygon2dOfTheIntPCurvePCurveOfCInter_swigregister = _HLRBRep.HLRBRep_ThePolygon2dOfTheIntPCurvePCurveOfCInter_swigregister
HLRBRep_ThePolygon2dOfTheIntPCurvePCurveOfCInter_swigregister(HLRBRep_ThePolygon2dOfTheIntPCurvePCurveOfCInter)

class HLRBRep_Surface(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(HLRBRep_Surface self) -> HLRBRep_Surface

        Creates an undefined surface with no face loaded.


        """
        this = _HLRBRep.new_HLRBRep_Surface(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Projector(self, *args):
        """
        Projector(HLRBRep_Surface self, HLRAlgo_Projector Proj)

        :type Proj: OCC.wrapper.HLRAlgo.HLRAlgo_Projector

        """
        return _HLRBRep.HLRBRep_Surface_Projector(self, *args)


    def Surface(self, *args):
        """
        Surface(HLRBRep_Surface self) -> BRepAdaptor_Surface
        Surface(HLRBRep_Surface self, TopoDS_Face F)

        Sets the 3D Surface to be projected.

        :type F: OCC.wrapper.TopoDS.TopoDS_Face

        """
        return _HLRBRep.HLRBRep_Surface_Surface(self, *args)


    def IsSide(self, *args):
        """
        IsSide(HLRBRep_Surface self, Standard_Real const tolf, Standard_Real const toler) -> Standard_Boolean

        returns true if it is a side face

        :type tolf: float
        :type toler: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _HLRBRep.HLRBRep_Surface_IsSide(self, *args)


    def IsAbove(self, *args):
        """
        IsAbove(HLRBRep_Surface self, Standard_Boolean const back, HLRBRep_Curve A, Standard_Real const tolC) -> Standard_Boolean

        :type back: bool
        :type A: OCC.wrapper.HLRBRep.HLRBRep_Curve
        :type tolC: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _HLRBRep.HLRBRep_Surface_IsAbove(self, *args)


    def FirstUParameter(self, *args):
        """
        FirstUParameter(HLRBRep_Surface self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _HLRBRep.HLRBRep_Surface_FirstUParameter(self, *args)


    def LastUParameter(self, *args):
        """
        LastUParameter(HLRBRep_Surface self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _HLRBRep.HLRBRep_Surface_LastUParameter(self, *args)


    def FirstVParameter(self, *args):
        """
        FirstVParameter(HLRBRep_Surface self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _HLRBRep.HLRBRep_Surface_FirstVParameter(self, *args)


    def LastVParameter(self, *args):
        """
        LastVParameter(HLRBRep_Surface self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _HLRBRep.HLRBRep_Surface_LastVParameter(self, *args)


    def UContinuity(self, *args):
        """
        UContinuity(HLRBRep_Surface self) -> GeomAbs_Shape

        :rtype: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _HLRBRep.HLRBRep_Surface_UContinuity(self, *args)


    def VContinuity(self, *args):
        """
        VContinuity(HLRBRep_Surface self) -> GeomAbs_Shape

        :rtype: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _HLRBRep.HLRBRep_Surface_VContinuity(self, *args)


    def NbUIntervals(self, *args):
        """
        NbUIntervals(HLRBRep_Surface self, GeomAbs_Shape const S) -> Standard_Integer

        If necessary, breaks the surface in U intervals of
        continuity    <S>.  And   returns  the  number  of
        intervals.

        :type S: OCC.wrapper.GeomAbs.GeomAbs_Shape
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _HLRBRep.HLRBRep_Surface_NbUIntervals(self, *args)


    def NbVIntervals(self, *args):
        """
        NbVIntervals(HLRBRep_Surface self, GeomAbs_Shape const S) -> Standard_Integer

        If necessary, breaks the surface in V intervals of
        continuity    <S>.  And   returns  the  number  of
        intervals.

        :type S: OCC.wrapper.GeomAbs.GeomAbs_Shape
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _HLRBRep.HLRBRep_Surface_NbVIntervals(self, *args)


    def IsUClosed(self, *args):
        """
        IsUClosed(HLRBRep_Surface self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _HLRBRep.HLRBRep_Surface_IsUClosed(self, *args)


    def IsVClosed(self, *args):
        """
        IsVClosed(HLRBRep_Surface self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _HLRBRep.HLRBRep_Surface_IsVClosed(self, *args)


    def IsUPeriodic(self, *args):
        """
        IsUPeriodic(HLRBRep_Surface self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _HLRBRep.HLRBRep_Surface_IsUPeriodic(self, *args)


    def UPeriod(self, *args):
        """
        UPeriod(HLRBRep_Surface self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _HLRBRep.HLRBRep_Surface_UPeriod(self, *args)


    def IsVPeriodic(self, *args):
        """
        IsVPeriodic(HLRBRep_Surface self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _HLRBRep.HLRBRep_Surface_IsVPeriodic(self, *args)


    def VPeriod(self, *args):
        """
        VPeriod(HLRBRep_Surface self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _HLRBRep.HLRBRep_Surface_VPeriod(self, *args)


    def Value(self, *args):
        """
        Value(HLRBRep_Surface self, Standard_Real const U, Standard_Real const V) -> gp_Pnt

        Computes the point of parameters U,V on the surface.

        :type U: float
        :type V: float
        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _HLRBRep.HLRBRep_Surface_Value(self, *args)


    def D0(self, *args):
        """
        D0(HLRBRep_Surface self, Standard_Real const U, Standard_Real const V, gp_Pnt P)

        Computes the point of parameters U,V on the surface.

        :type U: float
        :type V: float
        :type P: OCC.wrapper.gp.gp_Pnt

        """
        return _HLRBRep.HLRBRep_Surface_D0(self, *args)


    def D1(self, *args):
        """
        D1(HLRBRep_Surface self, Standard_Real const U, Standard_Real const V, gp_Pnt P, gp_Vec D1U, gp_Vec D1V)

        Computes the point  and the first derivatives on
        the surface.
        Raised   if  the continuity  of   the  current
        intervals is not C1.

        :type U: float
        :type V: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type D1U: OCC.wrapper.gp.gp_Vec
        :type D1V: OCC.wrapper.gp.gp_Vec

        """
        return _HLRBRep.HLRBRep_Surface_D1(self, *args)


    def D2(self, *args):
        """
        D2(HLRBRep_Surface self, Standard_Real const U, Standard_Real const V, gp_Pnt P, gp_Vec D1U, gp_Vec D1V, gp_Vec D2U, gp_Vec D2V, gp_Vec D2UV)

        Computes   the point,  the  first  and  second
        derivatives on the surface.
        Raised  if   the   continuity   of the current
        intervals is not C2.

        :type U: float
        :type V: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type D1U: OCC.wrapper.gp.gp_Vec
        :type D1V: OCC.wrapper.gp.gp_Vec
        :type D2U: OCC.wrapper.gp.gp_Vec
        :type D2V: OCC.wrapper.gp.gp_Vec
        :type D2UV: OCC.wrapper.gp.gp_Vec

        """
        return _HLRBRep.HLRBRep_Surface_D2(self, *args)


    def D3(self, *args):
        """
        D3(HLRBRep_Surface self, Standard_Real const U, Standard_Real const V, gp_Pnt P, gp_Vec D1U, gp_Vec D1V, gp_Vec D2U, gp_Vec D2V, gp_Vec D2UV, gp_Vec D3U, gp_Vec D3V, gp_Vec D3UUV, gp_Vec D3UVV)

        Computes the point,  the first, second and third
        derivatives on the surface.
        Raised  if   the   continuity   of the current
        intervals is not C3.

        :type U: float
        :type V: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type D1U: OCC.wrapper.gp.gp_Vec
        :type D1V: OCC.wrapper.gp.gp_Vec
        :type D2U: OCC.wrapper.gp.gp_Vec
        :type D2V: OCC.wrapper.gp.gp_Vec
        :type D2UV: OCC.wrapper.gp.gp_Vec
        :type D3U: OCC.wrapper.gp.gp_Vec
        :type D3V: OCC.wrapper.gp.gp_Vec
        :type D3UUV: OCC.wrapper.gp.gp_Vec
        :type D3UVV: OCC.wrapper.gp.gp_Vec

        """
        return _HLRBRep.HLRBRep_Surface_D3(self, *args)


    def DN(self, *args):
        """
        DN(HLRBRep_Surface self, Standard_Real const U, Standard_Real const V, Standard_Integer const Nu, Standard_Integer const Nv) -> gp_Vec

        Computes  the  derivative of order   Nu  in the
        direction U and Nv in the  direction  V  at the point P(U,
        V).
        Raised if the current U  interval is not not CNu
        and the current V interval is not CNv.
        Raised if Nu + Nv < 1 or Nu < 0 or Nv < 0.

        :type U: float
        :type V: float
        :type Nu: int
        :type Nv: int
        :rtype: OCC.wrapper.gp.gp_Vec

        """
        return _HLRBRep.HLRBRep_Surface_DN(self, *args)


    def GetType(self, *args):
        """
        GetType(HLRBRep_Surface self) -> GeomAbs_SurfaceType

        Returns the type of the surface : Plane, Cylinder,
        Cone,      Sphere,        Torus,    BezierSurface,
        BSplineSurface,               SurfaceOfRevolution,
        SurfaceOfExtrusion, OtherSurface

        :rtype: OCC.wrapper.GeomAbs.GeomAbs_SurfaceType

        """
        return _HLRBRep.HLRBRep_Surface_GetType(self, *args)


    def Plane(self, *args):
        """
        Plane(HLRBRep_Surface self) -> gp_Pln

        :rtype: OCC.wrapper.gp.gp_Pln

        """
        return _HLRBRep.HLRBRep_Surface_Plane(self, *args)


    def Cylinder(self, *args):
        """
        Cylinder(HLRBRep_Surface self) -> gp_Cylinder

        :rtype: OCC.wrapper.gp.gp_Cylinder

        """
        return _HLRBRep.HLRBRep_Surface_Cylinder(self, *args)


    def Cone(self, *args):
        """
        Cone(HLRBRep_Surface self) -> gp_Cone

        :rtype: OCC.wrapper.gp.gp_Cone

        """
        return _HLRBRep.HLRBRep_Surface_Cone(self, *args)


    def Sphere(self, *args):
        """
        Sphere(HLRBRep_Surface self) -> gp_Sphere

        :rtype: OCC.wrapper.gp.gp_Sphere

        """
        return _HLRBRep.HLRBRep_Surface_Sphere(self, *args)


    def Torus(self, *args):
        """
        Torus(HLRBRep_Surface self) -> gp_Torus

        :rtype: OCC.wrapper.gp.gp_Torus

        """
        return _HLRBRep.HLRBRep_Surface_Torus(self, *args)


    def UDegree(self, *args):
        """
        UDegree(HLRBRep_Surface self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _HLRBRep.HLRBRep_Surface_UDegree(self, *args)


    def NbUPoles(self, *args):
        """
        NbUPoles(HLRBRep_Surface self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _HLRBRep.HLRBRep_Surface_NbUPoles(self, *args)


    def VDegree(self, *args):
        """
        VDegree(HLRBRep_Surface self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _HLRBRep.HLRBRep_Surface_VDegree(self, *args)


    def NbVPoles(self, *args):
        """
        NbVPoles(HLRBRep_Surface self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _HLRBRep.HLRBRep_Surface_NbVPoles(self, *args)


    def NbUKnots(self, *args):
        """
        NbUKnots(HLRBRep_Surface self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _HLRBRep.HLRBRep_Surface_NbUKnots(self, *args)


    def NbVKnots(self, *args):
        """
        NbVKnots(HLRBRep_Surface self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _HLRBRep.HLRBRep_Surface_NbVKnots(self, *args)


    def Axis(self, *args):
        """
        Axis(HLRBRep_Surface self) -> gp_Ax1

        :rtype: OCC.wrapper.gp.gp_Ax1

        """
        return _HLRBRep.HLRBRep_Surface_Axis(self, *args)

    __swig_destroy__ = _HLRBRep.delete_HLRBRep_Surface
HLRBRep_Surface_swigregister = _HLRBRep.HLRBRep_Surface_swigregister
HLRBRep_Surface_swigregister(HLRBRep_Surface)

class NCollection_List_HLRBRep_BiPoint_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _HLRBRep.new_NCollection_List_HLRBRep_BiPoint_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _HLRBRep.delete_NCollection_List_HLRBRep_BiPoint_IteratorHelper

    def __next__(self):
        return _HLRBRep.NCollection_List_HLRBRep_BiPoint_IteratorHelper___next__(self)
NCollection_List_HLRBRep_BiPoint_IteratorHelper_swigregister = _HLRBRep.NCollection_List_HLRBRep_BiPoint_IteratorHelper_swigregister
NCollection_List_HLRBRep_BiPoint_IteratorHelper_swigregister(NCollection_List_HLRBRep_BiPoint_IteratorHelper)


try:
	HLRBRep_ListOfBPoint = NCollection_List_HLRBRep_BiPoint
except NameError:
	pass # does not exist, probably ignored

class HLRBRep_IntConicCurveOfCInter(IntRes2d.IntRes2d_Intersection):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(HLRBRep_IntConicCurveOfCInter self) -> HLRBRep_IntConicCurveOfCInter
        __init__(HLRBRep_IntConicCurveOfCInter self, gp_Lin2d L, IntRes2d_Domain D1, Standard_Address const & PCurve, IntRes2d_Domain D2, Standard_Real const TolConf, Standard_Real const Tol) -> HLRBRep_IntConicCurveOfCInter
        __init__(HLRBRep_IntConicCurveOfCInter self, gp_Circ2d C, IntRes2d_Domain D1, Standard_Address const & PCurve, IntRes2d_Domain D2, Standard_Real const TolConf, Standard_Real const Tol) -> HLRBRep_IntConicCurveOfCInter
        __init__(HLRBRep_IntConicCurveOfCInter self, gp_Elips2d E, IntRes2d_Domain D1, Standard_Address const & PCurve, IntRes2d_Domain D2, Standard_Real const TolConf, Standard_Real const Tol) -> HLRBRep_IntConicCurveOfCInter
        __init__(HLRBRep_IntConicCurveOfCInter self, gp_Parab2d Prb, IntRes2d_Domain D1, Standard_Address const & PCurve, IntRes2d_Domain D2, Standard_Real const TolConf, Standard_Real const Tol) -> HLRBRep_IntConicCurveOfCInter
        __init__(HLRBRep_IntConicCurveOfCInter self, gp_Hypr2d H, IntRes2d_Domain D1, Standard_Address const & PCurve, IntRes2d_Domain D2, Standard_Real const TolConf, Standard_Real const Tol) -> HLRBRep_IntConicCurveOfCInter

        Intersection between the main branch of an hyperbola
        and a parametric curve.

        :type H: OCC.wrapper.gp.gp_Hypr2d
        :type D1: OCC.wrapper.IntRes2d.IntRes2d_Domain
        :type PCurve: OCC.wrapper.Standard.Standard_Address
        :type D2: OCC.wrapper.IntRes2d.IntRes2d_Domain
        :type TolConf: float
        :type Tol: float

        """
        this = _HLRBRep.new_HLRBRep_IntConicCurveOfCInter(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Perform(self, *args):
        """
        Perform(HLRBRep_IntConicCurveOfCInter self, gp_Lin2d L, IntRes2d_Domain D1, Standard_Address const & PCurve, IntRes2d_Domain D2, Standard_Real const TolConf, Standard_Real const Tol)
        Perform(HLRBRep_IntConicCurveOfCInter self, gp_Circ2d C, IntRes2d_Domain D1, Standard_Address const & PCurve, IntRes2d_Domain D2, Standard_Real const TolConf, Standard_Real const Tol)
        Perform(HLRBRep_IntConicCurveOfCInter self, gp_Elips2d E, IntRes2d_Domain D1, Standard_Address const & PCurve, IntRes2d_Domain D2, Standard_Real const TolConf, Standard_Real const Tol)
        Perform(HLRBRep_IntConicCurveOfCInter self, gp_Parab2d Prb, IntRes2d_Domain D1, Standard_Address const & PCurve, IntRes2d_Domain D2, Standard_Real const TolConf, Standard_Real const Tol)
        Perform(HLRBRep_IntConicCurveOfCInter self, gp_Hypr2d H, IntRes2d_Domain D1, Standard_Address const & PCurve, IntRes2d_Domain D2, Standard_Real const TolConf, Standard_Real const Tol)

        Intersection between the main branch of an hyperbola
        and a parametric curve.

        :type H: OCC.wrapper.gp.gp_Hypr2d
        :type D1: OCC.wrapper.IntRes2d.IntRes2d_Domain
        :type PCurve: OCC.wrapper.Standard.Standard_Address
        :type D2: OCC.wrapper.IntRes2d.IntRes2d_Domain
        :type TolConf: float
        :type Tol: float

        """
        return _HLRBRep.HLRBRep_IntConicCurveOfCInter_Perform(self, *args)

    __swig_destroy__ = _HLRBRep.delete_HLRBRep_IntConicCurveOfCInter
HLRBRep_IntConicCurveOfCInter_swigregister = _HLRBRep.HLRBRep_IntConicCurveOfCInter_swigregister
HLRBRep_IntConicCurveOfCInter_swigregister(HLRBRep_IntConicCurveOfCInter)

class HLRBRep_(object):
    """
    Hidden Lines Removal
    algorithms on the BRep DataStructure.

    The class PolyAlgo  is used to remove Hidden lines
    on Shapes with Triangulations.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def MakeEdge(*args):
        """
        MakeEdge(HLRBRep_Curve ec, Standard_Real const U1, Standard_Real const U2) -> TopoDS_Edge

        :type ec: OCC.wrapper.HLRBRep.HLRBRep_Curve
        :type U1: float
        :type U2: float
        :rtype: OCC.wrapper.TopoDS.TopoDS_Edge

        """
        return _HLRBRep.HLRBRep__MakeEdge(*args)

    MakeEdge = staticmethod(MakeEdge)

    def MakeEdge3d(*args):
        """
        MakeEdge3d(HLRBRep_Curve ec, Standard_Real const U1, Standard_Real const U2) -> TopoDS_Edge

        :type ec: OCC.wrapper.HLRBRep.HLRBRep_Curve
        :type U1: float
        :type U2: float
        :rtype: OCC.wrapper.TopoDS.TopoDS_Edge

        """
        return _HLRBRep.HLRBRep__MakeEdge3d(*args)

    MakeEdge3d = staticmethod(MakeEdge3d)

    def PolyHLRAngleAndDeflection(*args):
        """
        PolyHLRAngleAndDeflection(Standard_Real const InAngl)

        :type InAngl: float
        :type OutAngl: float
        :type OutDefl: float

        """
        return _HLRBRep.HLRBRep__PolyHLRAngleAndDeflection(*args)

    PolyHLRAngleAndDeflection = staticmethod(PolyHLRAngleAndDeflection)

    def __init__(self):
        """
        Hidden Lines Removal
        algorithms on the BRep DataStructure.

        The class PolyAlgo  is used to remove Hidden lines
        on Shapes with Triangulations.
        """
        this = _HLRBRep.new_HLRBRep_()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _HLRBRep.delete_HLRBRep_
HLRBRep__swigregister = _HLRBRep.HLRBRep__swigregister
HLRBRep__swigregister(HLRBRep_)

def HLRBRep__MakeEdge(*args):
    """
    HLRBRep__MakeEdge(HLRBRep_Curve ec, Standard_Real const U1, Standard_Real const U2) -> TopoDS_Edge

    :type ec: OCC.wrapper.HLRBRep.HLRBRep_Curve
    :type U1: float
    :type U2: float
    :rtype: OCC.wrapper.TopoDS.TopoDS_Edge

    """
    return _HLRBRep.HLRBRep__MakeEdge(*args)

def HLRBRep__MakeEdge3d(*args):
    """
    HLRBRep__MakeEdge3d(HLRBRep_Curve ec, Standard_Real const U1, Standard_Real const U2) -> TopoDS_Edge

    :type ec: OCC.wrapper.HLRBRep.HLRBRep_Curve
    :type U1: float
    :type U2: float
    :rtype: OCC.wrapper.TopoDS.TopoDS_Edge

    """
    return _HLRBRep.HLRBRep__MakeEdge3d(*args)

def HLRBRep__PolyHLRAngleAndDeflection(*args):
    """
    HLRBRep__PolyHLRAngleAndDeflection(Standard_Real const InAngl)

    :type InAngl: float
    :type OutAngl: float
    :type OutDefl: float

    """
    return _HLRBRep.HLRBRep__PolyHLRAngleAndDeflection(*args)

class HLRBRep_FaceData(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """__init__(HLRBRep_FaceData self) -> HLRBRep_FaceData"""
        this = _HLRBRep.new_HLRBRep_FaceData(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Set(self, *args):
        """
        Set(HLRBRep_FaceData self, TopoDS_Face FG, TopAbs_Orientation const Or, Standard_Boolean const Cl, Standard_Integer const NW)

        <Or> is the orientation of the face.  <Cl> is true
        if the face  belongs to a  closed  volume. <NW> is
        the number of wires ( or block  of  edges ) of the
        face.

        :type FG: OCC.wrapper.TopoDS.TopoDS_Face
        :type Or: OCC.wrapper.TopAbs.TopAbs_Orientation
        :type Cl: bool
        :type NW: int

        """
        return _HLRBRep.HLRBRep_FaceData_Set(self, *args)


    def SetWire(self, *args):
        """
        SetWire(HLRBRep_FaceData self, Standard_Integer const WI, Standard_Integer const NE)

        Set <NE> the number  of  edges of the wire  number
        <WI>.

        :type WI: int
        :type NE: int

        """
        return _HLRBRep.HLRBRep_FaceData_SetWire(self, *args)


    def SetWEdge(self, *args):
        """
        SetWEdge(HLRBRep_FaceData self, Standard_Integer const WI, Standard_Integer const EWI, Standard_Integer const EI, TopAbs_Orientation const Or, Standard_Boolean const OutL, Standard_Boolean const Inte, Standard_Boolean const Dble, Standard_Boolean const IsoL)

        Set the edge number <EWI> of the  wire <WI>.

        :type WI: int
        :type EWI: int
        :type EI: int
        :type Or: OCC.wrapper.TopAbs.TopAbs_Orientation
        :type OutL: bool
        :type Inte: bool
        :type Dble: bool
        :type IsoL: bool

        """
        return _HLRBRep.HLRBRep_FaceData_SetWEdge(self, *args)


    def Selected(self, *args):
        """
        Selected(HLRBRep_FaceData self) -> Standard_Boolean
        Selected(HLRBRep_FaceData self, Standard_Boolean const B)

        :type B: bool

        """
        return _HLRBRep.HLRBRep_FaceData_Selected(self, *args)


    def Back(self, *args):
        """
        Back(HLRBRep_FaceData self) -> Standard_Boolean
        Back(HLRBRep_FaceData self, Standard_Boolean const B)

        :type B: bool

        """
        return _HLRBRep.HLRBRep_FaceData_Back(self, *args)


    def Side(self, *args):
        """
        Side(HLRBRep_FaceData self) -> Standard_Boolean
        Side(HLRBRep_FaceData self, Standard_Boolean const B)

        :type B: bool

        """
        return _HLRBRep.HLRBRep_FaceData_Side(self, *args)


    def Closed(self, *args):
        """
        Closed(HLRBRep_FaceData self) -> Standard_Boolean
        Closed(HLRBRep_FaceData self, Standard_Boolean const B)

        :type B: bool

        """
        return _HLRBRep.HLRBRep_FaceData_Closed(self, *args)


    def Hiding(self, *args):
        """
        Hiding(HLRBRep_FaceData self) -> Standard_Boolean
        Hiding(HLRBRep_FaceData self, Standard_Boolean const B)

        :type B: bool

        """
        return _HLRBRep.HLRBRep_FaceData_Hiding(self, *args)


    def Simple(self, *args):
        """
        Simple(HLRBRep_FaceData self) -> Standard_Boolean
        Simple(HLRBRep_FaceData self, Standard_Boolean const B)

        :type B: bool

        """
        return _HLRBRep.HLRBRep_FaceData_Simple(self, *args)


    def Cut(self, *args):
        """
        Cut(HLRBRep_FaceData self) -> Standard_Boolean
        Cut(HLRBRep_FaceData self, Standard_Boolean const B)

        :type B: bool

        """
        return _HLRBRep.HLRBRep_FaceData_Cut(self, *args)


    def WithOutL(self, *args):
        """
        WithOutL(HLRBRep_FaceData self) -> Standard_Boolean
        WithOutL(HLRBRep_FaceData self, Standard_Boolean const B)

        :type B: bool

        """
        return _HLRBRep.HLRBRep_FaceData_WithOutL(self, *args)


    def Plane(self, *args):
        """
        Plane(HLRBRep_FaceData self) -> Standard_Boolean
        Plane(HLRBRep_FaceData self, Standard_Boolean const B)

        :type B: bool

        """
        return _HLRBRep.HLRBRep_FaceData_Plane(self, *args)


    def Cylinder(self, *args):
        """
        Cylinder(HLRBRep_FaceData self) -> Standard_Boolean
        Cylinder(HLRBRep_FaceData self, Standard_Boolean const B)

        :type B: bool

        """
        return _HLRBRep.HLRBRep_FaceData_Cylinder(self, *args)


    def Cone(self, *args):
        """
        Cone(HLRBRep_FaceData self) -> Standard_Boolean
        Cone(HLRBRep_FaceData self, Standard_Boolean const B)

        :type B: bool

        """
        return _HLRBRep.HLRBRep_FaceData_Cone(self, *args)


    def Sphere(self, *args):
        """
        Sphere(HLRBRep_FaceData self) -> Standard_Boolean
        Sphere(HLRBRep_FaceData self, Standard_Boolean const B)

        :type B: bool

        """
        return _HLRBRep.HLRBRep_FaceData_Sphere(self, *args)


    def Torus(self, *args):
        """
        Torus(HLRBRep_FaceData self) -> Standard_Boolean
        Torus(HLRBRep_FaceData self, Standard_Boolean const B)

        :type B: bool

        """
        return _HLRBRep.HLRBRep_FaceData_Torus(self, *args)


    def Size(self, *args):
        """
        Size(HLRBRep_FaceData self) -> Standard_Real
        Size(HLRBRep_FaceData self, Standard_Real const S)

        :type S: float

        """
        return _HLRBRep.HLRBRep_FaceData_Size(self, *args)


    def Orientation(self, *args):
        """
        Orientation(HLRBRep_FaceData self) -> TopAbs_Orientation
        Orientation(HLRBRep_FaceData self, TopAbs_Orientation const O)

        :type O: OCC.wrapper.TopAbs.TopAbs_Orientation

        """
        return _HLRBRep.HLRBRep_FaceData_Orientation(self, *args)


    def Wires(self, *args):
        """
        Wires(HLRBRep_FaceData self) -> Handle_HLRAlgo_WiresBlock

        :rtype: OCC.wrapper.HLRAlgo.Handle_HLRAlgo_WiresBlock

        """
        return _HLRBRep.HLRBRep_FaceData_Wires(self, *args)


    def Geometry(self, *args):
        """
        Geometry(HLRBRep_FaceData self) -> HLRBRep_Surface

        :rtype: OCC.wrapper.HLRBRep.HLRBRep_Surface

        """
        return _HLRBRep.HLRBRep_FaceData_Geometry(self, *args)


    def Tolerance(self, *args):
        """
        Tolerance(HLRBRep_FaceData self) -> Standard_ShortReal

        :rtype: OCC.wrapper.Standard.Standard_ShortReal

        """
        return _HLRBRep.HLRBRep_FaceData_Tolerance(self, *args)

    __swig_destroy__ = _HLRBRep.delete_HLRBRep_FaceData
HLRBRep_FaceData_swigregister = _HLRBRep.HLRBRep_FaceData_swigregister
HLRBRep_FaceData_swigregister(HLRBRep_FaceData)

class HLRBRep_EdgeInterferenceTool(object):
    """
    Implements the  methods required  to  instantiates
    the EdgeInterferenceList from HLRAlgo.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(HLRBRep_EdgeInterferenceTool self, Handle_HLRBRep_Data DS) -> HLRBRep_EdgeInterferenceTool

        :type DS: OCC.wrapper.HLRBRep.Handle_HLRBRep_Data

        """
        this = _HLRBRep.new_HLRBRep_EdgeInterferenceTool(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def LoadEdge(self, *args):
        """LoadEdge(HLRBRep_EdgeInterferenceTool self)"""
        return _HLRBRep.HLRBRep_EdgeInterferenceTool_LoadEdge(self, *args)


    def InitVertices(self, *args):
        """InitVertices(HLRBRep_EdgeInterferenceTool self)"""
        return _HLRBRep.HLRBRep_EdgeInterferenceTool_InitVertices(self, *args)


    def MoreVertices(self, *args):
        """
        MoreVertices(HLRBRep_EdgeInterferenceTool self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _HLRBRep.HLRBRep_EdgeInterferenceTool_MoreVertices(self, *args)


    def NextVertex(self, *args):
        """NextVertex(HLRBRep_EdgeInterferenceTool self)"""
        return _HLRBRep.HLRBRep_EdgeInterferenceTool_NextVertex(self, *args)


    def CurrentVertex(self, *args):
        """
        :rtype: OCC.wrapper.HLRAlgo.HLRAlgo_Intersection

        """
        res = _HLRBRep.HLRBRep_EdgeInterferenceTool_CurrentVertex(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def CurrentOrientation(self, *args):
        """
        CurrentOrientation(HLRBRep_EdgeInterferenceTool self) -> TopAbs_Orientation

        :rtype: OCC.wrapper.TopAbs.TopAbs_Orientation

        """
        return _HLRBRep.HLRBRep_EdgeInterferenceTool_CurrentOrientation(self, *args)


    def CurrentParameter(self, *args):
        """
        CurrentParameter(HLRBRep_EdgeInterferenceTool self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _HLRBRep.HLRBRep_EdgeInterferenceTool_CurrentParameter(self, *args)


    def IsPeriodic(self, *args):
        """
        IsPeriodic(HLRBRep_EdgeInterferenceTool self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _HLRBRep.HLRBRep_EdgeInterferenceTool_IsPeriodic(self, *args)


    def EdgeGeometry(self, *args):
        """
        EdgeGeometry(HLRBRep_EdgeInterferenceTool self, Standard_Real const Param, gp_Dir Tgt, gp_Dir Nrm)

        Returns local geometric description of the Edge at
        parameter   <Para>.  See  method  Reset  of  class
        EdgeFaceTransition from TopCnx for other arguments.

        :type Param: float
        :type Tgt: OCC.wrapper.gp.gp_Dir
        :type Nrm: OCC.wrapper.gp.gp_Dir
        :type Curv: float

        """
        return _HLRBRep.HLRBRep_EdgeInterferenceTool_EdgeGeometry(self, *args)


    def ParameterOfInterference(self, *args):
        """
        ParameterOfInterference(HLRBRep_EdgeInterferenceTool self, HLRAlgo_Interference I) -> Standard_Real

        :type I: OCC.wrapper.HLRAlgo.HLRAlgo_Interference
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _HLRBRep.HLRBRep_EdgeInterferenceTool_ParameterOfInterference(self, *args)


    def SameInterferences(self, *args):
        """
        SameInterferences(HLRBRep_EdgeInterferenceTool self, HLRAlgo_Interference I1, HLRAlgo_Interference I2) -> Standard_Boolean

        True if   the  two interferences are on   the same
        geometric locus.

        :type I1: OCC.wrapper.HLRAlgo.HLRAlgo_Interference
        :type I2: OCC.wrapper.HLRAlgo.HLRAlgo_Interference
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _HLRBRep.HLRBRep_EdgeInterferenceTool_SameInterferences(self, *args)


    def SameVertexAndInterference(self, *args):
        """
        SameVertexAndInterference(HLRBRep_EdgeInterferenceTool self, HLRAlgo_Interference I) -> Standard_Boolean

        True if the  Interference and the  current  Vertex
        are on the same geometric locus.

        :type I: OCC.wrapper.HLRAlgo.HLRAlgo_Interference
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _HLRBRep.HLRBRep_EdgeInterferenceTool_SameVertexAndInterference(self, *args)


    def InterferenceBoundaryGeometry(self, *args):
        """
        InterferenceBoundaryGeometry(HLRBRep_EdgeInterferenceTool self, HLRAlgo_Interference I, gp_Dir Tang, gp_Dir Norm)

        Returns   the  geometry of  the   boundary  at the
        interference  <I>.  See the AddInterference method
        of the class  EdgeFaceTransition  from  TopCnx for
        the other arguments.

        :type I: OCC.wrapper.HLRAlgo.HLRAlgo_Interference
        :type Tang: OCC.wrapper.gp.gp_Dir
        :type Norm: OCC.wrapper.gp.gp_Dir
        :type Curv: float

        """
        return _HLRBRep.HLRBRep_EdgeInterferenceTool_InterferenceBoundaryGeometry(self, *args)

    __swig_destroy__ = _HLRBRep.delete_HLRBRep_EdgeInterferenceTool
HLRBRep_EdgeInterferenceTool_swigregister = _HLRBRep.HLRBRep_EdgeInterferenceTool_swigregister
HLRBRep_EdgeInterferenceTool_swigregister(HLRBRep_EdgeInterferenceTool)

class Handle_HLRBRep_Data(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_HLRBRep_Data self)

        Nullify the handle


        """
        return _HLRBRep.Handle_HLRBRep_Data_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_HLRBRep_Data self) -> bool

        Check for being null

        :rtype: bool

        """
        return _HLRBRep.Handle_HLRBRep_Data_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_HLRBRep_Data self, HLRBRep_Data thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _HLRBRep.Handle_HLRBRep_Data_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_HLRBRep_Data self, Handle_HLRBRep_Data theHandle) -> Handle_HLRBRep_Data
        assign(Handle_HLRBRep_Data self, HLRBRep_Data thePtr) -> Handle_HLRBRep_Data
        assign(Handle_HLRBRep_Data self, Handle_HLRBRep_Data theHandle) -> Handle_HLRBRep_Data

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _HLRBRep.Handle_HLRBRep_Data_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_HLRBRep_Data self) -> HLRBRep_Data

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _HLRBRep.Handle_HLRBRep_Data_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_HLRBRep_Data self) -> HLRBRep_Data

        Member access operator (note non-const)

        :rtype: T *

        """
        return _HLRBRep.Handle_HLRBRep_Data___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_HLRBRep_Data self) -> HLRBRep_Data

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _HLRBRep.Handle_HLRBRep_Data___ref__(self, *args)


    def __hash__(self):
        return _HLRBRep.Handle_HLRBRep_Data___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _HLRBRep.Handle_HLRBRep_Data___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _HLRBRep.new_Handle_HLRBRep_Data(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_HLRBRep.Handle_HLRBRep_Data_DownCast)
    __swig_destroy__ = _HLRBRep.delete_Handle_HLRBRep_Data

    def Write(self, *args):
        """
        Write(Handle_HLRBRep_Data self, Handle_HLRBRep_Data DS, Standard_Integer const dv, Standard_Integer const de, Standard_Integer const df)

        Write <DS>    in   me  with   a     translation of
        <dv>,<de>,<df>.

        :type DS: OCC.wrapper.HLRBRep.Handle_HLRBRep_Data
        :type dv: int
        :type de: int
        :type df: int

        """
        return _HLRBRep.Handle_HLRBRep_Data_Write(self, *args)


    def EDataArray(self, *args):
        """
        EDataArray(Handle_HLRBRep_Data self) -> NCollection_Array1_HLRBRep_EdgeData

        :rtype: OCC.wrapper.HLRBRep.HLRBRep_Array1OfEData

        """
        return _HLRBRep.Handle_HLRBRep_Data_EDataArray(self, *args)


    def FDataArray(self, *args):
        """
        FDataArray(Handle_HLRBRep_Data self) -> NCollection_Array1_HLRBRep_FaceData

        :rtype: OCC.wrapper.HLRBRep.HLRBRep_Array1OfFData

        """
        return _HLRBRep.Handle_HLRBRep_Data_FDataArray(self, *args)


    def Tolerance(self, *args):
        """
        Tolerance(Handle_HLRBRep_Data self, Standard_ShortReal const tol)
        Tolerance(Handle_HLRBRep_Data self) -> Standard_ShortReal

        returns  the tolerance for the  rejections  during
        the exploration

        :rtype: OCC.wrapper.Standard.Standard_ShortReal

        """
        return _HLRBRep.Handle_HLRBRep_Data_Tolerance(self, *args)


    def Update(self, *args):
        """
        Update(Handle_HLRBRep_Data self, HLRAlgo_Projector P)

        end of building  of the Data and updating
        all the informations linked to the projection.

        :type P: OCC.wrapper.HLRAlgo.HLRAlgo_Projector

        """
        return _HLRBRep.Handle_HLRBRep_Data_Update(self, *args)


    def Projector(self, *args):
        """
        Projector(Handle_HLRBRep_Data self) -> HLRAlgo_Projector

        :rtype: OCC.wrapper.HLRAlgo.HLRAlgo_Projector

        """
        return _HLRBRep.Handle_HLRBRep_Data_Projector(self, *args)


    def NbVertices(self, *args):
        """
        NbVertices(Handle_HLRBRep_Data self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _HLRBRep.Handle_HLRBRep_Data_NbVertices(self, *args)


    def NbEdges(self, *args):
        """
        NbEdges(Handle_HLRBRep_Data self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _HLRBRep.Handle_HLRBRep_Data_NbEdges(self, *args)


    def NbFaces(self, *args):
        """
        NbFaces(Handle_HLRBRep_Data self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _HLRBRep.Handle_HLRBRep_Data_NbFaces(self, *args)


    def EdgeMap(self, *args):
        """
        EdgeMap(Handle_HLRBRep_Data self) -> NCollection_IndexedMap_TopoDS_Shape_TopTools_ShapeMapHasher

        :rtype: OCC.wrapper.TopTools.TopTools_IndexedMapOfShape

        """
        return _HLRBRep.Handle_HLRBRep_Data_EdgeMap(self, *args)


    def FaceMap(self, *args):
        """
        FaceMap(Handle_HLRBRep_Data self) -> NCollection_IndexedMap_TopoDS_Shape_TopTools_ShapeMapHasher

        :rtype: OCC.wrapper.TopTools.TopTools_IndexedMapOfShape

        """
        return _HLRBRep.Handle_HLRBRep_Data_FaceMap(self, *args)


    def InitBoundSort(self, *args):
        """
        InitBoundSort(Handle_HLRBRep_Data self, HLRAlgo_EdgesBlock::MinMaxIndices const & MinMaxTot, Standard_Integer const e1, Standard_Integer const e2)

        to compare with only non rejected edges.

        :type MinMaxTot: MinMaxIndices
        :type e1: int
        :type e2: int

        """
        return _HLRBRep.Handle_HLRBRep_Data_InitBoundSort(self, *args)


    def InitEdge(self, *args):
        """
        InitEdge(Handle_HLRBRep_Data self, Standard_Integer const FI, NCollection_DataMap_TopoDS_Shape_BRepTopAdaptor_Tool_TopTools_ShapeMapHasher MST)

        Begin an iteration only  on visible Edges
        crossing the face number <FI>.

        :type FI: int
        :type MST: OCC.wrapper.BRepTopAdaptor.BRepTopAdaptor_MapOfShapeTool

        """
        return _HLRBRep.Handle_HLRBRep_Data_InitEdge(self, *args)


    def MoreEdge(self, *args):
        """
        MoreEdge(Handle_HLRBRep_Data self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _HLRBRep.Handle_HLRBRep_Data_MoreEdge(self, *args)


    def NextEdge(self, *args):
        """
        NextEdge(Handle_HLRBRep_Data self, Standard_Boolean const skip)

        :type skip: bool

        """
        return _HLRBRep.Handle_HLRBRep_Data_NextEdge(self, *args)


    def Edge(self, *args):
        """
        Edge(Handle_HLRBRep_Data self) -> Standard_Integer

        Returns the  current Edge

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _HLRBRep.Handle_HLRBRep_Data_Edge(self, *args)


    def HidingTheFace(self, *args):
        """
        HidingTheFace(Handle_HLRBRep_Data self) -> Standard_Boolean

        Returns true if   the  current edge to   be hidden
        belongs to the hiding face.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _HLRBRep.Handle_HLRBRep_Data_HidingTheFace(self, *args)


    def SimpleHidingFace(self, *args):
        """
        SimpleHidingFace(Handle_HLRBRep_Data self) -> Standard_Boolean

        Returns true if the current hiding face is not  an
        auto-intersected one.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _HLRBRep.Handle_HLRBRep_Data_SimpleHidingFace(self, *args)


    def InitInterference(self, *args):
        """
        InitInterference(Handle_HLRBRep_Data self)

        Intersect  the current  Edge  with the boundary of
        the hiding  face.   The interferences are given by
        the More, Next, and Value methods.


        """
        return _HLRBRep.Handle_HLRBRep_Data_InitInterference(self, *args)


    def MoreInterference(self, *args):
        """
        MoreInterference(Handle_HLRBRep_Data self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _HLRBRep.Handle_HLRBRep_Data_MoreInterference(self, *args)


    def NextInterference(self, *args):
        """NextInterference(Handle_HLRBRep_Data self)"""
        return _HLRBRep.Handle_HLRBRep_Data_NextInterference(self, *args)


    def RejectedInterference(self, *args):
        """
        RejectedInterference(Handle_HLRBRep_Data self) -> Standard_Boolean

        Returns  True if the  interference is rejected.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _HLRBRep.Handle_HLRBRep_Data_RejectedInterference(self, *args)


    def AboveInterference(self, *args):
        """
        AboveInterference(Handle_HLRBRep_Data self) -> Standard_Boolean

        Returns True if the rejected interference is above
        the face.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _HLRBRep.Handle_HLRBRep_Data_AboveInterference(self, *args)


    def Interference(self, *args):
        """
        Interference(Handle_HLRBRep_Data self) -> HLRAlgo_Interference

        :rtype: OCC.wrapper.HLRAlgo.HLRAlgo_Interference

        """
        return _HLRBRep.Handle_HLRBRep_Data_Interference(self, *args)


    def LocalLEGeometry2D(self, *args):
        """
        LocalLEGeometry2D(Handle_HLRBRep_Data self, Standard_Real const Param, gp_Dir2d Tg, gp_Dir2d Nm)

        Returns the local description of the projection of
        the current LEdge  at parameter  <Param>.

        :type Param: float
        :type Tg: OCC.wrapper.gp.gp_Dir2d
        :type Nm: OCC.wrapper.gp.gp_Dir2d
        :type Cu: float

        """
        return _HLRBRep.Handle_HLRBRep_Data_LocalLEGeometry2D(self, *args)


    def LocalFEGeometry2D(self, *args):
        """
        LocalFEGeometry2D(Handle_HLRBRep_Data self, Standard_Integer const FE, Standard_Real const Param, gp_Dir2d Tg, gp_Dir2d Nm)

        Returns the local description of the projection of
        the current FEdge  at parameter  <Param>.

        :type FE: int
        :type Param: float
        :type Tg: OCC.wrapper.gp.gp_Dir2d
        :type Nm: OCC.wrapper.gp.gp_Dir2d
        :type Cu: float

        """
        return _HLRBRep.Handle_HLRBRep_Data_LocalFEGeometry2D(self, *args)


    def EdgeState(self, *args):
        """
        EdgeState(Handle_HLRBRep_Data self, Standard_Real const p1, Standard_Real const p2)

        Returns the local  3D   state of the  intersection
        between the current edge and the current face at the
        <p1> and <p2> parameters.

        :type p1: float
        :type p2: float
        :type stbef: OCC.wrapper.TopAbs.TopAbs_State
        :type staf: OCC.wrapper.TopAbs.TopAbs_State

        """
        return _HLRBRep.Handle_HLRBRep_Data_EdgeState(self, *args)


    def EdgeOfTheHidingFace(self, *args):
        """
        EdgeOfTheHidingFace(Handle_HLRBRep_Data self, Standard_Integer const E, HLRBRep_EdgeData ED) -> Standard_Boolean

        Returns the  true if the  Edge <ED> belongs to the
        Hiding Face.

        :type E: int
        :type ED: OCC.wrapper.HLRBRep.HLRBRep_EdgeData
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _HLRBRep.Handle_HLRBRep_Data_EdgeOfTheHidingFace(self, *args)


    def HidingStartLevel(self, *args):
        """
        HidingStartLevel(Handle_HLRBRep_Data self, Standard_Integer const E, HLRBRep_EdgeData ED, HLRAlgo_InterferenceList const & IL) -> Standard_Integer

        Returns the number of  levels of hiding face above
        the   first  point  of   the    edge <ED>.     The
        InterferenceList is  given to  compute far away of
        the Interferences and then come back.

        :type E: int
        :type ED: OCC.wrapper.HLRBRep.HLRBRep_EdgeData
        :type IL: OCC.wrapper.HLRAlgo.HLRAlgo_InterferenceList
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _HLRBRep.Handle_HLRBRep_Data_HidingStartLevel(self, *args)


    def Compare(self, *args):
        """
        Compare(Handle_HLRBRep_Data self, Standard_Integer const E, HLRBRep_EdgeData ED) -> TopAbs_State

        Returns   the  state   of  the   Edge  <ED>  after
        classification.

        :type E: int
        :type ED: OCC.wrapper.HLRBRep.HLRBRep_EdgeData
        :rtype: OCC.wrapper.TopAbs.TopAbs_State

        """
        return _HLRBRep.Handle_HLRBRep_Data_Compare(self, *args)


    def SimplClassify(self, *args):
        """
        SimplClassify(Handle_HLRBRep_Data self, Standard_Integer const E, HLRBRep_EdgeData ED, Standard_Integer const Nbp, Standard_Real const p1, Standard_Real const p2) -> TopAbs_State

        Simple classification of part of edge  [p1,  p2]
        returns  OUT  if  at  least  1 of  Nbp  points  of  edge  is  out
        othewise  returns  IN
        It  is  used  to  check  "suspision"  hided  part  of  edge.

        :type E: int
        :type ED: OCC.wrapper.HLRBRep.HLRBRep_EdgeData
        :type Nbp: int
        :type p1: float
        :type p2: float
        :rtype: OCC.wrapper.TopAbs.TopAbs_State

        """
        return _HLRBRep.Handle_HLRBRep_Data_SimplClassify(self, *args)


    def Classify(self, *args):
        """
        Classify(Handle_HLRBRep_Data self, Standard_Integer const E, HLRBRep_EdgeData ED, Standard_Boolean const LevelFlag, Standard_Real const param) -> TopAbs_State

        Classification of an edge.

        :type E: int
        :type ED: OCC.wrapper.HLRBRep.HLRBRep_EdgeData
        :type LevelFlag: bool
        :type Level: int
        :type param: float
        :rtype: OCC.wrapper.TopAbs.TopAbs_State

        """
        return _HLRBRep.Handle_HLRBRep_Data_Classify(self, *args)


    def IsBadFace(self, *args):
        """
        IsBadFace(Handle_HLRBRep_Data self) -> Standard_Boolean

        Returns true if the current face is bad.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _HLRBRep.Handle_HLRBRep_Data_IsBadFace(self, *args)


    def Destroy(self, *args):
        """Destroy(Handle_HLRBRep_Data self)"""
        return _HLRBRep.Handle_HLRBRep_Data_Destroy(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_HLRBRep_Data self) -> char const *

        :rtype: const char *

        """
        return _HLRBRep.Handle_HLRBRep_Data_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _HLRBRep.Handle_HLRBRep_Data_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _HLRBRep.Handle_HLRBRep_Data_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_HLRBRep_Data self)

        Memory deallocator for transient classes


        """
        return _HLRBRep.Handle_HLRBRep_Data_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_HLRBRep_Data self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_HLRBRep_Data self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _HLRBRep.Handle_HLRBRep_Data_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_HLRBRep_Data self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_HLRBRep_Data self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _HLRBRep.Handle_HLRBRep_Data_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_HLRBRep_Data self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _HLRBRep.Handle_HLRBRep_Data_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_HLRBRep_Data self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _HLRBRep.Handle_HLRBRep_Data_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_HLRBRep_Data self)

        Increments the reference counter of this object


        """
        return _HLRBRep.Handle_HLRBRep_Data_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_HLRBRep_Data self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _HLRBRep.Handle_HLRBRep_Data_DecrementRefCounter(self, *args)

Handle_HLRBRep_Data_swigregister = _HLRBRep.Handle_HLRBRep_Data_swigregister
Handle_HLRBRep_Data_swigregister(Handle_HLRBRep_Data)

def Handle_HLRBRep_Data_DownCast(thing):
    return _HLRBRep.Handle_HLRBRep_Data_DownCast(thing)
Handle_HLRBRep_Data_DownCast = _HLRBRep.Handle_HLRBRep_Data_DownCast

class NCollection_List_HLRBRep_BiPnt2D_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _HLRBRep.new_NCollection_List_HLRBRep_BiPnt2D_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _HLRBRep.delete_NCollection_List_HLRBRep_BiPnt2D_IteratorHelper

    def __next__(self):
        return _HLRBRep.NCollection_List_HLRBRep_BiPnt2D_IteratorHelper___next__(self)
NCollection_List_HLRBRep_BiPnt2D_IteratorHelper_swigregister = _HLRBRep.NCollection_List_HLRBRep_BiPnt2D_IteratorHelper_swigregister
NCollection_List_HLRBRep_BiPnt2D_IteratorHelper_swigregister(NCollection_List_HLRBRep_BiPnt2D_IteratorHelper)


try:
	HLRBRep_ListOfBPnt2D = NCollection_List_HLRBRep_BiPnt2D
except NameError:
	pass # does not exist, probably ignored

class HLRBRep_PCLocFOfTheLocateExtPCOfTheProjPCurOfCInter(math.math_FunctionWithDerivative):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(HLRBRep_PCLocFOfTheLocateExtPCOfTheProjPCurOfCInter self) -> HLRBRep_PCLocFOfTheLocateExtPCOfTheProjPCurOfCInter
        __init__(HLRBRep_PCLocFOfTheLocateExtPCOfTheProjPCurOfCInter self, gp_Pnt2d P, Standard_Address const & C) -> HLRBRep_PCLocFOfTheLocateExtPCOfTheProjPCurOfCInter

        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type C: OCC.wrapper.Standard.Standard_Address

        """
        this = _HLRBRep.new_HLRBRep_PCLocFOfTheLocateExtPCOfTheProjPCurOfCInter(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Initialize(self, *args):
        """
        Initialize(HLRBRep_PCLocFOfTheLocateExtPCOfTheProjPCurOfCInter self, Standard_Address const & C)

        sets the field mycurve of the function.

        :type C: OCC.wrapper.Standard.Standard_Address

        """
        return _HLRBRep.HLRBRep_PCLocFOfTheLocateExtPCOfTheProjPCurOfCInter_Initialize(self, *args)


    def SetPoint(self, *args):
        """
        SetPoint(HLRBRep_PCLocFOfTheLocateExtPCOfTheProjPCurOfCInter self, gp_Pnt2d P)

        sets the field P of the function.

        :type P: OCC.wrapper.gp.gp_Pnt2d

        """
        return _HLRBRep.HLRBRep_PCLocFOfTheLocateExtPCOfTheProjPCurOfCInter_SetPoint(self, *args)


    def Value(self, *args):
        """
        Value(HLRBRep_PCLocFOfTheLocateExtPCOfTheProjPCurOfCInter self, Standard_Real const U) -> Standard_Boolean

        Calculation of F(U).

        :type U: float
        :type F: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _HLRBRep.HLRBRep_PCLocFOfTheLocateExtPCOfTheProjPCurOfCInter_Value(self, *args)


    def Derivative(self, *args):
        """
        Derivative(HLRBRep_PCLocFOfTheLocateExtPCOfTheProjPCurOfCInter self, Standard_Real const U) -> Standard_Boolean

        Calculation of F'(U).

        :type U: float
        :type DF: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _HLRBRep.HLRBRep_PCLocFOfTheLocateExtPCOfTheProjPCurOfCInter_Derivative(self, *args)


    def Values(self, *args):
        """
        Values(HLRBRep_PCLocFOfTheLocateExtPCOfTheProjPCurOfCInter self, Standard_Real const U) -> Standard_Boolean

        Calculation of F(U) and F'(U).

        :type U: float
        :type F: float
        :type DF: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _HLRBRep.HLRBRep_PCLocFOfTheLocateExtPCOfTheProjPCurOfCInter_Values(self, *args)


    def GetStateNumber(self, *args):
        """
        GetStateNumber(HLRBRep_PCLocFOfTheLocateExtPCOfTheProjPCurOfCInter self) -> Standard_Integer

        Save the found extremum.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _HLRBRep.HLRBRep_PCLocFOfTheLocateExtPCOfTheProjPCurOfCInter_GetStateNumber(self, *args)


    def NbExt(self, *args):
        """
        NbExt(HLRBRep_PCLocFOfTheLocateExtPCOfTheProjPCurOfCInter self) -> Standard_Integer

        Return the nunber of found extrema.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _HLRBRep.HLRBRep_PCLocFOfTheLocateExtPCOfTheProjPCurOfCInter_NbExt(self, *args)


    def SquareDistance(self, *args):
        """
        SquareDistance(HLRBRep_PCLocFOfTheLocateExtPCOfTheProjPCurOfCInter self, Standard_Integer const N) -> Standard_Real

        Returns the Nth distance.

        :type N: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _HLRBRep.HLRBRep_PCLocFOfTheLocateExtPCOfTheProjPCurOfCInter_SquareDistance(self, *args)


    def IsMin(self, *args):
        """
        IsMin(HLRBRep_PCLocFOfTheLocateExtPCOfTheProjPCurOfCInter self, Standard_Integer const N) -> Standard_Boolean

        Shows if the Nth distance is a minimum.

        :type N: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _HLRBRep.HLRBRep_PCLocFOfTheLocateExtPCOfTheProjPCurOfCInter_IsMin(self, *args)


    def Point(self, *args):
        """
        Returns the Nth extremum.

        :type N: int
        :rtype: OCC.wrapper.Extrema.Extrema_POnCurv2d

        """
        res = _HLRBRep.HLRBRep_PCLocFOfTheLocateExtPCOfTheProjPCurOfCInter_Point(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SubIntervalInitialize(self, *args):
        """
        SubIntervalInitialize(HLRBRep_PCLocFOfTheLocateExtPCOfTheProjPCurOfCInter self, Standard_Real const theUfirst, Standard_Real const theUlast)

        Determines boundaries of subinterval for find of root.

        :type theUfirst: float
        :type theUlast: float

        """
        return _HLRBRep.HLRBRep_PCLocFOfTheLocateExtPCOfTheProjPCurOfCInter_SubIntervalInitialize(self, *args)


    def SearchOfTolerance(self, *args):
        """
        SearchOfTolerance(HLRBRep_PCLocFOfTheLocateExtPCOfTheProjPCurOfCInter self) -> Standard_Real

        Computes a Tol value. If 1st derivative of curve
        |D1|<Tol, it is considered D1=0.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _HLRBRep.HLRBRep_PCLocFOfTheLocateExtPCOfTheProjPCurOfCInter_SearchOfTolerance(self, *args)

    __swig_destroy__ = _HLRBRep.delete_HLRBRep_PCLocFOfTheLocateExtPCOfTheProjPCurOfCInter
HLRBRep_PCLocFOfTheLocateExtPCOfTheProjPCurOfCInter_swigregister = _HLRBRep.HLRBRep_PCLocFOfTheLocateExtPCOfTheProjPCurOfCInter_swigregister
HLRBRep_PCLocFOfTheLocateExtPCOfTheProjPCurOfCInter_swigregister(HLRBRep_PCLocFOfTheLocateExtPCOfTheProjPCurOfCInter)

class HLRBRep_SLProps(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(HLRBRep_SLProps self, Standard_Address const & S, Standard_Real const U, Standard_Real const V, Standard_Integer const N, Standard_Real const Resolution) -> HLRBRep_SLProps
        __init__(HLRBRep_SLProps self, Standard_Address const & S, Standard_Integer const N, Standard_Real const Resolution) -> HLRBRep_SLProps
        __init__(HLRBRep_SLProps self, Standard_Integer const N, Standard_Real const Resolution) -> HLRBRep_SLProps

        idem as previous constructor but without setting the value
        of parameters <U> and <V> and the surface.
        the surface can have an empty constructor.

        :type N: int
        :type Resolution: float

        """
        this = _HLRBRep.new_HLRBRep_SLProps(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def SetSurface(self, *args):
        """
        SetSurface(HLRBRep_SLProps self, Standard_Address const & S)

        Initializes the local properties of the surface S
        for the new surface.

        :type S: OCC.wrapper.Standard.Standard_Address

        """
        return _HLRBRep.HLRBRep_SLProps_SetSurface(self, *args)


    def SetParameters(self, *args):
        """
        SetParameters(HLRBRep_SLProps self, Standard_Real const U, Standard_Real const V)

        Initializes the local properties of the surface S
        for the new parameter values (<U>, <V>).

        :type U: float
        :type V: float

        """
        return _HLRBRep.HLRBRep_SLProps_SetParameters(self, *args)


    def Value(self, *args):
        """
        Returns the point.

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        res = _HLRBRep.HLRBRep_SLProps_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def D1U(self, *args):
        """
        Returns the first U derivative.
        The derivative is computed if it has not been yet.

        :rtype: OCC.wrapper.gp.gp_Vec

        """
        res = _HLRBRep.HLRBRep_SLProps_D1U(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def D1V(self, *args):
        """
        Returns the first V derivative.
        The derivative is computed if it has not been yet.

        :rtype: OCC.wrapper.gp.gp_Vec

        """
        res = _HLRBRep.HLRBRep_SLProps_D1V(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def D2U(self, *args):
        """
        Returns the second U derivatives
        The derivative is computed if it has not been yet.

        :rtype: OCC.wrapper.gp.gp_Vec

        """
        res = _HLRBRep.HLRBRep_SLProps_D2U(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def D2V(self, *args):
        """
        Returns the second V derivative.
        The derivative is computed if it has not been yet.

        :rtype: OCC.wrapper.gp.gp_Vec

        """
        res = _HLRBRep.HLRBRep_SLProps_D2V(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DUV(self, *args):
        """
        Returns the second UV cross-derivative.
        The derivative is computed if it has not been yet.

        :rtype: OCC.wrapper.gp.gp_Vec

        """
        res = _HLRBRep.HLRBRep_SLProps_DUV(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def IsTangentUDefined(self, *args):
        """
        IsTangentUDefined(HLRBRep_SLProps self) -> Standard_Boolean

        returns True if the U tangent is defined.
        For example, the tangent is not defined if the
        two first U derivatives are null.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _HLRBRep.HLRBRep_SLProps_IsTangentUDefined(self, *args)


    def TangentU(self, *args):
        """
        TangentU(HLRBRep_SLProps self, gp_Dir D)

        Returns the tangent direction <D> on the iso-V.

        :type D: OCC.wrapper.gp.gp_Dir

        """
        return _HLRBRep.HLRBRep_SLProps_TangentU(self, *args)


    def IsTangentVDefined(self, *args):
        """
        IsTangentVDefined(HLRBRep_SLProps self) -> Standard_Boolean

        returns if the V tangent is defined.
        For example, the tangent is not defined if the
        two first V derivatives are null.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _HLRBRep.HLRBRep_SLProps_IsTangentVDefined(self, *args)


    def TangentV(self, *args):
        """
        TangentV(HLRBRep_SLProps self, gp_Dir D)

        Returns the tangent direction <D> on the iso-V.

        :type D: OCC.wrapper.gp.gp_Dir

        """
        return _HLRBRep.HLRBRep_SLProps_TangentV(self, *args)


    def IsNormalDefined(self, *args):
        """
        IsNormalDefined(HLRBRep_SLProps self) -> Standard_Boolean

        Tells if the normal is defined.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _HLRBRep.HLRBRep_SLProps_IsNormalDefined(self, *args)


    def Normal(self, *args):
        """
        Returns the normal direction.

        :rtype: OCC.wrapper.gp.gp_Dir

        """
        res = _HLRBRep.HLRBRep_SLProps_Normal(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def IsCurvatureDefined(self, *args):
        """
        IsCurvatureDefined(HLRBRep_SLProps self) -> Standard_Boolean

        returns True if the curvature is defined.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _HLRBRep.HLRBRep_SLProps_IsCurvatureDefined(self, *args)


    def IsUmbilic(self, *args):
        """
        IsUmbilic(HLRBRep_SLProps self) -> Standard_Boolean

        returns True if the point is umbilic (i.e. if the
        curvature is constant).

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _HLRBRep.HLRBRep_SLProps_IsUmbilic(self, *args)


    def MaxCurvature(self, *args):
        """
        MaxCurvature(HLRBRep_SLProps self) -> Standard_Real

        Returns the maximum curvature

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _HLRBRep.HLRBRep_SLProps_MaxCurvature(self, *args)


    def MinCurvature(self, *args):
        """
        MinCurvature(HLRBRep_SLProps self) -> Standard_Real

        Returns the minimum curvature

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _HLRBRep.HLRBRep_SLProps_MinCurvature(self, *args)


    def CurvatureDirections(self, *args):
        """
        CurvatureDirections(HLRBRep_SLProps self, gp_Dir MaxD, gp_Dir MinD)

        Returns the direction of the maximum and minimum curvature
        <MaxD> and <MinD>

        :type MaxD: OCC.wrapper.gp.gp_Dir
        :type MinD: OCC.wrapper.gp.gp_Dir

        """
        return _HLRBRep.HLRBRep_SLProps_CurvatureDirections(self, *args)


    def MeanCurvature(self, *args):
        """
        MeanCurvature(HLRBRep_SLProps self) -> Standard_Real

        Returns the mean curvature.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _HLRBRep.HLRBRep_SLProps_MeanCurvature(self, *args)


    def GaussianCurvature(self, *args):
        """
        GaussianCurvature(HLRBRep_SLProps self) -> Standard_Real

        Returns the Gaussian curvature

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _HLRBRep.HLRBRep_SLProps_GaussianCurvature(self, *args)

    __swig_destroy__ = _HLRBRep.delete_HLRBRep_SLProps
HLRBRep_SLProps_swigregister = _HLRBRep.HLRBRep_SLProps_swigregister
HLRBRep_SLProps_swigregister(HLRBRep_SLProps)

class HLRBRep_TheInterferenceOfInterCSurf(Intf.Intf_Interference):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(HLRBRep_TheInterferenceOfInterCSurf self) -> HLRBRep_TheInterferenceOfInterCSurf
        __init__(HLRBRep_TheInterferenceOfInterCSurf self, HLRBRep_ThePolygonOfInterCSurf thePolyg, HLRBRep_ThePolyhedronOfInterCSurf thePolyh) -> HLRBRep_TheInterferenceOfInterCSurf
        __init__(HLRBRep_TheInterferenceOfInterCSurf self, gp_Lin theLin, HLRBRep_ThePolyhedronOfInterCSurf thePolyh) -> HLRBRep_TheInterferenceOfInterCSurf
        __init__(HLRBRep_TheInterferenceOfInterCSurf self, NCollection_Array1_gp_Lin theLins, HLRBRep_ThePolyhedronOfInterCSurf thePolyh) -> HLRBRep_TheInterferenceOfInterCSurf
        __init__(HLRBRep_TheInterferenceOfInterCSurf self, HLRBRep_ThePolygonOfInterCSurf thePolyg, HLRBRep_ThePolyhedronOfInterCSurf thePolyh, Bnd_BoundSortBox theBoundSB) -> HLRBRep_TheInterferenceOfInterCSurf
        __init__(HLRBRep_TheInterferenceOfInterCSurf self, gp_Lin theLin, HLRBRep_ThePolyhedronOfInterCSurf thePolyh, Bnd_BoundSortBox theBoundSB) -> HLRBRep_TheInterferenceOfInterCSurf
        __init__(HLRBRep_TheInterferenceOfInterCSurf self, NCollection_Array1_gp_Lin theLins, HLRBRep_ThePolyhedronOfInterCSurf thePolyh, Bnd_BoundSortBox theBoundSB) -> HLRBRep_TheInterferenceOfInterCSurf

        Constructs   and   computes  an  interference   between the
        Straight Lines and the Polyhedron.

        :type theLins: OCC.wrapper.Intf.Intf_Array1OfLin
        :type thePolyh: OCC.wrapper.HLRBRep.HLRBRep_ThePolyhedronOfInterCSurf
        :type theBoundSB: OCC.wrapper.Bnd.Bnd_BoundSortBox

        """
        this = _HLRBRep.new_HLRBRep_TheInterferenceOfInterCSurf(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Perform(self, *args):
        """
        Perform(HLRBRep_TheInterferenceOfInterCSurf self, HLRBRep_ThePolygonOfInterCSurf thePolyg, HLRBRep_ThePolyhedronOfInterCSurf thePolyh)
        Perform(HLRBRep_TheInterferenceOfInterCSurf self, gp_Lin theLin, HLRBRep_ThePolyhedronOfInterCSurf thePolyh)
        Perform(HLRBRep_TheInterferenceOfInterCSurf self, NCollection_Array1_gp_Lin theLins, HLRBRep_ThePolyhedronOfInterCSurf thePolyh)
        Perform(HLRBRep_TheInterferenceOfInterCSurf self, HLRBRep_ThePolygonOfInterCSurf thePolyg, HLRBRep_ThePolyhedronOfInterCSurf thePolyh, Bnd_BoundSortBox theBoundSB)
        Perform(HLRBRep_TheInterferenceOfInterCSurf self, gp_Lin theLin, HLRBRep_ThePolyhedronOfInterCSurf thePolyh, Bnd_BoundSortBox theBoundSB)
        Perform(HLRBRep_TheInterferenceOfInterCSurf self, NCollection_Array1_gp_Lin theLins, HLRBRep_ThePolyhedronOfInterCSurf thePolyh, Bnd_BoundSortBox theBoundSB)

        Computes an interference  between the  Straight Lines  and
        the Polyhedron.

        :type theLins: OCC.wrapper.Intf.Intf_Array1OfLin
        :type thePolyh: OCC.wrapper.HLRBRep.HLRBRep_ThePolyhedronOfInterCSurf
        :type theBoundSB: OCC.wrapper.Bnd.Bnd_BoundSortBox

        """
        return _HLRBRep.HLRBRep_TheInterferenceOfInterCSurf_Perform(self, *args)


    def Interference(self, *args):
        """
        Interference(HLRBRep_TheInterferenceOfInterCSurf self, HLRBRep_ThePolygonOfInterCSurf thePolyg, HLRBRep_ThePolyhedronOfInterCSurf thePolyh, Bnd_BoundSortBox theBoundSB)
        Interference(HLRBRep_TheInterferenceOfInterCSurf self, HLRBRep_ThePolygonOfInterCSurf thePolyg, HLRBRep_ThePolyhedronOfInterCSurf thePolyh)

        Compares the boundings between the segment of <thePolyg> and
        the facets of <thePolyh>.

        :type thePolyg: OCC.wrapper.HLRBRep.HLRBRep_ThePolygonOfInterCSurf
        :type thePolyh: OCC.wrapper.HLRBRep.HLRBRep_ThePolyhedronOfInterCSurf

        """
        return _HLRBRep.HLRBRep_TheInterferenceOfInterCSurf_Interference(self, *args)

    __swig_destroy__ = _HLRBRep.delete_HLRBRep_TheInterferenceOfInterCSurf
HLRBRep_TheInterferenceOfInterCSurf_swigregister = _HLRBRep.HLRBRep_TheInterferenceOfInterCSurf_swigregister
HLRBRep_TheInterferenceOfInterCSurf_swigregister(HLRBRep_TheInterferenceOfInterCSurf)

class NCollection_Array1_HLRBRep_FaceData(object):
    """
    Purpose:     The class Array1 represents unidimensional arrays 
    of fixed size known at run time. 
    The range of the index is user defined.
    An array1 can be constructed with a "C array".
    This functionality is useful to call methods expecting
    an Array1. It allows to carry the bounds inside the arrays.

    Examples:    Item tab[100]; //  An example with a C array
    Array1OfItem ttab (tab[0],1,100);

    Array1OfItem tttab (ttab(10),10,20); // a slice of ttab

    If you want to reindex an array from 1 to Length do :

    Array1 tab1(tab(tab.Lower()),1,tab.Length());

    Warning:     Programs client of such a class must be independant
    of the range of the first element. Then, a C++ for
    loop must be written like this

    for (i = A.Lower(); i <= A.Upper(); i++)

    Changes:     In  comparison  to  TCollection  the  flag  isAllocated  was
    renamed into myDeletable (alike in  the Array2).  For naming
    compatibility the method IsAllocated remained in class along
    with IsDeletable.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Array1_HLRBRep_FaceData self) -> NCollection_Array1< HLRBRep_FaceData >::iterator

        Returns an iterator pointing to the first element in the array.

        :rtype: iterator

        """
        return _HLRBRep.NCollection_Array1_HLRBRep_FaceData_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Array1_HLRBRep_FaceData self) -> NCollection_Array1< HLRBRep_FaceData >::iterator

        Returns an iterator referring to the past-the-end element in the array.

        :rtype: iterator

        """
        return _HLRBRep.NCollection_Array1_HLRBRep_FaceData_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Array1_HLRBRep_FaceData self) -> NCollection_Array1< HLRBRep_FaceData >::const_iterator

        Returns a const iterator pointing to the first element in the array.

        :rtype: const_iterator

        """
        return _HLRBRep.NCollection_Array1_HLRBRep_FaceData_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Array1_HLRBRep_FaceData self) -> NCollection_Array1< HLRBRep_FaceData >::const_iterator

        Returns a const iterator referring to the past-the-end element in the array.

        :rtype: const_iterator

        """
        return _HLRBRep.NCollection_Array1_HLRBRep_FaceData_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     The class Array1 represents unidimensional arrays 
        of fixed size known at run time. 
        The range of the index is user defined.
        An array1 can be constructed with a "C array".
        This functionality is useful to call methods expecting
        an Array1. It allows to carry the bounds inside the arrays.

        Examples:    Item tab[100]; //  An example with a C array
        Array1OfItem ttab (tab[0],1,100);

        Array1OfItem tttab (ttab(10),10,20); // a slice of ttab

        If you want to reindex an array from 1 to Length do :

        Array1 tab1(tab(tab.Lower()),1,tab.Length());

        Warning:     Programs client of such a class must be independant
        of the range of the first element. Then, a C++ for
        loop must be written like this

        for (i = A.Lower(); i <= A.Upper(); i++)

        Changes:     In  comparison  to  TCollection  the  flag  isAllocated  was
        renamed into myDeletable (alike in  the Array2).  For naming
        compatibility the method IsAllocated remained in class along
        with IsDeletable.
        """
        this = _HLRBRep.new_NCollection_Array1_HLRBRep_FaceData(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(NCollection_Array1_HLRBRep_FaceData self, HLRBRep_FaceData theValue)

        Initialise the items with theValue

        :type theValue: const TheItemType &

        """
        return _HLRBRep.NCollection_Array1_HLRBRep_FaceData_Init(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_Array1_HLRBRep_FaceData self) -> Standard_Integer

        Size query

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _HLRBRep.NCollection_Array1_HLRBRep_FaceData_Size(self, *args)


    def Length(self, *args):
        """
        Length(NCollection_Array1_HLRBRep_FaceData self) -> Standard_Integer

        Length query (the same)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _HLRBRep.NCollection_Array1_HLRBRep_FaceData_Length(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Array1_HLRBRep_FaceData self) -> Standard_Boolean

        Return TRUE if array has zero length.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _HLRBRep.NCollection_Array1_HLRBRep_FaceData_IsEmpty(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Array1_HLRBRep_FaceData self) -> Standard_Integer

        Lower bound

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _HLRBRep.NCollection_Array1_HLRBRep_FaceData_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Array1_HLRBRep_FaceData self) -> Standard_Integer

        Upper bound

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _HLRBRep.NCollection_Array1_HLRBRep_FaceData_Upper(self, *args)


    def IsDeletable(self, *args):
        """
        IsDeletable(NCollection_Array1_HLRBRep_FaceData self) -> Standard_Boolean

        myDeletable flag

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _HLRBRep.NCollection_Array1_HLRBRep_FaceData_IsDeletable(self, *args)


    def IsAllocated(self, *args):
        """
        IsAllocated(NCollection_Array1_HLRBRep_FaceData self) -> Standard_Boolean

        IsAllocated flag - for naming compatibility

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _HLRBRep.NCollection_Array1_HLRBRep_FaceData_IsAllocated(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Array1_HLRBRep_FaceData self, NCollection_Array1_HLRBRep_FaceData theOther) -> NCollection_Array1_HLRBRep_FaceData

        Copies data of theOther array to this.
        This array should be pre-allocated and have the same length as theOther;
        otherwise exception Standard_DimensionMismatch is thrown.

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _HLRBRep.NCollection_Array1_HLRBRep_FaceData_Assign(self, *args)


    def Move(self, *args):
        """
        Move(NCollection_Array1_HLRBRep_FaceData self, NCollection_Array1_HLRBRep_FaceData theOther) -> NCollection_Array1_HLRBRep_FaceData

        Move assignment.
        This array will borrow all the data from theOther.
        The moved object will keep pointer to the memory buffer and
        range, but it will not free the buffer on destruction.

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _HLRBRep.NCollection_Array1_HLRBRep_FaceData_Move(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Array1_HLRBRep_FaceData self, NCollection_Array1_HLRBRep_FaceData theOther) -> NCollection_Array1_HLRBRep_FaceData
        assign(NCollection_Array1_HLRBRep_FaceData self, NCollection_Array1_HLRBRep_FaceData theOther) -> NCollection_Array1_HLRBRep_FaceData

        Move assignment operator; @sa Move()

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1<TheItemType> &&
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _HLRBRep.NCollection_Array1_HLRBRep_FaceData_assign(self, *args)


    def First(self, *args):
        """
        @return first element

        :rtype: const TheItemType &

        """
        res = _HLRBRep.NCollection_Array1_HLRBRep_FaceData_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Array1_HLRBRep_FaceData self) -> HLRBRep_FaceData

        @return first element

        :rtype: TheItemType &

        """
        return _HLRBRep.NCollection_Array1_HLRBRep_FaceData_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        @return last element

        :rtype: const TheItemType &

        """
        res = _HLRBRep.NCollection_Array1_HLRBRep_FaceData_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Array1_HLRBRep_FaceData self) -> HLRBRep_FaceData

        @return last element

        :rtype: TheItemType &

        """
        return _HLRBRep.NCollection_Array1_HLRBRep_FaceData_ChangeLast(self, *args)


    def Value(self, *args):
        """
        Constant value access

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _HLRBRep.NCollection_Array1_HLRBRep_FaceData_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Array1_HLRBRep_FaceData self, Standard_Integer const theIndex) -> HLRBRep_FaceData

        Variable value access

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _HLRBRep.NCollection_Array1_HLRBRep_FaceData_ChangeValue(self, *args)


    def __call__(self, *args):
        """
        operator() - alias to Value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _HLRBRep.NCollection_Array1_HLRBRep_FaceData___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __getitem__(self, *args):
        """
        operator[] - alias to Value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _HLRBRep.NCollection_Array1_HLRBRep_FaceData_at(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetValue(self, *args):
        """
        SetValue(NCollection_Array1_HLRBRep_FaceData self, Standard_Integer const theIndex, HLRBRep_FaceData theItem)

        Set value 

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _HLRBRep.NCollection_Array1_HLRBRep_FaceData_SetValue(self, *args)


    def Resize(self, *args):
        """
        Resize(NCollection_Array1_HLRBRep_FaceData self, Standard_Integer const theLower, Standard_Integer const theUpper, Standard_Boolean const theToCopyData)

        Resizes the array to specified bounds.
        No re-allocation will be done if length of array does not change,
        but existing values will not be discarded if theToCopyData set to FALSE.
        @param theLower new lower bound of array
        @param theUpper new upper bound of array
        @param theToCopyData flag to copy existing data into new array

        :type theLower: int
        :type theUpper: int
        :type theToCopyData: bool

        """
        return _HLRBRep.NCollection_Array1_HLRBRep_FaceData_Resize(self, *args)

    __swig_destroy__ = _HLRBRep.delete_NCollection_Array1_HLRBRep_FaceData
NCollection_Array1_HLRBRep_FaceData_swigregister = _HLRBRep.NCollection_Array1_HLRBRep_FaceData_swigregister
NCollection_Array1_HLRBRep_FaceData_swigregister(NCollection_Array1_HLRBRep_FaceData)


try:
	HLRBRep_Array1OfFData = NCollection_Array1_HLRBRep_FaceData
except NameError:
	pass # does not exist, probably ignored

class HLRBRep_InterCSurf(IntCurveSurface.IntCurveSurface_Intersection):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(HLRBRep_InterCSurf self) -> HLRBRep_InterCSurf

        Empty Constructor


        """
        this = _HLRBRep.new_HLRBRep_InterCSurf(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Perform(self, *args):
        """
        Perform(HLRBRep_InterCSurf self, gp_Lin Curve, Standard_Address const & Surface)
        Perform(HLRBRep_InterCSurf self, gp_Lin Curve, HLRBRep_ThePolygonOfInterCSurf Polygon, Standard_Address const & Surface)
        Perform(HLRBRep_InterCSurf self, gp_Lin Curve, HLRBRep_ThePolygonOfInterCSurf ThePolygon, Standard_Address const & Surface, HLRBRep_ThePolyhedronOfInterCSurf Polyhedron)
        Perform(HLRBRep_InterCSurf self, gp_Lin Curve, HLRBRep_ThePolygonOfInterCSurf ThePolygon, Standard_Address const & Surface, HLRBRep_ThePolyhedronOfInterCSurf Polyhedron, Bnd_BoundSortBox BndBSB)
        Perform(HLRBRep_InterCSurf self, gp_Lin Curve, Standard_Address const & Surface, HLRBRep_ThePolyhedronOfInterCSurf Polyhedron)

        Compute the Intersection  between the curve  and
        the surface. The Surface is already  sampled and
        its polyhedron : <Polyhedron> is given.

        :type Curve: OCC.wrapper.gp.gp_Lin
        :type Surface: OCC.wrapper.Standard.Standard_Address
        :type Polyhedron: OCC.wrapper.HLRBRep.HLRBRep_ThePolyhedronOfInterCSurf

        """
        return _HLRBRep.HLRBRep_InterCSurf_Perform(self, *args)

    __swig_destroy__ = _HLRBRep.delete_HLRBRep_InterCSurf
HLRBRep_InterCSurf_swigregister = _HLRBRep.HLRBRep_InterCSurf_swigregister
HLRBRep_InterCSurf_swigregister(HLRBRep_InterCSurf)

class HLRBRep_BCurveTool(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def FirstParameter(*args):
        """
        FirstParameter(BRepAdaptor_Curve C) -> Standard_Real

        :type C: OCC.wrapper.BRepAdaptor.BRepAdaptor_Curve
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _HLRBRep.HLRBRep_BCurveTool_FirstParameter(*args)

    FirstParameter = staticmethod(FirstParameter)

    def LastParameter(*args):
        """
        LastParameter(BRepAdaptor_Curve C) -> Standard_Real

        :type C: OCC.wrapper.BRepAdaptor.BRepAdaptor_Curve
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _HLRBRep.HLRBRep_BCurveTool_LastParameter(*args)

    LastParameter = staticmethod(LastParameter)

    def Continuity(*args):
        """
        Continuity(BRepAdaptor_Curve C) -> GeomAbs_Shape

        :type C: OCC.wrapper.BRepAdaptor.BRepAdaptor_Curve
        :rtype: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _HLRBRep.HLRBRep_BCurveTool_Continuity(*args)

    Continuity = staticmethod(Continuity)

    def NbIntervals(*args):
        """
        NbIntervals(BRepAdaptor_Curve C, GeomAbs_Shape const S) -> Standard_Integer

        Returns  the number  of  intervals for  continuity
        <S>. May be one if Continuity(myclass) >= <S>

        :type C: OCC.wrapper.BRepAdaptor.BRepAdaptor_Curve
        :type S: OCC.wrapper.GeomAbs.GeomAbs_Shape
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _HLRBRep.HLRBRep_BCurveTool_NbIntervals(*args)

    NbIntervals = staticmethod(NbIntervals)

    def Intervals(*args):
        """
        Intervals(BRepAdaptor_Curve C, NCollection_Array1_Standard_Real T, GeomAbs_Shape const S)

        Stores in <T> the  parameters bounding the intervals
        of continuity <S>.

        The array must provide  enough room to  accomodate
        for the parameters. i.e. T.Length() > NbIntervals()

        :type C: OCC.wrapper.BRepAdaptor.BRepAdaptor_Curve
        :type T: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type S: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _HLRBRep.HLRBRep_BCurveTool_Intervals(*args)

    Intervals = staticmethod(Intervals)

    def IsClosed(*args):
        """
        IsClosed(BRepAdaptor_Curve C) -> Standard_Boolean

        :type C: OCC.wrapper.BRepAdaptor.BRepAdaptor_Curve
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _HLRBRep.HLRBRep_BCurveTool_IsClosed(*args)

    IsClosed = staticmethod(IsClosed)

    def IsPeriodic(*args):
        """
        IsPeriodic(BRepAdaptor_Curve C) -> Standard_Boolean

        :type C: OCC.wrapper.BRepAdaptor.BRepAdaptor_Curve
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _HLRBRep.HLRBRep_BCurveTool_IsPeriodic(*args)

    IsPeriodic = staticmethod(IsPeriodic)

    def Period(*args):
        """
        Period(BRepAdaptor_Curve C) -> Standard_Real

        :type C: OCC.wrapper.BRepAdaptor.BRepAdaptor_Curve
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _HLRBRep.HLRBRep_BCurveTool_Period(*args)

    Period = staticmethod(Period)

    def Value(*args):
        """
        Value(BRepAdaptor_Curve C, Standard_Real const U) -> gp_Pnt

        Computes the point of parameter U on the curve.

        :type C: OCC.wrapper.BRepAdaptor.BRepAdaptor_Curve
        :type U: float
        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _HLRBRep.HLRBRep_BCurveTool_Value(*args)

    Value = staticmethod(Value)

    def D0(*args):
        """
        D0(BRepAdaptor_Curve C, Standard_Real const U, gp_Pnt P)

        Computes the point of parameter U on the curve.

        :type C: OCC.wrapper.BRepAdaptor.BRepAdaptor_Curve
        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt

        """
        return _HLRBRep.HLRBRep_BCurveTool_D0(*args)

    D0 = staticmethod(D0)

    def D1(*args):
        """
        D1(BRepAdaptor_Curve C, Standard_Real const U, gp_Pnt P, gp_Vec V)

        Computes the point of parameter U on the curve with its
        first derivative.
        Raised if the continuity of the current interval
        is not C1.

        :type C: OCC.wrapper.BRepAdaptor.BRepAdaptor_Curve
        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type V: OCC.wrapper.gp.gp_Vec

        """
        return _HLRBRep.HLRBRep_BCurveTool_D1(*args)

    D1 = staticmethod(D1)

    def D2(*args):
        """
        D2(BRepAdaptor_Curve C, Standard_Real const U, gp_Pnt P, gp_Vec V1, gp_Vec V2)

        Returns the point P of parameter U, the first and second
        derivatives V1 and V2.
        Raised if the continuity of the current interval
        is not C2.

        :type C: OCC.wrapper.BRepAdaptor.BRepAdaptor_Curve
        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type V1: OCC.wrapper.gp.gp_Vec
        :type V2: OCC.wrapper.gp.gp_Vec

        """
        return _HLRBRep.HLRBRep_BCurveTool_D2(*args)

    D2 = staticmethod(D2)

    def D3(*args):
        """
        D3(BRepAdaptor_Curve C, Standard_Real const U, gp_Pnt P, gp_Vec V1, gp_Vec V2, gp_Vec V3)

        Returns the point P of parameter U, the first, the second
        and the third derivative.
        Raised if the continuity of the current interval
        is not C3.

        :type C: OCC.wrapper.BRepAdaptor.BRepAdaptor_Curve
        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type V1: OCC.wrapper.gp.gp_Vec
        :type V2: OCC.wrapper.gp.gp_Vec
        :type V3: OCC.wrapper.gp.gp_Vec

        """
        return _HLRBRep.HLRBRep_BCurveTool_D3(*args)

    D3 = staticmethod(D3)

    def DN(*args):
        """
        DN(BRepAdaptor_Curve C, Standard_Real const U, Standard_Integer const N) -> gp_Vec

        The returned vector gives the value of the derivative for the
        order of derivation N.
        Raised if the continuity of the current interval
        is not CN.
        Raised if N < 1.

        :type C: OCC.wrapper.BRepAdaptor.BRepAdaptor_Curve
        :type U: float
        :type N: int
        :rtype: OCC.wrapper.gp.gp_Vec

        """
        return _HLRBRep.HLRBRep_BCurveTool_DN(*args)

    DN = staticmethod(DN)

    def Resolution(*args):
        """
        Resolution(BRepAdaptor_Curve C, Standard_Real const R3d) -> Standard_Real

        Returns the parametric  resolution corresponding
        to the real space resolution <R3d>.

        :type C: OCC.wrapper.BRepAdaptor.BRepAdaptor_Curve
        :type R3d: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _HLRBRep.HLRBRep_BCurveTool_Resolution(*args)

    Resolution = staticmethod(Resolution)

    def GetType(*args):
        """
        GetType(BRepAdaptor_Curve C) -> GeomAbs_CurveType

        Returns  the  type of the   curve  in the  current
        interval :   Line,   Circle,   Ellipse, Hyperbola,
        Parabola, BezierCurve, BSplineCurve, OtherCurve.

        :type C: OCC.wrapper.BRepAdaptor.BRepAdaptor_Curve
        :rtype: OCC.wrapper.GeomAbs.GeomAbs_CurveType

        """
        return _HLRBRep.HLRBRep_BCurveTool_GetType(*args)

    GetType = staticmethod(GetType)

    def Line(*args):
        """
        Line(BRepAdaptor_Curve C) -> gp_Lin

        :type C: OCC.wrapper.BRepAdaptor.BRepAdaptor_Curve
        :rtype: OCC.wrapper.gp.gp_Lin

        """
        return _HLRBRep.HLRBRep_BCurveTool_Line(*args)

    Line = staticmethod(Line)

    def Circle(*args):
        """
        Circle(BRepAdaptor_Curve C) -> gp_Circ

        :type C: OCC.wrapper.BRepAdaptor.BRepAdaptor_Curve
        :rtype: OCC.wrapper.gp.gp_Circ

        """
        return _HLRBRep.HLRBRep_BCurveTool_Circle(*args)

    Circle = staticmethod(Circle)

    def Ellipse(*args):
        """
        Ellipse(BRepAdaptor_Curve C) -> gp_Elips

        :type C: OCC.wrapper.BRepAdaptor.BRepAdaptor_Curve
        :rtype: OCC.wrapper.gp.gp_Elips

        """
        return _HLRBRep.HLRBRep_BCurveTool_Ellipse(*args)

    Ellipse = staticmethod(Ellipse)

    def Hyperbola(*args):
        """
        Hyperbola(BRepAdaptor_Curve C) -> gp_Hypr

        :type C: OCC.wrapper.BRepAdaptor.BRepAdaptor_Curve
        :rtype: OCC.wrapper.gp.gp_Hypr

        """
        return _HLRBRep.HLRBRep_BCurveTool_Hyperbola(*args)

    Hyperbola = staticmethod(Hyperbola)

    def Parabola(*args):
        """
        Parabola(BRepAdaptor_Curve C) -> gp_Parab

        :type C: OCC.wrapper.BRepAdaptor.BRepAdaptor_Curve
        :rtype: OCC.wrapper.gp.gp_Parab

        """
        return _HLRBRep.HLRBRep_BCurveTool_Parabola(*args)

    Parabola = staticmethod(Parabola)

    def Bezier(*args):
        """
        Bezier(BRepAdaptor_Curve C) -> Handle_Geom_BezierCurve

        :type C: OCC.wrapper.BRepAdaptor.BRepAdaptor_Curve
        :rtype: OCC.wrapper.Geom.Handle_Geom_BezierCurve

        """
        return _HLRBRep.HLRBRep_BCurveTool_Bezier(*args)

    Bezier = staticmethod(Bezier)

    def BSpline(*args):
        """
        BSpline(BRepAdaptor_Curve C) -> Handle_Geom_BSplineCurve

        :type C: OCC.wrapper.BRepAdaptor.BRepAdaptor_Curve
        :rtype: OCC.wrapper.Geom.Handle_Geom_BSplineCurve

        """
        return _HLRBRep.HLRBRep_BCurveTool_BSpline(*args)

    BSpline = staticmethod(BSpline)

    def Degree(*args):
        """
        Degree(BRepAdaptor_Curve C) -> Standard_Integer

        :type C: OCC.wrapper.BRepAdaptor.BRepAdaptor_Curve
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _HLRBRep.HLRBRep_BCurveTool_Degree(*args)

    Degree = staticmethod(Degree)

    def IsRational(*args):
        """
        IsRational(BRepAdaptor_Curve C) -> Standard_Boolean

        :type C: OCC.wrapper.BRepAdaptor.BRepAdaptor_Curve
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _HLRBRep.HLRBRep_BCurveTool_IsRational(*args)

    IsRational = staticmethod(IsRational)

    def NbPoles(*args):
        """
        NbPoles(BRepAdaptor_Curve C) -> Standard_Integer

        :type C: OCC.wrapper.BRepAdaptor.BRepAdaptor_Curve
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _HLRBRep.HLRBRep_BCurveTool_NbPoles(*args)

    NbPoles = staticmethod(NbPoles)

    def NbKnots(*args):
        """
        NbKnots(BRepAdaptor_Curve C) -> Standard_Integer

        :type C: OCC.wrapper.BRepAdaptor.BRepAdaptor_Curve
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _HLRBRep.HLRBRep_BCurveTool_NbKnots(*args)

    NbKnots = staticmethod(NbKnots)

    def Poles(*args):
        """
        Poles(BRepAdaptor_Curve C, NCollection_Array1_gp_Pnt T)

        :type C: OCC.wrapper.BRepAdaptor.BRepAdaptor_Curve
        :type T: OCC.wrapper.TColgp.TColgp_Array1OfPnt

        """
        return _HLRBRep.HLRBRep_BCurveTool_Poles(*args)

    Poles = staticmethod(Poles)

    def PolesAndWeights(*args):
        """
        PolesAndWeights(BRepAdaptor_Curve C, NCollection_Array1_gp_Pnt T, NCollection_Array1_Standard_Real W)

        :type C: OCC.wrapper.BRepAdaptor.BRepAdaptor_Curve
        :type T: OCC.wrapper.TColgp.TColgp_Array1OfPnt
        :type W: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        return _HLRBRep.HLRBRep_BCurveTool_PolesAndWeights(*args)

    PolesAndWeights = staticmethod(PolesAndWeights)

    def NbSamples(*args):
        """
        NbSamples(BRepAdaptor_Curve C, Standard_Real const U0, Standard_Real const U1) -> Standard_Integer

        :type C: OCC.wrapper.BRepAdaptor.BRepAdaptor_Curve
        :type U0: float
        :type U1: float
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _HLRBRep.HLRBRep_BCurveTool_NbSamples(*args)

    NbSamples = staticmethod(NbSamples)

    def __init__(self):
        this = _HLRBRep.new_HLRBRep_BCurveTool()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _HLRBRep.delete_HLRBRep_BCurveTool
HLRBRep_BCurveTool_swigregister = _HLRBRep.HLRBRep_BCurveTool_swigregister
HLRBRep_BCurveTool_swigregister(HLRBRep_BCurveTool)

def HLRBRep_BCurveTool_FirstParameter(*args):
    """
    HLRBRep_BCurveTool_FirstParameter(BRepAdaptor_Curve C) -> Standard_Real

    :type C: OCC.wrapper.BRepAdaptor.BRepAdaptor_Curve
    :rtype: OCC.wrapper.Standard.Standard_Real

    """
    return _HLRBRep.HLRBRep_BCurveTool_FirstParameter(*args)

def HLRBRep_BCurveTool_LastParameter(*args):
    """
    HLRBRep_BCurveTool_LastParameter(BRepAdaptor_Curve C) -> Standard_Real

    :type C: OCC.wrapper.BRepAdaptor.BRepAdaptor_Curve
    :rtype: OCC.wrapper.Standard.Standard_Real

    """
    return _HLRBRep.HLRBRep_BCurveTool_LastParameter(*args)

def HLRBRep_BCurveTool_Continuity(*args):
    """
    HLRBRep_BCurveTool_Continuity(BRepAdaptor_Curve C) -> GeomAbs_Shape

    :type C: OCC.wrapper.BRepAdaptor.BRepAdaptor_Curve
    :rtype: OCC.wrapper.GeomAbs.GeomAbs_Shape

    """
    return _HLRBRep.HLRBRep_BCurveTool_Continuity(*args)

def HLRBRep_BCurveTool_NbIntervals(*args):
    """
    HLRBRep_BCurveTool_NbIntervals(BRepAdaptor_Curve C, GeomAbs_Shape const S) -> Standard_Integer

    Returns  the number  of  intervals for  continuity
    <S>. May be one if Continuity(myclass) >= <S>

    :type C: OCC.wrapper.BRepAdaptor.BRepAdaptor_Curve
    :type S: OCC.wrapper.GeomAbs.GeomAbs_Shape
    :rtype: OCC.wrapper.Standard.Standard_Integer

    """
    return _HLRBRep.HLRBRep_BCurveTool_NbIntervals(*args)

def HLRBRep_BCurveTool_Intervals(*args):
    """
    HLRBRep_BCurveTool_Intervals(BRepAdaptor_Curve C, NCollection_Array1_Standard_Real T, GeomAbs_Shape const S)

    Stores in <T> the  parameters bounding the intervals
    of continuity <S>.

    The array must provide  enough room to  accomodate
    for the parameters. i.e. T.Length() > NbIntervals()

    :type C: OCC.wrapper.BRepAdaptor.BRepAdaptor_Curve
    :type T: OCC.wrapper.TColStd.TColStd_Array1OfReal
    :type S: OCC.wrapper.GeomAbs.GeomAbs_Shape

    """
    return _HLRBRep.HLRBRep_BCurveTool_Intervals(*args)

def HLRBRep_BCurveTool_IsClosed(*args):
    """
    HLRBRep_BCurveTool_IsClosed(BRepAdaptor_Curve C) -> Standard_Boolean

    :type C: OCC.wrapper.BRepAdaptor.BRepAdaptor_Curve
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _HLRBRep.HLRBRep_BCurveTool_IsClosed(*args)

def HLRBRep_BCurveTool_IsPeriodic(*args):
    """
    HLRBRep_BCurveTool_IsPeriodic(BRepAdaptor_Curve C) -> Standard_Boolean

    :type C: OCC.wrapper.BRepAdaptor.BRepAdaptor_Curve
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _HLRBRep.HLRBRep_BCurveTool_IsPeriodic(*args)

def HLRBRep_BCurveTool_Period(*args):
    """
    HLRBRep_BCurveTool_Period(BRepAdaptor_Curve C) -> Standard_Real

    :type C: OCC.wrapper.BRepAdaptor.BRepAdaptor_Curve
    :rtype: OCC.wrapper.Standard.Standard_Real

    """
    return _HLRBRep.HLRBRep_BCurveTool_Period(*args)

def HLRBRep_BCurveTool_Value(*args):
    """
    HLRBRep_BCurveTool_Value(BRepAdaptor_Curve C, Standard_Real const U) -> gp_Pnt

    Computes the point of parameter U on the curve.

    :type C: OCC.wrapper.BRepAdaptor.BRepAdaptor_Curve
    :type U: float
    :rtype: OCC.wrapper.gp.gp_Pnt

    """
    return _HLRBRep.HLRBRep_BCurveTool_Value(*args)

def HLRBRep_BCurveTool_D0(*args):
    """
    HLRBRep_BCurveTool_D0(BRepAdaptor_Curve C, Standard_Real const U, gp_Pnt P)

    Computes the point of parameter U on the curve.

    :type C: OCC.wrapper.BRepAdaptor.BRepAdaptor_Curve
    :type U: float
    :type P: OCC.wrapper.gp.gp_Pnt

    """
    return _HLRBRep.HLRBRep_BCurveTool_D0(*args)

def HLRBRep_BCurveTool_D1(*args):
    """
    HLRBRep_BCurveTool_D1(BRepAdaptor_Curve C, Standard_Real const U, gp_Pnt P, gp_Vec V)

    Computes the point of parameter U on the curve with its
    first derivative.
    Raised if the continuity of the current interval
    is not C1.

    :type C: OCC.wrapper.BRepAdaptor.BRepAdaptor_Curve
    :type U: float
    :type P: OCC.wrapper.gp.gp_Pnt
    :type V: OCC.wrapper.gp.gp_Vec

    """
    return _HLRBRep.HLRBRep_BCurveTool_D1(*args)

def HLRBRep_BCurveTool_D2(*args):
    """
    HLRBRep_BCurveTool_D2(BRepAdaptor_Curve C, Standard_Real const U, gp_Pnt P, gp_Vec V1, gp_Vec V2)

    Returns the point P of parameter U, the first and second
    derivatives V1 and V2.
    Raised if the continuity of the current interval
    is not C2.

    :type C: OCC.wrapper.BRepAdaptor.BRepAdaptor_Curve
    :type U: float
    :type P: OCC.wrapper.gp.gp_Pnt
    :type V1: OCC.wrapper.gp.gp_Vec
    :type V2: OCC.wrapper.gp.gp_Vec

    """
    return _HLRBRep.HLRBRep_BCurveTool_D2(*args)

def HLRBRep_BCurveTool_D3(*args):
    """
    HLRBRep_BCurveTool_D3(BRepAdaptor_Curve C, Standard_Real const U, gp_Pnt P, gp_Vec V1, gp_Vec V2, gp_Vec V3)

    Returns the point P of parameter U, the first, the second
    and the third derivative.
    Raised if the continuity of the current interval
    is not C3.

    :type C: OCC.wrapper.BRepAdaptor.BRepAdaptor_Curve
    :type U: float
    :type P: OCC.wrapper.gp.gp_Pnt
    :type V1: OCC.wrapper.gp.gp_Vec
    :type V2: OCC.wrapper.gp.gp_Vec
    :type V3: OCC.wrapper.gp.gp_Vec

    """
    return _HLRBRep.HLRBRep_BCurveTool_D3(*args)

def HLRBRep_BCurveTool_DN(*args):
    """
    HLRBRep_BCurveTool_DN(BRepAdaptor_Curve C, Standard_Real const U, Standard_Integer const N) -> gp_Vec

    The returned vector gives the value of the derivative for the
    order of derivation N.
    Raised if the continuity of the current interval
    is not CN.
    Raised if N < 1.

    :type C: OCC.wrapper.BRepAdaptor.BRepAdaptor_Curve
    :type U: float
    :type N: int
    :rtype: OCC.wrapper.gp.gp_Vec

    """
    return _HLRBRep.HLRBRep_BCurveTool_DN(*args)

def HLRBRep_BCurveTool_Resolution(*args):
    """
    HLRBRep_BCurveTool_Resolution(BRepAdaptor_Curve C, Standard_Real const R3d) -> Standard_Real

    Returns the parametric  resolution corresponding
    to the real space resolution <R3d>.

    :type C: OCC.wrapper.BRepAdaptor.BRepAdaptor_Curve
    :type R3d: float
    :rtype: OCC.wrapper.Standard.Standard_Real

    """
    return _HLRBRep.HLRBRep_BCurveTool_Resolution(*args)

def HLRBRep_BCurveTool_GetType(*args):
    """
    HLRBRep_BCurveTool_GetType(BRepAdaptor_Curve C) -> GeomAbs_CurveType

    Returns  the  type of the   curve  in the  current
    interval :   Line,   Circle,   Ellipse, Hyperbola,
    Parabola, BezierCurve, BSplineCurve, OtherCurve.

    :type C: OCC.wrapper.BRepAdaptor.BRepAdaptor_Curve
    :rtype: OCC.wrapper.GeomAbs.GeomAbs_CurveType

    """
    return _HLRBRep.HLRBRep_BCurveTool_GetType(*args)

def HLRBRep_BCurveTool_Line(*args):
    """
    HLRBRep_BCurveTool_Line(BRepAdaptor_Curve C) -> gp_Lin

    :type C: OCC.wrapper.BRepAdaptor.BRepAdaptor_Curve
    :rtype: OCC.wrapper.gp.gp_Lin

    """
    return _HLRBRep.HLRBRep_BCurveTool_Line(*args)

def HLRBRep_BCurveTool_Circle(*args):
    """
    HLRBRep_BCurveTool_Circle(BRepAdaptor_Curve C) -> gp_Circ

    :type C: OCC.wrapper.BRepAdaptor.BRepAdaptor_Curve
    :rtype: OCC.wrapper.gp.gp_Circ

    """
    return _HLRBRep.HLRBRep_BCurveTool_Circle(*args)

def HLRBRep_BCurveTool_Ellipse(*args):
    """
    HLRBRep_BCurveTool_Ellipse(BRepAdaptor_Curve C) -> gp_Elips

    :type C: OCC.wrapper.BRepAdaptor.BRepAdaptor_Curve
    :rtype: OCC.wrapper.gp.gp_Elips

    """
    return _HLRBRep.HLRBRep_BCurveTool_Ellipse(*args)

def HLRBRep_BCurveTool_Hyperbola(*args):
    """
    HLRBRep_BCurveTool_Hyperbola(BRepAdaptor_Curve C) -> gp_Hypr

    :type C: OCC.wrapper.BRepAdaptor.BRepAdaptor_Curve
    :rtype: OCC.wrapper.gp.gp_Hypr

    """
    return _HLRBRep.HLRBRep_BCurveTool_Hyperbola(*args)

def HLRBRep_BCurveTool_Parabola(*args):
    """
    HLRBRep_BCurveTool_Parabola(BRepAdaptor_Curve C) -> gp_Parab

    :type C: OCC.wrapper.BRepAdaptor.BRepAdaptor_Curve
    :rtype: OCC.wrapper.gp.gp_Parab

    """
    return _HLRBRep.HLRBRep_BCurveTool_Parabola(*args)

def HLRBRep_BCurveTool_Bezier(*args):
    """
    HLRBRep_BCurveTool_Bezier(BRepAdaptor_Curve C) -> Handle_Geom_BezierCurve

    :type C: OCC.wrapper.BRepAdaptor.BRepAdaptor_Curve
    :rtype: OCC.wrapper.Geom.Handle_Geom_BezierCurve

    """
    return _HLRBRep.HLRBRep_BCurveTool_Bezier(*args)

def HLRBRep_BCurveTool_BSpline(*args):
    """
    HLRBRep_BCurveTool_BSpline(BRepAdaptor_Curve C) -> Handle_Geom_BSplineCurve

    :type C: OCC.wrapper.BRepAdaptor.BRepAdaptor_Curve
    :rtype: OCC.wrapper.Geom.Handle_Geom_BSplineCurve

    """
    return _HLRBRep.HLRBRep_BCurveTool_BSpline(*args)

def HLRBRep_BCurveTool_Degree(*args):
    """
    HLRBRep_BCurveTool_Degree(BRepAdaptor_Curve C) -> Standard_Integer

    :type C: OCC.wrapper.BRepAdaptor.BRepAdaptor_Curve
    :rtype: OCC.wrapper.Standard.Standard_Integer

    """
    return _HLRBRep.HLRBRep_BCurveTool_Degree(*args)

def HLRBRep_BCurveTool_IsRational(*args):
    """
    HLRBRep_BCurveTool_IsRational(BRepAdaptor_Curve C) -> Standard_Boolean

    :type C: OCC.wrapper.BRepAdaptor.BRepAdaptor_Curve
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _HLRBRep.HLRBRep_BCurveTool_IsRational(*args)

def HLRBRep_BCurveTool_NbPoles(*args):
    """
    HLRBRep_BCurveTool_NbPoles(BRepAdaptor_Curve C) -> Standard_Integer

    :type C: OCC.wrapper.BRepAdaptor.BRepAdaptor_Curve
    :rtype: OCC.wrapper.Standard.Standard_Integer

    """
    return _HLRBRep.HLRBRep_BCurveTool_NbPoles(*args)

def HLRBRep_BCurveTool_NbKnots(*args):
    """
    HLRBRep_BCurveTool_NbKnots(BRepAdaptor_Curve C) -> Standard_Integer

    :type C: OCC.wrapper.BRepAdaptor.BRepAdaptor_Curve
    :rtype: OCC.wrapper.Standard.Standard_Integer

    """
    return _HLRBRep.HLRBRep_BCurveTool_NbKnots(*args)

def HLRBRep_BCurveTool_Poles(*args):
    """
    HLRBRep_BCurveTool_Poles(BRepAdaptor_Curve C, NCollection_Array1_gp_Pnt T)

    :type C: OCC.wrapper.BRepAdaptor.BRepAdaptor_Curve
    :type T: OCC.wrapper.TColgp.TColgp_Array1OfPnt

    """
    return _HLRBRep.HLRBRep_BCurveTool_Poles(*args)

def HLRBRep_BCurveTool_PolesAndWeights(*args):
    """
    HLRBRep_BCurveTool_PolesAndWeights(BRepAdaptor_Curve C, NCollection_Array1_gp_Pnt T, NCollection_Array1_Standard_Real W)

    :type C: OCC.wrapper.BRepAdaptor.BRepAdaptor_Curve
    :type T: OCC.wrapper.TColgp.TColgp_Array1OfPnt
    :type W: OCC.wrapper.TColStd.TColStd_Array1OfReal

    """
    return _HLRBRep.HLRBRep_BCurveTool_PolesAndWeights(*args)

def HLRBRep_BCurveTool_NbSamples(*args):
    """
    HLRBRep_BCurveTool_NbSamples(BRepAdaptor_Curve C, Standard_Real const U0, Standard_Real const U1) -> Standard_Integer

    :type C: OCC.wrapper.BRepAdaptor.BRepAdaptor_Curve
    :type U0: float
    :type U1: float
    :rtype: OCC.wrapper.Standard.Standard_Integer

    """
    return _HLRBRep.HLRBRep_BCurveTool_NbSamples(*args)

class HLRBRep_TheIntPCurvePCurveOfCInter(IntRes2d.IntRes2d_Intersection):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """__init__(HLRBRep_TheIntPCurvePCurveOfCInter self) -> HLRBRep_TheIntPCurvePCurveOfCInter"""
        this = _HLRBRep.new_HLRBRep_TheIntPCurvePCurveOfCInter(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Perform(self, *args):
        """
        Perform(HLRBRep_TheIntPCurvePCurveOfCInter self, Standard_Address const & Curve1, IntRes2d_Domain Domain1, Standard_Address const & Curve2, IntRes2d_Domain Domain2, Standard_Real const TolConf, Standard_Real const Tol)
        Perform(HLRBRep_TheIntPCurvePCurveOfCInter self, Standard_Address const & Curve1, IntRes2d_Domain Domain1, Standard_Real const TolConf, Standard_Real const Tol)

        :type Curve1: OCC.wrapper.Standard.Standard_Address
        :type Domain1: OCC.wrapper.IntRes2d.IntRes2d_Domain
        :type TolConf: float
        :type Tol: float

        """
        return _HLRBRep.HLRBRep_TheIntPCurvePCurveOfCInter_Perform(self, *args)


    def SetMinNbSamples(self, *args):
        """
        SetMinNbSamples(HLRBRep_TheIntPCurvePCurveOfCInter self, Standard_Integer const theMinNbSamples)

        Set / get minimum number of points in polygon for intersection.

        :type theMinNbSamples: int

        """
        return _HLRBRep.HLRBRep_TheIntPCurvePCurveOfCInter_SetMinNbSamples(self, *args)


    def GetMinNbSamples(self, *args):
        """
        GetMinNbSamples(HLRBRep_TheIntPCurvePCurveOfCInter self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _HLRBRep.HLRBRep_TheIntPCurvePCurveOfCInter_GetMinNbSamples(self, *args)

    __swig_destroy__ = _HLRBRep.delete_HLRBRep_TheIntPCurvePCurveOfCInter
HLRBRep_TheIntPCurvePCurveOfCInter_swigregister = _HLRBRep.HLRBRep_TheIntPCurvePCurveOfCInter_swigregister
HLRBRep_TheIntPCurvePCurveOfCInter_swigregister(HLRBRep_TheIntPCurvePCurveOfCInter)

class HLRBRep_ThePolygonOfInterCSurf(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(HLRBRep_ThePolygonOfInterCSurf self, gp_Lin Curve, Standard_Integer const NbPnt) -> HLRBRep_ThePolygonOfInterCSurf
        __init__(HLRBRep_ThePolygonOfInterCSurf self, gp_Lin Curve, Standard_Real const U1, Standard_Real const U2, Standard_Integer const NbPnt) -> HLRBRep_ThePolygonOfInterCSurf
        __init__(HLRBRep_ThePolygonOfInterCSurf self, gp_Lin Curve, NCollection_Array1_Standard_Real Upars) -> HLRBRep_ThePolygonOfInterCSurf

        :type Curve: OCC.wrapper.gp.gp_Lin
        :type Upars: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        this = _HLRBRep.new_HLRBRep_ThePolygonOfInterCSurf(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Bounding(self, *args):
        """
        Give the bounding box of the polygon.

        :rtype: OCC.wrapper.Bnd.Bnd_Box

        """
        res = _HLRBRep.HLRBRep_ThePolygonOfInterCSurf_Bounding(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DeflectionOverEstimation(self, *args):
        """
        DeflectionOverEstimation(HLRBRep_ThePolygonOfInterCSurf self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _HLRBRep.HLRBRep_ThePolygonOfInterCSurf_DeflectionOverEstimation(self, *args)


    def SetDeflectionOverEstimation(self, *args):
        """
        SetDeflectionOverEstimation(HLRBRep_ThePolygonOfInterCSurf self, Standard_Real const x)

        :type x: float

        """
        return _HLRBRep.HLRBRep_ThePolygonOfInterCSurf_SetDeflectionOverEstimation(self, *args)


    def Closed(self, *args):
        """
        Closed(HLRBRep_ThePolygonOfInterCSurf self, Standard_Boolean const clos)
        Closed(HLRBRep_ThePolygonOfInterCSurf self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _HLRBRep.HLRBRep_ThePolygonOfInterCSurf_Closed(self, *args)


    def NbSegments(self, *args):
        """
        NbSegments(HLRBRep_ThePolygonOfInterCSurf self) -> Standard_Integer

        Give the number of Segments in the polyline.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _HLRBRep.HLRBRep_ThePolygonOfInterCSurf_NbSegments(self, *args)


    def BeginOfSeg(self, *args):
        """
        Give the point of range Index in the Polygon.

        :type Index: int
        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        res = _HLRBRep.HLRBRep_ThePolygonOfInterCSurf_BeginOfSeg(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def EndOfSeg(self, *args):
        """
        Give the point of range Index in the Polygon.

        :type Index: int
        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        res = _HLRBRep.HLRBRep_ThePolygonOfInterCSurf_EndOfSeg(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def InfParameter(self, *args):
        """
        InfParameter(HLRBRep_ThePolygonOfInterCSurf self) -> Standard_Real

        Returns the parameter (On the curve)
        of the first point of the Polygon

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _HLRBRep.HLRBRep_ThePolygonOfInterCSurf_InfParameter(self, *args)


    def SupParameter(self, *args):
        """
        SupParameter(HLRBRep_ThePolygonOfInterCSurf self) -> Standard_Real

        Returns the parameter (On the curve)
        of the last point of the Polygon

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _HLRBRep.HLRBRep_ThePolygonOfInterCSurf_SupParameter(self, *args)


    def ApproxParamOnCurve(self, *args):
        """
        ApproxParamOnCurve(HLRBRep_ThePolygonOfInterCSurf self, Standard_Integer const Index, Standard_Real const ParamOnLine) -> Standard_Real

        Give an approximation of the parameter on the curve
        according to the discretization of the Curve.

        :type Index: int
        :type ParamOnLine: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _HLRBRep.HLRBRep_ThePolygonOfInterCSurf_ApproxParamOnCurve(self, *args)


    def Dump(self, *args):
        """Dump(HLRBRep_ThePolygonOfInterCSurf self)"""
        return _HLRBRep.HLRBRep_ThePolygonOfInterCSurf_Dump(self, *args)

    __swig_destroy__ = _HLRBRep.delete_HLRBRep_ThePolygonOfInterCSurf
HLRBRep_ThePolygonOfInterCSurf_swigregister = _HLRBRep.HLRBRep_ThePolygonOfInterCSurf_swigregister
HLRBRep_ThePolygonOfInterCSurf_swigregister(HLRBRep_ThePolygonOfInterCSurf)

class HLRBRep_TheCurveLocatorOfTheProjPCurOfCInter(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Locate(*args):
        """
        Locate(gp_Pnt2d P, Standard_Address const & C, Standard_Integer const NbU, Extrema_POnCurv2d Papp)
        Locate(gp_Pnt2d P, Standard_Address const & C, Standard_Integer const NbU, Standard_Real const Umin, Standard_Real const Usup, Extrema_POnCurv2d Papp)

        Among a set of points {C(ui),i=1,NbU}, locate the point
        P=C(uj) such that:
        distance(P,C) = Min{distance(P,C(ui))}
        The research is done between umin and usup.

        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type C: OCC.wrapper.Standard.Standard_Address
        :type NbU: int
        :type Umin: float
        :type Usup: float
        :type Papp: OCC.wrapper.Extrema.Extrema_POnCurv2d

        """
        return _HLRBRep.HLRBRep_TheCurveLocatorOfTheProjPCurOfCInter_Locate(*args)

    Locate = staticmethod(Locate)

    def __init__(self):
        this = _HLRBRep.new_HLRBRep_TheCurveLocatorOfTheProjPCurOfCInter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _HLRBRep.delete_HLRBRep_TheCurveLocatorOfTheProjPCurOfCInter
HLRBRep_TheCurveLocatorOfTheProjPCurOfCInter_swigregister = _HLRBRep.HLRBRep_TheCurveLocatorOfTheProjPCurOfCInter_swigregister
HLRBRep_TheCurveLocatorOfTheProjPCurOfCInter_swigregister(HLRBRep_TheCurveLocatorOfTheProjPCurOfCInter)

def HLRBRep_TheCurveLocatorOfTheProjPCurOfCInter_Locate(*args):
    """
    Locate(gp_Pnt2d P, Standard_Address const & C, Standard_Integer const NbU, Extrema_POnCurv2d Papp)
    HLRBRep_TheCurveLocatorOfTheProjPCurOfCInter_Locate(gp_Pnt2d P, Standard_Address const & C, Standard_Integer const NbU, Standard_Real const Umin, Standard_Real const Usup, Extrema_POnCurv2d Papp)

    Among a set of points {C(ui),i=1,NbU}, locate the point
    P=C(uj) such that:
    distance(P,C) = Min{distance(P,C(ui))}
    The research is done between umin and usup.

    :type P: OCC.wrapper.gp.gp_Pnt2d
    :type C: OCC.wrapper.Standard.Standard_Address
    :type NbU: int
    :type Umin: float
    :type Usup: float
    :type Papp: OCC.wrapper.Extrema.Extrema_POnCurv2d

    """
    return _HLRBRep.HLRBRep_TheCurveLocatorOfTheProjPCurOfCInter_Locate(*args)




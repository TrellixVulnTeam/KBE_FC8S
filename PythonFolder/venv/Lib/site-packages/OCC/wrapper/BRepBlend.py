# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_BRepBlend')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_BRepBlend')
    _BRepBlend = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_BRepBlend', [dirname(__file__)])
        except ImportError:
            import _BRepBlend
            return _BRepBlend
        try:
            _mod = imp.load_module('_BRepBlend', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _BRepBlend = swig_import_helper()
    del swig_import_helper
else:
    import _BRepBlend
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


class SwigPyIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _BRepBlend.delete_SwigPyIterator

    def value(self):
        return _BRepBlend.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _BRepBlend.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _BRepBlend.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _BRepBlend.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _BRepBlend.SwigPyIterator_equal(self, x)

    def copy(self):
        return _BRepBlend.SwigPyIterator_copy(self)

    def next(self):
        return _BRepBlend.SwigPyIterator_next(self)

    def __next__(self):
        return _BRepBlend.SwigPyIterator___next__(self)

    def previous(self):
        return _BRepBlend.SwigPyIterator_previous(self)

    def advance(self, n):
        return _BRepBlend.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _BRepBlend.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _BRepBlend.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _BRepBlend.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _BRepBlend.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _BRepBlend.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _BRepBlend.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self
SwigPyIterator_swigregister = _BRepBlend.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

class NCollection_CellFilter_InspectorXYZ(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _BRepBlend.NCollection_CellFilter_InspectorXYZ_Dimension
    Coord = staticmethod(_BRepBlend.NCollection_CellFilter_InspectorXYZ_Coord)

    def Shift(self, thePnt, theTol):
        return _BRepBlend.NCollection_CellFilter_InspectorXYZ_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _BRepBlend.new_NCollection_CellFilter_InspectorXYZ()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _BRepBlend.delete_NCollection_CellFilter_InspectorXYZ
NCollection_CellFilter_InspectorXYZ_swigregister = _BRepBlend.NCollection_CellFilter_InspectorXYZ_swigregister
NCollection_CellFilter_InspectorXYZ_swigregister(NCollection_CellFilter_InspectorXYZ)

def NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt):
    return _BRepBlend.NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt)
NCollection_CellFilter_InspectorXYZ_Coord = _BRepBlend.NCollection_CellFilter_InspectorXYZ_Coord

class NCollection_CellFilter_InspectorXY(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _BRepBlend.NCollection_CellFilter_InspectorXY_Dimension
    Coord = staticmethod(_BRepBlend.NCollection_CellFilter_InspectorXY_Coord)

    def Shift(self, thePnt, theTol):
        return _BRepBlend.NCollection_CellFilter_InspectorXY_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _BRepBlend.new_NCollection_CellFilter_InspectorXY()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _BRepBlend.delete_NCollection_CellFilter_InspectorXY
NCollection_CellFilter_InspectorXY_swigregister = _BRepBlend.NCollection_CellFilter_InspectorXY_swigregister
NCollection_CellFilter_InspectorXY_swigregister(NCollection_CellFilter_InspectorXY)

def NCollection_CellFilter_InspectorXY_Coord(i, thePnt):
    return _BRepBlend.NCollection_CellFilter_InspectorXY_Coord(i, thePnt)
NCollection_CellFilter_InspectorXY_Coord = _BRepBlend.NCollection_CellFilter_InspectorXY_Coord


def ptr_to_number(item):
    return _BRepBlend.ptr_to_number(item)
ptr_to_number = _BRepBlend.ptr_to_number

def HashCode(*args):
    return _BRepBlend.HashCode(*args)
HashCode = _BRepBlend.HashCode

def ptr_equal(a, b):
    return _BRepBlend.ptr_equal(a, b)
ptr_equal = _BRepBlend.ptr_equal
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Adaptor2d
else:
    import Adaptor2d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Geom2d
else:
    import Geom2d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import GeomAbs
else:
    import GeomAbs
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColStd
else:
    import TColStd
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TCollection
else:
    import TCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Standard
else:
    import Standard
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import NCollection
else:
    import NCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import gp
else:
    import gp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColgp
else:
    import TColgp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Approx
else:
    import Approx
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import AppCont
else:
    import AppCont
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import AppParCurves
else:
    import AppParCurves
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import math
else:
    import math
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import AdvApprox
else:
    import AdvApprox
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import PLib
else:
    import PLib
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Geom
else:
    import Geom
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Adaptor3d
else:
    import Adaptor3d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopAbs
else:
    import TopAbs
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Law
else:
    import Law
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import ChFiDS
else:
    import ChFiDS
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopoDS
else:
    import TopoDS
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Message
else:
    import Message
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopLoc
else:
    import TopLoc
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import BRepAdaptor
else:
    import BRepAdaptor
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Geom2dAdaptor
else:
    import Geom2dAdaptor
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import GeomAdaptor
else:
    import GeomAdaptor
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopTools
else:
    import TopTools
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Bnd
else:
    import Bnd
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import IntSurf
else:
    import IntSurf
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import AppBlend
else:
    import AppBlend
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Blend
else:
    import Blend
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import BlendFunc
else:
    import BlendFunc
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Convert
else:
    import Convert
del _swig_python_version_info
class BRepBlend_AppFuncRoot(Approx.Approx_SweepFunction):
    """Function to approximate by AppSurface"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_BRepBlend_AppFuncRoot
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_BRepBlend_AppFuncRoot(self) 
            return h


    def D0(self, *args):
        """
        D0(BRepBlend_AppFuncRoot self, Standard_Real const Param, Standard_Real const First, Standard_Real const Last, NCollection_Array1_gp_Pnt Poles, NCollection_Array1_gp_Pnt2d Poles2d, NCollection_Array1_Standard_Real Weigths) -> Standard_Boolean

        compute the section for v = param

        :type Param: float
        :type First: float
        :type Last: float
        :type Poles: OCC.wrapper.TColgp.TColgp_Array1OfPnt
        :type Poles2d: OCC.wrapper.TColgp.TColgp_Array1OfPnt2d
        :type Weigths: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepBlend.BRepBlend_AppFuncRoot_D0(self, *args)


    def D1(self, *args):
        """
        D1(BRepBlend_AppFuncRoot self, Standard_Real const Param, Standard_Real const First, Standard_Real const Last, NCollection_Array1_gp_Pnt Poles, NCollection_Array1_gp_Vec DPoles, NCollection_Array1_gp_Pnt2d Poles2d, NCollection_Array1_gp_Vec2d DPoles2d, NCollection_Array1_Standard_Real Weigths, NCollection_Array1_Standard_Real DWeigths) -> Standard_Boolean

        compute the first  derivative in v direction  of the
        section for v =  param

        :type Param: float
        :type First: float
        :type Last: float
        :type Poles: OCC.wrapper.TColgp.TColgp_Array1OfPnt
        :type DPoles: OCC.wrapper.TColgp.TColgp_Array1OfVec
        :type Poles2d: OCC.wrapper.TColgp.TColgp_Array1OfPnt2d
        :type DPoles2d: OCC.wrapper.TColgp.TColgp_Array1OfVec2d
        :type Weigths: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type DWeigths: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepBlend.BRepBlend_AppFuncRoot_D1(self, *args)


    def D2(self, *args):
        """
        D2(BRepBlend_AppFuncRoot self, Standard_Real const Param, Standard_Real const First, Standard_Real const Last, NCollection_Array1_gp_Pnt Poles, NCollection_Array1_gp_Vec DPoles, NCollection_Array1_gp_Vec D2Poles, NCollection_Array1_gp_Pnt2d Poles2d, NCollection_Array1_gp_Vec2d DPoles2d, NCollection_Array1_gp_Vec2d D2Poles2d, NCollection_Array1_Standard_Real Weigths, NCollection_Array1_Standard_Real DWeigths, NCollection_Array1_Standard_Real D2Weigths) -> Standard_Boolean

        compute the second derivative  in v direction of the
        section  for v = param

        :type Param: float
        :type First: float
        :type Last: float
        :type Poles: OCC.wrapper.TColgp.TColgp_Array1OfPnt
        :type DPoles: OCC.wrapper.TColgp.TColgp_Array1OfVec
        :type D2Poles: OCC.wrapper.TColgp.TColgp_Array1OfVec
        :type Poles2d: OCC.wrapper.TColgp.TColgp_Array1OfPnt2d
        :type DPoles2d: OCC.wrapper.TColgp.TColgp_Array1OfVec2d
        :type D2Poles2d: OCC.wrapper.TColgp.TColgp_Array1OfVec2d
        :type Weigths: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type DWeigths: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type D2Weigths: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepBlend.BRepBlend_AppFuncRoot_D2(self, *args)


    def Nb2dCurves(self, *args):
        """
        Nb2dCurves(BRepBlend_AppFuncRoot self) -> Standard_Integer

        get the number of 2d curves to  approximate.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepBlend.BRepBlend_AppFuncRoot_Nb2dCurves(self, *args)


    def SectionShape(self, *args):
        """
        SectionShape(BRepBlend_AppFuncRoot self)

        get the format of an  section

        :type NbPoles: int
        :type NbKnots: int
        :type Degree: int

        """
        return _BRepBlend.BRepBlend_AppFuncRoot_SectionShape(self, *args)


    def Knots(self, *args):
        """
        Knots(BRepBlend_AppFuncRoot self, NCollection_Array1_Standard_Real TKnots)

        get the Knots of the section

        :type TKnots: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        return _BRepBlend.BRepBlend_AppFuncRoot_Knots(self, *args)


    def Mults(self, *args):
        """
        Mults(BRepBlend_AppFuncRoot self, NCollection_Array1_Standard_Integer TMults)

        get the Multplicities of the section

        :type TMults: OCC.wrapper.TColStd.TColStd_Array1OfInteger

        """
        return _BRepBlend.BRepBlend_AppFuncRoot_Mults(self, *args)


    def IsRational(self, *args):
        """
        IsRational(BRepBlend_AppFuncRoot self) -> Standard_Boolean

        Returns if the section is rationnal or not

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepBlend.BRepBlend_AppFuncRoot_IsRational(self, *args)


    def NbIntervals(self, *args):
        """
        NbIntervals(BRepBlend_AppFuncRoot self, GeomAbs_Shape const S) -> Standard_Integer

        Returns  the number  of  intervals for  continuity
        <S>. May be one if Continuity(me) >= <S>

        :type S: OCC.wrapper.GeomAbs.GeomAbs_Shape
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepBlend.BRepBlend_AppFuncRoot_NbIntervals(self, *args)


    def Intervals(self, *args):
        """
        Intervals(BRepBlend_AppFuncRoot self, NCollection_Array1_Standard_Real T, GeomAbs_Shape const S)

        Stores in <T> the  parameters bounding the intervals
        of continuity <S>.

        The array must provide  enough room to  accomodate
        for the parameters. i.e. T.Length() > NbIntervals()

        :type T: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type S: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _BRepBlend.BRepBlend_AppFuncRoot_Intervals(self, *args)


    def SetInterval(self, *args):
        """
        SetInterval(BRepBlend_AppFuncRoot self, Standard_Real const First, Standard_Real const Last)

        Sets the bounds of the parametric interval on
        the fonction
        This determines the derivatives in these values if the
        function is not Cn.

        :type First: float
        :type Last: float

        """
        return _BRepBlend.BRepBlend_AppFuncRoot_SetInterval(self, *args)


    def Resolution(self, *args):
        """
        Resolution(BRepBlend_AppFuncRoot self, Standard_Integer const Index, Standard_Real const Tol)

        Returns the resolutions in the  sub-space 2d <Index> --
        This information is usfull to find an good tolerance in
        2d approximation

        :type Index: int
        :type Tol: float
        :type TolU: float
        :type TolV: float

        """
        return _BRepBlend.BRepBlend_AppFuncRoot_Resolution(self, *args)


    def GetTolerance(self, *args):
        """
        GetTolerance(BRepBlend_AppFuncRoot self, Standard_Real const BoundTol, Standard_Real const SurfTol, Standard_Real const AngleTol, NCollection_Array1_Standard_Real Tol3d)

        Returns the tolerance to reach in approximation
        to respecte
        BoundTol error at the Boundary
        AngleTol tangent error at the Boundary (in radian)
        SurfTol error inside the surface.

        :type BoundTol: float
        :type SurfTol: float
        :type AngleTol: float
        :type Tol3d: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        return _BRepBlend.BRepBlend_AppFuncRoot_GetTolerance(self, *args)


    def SetTolerance(self, *args):
        """
        SetTolerance(BRepBlend_AppFuncRoot self, Standard_Real const Tol3d, Standard_Real const Tol2d)

        Is usfull, if (me) have to  be run numerical
        algorithme to perform D0, D1 or D2

        :type Tol3d: float
        :type Tol2d: float

        """
        return _BRepBlend.BRepBlend_AppFuncRoot_SetTolerance(self, *args)


    def BarycentreOfSurf(self, *args):
        """
        BarycentreOfSurf(BRepBlend_AppFuncRoot self) -> gp_Pnt

        Get    the   barycentre of   Surface.   An   very  poor
        estimation is sufficent. This information is usefull
        to perform well conditionned rational approximation.

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _BRepBlend.BRepBlend_AppFuncRoot_BarycentreOfSurf(self, *args)


    def MaximalSection(self, *args):
        """
        MaximalSection(BRepBlend_AppFuncRoot self) -> Standard_Real

        Returns the   length of the maximum section. This
        information is usefull to perform well conditionned rational
        approximation.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _BRepBlend.BRepBlend_AppFuncRoot_MaximalSection(self, *args)


    def GetMinimalWeight(self, *args):
        """
        GetMinimalWeight(BRepBlend_AppFuncRoot self, NCollection_Array1_Standard_Real Weigths)

        Compute the minimal value of weight for each poles
        of all  sections.  This information is  usefull to
        perform well conditionned rational approximation.

        :type Weigths: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        return _BRepBlend.BRepBlend_AppFuncRoot_GetMinimalWeight(self, *args)


    def Point(self, *args):
        """
        Point(BRepBlend_AppFuncRoot self, Blend_AppFunction Func, Standard_Real const Param, math_Vector Sol, Blend_Point Pnt)

        :type Func: OCC.wrapper.Blend.Blend_AppFunction
        :type Param: float
        :type Sol: OCC.wrapper.math.math_Vector
        :type Pnt: OCC.wrapper.Blend.Blend_Point

        """
        return _BRepBlend.BRepBlend_AppFuncRoot_Point(self, *args)


    def Vec(self, *args):
        """
        Vec(BRepBlend_AppFuncRoot self, math_Vector Sol, Blend_Point Pnt)

        :type Sol: OCC.wrapper.math.math_Vector
        :type Pnt: OCC.wrapper.Blend.Blend_Point

        """
        return _BRepBlend.BRepBlend_AppFuncRoot_Vec(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _BRepBlend.BRepBlend_AppFuncRoot_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _BRepBlend.BRepBlend_AppFuncRoot_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _BRepBlend.BRepBlend_AppFuncRoot_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _BRepBlend.delete_BRepBlend_AppFuncRoot
BRepBlend_AppFuncRoot_swigregister = _BRepBlend.BRepBlend_AppFuncRoot_swigregister
BRepBlend_AppFuncRoot_swigregister(BRepBlend_AppFuncRoot)

def BRepBlend_AppFuncRoot_get_type_name(*args):
    """
    BRepBlend_AppFuncRoot_get_type_name() -> char const *

    :rtype: const char *

    """
    return _BRepBlend.BRepBlend_AppFuncRoot_get_type_name(*args)

def BRepBlend_AppFuncRoot_get_type_descriptor(*args):
    """
    BRepBlend_AppFuncRoot_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _BRepBlend.BRepBlend_AppFuncRoot_get_type_descriptor(*args)

class BRepBlend_AppFunc(BRepBlend_AppFuncRoot):
    """
    Function to approximate by AppSurface
    for Surface/Surface contact.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_BRepBlend_AppFunc
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_BRepBlend_AppFunc(self) 
            return h


    def __init__(self, *args):
        """
        __init__(BRepBlend_AppFunc self, Handle_BRepBlend_Line Line, Blend_Function Func, Standard_Real const Tol3d, Standard_Real const Tol2d) -> BRepBlend_AppFunc

        :type Line: OCC.wrapper.BRepBlend.Handle_BRepBlend_Line
        :type Func: OCC.wrapper.Blend.Blend_Function
        :type Tol3d: float
        :type Tol2d: float

        """
        this = _BRepBlend.new_BRepBlend_AppFunc(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Point(self, *args):
        """
        Point(BRepBlend_AppFunc self, Blend_AppFunction Func, Standard_Real const Param, math_Vector Sol, Blend_Point Pnt)

        :type Func: OCC.wrapper.Blend.Blend_AppFunction
        :type Param: float
        :type Sol: OCC.wrapper.math.math_Vector
        :type Pnt: OCC.wrapper.Blend.Blend_Point

        """
        return _BRepBlend.BRepBlend_AppFunc_Point(self, *args)


    def Vec(self, *args):
        """
        Vec(BRepBlend_AppFunc self, math_Vector Sol, Blend_Point Pnt)

        :type Sol: OCC.wrapper.math.math_Vector
        :type Pnt: OCC.wrapper.Blend.Blend_Point

        """
        return _BRepBlend.BRepBlend_AppFunc_Vec(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _BRepBlend.BRepBlend_AppFunc_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _BRepBlend.BRepBlend_AppFunc_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _BRepBlend.BRepBlend_AppFunc_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _BRepBlend.delete_BRepBlend_AppFunc
BRepBlend_AppFunc_swigregister = _BRepBlend.BRepBlend_AppFunc_swigregister
BRepBlend_AppFunc_swigregister(BRepBlend_AppFunc)

def BRepBlend_AppFunc_get_type_name(*args):
    """
    BRepBlend_AppFunc_get_type_name() -> char const *

    :rtype: const char *

    """
    return _BRepBlend.BRepBlend_AppFunc_get_type_name(*args)

def BRepBlend_AppFunc_get_type_descriptor(*args):
    """
    BRepBlend_AppFunc_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _BRepBlend.BRepBlend_AppFunc_get_type_descriptor(*args)

class BRepBlend_AppSurface(AppBlend.AppBlend_Approx):
    """Used to Approximate the blending surfaces."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BRepBlend_AppSurface self, Handle_Approx_SweepFunction Funct, Standard_Real const First, Standard_Real const Last, Standard_Real const Tol3d, Standard_Real const Tol2d, Standard_Real const TolAngular, GeomAbs_Shape const Continuity=GeomAbs_C0, Standard_Integer const Degmax=11, Standard_Integer const Segmax=50) -> BRepBlend_AppSurface

        Approximation     of   the   new  Surface  (and
        eventually the  2d    Curves   on the   support
        surfaces).
        Normaly     the  2d    curve are
        approximated  with an  tolerance   given  by   the
        resolution on   support surfaces,  but  if this
        tolerance is too large Tol2d  is used.

        :type Funct: OCC.wrapper.Approx.Handle_Approx_SweepFunction
        :type First: float
        :type Last: float
        :type Tol3d: float
        :type Tol2d: float
        :type TolAngular: float
        :type Continuity: OCC.wrapper.GeomAbs.GeomAbs_Shape
        :type Degmax: int
        :type Segmax: int

        """
        this = _BRepBlend.new_BRepBlend_AppSurface(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def IsDone(self, *args):
        """
        IsDone(BRepBlend_AppSurface self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepBlend.BRepBlend_AppSurface_IsDone(self, *args)


    def SurfShape(self, *args):
        """
        SurfShape(BRepBlend_AppSurface self)

        :type UDegree: int
        :type VDegree: int
        :type NbUPoles: int
        :type NbVPoles: int
        :type NbUKnots: int
        :type NbVKnots: int

        """
        return _BRepBlend.BRepBlend_AppSurface_SurfShape(self, *args)


    def Surface(self, *args):
        """
        Surface(BRepBlend_AppSurface self, NCollection_Array2_gp_Pnt TPoles, NCollection_Array2_Standard_Real TWeights, NCollection_Array1_Standard_Real TUKnots, NCollection_Array1_Standard_Real TVKnots, NCollection_Array1_Standard_Integer TUMults, NCollection_Array1_Standard_Integer TVMults)

        :type TPoles: OCC.wrapper.TColgp.TColgp_Array2OfPnt
        :type TWeights: OCC.wrapper.TColStd.TColStd_Array2OfReal
        :type TUKnots: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type TVKnots: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type TUMults: OCC.wrapper.TColStd.TColStd_Array1OfInteger
        :type TVMults: OCC.wrapper.TColStd.TColStd_Array1OfInteger

        """
        return _BRepBlend.BRepBlend_AppSurface_Surface(self, *args)


    def UDegree(self, *args):
        """
        UDegree(BRepBlend_AppSurface self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepBlend.BRepBlend_AppSurface_UDegree(self, *args)


    def VDegree(self, *args):
        """
        VDegree(BRepBlend_AppSurface self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepBlend.BRepBlend_AppSurface_VDegree(self, *args)


    def SurfPoles(self, *args):
        """
        :rtype: OCC.wrapper.TColgp.TColgp_Array2OfPnt

        """
        res = _BRepBlend.BRepBlend_AppSurface_SurfPoles(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SurfWeights(self, *args):
        """
        :rtype: OCC.wrapper.TColStd.TColStd_Array2OfReal

        """
        res = _BRepBlend.BRepBlend_AppSurface_SurfWeights(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SurfUKnots(self, *args):
        """
        :rtype: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        res = _BRepBlend.BRepBlend_AppSurface_SurfUKnots(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SurfVKnots(self, *args):
        """
        :rtype: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        res = _BRepBlend.BRepBlend_AppSurface_SurfVKnots(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SurfUMults(self, *args):
        """
        :rtype: OCC.wrapper.TColStd.TColStd_Array1OfInteger

        """
        res = _BRepBlend.BRepBlend_AppSurface_SurfUMults(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SurfVMults(self, *args):
        """
        :rtype: OCC.wrapper.TColStd.TColStd_Array1OfInteger

        """
        res = _BRepBlend.BRepBlend_AppSurface_SurfVMults(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def MaxErrorOnSurf(self, *args):
        """
        MaxErrorOnSurf(BRepBlend_AppSurface self) -> Standard_Real

        returns the maximum error in the suface approximation.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _BRepBlend.BRepBlend_AppSurface_MaxErrorOnSurf(self, *args)


    def NbCurves2d(self, *args):
        """
        NbCurves2d(BRepBlend_AppSurface self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepBlend.BRepBlend_AppSurface_NbCurves2d(self, *args)


    def Curves2dShape(self, *args):
        """
        Curves2dShape(BRepBlend_AppSurface self)

        :type Degree: int
        :type NbPoles: int
        :type NbKnots: int

        """
        return _BRepBlend.BRepBlend_AppSurface_Curves2dShape(self, *args)


    def Curve2d(self, *args):
        """
        Curve2d(BRepBlend_AppSurface self, Standard_Integer const Index, NCollection_Array1_gp_Pnt2d TPoles, NCollection_Array1_Standard_Real TKnots, NCollection_Array1_Standard_Integer TMults)

        :type Index: int
        :type TPoles: OCC.wrapper.TColgp.TColgp_Array1OfPnt2d
        :type TKnots: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type TMults: OCC.wrapper.TColStd.TColStd_Array1OfInteger

        """
        return _BRepBlend.BRepBlend_AppSurface_Curve2d(self, *args)


    def Curves2dDegree(self, *args):
        """
        Curves2dDegree(BRepBlend_AppSurface self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepBlend.BRepBlend_AppSurface_Curves2dDegree(self, *args)


    def Curve2dPoles(self, *args):
        """
        :type Index: int
        :rtype: OCC.wrapper.TColgp.TColgp_Array1OfPnt2d

        """
        res = _BRepBlend.BRepBlend_AppSurface_Curve2dPoles(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Curves2dKnots(self, *args):
        """
        :rtype: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        res = _BRepBlend.BRepBlend_AppSurface_Curves2dKnots(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Curves2dMults(self, *args):
        """
        :rtype: OCC.wrapper.TColStd.TColStd_Array1OfInteger

        """
        res = _BRepBlend.BRepBlend_AppSurface_Curves2dMults(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def TolReached(self, *args):
        """
        TolReached(BRepBlend_AppSurface self)

        :type Tol3d: float
        :type Tol2d: float

        """
        return _BRepBlend.BRepBlend_AppSurface_TolReached(self, *args)


    def Max2dError(self, *args):
        """
        Max2dError(BRepBlend_AppSurface self, Standard_Integer const Index) -> Standard_Real

        returns the maximum error in the <Index> 2d curve approximation.

        :type Index: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _BRepBlend.BRepBlend_AppSurface_Max2dError(self, *args)


    def TolCurveOnSurf(self, *args):
        """
        TolCurveOnSurf(BRepBlend_AppSurface self, Standard_Integer const Index) -> Standard_Real

        :type Index: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _BRepBlend.BRepBlend_AppSurface_TolCurveOnSurf(self, *args)


    def Dump(self, *args):
        """
        Dump(BRepBlend_AppSurface self, Standard_OStream & o)

        diplay information on approximation.

        :type o: OCC.wrapper.Standard.Standard_OStream

        """
        return _BRepBlend.BRepBlend_AppSurface_Dump(self, *args)

    __swig_destroy__ = _BRepBlend.delete_BRepBlend_AppSurface
BRepBlend_AppSurface_swigregister = _BRepBlend.BRepBlend_AppSurface_swigregister
BRepBlend_AppSurface_swigregister(BRepBlend_AppSurface)

class BRepBlend_Line(Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_BRepBlend_Line
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_BRepBlend_Line(self) 
            return h


    def __init__(self, *args):
        """__init__(BRepBlend_Line self) -> BRepBlend_Line"""
        this = _BRepBlend.new_BRepBlend_Line(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Clear(self, *args):
        """
        Clear(BRepBlend_Line self)

        Clears the content of the line.


        """
        return _BRepBlend.BRepBlend_Line_Clear(self, *args)


    def Append(self, *args):
        """
        Append(BRepBlend_Line self, Blend_Point P)

        Adds a point in the line.

        :type P: OCC.wrapper.Blend.Blend_Point

        """
        return _BRepBlend.BRepBlend_Line_Append(self, *args)


    def Prepend(self, *args):
        """
        Prepend(BRepBlend_Line self, Blend_Point P)

        Adds a point in the line at the first place.

        :type P: OCC.wrapper.Blend.Blend_Point

        """
        return _BRepBlend.BRepBlend_Line_Prepend(self, *args)


    def InsertBefore(self, *args):
        """
        InsertBefore(BRepBlend_Line self, Standard_Integer const Index, Blend_Point P)

        Adds a point in the line at the first place.

        :type Index: int
        :type P: OCC.wrapper.Blend.Blend_Point

        """
        return _BRepBlend.BRepBlend_Line_InsertBefore(self, *args)


    def Remove(self, *args):
        """
        Remove(BRepBlend_Line self, Standard_Integer const FromIndex, Standard_Integer const ToIndex)

        Removes  from  <me>    all  the  items  of
        positions between <FromIndex> and <ToIndex>.
        Raises an exception if the indices are out of bounds.

        :type FromIndex: int
        :type ToIndex: int

        """
        return _BRepBlend.BRepBlend_Line_Remove(self, *args)


    def Set(self, *args):
        """
        Set(BRepBlend_Line self, IntSurf_TypeTrans const TranS1, IntSurf_TypeTrans const TranS2)
        Set(BRepBlend_Line self, IntSurf_TypeTrans const Trans)

        Sets the value of the transition of the line on a surface

        :type Trans: OCC.wrapper.IntSurf.IntSurf_TypeTrans

        """
        return _BRepBlend.BRepBlend_Line_Set(self, *args)


    def SetStartPoints(self, *args):
        """
        SetStartPoints(BRepBlend_Line self, BRepBlend_Extremity StartPt1, BRepBlend_Extremity StartPt2)

        Sets the values of the start points for the line.

        :type StartPt1: OCC.wrapper.BRepBlend.BRepBlend_Extremity
        :type StartPt2: OCC.wrapper.BRepBlend.BRepBlend_Extremity

        """
        return _BRepBlend.BRepBlend_Line_SetStartPoints(self, *args)


    def SetEndPoints(self, *args):
        """
        SetEndPoints(BRepBlend_Line self, BRepBlend_Extremity EndPt1, BRepBlend_Extremity EndPt2)

        Sets tne values of the end points for the line.

        :type EndPt1: OCC.wrapper.BRepBlend.BRepBlend_Extremity
        :type EndPt2: OCC.wrapper.BRepBlend.BRepBlend_Extremity

        """
        return _BRepBlend.BRepBlend_Line_SetEndPoints(self, *args)


    def NbPoints(self, *args):
        """
        NbPoints(BRepBlend_Line self) -> Standard_Integer

        Returns the number of points in the line.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepBlend.BRepBlend_Line_NbPoints(self, *args)


    def Point(self, *args):
        """
        Returns the point of range Index.

        :type Index: int
        :rtype: OCC.wrapper.Blend.Blend_Point

        """
        res = _BRepBlend.BRepBlend_Line_Point(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def TransitionOnS1(self, *args):
        """
        TransitionOnS1(BRepBlend_Line self) -> IntSurf_TypeTrans

        Returns the type of the transition of the line defined
        on the first surface. The transition is "constant"
        along the line.
        The transition is IN if the line is oriented in such
        a way that the system of vectors (N,DRac,T) is
        right-handed, where
        N is the normal to the first surface at a point P,
        DRac is a vector tangent to the blending patch,
        oriented towards the valid part of this patch,
        T  is the tangent to the line on S1 at P.
        The transitioon is OUT when the system of vectors is
        left-handed.

        :rtype: OCC.wrapper.IntSurf.IntSurf_TypeTrans

        """
        return _BRepBlend.BRepBlend_Line_TransitionOnS1(self, *args)


    def TransitionOnS2(self, *args):
        """
        TransitionOnS2(BRepBlend_Line self) -> IntSurf_TypeTrans

        Returns the type of the transition of the line defined
        on the second surface. The transition is "constant"
        along the line.

        :rtype: OCC.wrapper.IntSurf.IntSurf_TypeTrans

        """
        return _BRepBlend.BRepBlend_Line_TransitionOnS2(self, *args)


    def StartPointOnFirst(self, *args):
        """
        Returns the start point on S1.

        :rtype: OCC.wrapper.BRepBlend.BRepBlend_Extremity

        """
        res = _BRepBlend.BRepBlend_Line_StartPointOnFirst(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def StartPointOnSecond(self, *args):
        """
        Returns the start point on S2

        :rtype: OCC.wrapper.BRepBlend.BRepBlend_Extremity

        """
        res = _BRepBlend.BRepBlend_Line_StartPointOnSecond(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def EndPointOnFirst(self, *args):
        """
        Returns the end point on S1.

        :rtype: OCC.wrapper.BRepBlend.BRepBlend_Extremity

        """
        res = _BRepBlend.BRepBlend_Line_EndPointOnFirst(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def EndPointOnSecond(self, *args):
        """
        Returns the point on S2.

        :rtype: OCC.wrapper.BRepBlend.BRepBlend_Extremity

        """
        res = _BRepBlend.BRepBlend_Line_EndPointOnSecond(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def TransitionOnS(self, *args):
        """
        TransitionOnS(BRepBlend_Line self) -> IntSurf_TypeTrans

        Returns the type of the transition of the line defined
        on the surface.

        :rtype: OCC.wrapper.IntSurf.IntSurf_TypeTrans

        """
        return _BRepBlend.BRepBlend_Line_TransitionOnS(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _BRepBlend.BRepBlend_Line_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _BRepBlend.BRepBlend_Line_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _BRepBlend.BRepBlend_Line_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _BRepBlend.delete_BRepBlend_Line
BRepBlend_Line_swigregister = _BRepBlend.BRepBlend_Line_swigregister
BRepBlend_Line_swigregister(BRepBlend_Line)

def BRepBlend_Line_get_type_name(*args):
    """
    BRepBlend_Line_get_type_name() -> char const *

    :rtype: const char *

    """
    return _BRepBlend.BRepBlend_Line_get_type_name(*args)

def BRepBlend_Line_get_type_descriptor(*args):
    """
    BRepBlend_Line_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _BRepBlend.BRepBlend_Line_get_type_descriptor(*args)

class BRepBlend_HCurveTool(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def FirstParameter(*args):
        """
        FirstParameter(Handle_Adaptor3d_HCurve C) -> Standard_Real

        :type C: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HCurve
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _BRepBlend.BRepBlend_HCurveTool_FirstParameter(*args)

    FirstParameter = staticmethod(FirstParameter)

    def LastParameter(*args):
        """
        LastParameter(Handle_Adaptor3d_HCurve C) -> Standard_Real

        :type C: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HCurve
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _BRepBlend.BRepBlend_HCurveTool_LastParameter(*args)

    LastParameter = staticmethod(LastParameter)

    def Continuity(*args):
        """
        Continuity(Handle_Adaptor3d_HCurve C) -> GeomAbs_Shape

        :type C: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HCurve
        :rtype: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _BRepBlend.BRepBlend_HCurveTool_Continuity(*args)

    Continuity = staticmethod(Continuity)

    def NbIntervals(*args):
        """
        NbIntervals(Handle_Adaptor3d_HCurve C, GeomAbs_Shape const S) -> Standard_Integer

        Returns  the number  of  intervals for  continuity
        <S>. May be one if Continuity(myclass) >= <S>

        :type C: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HCurve
        :type S: OCC.wrapper.GeomAbs.GeomAbs_Shape
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepBlend.BRepBlend_HCurveTool_NbIntervals(*args)

    NbIntervals = staticmethod(NbIntervals)

    def Intervals(*args):
        """
        Intervals(Handle_Adaptor3d_HCurve C, NCollection_Array1_Standard_Real T, GeomAbs_Shape const S)

        Stores in <T> the  parameters bounding the intervals
        of continuity <S>.

        The array must provide  enough room to  accomodate
        for the parameters. i.e. T.Length() > NbIntervals()

        :type C: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HCurve
        :type T: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type S: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _BRepBlend.BRepBlend_HCurveTool_Intervals(*args)

    Intervals = staticmethod(Intervals)

    def IsClosed(*args):
        """
        IsClosed(Handle_Adaptor3d_HCurve C) -> Standard_Boolean

        :type C: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HCurve
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepBlend.BRepBlend_HCurveTool_IsClosed(*args)

    IsClosed = staticmethod(IsClosed)

    def IsPeriodic(*args):
        """
        IsPeriodic(Handle_Adaptor3d_HCurve C) -> Standard_Boolean

        :type C: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HCurve
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepBlend.BRepBlend_HCurveTool_IsPeriodic(*args)

    IsPeriodic = staticmethod(IsPeriodic)

    def Period(*args):
        """
        Period(Handle_Adaptor3d_HCurve C) -> Standard_Real

        :type C: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HCurve
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _BRepBlend.BRepBlend_HCurveTool_Period(*args)

    Period = staticmethod(Period)

    def Value(*args):
        """
        Value(Handle_Adaptor3d_HCurve C, Standard_Real const U) -> gp_Pnt

        Computes the point of parameter U on the curve.

        :type C: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HCurve
        :type U: float
        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _BRepBlend.BRepBlend_HCurveTool_Value(*args)

    Value = staticmethod(Value)

    def D0(*args):
        """
        D0(Handle_Adaptor3d_HCurve C, Standard_Real const U, gp_Pnt P)

        Computes the point of parameter U on the curve.

        :type C: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HCurve
        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt

        """
        return _BRepBlend.BRepBlend_HCurveTool_D0(*args)

    D0 = staticmethod(D0)

    def D1(*args):
        """
        D1(Handle_Adaptor3d_HCurve C, Standard_Real const U, gp_Pnt P, gp_Vec V)

        Computes the point of parameter U on the curve with its
        first derivative.
        Raised if the continuity of the current interval
        is not C1.

        :type C: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HCurve
        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type V: OCC.wrapper.gp.gp_Vec

        """
        return _BRepBlend.BRepBlend_HCurveTool_D1(*args)

    D1 = staticmethod(D1)

    def D2(*args):
        """
        D2(Handle_Adaptor3d_HCurve C, Standard_Real const U, gp_Pnt P, gp_Vec V1, gp_Vec V2)

        Returns the point P of parameter U, the first and second
        derivatives V1 and V2.
        Raised if the continuity of the current interval
        is not C2.

        :type C: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HCurve
        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type V1: OCC.wrapper.gp.gp_Vec
        :type V2: OCC.wrapper.gp.gp_Vec

        """
        return _BRepBlend.BRepBlend_HCurveTool_D2(*args)

    D2 = staticmethod(D2)

    def D3(*args):
        """
        D3(Handle_Adaptor3d_HCurve C, Standard_Real const U, gp_Pnt P, gp_Vec V1, gp_Vec V2, gp_Vec V3)

        Returns the point P of parameter U, the first, the second
        and the third derivative.
        Raised if the continuity of the current interval
        is not C3.

        :type C: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HCurve
        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type V1: OCC.wrapper.gp.gp_Vec
        :type V2: OCC.wrapper.gp.gp_Vec
        :type V3: OCC.wrapper.gp.gp_Vec

        """
        return _BRepBlend.BRepBlend_HCurveTool_D3(*args)

    D3 = staticmethod(D3)

    def DN(*args):
        """
        DN(Handle_Adaptor3d_HCurve C, Standard_Real const U, Standard_Integer const N) -> gp_Vec

        The returned vector gives the value of the derivative for the
        order of derivation N.
        Raised if the continuity of the current interval
        is not CN.
        Raised if N < 1.

        :type C: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HCurve
        :type U: float
        :type N: int
        :rtype: OCC.wrapper.gp.gp_Vec

        """
        return _BRepBlend.BRepBlend_HCurveTool_DN(*args)

    DN = staticmethod(DN)

    def Resolution(*args):
        """
        Resolution(Handle_Adaptor3d_HCurve C, Standard_Real const R3d) -> Standard_Real

        Returns the parametric  resolution corresponding
        to the real space resolution <R3d>.

        :type C: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HCurve
        :type R3d: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _BRepBlend.BRepBlend_HCurveTool_Resolution(*args)

    Resolution = staticmethod(Resolution)

    def GetType(*args):
        """
        GetType(Handle_Adaptor3d_HCurve C) -> GeomAbs_CurveType

        Returns  the  type of the   curve  in the  current
        interval :   Line,   Circle,   Ellipse, Hyperbola,
        Parabola, BezierCurve, BSplineCurve, OtherCurve.

        :type C: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HCurve
        :rtype: OCC.wrapper.GeomAbs.GeomAbs_CurveType

        """
        return _BRepBlend.BRepBlend_HCurveTool_GetType(*args)

    GetType = staticmethod(GetType)

    def Line(*args):
        """
        Line(Handle_Adaptor3d_HCurve C) -> gp_Lin

        :type C: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HCurve
        :rtype: OCC.wrapper.gp.gp_Lin

        """
        return _BRepBlend.BRepBlend_HCurveTool_Line(*args)

    Line = staticmethod(Line)

    def Circle(*args):
        """
        Circle(Handle_Adaptor3d_HCurve C) -> gp_Circ

        :type C: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HCurve
        :rtype: OCC.wrapper.gp.gp_Circ

        """
        return _BRepBlend.BRepBlend_HCurveTool_Circle(*args)

    Circle = staticmethod(Circle)

    def Ellipse(*args):
        """
        Ellipse(Handle_Adaptor3d_HCurve C) -> gp_Elips

        :type C: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HCurve
        :rtype: OCC.wrapper.gp.gp_Elips

        """
        return _BRepBlend.BRepBlend_HCurveTool_Ellipse(*args)

    Ellipse = staticmethod(Ellipse)

    def Hyperbola(*args):
        """
        Hyperbola(Handle_Adaptor3d_HCurve C) -> gp_Hypr

        :type C: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HCurve
        :rtype: OCC.wrapper.gp.gp_Hypr

        """
        return _BRepBlend.BRepBlend_HCurveTool_Hyperbola(*args)

    Hyperbola = staticmethod(Hyperbola)

    def Parabola(*args):
        """
        Parabola(Handle_Adaptor3d_HCurve C) -> gp_Parab

        :type C: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HCurve
        :rtype: OCC.wrapper.gp.gp_Parab

        """
        return _BRepBlend.BRepBlend_HCurveTool_Parabola(*args)

    Parabola = staticmethod(Parabola)

    def Bezier(*args):
        """
        Bezier(Handle_Adaptor3d_HCurve C) -> Handle_Geom_BezierCurve

        :type C: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HCurve
        :rtype: OCC.wrapper.Geom.Handle_Geom_BezierCurve

        """
        return _BRepBlend.BRepBlend_HCurveTool_Bezier(*args)

    Bezier = staticmethod(Bezier)

    def BSpline(*args):
        """
        BSpline(Handle_Adaptor3d_HCurve C) -> Handle_Geom_BSplineCurve

        :type C: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HCurve
        :rtype: OCC.wrapper.Geom.Handle_Geom_BSplineCurve

        """
        return _BRepBlend.BRepBlend_HCurveTool_BSpline(*args)

    BSpline = staticmethod(BSpline)

    def NbSamples(*args):
        """
        NbSamples(Handle_Adaptor3d_HCurve C, Standard_Real const U0, Standard_Real const U1) -> Standard_Integer

        :type C: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HCurve
        :type U0: float
        :type U1: float
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepBlend.BRepBlend_HCurveTool_NbSamples(*args)

    NbSamples = staticmethod(NbSamples)

    def __init__(self):
        this = _BRepBlend.new_BRepBlend_HCurveTool()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _BRepBlend.delete_BRepBlend_HCurveTool
BRepBlend_HCurveTool_swigregister = _BRepBlend.BRepBlend_HCurveTool_swigregister
BRepBlend_HCurveTool_swigregister(BRepBlend_HCurveTool)

def BRepBlend_HCurveTool_FirstParameter(*args):
    """
    BRepBlend_HCurveTool_FirstParameter(Handle_Adaptor3d_HCurve C) -> Standard_Real

    :type C: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HCurve
    :rtype: OCC.wrapper.Standard.Standard_Real

    """
    return _BRepBlend.BRepBlend_HCurveTool_FirstParameter(*args)

def BRepBlend_HCurveTool_LastParameter(*args):
    """
    BRepBlend_HCurveTool_LastParameter(Handle_Adaptor3d_HCurve C) -> Standard_Real

    :type C: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HCurve
    :rtype: OCC.wrapper.Standard.Standard_Real

    """
    return _BRepBlend.BRepBlend_HCurveTool_LastParameter(*args)

def BRepBlend_HCurveTool_Continuity(*args):
    """
    BRepBlend_HCurveTool_Continuity(Handle_Adaptor3d_HCurve C) -> GeomAbs_Shape

    :type C: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HCurve
    :rtype: OCC.wrapper.GeomAbs.GeomAbs_Shape

    """
    return _BRepBlend.BRepBlend_HCurveTool_Continuity(*args)

def BRepBlend_HCurveTool_NbIntervals(*args):
    """
    BRepBlend_HCurveTool_NbIntervals(Handle_Adaptor3d_HCurve C, GeomAbs_Shape const S) -> Standard_Integer

    Returns  the number  of  intervals for  continuity
    <S>. May be one if Continuity(myclass) >= <S>

    :type C: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HCurve
    :type S: OCC.wrapper.GeomAbs.GeomAbs_Shape
    :rtype: OCC.wrapper.Standard.Standard_Integer

    """
    return _BRepBlend.BRepBlend_HCurveTool_NbIntervals(*args)

def BRepBlend_HCurveTool_Intervals(*args):
    """
    BRepBlend_HCurveTool_Intervals(Handle_Adaptor3d_HCurve C, NCollection_Array1_Standard_Real T, GeomAbs_Shape const S)

    Stores in <T> the  parameters bounding the intervals
    of continuity <S>.

    The array must provide  enough room to  accomodate
    for the parameters. i.e. T.Length() > NbIntervals()

    :type C: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HCurve
    :type T: OCC.wrapper.TColStd.TColStd_Array1OfReal
    :type S: OCC.wrapper.GeomAbs.GeomAbs_Shape

    """
    return _BRepBlend.BRepBlend_HCurveTool_Intervals(*args)

def BRepBlend_HCurveTool_IsClosed(*args):
    """
    BRepBlend_HCurveTool_IsClosed(Handle_Adaptor3d_HCurve C) -> Standard_Boolean

    :type C: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HCurve
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _BRepBlend.BRepBlend_HCurveTool_IsClosed(*args)

def BRepBlend_HCurveTool_IsPeriodic(*args):
    """
    BRepBlend_HCurveTool_IsPeriodic(Handle_Adaptor3d_HCurve C) -> Standard_Boolean

    :type C: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HCurve
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _BRepBlend.BRepBlend_HCurveTool_IsPeriodic(*args)

def BRepBlend_HCurveTool_Period(*args):
    """
    BRepBlend_HCurveTool_Period(Handle_Adaptor3d_HCurve C) -> Standard_Real

    :type C: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HCurve
    :rtype: OCC.wrapper.Standard.Standard_Real

    """
    return _BRepBlend.BRepBlend_HCurveTool_Period(*args)

def BRepBlend_HCurveTool_Value(*args):
    """
    BRepBlend_HCurveTool_Value(Handle_Adaptor3d_HCurve C, Standard_Real const U) -> gp_Pnt

    Computes the point of parameter U on the curve.

    :type C: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HCurve
    :type U: float
    :rtype: OCC.wrapper.gp.gp_Pnt

    """
    return _BRepBlend.BRepBlend_HCurveTool_Value(*args)

def BRepBlend_HCurveTool_D0(*args):
    """
    BRepBlend_HCurveTool_D0(Handle_Adaptor3d_HCurve C, Standard_Real const U, gp_Pnt P)

    Computes the point of parameter U on the curve.

    :type C: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HCurve
    :type U: float
    :type P: OCC.wrapper.gp.gp_Pnt

    """
    return _BRepBlend.BRepBlend_HCurveTool_D0(*args)

def BRepBlend_HCurveTool_D1(*args):
    """
    BRepBlend_HCurveTool_D1(Handle_Adaptor3d_HCurve C, Standard_Real const U, gp_Pnt P, gp_Vec V)

    Computes the point of parameter U on the curve with its
    first derivative.
    Raised if the continuity of the current interval
    is not C1.

    :type C: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HCurve
    :type U: float
    :type P: OCC.wrapper.gp.gp_Pnt
    :type V: OCC.wrapper.gp.gp_Vec

    """
    return _BRepBlend.BRepBlend_HCurveTool_D1(*args)

def BRepBlend_HCurveTool_D2(*args):
    """
    BRepBlend_HCurveTool_D2(Handle_Adaptor3d_HCurve C, Standard_Real const U, gp_Pnt P, gp_Vec V1, gp_Vec V2)

    Returns the point P of parameter U, the first and second
    derivatives V1 and V2.
    Raised if the continuity of the current interval
    is not C2.

    :type C: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HCurve
    :type U: float
    :type P: OCC.wrapper.gp.gp_Pnt
    :type V1: OCC.wrapper.gp.gp_Vec
    :type V2: OCC.wrapper.gp.gp_Vec

    """
    return _BRepBlend.BRepBlend_HCurveTool_D2(*args)

def BRepBlend_HCurveTool_D3(*args):
    """
    BRepBlend_HCurveTool_D3(Handle_Adaptor3d_HCurve C, Standard_Real const U, gp_Pnt P, gp_Vec V1, gp_Vec V2, gp_Vec V3)

    Returns the point P of parameter U, the first, the second
    and the third derivative.
    Raised if the continuity of the current interval
    is not C3.

    :type C: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HCurve
    :type U: float
    :type P: OCC.wrapper.gp.gp_Pnt
    :type V1: OCC.wrapper.gp.gp_Vec
    :type V2: OCC.wrapper.gp.gp_Vec
    :type V3: OCC.wrapper.gp.gp_Vec

    """
    return _BRepBlend.BRepBlend_HCurveTool_D3(*args)

def BRepBlend_HCurveTool_DN(*args):
    """
    BRepBlend_HCurveTool_DN(Handle_Adaptor3d_HCurve C, Standard_Real const U, Standard_Integer const N) -> gp_Vec

    The returned vector gives the value of the derivative for the
    order of derivation N.
    Raised if the continuity of the current interval
    is not CN.
    Raised if N < 1.

    :type C: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HCurve
    :type U: float
    :type N: int
    :rtype: OCC.wrapper.gp.gp_Vec

    """
    return _BRepBlend.BRepBlend_HCurveTool_DN(*args)

def BRepBlend_HCurveTool_Resolution(*args):
    """
    BRepBlend_HCurveTool_Resolution(Handle_Adaptor3d_HCurve C, Standard_Real const R3d) -> Standard_Real

    Returns the parametric  resolution corresponding
    to the real space resolution <R3d>.

    :type C: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HCurve
    :type R3d: float
    :rtype: OCC.wrapper.Standard.Standard_Real

    """
    return _BRepBlend.BRepBlend_HCurveTool_Resolution(*args)

def BRepBlend_HCurveTool_GetType(*args):
    """
    BRepBlend_HCurveTool_GetType(Handle_Adaptor3d_HCurve C) -> GeomAbs_CurveType

    Returns  the  type of the   curve  in the  current
    interval :   Line,   Circle,   Ellipse, Hyperbola,
    Parabola, BezierCurve, BSplineCurve, OtherCurve.

    :type C: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HCurve
    :rtype: OCC.wrapper.GeomAbs.GeomAbs_CurveType

    """
    return _BRepBlend.BRepBlend_HCurveTool_GetType(*args)

def BRepBlend_HCurveTool_Line(*args):
    """
    BRepBlend_HCurveTool_Line(Handle_Adaptor3d_HCurve C) -> gp_Lin

    :type C: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HCurve
    :rtype: OCC.wrapper.gp.gp_Lin

    """
    return _BRepBlend.BRepBlend_HCurveTool_Line(*args)

def BRepBlend_HCurveTool_Circle(*args):
    """
    BRepBlend_HCurveTool_Circle(Handle_Adaptor3d_HCurve C) -> gp_Circ

    :type C: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HCurve
    :rtype: OCC.wrapper.gp.gp_Circ

    """
    return _BRepBlend.BRepBlend_HCurveTool_Circle(*args)

def BRepBlend_HCurveTool_Ellipse(*args):
    """
    BRepBlend_HCurveTool_Ellipse(Handle_Adaptor3d_HCurve C) -> gp_Elips

    :type C: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HCurve
    :rtype: OCC.wrapper.gp.gp_Elips

    """
    return _BRepBlend.BRepBlend_HCurveTool_Ellipse(*args)

def BRepBlend_HCurveTool_Hyperbola(*args):
    """
    BRepBlend_HCurveTool_Hyperbola(Handle_Adaptor3d_HCurve C) -> gp_Hypr

    :type C: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HCurve
    :rtype: OCC.wrapper.gp.gp_Hypr

    """
    return _BRepBlend.BRepBlend_HCurveTool_Hyperbola(*args)

def BRepBlend_HCurveTool_Parabola(*args):
    """
    BRepBlend_HCurveTool_Parabola(Handle_Adaptor3d_HCurve C) -> gp_Parab

    :type C: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HCurve
    :rtype: OCC.wrapper.gp.gp_Parab

    """
    return _BRepBlend.BRepBlend_HCurveTool_Parabola(*args)

def BRepBlend_HCurveTool_Bezier(*args):
    """
    BRepBlend_HCurveTool_Bezier(Handle_Adaptor3d_HCurve C) -> Handle_Geom_BezierCurve

    :type C: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HCurve
    :rtype: OCC.wrapper.Geom.Handle_Geom_BezierCurve

    """
    return _BRepBlend.BRepBlend_HCurveTool_Bezier(*args)

def BRepBlend_HCurveTool_BSpline(*args):
    """
    BRepBlend_HCurveTool_BSpline(Handle_Adaptor3d_HCurve C) -> Handle_Geom_BSplineCurve

    :type C: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HCurve
    :rtype: OCC.wrapper.Geom.Handle_Geom_BSplineCurve

    """
    return _BRepBlend.BRepBlend_HCurveTool_BSpline(*args)

def BRepBlend_HCurveTool_NbSamples(*args):
    """
    BRepBlend_HCurveTool_NbSamples(Handle_Adaptor3d_HCurve C, Standard_Real const U0, Standard_Real const U1) -> Standard_Integer

    :type C: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HCurve
    :type U0: float
    :type U1: float
    :rtype: OCC.wrapper.Standard.Standard_Integer

    """
    return _BRepBlend.BRepBlend_HCurveTool_NbSamples(*args)

class BRepBlend_AppFuncRst(BRepBlend_AppFuncRoot):
    """Function  to approximate by AppSurface  for Curve/Surface contact."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_BRepBlend_AppFuncRst
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_BRepBlend_AppFuncRst(self) 
            return h


    def __init__(self, *args):
        """
        __init__(BRepBlend_AppFuncRst self, Handle_BRepBlend_Line Line, Blend_SurfRstFunction Func, Standard_Real const Tol3d, Standard_Real const Tol2d) -> BRepBlend_AppFuncRst

        :type Line: OCC.wrapper.BRepBlend.Handle_BRepBlend_Line
        :type Func: OCC.wrapper.Blend.Blend_SurfRstFunction
        :type Tol3d: float
        :type Tol2d: float

        """
        this = _BRepBlend.new_BRepBlend_AppFuncRst(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Point(self, *args):
        """
        Point(BRepBlend_AppFuncRst self, Blend_AppFunction Func, Standard_Real const Param, math_Vector Sol, Blend_Point Pnt)

        :type Func: OCC.wrapper.Blend.Blend_AppFunction
        :type Param: float
        :type Sol: OCC.wrapper.math.math_Vector
        :type Pnt: OCC.wrapper.Blend.Blend_Point

        """
        return _BRepBlend.BRepBlend_AppFuncRst_Point(self, *args)


    def Vec(self, *args):
        """
        Vec(BRepBlend_AppFuncRst self, math_Vector Sol, Blend_Point Pnt)

        :type Sol: OCC.wrapper.math.math_Vector
        :type Pnt: OCC.wrapper.Blend.Blend_Point

        """
        return _BRepBlend.BRepBlend_AppFuncRst_Vec(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _BRepBlend.BRepBlend_AppFuncRst_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _BRepBlend.BRepBlend_AppFuncRst_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _BRepBlend.BRepBlend_AppFuncRst_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _BRepBlend.delete_BRepBlend_AppFuncRst
BRepBlend_AppFuncRst_swigregister = _BRepBlend.BRepBlend_AppFuncRst_swigregister
BRepBlend_AppFuncRst_swigregister(BRepBlend_AppFuncRst)

def BRepBlend_AppFuncRst_get_type_name(*args):
    """
    BRepBlend_AppFuncRst_get_type_name() -> char const *

    :rtype: const char *

    """
    return _BRepBlend.BRepBlend_AppFuncRst_get_type_name(*args)

def BRepBlend_AppFuncRst_get_type_descriptor(*args):
    """
    BRepBlend_AppFuncRst_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _BRepBlend.BRepBlend_AppFuncRst_get_type_descriptor(*args)

class BRepBlend_BlendTool(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Project(*args):
        """
        Project(gp_Pnt2d P, Handle_Adaptor3d_HSurface S, Handle_Adaptor2d_HCurve2d C) -> Standard_Boolean

        Projects the point P on the arc C.
        If the methods returns Standard_True, the projection is
        successful, and Paramproj is the parameter on the arc
        of the projected point, Dist is the distance between
        P and the curve..
        If the method returns Standard_False, Param proj and Dist
        are not significant.

        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type S: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface
        :type C: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d
        :type Paramproj: float
        :type Dist: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepBlend.BRepBlend_BlendTool_Project(*args)

    Project = staticmethod(Project)

    def Inters(*args):
        """
        Inters(gp_Pnt2d P1, gp_Pnt2d P2, Handle_Adaptor3d_HSurface S, Handle_Adaptor2d_HCurve2d C) -> Standard_Boolean

        :type P1: OCC.wrapper.gp.gp_Pnt2d
        :type P2: OCC.wrapper.gp.gp_Pnt2d
        :type S: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface
        :type C: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d
        :type Param: float
        :type Dist: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepBlend.BRepBlend_BlendTool_Inters(*args)

    Inters = staticmethod(Inters)

    def Parameter(*args):
        """
        Parameter(Handle_Adaptor3d_HVertex V, Handle_Adaptor2d_HCurve2d A) -> Standard_Real

        Returns the parameter of the vertex V on the edge A.

        :type V: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HVertex
        :type A: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _BRepBlend.BRepBlend_BlendTool_Parameter(*args)

    Parameter = staticmethod(Parameter)

    def Tolerance(*args):
        """
        Tolerance(Handle_Adaptor3d_HVertex V, Handle_Adaptor2d_HCurve2d A) -> Standard_Real

        Returns the parametric tolerance on the arc A
        used to consider that the vertex and another point meet,
        i-e if Abs(Parameter(Vertex)-Parameter(OtherPnt))<=
        Tolerance, the points are "merged".

        :type V: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HVertex
        :type A: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _BRepBlend.BRepBlend_BlendTool_Tolerance(*args)

    Tolerance = staticmethod(Tolerance)

    def SingularOnUMin(*args):
        """
        SingularOnUMin(Handle_Adaptor3d_HSurface S) -> Standard_Boolean

        :type S: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepBlend.BRepBlend_BlendTool_SingularOnUMin(*args)

    SingularOnUMin = staticmethod(SingularOnUMin)

    def SingularOnUMax(*args):
        """
        SingularOnUMax(Handle_Adaptor3d_HSurface S) -> Standard_Boolean

        :type S: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepBlend.BRepBlend_BlendTool_SingularOnUMax(*args)

    SingularOnUMax = staticmethod(SingularOnUMax)

    def SingularOnVMin(*args):
        """
        SingularOnVMin(Handle_Adaptor3d_HSurface S) -> Standard_Boolean

        :type S: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepBlend.BRepBlend_BlendTool_SingularOnVMin(*args)

    SingularOnVMin = staticmethod(SingularOnVMin)

    def SingularOnVMax(*args):
        """
        SingularOnVMax(Handle_Adaptor3d_HSurface S) -> Standard_Boolean

        :type S: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepBlend.BRepBlend_BlendTool_SingularOnVMax(*args)

    SingularOnVMax = staticmethod(SingularOnVMax)

    def NbSamplesU(*args):
        """
        NbSamplesU(Handle_Adaptor3d_HSurface S, Standard_Real const u1, Standard_Real const u2) -> Standard_Integer

        :type S: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface
        :type u1: float
        :type u2: float
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepBlend.BRepBlend_BlendTool_NbSamplesU(*args)

    NbSamplesU = staticmethod(NbSamplesU)

    def NbSamplesV(*args):
        """
        NbSamplesV(Handle_Adaptor3d_HSurface S, Standard_Real const v1, Standard_Real const v2) -> Standard_Integer

        :type S: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface
        :type v1: float
        :type v2: float
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepBlend.BRepBlend_BlendTool_NbSamplesV(*args)

    NbSamplesV = staticmethod(NbSamplesV)

    def Bounds(*args):
        """
        Bounds(Handle_Adaptor2d_HCurve2d C)

        Returns the parametric limits on the arc C.
        These limits must be finite : they are either
        the real limits of the arc, for a finite arc,
        or a bounding box for an infinite arc.

        :type C: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d
        :type Ufirst: float
        :type Ulast: float

        """
        return _BRepBlend.BRepBlend_BlendTool_Bounds(*args)

    Bounds = staticmethod(Bounds)

    def CurveOnSurf(*args):
        """
        CurveOnSurf(Handle_Adaptor2d_HCurve2d C, Handle_Adaptor3d_HSurface S) -> Handle_Adaptor2d_HCurve2d

        :type C: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d
        :type S: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface
        :rtype: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d

        """
        return _BRepBlend.BRepBlend_BlendTool_CurveOnSurf(*args)

    CurveOnSurf = staticmethod(CurveOnSurf)

    def __init__(self):
        this = _BRepBlend.new_BRepBlend_BlendTool()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _BRepBlend.delete_BRepBlend_BlendTool
BRepBlend_BlendTool_swigregister = _BRepBlend.BRepBlend_BlendTool_swigregister
BRepBlend_BlendTool_swigregister(BRepBlend_BlendTool)

def BRepBlend_BlendTool_Project(*args):
    """
    BRepBlend_BlendTool_Project(gp_Pnt2d P, Handle_Adaptor3d_HSurface S, Handle_Adaptor2d_HCurve2d C) -> Standard_Boolean

    Projects the point P on the arc C.
    If the methods returns Standard_True, the projection is
    successful, and Paramproj is the parameter on the arc
    of the projected point, Dist is the distance between
    P and the curve..
    If the method returns Standard_False, Param proj and Dist
    are not significant.

    :type P: OCC.wrapper.gp.gp_Pnt2d
    :type S: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface
    :type C: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d
    :type Paramproj: float
    :type Dist: float
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _BRepBlend.BRepBlend_BlendTool_Project(*args)

def BRepBlend_BlendTool_Inters(*args):
    """
    BRepBlend_BlendTool_Inters(gp_Pnt2d P1, gp_Pnt2d P2, Handle_Adaptor3d_HSurface S, Handle_Adaptor2d_HCurve2d C) -> Standard_Boolean

    :type P1: OCC.wrapper.gp.gp_Pnt2d
    :type P2: OCC.wrapper.gp.gp_Pnt2d
    :type S: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface
    :type C: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d
    :type Param: float
    :type Dist: float
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _BRepBlend.BRepBlend_BlendTool_Inters(*args)

def BRepBlend_BlendTool_Parameter(*args):
    """
    BRepBlend_BlendTool_Parameter(Handle_Adaptor3d_HVertex V, Handle_Adaptor2d_HCurve2d A) -> Standard_Real

    Returns the parameter of the vertex V on the edge A.

    :type V: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HVertex
    :type A: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d
    :rtype: OCC.wrapper.Standard.Standard_Real

    """
    return _BRepBlend.BRepBlend_BlendTool_Parameter(*args)

def BRepBlend_BlendTool_Tolerance(*args):
    """
    BRepBlend_BlendTool_Tolerance(Handle_Adaptor3d_HVertex V, Handle_Adaptor2d_HCurve2d A) -> Standard_Real

    Returns the parametric tolerance on the arc A
    used to consider that the vertex and another point meet,
    i-e if Abs(Parameter(Vertex)-Parameter(OtherPnt))<=
    Tolerance, the points are "merged".

    :type V: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HVertex
    :type A: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d
    :rtype: OCC.wrapper.Standard.Standard_Real

    """
    return _BRepBlend.BRepBlend_BlendTool_Tolerance(*args)

def BRepBlend_BlendTool_SingularOnUMin(*args):
    """
    BRepBlend_BlendTool_SingularOnUMin(Handle_Adaptor3d_HSurface S) -> Standard_Boolean

    :type S: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _BRepBlend.BRepBlend_BlendTool_SingularOnUMin(*args)

def BRepBlend_BlendTool_SingularOnUMax(*args):
    """
    BRepBlend_BlendTool_SingularOnUMax(Handle_Adaptor3d_HSurface S) -> Standard_Boolean

    :type S: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _BRepBlend.BRepBlend_BlendTool_SingularOnUMax(*args)

def BRepBlend_BlendTool_SingularOnVMin(*args):
    """
    BRepBlend_BlendTool_SingularOnVMin(Handle_Adaptor3d_HSurface S) -> Standard_Boolean

    :type S: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _BRepBlend.BRepBlend_BlendTool_SingularOnVMin(*args)

def BRepBlend_BlendTool_SingularOnVMax(*args):
    """
    BRepBlend_BlendTool_SingularOnVMax(Handle_Adaptor3d_HSurface S) -> Standard_Boolean

    :type S: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _BRepBlend.BRepBlend_BlendTool_SingularOnVMax(*args)

def BRepBlend_BlendTool_NbSamplesU(*args):
    """
    BRepBlend_BlendTool_NbSamplesU(Handle_Adaptor3d_HSurface S, Standard_Real const u1, Standard_Real const u2) -> Standard_Integer

    :type S: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface
    :type u1: float
    :type u2: float
    :rtype: OCC.wrapper.Standard.Standard_Integer

    """
    return _BRepBlend.BRepBlend_BlendTool_NbSamplesU(*args)

def BRepBlend_BlendTool_NbSamplesV(*args):
    """
    BRepBlend_BlendTool_NbSamplesV(Handle_Adaptor3d_HSurface S, Standard_Real const v1, Standard_Real const v2) -> Standard_Integer

    :type S: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface
    :type v1: float
    :type v2: float
    :rtype: OCC.wrapper.Standard.Standard_Integer

    """
    return _BRepBlend.BRepBlend_BlendTool_NbSamplesV(*args)

def BRepBlend_BlendTool_Bounds(*args):
    """
    BRepBlend_BlendTool_Bounds(Handle_Adaptor2d_HCurve2d C)

    Returns the parametric limits on the arc C.
    These limits must be finite : they are either
    the real limits of the arc, for a finite arc,
    or a bounding box for an infinite arc.

    :type C: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d
    :type Ufirst: float
    :type Ulast: float

    """
    return _BRepBlend.BRepBlend_BlendTool_Bounds(*args)

def BRepBlend_BlendTool_CurveOnSurf(*args):
    """
    BRepBlend_BlendTool_CurveOnSurf(Handle_Adaptor2d_HCurve2d C, Handle_Adaptor3d_HSurface S) -> Handle_Adaptor2d_HCurve2d

    :type C: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d
    :type S: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface
    :rtype: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d

    """
    return _BRepBlend.BRepBlend_BlendTool_CurveOnSurf(*args)

class BRepBlend_SurfRstEvolRad(Blend.Blend_SurfRstFunction):
    """
    Function  to approximate by AppSurface  for
    Edge/Face  and  evolutif  radius
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BRepBlend_SurfRstEvolRad self, Handle_Adaptor3d_HSurface Surf, Handle_Adaptor3d_HSurface SurfRst, Handle_Adaptor2d_HCurve2d Rst, Handle_Adaptor3d_HCurve CGuide, Handle_Law_Function Evol) -> BRepBlend_SurfRstEvolRad

        :type Surf: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface
        :type SurfRst: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface
        :type Rst: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d
        :type CGuide: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HCurve
        :type Evol: OCC.wrapper.Law.Handle_Law_Function

        """
        this = _BRepBlend.new_BRepBlend_SurfRstEvolRad(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def NbVariables(self, *args):
        """
        NbVariables(BRepBlend_SurfRstEvolRad self) -> Standard_Integer

        Returns 3.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepBlend.BRepBlend_SurfRstEvolRad_NbVariables(self, *args)


    def NbEquations(self, *args):
        """
        NbEquations(BRepBlend_SurfRstEvolRad self) -> Standard_Integer

        Returns 3.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepBlend.BRepBlend_SurfRstEvolRad_NbEquations(self, *args)


    def Value(self, *args):
        """
        Value(BRepBlend_SurfRstEvolRad self, math_Vector X, math_Vector F) -> Standard_Boolean

        computes the values <F> of the Functions for the
        variable <X>.
        Returns True if the computation was done successfully,
        False otherwise.

        :type X: OCC.wrapper.math.math_Vector
        :type F: OCC.wrapper.math.math_Vector
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepBlend.BRepBlend_SurfRstEvolRad_Value(self, *args)


    def Derivatives(self, *args):
        """
        Derivatives(BRepBlend_SurfRstEvolRad self, math_Vector X, math_Matrix D) -> Standard_Boolean

        returns the values <D> of the derivatives for the
        variable <X>.
        Returns True if the computation was done successfully,
        False otherwise.

        :type X: OCC.wrapper.math.math_Vector
        :type D: OCC.wrapper.math.math_Matrix
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepBlend.BRepBlend_SurfRstEvolRad_Derivatives(self, *args)


    def Values(self, *args):
        """
        Values(BRepBlend_SurfRstEvolRad self, math_Vector X, math_Vector F, math_Matrix D) -> Standard_Boolean

        returns the values <F> of the functions and the derivatives
        <D> for the variable <X>.
        Returns True if the computation was done successfully,
        False otherwise.

        :type X: OCC.wrapper.math.math_Vector
        :type F: OCC.wrapper.math.math_Vector
        :type D: OCC.wrapper.math.math_Matrix
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepBlend.BRepBlend_SurfRstEvolRad_Values(self, *args)


    def GetBounds(self, *args):
        """
        GetBounds(BRepBlend_SurfRstEvolRad self, math_Vector InfBound, math_Vector SupBound)

        :type InfBound: OCC.wrapper.math.math_Vector
        :type SupBound: OCC.wrapper.math.math_Vector

        """
        return _BRepBlend.BRepBlend_SurfRstEvolRad_GetBounds(self, *args)


    def IsSolution(self, *args):
        """
        IsSolution(BRepBlend_SurfRstEvolRad self, math_Vector Sol, Standard_Real const Tol) -> Standard_Boolean

        :type Sol: OCC.wrapper.math.math_Vector
        :type Tol: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepBlend.BRepBlend_SurfRstEvolRad_IsSolution(self, *args)


    def GetMinimalDistance(self, *args):
        """
        GetMinimalDistance(BRepBlend_SurfRstEvolRad self) -> Standard_Real

        Returns   the    minimal  Distance  beetween   two
        extremitys of calculed sections.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _BRepBlend.BRepBlend_SurfRstEvolRad_GetMinimalDistance(self, *args)


    def PointOnS(self, *args):
        """
        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        res = _BRepBlend.BRepBlend_SurfRstEvolRad_PointOnS(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def PointOnRst(self, *args):
        """
        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        res = _BRepBlend.BRepBlend_SurfRstEvolRad_PointOnRst(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Pnt2dOnS(self, *args):
        """
        Returns U,V coordinates of the point on the surface.

        :rtype: OCC.wrapper.gp.gp_Pnt2d

        """
        res = _BRepBlend.BRepBlend_SurfRstEvolRad_Pnt2dOnS(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Pnt2dOnRst(self, *args):
        """
        Returns  U,V coordinates of the point  on the curve on
        surface.

        :rtype: OCC.wrapper.gp.gp_Pnt2d

        """
        res = _BRepBlend.BRepBlend_SurfRstEvolRad_Pnt2dOnRst(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ParameterOnRst(self, *args):
        """
        ParameterOnRst(BRepBlend_SurfRstEvolRad self) -> Standard_Real

        Returns parameter of the point on the curve.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _BRepBlend.BRepBlend_SurfRstEvolRad_ParameterOnRst(self, *args)


    def IsTangencyPoint(self, *args):
        """
        IsTangencyPoint(BRepBlend_SurfRstEvolRad self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepBlend.BRepBlend_SurfRstEvolRad_IsTangencyPoint(self, *args)


    def TangentOnS(self, *args):
        """
        :rtype: OCC.wrapper.gp.gp_Vec

        """
        res = _BRepBlend.BRepBlend_SurfRstEvolRad_TangentOnS(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Tangent2dOnS(self, *args):
        """
        :rtype: OCC.wrapper.gp.gp_Vec2d

        """
        res = _BRepBlend.BRepBlend_SurfRstEvolRad_Tangent2dOnS(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def TangentOnRst(self, *args):
        """
        :rtype: OCC.wrapper.gp.gp_Vec

        """
        res = _BRepBlend.BRepBlend_SurfRstEvolRad_TangentOnRst(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Tangent2dOnRst(self, *args):
        """
        :rtype: OCC.wrapper.gp.gp_Vec2d

        """
        res = _BRepBlend.BRepBlend_SurfRstEvolRad_Tangent2dOnRst(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Decroch(self, *args):
        """
        Decroch(BRepBlend_SurfRstEvolRad self, math_Vector Sol, gp_Vec NS, gp_Vec TgS) -> Standard_Boolean

        Permet  d ' implementer   un   critere  de  decrochage
        specifique a la fonction.

        :type Sol: OCC.wrapper.math.math_Vector
        :type NS: OCC.wrapper.gp.gp_Vec
        :type TgS: OCC.wrapper.gp.gp_Vec
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepBlend.BRepBlend_SurfRstEvolRad_Decroch(self, *args)


    def Set(self, *args):
        """
        Set(BRepBlend_SurfRstEvolRad self, Handle_Adaptor3d_HSurface SurfRef, Handle_Adaptor2d_HCurve2d RstRef)
        Set(BRepBlend_SurfRstEvolRad self, Standard_Real const Param)
        Set(BRepBlend_SurfRstEvolRad self, Standard_Real const First, Standard_Real const Last)
        Set(BRepBlend_SurfRstEvolRad self, Standard_Integer const Choix)
        Set(BRepBlend_SurfRstEvolRad self, BlendFunc_SectionShape const TypeSection)

        Sets  the  type  of   section generation   for the
        approximations.

        :type TypeSection: OCC.wrapper.BlendFunc.BlendFunc_SectionShape

        """
        return _BRepBlend.BRepBlend_SurfRstEvolRad_Set(self, *args)


    def IsRational(self, *args):
        """
        IsRational(BRepBlend_SurfRstEvolRad self) -> Standard_Boolean

        Returns  if the section is rationnal

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepBlend.BRepBlend_SurfRstEvolRad_IsRational(self, *args)


    def GetSectionSize(self, *args):
        """
        GetSectionSize(BRepBlend_SurfRstEvolRad self) -> Standard_Real

        Returns the length of the maximum section

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _BRepBlend.BRepBlend_SurfRstEvolRad_GetSectionSize(self, *args)


    def GetMinimalWeight(self, *args):
        """
        GetMinimalWeight(BRepBlend_SurfRstEvolRad self, NCollection_Array1_Standard_Real Weigths)

        Compute the minimal value of weight for each poles
        of all sections.

        :type Weigths: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        return _BRepBlend.BRepBlend_SurfRstEvolRad_GetMinimalWeight(self, *args)


    def NbIntervals(self, *args):
        """
        NbIntervals(BRepBlend_SurfRstEvolRad self, GeomAbs_Shape const S) -> Standard_Integer

        Returns  the number  of  intervals for  continuity
        <S>. May be one if Continuity(me) >= <S>

        :type S: OCC.wrapper.GeomAbs.GeomAbs_Shape
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepBlend.BRepBlend_SurfRstEvolRad_NbIntervals(self, *args)


    def Intervals(self, *args):
        """
        Intervals(BRepBlend_SurfRstEvolRad self, NCollection_Array1_Standard_Real T, GeomAbs_Shape const S)

        Stores in <T> the  parameters bounding the intervals
        of continuity <S>.
        The array must provide  enough room to  accomodate
        for the parameters. i.e. T.Length() > NbIntervals()

        :type T: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type S: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _BRepBlend.BRepBlend_SurfRstEvolRad_Intervals(self, *args)


    def GetShape(self, *args):
        """
        GetShape(BRepBlend_SurfRstEvolRad self)

        :type NbPoles: int
        :type NbKnots: int
        :type Degree: int
        :type NbPoles2d: int

        """
        return _BRepBlend.BRepBlend_SurfRstEvolRad_GetShape(self, *args)


    def GetTolerance(self, *args):
        """
        GetTolerance(BRepBlend_SurfRstEvolRad self, math_Vector Tolerance, Standard_Real const Tol)
        GetTolerance(BRepBlend_SurfRstEvolRad self, Standard_Real const BoundTol, Standard_Real const SurfTol, Standard_Real const AngleTol, math_Vector Tol3d, math_Vector Tol1D)

        Returns the tolerance to reach in approximation
        to respecte
        BoundTol error at the Boundary
        AngleTol tangent error at the Boundary
        SurfTol error inside the surface.

        :type BoundTol: float
        :type SurfTol: float
        :type AngleTol: float
        :type Tol3d: OCC.wrapper.math.math_Vector
        :type Tol1D: OCC.wrapper.math.math_Vector

        """
        return _BRepBlend.BRepBlend_SurfRstEvolRad_GetTolerance(self, *args)


    def Knots(self, *args):
        """
        Knots(BRepBlend_SurfRstEvolRad self, NCollection_Array1_Standard_Real TKnots)

        :type TKnots: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        return _BRepBlend.BRepBlend_SurfRstEvolRad_Knots(self, *args)


    def Mults(self, *args):
        """
        Mults(BRepBlend_SurfRstEvolRad self, NCollection_Array1_Standard_Integer TMults)

        :type TMults: OCC.wrapper.TColStd.TColStd_Array1OfInteger

        """
        return _BRepBlend.BRepBlend_SurfRstEvolRad_Mults(self, *args)


    def Section(self, *args):
        """
        Section(BRepBlend_SurfRstEvolRad self, Standard_Real const Param, Standard_Real const U, Standard_Real const V, Standard_Real const W, gp_Circ C)
        Section(BRepBlend_SurfRstEvolRad self, Blend_Point P, NCollection_Array1_gp_Pnt Poles, NCollection_Array1_gp_Vec DPoles, NCollection_Array1_gp_Pnt2d Poles2d, NCollection_Array1_gp_Vec2d DPoles2d, NCollection_Array1_Standard_Real Weigths, NCollection_Array1_Standard_Real DWeigths) -> Standard_Boolean
        Section(BRepBlend_SurfRstEvolRad self, Blend_Point P, NCollection_Array1_gp_Pnt Poles, NCollection_Array1_gp_Vec DPoles, NCollection_Array1_gp_Vec D2Poles, NCollection_Array1_gp_Pnt2d Poles2d, NCollection_Array1_gp_Vec2d DPoles2d, NCollection_Array1_gp_Vec2d D2Poles2d, NCollection_Array1_Standard_Real Weigths, NCollection_Array1_Standard_Real DWeigths, NCollection_Array1_Standard_Real D2Weigths) -> Standard_Boolean
        Section(BRepBlend_SurfRstEvolRad self, Blend_Point P, NCollection_Array1_gp_Pnt Poles, NCollection_Array1_gp_Pnt2d Poles2d, NCollection_Array1_Standard_Real Weigths)

        :type P: OCC.wrapper.Blend.Blend_Point
        :type Poles: OCC.wrapper.TColgp.TColgp_Array1OfPnt
        :type Poles2d: OCC.wrapper.TColgp.TColgp_Array1OfPnt2d
        :type Weigths: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        return _BRepBlend.BRepBlend_SurfRstEvolRad_Section(self, *args)


    def Resolution(self, *args):
        """
        Resolution(BRepBlend_SurfRstEvolRad self, Standard_Integer const IC2d, Standard_Real const Tol)

        :type IC2d: int
        :type Tol: float
        :type TolU: float
        :type TolV: float

        """
        return _BRepBlend.BRepBlend_SurfRstEvolRad_Resolution(self, *args)

    __swig_destroy__ = _BRepBlend.delete_BRepBlend_SurfRstEvolRad
BRepBlend_SurfRstEvolRad_swigregister = _BRepBlend.BRepBlend_SurfRstEvolRad_swigregister
BRepBlend_SurfRstEvolRad_swigregister(BRepBlend_SurfRstEvolRad)

class BRepBlend_AppSurf(AppBlend.AppBlend_Approx):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BRepBlend_AppSurf self) -> BRepBlend_AppSurf
        __init__(BRepBlend_AppSurf self, Standard_Integer const Degmin, Standard_Integer const Degmax, Standard_Real const Tol3d, Standard_Real const Tol2d, Standard_Integer const NbIt, Standard_Boolean const KnownParameters) -> BRepBlend_AppSurf

        :type Degmin: int
        :type Degmax: int
        :type Tol3d: float
        :type Tol2d: float
        :type NbIt: int
        :type KnownParameters: bool

        """
        this = _BRepBlend.new_BRepBlend_AppSurf(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(BRepBlend_AppSurf self, Standard_Integer const Degmin, Standard_Integer const Degmax, Standard_Real const Tol3d, Standard_Real const Tol2d, Standard_Integer const NbIt, Standard_Boolean const KnownParameters)

        :type Degmin: int
        :type Degmax: int
        :type Tol3d: float
        :type Tol2d: float
        :type NbIt: int
        :type KnownParameters: bool

        """
        return _BRepBlend.BRepBlend_AppSurf_Init(self, *args)


    def SetParType(self, *args):
        """
        SetParType(BRepBlend_AppSurf self, Approx_ParametrizationType const ParType)

        Define the type of parametrization used in the approximation

        :type ParType: OCC.wrapper.Approx.Approx_ParametrizationType

        """
        return _BRepBlend.BRepBlend_AppSurf_SetParType(self, *args)


    def SetContinuity(self, *args):
        """
        SetContinuity(BRepBlend_AppSurf self, GeomAbs_Shape const C)

        Define the Continuity used in the approximation

        :type C: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _BRepBlend.BRepBlend_AppSurf_SetContinuity(self, *args)


    def SetCriteriumWeight(self, *args):
        """
        SetCriteriumWeight(BRepBlend_AppSurf self, Standard_Real const W1, Standard_Real const W2, Standard_Real const W3)

        define the Weights  associed to the criterium used in
        the  optimization.

        if Wi <= 0

        :type W1: float
        :type W2: float
        :type W3: float

        """
        return _BRepBlend.BRepBlend_AppSurf_SetCriteriumWeight(self, *args)


    def ParType(self, *args):
        """
        ParType(BRepBlend_AppSurf self) -> Approx_ParametrizationType

        returns the type of parametrization used in the approximation

        :rtype: OCC.wrapper.Approx.Approx_ParametrizationType

        """
        return _BRepBlend.BRepBlend_AppSurf_ParType(self, *args)


    def Continuity(self, *args):
        """
        Continuity(BRepBlend_AppSurf self) -> GeomAbs_Shape

        returns the Continuity used in the approximation

        :rtype: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _BRepBlend.BRepBlend_AppSurf_Continuity(self, *args)


    def CriteriumWeight(self, *args):
        """
        CriteriumWeight(BRepBlend_AppSurf self)

        returns the Weights (as percent) associed  to the criterium used in
        the  optimization.

        :type W1: float
        :type W2: float
        :type W3: float

        """
        return _BRepBlend.BRepBlend_AppSurf_CriteriumWeight(self, *args)


    def PerformSmoothing(self, *args):
        """
        PerformSmoothing(BRepBlend_AppSurf self, Handle_BRepBlend_Line Lin, Blend_AppFunction SecGen)

        :type Lin: OCC.wrapper.BRepBlend.Handle_BRepBlend_Line
        :type SecGen: OCC.wrapper.Blend.Blend_AppFunction

        """
        return _BRepBlend.BRepBlend_AppSurf_PerformSmoothing(self, *args)


    def Perform(self, *args):
        """
        Perform(BRepBlend_AppSurf self, Handle_BRepBlend_Line Lin, Blend_AppFunction SecGen, Standard_Boolean const SpApprox)
        Perform(BRepBlend_AppSurf self, Handle_BRepBlend_Line Lin, Blend_AppFunction SecGen, Standard_Integer const NbMaxP)

        :type Lin: OCC.wrapper.BRepBlend.Handle_BRepBlend_Line
        :type SecGen: OCC.wrapper.Blend.Blend_AppFunction
        :type NbMaxP: int

        """
        return _BRepBlend.BRepBlend_AppSurf_Perform(self, *args)


    def IsDone(self, *args):
        """
        IsDone(BRepBlend_AppSurf self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepBlend.BRepBlend_AppSurf_IsDone(self, *args)


    def SurfShape(self, *args):
        """
        SurfShape(BRepBlend_AppSurf self)

        :type UDegree: int
        :type VDegree: int
        :type NbUPoles: int
        :type NbVPoles: int
        :type NbUKnots: int
        :type NbVKnots: int

        """
        return _BRepBlend.BRepBlend_AppSurf_SurfShape(self, *args)


    def Surface(self, *args):
        """
        Surface(BRepBlend_AppSurf self, NCollection_Array2_gp_Pnt TPoles, NCollection_Array2_Standard_Real TWeights, NCollection_Array1_Standard_Real TUKnots, NCollection_Array1_Standard_Real TVKnots, NCollection_Array1_Standard_Integer TUMults, NCollection_Array1_Standard_Integer TVMults)

        :type TPoles: OCC.wrapper.TColgp.TColgp_Array2OfPnt
        :type TWeights: OCC.wrapper.TColStd.TColStd_Array2OfReal
        :type TUKnots: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type TVKnots: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type TUMults: OCC.wrapper.TColStd.TColStd_Array1OfInteger
        :type TVMults: OCC.wrapper.TColStd.TColStd_Array1OfInteger

        """
        return _BRepBlend.BRepBlend_AppSurf_Surface(self, *args)


    def UDegree(self, *args):
        """
        UDegree(BRepBlend_AppSurf self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepBlend.BRepBlend_AppSurf_UDegree(self, *args)


    def VDegree(self, *args):
        """
        VDegree(BRepBlend_AppSurf self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepBlend.BRepBlend_AppSurf_VDegree(self, *args)


    def SurfPoles(self, *args):
        """
        :rtype: OCC.wrapper.TColgp.TColgp_Array2OfPnt

        """
        res = _BRepBlend.BRepBlend_AppSurf_SurfPoles(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SurfWeights(self, *args):
        """
        :rtype: OCC.wrapper.TColStd.TColStd_Array2OfReal

        """
        res = _BRepBlend.BRepBlend_AppSurf_SurfWeights(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SurfUKnots(self, *args):
        """
        :rtype: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        res = _BRepBlend.BRepBlend_AppSurf_SurfUKnots(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SurfVKnots(self, *args):
        """
        :rtype: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        res = _BRepBlend.BRepBlend_AppSurf_SurfVKnots(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SurfUMults(self, *args):
        """
        :rtype: OCC.wrapper.TColStd.TColStd_Array1OfInteger

        """
        res = _BRepBlend.BRepBlend_AppSurf_SurfUMults(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SurfVMults(self, *args):
        """
        :rtype: OCC.wrapper.TColStd.TColStd_Array1OfInteger

        """
        res = _BRepBlend.BRepBlend_AppSurf_SurfVMults(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def NbCurves2d(self, *args):
        """
        NbCurves2d(BRepBlend_AppSurf self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepBlend.BRepBlend_AppSurf_NbCurves2d(self, *args)


    def Curves2dShape(self, *args):
        """
        Curves2dShape(BRepBlend_AppSurf self)

        :type Degree: int
        :type NbPoles: int
        :type NbKnots: int

        """
        return _BRepBlend.BRepBlend_AppSurf_Curves2dShape(self, *args)


    def Curve2d(self, *args):
        """
        Curve2d(BRepBlend_AppSurf self, Standard_Integer const Index, NCollection_Array1_gp_Pnt2d TPoles, NCollection_Array1_Standard_Real TKnots, NCollection_Array1_Standard_Integer TMults)

        :type Index: int
        :type TPoles: OCC.wrapper.TColgp.TColgp_Array1OfPnt2d
        :type TKnots: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type TMults: OCC.wrapper.TColStd.TColStd_Array1OfInteger

        """
        return _BRepBlend.BRepBlend_AppSurf_Curve2d(self, *args)


    def Curves2dDegree(self, *args):
        """
        Curves2dDegree(BRepBlend_AppSurf self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepBlend.BRepBlend_AppSurf_Curves2dDegree(self, *args)


    def Curve2dPoles(self, *args):
        """
        :type Index: int
        :rtype: OCC.wrapper.TColgp.TColgp_Array1OfPnt2d

        """
        res = _BRepBlend.BRepBlend_AppSurf_Curve2dPoles(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Curves2dKnots(self, *args):
        """
        :rtype: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        res = _BRepBlend.BRepBlend_AppSurf_Curves2dKnots(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Curves2dMults(self, *args):
        """
        :rtype: OCC.wrapper.TColStd.TColStd_Array1OfInteger

        """
        res = _BRepBlend.BRepBlend_AppSurf_Curves2dMults(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def TolReached(self, *args):
        """
        TolReached(BRepBlend_AppSurf self)

        :type Tol3d: float
        :type Tol2d: float

        """
        return _BRepBlend.BRepBlend_AppSurf_TolReached(self, *args)


    def TolCurveOnSurf(self, *args):
        """
        TolCurveOnSurf(BRepBlend_AppSurf self, Standard_Integer const Index) -> Standard_Real

        :type Index: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _BRepBlend.BRepBlend_AppSurf_TolCurveOnSurf(self, *args)

    __swig_destroy__ = _BRepBlend.delete_BRepBlend_AppSurf
BRepBlend_AppSurf_swigregister = _BRepBlend.BRepBlend_AppSurf_swigregister
BRepBlend_AppSurf_swigregister(BRepBlend_AppSurf)

class Handle_BRepBlend_AppFuncRoot(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_BRepBlend_AppFuncRoot self)

        Nullify the handle


        """
        return _BRepBlend.Handle_BRepBlend_AppFuncRoot_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_BRepBlend_AppFuncRoot self) -> bool

        Check for being null

        :rtype: bool

        """
        return _BRepBlend.Handle_BRepBlend_AppFuncRoot_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_BRepBlend_AppFuncRoot self, BRepBlend_AppFuncRoot thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _BRepBlend.Handle_BRepBlend_AppFuncRoot_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_BRepBlend_AppFuncRoot self, Handle_BRepBlend_AppFuncRoot theHandle) -> Handle_BRepBlend_AppFuncRoot
        assign(Handle_BRepBlend_AppFuncRoot self, BRepBlend_AppFuncRoot thePtr) -> Handle_BRepBlend_AppFuncRoot
        assign(Handle_BRepBlend_AppFuncRoot self, Handle_BRepBlend_AppFuncRoot theHandle) -> Handle_BRepBlend_AppFuncRoot

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _BRepBlend.Handle_BRepBlend_AppFuncRoot_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_BRepBlend_AppFuncRoot self) -> BRepBlend_AppFuncRoot

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _BRepBlend.Handle_BRepBlend_AppFuncRoot_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_BRepBlend_AppFuncRoot self) -> BRepBlend_AppFuncRoot

        Member access operator (note non-const)

        :rtype: T *

        """
        return _BRepBlend.Handle_BRepBlend_AppFuncRoot___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_BRepBlend_AppFuncRoot self) -> BRepBlend_AppFuncRoot

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _BRepBlend.Handle_BRepBlend_AppFuncRoot___ref__(self, *args)


    def __hash__(self):
        return _BRepBlend.Handle_BRepBlend_AppFuncRoot___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _BRepBlend.Handle_BRepBlend_AppFuncRoot___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _BRepBlend.new_Handle_BRepBlend_AppFuncRoot(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_BRepBlend.Handle_BRepBlend_AppFuncRoot_DownCast)
    __swig_destroy__ = _BRepBlend.delete_Handle_BRepBlend_AppFuncRoot

    def D0(self, *args):
        """
        D0(Handle_BRepBlend_AppFuncRoot self, Standard_Real const Param, Standard_Real const First, Standard_Real const Last, NCollection_Array1_gp_Pnt Poles, NCollection_Array1_gp_Pnt2d Poles2d, NCollection_Array1_Standard_Real Weigths) -> Standard_Boolean

        compute the section for v = param

        :type Param: float
        :type First: float
        :type Last: float
        :type Poles: OCC.wrapper.TColgp.TColgp_Array1OfPnt
        :type Poles2d: OCC.wrapper.TColgp.TColgp_Array1OfPnt2d
        :type Weigths: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepBlend.Handle_BRepBlend_AppFuncRoot_D0(self, *args)


    def D1(self, *args):
        """
        D1(Handle_BRepBlend_AppFuncRoot self, Standard_Real const Param, Standard_Real const First, Standard_Real const Last, NCollection_Array1_gp_Pnt Poles, NCollection_Array1_gp_Vec DPoles, NCollection_Array1_gp_Pnt2d Poles2d, NCollection_Array1_gp_Vec2d DPoles2d, NCollection_Array1_Standard_Real Weigths, NCollection_Array1_Standard_Real DWeigths) -> Standard_Boolean

        compute the first  derivative in v direction  of the
        section for v =  param

        :type Param: float
        :type First: float
        :type Last: float
        :type Poles: OCC.wrapper.TColgp.TColgp_Array1OfPnt
        :type DPoles: OCC.wrapper.TColgp.TColgp_Array1OfVec
        :type Poles2d: OCC.wrapper.TColgp.TColgp_Array1OfPnt2d
        :type DPoles2d: OCC.wrapper.TColgp.TColgp_Array1OfVec2d
        :type Weigths: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type DWeigths: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepBlend.Handle_BRepBlend_AppFuncRoot_D1(self, *args)


    def D2(self, *args):
        """
        D2(Handle_BRepBlend_AppFuncRoot self, Standard_Real const Param, Standard_Real const First, Standard_Real const Last, NCollection_Array1_gp_Pnt Poles, NCollection_Array1_gp_Vec DPoles, NCollection_Array1_gp_Vec D2Poles, NCollection_Array1_gp_Pnt2d Poles2d, NCollection_Array1_gp_Vec2d DPoles2d, NCollection_Array1_gp_Vec2d D2Poles2d, NCollection_Array1_Standard_Real Weigths, NCollection_Array1_Standard_Real DWeigths, NCollection_Array1_Standard_Real D2Weigths) -> Standard_Boolean

        compute the second derivative  in v direction of the
        section  for v = param

        :type Param: float
        :type First: float
        :type Last: float
        :type Poles: OCC.wrapper.TColgp.TColgp_Array1OfPnt
        :type DPoles: OCC.wrapper.TColgp.TColgp_Array1OfVec
        :type D2Poles: OCC.wrapper.TColgp.TColgp_Array1OfVec
        :type Poles2d: OCC.wrapper.TColgp.TColgp_Array1OfPnt2d
        :type DPoles2d: OCC.wrapper.TColgp.TColgp_Array1OfVec2d
        :type D2Poles2d: OCC.wrapper.TColgp.TColgp_Array1OfVec2d
        :type Weigths: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type DWeigths: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type D2Weigths: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepBlend.Handle_BRepBlend_AppFuncRoot_D2(self, *args)


    def Nb2dCurves(self, *args):
        """
        Nb2dCurves(Handle_BRepBlend_AppFuncRoot self) -> Standard_Integer

        get the number of 2d curves to  approximate.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepBlend.Handle_BRepBlend_AppFuncRoot_Nb2dCurves(self, *args)


    def SectionShape(self, *args):
        """
        SectionShape(Handle_BRepBlend_AppFuncRoot self)

        get the format of an  section

        :type NbPoles: int
        :type NbKnots: int
        :type Degree: int

        """
        return _BRepBlend.Handle_BRepBlend_AppFuncRoot_SectionShape(self, *args)


    def Knots(self, *args):
        """
        Knots(Handle_BRepBlend_AppFuncRoot self, NCollection_Array1_Standard_Real TKnots)

        get the Knots of the section

        :type TKnots: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        return _BRepBlend.Handle_BRepBlend_AppFuncRoot_Knots(self, *args)


    def Mults(self, *args):
        """
        Mults(Handle_BRepBlend_AppFuncRoot self, NCollection_Array1_Standard_Integer TMults)

        get the Multplicities of the section

        :type TMults: OCC.wrapper.TColStd.TColStd_Array1OfInteger

        """
        return _BRepBlend.Handle_BRepBlend_AppFuncRoot_Mults(self, *args)


    def IsRational(self, *args):
        """
        IsRational(Handle_BRepBlend_AppFuncRoot self) -> Standard_Boolean

        Returns if the section is rationnal or not

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepBlend.Handle_BRepBlend_AppFuncRoot_IsRational(self, *args)


    def NbIntervals(self, *args):
        """
        NbIntervals(Handle_BRepBlend_AppFuncRoot self, GeomAbs_Shape const S) -> Standard_Integer

        Returns  the number  of  intervals for  continuity
        <S>. May be one if Continuity(me) >= <S>

        :type S: OCC.wrapper.GeomAbs.GeomAbs_Shape
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepBlend.Handle_BRepBlend_AppFuncRoot_NbIntervals(self, *args)


    def Intervals(self, *args):
        """
        Intervals(Handle_BRepBlend_AppFuncRoot self, NCollection_Array1_Standard_Real T, GeomAbs_Shape const S)

        Stores in <T> the  parameters bounding the intervals
        of continuity <S>.

        The array must provide  enough room to  accomodate
        for the parameters. i.e. T.Length() > NbIntervals()

        :type T: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type S: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _BRepBlend.Handle_BRepBlend_AppFuncRoot_Intervals(self, *args)


    def SetInterval(self, *args):
        """
        SetInterval(Handle_BRepBlend_AppFuncRoot self, Standard_Real const First, Standard_Real const Last)

        Sets the bounds of the parametric interval on
        the fonction
        This determines the derivatives in these values if the
        function is not Cn.

        :type First: float
        :type Last: float

        """
        return _BRepBlend.Handle_BRepBlend_AppFuncRoot_SetInterval(self, *args)


    def Resolution(self, *args):
        """
        Resolution(Handle_BRepBlend_AppFuncRoot self, Standard_Integer const Index, Standard_Real const Tol)

        Returns the resolutions in the  sub-space 2d <Index> --
        This information is usfull to find an good tolerance in
        2d approximation

        :type Index: int
        :type Tol: float
        :type TolU: float
        :type TolV: float

        """
        return _BRepBlend.Handle_BRepBlend_AppFuncRoot_Resolution(self, *args)


    def GetTolerance(self, *args):
        """
        GetTolerance(Handle_BRepBlend_AppFuncRoot self, Standard_Real const BoundTol, Standard_Real const SurfTol, Standard_Real const AngleTol, NCollection_Array1_Standard_Real Tol3d)

        Returns the tolerance to reach in approximation
        to respecte
        BoundTol error at the Boundary
        AngleTol tangent error at the Boundary (in radian)
        SurfTol error inside the surface.

        :type BoundTol: float
        :type SurfTol: float
        :type AngleTol: float
        :type Tol3d: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        return _BRepBlend.Handle_BRepBlend_AppFuncRoot_GetTolerance(self, *args)


    def SetTolerance(self, *args):
        """
        SetTolerance(Handle_BRepBlend_AppFuncRoot self, Standard_Real const Tol3d, Standard_Real const Tol2d)

        Is usfull, if (me) have to  be run numerical
        algorithme to perform D0, D1 or D2

        :type Tol3d: float
        :type Tol2d: float

        """
        return _BRepBlend.Handle_BRepBlend_AppFuncRoot_SetTolerance(self, *args)


    def BarycentreOfSurf(self, *args):
        """
        BarycentreOfSurf(Handle_BRepBlend_AppFuncRoot self) -> gp_Pnt

        Get    the   barycentre of   Surface.   An   very  poor
        estimation is sufficent. This information is usefull
        to perform well conditionned rational approximation.

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _BRepBlend.Handle_BRepBlend_AppFuncRoot_BarycentreOfSurf(self, *args)


    def MaximalSection(self, *args):
        """
        MaximalSection(Handle_BRepBlend_AppFuncRoot self) -> Standard_Real

        Returns the   length of the maximum section. This
        information is usefull to perform well conditionned rational
        approximation.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _BRepBlend.Handle_BRepBlend_AppFuncRoot_MaximalSection(self, *args)


    def GetMinimalWeight(self, *args):
        """
        GetMinimalWeight(Handle_BRepBlend_AppFuncRoot self, NCollection_Array1_Standard_Real Weigths)

        Compute the minimal value of weight for each poles
        of all  sections.  This information is  usefull to
        perform well conditionned rational approximation.

        :type Weigths: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        return _BRepBlend.Handle_BRepBlend_AppFuncRoot_GetMinimalWeight(self, *args)


    def Point(self, *args):
        """
        Point(Handle_BRepBlend_AppFuncRoot self, Blend_AppFunction Func, Standard_Real const Param, math_Vector Sol, Blend_Point Pnt)

        :type Func: OCC.wrapper.Blend.Blend_AppFunction
        :type Param: float
        :type Sol: OCC.wrapper.math.math_Vector
        :type Pnt: OCC.wrapper.Blend.Blend_Point

        """
        return _BRepBlend.Handle_BRepBlend_AppFuncRoot_Point(self, *args)


    def Vec(self, *args):
        """
        Vec(Handle_BRepBlend_AppFuncRoot self, math_Vector Sol, Blend_Point Pnt)

        :type Sol: OCC.wrapper.math.math_Vector
        :type Pnt: OCC.wrapper.Blend.Blend_Point

        """
        return _BRepBlend.Handle_BRepBlend_AppFuncRoot_Vec(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_BRepBlend_AppFuncRoot self) -> char const *

        :rtype: const char *

        """
        return _BRepBlend.Handle_BRepBlend_AppFuncRoot_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _BRepBlend.Handle_BRepBlend_AppFuncRoot_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _BRepBlend.Handle_BRepBlend_AppFuncRoot_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_BRepBlend_AppFuncRoot self)

        Memory deallocator for transient classes


        """
        return _BRepBlend.Handle_BRepBlend_AppFuncRoot_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_BRepBlend_AppFuncRoot self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_BRepBlend_AppFuncRoot self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepBlend.Handle_BRepBlend_AppFuncRoot_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_BRepBlend_AppFuncRoot self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_BRepBlend_AppFuncRoot self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepBlend.Handle_BRepBlend_AppFuncRoot_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_BRepBlend_AppFuncRoot self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _BRepBlend.Handle_BRepBlend_AppFuncRoot_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_BRepBlend_AppFuncRoot self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepBlend.Handle_BRepBlend_AppFuncRoot_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_BRepBlend_AppFuncRoot self)

        Increments the reference counter of this object


        """
        return _BRepBlend.Handle_BRepBlend_AppFuncRoot_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_BRepBlend_AppFuncRoot self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepBlend.Handle_BRepBlend_AppFuncRoot_DecrementRefCounter(self, *args)

Handle_BRepBlend_AppFuncRoot_swigregister = _BRepBlend.Handle_BRepBlend_AppFuncRoot_swigregister
Handle_BRepBlend_AppFuncRoot_swigregister(Handle_BRepBlend_AppFuncRoot)

def Handle_BRepBlend_AppFuncRoot_DownCast(thing):
    return _BRepBlend.Handle_BRepBlend_AppFuncRoot_DownCast(thing)
Handle_BRepBlend_AppFuncRoot_DownCast = _BRepBlend.Handle_BRepBlend_AppFuncRoot_DownCast

class BRepBlend_RstRstEvolRad(Blend.Blend_RstRstFunction):
    """
    Function  to approximate by AppSurface  for
    Edge/Edge  and  evolutif  radius
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BRepBlend_RstRstEvolRad self, Handle_Adaptor3d_HSurface Surf1, Handle_Adaptor2d_HCurve2d Rst1, Handle_Adaptor3d_HSurface Surf2, Handle_Adaptor2d_HCurve2d Rst2, Handle_Adaptor3d_HCurve CGuide, Handle_Law_Function Evol) -> BRepBlend_RstRstEvolRad

        :type Surf1: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface
        :type Rst1: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d
        :type Surf2: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface
        :type Rst2: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d
        :type CGuide: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HCurve
        :type Evol: OCC.wrapper.Law.Handle_Law_Function

        """
        this = _BRepBlend.new_BRepBlend_RstRstEvolRad(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def NbVariables(self, *args):
        """
        NbVariables(BRepBlend_RstRstEvolRad self) -> Standard_Integer

        Returns 2.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepBlend.BRepBlend_RstRstEvolRad_NbVariables(self, *args)


    def NbEquations(self, *args):
        """
        NbEquations(BRepBlend_RstRstEvolRad self) -> Standard_Integer

        Returns 2.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepBlend.BRepBlend_RstRstEvolRad_NbEquations(self, *args)


    def Value(self, *args):
        """
        Value(BRepBlend_RstRstEvolRad self, math_Vector X, math_Vector F) -> Standard_Boolean

        computes the values <F> of the Functions for the
        variable <X>.
        Returns True if the computation was done successfully,
        False otherwise.

        :type X: OCC.wrapper.math.math_Vector
        :type F: OCC.wrapper.math.math_Vector
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepBlend.BRepBlend_RstRstEvolRad_Value(self, *args)


    def Derivatives(self, *args):
        """
        Derivatives(BRepBlend_RstRstEvolRad self, math_Vector X, math_Matrix D) -> Standard_Boolean

        returns the values <D> of the derivatives for the
        variable <X>.
        Returns True if the computation was done successfully,
        False otherwise.

        :type X: OCC.wrapper.math.math_Vector
        :type D: OCC.wrapper.math.math_Matrix
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepBlend.BRepBlend_RstRstEvolRad_Derivatives(self, *args)


    def Values(self, *args):
        """
        Values(BRepBlend_RstRstEvolRad self, math_Vector X, math_Vector F, math_Matrix D) -> Standard_Boolean

        returns the values <F> of the functions and the derivatives
        <D> for the variable <X>.
        Returns True if the computation was done successfully,
        False otherwise.

        :type X: OCC.wrapper.math.math_Vector
        :type F: OCC.wrapper.math.math_Vector
        :type D: OCC.wrapper.math.math_Matrix
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepBlend.BRepBlend_RstRstEvolRad_Values(self, *args)


    def GetBounds(self, *args):
        """
        GetBounds(BRepBlend_RstRstEvolRad self, math_Vector InfBound, math_Vector SupBound)

        :type InfBound: OCC.wrapper.math.math_Vector
        :type SupBound: OCC.wrapper.math.math_Vector

        """
        return _BRepBlend.BRepBlend_RstRstEvolRad_GetBounds(self, *args)


    def IsSolution(self, *args):
        """
        IsSolution(BRepBlend_RstRstEvolRad self, math_Vector Sol, Standard_Real const Tol) -> Standard_Boolean

        :type Sol: OCC.wrapper.math.math_Vector
        :type Tol: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepBlend.BRepBlend_RstRstEvolRad_IsSolution(self, *args)


    def GetMinimalDistance(self, *args):
        """
        GetMinimalDistance(BRepBlend_RstRstEvolRad self) -> Standard_Real

        Returns   the    minimal  Distance  beetween   two
        extremitys of calculed sections.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _BRepBlend.BRepBlend_RstRstEvolRad_GetMinimalDistance(self, *args)


    def PointOnRst1(self, *args):
        """
        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        res = _BRepBlend.BRepBlend_RstRstEvolRad_PointOnRst1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def PointOnRst2(self, *args):
        """
        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        res = _BRepBlend.BRepBlend_RstRstEvolRad_PointOnRst2(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Pnt2dOnRst1(self, *args):
        """
        Returns U,V coordinates of the point on the surface.

        :rtype: OCC.wrapper.gp.gp_Pnt2d

        """
        res = _BRepBlend.BRepBlend_RstRstEvolRad_Pnt2dOnRst1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Pnt2dOnRst2(self, *args):
        """
        Returns  U,V coordinates of the point  on the curve on
        surface.

        :rtype: OCC.wrapper.gp.gp_Pnt2d

        """
        res = _BRepBlend.BRepBlend_RstRstEvolRad_Pnt2dOnRst2(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ParameterOnRst1(self, *args):
        """
        ParameterOnRst1(BRepBlend_RstRstEvolRad self) -> Standard_Real

        Returns parameter of the point on the curve.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _BRepBlend.BRepBlend_RstRstEvolRad_ParameterOnRst1(self, *args)


    def ParameterOnRst2(self, *args):
        """
        ParameterOnRst2(BRepBlend_RstRstEvolRad self) -> Standard_Real

        Returns parameter of the point on the curve.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _BRepBlend.BRepBlend_RstRstEvolRad_ParameterOnRst2(self, *args)


    def IsTangencyPoint(self, *args):
        """
        IsTangencyPoint(BRepBlend_RstRstEvolRad self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepBlend.BRepBlend_RstRstEvolRad_IsTangencyPoint(self, *args)


    def TangentOnRst1(self, *args):
        """
        :rtype: OCC.wrapper.gp.gp_Vec

        """
        res = _BRepBlend.BRepBlend_RstRstEvolRad_TangentOnRst1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Tangent2dOnRst1(self, *args):
        """
        :rtype: OCC.wrapper.gp.gp_Vec2d

        """
        res = _BRepBlend.BRepBlend_RstRstEvolRad_Tangent2dOnRst1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def TangentOnRst2(self, *args):
        """
        :rtype: OCC.wrapper.gp.gp_Vec

        """
        res = _BRepBlend.BRepBlend_RstRstEvolRad_TangentOnRst2(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Tangent2dOnRst2(self, *args):
        """
        :rtype: OCC.wrapper.gp.gp_Vec2d

        """
        res = _BRepBlend.BRepBlend_RstRstEvolRad_Tangent2dOnRst2(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Decroch(self, *args):
        """
        Decroch(BRepBlend_RstRstEvolRad self, math_Vector Sol, gp_Vec NRst1, gp_Vec TgRst1, gp_Vec NRst2, gp_Vec TgRst2) -> Blend_DecrochStatus

        Enables  implementation of a criterion  of  decrochage
        specific to the function.

        :type Sol: OCC.wrapper.math.math_Vector
        :type NRst1: OCC.wrapper.gp.gp_Vec
        :type TgRst1: OCC.wrapper.gp.gp_Vec
        :type NRst2: OCC.wrapper.gp.gp_Vec
        :type TgRst2: OCC.wrapper.gp.gp_Vec
        :rtype: OCC.wrapper.Blend.Blend_DecrochStatus

        """
        return _BRepBlend.BRepBlend_RstRstEvolRad_Decroch(self, *args)


    def Set(self, *args):
        """
        Set(BRepBlend_RstRstEvolRad self, Handle_Adaptor3d_HSurface SurfRef1, Handle_Adaptor2d_HCurve2d RstRef1, Handle_Adaptor3d_HSurface SurfRef2, Handle_Adaptor2d_HCurve2d RstRef2)
        Set(BRepBlend_RstRstEvolRad self, Standard_Real const Param)
        Set(BRepBlend_RstRstEvolRad self, Standard_Real const First, Standard_Real const Last)
        Set(BRepBlend_RstRstEvolRad self, Standard_Integer const Choix)
        Set(BRepBlend_RstRstEvolRad self, BlendFunc_SectionShape const TypeSection)

        Sets  the  type  of   section generation   for the
        approximations.

        :type TypeSection: OCC.wrapper.BlendFunc.BlendFunc_SectionShape

        """
        return _BRepBlend.BRepBlend_RstRstEvolRad_Set(self, *args)


    def CenterCircleRst1Rst2(self, *args):
        """
        CenterCircleRst1Rst2(BRepBlend_RstRstEvolRad self, gp_Pnt PtRst1, gp_Pnt PtRst2, gp_Vec np, gp_Pnt Center, gp_Vec VdMed) -> Standard_Boolean

        Gives the center of circle defined   by PtRst1, PtRst2 and
        radius ray.

        :type PtRst1: OCC.wrapper.gp.gp_Pnt
        :type PtRst2: OCC.wrapper.gp.gp_Pnt
        :type np: OCC.wrapper.gp.gp_Vec
        :type Center: OCC.wrapper.gp.gp_Pnt
        :type VdMed: OCC.wrapper.gp.gp_Vec
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepBlend.BRepBlend_RstRstEvolRad_CenterCircleRst1Rst2(self, *args)


    def IsRational(self, *args):
        """
        IsRational(BRepBlend_RstRstEvolRad self) -> Standard_Boolean

        Returns  if the section is rationnal

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepBlend.BRepBlend_RstRstEvolRad_IsRational(self, *args)


    def GetSectionSize(self, *args):
        """
        GetSectionSize(BRepBlend_RstRstEvolRad self) -> Standard_Real

        Returns the length of the maximum section

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _BRepBlend.BRepBlend_RstRstEvolRad_GetSectionSize(self, *args)


    def GetMinimalWeight(self, *args):
        """
        GetMinimalWeight(BRepBlend_RstRstEvolRad self, NCollection_Array1_Standard_Real Weigths)

        Compute the minimal value of weight for each poles
        of all sections.

        :type Weigths: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        return _BRepBlend.BRepBlend_RstRstEvolRad_GetMinimalWeight(self, *args)


    def NbIntervals(self, *args):
        """
        NbIntervals(BRepBlend_RstRstEvolRad self, GeomAbs_Shape const S) -> Standard_Integer

        Returns  the number  of  intervals for  continuity
        <S>. May be one if Continuity(me) >= <S>

        :type S: OCC.wrapper.GeomAbs.GeomAbs_Shape
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepBlend.BRepBlend_RstRstEvolRad_NbIntervals(self, *args)


    def Intervals(self, *args):
        """
        Intervals(BRepBlend_RstRstEvolRad self, NCollection_Array1_Standard_Real T, GeomAbs_Shape const S)

        Stores in <T> the  parameters bounding the intervals
        of continuity <S>.
        The array must provide  enough room to  accomodate
        for the parameters. i.e. T.Length() > NbIntervals()

        :type T: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type S: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _BRepBlend.BRepBlend_RstRstEvolRad_Intervals(self, *args)


    def GetShape(self, *args):
        """
        GetShape(BRepBlend_RstRstEvolRad self)

        :type NbPoles: int
        :type NbKnots: int
        :type Degree: int
        :type NbPoles2d: int

        """
        return _BRepBlend.BRepBlend_RstRstEvolRad_GetShape(self, *args)


    def GetTolerance(self, *args):
        """
        GetTolerance(BRepBlend_RstRstEvolRad self, math_Vector Tolerance, Standard_Real const Tol)
        GetTolerance(BRepBlend_RstRstEvolRad self, Standard_Real const BoundTol, Standard_Real const SurfTol, Standard_Real const AngleTol, math_Vector Tol3d, math_Vector Tol1D)

        Returns the tolerance to reach in approximation
        to respecte
        BoundTol error at the Boundary
        AngleTol tangent error at the Boundary
        SurfTol error inside the surface.

        :type BoundTol: float
        :type SurfTol: float
        :type AngleTol: float
        :type Tol3d: OCC.wrapper.math.math_Vector
        :type Tol1D: OCC.wrapper.math.math_Vector

        """
        return _BRepBlend.BRepBlend_RstRstEvolRad_GetTolerance(self, *args)


    def Knots(self, *args):
        """
        Knots(BRepBlend_RstRstEvolRad self, NCollection_Array1_Standard_Real TKnots)

        :type TKnots: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        return _BRepBlend.BRepBlend_RstRstEvolRad_Knots(self, *args)


    def Mults(self, *args):
        """
        Mults(BRepBlend_RstRstEvolRad self, NCollection_Array1_Standard_Integer TMults)

        :type TMults: OCC.wrapper.TColStd.TColStd_Array1OfInteger

        """
        return _BRepBlend.BRepBlend_RstRstEvolRad_Mults(self, *args)


    def Section(self, *args):
        """
        Section(BRepBlend_RstRstEvolRad self, Standard_Real const Param, Standard_Real const U, Standard_Real const V, gp_Circ C)
        Section(BRepBlend_RstRstEvolRad self, Blend_Point P, NCollection_Array1_gp_Pnt Poles, NCollection_Array1_gp_Vec DPoles, NCollection_Array1_gp_Pnt2d Poles2d, NCollection_Array1_gp_Vec2d DPoles2d, NCollection_Array1_Standard_Real Weigths, NCollection_Array1_Standard_Real DWeigths) -> Standard_Boolean
        Section(BRepBlend_RstRstEvolRad self, Blend_Point P, NCollection_Array1_gp_Pnt Poles, NCollection_Array1_gp_Pnt2d Poles2d, NCollection_Array1_Standard_Real Weigths)
        Section(BRepBlend_RstRstEvolRad self, Blend_Point P, NCollection_Array1_gp_Pnt Poles, NCollection_Array1_gp_Vec DPoles, NCollection_Array1_gp_Vec D2Poles, NCollection_Array1_gp_Pnt2d Poles2d, NCollection_Array1_gp_Vec2d DPoles2d, NCollection_Array1_gp_Vec2d D2Poles2d, NCollection_Array1_Standard_Real Weigths, NCollection_Array1_Standard_Real DWeigths, NCollection_Array1_Standard_Real D2Weigths) -> Standard_Boolean

        Used for the first and last section
        The method returns Standard_True if the derivatives
        are computed, otherwise it returns Standard_False.

        :type P: OCC.wrapper.Blend.Blend_Point
        :type Poles: OCC.wrapper.TColgp.TColgp_Array1OfPnt
        :type DPoles: OCC.wrapper.TColgp.TColgp_Array1OfVec
        :type D2Poles: OCC.wrapper.TColgp.TColgp_Array1OfVec
        :type Poles2d: OCC.wrapper.TColgp.TColgp_Array1OfPnt2d
        :type DPoles2d: OCC.wrapper.TColgp.TColgp_Array1OfVec2d
        :type D2Poles2d: OCC.wrapper.TColgp.TColgp_Array1OfVec2d
        :type Weigths: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type DWeigths: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type D2Weigths: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepBlend.BRepBlend_RstRstEvolRad_Section(self, *args)


    def Resolution(self, *args):
        """
        Resolution(BRepBlend_RstRstEvolRad self, Standard_Integer const IC2d, Standard_Real const Tol)

        :type IC2d: int
        :type Tol: float
        :type TolU: float
        :type TolV: float

        """
        return _BRepBlend.BRepBlend_RstRstEvolRad_Resolution(self, *args)

    __swig_destroy__ = _BRepBlend.delete_BRepBlend_RstRstEvolRad
BRepBlend_RstRstEvolRad_swigregister = _BRepBlend.BRepBlend_RstRstEvolRad_swigregister
BRepBlend_RstRstEvolRad_swigregister(BRepBlend_RstRstEvolRad)

class BRepBlend_RstRstLineBuilder(object):
    """
    This  class processes the  data  resulting from
    Blend_CSWalking  but  it  takes  in  consideration the Surface
    supporting  the  curve to detect the  breakpoint.

    As  a  result, the  criteria of distribution of
    points on  the line become  more flexible  because  it
    should  calculate values  approached
    by an approximation of continued  functions based on the
    Blend_RstRstFunction.

    Thus this pseudo path necessitates 3 criteria  of
    regrouping :

    1) exit of  the domain of  the  curve

    2) exit of  the domain of  the surface

    3) stall as there  is a solution of problem
    surf/surf  within the domain  of the  surface
    of support of the restriction.

    Construction of a BRepBlend_Line between two pcurves
    from an approached starting solution. The output
    entries of this builder are of the same nature
    as of a traditional walking, but the requirements
    to the Line are not the same. If the determination of validity range is always
    guaranteed, the criteria of correct repartition of sections
    before smoothing are not respected. The resulting Line
    is f(t) oriented.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BRepBlend_RstRstLineBuilder self, Handle_Adaptor3d_HSurface Surf1, Handle_Adaptor2d_HCurve2d Rst1, Handle_Adaptor3d_TopolTool Domain1, Handle_Adaptor3d_HSurface Surf2, Handle_Adaptor2d_HCurve2d Rst2, Handle_Adaptor3d_TopolTool Domain2) -> BRepBlend_RstRstLineBuilder

        :type Surf1: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface
        :type Rst1: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d
        :type Domain1: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_TopolTool
        :type Surf2: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface
        :type Rst2: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d
        :type Domain2: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_TopolTool

        """
        this = _BRepBlend.new_BRepBlend_RstRstLineBuilder(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Perform(self, *args):
        """
        Perform(BRepBlend_RstRstLineBuilder self, Blend_RstRstFunction Func, Blend_SurfCurvFuncInv Finv1, Blend_CurvPointFuncInv FinvP1, Blend_SurfCurvFuncInv Finv2, Blend_CurvPointFuncInv FinvP2, Standard_Real const Pdep, Standard_Real const Pmax, Standard_Real const MaxStep, Standard_Real const TolGuide, math_Vector Soldep, Standard_Real const Tolesp, Standard_Real const Fleche, Standard_Boolean const Appro)

        :type Func: OCC.wrapper.Blend.Blend_RstRstFunction
        :type Finv1: OCC.wrapper.Blend.Blend_SurfCurvFuncInv
        :type FinvP1: OCC.wrapper.Blend.Blend_CurvPointFuncInv
        :type Finv2: OCC.wrapper.Blend.Blend_SurfCurvFuncInv
        :type FinvP2: OCC.wrapper.Blend.Blend_CurvPointFuncInv
        :type Pdep: float
        :type Pmax: float
        :type MaxStep: float
        :type TolGuide: float
        :type Soldep: OCC.wrapper.math.math_Vector
        :type Tolesp: float
        :type Fleche: float
        :type Appro: bool

        """
        return _BRepBlend.BRepBlend_RstRstLineBuilder_Perform(self, *args)


    def PerformFirstSection(self, *args):
        """
        PerformFirstSection(BRepBlend_RstRstLineBuilder self, Blend_RstRstFunction Func, Blend_SurfCurvFuncInv Finv1, Blend_CurvPointFuncInv FinvP1, Blend_SurfCurvFuncInv Finv2, Blend_CurvPointFuncInv FinvP2, Standard_Real const Pdep, Standard_Real const Pmax, math_Vector Soldep, Standard_Real const Tolesp, Standard_Real const TolGuide, Standard_Boolean const RecRst1, Standard_Boolean const RecP1, Standard_Boolean const RecRst2, Standard_Boolean const RecP2, math_Vector ParSol) -> Standard_Boolean

        :type Func: OCC.wrapper.Blend.Blend_RstRstFunction
        :type Finv1: OCC.wrapper.Blend.Blend_SurfCurvFuncInv
        :type FinvP1: OCC.wrapper.Blend.Blend_CurvPointFuncInv
        :type Finv2: OCC.wrapper.Blend.Blend_SurfCurvFuncInv
        :type FinvP2: OCC.wrapper.Blend.Blend_CurvPointFuncInv
        :type Pdep: float
        :type Pmax: float
        :type Soldep: OCC.wrapper.math.math_Vector
        :type Tolesp: float
        :type TolGuide: float
        :type RecRst1: bool
        :type RecP1: bool
        :type RecRst2: bool
        :type RecP2: bool
        :type Psol: float
        :type ParSol: OCC.wrapper.math.math_Vector
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepBlend.BRepBlend_RstRstLineBuilder_PerformFirstSection(self, *args)


    def Complete(self, *args):
        """
        Complete(BRepBlend_RstRstLineBuilder self, Blend_RstRstFunction Func, Blend_SurfCurvFuncInv Finv1, Blend_CurvPointFuncInv FinvP1, Blend_SurfCurvFuncInv Finv2, Blend_CurvPointFuncInv FinvP2, Standard_Real const Pmin) -> Standard_Boolean

        :type Func: OCC.wrapper.Blend.Blend_RstRstFunction
        :type Finv1: OCC.wrapper.Blend.Blend_SurfCurvFuncInv
        :type FinvP1: OCC.wrapper.Blend.Blend_CurvPointFuncInv
        :type Finv2: OCC.wrapper.Blend.Blend_SurfCurvFuncInv
        :type FinvP2: OCC.wrapper.Blend.Blend_CurvPointFuncInv
        :type Pmin: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepBlend.BRepBlend_RstRstLineBuilder_Complete(self, *args)


    def IsDone(self, *args):
        """
        IsDone(BRepBlend_RstRstLineBuilder self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepBlend.BRepBlend_RstRstLineBuilder_IsDone(self, *args)


    def Line(self, *args):
        """
        :rtype: OCC.wrapper.BRepBlend.Handle_BRepBlend_Line

        """
        res = _BRepBlend.BRepBlend_RstRstLineBuilder_Line(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Decroch1Start(self, *args):
        """
        Decroch1Start(BRepBlend_RstRstLineBuilder self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepBlend.BRepBlend_RstRstLineBuilder_Decroch1Start(self, *args)


    def Decroch1End(self, *args):
        """
        Decroch1End(BRepBlend_RstRstLineBuilder self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepBlend.BRepBlend_RstRstLineBuilder_Decroch1End(self, *args)


    def Decroch2Start(self, *args):
        """
        Decroch2Start(BRepBlend_RstRstLineBuilder self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepBlend.BRepBlend_RstRstLineBuilder_Decroch2Start(self, *args)


    def Decroch2End(self, *args):
        """
        Decroch2End(BRepBlend_RstRstLineBuilder self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepBlend.BRepBlend_RstRstLineBuilder_Decroch2End(self, *args)

    __swig_destroy__ = _BRepBlend.delete_BRepBlend_RstRstLineBuilder
BRepBlend_RstRstLineBuilder_swigregister = _BRepBlend.BRepBlend_RstRstLineBuilder_swigregister
BRepBlend_RstRstLineBuilder_swigregister(BRepBlend_RstRstLineBuilder)

class NCollection_Sequence_Handle_BRepBlend_Line(NCollection.NCollection_BaseSequence):
    """
    Purpose:     Definition of a sequence of elements indexed by
    an Integer in range of 1..n
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Sequence_Handle_BRepBlend_Line self) -> NCollection_Sequence< opencascade::handle< BRepBlend_Line > >::iterator

        Returns an iterator pointing to the first element in the sequence.

        :rtype: iterator

        """
        return _BRepBlend.NCollection_Sequence_Handle_BRepBlend_Line_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Sequence_Handle_BRepBlend_Line self) -> NCollection_Sequence< opencascade::handle< BRepBlend_Line > >::iterator

        Returns an iterator referring to the past-the-end element in the sequence.

        :rtype: iterator

        """
        return _BRepBlend.NCollection_Sequence_Handle_BRepBlend_Line_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Sequence_Handle_BRepBlend_Line self) -> NCollection_Sequence< opencascade::handle< BRepBlend_Line > >::const_iterator

        Returns a const iterator pointing to the first element in the sequence.

        :rtype: const_iterator

        """
        return _BRepBlend.NCollection_Sequence_Handle_BRepBlend_Line_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Sequence_Handle_BRepBlend_Line self) -> NCollection_Sequence< opencascade::handle< BRepBlend_Line > >::const_iterator

        Returns a const iterator referring to the past-the-end element in the sequence.

        :rtype: const_iterator

        """
        return _BRepBlend.NCollection_Sequence_Handle_BRepBlend_Line_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     Definition of a sequence of elements indexed by
        an Integer in range of 1..n
        """
        this = _BRepBlend.new_NCollection_Sequence_Handle_BRepBlend_Line(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Size(self, *args):
        """
        Size(NCollection_Sequence_Handle_BRepBlend_Line self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepBlend.NCollection_Sequence_Handle_BRepBlend_Line_Size(self, *args)


    def Length(self, *args):
        """
        Length(NCollection_Sequence_Handle_BRepBlend_Line self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepBlend.NCollection_Sequence_Handle_BRepBlend_Line_Length(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Sequence_Handle_BRepBlend_Line self) -> Standard_Integer

        Method for consistency with other collections.
        @return Lower bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepBlend.NCollection_Sequence_Handle_BRepBlend_Line_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Sequence_Handle_BRepBlend_Line self) -> Standard_Integer

        Method for consistency with other collections.
        @return Upper bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepBlend.NCollection_Sequence_Handle_BRepBlend_Line_Upper(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Sequence_Handle_BRepBlend_Line self) -> Standard_Boolean

        Empty query

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepBlend.NCollection_Sequence_Handle_BRepBlend_Line_IsEmpty(self, *args)


    def Reverse(self, *args):
        """
        Reverse(NCollection_Sequence_Handle_BRepBlend_Line self)

        Reverse sequence


        """
        return _BRepBlend.NCollection_Sequence_Handle_BRepBlend_Line_Reverse(self, *args)


    def Exchange(self, *args):
        """
        Exchange(NCollection_Sequence_Handle_BRepBlend_Line self, Standard_Integer const I, Standard_Integer const J)

        Exchange two members

        :type I: int
        :type J: int

        """
        return _BRepBlend.NCollection_Sequence_Handle_BRepBlend_Line_Exchange(self, *args)


    def delNode(*args):
        """
        delNode(NCollection_SeqNode theNode, Handle_NCollection_BaseAllocator theAl)

        Static deleter to be passed to BaseSequence

        :type theNode: OCC.wrapper.NCollection.NCollection_SeqNode
        :type theAl: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _BRepBlend.NCollection_Sequence_Handle_BRepBlend_Line_delNode(*args)

    delNode = staticmethod(delNode)

    def Clear(self, *args):
        """
        Clear(NCollection_Sequence_Handle_BRepBlend_Line self, Handle_NCollection_BaseAllocator theAllocator=0)

        Clear the items out, take a new allocator if non null

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _BRepBlend.NCollection_Sequence_Handle_BRepBlend_Line_Clear(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Sequence_Handle_BRepBlend_Line self, NCollection_Sequence_Handle_BRepBlend_Line theOther) -> NCollection_Sequence_Handle_BRepBlend_Line

        Replace this sequence by the items of theOther.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_Sequence
        :rtype: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _BRepBlend.NCollection_Sequence_Handle_BRepBlend_Line_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Sequence_Handle_BRepBlend_Line self, NCollection_Sequence_Handle_BRepBlend_Line theOther) -> NCollection_Sequence_Handle_BRepBlend_Line

        Replacement operator

        :type theOther: OCC.wrapper.NCollection.NCollection_Sequence
        :rtype: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _BRepBlend.NCollection_Sequence_Handle_BRepBlend_Line_assign(self, *args)


    def Remove(self, *args):
        """
        Remove(NCollection_Sequence_Handle_BRepBlend_Line self, NCollection_Sequence< opencascade::handle< BRepBlend_Line > >::Iterator & thePosition)
        Remove(NCollection_Sequence_Handle_BRepBlend_Line self, Standard_Integer const theIndex)
        Remove(NCollection_Sequence_Handle_BRepBlend_Line self, Standard_Integer const theFromIndex, Standard_Integer const theToIndex)

        Remove range of items

        :type theFromIndex: int
        :type theToIndex: int

        """
        return _BRepBlend.NCollection_Sequence_Handle_BRepBlend_Line_Remove(self, *args)


    def Append(self, *args):
        """
        Append(NCollection_Sequence_Handle_BRepBlend_Line self, Handle_BRepBlend_Line theItem)
        Append(NCollection_Sequence_Handle_BRepBlend_Line self, NCollection_Sequence_Handle_BRepBlend_Line theSeq)

        Append another sequence (making it empty)

        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _BRepBlend.NCollection_Sequence_Handle_BRepBlend_Line_Append(self, *args)


    def Prepend(self, *args):
        """
        Prepend(NCollection_Sequence_Handle_BRepBlend_Line self, Handle_BRepBlend_Line theItem)
        Prepend(NCollection_Sequence_Handle_BRepBlend_Line self, NCollection_Sequence_Handle_BRepBlend_Line theSeq)

        Prepend another sequence (making it empty)

        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _BRepBlend.NCollection_Sequence_Handle_BRepBlend_Line_Prepend(self, *args)


    def InsertBefore(self, *args):
        """
        InsertBefore(NCollection_Sequence_Handle_BRepBlend_Line self, Standard_Integer const theIndex, Handle_BRepBlend_Line theItem)
        InsertBefore(NCollection_Sequence_Handle_BRepBlend_Line self, Standard_Integer const theIndex, NCollection_Sequence_Handle_BRepBlend_Line theSeq)

        InsertBefore theIndex another sequence

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _BRepBlend.NCollection_Sequence_Handle_BRepBlend_Line_InsertBefore(self, *args)


    def InsertAfter(self, *args):
        """
        InsertAfter(NCollection_Sequence_Handle_BRepBlend_Line self, NCollection_Sequence< opencascade::handle< BRepBlend_Line > >::Iterator & thePosition, Handle_BRepBlend_Line theItem)
        InsertAfter(NCollection_Sequence_Handle_BRepBlend_Line self, Standard_Integer const theIndex, NCollection_Sequence_Handle_BRepBlend_Line theSeq)
        InsertAfter(NCollection_Sequence_Handle_BRepBlend_Line self, Standard_Integer const theIndex, Handle_BRepBlend_Line theItem)

        InsertAfter theIndex another sequence

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _BRepBlend.NCollection_Sequence_Handle_BRepBlend_Line_InsertAfter(self, *args)


    def Split(self, *args):
        """
        Split(NCollection_Sequence_Handle_BRepBlend_Line self, Standard_Integer const theIndex, NCollection_Sequence_Handle_BRepBlend_Line theSeq)

        Split in two sequences

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _BRepBlend.NCollection_Sequence_Handle_BRepBlend_Line_Split(self, *args)


    def First(self, *args):
        """
        First item access

        :rtype: const TheItemType &

        """
        res = _BRepBlend.NCollection_Sequence_Handle_BRepBlend_Line_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Sequence_Handle_BRepBlend_Line self) -> Handle_BRepBlend_Line

        First item access

        :rtype: TheItemType &

        """
        return _BRepBlend.NCollection_Sequence_Handle_BRepBlend_Line_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        Last item access

        :rtype: const TheItemType &

        """
        res = _BRepBlend.NCollection_Sequence_Handle_BRepBlend_Line_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Sequence_Handle_BRepBlend_Line self) -> Handle_BRepBlend_Line

        Last item access

        :rtype: TheItemType &

        """
        return _BRepBlend.NCollection_Sequence_Handle_BRepBlend_Line_ChangeLast(self, *args)


    def Value(self, *args):
        """
        Constant item access by theIndex

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _BRepBlend.NCollection_Sequence_Handle_BRepBlend_Line_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Sequence_Handle_BRepBlend_Line self, Standard_Integer const theIndex) -> Handle_BRepBlend_Line

        Variable item access by theIndex

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _BRepBlend.NCollection_Sequence_Handle_BRepBlend_Line_ChangeValue(self, *args)


    def __call__(self, *args):
        """
        Constant operator()

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _BRepBlend.NCollection_Sequence_Handle_BRepBlend_Line___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetValue(self, *args):
        """
        SetValue(NCollection_Sequence_Handle_BRepBlend_Line self, Standard_Integer const theIndex, Handle_BRepBlend_Line theItem)

        Set item value by theIndex

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _BRepBlend.NCollection_Sequence_Handle_BRepBlend_Line_SetValue(self, *args)


    def __iter__(self):
        return _BRepBlend.NCollection_Sequence_Handle_BRepBlend_Line___iter__(self)
    __swig_destroy__ = _BRepBlend.delete_NCollection_Sequence_Handle_BRepBlend_Line
NCollection_Sequence_Handle_BRepBlend_Line_swigregister = _BRepBlend.NCollection_Sequence_Handle_BRepBlend_Line_swigregister
NCollection_Sequence_Handle_BRepBlend_Line_swigregister(NCollection_Sequence_Handle_BRepBlend_Line)

def NCollection_Sequence_Handle_BRepBlend_Line_delNode(*args):
    """
    NCollection_Sequence_Handle_BRepBlend_Line_delNode(NCollection_SeqNode theNode, Handle_NCollection_BaseAllocator theAl)

    Static deleter to be passed to BaseSequence

    :type theNode: OCC.wrapper.NCollection.NCollection_SeqNode
    :type theAl: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

    """
    return _BRepBlend.NCollection_Sequence_Handle_BRepBlend_Line_delNode(*args)

class NCollection_Sequence_Handle_BRepBlend_Line_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _BRepBlend.new_NCollection_Sequence_Handle_BRepBlend_Line_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _BRepBlend.delete_NCollection_Sequence_Handle_BRepBlend_Line_IteratorHelper

    def __next__(self):
        return _BRepBlend.NCollection_Sequence_Handle_BRepBlend_Line_IteratorHelper___next__(self)
NCollection_Sequence_Handle_BRepBlend_Line_IteratorHelper_swigregister = _BRepBlend.NCollection_Sequence_Handle_BRepBlend_Line_IteratorHelper_swigregister
NCollection_Sequence_Handle_BRepBlend_Line_IteratorHelper_swigregister(NCollection_Sequence_Handle_BRepBlend_Line_IteratorHelper)


try:
	BRepBlend_SequenceOfLine = NCollection_Sequence_Handle_BRepBlend_Line
except NameError:
	pass # does not exist, probably ignored

class BRepBlend_SurfPointConstRadInv(Blend.Blend_SurfPointFuncInv):
    """
    Function of reframing between a point and a surface.
    This function  is used  to find a  solution on  a done
    point   of   the curve when   using  SurfRstConsRad or
    CSConstRad...
    The vector <X>  used in Value, Values and  Derivatives
    methods  has  to   be the  vector   of the  parametric
    coordinates w, U,  V where w is  the parameter  on the
    guide line, U,V   are the parametric coordinates of  a
    point on the partner surface.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BRepBlend_SurfPointConstRadInv self, Handle_Adaptor3d_HSurface S, Handle_Adaptor3d_HCurve C) -> BRepBlend_SurfPointConstRadInv

        :type S: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface
        :type C: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HCurve

        """
        this = _BRepBlend.new_BRepBlend_SurfPointConstRadInv(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def NbEquations(self, *args):
        """
        NbEquations(BRepBlend_SurfPointConstRadInv self) -> Standard_Integer

        returns 3.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepBlend.BRepBlend_SurfPointConstRadInv_NbEquations(self, *args)


    def Value(self, *args):
        """
        Value(BRepBlend_SurfPointConstRadInv self, math_Vector X, math_Vector F) -> Standard_Boolean

        computes the values <F> of the Functions for the
        variable <X>.
        Returns True if the computation was done successfully,
        False otherwise.

        :type X: OCC.wrapper.math.math_Vector
        :type F: OCC.wrapper.math.math_Vector
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepBlend.BRepBlend_SurfPointConstRadInv_Value(self, *args)


    def Derivatives(self, *args):
        """
        Derivatives(BRepBlend_SurfPointConstRadInv self, math_Vector X, math_Matrix D) -> Standard_Boolean

        returns the values <D> of the derivatives for the
        variable <X>.
        Returns True if the computation was done successfully,
        False otherwise.

        :type X: OCC.wrapper.math.math_Vector
        :type D: OCC.wrapper.math.math_Matrix
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepBlend.BRepBlend_SurfPointConstRadInv_Derivatives(self, *args)


    def Values(self, *args):
        """
        Values(BRepBlend_SurfPointConstRadInv self, math_Vector X, math_Vector F, math_Matrix D) -> Standard_Boolean

        returns the values <F> of the functions and the derivatives
        <D> for the variable <X>.
        Returns True if the computation was done successfully,
        False otherwise.

        :type X: OCC.wrapper.math.math_Vector
        :type F: OCC.wrapper.math.math_Vector
        :type D: OCC.wrapper.math.math_Matrix
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepBlend.BRepBlend_SurfPointConstRadInv_Values(self, *args)


    def Set(self, *args):
        """
        Set(BRepBlend_SurfPointConstRadInv self, Standard_Real const R, Standard_Integer const Choix)
        Set(BRepBlend_SurfPointConstRadInv self, gp_Pnt P)

        Set the Point on which a solution has to be found.

        :type P: OCC.wrapper.gp.gp_Pnt

        """
        return _BRepBlend.BRepBlend_SurfPointConstRadInv_Set(self, *args)


    def GetTolerance(self, *args):
        """
        GetTolerance(BRepBlend_SurfPointConstRadInv self, math_Vector Tolerance, Standard_Real const Tol)

        Returns in the vector Tolerance the parametric tolerance
        for each of the 3 variables;
        Tol is the tolerance used in 3d space.

        :type Tolerance: OCC.wrapper.math.math_Vector
        :type Tol: float

        """
        return _BRepBlend.BRepBlend_SurfPointConstRadInv_GetTolerance(self, *args)


    def GetBounds(self, *args):
        """
        GetBounds(BRepBlend_SurfPointConstRadInv self, math_Vector InfBound, math_Vector SupBound)

        Returns in the vector InfBound the lowest values allowed
        for each of the 3 variables.
        Returns in the vector SupBound the greatest values allowed
        for each of the 3 variables.

        :type InfBound: OCC.wrapper.math.math_Vector
        :type SupBound: OCC.wrapper.math.math_Vector

        """
        return _BRepBlend.BRepBlend_SurfPointConstRadInv_GetBounds(self, *args)


    def IsSolution(self, *args):
        """
        IsSolution(BRepBlend_SurfPointConstRadInv self, math_Vector Sol, Standard_Real const Tol) -> Standard_Boolean

        Returns Standard_True if Sol is a zero of the function.
        Tol is the tolerance used in 3d space.

        :type Sol: OCC.wrapper.math.math_Vector
        :type Tol: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepBlend.BRepBlend_SurfPointConstRadInv_IsSolution(self, *args)

    __swig_destroy__ = _BRepBlend.delete_BRepBlend_SurfPointConstRadInv
BRepBlend_SurfPointConstRadInv_swigregister = _BRepBlend.BRepBlend_SurfPointConstRadInv_swigregister
BRepBlend_SurfPointConstRadInv_swigregister(BRepBlend_SurfPointConstRadInv)

class BRepBlend_SurfRstConstRad(Blend.Blend_SurfRstFunction):
    """
    Copy of CSConstRad with pcurve on surface
    as support.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BRepBlend_SurfRstConstRad self, Handle_Adaptor3d_HSurface Surf, Handle_Adaptor3d_HSurface SurfRst, Handle_Adaptor2d_HCurve2d Rst, Handle_Adaptor3d_HCurve CGuide) -> BRepBlend_SurfRstConstRad

        :type Surf: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface
        :type SurfRst: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface
        :type Rst: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d
        :type CGuide: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HCurve

        """
        this = _BRepBlend.new_BRepBlend_SurfRstConstRad(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def NbVariables(self, *args):
        """
        NbVariables(BRepBlend_SurfRstConstRad self) -> Standard_Integer

        Returns 3.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepBlend.BRepBlend_SurfRstConstRad_NbVariables(self, *args)


    def NbEquations(self, *args):
        """
        NbEquations(BRepBlend_SurfRstConstRad self) -> Standard_Integer

        Returns 3.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepBlend.BRepBlend_SurfRstConstRad_NbEquations(self, *args)


    def Value(self, *args):
        """
        Value(BRepBlend_SurfRstConstRad self, math_Vector X, math_Vector F) -> Standard_Boolean

        computes the values <F> of the Functions for the
        variable <X>.
        Returns True if the computation was done successfully,
        False otherwise.

        :type X: OCC.wrapper.math.math_Vector
        :type F: OCC.wrapper.math.math_Vector
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepBlend.BRepBlend_SurfRstConstRad_Value(self, *args)


    def Derivatives(self, *args):
        """
        Derivatives(BRepBlend_SurfRstConstRad self, math_Vector X, math_Matrix D) -> Standard_Boolean

        returns the values <D> of the derivatives for the
        variable <X>.
        Returns True if the computation was done successfully,
        False otherwise.

        :type X: OCC.wrapper.math.math_Vector
        :type D: OCC.wrapper.math.math_Matrix
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepBlend.BRepBlend_SurfRstConstRad_Derivatives(self, *args)


    def Values(self, *args):
        """
        Values(BRepBlend_SurfRstConstRad self, math_Vector X, math_Vector F, math_Matrix D) -> Standard_Boolean

        returns the values <F> of the functions and the derivatives
        <D> for the variable <X>.
        Returns True if the computation was done successfully,
        False otherwise.

        :type X: OCC.wrapper.math.math_Vector
        :type F: OCC.wrapper.math.math_Vector
        :type D: OCC.wrapper.math.math_Matrix
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepBlend.BRepBlend_SurfRstConstRad_Values(self, *args)


    def GetBounds(self, *args):
        """
        GetBounds(BRepBlend_SurfRstConstRad self, math_Vector InfBound, math_Vector SupBound)

        :type InfBound: OCC.wrapper.math.math_Vector
        :type SupBound: OCC.wrapper.math.math_Vector

        """
        return _BRepBlend.BRepBlend_SurfRstConstRad_GetBounds(self, *args)


    def IsSolution(self, *args):
        """
        IsSolution(BRepBlend_SurfRstConstRad self, math_Vector Sol, Standard_Real const Tol) -> Standard_Boolean

        :type Sol: OCC.wrapper.math.math_Vector
        :type Tol: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepBlend.BRepBlend_SurfRstConstRad_IsSolution(self, *args)


    def GetMinimalDistance(self, *args):
        """
        GetMinimalDistance(BRepBlend_SurfRstConstRad self) -> Standard_Real

        Returns   the    minimal  Distance  beetween   two
        extremitys of calculed sections.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _BRepBlend.BRepBlend_SurfRstConstRad_GetMinimalDistance(self, *args)


    def PointOnS(self, *args):
        """
        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        res = _BRepBlend.BRepBlend_SurfRstConstRad_PointOnS(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def PointOnRst(self, *args):
        """
        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        res = _BRepBlend.BRepBlend_SurfRstConstRad_PointOnRst(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Pnt2dOnS(self, *args):
        """
        Returns U,V coordinates of the point on the surface.

        :rtype: OCC.wrapper.gp.gp_Pnt2d

        """
        res = _BRepBlend.BRepBlend_SurfRstConstRad_Pnt2dOnS(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Pnt2dOnRst(self, *args):
        """
        Returns  U,V coordinates of the point  on the curve on
        surface.

        :rtype: OCC.wrapper.gp.gp_Pnt2d

        """
        res = _BRepBlend.BRepBlend_SurfRstConstRad_Pnt2dOnRst(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ParameterOnRst(self, *args):
        """
        ParameterOnRst(BRepBlend_SurfRstConstRad self) -> Standard_Real

        Returns parameter of the point on the curve.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _BRepBlend.BRepBlend_SurfRstConstRad_ParameterOnRst(self, *args)


    def IsTangencyPoint(self, *args):
        """
        IsTangencyPoint(BRepBlend_SurfRstConstRad self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepBlend.BRepBlend_SurfRstConstRad_IsTangencyPoint(self, *args)


    def TangentOnS(self, *args):
        """
        :rtype: OCC.wrapper.gp.gp_Vec

        """
        res = _BRepBlend.BRepBlend_SurfRstConstRad_TangentOnS(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Tangent2dOnS(self, *args):
        """
        :rtype: OCC.wrapper.gp.gp_Vec2d

        """
        res = _BRepBlend.BRepBlend_SurfRstConstRad_Tangent2dOnS(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def TangentOnRst(self, *args):
        """
        :rtype: OCC.wrapper.gp.gp_Vec

        """
        res = _BRepBlend.BRepBlend_SurfRstConstRad_TangentOnRst(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Tangent2dOnRst(self, *args):
        """
        :rtype: OCC.wrapper.gp.gp_Vec2d

        """
        res = _BRepBlend.BRepBlend_SurfRstConstRad_Tangent2dOnRst(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Decroch(self, *args):
        """
        Decroch(BRepBlend_SurfRstConstRad self, math_Vector Sol, gp_Vec NS, gp_Vec TgS) -> Standard_Boolean

        Enables  implementation  of  a criterion of  decrochage
        specific to  the function.
        Warning: Can  be  called  without  previous  call  of  issolution
        but the values  calculated can  be  senseless.

        :type Sol: OCC.wrapper.math.math_Vector
        :type NS: OCC.wrapper.gp.gp_Vec
        :type TgS: OCC.wrapper.gp.gp_Vec
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepBlend.BRepBlend_SurfRstConstRad_Decroch(self, *args)


    def Set(self, *args):
        """
        Set(BRepBlend_SurfRstConstRad self, Handle_Adaptor3d_HSurface SurfRef, Handle_Adaptor2d_HCurve2d RstRef)
        Set(BRepBlend_SurfRstConstRad self, Standard_Real const Param)
        Set(BRepBlend_SurfRstConstRad self, Standard_Real const First, Standard_Real const Last)
        Set(BRepBlend_SurfRstConstRad self, Standard_Real const Radius, Standard_Integer const Choix)
        Set(BRepBlend_SurfRstConstRad self, BlendFunc_SectionShape const TypeSection)

        Sets  the  type  of   section generation   for the
        approximations.

        :type TypeSection: OCC.wrapper.BlendFunc.BlendFunc_SectionShape

        """
        return _BRepBlend.BRepBlend_SurfRstConstRad_Set(self, *args)


    def IsRational(self, *args):
        """
        IsRational(BRepBlend_SurfRstConstRad self) -> Standard_Boolean

        Returns  if the section is rationnal

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepBlend.BRepBlend_SurfRstConstRad_IsRational(self, *args)


    def GetSectionSize(self, *args):
        """
        GetSectionSize(BRepBlend_SurfRstConstRad self) -> Standard_Real

        Returns the length of the maximum section

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _BRepBlend.BRepBlend_SurfRstConstRad_GetSectionSize(self, *args)


    def GetMinimalWeight(self, *args):
        """
        GetMinimalWeight(BRepBlend_SurfRstConstRad self, NCollection_Array1_Standard_Real Weigths)

        Compute the minimal value of weight for each poles
        of all sections.

        :type Weigths: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        return _BRepBlend.BRepBlend_SurfRstConstRad_GetMinimalWeight(self, *args)


    def NbIntervals(self, *args):
        """
        NbIntervals(BRepBlend_SurfRstConstRad self, GeomAbs_Shape const S) -> Standard_Integer

        Returns  the number  of  intervals for  continuity
        <S>. May be one if Continuity(me) >= <S>

        :type S: OCC.wrapper.GeomAbs.GeomAbs_Shape
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepBlend.BRepBlend_SurfRstConstRad_NbIntervals(self, *args)


    def Intervals(self, *args):
        """
        Intervals(BRepBlend_SurfRstConstRad self, NCollection_Array1_Standard_Real T, GeomAbs_Shape const S)

        Stores in <T> the  parameters bounding the intervals
        of continuity <S>.
        The array must provide  enough room to  accomodate
        for the parameters. i.e. T.Length() > NbIntervals()

        :type T: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type S: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _BRepBlend.BRepBlend_SurfRstConstRad_Intervals(self, *args)


    def GetShape(self, *args):
        """
        GetShape(BRepBlend_SurfRstConstRad self)

        :type NbPoles: int
        :type NbKnots: int
        :type Degree: int
        :type NbPoles2d: int

        """
        return _BRepBlend.BRepBlend_SurfRstConstRad_GetShape(self, *args)


    def GetTolerance(self, *args):
        """
        GetTolerance(BRepBlend_SurfRstConstRad self, math_Vector Tolerance, Standard_Real const Tol)
        GetTolerance(BRepBlend_SurfRstConstRad self, Standard_Real const BoundTol, Standard_Real const SurfTol, Standard_Real const AngleTol, math_Vector Tol3d, math_Vector Tol1D)

        Returns the tolerance to reach in approximation
        to respecte
        BoundTol error at the Boundary
        AngleTol tangent error at the Boundary
        SurfTol error inside the surface.

        :type BoundTol: float
        :type SurfTol: float
        :type AngleTol: float
        :type Tol3d: OCC.wrapper.math.math_Vector
        :type Tol1D: OCC.wrapper.math.math_Vector

        """
        return _BRepBlend.BRepBlend_SurfRstConstRad_GetTolerance(self, *args)


    def Knots(self, *args):
        """
        Knots(BRepBlend_SurfRstConstRad self, NCollection_Array1_Standard_Real TKnots)

        :type TKnots: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        return _BRepBlend.BRepBlend_SurfRstConstRad_Knots(self, *args)


    def Mults(self, *args):
        """
        Mults(BRepBlend_SurfRstConstRad self, NCollection_Array1_Standard_Integer TMults)

        :type TMults: OCC.wrapper.TColStd.TColStd_Array1OfInteger

        """
        return _BRepBlend.BRepBlend_SurfRstConstRad_Mults(self, *args)


    def Section(self, *args):
        """
        Section(BRepBlend_SurfRstConstRad self, Standard_Real const Param, Standard_Real const U, Standard_Real const V, Standard_Real const W, gp_Circ C)
        Section(BRepBlend_SurfRstConstRad self, Blend_Point P, NCollection_Array1_gp_Pnt Poles, NCollection_Array1_gp_Vec DPoles, NCollection_Array1_gp_Pnt2d Poles2d, NCollection_Array1_gp_Vec2d DPoles2d, NCollection_Array1_Standard_Real Weigths, NCollection_Array1_Standard_Real DWeigths) -> Standard_Boolean
        Section(BRepBlend_SurfRstConstRad self, Blend_Point P, NCollection_Array1_gp_Pnt Poles, NCollection_Array1_gp_Vec DPoles, NCollection_Array1_gp_Vec D2Poles, NCollection_Array1_gp_Pnt2d Poles2d, NCollection_Array1_gp_Vec2d DPoles2d, NCollection_Array1_gp_Vec2d D2Poles2d, NCollection_Array1_Standard_Real Weigths, NCollection_Array1_Standard_Real DWeigths, NCollection_Array1_Standard_Real D2Weigths) -> Standard_Boolean
        Section(BRepBlend_SurfRstConstRad self, Blend_Point P, NCollection_Array1_gp_Pnt Poles, NCollection_Array1_gp_Pnt2d Poles2d, NCollection_Array1_Standard_Real Weigths)

        :type P: OCC.wrapper.Blend.Blend_Point
        :type Poles: OCC.wrapper.TColgp.TColgp_Array1OfPnt
        :type Poles2d: OCC.wrapper.TColgp.TColgp_Array1OfPnt2d
        :type Weigths: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        return _BRepBlend.BRepBlend_SurfRstConstRad_Section(self, *args)


    def Resolution(self, *args):
        """
        Resolution(BRepBlend_SurfRstConstRad self, Standard_Integer const IC2d, Standard_Real const Tol)

        :type IC2d: int
        :type Tol: float
        :type TolU: float
        :type TolV: float

        """
        return _BRepBlend.BRepBlend_SurfRstConstRad_Resolution(self, *args)

    __swig_destroy__ = _BRepBlend.delete_BRepBlend_SurfRstConstRad
BRepBlend_SurfRstConstRad_swigregister = _BRepBlend.BRepBlend_SurfRstConstRad_swigregister
BRepBlend_SurfRstConstRad_swigregister(BRepBlend_SurfRstConstRad)

class Handle_BRepBlend_AppFunc(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_BRepBlend_AppFunc self)

        Nullify the handle


        """
        return _BRepBlend.Handle_BRepBlend_AppFunc_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_BRepBlend_AppFunc self) -> bool

        Check for being null

        :rtype: bool

        """
        return _BRepBlend.Handle_BRepBlend_AppFunc_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_BRepBlend_AppFunc self, BRepBlend_AppFunc thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _BRepBlend.Handle_BRepBlend_AppFunc_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_BRepBlend_AppFunc self, Handle_BRepBlend_AppFunc theHandle) -> Handle_BRepBlend_AppFunc
        assign(Handle_BRepBlend_AppFunc self, BRepBlend_AppFunc thePtr) -> Handle_BRepBlend_AppFunc
        assign(Handle_BRepBlend_AppFunc self, Handle_BRepBlend_AppFunc theHandle) -> Handle_BRepBlend_AppFunc

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _BRepBlend.Handle_BRepBlend_AppFunc_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_BRepBlend_AppFunc self) -> BRepBlend_AppFunc

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _BRepBlend.Handle_BRepBlend_AppFunc_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_BRepBlend_AppFunc self) -> BRepBlend_AppFunc

        Member access operator (note non-const)

        :rtype: T *

        """
        return _BRepBlend.Handle_BRepBlend_AppFunc___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_BRepBlend_AppFunc self) -> BRepBlend_AppFunc

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _BRepBlend.Handle_BRepBlend_AppFunc___ref__(self, *args)


    def __hash__(self):
        return _BRepBlend.Handle_BRepBlend_AppFunc___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _BRepBlend.Handle_BRepBlend_AppFunc___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _BRepBlend.new_Handle_BRepBlend_AppFunc(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_BRepBlend.Handle_BRepBlend_AppFunc_DownCast)
    __swig_destroy__ = _BRepBlend.delete_Handle_BRepBlend_AppFunc

    def Point(self, *args):
        """
        Point(Handle_BRepBlend_AppFunc self, Blend_AppFunction Func, Standard_Real const Param, math_Vector Sol, Blend_Point Pnt)

        :type Func: OCC.wrapper.Blend.Blend_AppFunction
        :type Param: float
        :type Sol: OCC.wrapper.math.math_Vector
        :type Pnt: OCC.wrapper.Blend.Blend_Point

        """
        return _BRepBlend.Handle_BRepBlend_AppFunc_Point(self, *args)


    def Vec(self, *args):
        """
        Vec(Handle_BRepBlend_AppFunc self, math_Vector Sol, Blend_Point Pnt)

        :type Sol: OCC.wrapper.math.math_Vector
        :type Pnt: OCC.wrapper.Blend.Blend_Point

        """
        return _BRepBlend.Handle_BRepBlend_AppFunc_Vec(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_BRepBlend_AppFunc self) -> char const *

        :rtype: const char *

        """
        return _BRepBlend.Handle_BRepBlend_AppFunc_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _BRepBlend.Handle_BRepBlend_AppFunc_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _BRepBlend.Handle_BRepBlend_AppFunc_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def D0(self, *args):
        """
        D0(Handle_BRepBlend_AppFunc self, Standard_Real const Param, Standard_Real const First, Standard_Real const Last, NCollection_Array1_gp_Pnt Poles, NCollection_Array1_gp_Pnt2d Poles2d, NCollection_Array1_Standard_Real Weigths) -> Standard_Boolean

        compute the section for v = param

        :type Param: float
        :type First: float
        :type Last: float
        :type Poles: OCC.wrapper.TColgp.TColgp_Array1OfPnt
        :type Poles2d: OCC.wrapper.TColgp.TColgp_Array1OfPnt2d
        :type Weigths: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepBlend.Handle_BRepBlend_AppFunc_D0(self, *args)


    def D1(self, *args):
        """
        D1(Handle_BRepBlend_AppFunc self, Standard_Real const Param, Standard_Real const First, Standard_Real const Last, NCollection_Array1_gp_Pnt Poles, NCollection_Array1_gp_Vec DPoles, NCollection_Array1_gp_Pnt2d Poles2d, NCollection_Array1_gp_Vec2d DPoles2d, NCollection_Array1_Standard_Real Weigths, NCollection_Array1_Standard_Real DWeigths) -> Standard_Boolean

        compute the first  derivative in v direction  of the
        section for v =  param

        :type Param: float
        :type First: float
        :type Last: float
        :type Poles: OCC.wrapper.TColgp.TColgp_Array1OfPnt
        :type DPoles: OCC.wrapper.TColgp.TColgp_Array1OfVec
        :type Poles2d: OCC.wrapper.TColgp.TColgp_Array1OfPnt2d
        :type DPoles2d: OCC.wrapper.TColgp.TColgp_Array1OfVec2d
        :type Weigths: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type DWeigths: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepBlend.Handle_BRepBlend_AppFunc_D1(self, *args)


    def D2(self, *args):
        """
        D2(Handle_BRepBlend_AppFunc self, Standard_Real const Param, Standard_Real const First, Standard_Real const Last, NCollection_Array1_gp_Pnt Poles, NCollection_Array1_gp_Vec DPoles, NCollection_Array1_gp_Vec D2Poles, NCollection_Array1_gp_Pnt2d Poles2d, NCollection_Array1_gp_Vec2d DPoles2d, NCollection_Array1_gp_Vec2d D2Poles2d, NCollection_Array1_Standard_Real Weigths, NCollection_Array1_Standard_Real DWeigths, NCollection_Array1_Standard_Real D2Weigths) -> Standard_Boolean

        compute the second derivative  in v direction of the
        section  for v = param

        :type Param: float
        :type First: float
        :type Last: float
        :type Poles: OCC.wrapper.TColgp.TColgp_Array1OfPnt
        :type DPoles: OCC.wrapper.TColgp.TColgp_Array1OfVec
        :type D2Poles: OCC.wrapper.TColgp.TColgp_Array1OfVec
        :type Poles2d: OCC.wrapper.TColgp.TColgp_Array1OfPnt2d
        :type DPoles2d: OCC.wrapper.TColgp.TColgp_Array1OfVec2d
        :type D2Poles2d: OCC.wrapper.TColgp.TColgp_Array1OfVec2d
        :type Weigths: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type DWeigths: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type D2Weigths: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepBlend.Handle_BRepBlend_AppFunc_D2(self, *args)


    def Nb2dCurves(self, *args):
        """
        Nb2dCurves(Handle_BRepBlend_AppFunc self) -> Standard_Integer

        get the number of 2d curves to  approximate.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepBlend.Handle_BRepBlend_AppFunc_Nb2dCurves(self, *args)


    def SectionShape(self, *args):
        """
        SectionShape(Handle_BRepBlend_AppFunc self)

        get the format of an  section

        :type NbPoles: int
        :type NbKnots: int
        :type Degree: int

        """
        return _BRepBlend.Handle_BRepBlend_AppFunc_SectionShape(self, *args)


    def Knots(self, *args):
        """
        Knots(Handle_BRepBlend_AppFunc self, NCollection_Array1_Standard_Real TKnots)

        get the Knots of the section

        :type TKnots: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        return _BRepBlend.Handle_BRepBlend_AppFunc_Knots(self, *args)


    def Mults(self, *args):
        """
        Mults(Handle_BRepBlend_AppFunc self, NCollection_Array1_Standard_Integer TMults)

        get the Multplicities of the section

        :type TMults: OCC.wrapper.TColStd.TColStd_Array1OfInteger

        """
        return _BRepBlend.Handle_BRepBlend_AppFunc_Mults(self, *args)


    def IsRational(self, *args):
        """
        IsRational(Handle_BRepBlend_AppFunc self) -> Standard_Boolean

        Returns if the section is rationnal or not

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepBlend.Handle_BRepBlend_AppFunc_IsRational(self, *args)


    def NbIntervals(self, *args):
        """
        NbIntervals(Handle_BRepBlend_AppFunc self, GeomAbs_Shape const S) -> Standard_Integer

        Returns  the number  of  intervals for  continuity
        <S>. May be one if Continuity(me) >= <S>

        :type S: OCC.wrapper.GeomAbs.GeomAbs_Shape
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepBlend.Handle_BRepBlend_AppFunc_NbIntervals(self, *args)


    def Intervals(self, *args):
        """
        Intervals(Handle_BRepBlend_AppFunc self, NCollection_Array1_Standard_Real T, GeomAbs_Shape const S)

        Stores in <T> the  parameters bounding the intervals
        of continuity <S>.

        The array must provide  enough room to  accomodate
        for the parameters. i.e. T.Length() > NbIntervals()

        :type T: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type S: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _BRepBlend.Handle_BRepBlend_AppFunc_Intervals(self, *args)


    def SetInterval(self, *args):
        """
        SetInterval(Handle_BRepBlend_AppFunc self, Standard_Real const First, Standard_Real const Last)

        Sets the bounds of the parametric interval on
        the fonction
        This determines the derivatives in these values if the
        function is not Cn.

        :type First: float
        :type Last: float

        """
        return _BRepBlend.Handle_BRepBlend_AppFunc_SetInterval(self, *args)


    def Resolution(self, *args):
        """
        Resolution(Handle_BRepBlend_AppFunc self, Standard_Integer const Index, Standard_Real const Tol)

        Returns the resolutions in the  sub-space 2d <Index> --
        This information is usfull to find an good tolerance in
        2d approximation

        :type Index: int
        :type Tol: float
        :type TolU: float
        :type TolV: float

        """
        return _BRepBlend.Handle_BRepBlend_AppFunc_Resolution(self, *args)


    def GetTolerance(self, *args):
        """
        GetTolerance(Handle_BRepBlend_AppFunc self, Standard_Real const BoundTol, Standard_Real const SurfTol, Standard_Real const AngleTol, NCollection_Array1_Standard_Real Tol3d)

        Returns the tolerance to reach in approximation
        to respecte
        BoundTol error at the Boundary
        AngleTol tangent error at the Boundary (in radian)
        SurfTol error inside the surface.

        :type BoundTol: float
        :type SurfTol: float
        :type AngleTol: float
        :type Tol3d: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        return _BRepBlend.Handle_BRepBlend_AppFunc_GetTolerance(self, *args)


    def SetTolerance(self, *args):
        """
        SetTolerance(Handle_BRepBlend_AppFunc self, Standard_Real const Tol3d, Standard_Real const Tol2d)

        Is usfull, if (me) have to  be run numerical
        algorithme to perform D0, D1 or D2

        :type Tol3d: float
        :type Tol2d: float

        """
        return _BRepBlend.Handle_BRepBlend_AppFunc_SetTolerance(self, *args)


    def BarycentreOfSurf(self, *args):
        """
        BarycentreOfSurf(Handle_BRepBlend_AppFunc self) -> gp_Pnt

        Get    the   barycentre of   Surface.   An   very  poor
        estimation is sufficent. This information is usefull
        to perform well conditionned rational approximation.

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _BRepBlend.Handle_BRepBlend_AppFunc_BarycentreOfSurf(self, *args)


    def MaximalSection(self, *args):
        """
        MaximalSection(Handle_BRepBlend_AppFunc self) -> Standard_Real

        Returns the   length of the maximum section. This
        information is usefull to perform well conditionned rational
        approximation.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _BRepBlend.Handle_BRepBlend_AppFunc_MaximalSection(self, *args)


    def GetMinimalWeight(self, *args):
        """
        GetMinimalWeight(Handle_BRepBlend_AppFunc self, NCollection_Array1_Standard_Real Weigths)

        Compute the minimal value of weight for each poles
        of all  sections.  This information is  usefull to
        perform well conditionned rational approximation.

        :type Weigths: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        return _BRepBlend.Handle_BRepBlend_AppFunc_GetMinimalWeight(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_BRepBlend_AppFunc self)

        Memory deallocator for transient classes


        """
        return _BRepBlend.Handle_BRepBlend_AppFunc_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_BRepBlend_AppFunc self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_BRepBlend_AppFunc self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepBlend.Handle_BRepBlend_AppFunc_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_BRepBlend_AppFunc self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_BRepBlend_AppFunc self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepBlend.Handle_BRepBlend_AppFunc_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_BRepBlend_AppFunc self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _BRepBlend.Handle_BRepBlend_AppFunc_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_BRepBlend_AppFunc self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepBlend.Handle_BRepBlend_AppFunc_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_BRepBlend_AppFunc self)

        Increments the reference counter of this object


        """
        return _BRepBlend.Handle_BRepBlend_AppFunc_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_BRepBlend_AppFunc self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepBlend.Handle_BRepBlend_AppFunc_DecrementRefCounter(self, *args)

Handle_BRepBlend_AppFunc_swigregister = _BRepBlend.Handle_BRepBlend_AppFunc_swigregister
Handle_BRepBlend_AppFunc_swigregister(Handle_BRepBlend_AppFunc)

def Handle_BRepBlend_AppFunc_DownCast(thing):
    return _BRepBlend.Handle_BRepBlend_AppFunc_DownCast(thing)
Handle_BRepBlend_AppFunc_DownCast = _BRepBlend.Handle_BRepBlend_AppFunc_DownCast

class BRepBlend_SurfCurvEvolRadInv(Blend.Blend_SurfCurvFuncInv):
    """
    Function of reframing between a surface restriction
    of the surface and a curve.
    Class     used   to   compute  a    solution   of  the
    surfRstConstRad  problem  on a done restriction of the
    surface.
    The vector  <X> used in  Value, Values and Derivatives
    methods  has   to  be the   vector  of  the parametric
    coordinates  wguide, wcurv, wrst  where  wguide is the
    parameter on the guide line, wcurv is the parameter on
    the curve, wrst is the parameter on the restriction on
    the surface.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BRepBlend_SurfCurvEvolRadInv self, Handle_Adaptor3d_HSurface S, Handle_Adaptor3d_HCurve C, Handle_Adaptor3d_HCurve Cg, Handle_Law_Function Evol) -> BRepBlend_SurfCurvEvolRadInv

        :type S: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface
        :type C: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HCurve
        :type Cg: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HCurve
        :type Evol: OCC.wrapper.Law.Handle_Law_Function

        """
        this = _BRepBlend.new_BRepBlend_SurfCurvEvolRadInv(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def NbEquations(self, *args):
        """
        NbEquations(BRepBlend_SurfCurvEvolRadInv self) -> Standard_Integer

        returns 3.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepBlend.BRepBlend_SurfCurvEvolRadInv_NbEquations(self, *args)


    def Value(self, *args):
        """
        Value(BRepBlend_SurfCurvEvolRadInv self, math_Vector X, math_Vector F) -> Standard_Boolean

        computes the values <F> of the Functions for the
        variable <X>.
        Returns True if the computation was done successfully,
        False otherwise.

        :type X: OCC.wrapper.math.math_Vector
        :type F: OCC.wrapper.math.math_Vector
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepBlend.BRepBlend_SurfCurvEvolRadInv_Value(self, *args)


    def Derivatives(self, *args):
        """
        Derivatives(BRepBlend_SurfCurvEvolRadInv self, math_Vector X, math_Matrix D) -> Standard_Boolean

        returns the values <D> of the derivatives for the
        variable <X>.
        Returns True if the computation was done successfully,
        False otherwise.

        :type X: OCC.wrapper.math.math_Vector
        :type D: OCC.wrapper.math.math_Matrix
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepBlend.BRepBlend_SurfCurvEvolRadInv_Derivatives(self, *args)


    def Values(self, *args):
        """
        Values(BRepBlend_SurfCurvEvolRadInv self, math_Vector X, math_Vector F, math_Matrix D) -> Standard_Boolean

        returns the values <F> of the functions and the derivatives
        <D> for the variable <X>.
        Returns True if the computation was done successfully,
        False otherwise.

        :type X: OCC.wrapper.math.math_Vector
        :type F: OCC.wrapper.math.math_Vector
        :type D: OCC.wrapper.math.math_Matrix
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepBlend.BRepBlend_SurfCurvEvolRadInv_Values(self, *args)


    def Set(self, *args):
        """
        Set(BRepBlend_SurfCurvEvolRadInv self, Standard_Integer const Choix)
        Set(BRepBlend_SurfCurvEvolRadInv self, Handle_Adaptor2d_HCurve2d Rst)

        Set the restriction on which a solution has to be found.

        :type Rst: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d

        """
        return _BRepBlend.BRepBlend_SurfCurvEvolRadInv_Set(self, *args)


    def GetTolerance(self, *args):
        """
        GetTolerance(BRepBlend_SurfCurvEvolRadInv self, math_Vector Tolerance, Standard_Real const Tol)

        Returns in the vector Tolerance the parametric tolerance
        for each of the 3 variables;
        Tol is the tolerance used in 3d space.

        :type Tolerance: OCC.wrapper.math.math_Vector
        :type Tol: float

        """
        return _BRepBlend.BRepBlend_SurfCurvEvolRadInv_GetTolerance(self, *args)


    def GetBounds(self, *args):
        """
        GetBounds(BRepBlend_SurfCurvEvolRadInv self, math_Vector InfBound, math_Vector SupBound)

        Returns in the vector InfBound the lowest values allowed
        for each of the 3 variables.
        Returns in the vector SupBound the greatest values allowed
        for each of the 3 variables.

        :type InfBound: OCC.wrapper.math.math_Vector
        :type SupBound: OCC.wrapper.math.math_Vector

        """
        return _BRepBlend.BRepBlend_SurfCurvEvolRadInv_GetBounds(self, *args)


    def IsSolution(self, *args):
        """
        IsSolution(BRepBlend_SurfCurvEvolRadInv self, math_Vector Sol, Standard_Real const Tol) -> Standard_Boolean

        Returns Standard_True if Sol is a zero of the function.
        Tol is the tolerance used in 3d space.

        :type Sol: OCC.wrapper.math.math_Vector
        :type Tol: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepBlend.BRepBlend_SurfCurvEvolRadInv_IsSolution(self, *args)

    __swig_destroy__ = _BRepBlend.delete_BRepBlend_SurfCurvEvolRadInv
BRepBlend_SurfCurvEvolRadInv_swigregister = _BRepBlend.BRepBlend_SurfCurvEvolRadInv_swigregister
BRepBlend_SurfCurvEvolRadInv_swigregister(BRepBlend_SurfCurvEvolRadInv)

class BRepBlend_HCurve2dTool(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def FirstParameter(*args):
        """
        FirstParameter(Handle_Adaptor2d_HCurve2d C) -> Standard_Real

        :type C: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _BRepBlend.BRepBlend_HCurve2dTool_FirstParameter(*args)

    FirstParameter = staticmethod(FirstParameter)

    def LastParameter(*args):
        """
        LastParameter(Handle_Adaptor2d_HCurve2d C) -> Standard_Real

        :type C: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _BRepBlend.BRepBlend_HCurve2dTool_LastParameter(*args)

    LastParameter = staticmethod(LastParameter)

    def Continuity(*args):
        """
        Continuity(Handle_Adaptor2d_HCurve2d C) -> GeomAbs_Shape

        :type C: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d
        :rtype: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _BRepBlend.BRepBlend_HCurve2dTool_Continuity(*args)

    Continuity = staticmethod(Continuity)

    def NbIntervals(*args):
        """
        NbIntervals(Handle_Adaptor2d_HCurve2d C, GeomAbs_Shape const S) -> Standard_Integer

        Returns  the number  of  intervals for  continuity
        <S>. May be one if Continuity(myclass) >= <S>

        :type C: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d
        :type S: OCC.wrapper.GeomAbs.GeomAbs_Shape
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepBlend.BRepBlend_HCurve2dTool_NbIntervals(*args)

    NbIntervals = staticmethod(NbIntervals)

    def Intervals(*args):
        """
        Intervals(Handle_Adaptor2d_HCurve2d C, NCollection_Array1_Standard_Real T, GeomAbs_Shape const S)

        Stores in <T> the  parameters bounding the intervals
        of continuity <S>.

        The array must provide  enough room to  accomodate
        for the parameters. i.e. T.Length() > NbIntervals()

        :type C: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d
        :type T: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type S: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _BRepBlend.BRepBlend_HCurve2dTool_Intervals(*args)

    Intervals = staticmethod(Intervals)

    def IsClosed(*args):
        """
        IsClosed(Handle_Adaptor2d_HCurve2d C) -> Standard_Boolean

        :type C: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepBlend.BRepBlend_HCurve2dTool_IsClosed(*args)

    IsClosed = staticmethod(IsClosed)

    def IsPeriodic(*args):
        """
        IsPeriodic(Handle_Adaptor2d_HCurve2d C) -> Standard_Boolean

        :type C: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepBlend.BRepBlend_HCurve2dTool_IsPeriodic(*args)

    IsPeriodic = staticmethod(IsPeriodic)

    def Period(*args):
        """
        Period(Handle_Adaptor2d_HCurve2d C) -> Standard_Real

        :type C: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _BRepBlend.BRepBlend_HCurve2dTool_Period(*args)

    Period = staticmethod(Period)

    def Value(*args):
        """
        Value(Handle_Adaptor2d_HCurve2d C, Standard_Real const U) -> gp_Pnt2d

        Computes the point of parameter U on the curve.

        :type C: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d
        :type U: float
        :rtype: OCC.wrapper.gp.gp_Pnt2d

        """
        return _BRepBlend.BRepBlend_HCurve2dTool_Value(*args)

    Value = staticmethod(Value)

    def D0(*args):
        """
        D0(Handle_Adaptor2d_HCurve2d C, Standard_Real const U, gp_Pnt2d P)

        Computes the point of parameter U on the curve.

        :type C: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d
        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt2d

        """
        return _BRepBlend.BRepBlend_HCurve2dTool_D0(*args)

    D0 = staticmethod(D0)

    def D1(*args):
        """
        D1(Handle_Adaptor2d_HCurve2d C, Standard_Real const U, gp_Pnt2d P, gp_Vec2d V)

        Computes the point of parameter U on the curve with its
        first derivative.
        Raised if the continuity of the current interval
        is not C1.

        :type C: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d
        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type V: OCC.wrapper.gp.gp_Vec2d

        """
        return _BRepBlend.BRepBlend_HCurve2dTool_D1(*args)

    D1 = staticmethod(D1)

    def D2(*args):
        """
        D2(Handle_Adaptor2d_HCurve2d C, Standard_Real const U, gp_Pnt2d P, gp_Vec2d V1, gp_Vec2d V2)

        Returns the point P of parameter U, the first and second
        derivatives V1 and V2.
        Raised if the continuity of the current interval
        is not C2.

        :type C: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d
        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type V1: OCC.wrapper.gp.gp_Vec2d
        :type V2: OCC.wrapper.gp.gp_Vec2d

        """
        return _BRepBlend.BRepBlend_HCurve2dTool_D2(*args)

    D2 = staticmethod(D2)

    def D3(*args):
        """
        D3(Handle_Adaptor2d_HCurve2d C, Standard_Real const U, gp_Pnt2d P, gp_Vec2d V1, gp_Vec2d V2, gp_Vec2d V3)

        Returns the point P of parameter U, the first, the second
        and the third derivative.
        Raised if the continuity of the current interval
        is not C3.

        :type C: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d
        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type V1: OCC.wrapper.gp.gp_Vec2d
        :type V2: OCC.wrapper.gp.gp_Vec2d
        :type V3: OCC.wrapper.gp.gp_Vec2d

        """
        return _BRepBlend.BRepBlend_HCurve2dTool_D3(*args)

    D3 = staticmethod(D3)

    def DN(*args):
        """
        DN(Handle_Adaptor2d_HCurve2d C, Standard_Real const U, Standard_Integer const N) -> gp_Vec2d

        The returned vector gives the value of the derivative for the
        order of derivation N.
        Raised if the continuity of the current interval
        is not CN.
        Raised if N < 1.

        :type C: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d
        :type U: float
        :type N: int
        :rtype: OCC.wrapper.gp.gp_Vec2d

        """
        return _BRepBlend.BRepBlend_HCurve2dTool_DN(*args)

    DN = staticmethod(DN)

    def Resolution(*args):
        """
        Resolution(Handle_Adaptor2d_HCurve2d C, Standard_Real const R3d) -> Standard_Real

        Returns the parametric  resolution corresponding
        to the real space resolution <R3d>.

        :type C: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d
        :type R3d: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _BRepBlend.BRepBlend_HCurve2dTool_Resolution(*args)

    Resolution = staticmethod(Resolution)

    def GetType(*args):
        """
        GetType(Handle_Adaptor2d_HCurve2d C) -> GeomAbs_CurveType

        Returns  the  type of the   curve  in the  current
        interval :   Line,   Circle,   Ellipse, Hyperbola,
        Parabola, BezierCurve, BSplineCurve, OtherCurve.

        :type C: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d
        :rtype: OCC.wrapper.GeomAbs.GeomAbs_CurveType

        """
        return _BRepBlend.BRepBlend_HCurve2dTool_GetType(*args)

    GetType = staticmethod(GetType)

    def Line(*args):
        """
        Line(Handle_Adaptor2d_HCurve2d C) -> gp_Lin2d

        :type C: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d
        :rtype: OCC.wrapper.gp.gp_Lin2d

        """
        return _BRepBlend.BRepBlend_HCurve2dTool_Line(*args)

    Line = staticmethod(Line)

    def Circle(*args):
        """
        Circle(Handle_Adaptor2d_HCurve2d C) -> gp_Circ2d

        :type C: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d
        :rtype: OCC.wrapper.gp.gp_Circ2d

        """
        return _BRepBlend.BRepBlend_HCurve2dTool_Circle(*args)

    Circle = staticmethod(Circle)

    def Ellipse(*args):
        """
        Ellipse(Handle_Adaptor2d_HCurve2d C) -> gp_Elips2d

        :type C: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d
        :rtype: OCC.wrapper.gp.gp_Elips2d

        """
        return _BRepBlend.BRepBlend_HCurve2dTool_Ellipse(*args)

    Ellipse = staticmethod(Ellipse)

    def Hyperbola(*args):
        """
        Hyperbola(Handle_Adaptor2d_HCurve2d C) -> gp_Hypr2d

        :type C: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d
        :rtype: OCC.wrapper.gp.gp_Hypr2d

        """
        return _BRepBlend.BRepBlend_HCurve2dTool_Hyperbola(*args)

    Hyperbola = staticmethod(Hyperbola)

    def Parabola(*args):
        """
        Parabola(Handle_Adaptor2d_HCurve2d C) -> gp_Parab2d

        :type C: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d
        :rtype: OCC.wrapper.gp.gp_Parab2d

        """
        return _BRepBlend.BRepBlend_HCurve2dTool_Parabola(*args)

    Parabola = staticmethod(Parabola)

    def Bezier(*args):
        """
        Bezier(Handle_Adaptor2d_HCurve2d C) -> Handle_Geom2d_BezierCurve

        :type C: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d
        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_BezierCurve

        """
        return _BRepBlend.BRepBlend_HCurve2dTool_Bezier(*args)

    Bezier = staticmethod(Bezier)

    def BSpline(*args):
        """
        BSpline(Handle_Adaptor2d_HCurve2d C) -> Handle_Geom2d_BSplineCurve

        :type C: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d
        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_BSplineCurve

        """
        return _BRepBlend.BRepBlend_HCurve2dTool_BSpline(*args)

    BSpline = staticmethod(BSpline)

    def NbSamples(*args):
        """
        NbSamples(Handle_Adaptor2d_HCurve2d C, Standard_Real const U0, Standard_Real const U1) -> Standard_Integer

        :type C: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d
        :type U0: float
        :type U1: float
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepBlend.BRepBlend_HCurve2dTool_NbSamples(*args)

    NbSamples = staticmethod(NbSamples)

    def __init__(self):
        this = _BRepBlend.new_BRepBlend_HCurve2dTool()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _BRepBlend.delete_BRepBlend_HCurve2dTool
BRepBlend_HCurve2dTool_swigregister = _BRepBlend.BRepBlend_HCurve2dTool_swigregister
BRepBlend_HCurve2dTool_swigregister(BRepBlend_HCurve2dTool)

def BRepBlend_HCurve2dTool_FirstParameter(*args):
    """
    BRepBlend_HCurve2dTool_FirstParameter(Handle_Adaptor2d_HCurve2d C) -> Standard_Real

    :type C: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d
    :rtype: OCC.wrapper.Standard.Standard_Real

    """
    return _BRepBlend.BRepBlend_HCurve2dTool_FirstParameter(*args)

def BRepBlend_HCurve2dTool_LastParameter(*args):
    """
    BRepBlend_HCurve2dTool_LastParameter(Handle_Adaptor2d_HCurve2d C) -> Standard_Real

    :type C: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d
    :rtype: OCC.wrapper.Standard.Standard_Real

    """
    return _BRepBlend.BRepBlend_HCurve2dTool_LastParameter(*args)

def BRepBlend_HCurve2dTool_Continuity(*args):
    """
    BRepBlend_HCurve2dTool_Continuity(Handle_Adaptor2d_HCurve2d C) -> GeomAbs_Shape

    :type C: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d
    :rtype: OCC.wrapper.GeomAbs.GeomAbs_Shape

    """
    return _BRepBlend.BRepBlend_HCurve2dTool_Continuity(*args)

def BRepBlend_HCurve2dTool_NbIntervals(*args):
    """
    BRepBlend_HCurve2dTool_NbIntervals(Handle_Adaptor2d_HCurve2d C, GeomAbs_Shape const S) -> Standard_Integer

    Returns  the number  of  intervals for  continuity
    <S>. May be one if Continuity(myclass) >= <S>

    :type C: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d
    :type S: OCC.wrapper.GeomAbs.GeomAbs_Shape
    :rtype: OCC.wrapper.Standard.Standard_Integer

    """
    return _BRepBlend.BRepBlend_HCurve2dTool_NbIntervals(*args)

def BRepBlend_HCurve2dTool_Intervals(*args):
    """
    BRepBlend_HCurve2dTool_Intervals(Handle_Adaptor2d_HCurve2d C, NCollection_Array1_Standard_Real T, GeomAbs_Shape const S)

    Stores in <T> the  parameters bounding the intervals
    of continuity <S>.

    The array must provide  enough room to  accomodate
    for the parameters. i.e. T.Length() > NbIntervals()

    :type C: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d
    :type T: OCC.wrapper.TColStd.TColStd_Array1OfReal
    :type S: OCC.wrapper.GeomAbs.GeomAbs_Shape

    """
    return _BRepBlend.BRepBlend_HCurve2dTool_Intervals(*args)

def BRepBlend_HCurve2dTool_IsClosed(*args):
    """
    BRepBlend_HCurve2dTool_IsClosed(Handle_Adaptor2d_HCurve2d C) -> Standard_Boolean

    :type C: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _BRepBlend.BRepBlend_HCurve2dTool_IsClosed(*args)

def BRepBlend_HCurve2dTool_IsPeriodic(*args):
    """
    BRepBlend_HCurve2dTool_IsPeriodic(Handle_Adaptor2d_HCurve2d C) -> Standard_Boolean

    :type C: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _BRepBlend.BRepBlend_HCurve2dTool_IsPeriodic(*args)

def BRepBlend_HCurve2dTool_Period(*args):
    """
    BRepBlend_HCurve2dTool_Period(Handle_Adaptor2d_HCurve2d C) -> Standard_Real

    :type C: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d
    :rtype: OCC.wrapper.Standard.Standard_Real

    """
    return _BRepBlend.BRepBlend_HCurve2dTool_Period(*args)

def BRepBlend_HCurve2dTool_Value(*args):
    """
    BRepBlend_HCurve2dTool_Value(Handle_Adaptor2d_HCurve2d C, Standard_Real const U) -> gp_Pnt2d

    Computes the point of parameter U on the curve.

    :type C: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d
    :type U: float
    :rtype: OCC.wrapper.gp.gp_Pnt2d

    """
    return _BRepBlend.BRepBlend_HCurve2dTool_Value(*args)

def BRepBlend_HCurve2dTool_D0(*args):
    """
    BRepBlend_HCurve2dTool_D0(Handle_Adaptor2d_HCurve2d C, Standard_Real const U, gp_Pnt2d P)

    Computes the point of parameter U on the curve.

    :type C: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d
    :type U: float
    :type P: OCC.wrapper.gp.gp_Pnt2d

    """
    return _BRepBlend.BRepBlend_HCurve2dTool_D0(*args)

def BRepBlend_HCurve2dTool_D1(*args):
    """
    BRepBlend_HCurve2dTool_D1(Handle_Adaptor2d_HCurve2d C, Standard_Real const U, gp_Pnt2d P, gp_Vec2d V)

    Computes the point of parameter U on the curve with its
    first derivative.
    Raised if the continuity of the current interval
    is not C1.

    :type C: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d
    :type U: float
    :type P: OCC.wrapper.gp.gp_Pnt2d
    :type V: OCC.wrapper.gp.gp_Vec2d

    """
    return _BRepBlend.BRepBlend_HCurve2dTool_D1(*args)

def BRepBlend_HCurve2dTool_D2(*args):
    """
    BRepBlend_HCurve2dTool_D2(Handle_Adaptor2d_HCurve2d C, Standard_Real const U, gp_Pnt2d P, gp_Vec2d V1, gp_Vec2d V2)

    Returns the point P of parameter U, the first and second
    derivatives V1 and V2.
    Raised if the continuity of the current interval
    is not C2.

    :type C: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d
    :type U: float
    :type P: OCC.wrapper.gp.gp_Pnt2d
    :type V1: OCC.wrapper.gp.gp_Vec2d
    :type V2: OCC.wrapper.gp.gp_Vec2d

    """
    return _BRepBlend.BRepBlend_HCurve2dTool_D2(*args)

def BRepBlend_HCurve2dTool_D3(*args):
    """
    BRepBlend_HCurve2dTool_D3(Handle_Adaptor2d_HCurve2d C, Standard_Real const U, gp_Pnt2d P, gp_Vec2d V1, gp_Vec2d V2, gp_Vec2d V3)

    Returns the point P of parameter U, the first, the second
    and the third derivative.
    Raised if the continuity of the current interval
    is not C3.

    :type C: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d
    :type U: float
    :type P: OCC.wrapper.gp.gp_Pnt2d
    :type V1: OCC.wrapper.gp.gp_Vec2d
    :type V2: OCC.wrapper.gp.gp_Vec2d
    :type V3: OCC.wrapper.gp.gp_Vec2d

    """
    return _BRepBlend.BRepBlend_HCurve2dTool_D3(*args)

def BRepBlend_HCurve2dTool_DN(*args):
    """
    BRepBlend_HCurve2dTool_DN(Handle_Adaptor2d_HCurve2d C, Standard_Real const U, Standard_Integer const N) -> gp_Vec2d

    The returned vector gives the value of the derivative for the
    order of derivation N.
    Raised if the continuity of the current interval
    is not CN.
    Raised if N < 1.

    :type C: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d
    :type U: float
    :type N: int
    :rtype: OCC.wrapper.gp.gp_Vec2d

    """
    return _BRepBlend.BRepBlend_HCurve2dTool_DN(*args)

def BRepBlend_HCurve2dTool_Resolution(*args):
    """
    BRepBlend_HCurve2dTool_Resolution(Handle_Adaptor2d_HCurve2d C, Standard_Real const R3d) -> Standard_Real

    Returns the parametric  resolution corresponding
    to the real space resolution <R3d>.

    :type C: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d
    :type R3d: float
    :rtype: OCC.wrapper.Standard.Standard_Real

    """
    return _BRepBlend.BRepBlend_HCurve2dTool_Resolution(*args)

def BRepBlend_HCurve2dTool_GetType(*args):
    """
    BRepBlend_HCurve2dTool_GetType(Handle_Adaptor2d_HCurve2d C) -> GeomAbs_CurveType

    Returns  the  type of the   curve  in the  current
    interval :   Line,   Circle,   Ellipse, Hyperbola,
    Parabola, BezierCurve, BSplineCurve, OtherCurve.

    :type C: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d
    :rtype: OCC.wrapper.GeomAbs.GeomAbs_CurveType

    """
    return _BRepBlend.BRepBlend_HCurve2dTool_GetType(*args)

def BRepBlend_HCurve2dTool_Line(*args):
    """
    BRepBlend_HCurve2dTool_Line(Handle_Adaptor2d_HCurve2d C) -> gp_Lin2d

    :type C: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d
    :rtype: OCC.wrapper.gp.gp_Lin2d

    """
    return _BRepBlend.BRepBlend_HCurve2dTool_Line(*args)

def BRepBlend_HCurve2dTool_Circle(*args):
    """
    BRepBlend_HCurve2dTool_Circle(Handle_Adaptor2d_HCurve2d C) -> gp_Circ2d

    :type C: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d
    :rtype: OCC.wrapper.gp.gp_Circ2d

    """
    return _BRepBlend.BRepBlend_HCurve2dTool_Circle(*args)

def BRepBlend_HCurve2dTool_Ellipse(*args):
    """
    BRepBlend_HCurve2dTool_Ellipse(Handle_Adaptor2d_HCurve2d C) -> gp_Elips2d

    :type C: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d
    :rtype: OCC.wrapper.gp.gp_Elips2d

    """
    return _BRepBlend.BRepBlend_HCurve2dTool_Ellipse(*args)

def BRepBlend_HCurve2dTool_Hyperbola(*args):
    """
    BRepBlend_HCurve2dTool_Hyperbola(Handle_Adaptor2d_HCurve2d C) -> gp_Hypr2d

    :type C: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d
    :rtype: OCC.wrapper.gp.gp_Hypr2d

    """
    return _BRepBlend.BRepBlend_HCurve2dTool_Hyperbola(*args)

def BRepBlend_HCurve2dTool_Parabola(*args):
    """
    BRepBlend_HCurve2dTool_Parabola(Handle_Adaptor2d_HCurve2d C) -> gp_Parab2d

    :type C: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d
    :rtype: OCC.wrapper.gp.gp_Parab2d

    """
    return _BRepBlend.BRepBlend_HCurve2dTool_Parabola(*args)

def BRepBlend_HCurve2dTool_Bezier(*args):
    """
    BRepBlend_HCurve2dTool_Bezier(Handle_Adaptor2d_HCurve2d C) -> Handle_Geom2d_BezierCurve

    :type C: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d
    :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_BezierCurve

    """
    return _BRepBlend.BRepBlend_HCurve2dTool_Bezier(*args)

def BRepBlend_HCurve2dTool_BSpline(*args):
    """
    BRepBlend_HCurve2dTool_BSpline(Handle_Adaptor2d_HCurve2d C) -> Handle_Geom2d_BSplineCurve

    :type C: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d
    :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_BSplineCurve

    """
    return _BRepBlend.BRepBlend_HCurve2dTool_BSpline(*args)

def BRepBlend_HCurve2dTool_NbSamples(*args):
    """
    BRepBlend_HCurve2dTool_NbSamples(Handle_Adaptor2d_HCurve2d C, Standard_Real const U0, Standard_Real const U1) -> Standard_Integer

    :type C: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d
    :type U0: float
    :type U1: float
    :rtype: OCC.wrapper.Standard.Standard_Integer

    """
    return _BRepBlend.BRepBlend_HCurve2dTool_NbSamples(*args)

class BRepBlend_RstRstConstRad(Blend.Blend_RstRstFunction):
    """
    Copy of CSConstRad with a pcurve on surface
    as support.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BRepBlend_RstRstConstRad self, Handle_Adaptor3d_HSurface Surf1, Handle_Adaptor2d_HCurve2d Rst1, Handle_Adaptor3d_HSurface Surf2, Handle_Adaptor2d_HCurve2d Rst2, Handle_Adaptor3d_HCurve CGuide) -> BRepBlend_RstRstConstRad

        :type Surf1: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface
        :type Rst1: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d
        :type Surf2: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface
        :type Rst2: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d
        :type CGuide: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HCurve

        """
        this = _BRepBlend.new_BRepBlend_RstRstConstRad(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def NbVariables(self, *args):
        """
        NbVariables(BRepBlend_RstRstConstRad self) -> Standard_Integer

        Returns 2.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepBlend.BRepBlend_RstRstConstRad_NbVariables(self, *args)


    def NbEquations(self, *args):
        """
        NbEquations(BRepBlend_RstRstConstRad self) -> Standard_Integer

        Returns 2.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepBlend.BRepBlend_RstRstConstRad_NbEquations(self, *args)


    def Value(self, *args):
        """
        Value(BRepBlend_RstRstConstRad self, math_Vector X, math_Vector F) -> Standard_Boolean

        computes the values <F> of the Functions for the
        variable <X>.
        Returns True if the computation was done successfully,
        False otherwise.

        :type X: OCC.wrapper.math.math_Vector
        :type F: OCC.wrapper.math.math_Vector
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepBlend.BRepBlend_RstRstConstRad_Value(self, *args)


    def Derivatives(self, *args):
        """
        Derivatives(BRepBlend_RstRstConstRad self, math_Vector X, math_Matrix D) -> Standard_Boolean

        returns the values <D> of the derivatives for the
        variable <X>.
        Returns True if the computation was done successfully,
        False otherwise.

        :type X: OCC.wrapper.math.math_Vector
        :type D: OCC.wrapper.math.math_Matrix
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepBlend.BRepBlend_RstRstConstRad_Derivatives(self, *args)


    def Values(self, *args):
        """
        Values(BRepBlend_RstRstConstRad self, math_Vector X, math_Vector F, math_Matrix D) -> Standard_Boolean

        returns the values <F> of the functions and the derivatives
        <D> for the variable <X>.
        Returns True if the computation was done successfully,
        False otherwise.

        :type X: OCC.wrapper.math.math_Vector
        :type F: OCC.wrapper.math.math_Vector
        :type D: OCC.wrapper.math.math_Matrix
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepBlend.BRepBlend_RstRstConstRad_Values(self, *args)


    def GetBounds(self, *args):
        """
        GetBounds(BRepBlend_RstRstConstRad self, math_Vector InfBound, math_Vector SupBound)

        :type InfBound: OCC.wrapper.math.math_Vector
        :type SupBound: OCC.wrapper.math.math_Vector

        """
        return _BRepBlend.BRepBlend_RstRstConstRad_GetBounds(self, *args)


    def IsSolution(self, *args):
        """
        IsSolution(BRepBlend_RstRstConstRad self, math_Vector Sol, Standard_Real const Tol) -> Standard_Boolean

        :type Sol: OCC.wrapper.math.math_Vector
        :type Tol: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepBlend.BRepBlend_RstRstConstRad_IsSolution(self, *args)


    def GetMinimalDistance(self, *args):
        """
        GetMinimalDistance(BRepBlend_RstRstConstRad self) -> Standard_Real

        Returns   the    minimal  Distance  beetween   two
        extremitys of calculed sections.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _BRepBlend.BRepBlend_RstRstConstRad_GetMinimalDistance(self, *args)


    def PointOnRst1(self, *args):
        """
        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        res = _BRepBlend.BRepBlend_RstRstConstRad_PointOnRst1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def PointOnRst2(self, *args):
        """
        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        res = _BRepBlend.BRepBlend_RstRstConstRad_PointOnRst2(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Pnt2dOnRst1(self, *args):
        """
        Returns U,V coordinates of the point on the surface.

        :rtype: OCC.wrapper.gp.gp_Pnt2d

        """
        res = _BRepBlend.BRepBlend_RstRstConstRad_Pnt2dOnRst1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Pnt2dOnRst2(self, *args):
        """
        Returns  U,V coordinates of the point  on the curve on
        surface.

        :rtype: OCC.wrapper.gp.gp_Pnt2d

        """
        res = _BRepBlend.BRepBlend_RstRstConstRad_Pnt2dOnRst2(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ParameterOnRst1(self, *args):
        """
        ParameterOnRst1(BRepBlend_RstRstConstRad self) -> Standard_Real

        Returns parameter of the point on the curve.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _BRepBlend.BRepBlend_RstRstConstRad_ParameterOnRst1(self, *args)


    def ParameterOnRst2(self, *args):
        """
        ParameterOnRst2(BRepBlend_RstRstConstRad self) -> Standard_Real

        Returns parameter of the point on the curve.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _BRepBlend.BRepBlend_RstRstConstRad_ParameterOnRst2(self, *args)


    def IsTangencyPoint(self, *args):
        """
        IsTangencyPoint(BRepBlend_RstRstConstRad self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepBlend.BRepBlend_RstRstConstRad_IsTangencyPoint(self, *args)


    def TangentOnRst1(self, *args):
        """
        :rtype: OCC.wrapper.gp.gp_Vec

        """
        res = _BRepBlend.BRepBlend_RstRstConstRad_TangentOnRst1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Tangent2dOnRst1(self, *args):
        """
        :rtype: OCC.wrapper.gp.gp_Vec2d

        """
        res = _BRepBlend.BRepBlend_RstRstConstRad_Tangent2dOnRst1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def TangentOnRst2(self, *args):
        """
        :rtype: OCC.wrapper.gp.gp_Vec

        """
        res = _BRepBlend.BRepBlend_RstRstConstRad_TangentOnRst2(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Tangent2dOnRst2(self, *args):
        """
        :rtype: OCC.wrapper.gp.gp_Vec2d

        """
        res = _BRepBlend.BRepBlend_RstRstConstRad_Tangent2dOnRst2(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Decroch(self, *args):
        """
        Decroch(BRepBlend_RstRstConstRad self, math_Vector Sol, gp_Vec NRst1, gp_Vec TgRst1, gp_Vec NRst2, gp_Vec TgRst2) -> Blend_DecrochStatus

        Permet  d ' implementer   un   critere  de  decrochage
        specifique a la fonction.

        :type Sol: OCC.wrapper.math.math_Vector
        :type NRst1: OCC.wrapper.gp.gp_Vec
        :type TgRst1: OCC.wrapper.gp.gp_Vec
        :type NRst2: OCC.wrapper.gp.gp_Vec
        :type TgRst2: OCC.wrapper.gp.gp_Vec
        :rtype: OCC.wrapper.Blend.Blend_DecrochStatus

        """
        return _BRepBlend.BRepBlend_RstRstConstRad_Decroch(self, *args)


    def Set(self, *args):
        """
        Set(BRepBlend_RstRstConstRad self, Handle_Adaptor3d_HSurface SurfRef1, Handle_Adaptor2d_HCurve2d RstRef1, Handle_Adaptor3d_HSurface SurfRef2, Handle_Adaptor2d_HCurve2d RstRef2)
        Set(BRepBlend_RstRstConstRad self, Standard_Real const Param)
        Set(BRepBlend_RstRstConstRad self, Standard_Real const First, Standard_Real const Last)
        Set(BRepBlend_RstRstConstRad self, Standard_Real const Radius, Standard_Integer const Choix)
        Set(BRepBlend_RstRstConstRad self, BlendFunc_SectionShape const TypeSection)

        Sets  the  type  of   section generation   for the
        approximations.

        :type TypeSection: OCC.wrapper.BlendFunc.BlendFunc_SectionShape

        """
        return _BRepBlend.BRepBlend_RstRstConstRad_Set(self, *args)


    def CenterCircleRst1Rst2(self, *args):
        """
        CenterCircleRst1Rst2(BRepBlend_RstRstConstRad self, gp_Pnt PtRst1, gp_Pnt PtRst2, gp_Vec np, gp_Pnt Center, gp_Vec VdMed) -> Standard_Boolean

        Give the center of circle define by PtRst1, PtRst2 and
        radius ray.

        :type PtRst1: OCC.wrapper.gp.gp_Pnt
        :type PtRst2: OCC.wrapper.gp.gp_Pnt
        :type np: OCC.wrapper.gp.gp_Vec
        :type Center: OCC.wrapper.gp.gp_Pnt
        :type VdMed: OCC.wrapper.gp.gp_Vec
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepBlend.BRepBlend_RstRstConstRad_CenterCircleRst1Rst2(self, *args)


    def IsRational(self, *args):
        """
        IsRational(BRepBlend_RstRstConstRad self) -> Standard_Boolean

        Returns  if the section is rationnal

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepBlend.BRepBlend_RstRstConstRad_IsRational(self, *args)


    def GetSectionSize(self, *args):
        """
        GetSectionSize(BRepBlend_RstRstConstRad self) -> Standard_Real

        Returns the length of the maximum section

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _BRepBlend.BRepBlend_RstRstConstRad_GetSectionSize(self, *args)


    def GetMinimalWeight(self, *args):
        """
        GetMinimalWeight(BRepBlend_RstRstConstRad self, NCollection_Array1_Standard_Real Weigths)

        Compute the minimal value of weight for each poles
        of all sections.

        :type Weigths: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        return _BRepBlend.BRepBlend_RstRstConstRad_GetMinimalWeight(self, *args)


    def NbIntervals(self, *args):
        """
        NbIntervals(BRepBlend_RstRstConstRad self, GeomAbs_Shape const S) -> Standard_Integer

        Returns  the number  of  intervals for  continuity
        <S>. May be one if Continuity(me) >= <S>

        :type S: OCC.wrapper.GeomAbs.GeomAbs_Shape
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepBlend.BRepBlend_RstRstConstRad_NbIntervals(self, *args)


    def Intervals(self, *args):
        """
        Intervals(BRepBlend_RstRstConstRad self, NCollection_Array1_Standard_Real T, GeomAbs_Shape const S)

        Stores in <T> the  parameters bounding the intervals
        of continuity <S>.
        The array must provide  enough room to  accomodate
        for the parameters. i.e. T.Length() > NbIntervals()

        :type T: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type S: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _BRepBlend.BRepBlend_RstRstConstRad_Intervals(self, *args)


    def GetShape(self, *args):
        """
        GetShape(BRepBlend_RstRstConstRad self)

        :type NbPoles: int
        :type NbKnots: int
        :type Degree: int
        :type NbPoles2d: int

        """
        return _BRepBlend.BRepBlend_RstRstConstRad_GetShape(self, *args)


    def GetTolerance(self, *args):
        """
        GetTolerance(BRepBlend_RstRstConstRad self, math_Vector Tolerance, Standard_Real const Tol)
        GetTolerance(BRepBlend_RstRstConstRad self, Standard_Real const BoundTol, Standard_Real const SurfTol, Standard_Real const AngleTol, math_Vector Tol3d, math_Vector Tol1D)

        Returns the tolerance to reach in approximation
        to respecte
        BoundTol error at the Boundary
        AngleTol tangent error at the Boundary
        SurfTol error inside the surface.

        :type BoundTol: float
        :type SurfTol: float
        :type AngleTol: float
        :type Tol3d: OCC.wrapper.math.math_Vector
        :type Tol1D: OCC.wrapper.math.math_Vector

        """
        return _BRepBlend.BRepBlend_RstRstConstRad_GetTolerance(self, *args)


    def Knots(self, *args):
        """
        Knots(BRepBlend_RstRstConstRad self, NCollection_Array1_Standard_Real TKnots)

        :type TKnots: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        return _BRepBlend.BRepBlend_RstRstConstRad_Knots(self, *args)


    def Mults(self, *args):
        """
        Mults(BRepBlend_RstRstConstRad self, NCollection_Array1_Standard_Integer TMults)

        :type TMults: OCC.wrapper.TColStd.TColStd_Array1OfInteger

        """
        return _BRepBlend.BRepBlend_RstRstConstRad_Mults(self, *args)


    def Section(self, *args):
        """
        Section(BRepBlend_RstRstConstRad self, Standard_Real const Param, Standard_Real const U, Standard_Real const V, gp_Circ C)
        Section(BRepBlend_RstRstConstRad self, Blend_Point P, NCollection_Array1_gp_Pnt Poles, NCollection_Array1_gp_Vec DPoles, NCollection_Array1_gp_Pnt2d Poles2d, NCollection_Array1_gp_Vec2d DPoles2d, NCollection_Array1_Standard_Real Weigths, NCollection_Array1_Standard_Real DWeigths) -> Standard_Boolean
        Section(BRepBlend_RstRstConstRad self, Blend_Point P, NCollection_Array1_gp_Pnt Poles, NCollection_Array1_gp_Pnt2d Poles2d, NCollection_Array1_Standard_Real Weigths)
        Section(BRepBlend_RstRstConstRad self, Blend_Point P, NCollection_Array1_gp_Pnt Poles, NCollection_Array1_gp_Vec DPoles, NCollection_Array1_gp_Vec D2Poles, NCollection_Array1_gp_Pnt2d Poles2d, NCollection_Array1_gp_Vec2d DPoles2d, NCollection_Array1_gp_Vec2d D2Poles2d, NCollection_Array1_Standard_Real Weigths, NCollection_Array1_Standard_Real DWeigths, NCollection_Array1_Standard_Real D2Weigths) -> Standard_Boolean

        Used for the first and last section
        The method returns Standard_True if the derivatives
        are computed, otherwise it returns Standard_False.

        :type P: OCC.wrapper.Blend.Blend_Point
        :type Poles: OCC.wrapper.TColgp.TColgp_Array1OfPnt
        :type DPoles: OCC.wrapper.TColgp.TColgp_Array1OfVec
        :type D2Poles: OCC.wrapper.TColgp.TColgp_Array1OfVec
        :type Poles2d: OCC.wrapper.TColgp.TColgp_Array1OfPnt2d
        :type DPoles2d: OCC.wrapper.TColgp.TColgp_Array1OfVec2d
        :type D2Poles2d: OCC.wrapper.TColgp.TColgp_Array1OfVec2d
        :type Weigths: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type DWeigths: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type D2Weigths: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepBlend.BRepBlend_RstRstConstRad_Section(self, *args)


    def Resolution(self, *args):
        """
        Resolution(BRepBlend_RstRstConstRad self, Standard_Integer const IC2d, Standard_Real const Tol)

        :type IC2d: int
        :type Tol: float
        :type TolU: float
        :type TolV: float

        """
        return _BRepBlend.BRepBlend_RstRstConstRad_Resolution(self, *args)

    __swig_destroy__ = _BRepBlend.delete_BRepBlend_RstRstConstRad
BRepBlend_RstRstConstRad_swigregister = _BRepBlend.BRepBlend_RstRstConstRad_swigregister
BRepBlend_RstRstConstRad_swigregister(BRepBlend_RstRstConstRad)

class BRepBlend_PointOnRst(object):
    """
    Definition of an intersection point between a line
    and a restriction on a surface.
    Such a point is contains geometrical informations (see
    the Value method) and logical informations.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BRepBlend_PointOnRst self) -> BRepBlend_PointOnRst
        __init__(BRepBlend_PointOnRst self, Handle_Adaptor2d_HCurve2d A, Standard_Real const Param, IntSurf_Transition TLine, IntSurf_Transition TArc) -> BRepBlend_PointOnRst

        Creates the PointOnRst on the arc A, at parameter Param,
        with the transition TLine on the walking line, and
        TArc on the arc A.

        :type A: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d
        :type Param: float
        :type TLine: OCC.wrapper.IntSurf.IntSurf_Transition
        :type TArc: OCC.wrapper.IntSurf.IntSurf_Transition

        """
        this = _BRepBlend.new_BRepBlend_PointOnRst(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def SetArc(self, *args):
        """
        SetArc(BRepBlend_PointOnRst self, Handle_Adaptor2d_HCurve2d A, Standard_Real const Param, IntSurf_Transition TLine, IntSurf_Transition TArc)

        Sets the values of a point which is on the arc
        A, at parameter Param.

        :type A: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d
        :type Param: float
        :type TLine: OCC.wrapper.IntSurf.IntSurf_Transition
        :type TArc: OCC.wrapper.IntSurf.IntSurf_Transition

        """
        return _BRepBlend.BRepBlend_PointOnRst_SetArc(self, *args)


    def Arc(self, *args):
        """
        Returns the arc of restriction containing the
        vertex.

        :rtype: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d

        """
        res = _BRepBlend.BRepBlend_PointOnRst_Arc(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def TransitionOnLine(self, *args):
        """
        Returns the transition of the point on the
        line on surface.

        :rtype: OCC.wrapper.IntSurf.IntSurf_Transition

        """
        res = _BRepBlend.BRepBlend_PointOnRst_TransitionOnLine(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def TransitionOnArc(self, *args):
        """
        Returns the transition of the point on the arc
        returned by Arc().

        :rtype: OCC.wrapper.IntSurf.IntSurf_Transition

        """
        res = _BRepBlend.BRepBlend_PointOnRst_TransitionOnArc(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ParameterOnArc(self, *args):
        """
        ParameterOnArc(BRepBlend_PointOnRst self) -> Standard_Real

        Returns the parameter of the point on the
        arc returned by the method Arc().

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _BRepBlend.BRepBlend_PointOnRst_ParameterOnArc(self, *args)

    __swig_destroy__ = _BRepBlend.delete_BRepBlend_PointOnRst
BRepBlend_PointOnRst_swigregister = _BRepBlend.BRepBlend_PointOnRst_swigregister
BRepBlend_PointOnRst_swigregister(BRepBlend_PointOnRst)

class BRepBlend_AppFuncRstRst(BRepBlend_AppFuncRoot):
    """Function to approximate by AppSurface for Edge/Face (Curve/Curve contact)."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_BRepBlend_AppFuncRstRst
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_BRepBlend_AppFuncRstRst(self) 
            return h


    def __init__(self, *args):
        """
        __init__(BRepBlend_AppFuncRstRst self, Handle_BRepBlend_Line Line, Blend_RstRstFunction Func, Standard_Real const Tol3d, Standard_Real const Tol2d) -> BRepBlend_AppFuncRstRst

        :type Line: OCC.wrapper.BRepBlend.Handle_BRepBlend_Line
        :type Func: OCC.wrapper.Blend.Blend_RstRstFunction
        :type Tol3d: float
        :type Tol2d: float

        """
        this = _BRepBlend.new_BRepBlend_AppFuncRstRst(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Point(self, *args):
        """
        Point(BRepBlend_AppFuncRstRst self, Blend_AppFunction Func, Standard_Real const Param, math_Vector Sol, Blend_Point Pnt)

        :type Func: OCC.wrapper.Blend.Blend_AppFunction
        :type Param: float
        :type Sol: OCC.wrapper.math.math_Vector
        :type Pnt: OCC.wrapper.Blend.Blend_Point

        """
        return _BRepBlend.BRepBlend_AppFuncRstRst_Point(self, *args)


    def Vec(self, *args):
        """
        Vec(BRepBlend_AppFuncRstRst self, math_Vector Sol, Blend_Point Pnt)

        :type Sol: OCC.wrapper.math.math_Vector
        :type Pnt: OCC.wrapper.Blend.Blend_Point

        """
        return _BRepBlend.BRepBlend_AppFuncRstRst_Vec(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _BRepBlend.BRepBlend_AppFuncRstRst_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _BRepBlend.BRepBlend_AppFuncRstRst_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _BRepBlend.BRepBlend_AppFuncRstRst_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _BRepBlend.delete_BRepBlend_AppFuncRstRst
BRepBlend_AppFuncRstRst_swigregister = _BRepBlend.BRepBlend_AppFuncRstRst_swigregister
BRepBlend_AppFuncRstRst_swigregister(BRepBlend_AppFuncRstRst)

def BRepBlend_AppFuncRstRst_get_type_name(*args):
    """
    BRepBlend_AppFuncRstRst_get_type_name() -> char const *

    :rtype: const char *

    """
    return _BRepBlend.BRepBlend_AppFuncRstRst_get_type_name(*args)

def BRepBlend_AppFuncRstRst_get_type_descriptor(*args):
    """
    BRepBlend_AppFuncRstRst_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _BRepBlend.BRepBlend_AppFuncRstRst_get_type_descriptor(*args)

class Handle_BRepBlend_Line(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_BRepBlend_Line self)

        Nullify the handle


        """
        return _BRepBlend.Handle_BRepBlend_Line_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_BRepBlend_Line self) -> bool

        Check for being null

        :rtype: bool

        """
        return _BRepBlend.Handle_BRepBlend_Line_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_BRepBlend_Line self, BRepBlend_Line thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _BRepBlend.Handle_BRepBlend_Line_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_BRepBlend_Line self, Handle_BRepBlend_Line theHandle) -> Handle_BRepBlend_Line
        assign(Handle_BRepBlend_Line self, BRepBlend_Line thePtr) -> Handle_BRepBlend_Line
        assign(Handle_BRepBlend_Line self, Handle_BRepBlend_Line theHandle) -> Handle_BRepBlend_Line

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _BRepBlend.Handle_BRepBlend_Line_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_BRepBlend_Line self) -> BRepBlend_Line

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _BRepBlend.Handle_BRepBlend_Line_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_BRepBlend_Line self) -> BRepBlend_Line

        Member access operator (note non-const)

        :rtype: T *

        """
        return _BRepBlend.Handle_BRepBlend_Line___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_BRepBlend_Line self) -> BRepBlend_Line

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _BRepBlend.Handle_BRepBlend_Line___ref__(self, *args)


    def __hash__(self):
        return _BRepBlend.Handle_BRepBlend_Line___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _BRepBlend.Handle_BRepBlend_Line___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _BRepBlend.new_Handle_BRepBlend_Line(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_BRepBlend.Handle_BRepBlend_Line_DownCast)
    __swig_destroy__ = _BRepBlend.delete_Handle_BRepBlend_Line

    def Clear(self, *args):
        """
        Clear(Handle_BRepBlend_Line self)

        Clears the content of the line.


        """
        return _BRepBlend.Handle_BRepBlend_Line_Clear(self, *args)


    def Append(self, *args):
        """
        Append(Handle_BRepBlend_Line self, Blend_Point P)

        Adds a point in the line.

        :type P: OCC.wrapper.Blend.Blend_Point

        """
        return _BRepBlend.Handle_BRepBlend_Line_Append(self, *args)


    def Prepend(self, *args):
        """
        Prepend(Handle_BRepBlend_Line self, Blend_Point P)

        Adds a point in the line at the first place.

        :type P: OCC.wrapper.Blend.Blend_Point

        """
        return _BRepBlend.Handle_BRepBlend_Line_Prepend(self, *args)


    def InsertBefore(self, *args):
        """
        InsertBefore(Handle_BRepBlend_Line self, Standard_Integer const Index, Blend_Point P)

        Adds a point in the line at the first place.

        :type Index: int
        :type P: OCC.wrapper.Blend.Blend_Point

        """
        return _BRepBlend.Handle_BRepBlend_Line_InsertBefore(self, *args)


    def Remove(self, *args):
        """
        Remove(Handle_BRepBlend_Line self, Standard_Integer const FromIndex, Standard_Integer const ToIndex)

        Removes  from  <me>    all  the  items  of
        positions between <FromIndex> and <ToIndex>.
        Raises an exception if the indices are out of bounds.

        :type FromIndex: int
        :type ToIndex: int

        """
        return _BRepBlend.Handle_BRepBlend_Line_Remove(self, *args)


    def Set(self, *args):
        """
        Set(Handle_BRepBlend_Line self, IntSurf_TypeTrans const TranS1, IntSurf_TypeTrans const TranS2)
        Set(Handle_BRepBlend_Line self, IntSurf_TypeTrans const Trans)

        Sets the value of the transition of the line on a surface

        :type Trans: OCC.wrapper.IntSurf.IntSurf_TypeTrans

        """
        return _BRepBlend.Handle_BRepBlend_Line_Set(self, *args)


    def SetStartPoints(self, *args):
        """
        SetStartPoints(Handle_BRepBlend_Line self, BRepBlend_Extremity StartPt1, BRepBlend_Extremity StartPt2)

        Sets the values of the start points for the line.

        :type StartPt1: OCC.wrapper.BRepBlend.BRepBlend_Extremity
        :type StartPt2: OCC.wrapper.BRepBlend.BRepBlend_Extremity

        """
        return _BRepBlend.Handle_BRepBlend_Line_SetStartPoints(self, *args)


    def SetEndPoints(self, *args):
        """
        SetEndPoints(Handle_BRepBlend_Line self, BRepBlend_Extremity EndPt1, BRepBlend_Extremity EndPt2)

        Sets tne values of the end points for the line.

        :type EndPt1: OCC.wrapper.BRepBlend.BRepBlend_Extremity
        :type EndPt2: OCC.wrapper.BRepBlend.BRepBlend_Extremity

        """
        return _BRepBlend.Handle_BRepBlend_Line_SetEndPoints(self, *args)


    def NbPoints(self, *args):
        """
        NbPoints(Handle_BRepBlend_Line self) -> Standard_Integer

        Returns the number of points in the line.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepBlend.Handle_BRepBlend_Line_NbPoints(self, *args)


    def Point(self, *args):
        """
        Returns the point of range Index.

        :type Index: int
        :rtype: OCC.wrapper.Blend.Blend_Point

        """
        res = _BRepBlend.Handle_BRepBlend_Line_Point(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def TransitionOnS1(self, *args):
        """
        TransitionOnS1(Handle_BRepBlend_Line self) -> IntSurf_TypeTrans

        Returns the type of the transition of the line defined
        on the first surface. The transition is "constant"
        along the line.
        The transition is IN if the line is oriented in such
        a way that the system of vectors (N,DRac,T) is
        right-handed, where
        N is the normal to the first surface at a point P,
        DRac is a vector tangent to the blending patch,
        oriented towards the valid part of this patch,
        T  is the tangent to the line on S1 at P.
        The transitioon is OUT when the system of vectors is
        left-handed.

        :rtype: OCC.wrapper.IntSurf.IntSurf_TypeTrans

        """
        return _BRepBlend.Handle_BRepBlend_Line_TransitionOnS1(self, *args)


    def TransitionOnS2(self, *args):
        """
        TransitionOnS2(Handle_BRepBlend_Line self) -> IntSurf_TypeTrans

        Returns the type of the transition of the line defined
        on the second surface. The transition is "constant"
        along the line.

        :rtype: OCC.wrapper.IntSurf.IntSurf_TypeTrans

        """
        return _BRepBlend.Handle_BRepBlend_Line_TransitionOnS2(self, *args)


    def StartPointOnFirst(self, *args):
        """
        Returns the start point on S1.

        :rtype: OCC.wrapper.BRepBlend.BRepBlend_Extremity

        """
        res = _BRepBlend.Handle_BRepBlend_Line_StartPointOnFirst(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def StartPointOnSecond(self, *args):
        """
        Returns the start point on S2

        :rtype: OCC.wrapper.BRepBlend.BRepBlend_Extremity

        """
        res = _BRepBlend.Handle_BRepBlend_Line_StartPointOnSecond(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def EndPointOnFirst(self, *args):
        """
        Returns the end point on S1.

        :rtype: OCC.wrapper.BRepBlend.BRepBlend_Extremity

        """
        res = _BRepBlend.Handle_BRepBlend_Line_EndPointOnFirst(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def EndPointOnSecond(self, *args):
        """
        Returns the point on S2.

        :rtype: OCC.wrapper.BRepBlend.BRepBlend_Extremity

        """
        res = _BRepBlend.Handle_BRepBlend_Line_EndPointOnSecond(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def TransitionOnS(self, *args):
        """
        TransitionOnS(Handle_BRepBlend_Line self) -> IntSurf_TypeTrans

        Returns the type of the transition of the line defined
        on the surface.

        :rtype: OCC.wrapper.IntSurf.IntSurf_TypeTrans

        """
        return _BRepBlend.Handle_BRepBlend_Line_TransitionOnS(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_BRepBlend_Line self) -> char const *

        :rtype: const char *

        """
        return _BRepBlend.Handle_BRepBlend_Line_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _BRepBlend.Handle_BRepBlend_Line_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _BRepBlend.Handle_BRepBlend_Line_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_BRepBlend_Line self)

        Memory deallocator for transient classes


        """
        return _BRepBlend.Handle_BRepBlend_Line_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_BRepBlend_Line self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_BRepBlend_Line self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepBlend.Handle_BRepBlend_Line_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_BRepBlend_Line self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_BRepBlend_Line self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepBlend.Handle_BRepBlend_Line_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_BRepBlend_Line self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _BRepBlend.Handle_BRepBlend_Line_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_BRepBlend_Line self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepBlend.Handle_BRepBlend_Line_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_BRepBlend_Line self)

        Increments the reference counter of this object


        """
        return _BRepBlend.Handle_BRepBlend_Line_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_BRepBlend_Line self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepBlend.Handle_BRepBlend_Line_DecrementRefCounter(self, *args)

Handle_BRepBlend_Line_swigregister = _BRepBlend.Handle_BRepBlend_Line_swigregister
Handle_BRepBlend_Line_swigregister(Handle_BRepBlend_Line)

def Handle_BRepBlend_Line_DownCast(thing):
    return _BRepBlend.Handle_BRepBlend_Line_DownCast(thing)
Handle_BRepBlend_Line_DownCast = _BRepBlend.Handle_BRepBlend_Line_DownCast

class BRepBlend_SurfRstLineBuilder(object):
    """
    This  class processes data  resulting  from
    Blend_CSWalking  taking  in consideration the Surface
    supporting  the curve to detect the breakpoint.

    The criteria of  distribution  of  points on  the  line are  detailed
    because  it  is  to  be  used  in  the  calculatuon of values approached
    by an approximation of functions continued  basing on
    Blend_SurfRstFunction.

    Thus this pseudo path necessitates 3 criteria of regrouping :

    1) exit of the domain of  the curve

    2) exit of the domain of  the  surface

    3)  stall as there  is a solution to  the problem
    surf/surf  within  the  domain of  the surface
    of  support  of  the   restriction.

    Construction of a BRepBlend_Line between a surface and
    a pcurve on surface from an approached
    starting solution. The output entries of this builder
    are of the same nature as of the traditional walking
    but the requirements on the Line are not the same
    If the determination of validity range is always
    guaranteed, the criteria of correct repartition of sections
    before smoothing are not respected. The resulting Line
    is f(t) oriented.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BRepBlend_SurfRstLineBuilder self, Handle_Adaptor3d_HSurface Surf1, Handle_Adaptor3d_TopolTool Domain1, Handle_Adaptor3d_HSurface Surf2, Handle_Adaptor2d_HCurve2d Rst, Handle_Adaptor3d_TopolTool Domain2) -> BRepBlend_SurfRstLineBuilder

        :type Surf1: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface
        :type Domain1: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_TopolTool
        :type Surf2: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface
        :type Rst: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d
        :type Domain2: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_TopolTool

        """
        this = _BRepBlend.new_BRepBlend_SurfRstLineBuilder(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Perform(self, *args):
        """
        Perform(BRepBlend_SurfRstLineBuilder self, Blend_SurfRstFunction Func, Blend_FuncInv Finv, Blend_SurfPointFuncInv FinvP, Blend_SurfCurvFuncInv FinvC, Standard_Real const Pdep, Standard_Real const Pmax, Standard_Real const MaxStep, Standard_Real const TolGuide, math_Vector Soldep, Standard_Real const Tolesp, Standard_Real const Fleche, Standard_Boolean const Appro)

        :type Func: OCC.wrapper.Blend.Blend_SurfRstFunction
        :type Finv: OCC.wrapper.Blend.Blend_FuncInv
        :type FinvP: OCC.wrapper.Blend.Blend_SurfPointFuncInv
        :type FinvC: OCC.wrapper.Blend.Blend_SurfCurvFuncInv
        :type Pdep: float
        :type Pmax: float
        :type MaxStep: float
        :type TolGuide: float
        :type Soldep: OCC.wrapper.math.math_Vector
        :type Tolesp: float
        :type Fleche: float
        :type Appro: bool

        """
        return _BRepBlend.BRepBlend_SurfRstLineBuilder_Perform(self, *args)


    def PerformFirstSection(self, *args):
        """
        PerformFirstSection(BRepBlend_SurfRstLineBuilder self, Blend_SurfRstFunction Func, Blend_FuncInv Finv, Blend_SurfPointFuncInv FinvP, Blend_SurfCurvFuncInv FinvC, Standard_Real const Pdep, Standard_Real const Pmax, math_Vector Soldep, Standard_Real const Tolesp, Standard_Real const TolGuide, Standard_Boolean const RecRst, Standard_Boolean const RecP, Standard_Boolean const RecS, math_Vector ParSol) -> Standard_Boolean

        :type Func: OCC.wrapper.Blend.Blend_SurfRstFunction
        :type Finv: OCC.wrapper.Blend.Blend_FuncInv
        :type FinvP: OCC.wrapper.Blend.Blend_SurfPointFuncInv
        :type FinvC: OCC.wrapper.Blend.Blend_SurfCurvFuncInv
        :type Pdep: float
        :type Pmax: float
        :type Soldep: OCC.wrapper.math.math_Vector
        :type Tolesp: float
        :type TolGuide: float
        :type RecRst: bool
        :type RecP: bool
        :type RecS: bool
        :type Psol: float
        :type ParSol: OCC.wrapper.math.math_Vector
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepBlend.BRepBlend_SurfRstLineBuilder_PerformFirstSection(self, *args)


    def Complete(self, *args):
        """
        Complete(BRepBlend_SurfRstLineBuilder self, Blend_SurfRstFunction Func, Blend_FuncInv Finv, Blend_SurfPointFuncInv FinvP, Blend_SurfCurvFuncInv FinvC, Standard_Real const Pmin) -> Standard_Boolean

        :type Func: OCC.wrapper.Blend.Blend_SurfRstFunction
        :type Finv: OCC.wrapper.Blend.Blend_FuncInv
        :type FinvP: OCC.wrapper.Blend.Blend_SurfPointFuncInv
        :type FinvC: OCC.wrapper.Blend.Blend_SurfCurvFuncInv
        :type Pmin: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepBlend.BRepBlend_SurfRstLineBuilder_Complete(self, *args)


    def ArcToRecadre(self, *args):
        """
        ArcToRecadre(BRepBlend_SurfRstLineBuilder self, math_Vector Sol, Standard_Integer const PrevIndex, gp_Pnt2d pt2d, gp_Pnt2d lastpt2d) -> Standard_Integer

        :type Sol: OCC.wrapper.math.math_Vector
        :type PrevIndex: int
        :type pt2d: OCC.wrapper.gp.gp_Pnt2d
        :type lastpt2d: OCC.wrapper.gp.gp_Pnt2d
        :type ponarc: float
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepBlend.BRepBlend_SurfRstLineBuilder_ArcToRecadre(self, *args)


    def IsDone(self, *args):
        """
        IsDone(BRepBlend_SurfRstLineBuilder self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepBlend.BRepBlend_SurfRstLineBuilder_IsDone(self, *args)


    def Line(self, *args):
        """
        :rtype: OCC.wrapper.BRepBlend.Handle_BRepBlend_Line

        """
        res = _BRepBlend.BRepBlend_SurfRstLineBuilder_Line(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DecrochStart(self, *args):
        """
        DecrochStart(BRepBlend_SurfRstLineBuilder self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepBlend.BRepBlend_SurfRstLineBuilder_DecrochStart(self, *args)


    def DecrochEnd(self, *args):
        """
        DecrochEnd(BRepBlend_SurfRstLineBuilder self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepBlend.BRepBlend_SurfRstLineBuilder_DecrochEnd(self, *args)

    __swig_destroy__ = _BRepBlend.delete_BRepBlend_SurfRstLineBuilder
BRepBlend_SurfRstLineBuilder_swigregister = _BRepBlend.BRepBlend_SurfRstLineBuilder_swigregister
BRepBlend_SurfRstLineBuilder_swigregister(BRepBlend_SurfRstLineBuilder)

class BRepBlend_CSWalking(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BRepBlend_CSWalking self, Handle_Adaptor3d_HCurve Curv, Handle_Adaptor3d_HSurface Surf, Handle_Adaptor3d_TopolTool Domain) -> BRepBlend_CSWalking

        :type Curv: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HCurve
        :type Surf: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface
        :type Domain: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_TopolTool

        """
        this = _BRepBlend.new_BRepBlend_CSWalking(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Perform(self, *args):
        """
        Perform(BRepBlend_CSWalking self, Blend_CSFunction F, Standard_Real const Pdep, Standard_Real const Pmax, Standard_Real const MaxStep, Standard_Real const TolGuide, math_Vector Soldep, Standard_Real const Tolesp, Standard_Real const Fleche, Standard_Boolean const Appro)

        :type F: OCC.wrapper.Blend.Blend_CSFunction
        :type Pdep: float
        :type Pmax: float
        :type MaxStep: float
        :type TolGuide: float
        :type Soldep: OCC.wrapper.math.math_Vector
        :type Tolesp: float
        :type Fleche: float
        :type Appro: bool

        """
        return _BRepBlend.BRepBlend_CSWalking_Perform(self, *args)


    def Complete(self, *args):
        """
        Complete(BRepBlend_CSWalking self, Blend_CSFunction F, Standard_Real const Pmin) -> Standard_Boolean

        :type F: OCC.wrapper.Blend.Blend_CSFunction
        :type Pmin: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepBlend.BRepBlend_CSWalking_Complete(self, *args)


    def IsDone(self, *args):
        """
        IsDone(BRepBlend_CSWalking self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepBlend.BRepBlend_CSWalking_IsDone(self, *args)


    def Line(self, *args):
        """
        :rtype: OCC.wrapper.BRepBlend.Handle_BRepBlend_Line

        """
        res = _BRepBlend.BRepBlend_CSWalking_Line(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _BRepBlend.delete_BRepBlend_CSWalking
BRepBlend_CSWalking_swigregister = _BRepBlend.BRepBlend_CSWalking_swigregister
BRepBlend_CSWalking_swigregister(BRepBlend_CSWalking)

class BRepBlend_CurvPointRadInv(Blend.Blend_CurvPointFuncInv):
    """
    Function of reframing between a point and a curve.
    valid in cases of constant and progressive radius.
    This function  is used  to find a  solution on  a done
    point   of   the curve 1 when   using  RstRstConsRad or
    CSConstRad...
    The vector <X>  used in Value, Values and  Derivatives
    methods  has  to   be the  vector   of the  parametric
    coordinates w, U where w is  the parameter  on the
    guide line, U   are the parametric coordinates of  a
    point on the partner curve 2.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BRepBlend_CurvPointRadInv self, Handle_Adaptor3d_HCurve C1, Handle_Adaptor3d_HCurve C2) -> BRepBlend_CurvPointRadInv

        :type C1: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HCurve
        :type C2: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HCurve

        """
        this = _BRepBlend.new_BRepBlend_CurvPointRadInv(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def NbEquations(self, *args):
        """
        NbEquations(BRepBlend_CurvPointRadInv self) -> Standard_Integer

        returns 2.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepBlend.BRepBlend_CurvPointRadInv_NbEquations(self, *args)


    def Value(self, *args):
        """
        Value(BRepBlend_CurvPointRadInv self, math_Vector X, math_Vector F) -> Standard_Boolean

        computes the values <F> of the Functions for the
        variable <X>.
        Returns True if the computation was done successfully,
        False otherwise.

        :type X: OCC.wrapper.math.math_Vector
        :type F: OCC.wrapper.math.math_Vector
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepBlend.BRepBlend_CurvPointRadInv_Value(self, *args)


    def Derivatives(self, *args):
        """
        Derivatives(BRepBlend_CurvPointRadInv self, math_Vector X, math_Matrix D) -> Standard_Boolean

        returns the values <D> of the derivatives for the
        variable <X>.
        Returns True if the computation was done successfully,
        False otherwise.

        :type X: OCC.wrapper.math.math_Vector
        :type D: OCC.wrapper.math.math_Matrix
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepBlend.BRepBlend_CurvPointRadInv_Derivatives(self, *args)


    def Values(self, *args):
        """
        Values(BRepBlend_CurvPointRadInv self, math_Vector X, math_Vector F, math_Matrix D) -> Standard_Boolean

        returns the values <F> of the functions and the derivatives
        <D> for the variable <X>.
        Returns True if the computation was done successfully,
        False otherwise.

        :type X: OCC.wrapper.math.math_Vector
        :type F: OCC.wrapper.math.math_Vector
        :type D: OCC.wrapper.math.math_Matrix
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepBlend.BRepBlend_CurvPointRadInv_Values(self, *args)


    def Set(self, *args):
        """
        Set(BRepBlend_CurvPointRadInv self, Standard_Integer const Choix)
        Set(BRepBlend_CurvPointRadInv self, gp_Pnt P)

        Set the Point on which a solution has to be found.

        :type P: OCC.wrapper.gp.gp_Pnt

        """
        return _BRepBlend.BRepBlend_CurvPointRadInv_Set(self, *args)


    def GetTolerance(self, *args):
        """
        GetTolerance(BRepBlend_CurvPointRadInv self, math_Vector Tolerance, Standard_Real const Tol)

        Returns in the vector Tolerance the parametric tolerance
        for each of the 3 variables;
        Tol is the tolerance used in 3d space.

        :type Tolerance: OCC.wrapper.math.math_Vector
        :type Tol: float

        """
        return _BRepBlend.BRepBlend_CurvPointRadInv_GetTolerance(self, *args)


    def GetBounds(self, *args):
        """
        GetBounds(BRepBlend_CurvPointRadInv self, math_Vector InfBound, math_Vector SupBound)

        Returns in the vector InfBound the lowest values allowed
        for each of the 3 variables.
        Returns in the vector SupBound the greatest values allowed
        for each of the 3 variables.

        :type InfBound: OCC.wrapper.math.math_Vector
        :type SupBound: OCC.wrapper.math.math_Vector

        """
        return _BRepBlend.BRepBlend_CurvPointRadInv_GetBounds(self, *args)


    def IsSolution(self, *args):
        """
        IsSolution(BRepBlend_CurvPointRadInv self, math_Vector Sol, Standard_Real const Tol) -> Standard_Boolean

        Returns Standard_True if Sol is a zero of the function.
        Tol is the tolerance used in 3d space.

        :type Sol: OCC.wrapper.math.math_Vector
        :type Tol: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepBlend.BRepBlend_CurvPointRadInv_IsSolution(self, *args)

    __swig_destroy__ = _BRepBlend.delete_BRepBlend_CurvPointRadInv
BRepBlend_CurvPointRadInv_swigregister = _BRepBlend.BRepBlend_CurvPointRadInv_swigregister
BRepBlend_CurvPointRadInv_swigregister(BRepBlend_CurvPointRadInv)

class BRepBlend_SurfCurvConstRadInv(Blend.Blend_SurfCurvFuncInv):
    """
    Function of reframing between a restriction surface of the
    surface and a curve.
    Class     used   to   compute  a    solution   of  the
    surfRstConstRad  problem  on a done restriction of the
    surface.
    The vector  <X> used in  Value, Values and Derivatives
    methods  has   to  be the   vector  of  the parametric
    coordinates  wguide, wcurv, wrst  where  wguide is the
    parameter on the guide line, wcurv is the parameter on
    the curve, wrst is the parameter on the restriction on
    the surface.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BRepBlend_SurfCurvConstRadInv self, Handle_Adaptor3d_HSurface S, Handle_Adaptor3d_HCurve C, Handle_Adaptor3d_HCurve Cg) -> BRepBlend_SurfCurvConstRadInv

        :type S: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface
        :type C: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HCurve
        :type Cg: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HCurve

        """
        this = _BRepBlend.new_BRepBlend_SurfCurvConstRadInv(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def NbEquations(self, *args):
        """
        NbEquations(BRepBlend_SurfCurvConstRadInv self) -> Standard_Integer

        returns 3.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepBlend.BRepBlend_SurfCurvConstRadInv_NbEquations(self, *args)


    def Value(self, *args):
        """
        Value(BRepBlend_SurfCurvConstRadInv self, math_Vector X, math_Vector F) -> Standard_Boolean

        computes the values <F> of the Functions for the
        variable <X>.
        Returns True if the computation was done successfully,
        False otherwise.

        :type X: OCC.wrapper.math.math_Vector
        :type F: OCC.wrapper.math.math_Vector
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepBlend.BRepBlend_SurfCurvConstRadInv_Value(self, *args)


    def Derivatives(self, *args):
        """
        Derivatives(BRepBlend_SurfCurvConstRadInv self, math_Vector X, math_Matrix D) -> Standard_Boolean

        returns the values <D> of the derivatives for the
        variable <X>.
        Returns True if the computation was done successfully,
        False otherwise.

        :type X: OCC.wrapper.math.math_Vector
        :type D: OCC.wrapper.math.math_Matrix
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepBlend.BRepBlend_SurfCurvConstRadInv_Derivatives(self, *args)


    def Values(self, *args):
        """
        Values(BRepBlend_SurfCurvConstRadInv self, math_Vector X, math_Vector F, math_Matrix D) -> Standard_Boolean

        returns the values <F> of the functions and the derivatives
        <D> for the variable <X>.
        Returns True if the computation was done successfully,
        False otherwise.

        :type X: OCC.wrapper.math.math_Vector
        :type F: OCC.wrapper.math.math_Vector
        :type D: OCC.wrapper.math.math_Matrix
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepBlend.BRepBlend_SurfCurvConstRadInv_Values(self, *args)


    def Set(self, *args):
        """
        Set(BRepBlend_SurfCurvConstRadInv self, Standard_Real const R, Standard_Integer const Choix)
        Set(BRepBlend_SurfCurvConstRadInv self, Handle_Adaptor2d_HCurve2d Rst)

        Set the restriction on which a solution has to be found.

        :type Rst: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d

        """
        return _BRepBlend.BRepBlend_SurfCurvConstRadInv_Set(self, *args)


    def GetTolerance(self, *args):
        """
        GetTolerance(BRepBlend_SurfCurvConstRadInv self, math_Vector Tolerance, Standard_Real const Tol)

        Returns in the vector Tolerance the parametric tolerance
        for each of the 3 variables;
        Tol is the tolerance used in 3d space.

        :type Tolerance: OCC.wrapper.math.math_Vector
        :type Tol: float

        """
        return _BRepBlend.BRepBlend_SurfCurvConstRadInv_GetTolerance(self, *args)


    def GetBounds(self, *args):
        """
        GetBounds(BRepBlend_SurfCurvConstRadInv self, math_Vector InfBound, math_Vector SupBound)

        Returns in the vector InfBound the lowest values allowed
        for each of the 3 variables.
        Returns in the vector SupBound the greatest values allowed
        for each of the 3 variables.

        :type InfBound: OCC.wrapper.math.math_Vector
        :type SupBound: OCC.wrapper.math.math_Vector

        """
        return _BRepBlend.BRepBlend_SurfCurvConstRadInv_GetBounds(self, *args)


    def IsSolution(self, *args):
        """
        IsSolution(BRepBlend_SurfCurvConstRadInv self, math_Vector Sol, Standard_Real const Tol) -> Standard_Boolean

        Returns Standard_True if Sol is a zero of the function.
        Tol is the tolerance used in 3d space.

        :type Sol: OCC.wrapper.math.math_Vector
        :type Tol: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepBlend.BRepBlend_SurfCurvConstRadInv_IsSolution(self, *args)

    __swig_destroy__ = _BRepBlend.delete_BRepBlend_SurfCurvConstRadInv
BRepBlend_SurfCurvConstRadInv_swigregister = _BRepBlend.BRepBlend_SurfCurvConstRadInv_swigregister
BRepBlend_SurfCurvConstRadInv_swigregister(BRepBlend_SurfCurvConstRadInv)

class BRepBlend_Extremity(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BRepBlend_Extremity self) -> BRepBlend_Extremity
        __init__(BRepBlend_Extremity self, gp_Pnt P, Standard_Real const U, Standard_Real const V, Standard_Real const Param, Standard_Real const Tol) -> BRepBlend_Extremity
        __init__(BRepBlend_Extremity self, gp_Pnt P, Standard_Real const U, Standard_Real const V, Standard_Real const Param, Standard_Real const Tol, Handle_Adaptor3d_HVertex Vtx) -> BRepBlend_Extremity
        __init__(BRepBlend_Extremity self, gp_Pnt P, Standard_Real const W, Standard_Real const Param, Standard_Real const Tol) -> BRepBlend_Extremity

        Creates an extremity on a curve

        :type P: OCC.wrapper.gp.gp_Pnt
        :type W: float
        :type Param: float
        :type Tol: float

        """
        this = _BRepBlend.new_BRepBlend_Extremity(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def SetValue(self, *args):
        """
        SetValue(BRepBlend_Extremity self, gp_Pnt P, Standard_Real const U, Standard_Real const V, Standard_Real const Param, Standard_Real const Tol)
        SetValue(BRepBlend_Extremity self, gp_Pnt P, Standard_Real const U, Standard_Real const V, Standard_Real const Param, Standard_Real const Tol, Handle_Adaptor3d_HVertex Vtx)
        SetValue(BRepBlend_Extremity self, gp_Pnt P, Standard_Real const W, Standard_Real const Param, Standard_Real const Tol)

        Set the values for an extremity on curve.

        :type P: OCC.wrapper.gp.gp_Pnt
        :type W: float
        :type Param: float
        :type Tol: float

        """
        return _BRepBlend.BRepBlend_Extremity_SetValue(self, *args)


    def Value(self, *args):
        """
        This method returns the value of the point in 3d space.

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        res = _BRepBlend.BRepBlend_Extremity_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetTangent(self, *args):
        """
        SetTangent(BRepBlend_Extremity self, gp_Vec Tangent)

        Set the tangent   vector  for an extremity on  a
        surface.

        :type Tangent: OCC.wrapper.gp.gp_Vec

        """
        return _BRepBlend.BRepBlend_Extremity_SetTangent(self, *args)


    def HasTangent(self, *args):
        """
        HasTangent(BRepBlend_Extremity self) -> Standard_Boolean

        Returns TRUE if the Tangent is  stored.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepBlend.BRepBlend_Extremity_HasTangent(self, *args)


    def Tangent(self, *args):
        """
        This  method returns the   value of tangent  in 3d
        space.

        :rtype: OCC.wrapper.gp.gp_Vec

        """
        res = _BRepBlend.BRepBlend_Extremity_Tangent(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Tolerance(self, *args):
        """
        Tolerance(BRepBlend_Extremity self) -> Standard_Real

        This method returns the fuzziness on the point
        in 3d space.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _BRepBlend.BRepBlend_Extremity_Tolerance(self, *args)


    def SetVertex(self, *args):
        """
        SetVertex(BRepBlend_Extremity self, Handle_Adaptor3d_HVertex V)

        Set the values for an extremity on a curve.

        :type V: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HVertex

        """
        return _BRepBlend.BRepBlend_Extremity_SetVertex(self, *args)


    def AddArc(self, *args):
        """
        AddArc(BRepBlend_Extremity self, Handle_Adaptor2d_HCurve2d A, Standard_Real const Param, IntSurf_Transition TLine, IntSurf_Transition TArc)

        Sets the values of a point which is on the arc
        A, at parameter Param.

        :type A: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d
        :type Param: float
        :type TLine: OCC.wrapper.IntSurf.IntSurf_Transition
        :type TArc: OCC.wrapper.IntSurf.IntSurf_Transition

        """
        return _BRepBlend.BRepBlend_Extremity_AddArc(self, *args)


    def Parameters(self, *args):
        """
        Parameters(BRepBlend_Extremity self)

        This method returns the parameters of the point
        on the concerned surface.

        :type U: float
        :type V: float

        """
        return _BRepBlend.BRepBlend_Extremity_Parameters(self, *args)


    def IsVertex(self, *args):
        """
        IsVertex(BRepBlend_Extremity self) -> Standard_Boolean

        Returns Standard_True when the point coincide with
        an existing vertex.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepBlend.BRepBlend_Extremity_IsVertex(self, *args)


    def Vertex(self, *args):
        """
        Returns the vertex when IsVertex returns Standard_True.

        :rtype: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HVertex

        """
        res = _BRepBlend.BRepBlend_Extremity_Vertex(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def NbPointOnRst(self, *args):
        """
        NbPointOnRst(BRepBlend_Extremity self) -> Standard_Integer

        Returns the number of arc containing the extremity.
        If the method returns 0, the point is inside the
        surface.
        Otherwise, the extremity lies on at least 1 arc,
        and all the information (arc, parameter, transitions)
        are given by the point on restriction (PointOnRst)
        returned by the next method.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepBlend.BRepBlend_Extremity_NbPointOnRst(self, *args)


    def PointOnRst(self, *args):
        """
        :type Index: int
        :rtype: OCC.wrapper.BRepBlend.BRepBlend_PointOnRst

        """
        res = _BRepBlend.BRepBlend_Extremity_PointOnRst(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Parameter(self, *args):
        """
        Parameter(BRepBlend_Extremity self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _BRepBlend.BRepBlend_Extremity_Parameter(self, *args)


    def ParameterOnGuide(self, *args):
        """
        ParameterOnGuide(BRepBlend_Extremity self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _BRepBlend.BRepBlend_Extremity_ParameterOnGuide(self, *args)

    __swig_destroy__ = _BRepBlend.delete_BRepBlend_Extremity
BRepBlend_Extremity_swigregister = _BRepBlend.BRepBlend_Extremity_swigregister
BRepBlend_Extremity_swigregister(BRepBlend_Extremity)

class Handle_BRepBlend_AppFuncRstRst(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_BRepBlend_AppFuncRstRst self)

        Nullify the handle


        """
        return _BRepBlend.Handle_BRepBlend_AppFuncRstRst_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_BRepBlend_AppFuncRstRst self) -> bool

        Check for being null

        :rtype: bool

        """
        return _BRepBlend.Handle_BRepBlend_AppFuncRstRst_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_BRepBlend_AppFuncRstRst self, BRepBlend_AppFuncRstRst thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _BRepBlend.Handle_BRepBlend_AppFuncRstRst_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_BRepBlend_AppFuncRstRst self, Handle_BRepBlend_AppFuncRstRst theHandle) -> Handle_BRepBlend_AppFuncRstRst
        assign(Handle_BRepBlend_AppFuncRstRst self, BRepBlend_AppFuncRstRst thePtr) -> Handle_BRepBlend_AppFuncRstRst
        assign(Handle_BRepBlend_AppFuncRstRst self, Handle_BRepBlend_AppFuncRstRst theHandle) -> Handle_BRepBlend_AppFuncRstRst

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _BRepBlend.Handle_BRepBlend_AppFuncRstRst_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_BRepBlend_AppFuncRstRst self) -> BRepBlend_AppFuncRstRst

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _BRepBlend.Handle_BRepBlend_AppFuncRstRst_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_BRepBlend_AppFuncRstRst self) -> BRepBlend_AppFuncRstRst

        Member access operator (note non-const)

        :rtype: T *

        """
        return _BRepBlend.Handle_BRepBlend_AppFuncRstRst___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_BRepBlend_AppFuncRstRst self) -> BRepBlend_AppFuncRstRst

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _BRepBlend.Handle_BRepBlend_AppFuncRstRst___ref__(self, *args)


    def __hash__(self):
        return _BRepBlend.Handle_BRepBlend_AppFuncRstRst___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _BRepBlend.Handle_BRepBlend_AppFuncRstRst___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _BRepBlend.new_Handle_BRepBlend_AppFuncRstRst(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_BRepBlend.Handle_BRepBlend_AppFuncRstRst_DownCast)
    __swig_destroy__ = _BRepBlend.delete_Handle_BRepBlend_AppFuncRstRst

    def Point(self, *args):
        """
        Point(Handle_BRepBlend_AppFuncRstRst self, Blend_AppFunction Func, Standard_Real const Param, math_Vector Sol, Blend_Point Pnt)

        :type Func: OCC.wrapper.Blend.Blend_AppFunction
        :type Param: float
        :type Sol: OCC.wrapper.math.math_Vector
        :type Pnt: OCC.wrapper.Blend.Blend_Point

        """
        return _BRepBlend.Handle_BRepBlend_AppFuncRstRst_Point(self, *args)


    def Vec(self, *args):
        """
        Vec(Handle_BRepBlend_AppFuncRstRst self, math_Vector Sol, Blend_Point Pnt)

        :type Sol: OCC.wrapper.math.math_Vector
        :type Pnt: OCC.wrapper.Blend.Blend_Point

        """
        return _BRepBlend.Handle_BRepBlend_AppFuncRstRst_Vec(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_BRepBlend_AppFuncRstRst self) -> char const *

        :rtype: const char *

        """
        return _BRepBlend.Handle_BRepBlend_AppFuncRstRst_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _BRepBlend.Handle_BRepBlend_AppFuncRstRst_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _BRepBlend.Handle_BRepBlend_AppFuncRstRst_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def D0(self, *args):
        """
        D0(Handle_BRepBlend_AppFuncRstRst self, Standard_Real const Param, Standard_Real const First, Standard_Real const Last, NCollection_Array1_gp_Pnt Poles, NCollection_Array1_gp_Pnt2d Poles2d, NCollection_Array1_Standard_Real Weigths) -> Standard_Boolean

        compute the section for v = param

        :type Param: float
        :type First: float
        :type Last: float
        :type Poles: OCC.wrapper.TColgp.TColgp_Array1OfPnt
        :type Poles2d: OCC.wrapper.TColgp.TColgp_Array1OfPnt2d
        :type Weigths: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepBlend.Handle_BRepBlend_AppFuncRstRst_D0(self, *args)


    def D1(self, *args):
        """
        D1(Handle_BRepBlend_AppFuncRstRst self, Standard_Real const Param, Standard_Real const First, Standard_Real const Last, NCollection_Array1_gp_Pnt Poles, NCollection_Array1_gp_Vec DPoles, NCollection_Array1_gp_Pnt2d Poles2d, NCollection_Array1_gp_Vec2d DPoles2d, NCollection_Array1_Standard_Real Weigths, NCollection_Array1_Standard_Real DWeigths) -> Standard_Boolean

        compute the first  derivative in v direction  of the
        section for v =  param

        :type Param: float
        :type First: float
        :type Last: float
        :type Poles: OCC.wrapper.TColgp.TColgp_Array1OfPnt
        :type DPoles: OCC.wrapper.TColgp.TColgp_Array1OfVec
        :type Poles2d: OCC.wrapper.TColgp.TColgp_Array1OfPnt2d
        :type DPoles2d: OCC.wrapper.TColgp.TColgp_Array1OfVec2d
        :type Weigths: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type DWeigths: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepBlend.Handle_BRepBlend_AppFuncRstRst_D1(self, *args)


    def D2(self, *args):
        """
        D2(Handle_BRepBlend_AppFuncRstRst self, Standard_Real const Param, Standard_Real const First, Standard_Real const Last, NCollection_Array1_gp_Pnt Poles, NCollection_Array1_gp_Vec DPoles, NCollection_Array1_gp_Vec D2Poles, NCollection_Array1_gp_Pnt2d Poles2d, NCollection_Array1_gp_Vec2d DPoles2d, NCollection_Array1_gp_Vec2d D2Poles2d, NCollection_Array1_Standard_Real Weigths, NCollection_Array1_Standard_Real DWeigths, NCollection_Array1_Standard_Real D2Weigths) -> Standard_Boolean

        compute the second derivative  in v direction of the
        section  for v = param

        :type Param: float
        :type First: float
        :type Last: float
        :type Poles: OCC.wrapper.TColgp.TColgp_Array1OfPnt
        :type DPoles: OCC.wrapper.TColgp.TColgp_Array1OfVec
        :type D2Poles: OCC.wrapper.TColgp.TColgp_Array1OfVec
        :type Poles2d: OCC.wrapper.TColgp.TColgp_Array1OfPnt2d
        :type DPoles2d: OCC.wrapper.TColgp.TColgp_Array1OfVec2d
        :type D2Poles2d: OCC.wrapper.TColgp.TColgp_Array1OfVec2d
        :type Weigths: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type DWeigths: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type D2Weigths: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepBlend.Handle_BRepBlend_AppFuncRstRst_D2(self, *args)


    def Nb2dCurves(self, *args):
        """
        Nb2dCurves(Handle_BRepBlend_AppFuncRstRst self) -> Standard_Integer

        get the number of 2d curves to  approximate.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepBlend.Handle_BRepBlend_AppFuncRstRst_Nb2dCurves(self, *args)


    def SectionShape(self, *args):
        """
        SectionShape(Handle_BRepBlend_AppFuncRstRst self)

        get the format of an  section

        :type NbPoles: int
        :type NbKnots: int
        :type Degree: int

        """
        return _BRepBlend.Handle_BRepBlend_AppFuncRstRst_SectionShape(self, *args)


    def Knots(self, *args):
        """
        Knots(Handle_BRepBlend_AppFuncRstRst self, NCollection_Array1_Standard_Real TKnots)

        get the Knots of the section

        :type TKnots: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        return _BRepBlend.Handle_BRepBlend_AppFuncRstRst_Knots(self, *args)


    def Mults(self, *args):
        """
        Mults(Handle_BRepBlend_AppFuncRstRst self, NCollection_Array1_Standard_Integer TMults)

        get the Multplicities of the section

        :type TMults: OCC.wrapper.TColStd.TColStd_Array1OfInteger

        """
        return _BRepBlend.Handle_BRepBlend_AppFuncRstRst_Mults(self, *args)


    def IsRational(self, *args):
        """
        IsRational(Handle_BRepBlend_AppFuncRstRst self) -> Standard_Boolean

        Returns if the section is rationnal or not

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepBlend.Handle_BRepBlend_AppFuncRstRst_IsRational(self, *args)


    def NbIntervals(self, *args):
        """
        NbIntervals(Handle_BRepBlend_AppFuncRstRst self, GeomAbs_Shape const S) -> Standard_Integer

        Returns  the number  of  intervals for  continuity
        <S>. May be one if Continuity(me) >= <S>

        :type S: OCC.wrapper.GeomAbs.GeomAbs_Shape
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepBlend.Handle_BRepBlend_AppFuncRstRst_NbIntervals(self, *args)


    def Intervals(self, *args):
        """
        Intervals(Handle_BRepBlend_AppFuncRstRst self, NCollection_Array1_Standard_Real T, GeomAbs_Shape const S)

        Stores in <T> the  parameters bounding the intervals
        of continuity <S>.

        The array must provide  enough room to  accomodate
        for the parameters. i.e. T.Length() > NbIntervals()

        :type T: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type S: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _BRepBlend.Handle_BRepBlend_AppFuncRstRst_Intervals(self, *args)


    def SetInterval(self, *args):
        """
        SetInterval(Handle_BRepBlend_AppFuncRstRst self, Standard_Real const First, Standard_Real const Last)

        Sets the bounds of the parametric interval on
        the fonction
        This determines the derivatives in these values if the
        function is not Cn.

        :type First: float
        :type Last: float

        """
        return _BRepBlend.Handle_BRepBlend_AppFuncRstRst_SetInterval(self, *args)


    def Resolution(self, *args):
        """
        Resolution(Handle_BRepBlend_AppFuncRstRst self, Standard_Integer const Index, Standard_Real const Tol)

        Returns the resolutions in the  sub-space 2d <Index> --
        This information is usfull to find an good tolerance in
        2d approximation

        :type Index: int
        :type Tol: float
        :type TolU: float
        :type TolV: float

        """
        return _BRepBlend.Handle_BRepBlend_AppFuncRstRst_Resolution(self, *args)


    def GetTolerance(self, *args):
        """
        GetTolerance(Handle_BRepBlend_AppFuncRstRst self, Standard_Real const BoundTol, Standard_Real const SurfTol, Standard_Real const AngleTol, NCollection_Array1_Standard_Real Tol3d)

        Returns the tolerance to reach in approximation
        to respecte
        BoundTol error at the Boundary
        AngleTol tangent error at the Boundary (in radian)
        SurfTol error inside the surface.

        :type BoundTol: float
        :type SurfTol: float
        :type AngleTol: float
        :type Tol3d: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        return _BRepBlend.Handle_BRepBlend_AppFuncRstRst_GetTolerance(self, *args)


    def SetTolerance(self, *args):
        """
        SetTolerance(Handle_BRepBlend_AppFuncRstRst self, Standard_Real const Tol3d, Standard_Real const Tol2d)

        Is usfull, if (me) have to  be run numerical
        algorithme to perform D0, D1 or D2

        :type Tol3d: float
        :type Tol2d: float

        """
        return _BRepBlend.Handle_BRepBlend_AppFuncRstRst_SetTolerance(self, *args)


    def BarycentreOfSurf(self, *args):
        """
        BarycentreOfSurf(Handle_BRepBlend_AppFuncRstRst self) -> gp_Pnt

        Get    the   barycentre of   Surface.   An   very  poor
        estimation is sufficent. This information is usefull
        to perform well conditionned rational approximation.

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _BRepBlend.Handle_BRepBlend_AppFuncRstRst_BarycentreOfSurf(self, *args)


    def MaximalSection(self, *args):
        """
        MaximalSection(Handle_BRepBlend_AppFuncRstRst self) -> Standard_Real

        Returns the   length of the maximum section. This
        information is usefull to perform well conditionned rational
        approximation.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _BRepBlend.Handle_BRepBlend_AppFuncRstRst_MaximalSection(self, *args)


    def GetMinimalWeight(self, *args):
        """
        GetMinimalWeight(Handle_BRepBlend_AppFuncRstRst self, NCollection_Array1_Standard_Real Weigths)

        Compute the minimal value of weight for each poles
        of all  sections.  This information is  usefull to
        perform well conditionned rational approximation.

        :type Weigths: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        return _BRepBlend.Handle_BRepBlend_AppFuncRstRst_GetMinimalWeight(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_BRepBlend_AppFuncRstRst self)

        Memory deallocator for transient classes


        """
        return _BRepBlend.Handle_BRepBlend_AppFuncRstRst_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_BRepBlend_AppFuncRstRst self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_BRepBlend_AppFuncRstRst self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepBlend.Handle_BRepBlend_AppFuncRstRst_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_BRepBlend_AppFuncRstRst self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_BRepBlend_AppFuncRstRst self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepBlend.Handle_BRepBlend_AppFuncRstRst_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_BRepBlend_AppFuncRstRst self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _BRepBlend.Handle_BRepBlend_AppFuncRstRst_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_BRepBlend_AppFuncRstRst self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepBlend.Handle_BRepBlend_AppFuncRstRst_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_BRepBlend_AppFuncRstRst self)

        Increments the reference counter of this object


        """
        return _BRepBlend.Handle_BRepBlend_AppFuncRstRst_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_BRepBlend_AppFuncRstRst self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepBlend.Handle_BRepBlend_AppFuncRstRst_DecrementRefCounter(self, *args)

Handle_BRepBlend_AppFuncRstRst_swigregister = _BRepBlend.Handle_BRepBlend_AppFuncRstRst_swigregister
Handle_BRepBlend_AppFuncRstRst_swigregister(Handle_BRepBlend_AppFuncRstRst)

def Handle_BRepBlend_AppFuncRstRst_DownCast(thing):
    return _BRepBlend.Handle_BRepBlend_AppFuncRstRst_DownCast(thing)
Handle_BRepBlend_AppFuncRstRst_DownCast = _BRepBlend.Handle_BRepBlend_AppFuncRstRst_DownCast

class Handle_BRepBlend_AppFuncRst(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_BRepBlend_AppFuncRst self)

        Nullify the handle


        """
        return _BRepBlend.Handle_BRepBlend_AppFuncRst_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_BRepBlend_AppFuncRst self) -> bool

        Check for being null

        :rtype: bool

        """
        return _BRepBlend.Handle_BRepBlend_AppFuncRst_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_BRepBlend_AppFuncRst self, BRepBlend_AppFuncRst thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _BRepBlend.Handle_BRepBlend_AppFuncRst_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_BRepBlend_AppFuncRst self, Handle_BRepBlend_AppFuncRst theHandle) -> Handle_BRepBlend_AppFuncRst
        assign(Handle_BRepBlend_AppFuncRst self, BRepBlend_AppFuncRst thePtr) -> Handle_BRepBlend_AppFuncRst
        assign(Handle_BRepBlend_AppFuncRst self, Handle_BRepBlend_AppFuncRst theHandle) -> Handle_BRepBlend_AppFuncRst

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _BRepBlend.Handle_BRepBlend_AppFuncRst_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_BRepBlend_AppFuncRst self) -> BRepBlend_AppFuncRst

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _BRepBlend.Handle_BRepBlend_AppFuncRst_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_BRepBlend_AppFuncRst self) -> BRepBlend_AppFuncRst

        Member access operator (note non-const)

        :rtype: T *

        """
        return _BRepBlend.Handle_BRepBlend_AppFuncRst___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_BRepBlend_AppFuncRst self) -> BRepBlend_AppFuncRst

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _BRepBlend.Handle_BRepBlend_AppFuncRst___ref__(self, *args)


    def __hash__(self):
        return _BRepBlend.Handle_BRepBlend_AppFuncRst___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _BRepBlend.Handle_BRepBlend_AppFuncRst___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _BRepBlend.new_Handle_BRepBlend_AppFuncRst(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_BRepBlend.Handle_BRepBlend_AppFuncRst_DownCast)
    __swig_destroy__ = _BRepBlend.delete_Handle_BRepBlend_AppFuncRst

    def Point(self, *args):
        """
        Point(Handle_BRepBlend_AppFuncRst self, Blend_AppFunction Func, Standard_Real const Param, math_Vector Sol, Blend_Point Pnt)

        :type Func: OCC.wrapper.Blend.Blend_AppFunction
        :type Param: float
        :type Sol: OCC.wrapper.math.math_Vector
        :type Pnt: OCC.wrapper.Blend.Blend_Point

        """
        return _BRepBlend.Handle_BRepBlend_AppFuncRst_Point(self, *args)


    def Vec(self, *args):
        """
        Vec(Handle_BRepBlend_AppFuncRst self, math_Vector Sol, Blend_Point Pnt)

        :type Sol: OCC.wrapper.math.math_Vector
        :type Pnt: OCC.wrapper.Blend.Blend_Point

        """
        return _BRepBlend.Handle_BRepBlend_AppFuncRst_Vec(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_BRepBlend_AppFuncRst self) -> char const *

        :rtype: const char *

        """
        return _BRepBlend.Handle_BRepBlend_AppFuncRst_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _BRepBlend.Handle_BRepBlend_AppFuncRst_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _BRepBlend.Handle_BRepBlend_AppFuncRst_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def D0(self, *args):
        """
        D0(Handle_BRepBlend_AppFuncRst self, Standard_Real const Param, Standard_Real const First, Standard_Real const Last, NCollection_Array1_gp_Pnt Poles, NCollection_Array1_gp_Pnt2d Poles2d, NCollection_Array1_Standard_Real Weigths) -> Standard_Boolean

        compute the section for v = param

        :type Param: float
        :type First: float
        :type Last: float
        :type Poles: OCC.wrapper.TColgp.TColgp_Array1OfPnt
        :type Poles2d: OCC.wrapper.TColgp.TColgp_Array1OfPnt2d
        :type Weigths: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepBlend.Handle_BRepBlend_AppFuncRst_D0(self, *args)


    def D1(self, *args):
        """
        D1(Handle_BRepBlend_AppFuncRst self, Standard_Real const Param, Standard_Real const First, Standard_Real const Last, NCollection_Array1_gp_Pnt Poles, NCollection_Array1_gp_Vec DPoles, NCollection_Array1_gp_Pnt2d Poles2d, NCollection_Array1_gp_Vec2d DPoles2d, NCollection_Array1_Standard_Real Weigths, NCollection_Array1_Standard_Real DWeigths) -> Standard_Boolean

        compute the first  derivative in v direction  of the
        section for v =  param

        :type Param: float
        :type First: float
        :type Last: float
        :type Poles: OCC.wrapper.TColgp.TColgp_Array1OfPnt
        :type DPoles: OCC.wrapper.TColgp.TColgp_Array1OfVec
        :type Poles2d: OCC.wrapper.TColgp.TColgp_Array1OfPnt2d
        :type DPoles2d: OCC.wrapper.TColgp.TColgp_Array1OfVec2d
        :type Weigths: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type DWeigths: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepBlend.Handle_BRepBlend_AppFuncRst_D1(self, *args)


    def D2(self, *args):
        """
        D2(Handle_BRepBlend_AppFuncRst self, Standard_Real const Param, Standard_Real const First, Standard_Real const Last, NCollection_Array1_gp_Pnt Poles, NCollection_Array1_gp_Vec DPoles, NCollection_Array1_gp_Vec D2Poles, NCollection_Array1_gp_Pnt2d Poles2d, NCollection_Array1_gp_Vec2d DPoles2d, NCollection_Array1_gp_Vec2d D2Poles2d, NCollection_Array1_Standard_Real Weigths, NCollection_Array1_Standard_Real DWeigths, NCollection_Array1_Standard_Real D2Weigths) -> Standard_Boolean

        compute the second derivative  in v direction of the
        section  for v = param

        :type Param: float
        :type First: float
        :type Last: float
        :type Poles: OCC.wrapper.TColgp.TColgp_Array1OfPnt
        :type DPoles: OCC.wrapper.TColgp.TColgp_Array1OfVec
        :type D2Poles: OCC.wrapper.TColgp.TColgp_Array1OfVec
        :type Poles2d: OCC.wrapper.TColgp.TColgp_Array1OfPnt2d
        :type DPoles2d: OCC.wrapper.TColgp.TColgp_Array1OfVec2d
        :type D2Poles2d: OCC.wrapper.TColgp.TColgp_Array1OfVec2d
        :type Weigths: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type DWeigths: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type D2Weigths: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepBlend.Handle_BRepBlend_AppFuncRst_D2(self, *args)


    def Nb2dCurves(self, *args):
        """
        Nb2dCurves(Handle_BRepBlend_AppFuncRst self) -> Standard_Integer

        get the number of 2d curves to  approximate.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepBlend.Handle_BRepBlend_AppFuncRst_Nb2dCurves(self, *args)


    def SectionShape(self, *args):
        """
        SectionShape(Handle_BRepBlend_AppFuncRst self)

        get the format of an  section

        :type NbPoles: int
        :type NbKnots: int
        :type Degree: int

        """
        return _BRepBlend.Handle_BRepBlend_AppFuncRst_SectionShape(self, *args)


    def Knots(self, *args):
        """
        Knots(Handle_BRepBlend_AppFuncRst self, NCollection_Array1_Standard_Real TKnots)

        get the Knots of the section

        :type TKnots: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        return _BRepBlend.Handle_BRepBlend_AppFuncRst_Knots(self, *args)


    def Mults(self, *args):
        """
        Mults(Handle_BRepBlend_AppFuncRst self, NCollection_Array1_Standard_Integer TMults)

        get the Multplicities of the section

        :type TMults: OCC.wrapper.TColStd.TColStd_Array1OfInteger

        """
        return _BRepBlend.Handle_BRepBlend_AppFuncRst_Mults(self, *args)


    def IsRational(self, *args):
        """
        IsRational(Handle_BRepBlend_AppFuncRst self) -> Standard_Boolean

        Returns if the section is rationnal or not

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepBlend.Handle_BRepBlend_AppFuncRst_IsRational(self, *args)


    def NbIntervals(self, *args):
        """
        NbIntervals(Handle_BRepBlend_AppFuncRst self, GeomAbs_Shape const S) -> Standard_Integer

        Returns  the number  of  intervals for  continuity
        <S>. May be one if Continuity(me) >= <S>

        :type S: OCC.wrapper.GeomAbs.GeomAbs_Shape
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepBlend.Handle_BRepBlend_AppFuncRst_NbIntervals(self, *args)


    def Intervals(self, *args):
        """
        Intervals(Handle_BRepBlend_AppFuncRst self, NCollection_Array1_Standard_Real T, GeomAbs_Shape const S)

        Stores in <T> the  parameters bounding the intervals
        of continuity <S>.

        The array must provide  enough room to  accomodate
        for the parameters. i.e. T.Length() > NbIntervals()

        :type T: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type S: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _BRepBlend.Handle_BRepBlend_AppFuncRst_Intervals(self, *args)


    def SetInterval(self, *args):
        """
        SetInterval(Handle_BRepBlend_AppFuncRst self, Standard_Real const First, Standard_Real const Last)

        Sets the bounds of the parametric interval on
        the fonction
        This determines the derivatives in these values if the
        function is not Cn.

        :type First: float
        :type Last: float

        """
        return _BRepBlend.Handle_BRepBlend_AppFuncRst_SetInterval(self, *args)


    def Resolution(self, *args):
        """
        Resolution(Handle_BRepBlend_AppFuncRst self, Standard_Integer const Index, Standard_Real const Tol)

        Returns the resolutions in the  sub-space 2d <Index> --
        This information is usfull to find an good tolerance in
        2d approximation

        :type Index: int
        :type Tol: float
        :type TolU: float
        :type TolV: float

        """
        return _BRepBlend.Handle_BRepBlend_AppFuncRst_Resolution(self, *args)


    def GetTolerance(self, *args):
        """
        GetTolerance(Handle_BRepBlend_AppFuncRst self, Standard_Real const BoundTol, Standard_Real const SurfTol, Standard_Real const AngleTol, NCollection_Array1_Standard_Real Tol3d)

        Returns the tolerance to reach in approximation
        to respecte
        BoundTol error at the Boundary
        AngleTol tangent error at the Boundary (in radian)
        SurfTol error inside the surface.

        :type BoundTol: float
        :type SurfTol: float
        :type AngleTol: float
        :type Tol3d: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        return _BRepBlend.Handle_BRepBlend_AppFuncRst_GetTolerance(self, *args)


    def SetTolerance(self, *args):
        """
        SetTolerance(Handle_BRepBlend_AppFuncRst self, Standard_Real const Tol3d, Standard_Real const Tol2d)

        Is usfull, if (me) have to  be run numerical
        algorithme to perform D0, D1 or D2

        :type Tol3d: float
        :type Tol2d: float

        """
        return _BRepBlend.Handle_BRepBlend_AppFuncRst_SetTolerance(self, *args)


    def BarycentreOfSurf(self, *args):
        """
        BarycentreOfSurf(Handle_BRepBlend_AppFuncRst self) -> gp_Pnt

        Get    the   barycentre of   Surface.   An   very  poor
        estimation is sufficent. This information is usefull
        to perform well conditionned rational approximation.

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _BRepBlend.Handle_BRepBlend_AppFuncRst_BarycentreOfSurf(self, *args)


    def MaximalSection(self, *args):
        """
        MaximalSection(Handle_BRepBlend_AppFuncRst self) -> Standard_Real

        Returns the   length of the maximum section. This
        information is usefull to perform well conditionned rational
        approximation.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _BRepBlend.Handle_BRepBlend_AppFuncRst_MaximalSection(self, *args)


    def GetMinimalWeight(self, *args):
        """
        GetMinimalWeight(Handle_BRepBlend_AppFuncRst self, NCollection_Array1_Standard_Real Weigths)

        Compute the minimal value of weight for each poles
        of all  sections.  This information is  usefull to
        perform well conditionned rational approximation.

        :type Weigths: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        return _BRepBlend.Handle_BRepBlend_AppFuncRst_GetMinimalWeight(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_BRepBlend_AppFuncRst self)

        Memory deallocator for transient classes


        """
        return _BRepBlend.Handle_BRepBlend_AppFuncRst_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_BRepBlend_AppFuncRst self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_BRepBlend_AppFuncRst self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepBlend.Handle_BRepBlend_AppFuncRst_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_BRepBlend_AppFuncRst self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_BRepBlend_AppFuncRst self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepBlend.Handle_BRepBlend_AppFuncRst_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_BRepBlend_AppFuncRst self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _BRepBlend.Handle_BRepBlend_AppFuncRst_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_BRepBlend_AppFuncRst self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepBlend.Handle_BRepBlend_AppFuncRst_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_BRepBlend_AppFuncRst self)

        Increments the reference counter of this object


        """
        return _BRepBlend.Handle_BRepBlend_AppFuncRst_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_BRepBlend_AppFuncRst self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepBlend.Handle_BRepBlend_AppFuncRst_DecrementRefCounter(self, *args)

Handle_BRepBlend_AppFuncRst_swigregister = _BRepBlend.Handle_BRepBlend_AppFuncRst_swigregister
Handle_BRepBlend_AppFuncRst_swigregister(Handle_BRepBlend_AppFuncRst)

def Handle_BRepBlend_AppFuncRst_DownCast(thing):
    return _BRepBlend.Handle_BRepBlend_AppFuncRst_DownCast(thing)
Handle_BRepBlend_AppFuncRst_DownCast = _BRepBlend.Handle_BRepBlend_AppFuncRst_DownCast

class NCollection_Sequence_BRepBlend_PointOnRst(NCollection.NCollection_BaseSequence):
    """
    Purpose:     Definition of a sequence of elements indexed by
    an Integer in range of 1..n
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Sequence_BRepBlend_PointOnRst self) -> NCollection_Sequence< BRepBlend_PointOnRst >::iterator

        Returns an iterator pointing to the first element in the sequence.

        :rtype: iterator

        """
        return _BRepBlend.NCollection_Sequence_BRepBlend_PointOnRst_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Sequence_BRepBlend_PointOnRst self) -> NCollection_Sequence< BRepBlend_PointOnRst >::iterator

        Returns an iterator referring to the past-the-end element in the sequence.

        :rtype: iterator

        """
        return _BRepBlend.NCollection_Sequence_BRepBlend_PointOnRst_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Sequence_BRepBlend_PointOnRst self) -> NCollection_Sequence< BRepBlend_PointOnRst >::const_iterator

        Returns a const iterator pointing to the first element in the sequence.

        :rtype: const_iterator

        """
        return _BRepBlend.NCollection_Sequence_BRepBlend_PointOnRst_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Sequence_BRepBlend_PointOnRst self) -> NCollection_Sequence< BRepBlend_PointOnRst >::const_iterator

        Returns a const iterator referring to the past-the-end element in the sequence.

        :rtype: const_iterator

        """
        return _BRepBlend.NCollection_Sequence_BRepBlend_PointOnRst_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     Definition of a sequence of elements indexed by
        an Integer in range of 1..n
        """
        this = _BRepBlend.new_NCollection_Sequence_BRepBlend_PointOnRst(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Size(self, *args):
        """
        Size(NCollection_Sequence_BRepBlend_PointOnRst self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepBlend.NCollection_Sequence_BRepBlend_PointOnRst_Size(self, *args)


    def Length(self, *args):
        """
        Length(NCollection_Sequence_BRepBlend_PointOnRst self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepBlend.NCollection_Sequence_BRepBlend_PointOnRst_Length(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Sequence_BRepBlend_PointOnRst self) -> Standard_Integer

        Method for consistency with other collections.
        @return Lower bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepBlend.NCollection_Sequence_BRepBlend_PointOnRst_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Sequence_BRepBlend_PointOnRst self) -> Standard_Integer

        Method for consistency with other collections.
        @return Upper bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepBlend.NCollection_Sequence_BRepBlend_PointOnRst_Upper(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Sequence_BRepBlend_PointOnRst self) -> Standard_Boolean

        Empty query

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepBlend.NCollection_Sequence_BRepBlend_PointOnRst_IsEmpty(self, *args)


    def Reverse(self, *args):
        """
        Reverse(NCollection_Sequence_BRepBlend_PointOnRst self)

        Reverse sequence


        """
        return _BRepBlend.NCollection_Sequence_BRepBlend_PointOnRst_Reverse(self, *args)


    def Exchange(self, *args):
        """
        Exchange(NCollection_Sequence_BRepBlend_PointOnRst self, Standard_Integer const I, Standard_Integer const J)

        Exchange two members

        :type I: int
        :type J: int

        """
        return _BRepBlend.NCollection_Sequence_BRepBlend_PointOnRst_Exchange(self, *args)


    def delNode(*args):
        """
        delNode(NCollection_SeqNode theNode, Handle_NCollection_BaseAllocator theAl)

        Static deleter to be passed to BaseSequence

        :type theNode: OCC.wrapper.NCollection.NCollection_SeqNode
        :type theAl: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _BRepBlend.NCollection_Sequence_BRepBlend_PointOnRst_delNode(*args)

    delNode = staticmethod(delNode)

    def Clear(self, *args):
        """
        Clear(NCollection_Sequence_BRepBlend_PointOnRst self, Handle_NCollection_BaseAllocator theAllocator=0)

        Clear the items out, take a new allocator if non null

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _BRepBlend.NCollection_Sequence_BRepBlend_PointOnRst_Clear(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Sequence_BRepBlend_PointOnRst self, NCollection_Sequence_BRepBlend_PointOnRst theOther) -> NCollection_Sequence_BRepBlend_PointOnRst

        Replace this sequence by the items of theOther.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_Sequence
        :rtype: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _BRepBlend.NCollection_Sequence_BRepBlend_PointOnRst_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Sequence_BRepBlend_PointOnRst self, NCollection_Sequence_BRepBlend_PointOnRst theOther) -> NCollection_Sequence_BRepBlend_PointOnRst

        Replacement operator

        :type theOther: OCC.wrapper.NCollection.NCollection_Sequence
        :rtype: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _BRepBlend.NCollection_Sequence_BRepBlend_PointOnRst_assign(self, *args)


    def Remove(self, *args):
        """
        Remove(NCollection_Sequence_BRepBlend_PointOnRst self, NCollection_Sequence< BRepBlend_PointOnRst >::Iterator & thePosition)
        Remove(NCollection_Sequence_BRepBlend_PointOnRst self, Standard_Integer const theIndex)
        Remove(NCollection_Sequence_BRepBlend_PointOnRst self, Standard_Integer const theFromIndex, Standard_Integer const theToIndex)

        Remove range of items

        :type theFromIndex: int
        :type theToIndex: int

        """
        return _BRepBlend.NCollection_Sequence_BRepBlend_PointOnRst_Remove(self, *args)


    def Append(self, *args):
        """
        Append(NCollection_Sequence_BRepBlend_PointOnRst self, BRepBlend_PointOnRst theItem)
        Append(NCollection_Sequence_BRepBlend_PointOnRst self, NCollection_Sequence_BRepBlend_PointOnRst theSeq)

        Append another sequence (making it empty)

        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _BRepBlend.NCollection_Sequence_BRepBlend_PointOnRst_Append(self, *args)


    def Prepend(self, *args):
        """
        Prepend(NCollection_Sequence_BRepBlend_PointOnRst self, BRepBlend_PointOnRst theItem)
        Prepend(NCollection_Sequence_BRepBlend_PointOnRst self, NCollection_Sequence_BRepBlend_PointOnRst theSeq)

        Prepend another sequence (making it empty)

        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _BRepBlend.NCollection_Sequence_BRepBlend_PointOnRst_Prepend(self, *args)


    def InsertBefore(self, *args):
        """
        InsertBefore(NCollection_Sequence_BRepBlend_PointOnRst self, Standard_Integer const theIndex, BRepBlend_PointOnRst theItem)
        InsertBefore(NCollection_Sequence_BRepBlend_PointOnRst self, Standard_Integer const theIndex, NCollection_Sequence_BRepBlend_PointOnRst theSeq)

        InsertBefore theIndex another sequence

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _BRepBlend.NCollection_Sequence_BRepBlend_PointOnRst_InsertBefore(self, *args)


    def InsertAfter(self, *args):
        """
        InsertAfter(NCollection_Sequence_BRepBlend_PointOnRst self, NCollection_Sequence< BRepBlend_PointOnRst >::Iterator & thePosition, BRepBlend_PointOnRst theItem)
        InsertAfter(NCollection_Sequence_BRepBlend_PointOnRst self, Standard_Integer const theIndex, NCollection_Sequence_BRepBlend_PointOnRst theSeq)
        InsertAfter(NCollection_Sequence_BRepBlend_PointOnRst self, Standard_Integer const theIndex, BRepBlend_PointOnRst theItem)

        InsertAfter theIndex another sequence

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _BRepBlend.NCollection_Sequence_BRepBlend_PointOnRst_InsertAfter(self, *args)


    def Split(self, *args):
        """
        Split(NCollection_Sequence_BRepBlend_PointOnRst self, Standard_Integer const theIndex, NCollection_Sequence_BRepBlend_PointOnRst theSeq)

        Split in two sequences

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _BRepBlend.NCollection_Sequence_BRepBlend_PointOnRst_Split(self, *args)


    def First(self, *args):
        """
        First item access

        :rtype: const TheItemType &

        """
        res = _BRepBlend.NCollection_Sequence_BRepBlend_PointOnRst_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Sequence_BRepBlend_PointOnRst self) -> BRepBlend_PointOnRst

        First item access

        :rtype: TheItemType &

        """
        return _BRepBlend.NCollection_Sequence_BRepBlend_PointOnRst_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        Last item access

        :rtype: const TheItemType &

        """
        res = _BRepBlend.NCollection_Sequence_BRepBlend_PointOnRst_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Sequence_BRepBlend_PointOnRst self) -> BRepBlend_PointOnRst

        Last item access

        :rtype: TheItemType &

        """
        return _BRepBlend.NCollection_Sequence_BRepBlend_PointOnRst_ChangeLast(self, *args)


    def Value(self, *args):
        """
        Constant item access by theIndex

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _BRepBlend.NCollection_Sequence_BRepBlend_PointOnRst_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Sequence_BRepBlend_PointOnRst self, Standard_Integer const theIndex) -> BRepBlend_PointOnRst

        Variable item access by theIndex

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _BRepBlend.NCollection_Sequence_BRepBlend_PointOnRst_ChangeValue(self, *args)


    def __call__(self, *args):
        """
        Constant operator()

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _BRepBlend.NCollection_Sequence_BRepBlend_PointOnRst___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetValue(self, *args):
        """
        SetValue(NCollection_Sequence_BRepBlend_PointOnRst self, Standard_Integer const theIndex, BRepBlend_PointOnRst theItem)

        Set item value by theIndex

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _BRepBlend.NCollection_Sequence_BRepBlend_PointOnRst_SetValue(self, *args)


    def __iter__(self):
        return _BRepBlend.NCollection_Sequence_BRepBlend_PointOnRst___iter__(self)
    __swig_destroy__ = _BRepBlend.delete_NCollection_Sequence_BRepBlend_PointOnRst
NCollection_Sequence_BRepBlend_PointOnRst_swigregister = _BRepBlend.NCollection_Sequence_BRepBlend_PointOnRst_swigregister
NCollection_Sequence_BRepBlend_PointOnRst_swigregister(NCollection_Sequence_BRepBlend_PointOnRst)

def NCollection_Sequence_BRepBlend_PointOnRst_delNode(*args):
    """
    NCollection_Sequence_BRepBlend_PointOnRst_delNode(NCollection_SeqNode theNode, Handle_NCollection_BaseAllocator theAl)

    Static deleter to be passed to BaseSequence

    :type theNode: OCC.wrapper.NCollection.NCollection_SeqNode
    :type theAl: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

    """
    return _BRepBlend.NCollection_Sequence_BRepBlend_PointOnRst_delNode(*args)

class NCollection_Sequence_BRepBlend_PointOnRst_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _BRepBlend.new_NCollection_Sequence_BRepBlend_PointOnRst_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _BRepBlend.delete_NCollection_Sequence_BRepBlend_PointOnRst_IteratorHelper

    def __next__(self):
        return _BRepBlend.NCollection_Sequence_BRepBlend_PointOnRst_IteratorHelper___next__(self)
NCollection_Sequence_BRepBlend_PointOnRst_IteratorHelper_swigregister = _BRepBlend.NCollection_Sequence_BRepBlend_PointOnRst_IteratorHelper_swigregister
NCollection_Sequence_BRepBlend_PointOnRst_IteratorHelper_swigregister(NCollection_Sequence_BRepBlend_PointOnRst_IteratorHelper)


try:
	BRepBlend_SequenceOfPointOnRst = NCollection_Sequence_BRepBlend_PointOnRst
except NameError:
	pass # does not exist, probably ignored

class BRepBlend_Walking(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BRepBlend_Walking self, Handle_Adaptor3d_HSurface Surf1, Handle_Adaptor3d_HSurface Surf2, Handle_Adaptor3d_TopolTool Domain1, Handle_Adaptor3d_TopolTool Domain2, Handle_ChFiDS_HElSpine HGuide) -> BRepBlend_Walking

        :type Surf1: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface
        :type Surf2: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface
        :type Domain1: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_TopolTool
        :type Domain2: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_TopolTool
        :type HGuide: OCC.wrapper.ChFiDS.Handle_ChFiDS_HElSpine

        """
        this = _BRepBlend.new_BRepBlend_Walking(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def SetDomainsToRecadre(self, *args):
        """
        SetDomainsToRecadre(BRepBlend_Walking self, Handle_Adaptor3d_TopolTool RecDomain1, Handle_Adaptor3d_TopolTool RecDomain2)

        To define different domains for control and clipping.

        :type RecDomain1: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_TopolTool
        :type RecDomain2: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_TopolTool

        """
        return _BRepBlend.BRepBlend_Walking_SetDomainsToRecadre(self, *args)


    def AddSingularPoint(self, *args):
        """
        AddSingularPoint(BRepBlend_Walking self, Blend_Point P)

        To define singular points computed before walking.

        :type P: OCC.wrapper.Blend.Blend_Point

        """
        return _BRepBlend.BRepBlend_Walking_AddSingularPoint(self, *args)


    def Perform(self, *args):
        """
        Perform(BRepBlend_Walking self, Blend_Function F, Blend_FuncInv FInv, Standard_Real const Pdep, Standard_Real const Pmax, Standard_Real const MaxStep, Standard_Real const TolGuide, math_Vector Soldep, Standard_Real const Tolesp, Standard_Real const Fleche, Standard_Boolean const Appro)

        :type F: OCC.wrapper.Blend.Blend_Function
        :type FInv: OCC.wrapper.Blend.Blend_FuncInv
        :type Pdep: float
        :type Pmax: float
        :type MaxStep: float
        :type TolGuide: float
        :type Soldep: OCC.wrapper.math.math_Vector
        :type Tolesp: float
        :type Fleche: float
        :type Appro: bool

        """
        return _BRepBlend.BRepBlend_Walking_Perform(self, *args)


    def PerformFirstSection(self, *args):
        """
        PerformFirstSection(BRepBlend_Walking self, Blend_Function F, Standard_Real const Pdep, math_Vector ParDep, Standard_Real const Tolesp, Standard_Real const TolGuide) -> Standard_Boolean
        PerformFirstSection(BRepBlend_Walking self, Blend_Function F, Blend_FuncInv FInv, Standard_Real const Pdep, Standard_Real const Pmax, math_Vector ParDep, Standard_Real const Tolesp, Standard_Real const TolGuide, Standard_Boolean const RecOnS1, Standard_Boolean const RecOnS2, math_Vector ParSol) -> Standard_Boolean

        :type F: OCC.wrapper.Blend.Blend_Function
        :type FInv: OCC.wrapper.Blend.Blend_FuncInv
        :type Pdep: float
        :type Pmax: float
        :type ParDep: OCC.wrapper.math.math_Vector
        :type Tolesp: float
        :type TolGuide: float
        :type RecOnS1: bool
        :type RecOnS2: bool
        :type Psol: float
        :type ParSol: OCC.wrapper.math.math_Vector
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepBlend.BRepBlend_Walking_PerformFirstSection(self, *args)


    def Continu(self, *args):
        """
        Continu(BRepBlend_Walking self, Blend_Function F, Blend_FuncInv FInv, Standard_Real const P) -> Standard_Boolean
        Continu(BRepBlend_Walking self, Blend_Function F, Blend_FuncInv FInv, Standard_Real const P, Standard_Boolean const OnS1) -> Standard_Boolean

        :type F: OCC.wrapper.Blend.Blend_Function
        :type FInv: OCC.wrapper.Blend.Blend_FuncInv
        :type P: float
        :type OnS1: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepBlend.BRepBlend_Walking_Continu(self, *args)


    def Complete(self, *args):
        """
        Complete(BRepBlend_Walking self, Blend_Function F, Blend_FuncInv FInv, Standard_Real const Pmin) -> Standard_Boolean

        :type F: OCC.wrapper.Blend.Blend_Function
        :type FInv: OCC.wrapper.Blend.Blend_FuncInv
        :type Pmin: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepBlend.BRepBlend_Walking_Complete(self, *args)


    def ClassificationOnS1(self, *args):
        """
        ClassificationOnS1(BRepBlend_Walking self, Standard_Boolean const C)

        :type C: bool

        """
        return _BRepBlend.BRepBlend_Walking_ClassificationOnS1(self, *args)


    def ClassificationOnS2(self, *args):
        """
        ClassificationOnS2(BRepBlend_Walking self, Standard_Boolean const C)

        :type C: bool

        """
        return _BRepBlend.BRepBlend_Walking_ClassificationOnS2(self, *args)


    def Check2d(self, *args):
        """
        Check2d(BRepBlend_Walking self, Standard_Boolean const C)

        :type C: bool

        """
        return _BRepBlend.BRepBlend_Walking_Check2d(self, *args)


    def Check(self, *args):
        """
        Check(BRepBlend_Walking self, Standard_Boolean const C)

        :type C: bool

        """
        return _BRepBlend.BRepBlend_Walking_Check(self, *args)


    def TwistOnS1(self, *args):
        """
        TwistOnS1(BRepBlend_Walking self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepBlend.BRepBlend_Walking_TwistOnS1(self, *args)


    def TwistOnS2(self, *args):
        """
        TwistOnS2(BRepBlend_Walking self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepBlend.BRepBlend_Walking_TwistOnS2(self, *args)


    def IsDone(self, *args):
        """
        IsDone(BRepBlend_Walking self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepBlend.BRepBlend_Walking_IsDone(self, *args)


    def Line(self, *args):
        """
        :rtype: OCC.wrapper.BRepBlend.Handle_BRepBlend_Line

        """
        res = _BRepBlend.BRepBlend_Walking_Line(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _BRepBlend.delete_BRepBlend_Walking
BRepBlend_Walking_swigregister = _BRepBlend.BRepBlend_Walking_swigregister
BRepBlend_Walking_swigregister(BRepBlend_Walking)

class BRepBlend_SurfPointEvolRadInv(Blend.Blend_SurfPointFuncInv):
    """
    Function of reframing between a point and a surface.
    This function  is used  to find a  solution on  a done
    point   of   the curve when   using  SurfRstConsRad or
    CSConstRad...
    The vector <X>  used in Value, Values and  Derivatives
    methods  has  to   be the  vector   of the  parametric
    coordinates w, U,  V where w is  the parameter  on the
    guide line, U,V   are the parametric coordinates of  a
    point on the partner surface.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BRepBlend_SurfPointEvolRadInv self, Handle_Adaptor3d_HSurface S, Handle_Adaptor3d_HCurve C, Handle_Law_Function Evol) -> BRepBlend_SurfPointEvolRadInv

        :type S: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface
        :type C: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HCurve
        :type Evol: OCC.wrapper.Law.Handle_Law_Function

        """
        this = _BRepBlend.new_BRepBlend_SurfPointEvolRadInv(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def NbEquations(self, *args):
        """
        NbEquations(BRepBlend_SurfPointEvolRadInv self) -> Standard_Integer

        returns 3.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepBlend.BRepBlend_SurfPointEvolRadInv_NbEquations(self, *args)


    def Value(self, *args):
        """
        Value(BRepBlend_SurfPointEvolRadInv self, math_Vector X, math_Vector F) -> Standard_Boolean

        computes the values <F> of the Functions for the
        variable <X>.
        Returns True if the computation was done successfully,
        False otherwise.

        :type X: OCC.wrapper.math.math_Vector
        :type F: OCC.wrapper.math.math_Vector
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepBlend.BRepBlend_SurfPointEvolRadInv_Value(self, *args)


    def Derivatives(self, *args):
        """
        Derivatives(BRepBlend_SurfPointEvolRadInv self, math_Vector X, math_Matrix D) -> Standard_Boolean

        returns the values <D> of the derivatives for the
        variable <X>.
        Returns True if the computation was done successfully,
        False otherwise.

        :type X: OCC.wrapper.math.math_Vector
        :type D: OCC.wrapper.math.math_Matrix
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepBlend.BRepBlend_SurfPointEvolRadInv_Derivatives(self, *args)


    def Values(self, *args):
        """
        Values(BRepBlend_SurfPointEvolRadInv self, math_Vector X, math_Vector F, math_Matrix D) -> Standard_Boolean

        returns the values <F> of the functions and the derivatives
        <D> for the variable <X>.
        Returns True if the computation was done successfully,
        False otherwise.

        :type X: OCC.wrapper.math.math_Vector
        :type F: OCC.wrapper.math.math_Vector
        :type D: OCC.wrapper.math.math_Matrix
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepBlend.BRepBlend_SurfPointEvolRadInv_Values(self, *args)


    def Set(self, *args):
        """
        Set(BRepBlend_SurfPointEvolRadInv self, Standard_Integer const Choix)
        Set(BRepBlend_SurfPointEvolRadInv self, gp_Pnt P)

        Set the Point on which a solution has to be found.

        :type P: OCC.wrapper.gp.gp_Pnt

        """
        return _BRepBlend.BRepBlend_SurfPointEvolRadInv_Set(self, *args)


    def GetTolerance(self, *args):
        """
        GetTolerance(BRepBlend_SurfPointEvolRadInv self, math_Vector Tolerance, Standard_Real const Tol)

        Returns in the vector Tolerance the parametric tolerance
        for each of the 3 variables;
        Tol is the tolerance used in 3d space.

        :type Tolerance: OCC.wrapper.math.math_Vector
        :type Tol: float

        """
        return _BRepBlend.BRepBlend_SurfPointEvolRadInv_GetTolerance(self, *args)


    def GetBounds(self, *args):
        """
        GetBounds(BRepBlend_SurfPointEvolRadInv self, math_Vector InfBound, math_Vector SupBound)

        Returns in the vector InfBound the lowest values allowed
        for each of the 3 variables.
        Returns in the vector SupBound the greatest values allowed
        for each of the 3 variables.

        :type InfBound: OCC.wrapper.math.math_Vector
        :type SupBound: OCC.wrapper.math.math_Vector

        """
        return _BRepBlend.BRepBlend_SurfPointEvolRadInv_GetBounds(self, *args)


    def IsSolution(self, *args):
        """
        IsSolution(BRepBlend_SurfPointEvolRadInv self, math_Vector Sol, Standard_Real const Tol) -> Standard_Boolean

        Returns Standard_True if Sol is a zero of the function.
        Tol is the tolerance used in 3d space.

        :type Sol: OCC.wrapper.math.math_Vector
        :type Tol: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepBlend.BRepBlend_SurfPointEvolRadInv_IsSolution(self, *args)

    __swig_destroy__ = _BRepBlend.delete_BRepBlend_SurfPointEvolRadInv
BRepBlend_SurfPointEvolRadInv_swigregister = _BRepBlend.BRepBlend_SurfPointEvolRadInv_swigregister
BRepBlend_SurfPointEvolRadInv_swigregister(BRepBlend_SurfPointEvolRadInv)




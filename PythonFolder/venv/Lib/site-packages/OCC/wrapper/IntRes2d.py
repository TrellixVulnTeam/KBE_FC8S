# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_IntRes2d')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_IntRes2d')
    _IntRes2d = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_IntRes2d', [dirname(__file__)])
        except ImportError:
            import _IntRes2d
            return _IntRes2d
        try:
            _mod = imp.load_module('_IntRes2d', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _IntRes2d = swig_import_helper()
    del swig_import_helper
else:
    import _IntRes2d
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


class SwigPyIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _IntRes2d.delete_SwigPyIterator

    def value(self):
        return _IntRes2d.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _IntRes2d.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _IntRes2d.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _IntRes2d.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _IntRes2d.SwigPyIterator_equal(self, x)

    def copy(self):
        return _IntRes2d.SwigPyIterator_copy(self)

    def next(self):
        return _IntRes2d.SwigPyIterator_next(self)

    def __next__(self):
        return _IntRes2d.SwigPyIterator___next__(self)

    def previous(self):
        return _IntRes2d.SwigPyIterator_previous(self)

    def advance(self, n):
        return _IntRes2d.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _IntRes2d.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _IntRes2d.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _IntRes2d.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _IntRes2d.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _IntRes2d.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _IntRes2d.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self
SwigPyIterator_swigregister = _IntRes2d.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

class NCollection_CellFilter_InspectorXYZ(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _IntRes2d.NCollection_CellFilter_InspectorXYZ_Dimension
    Coord = staticmethod(_IntRes2d.NCollection_CellFilter_InspectorXYZ_Coord)

    def Shift(self, thePnt, theTol):
        return _IntRes2d.NCollection_CellFilter_InspectorXYZ_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _IntRes2d.new_NCollection_CellFilter_InspectorXYZ()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _IntRes2d.delete_NCollection_CellFilter_InspectorXYZ
NCollection_CellFilter_InspectorXYZ_swigregister = _IntRes2d.NCollection_CellFilter_InspectorXYZ_swigregister
NCollection_CellFilter_InspectorXYZ_swigregister(NCollection_CellFilter_InspectorXYZ)

def NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt):
    return _IntRes2d.NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt)
NCollection_CellFilter_InspectorXYZ_Coord = _IntRes2d.NCollection_CellFilter_InspectorXYZ_Coord

class NCollection_CellFilter_InspectorXY(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _IntRes2d.NCollection_CellFilter_InspectorXY_Dimension
    Coord = staticmethod(_IntRes2d.NCollection_CellFilter_InspectorXY_Coord)

    def Shift(self, thePnt, theTol):
        return _IntRes2d.NCollection_CellFilter_InspectorXY_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _IntRes2d.new_NCollection_CellFilter_InspectorXY()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _IntRes2d.delete_NCollection_CellFilter_InspectorXY
NCollection_CellFilter_InspectorXY_swigregister = _IntRes2d.NCollection_CellFilter_InspectorXY_swigregister
NCollection_CellFilter_InspectorXY_swigregister(NCollection_CellFilter_InspectorXY)

def NCollection_CellFilter_InspectorXY_Coord(i, thePnt):
    return _IntRes2d.NCollection_CellFilter_InspectorXY_Coord(i, thePnt)
NCollection_CellFilter_InspectorXY_Coord = _IntRes2d.NCollection_CellFilter_InspectorXY_Coord


def ptr_to_number(item):
    return _IntRes2d.ptr_to_number(item)
ptr_to_number = _IntRes2d.ptr_to_number

def HashCode(*args):
    return _IntRes2d.HashCode(*args)
HashCode = _IntRes2d.HashCode

def ptr_equal(a, b):
    return _IntRes2d.ptr_equal(a, b)
ptr_equal = _IntRes2d.ptr_equal
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Standard
else:
    import Standard
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import NCollection
else:
    import NCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import gp
else:
    import gp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColStd
else:
    import TColStd
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TCollection
else:
    import TCollection
del _swig_python_version_info
IntRes2d_Head = _IntRes2d.IntRes2d_Head
IntRes2d_Middle = _IntRes2d.IntRes2d_Middle
IntRes2d_End = _IntRes2d.IntRes2d_End
IntRes2d_In = _IntRes2d.IntRes2d_In
IntRes2d_Out = _IntRes2d.IntRes2d_Out
IntRes2d_Touch = _IntRes2d.IntRes2d_Touch
IntRes2d_Undecided = _IntRes2d.IntRes2d_Undecided
IntRes2d_Inside = _IntRes2d.IntRes2d_Inside
IntRes2d_Outside = _IntRes2d.IntRes2d_Outside
IntRes2d_Unknown = _IntRes2d.IntRes2d_Unknown
class IntRes2d_IntersectionPoint(object):
    """
    Definition of an intersection point between two
    2D curves.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(IntRes2d_IntersectionPoint self) -> IntRes2d_IntersectionPoint
        __init__(IntRes2d_IntersectionPoint self, gp_Pnt2d P, Standard_Real const Uc1, Standard_Real const Uc2, IntRes2d_Transition Trans1, IntRes2d_Transition Trans2, Standard_Boolean const ReversedFlag) -> IntRes2d_IntersectionPoint

        Creates an IntersectionPoint.
        if ReversedFlag is False, the parameter Uc1(resp. Uc2)
        and the Transition Trans1 (resp. Trans2) refer to
        the first curve (resp. second curve) otherwise Uc1
        and Trans1 (resp. Uc2 and Trans2) refer to the
        second curve (resp. the first curve).

        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type Uc1: float
        :type Uc2: float
        :type Trans1: OCC.wrapper.IntRes2d.IntRes2d_Transition
        :type Trans2: OCC.wrapper.IntRes2d.IntRes2d_Transition
        :type ReversedFlag: bool

        """
        this = _IntRes2d.new_IntRes2d_IntersectionPoint(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def SetValues(self, *args):
        """
        SetValues(IntRes2d_IntersectionPoint self, gp_Pnt2d P, Standard_Real const Uc1, Standard_Real const Uc2, IntRes2d_Transition Trans1, IntRes2d_Transition Trans2, Standard_Boolean const ReversedFlag)

        Sets the values for an existing intersection
        point. The meaning of the parameters are the same
        as for the Create.

        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type Uc1: float
        :type Uc2: float
        :type Trans1: OCC.wrapper.IntRes2d.IntRes2d_Transition
        :type Trans2: OCC.wrapper.IntRes2d.IntRes2d_Transition
        :type ReversedFlag: bool

        """
        return _IntRes2d.IntRes2d_IntersectionPoint_SetValues(self, *args)


    def Value(self, *args):
        """
        Returns the value of the coordinates of the
        intersection point in the 2D space.

        :rtype: OCC.wrapper.gp.gp_Pnt2d

        """
        res = _IntRes2d.IntRes2d_IntersectionPoint_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ParamOnFirst(self, *args):
        """
        ParamOnFirst(IntRes2d_IntersectionPoint self) -> Standard_Real

        Returns the parameter on the first curve.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _IntRes2d.IntRes2d_IntersectionPoint_ParamOnFirst(self, *args)


    def ParamOnSecond(self, *args):
        """
        ParamOnSecond(IntRes2d_IntersectionPoint self) -> Standard_Real

        Returns the parameter on the second curve.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _IntRes2d.IntRes2d_IntersectionPoint_ParamOnSecond(self, *args)


    def TransitionOfFirst(self, *args):
        """
        Returns the transition of the 1st curve compared to
        the 2nd one.

        :rtype: OCC.wrapper.IntRes2d.IntRes2d_Transition

        """
        res = _IntRes2d.IntRes2d_IntersectionPoint_TransitionOfFirst(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def TransitionOfSecond(self, *args):
        """
        returns the transition of the 2nd curve compared to
        the 1st one.

        :rtype: OCC.wrapper.IntRes2d.IntRes2d_Transition

        """
        res = _IntRes2d.IntRes2d_IntersectionPoint_TransitionOfSecond(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _IntRes2d.delete_IntRes2d_IntersectionPoint
IntRes2d_IntersectionPoint_swigregister = _IntRes2d.IntRes2d_IntersectionPoint_swigregister
IntRes2d_IntersectionPoint_swigregister(IntRes2d_IntersectionPoint)

class NCollection_Sequence_IntRes2d_IntersectionPoint(NCollection.NCollection_BaseSequence):
    """
    Purpose:     Definition of a sequence of elements indexed by
    an Integer in range of 1..n
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Sequence_IntRes2d_IntersectionPoint self) -> NCollection_Sequence< IntRes2d_IntersectionPoint >::iterator

        Returns an iterator pointing to the first element in the sequence.

        :rtype: iterator

        """
        return _IntRes2d.NCollection_Sequence_IntRes2d_IntersectionPoint_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Sequence_IntRes2d_IntersectionPoint self) -> NCollection_Sequence< IntRes2d_IntersectionPoint >::iterator

        Returns an iterator referring to the past-the-end element in the sequence.

        :rtype: iterator

        """
        return _IntRes2d.NCollection_Sequence_IntRes2d_IntersectionPoint_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Sequence_IntRes2d_IntersectionPoint self) -> NCollection_Sequence< IntRes2d_IntersectionPoint >::const_iterator

        Returns a const iterator pointing to the first element in the sequence.

        :rtype: const_iterator

        """
        return _IntRes2d.NCollection_Sequence_IntRes2d_IntersectionPoint_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Sequence_IntRes2d_IntersectionPoint self) -> NCollection_Sequence< IntRes2d_IntersectionPoint >::const_iterator

        Returns a const iterator referring to the past-the-end element in the sequence.

        :rtype: const_iterator

        """
        return _IntRes2d.NCollection_Sequence_IntRes2d_IntersectionPoint_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     Definition of a sequence of elements indexed by
        an Integer in range of 1..n
        """
        this = _IntRes2d.new_NCollection_Sequence_IntRes2d_IntersectionPoint(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Size(self, *args):
        """
        Size(NCollection_Sequence_IntRes2d_IntersectionPoint self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntRes2d.NCollection_Sequence_IntRes2d_IntersectionPoint_Size(self, *args)


    def Length(self, *args):
        """
        Length(NCollection_Sequence_IntRes2d_IntersectionPoint self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntRes2d.NCollection_Sequence_IntRes2d_IntersectionPoint_Length(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Sequence_IntRes2d_IntersectionPoint self) -> Standard_Integer

        Method for consistency with other collections.
        @return Lower bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntRes2d.NCollection_Sequence_IntRes2d_IntersectionPoint_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Sequence_IntRes2d_IntersectionPoint self) -> Standard_Integer

        Method for consistency with other collections.
        @return Upper bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntRes2d.NCollection_Sequence_IntRes2d_IntersectionPoint_Upper(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Sequence_IntRes2d_IntersectionPoint self) -> Standard_Boolean

        Empty query

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntRes2d.NCollection_Sequence_IntRes2d_IntersectionPoint_IsEmpty(self, *args)


    def Reverse(self, *args):
        """
        Reverse(NCollection_Sequence_IntRes2d_IntersectionPoint self)

        Reverse sequence


        """
        return _IntRes2d.NCollection_Sequence_IntRes2d_IntersectionPoint_Reverse(self, *args)


    def Exchange(self, *args):
        """
        Exchange(NCollection_Sequence_IntRes2d_IntersectionPoint self, Standard_Integer const I, Standard_Integer const J)

        Exchange two members

        :type I: int
        :type J: int

        """
        return _IntRes2d.NCollection_Sequence_IntRes2d_IntersectionPoint_Exchange(self, *args)


    def delNode(*args):
        """
        delNode(NCollection_SeqNode theNode, Handle_NCollection_BaseAllocator theAl)

        Static deleter to be passed to BaseSequence

        :type theNode: OCC.wrapper.NCollection.NCollection_SeqNode
        :type theAl: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _IntRes2d.NCollection_Sequence_IntRes2d_IntersectionPoint_delNode(*args)

    delNode = staticmethod(delNode)

    def Clear(self, *args):
        """
        Clear(NCollection_Sequence_IntRes2d_IntersectionPoint self, Handle_NCollection_BaseAllocator theAllocator=0)

        Clear the items out, take a new allocator if non null

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _IntRes2d.NCollection_Sequence_IntRes2d_IntersectionPoint_Clear(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Sequence_IntRes2d_IntersectionPoint self, NCollection_Sequence_IntRes2d_IntersectionPoint theOther) -> NCollection_Sequence_IntRes2d_IntersectionPoint

        Replace this sequence by the items of theOther.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_Sequence
        :rtype: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _IntRes2d.NCollection_Sequence_IntRes2d_IntersectionPoint_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Sequence_IntRes2d_IntersectionPoint self, NCollection_Sequence_IntRes2d_IntersectionPoint theOther) -> NCollection_Sequence_IntRes2d_IntersectionPoint

        Replacement operator

        :type theOther: OCC.wrapper.NCollection.NCollection_Sequence
        :rtype: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _IntRes2d.NCollection_Sequence_IntRes2d_IntersectionPoint_assign(self, *args)


    def Remove(self, *args):
        """
        Remove(NCollection_Sequence_IntRes2d_IntersectionPoint self, NCollection_Sequence< IntRes2d_IntersectionPoint >::Iterator & thePosition)
        Remove(NCollection_Sequence_IntRes2d_IntersectionPoint self, Standard_Integer const theIndex)
        Remove(NCollection_Sequence_IntRes2d_IntersectionPoint self, Standard_Integer const theFromIndex, Standard_Integer const theToIndex)

        Remove range of items

        :type theFromIndex: int
        :type theToIndex: int

        """
        return _IntRes2d.NCollection_Sequence_IntRes2d_IntersectionPoint_Remove(self, *args)


    def Append(self, *args):
        """
        Append(NCollection_Sequence_IntRes2d_IntersectionPoint self, IntRes2d_IntersectionPoint theItem)
        Append(NCollection_Sequence_IntRes2d_IntersectionPoint self, NCollection_Sequence_IntRes2d_IntersectionPoint theSeq)

        Append another sequence (making it empty)

        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _IntRes2d.NCollection_Sequence_IntRes2d_IntersectionPoint_Append(self, *args)


    def Prepend(self, *args):
        """
        Prepend(NCollection_Sequence_IntRes2d_IntersectionPoint self, IntRes2d_IntersectionPoint theItem)
        Prepend(NCollection_Sequence_IntRes2d_IntersectionPoint self, NCollection_Sequence_IntRes2d_IntersectionPoint theSeq)

        Prepend another sequence (making it empty)

        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _IntRes2d.NCollection_Sequence_IntRes2d_IntersectionPoint_Prepend(self, *args)


    def InsertBefore(self, *args):
        """
        InsertBefore(NCollection_Sequence_IntRes2d_IntersectionPoint self, Standard_Integer const theIndex, IntRes2d_IntersectionPoint theItem)
        InsertBefore(NCollection_Sequence_IntRes2d_IntersectionPoint self, Standard_Integer const theIndex, NCollection_Sequence_IntRes2d_IntersectionPoint theSeq)

        InsertBefore theIndex another sequence

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _IntRes2d.NCollection_Sequence_IntRes2d_IntersectionPoint_InsertBefore(self, *args)


    def InsertAfter(self, *args):
        """
        InsertAfter(NCollection_Sequence_IntRes2d_IntersectionPoint self, NCollection_Sequence< IntRes2d_IntersectionPoint >::Iterator & thePosition, IntRes2d_IntersectionPoint theItem)
        InsertAfter(NCollection_Sequence_IntRes2d_IntersectionPoint self, Standard_Integer const theIndex, NCollection_Sequence_IntRes2d_IntersectionPoint theSeq)
        InsertAfter(NCollection_Sequence_IntRes2d_IntersectionPoint self, Standard_Integer const theIndex, IntRes2d_IntersectionPoint theItem)

        InsertAfter theIndex another sequence

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _IntRes2d.NCollection_Sequence_IntRes2d_IntersectionPoint_InsertAfter(self, *args)


    def Split(self, *args):
        """
        Split(NCollection_Sequence_IntRes2d_IntersectionPoint self, Standard_Integer const theIndex, NCollection_Sequence_IntRes2d_IntersectionPoint theSeq)

        Split in two sequences

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _IntRes2d.NCollection_Sequence_IntRes2d_IntersectionPoint_Split(self, *args)


    def First(self, *args):
        """
        First item access

        :rtype: const TheItemType &

        """
        res = _IntRes2d.NCollection_Sequence_IntRes2d_IntersectionPoint_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Sequence_IntRes2d_IntersectionPoint self) -> IntRes2d_IntersectionPoint

        First item access

        :rtype: TheItemType &

        """
        return _IntRes2d.NCollection_Sequence_IntRes2d_IntersectionPoint_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        Last item access

        :rtype: const TheItemType &

        """
        res = _IntRes2d.NCollection_Sequence_IntRes2d_IntersectionPoint_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Sequence_IntRes2d_IntersectionPoint self) -> IntRes2d_IntersectionPoint

        Last item access

        :rtype: TheItemType &

        """
        return _IntRes2d.NCollection_Sequence_IntRes2d_IntersectionPoint_ChangeLast(self, *args)


    def Value(self, *args):
        """
        Constant item access by theIndex

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _IntRes2d.NCollection_Sequence_IntRes2d_IntersectionPoint_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Sequence_IntRes2d_IntersectionPoint self, Standard_Integer const theIndex) -> IntRes2d_IntersectionPoint

        Variable item access by theIndex

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _IntRes2d.NCollection_Sequence_IntRes2d_IntersectionPoint_ChangeValue(self, *args)


    def __call__(self, *args):
        """
        Constant operator()

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _IntRes2d.NCollection_Sequence_IntRes2d_IntersectionPoint___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetValue(self, *args):
        """
        SetValue(NCollection_Sequence_IntRes2d_IntersectionPoint self, Standard_Integer const theIndex, IntRes2d_IntersectionPoint theItem)

        Set item value by theIndex

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _IntRes2d.NCollection_Sequence_IntRes2d_IntersectionPoint_SetValue(self, *args)


    def __iter__(self):
        return _IntRes2d.NCollection_Sequence_IntRes2d_IntersectionPoint___iter__(self)
    __swig_destroy__ = _IntRes2d.delete_NCollection_Sequence_IntRes2d_IntersectionPoint
NCollection_Sequence_IntRes2d_IntersectionPoint_swigregister = _IntRes2d.NCollection_Sequence_IntRes2d_IntersectionPoint_swigregister
NCollection_Sequence_IntRes2d_IntersectionPoint_swigregister(NCollection_Sequence_IntRes2d_IntersectionPoint)

def NCollection_Sequence_IntRes2d_IntersectionPoint_delNode(*args):
    """
    NCollection_Sequence_IntRes2d_IntersectionPoint_delNode(NCollection_SeqNode theNode, Handle_NCollection_BaseAllocator theAl)

    Static deleter to be passed to BaseSequence

    :type theNode: OCC.wrapper.NCollection.NCollection_SeqNode
    :type theAl: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

    """
    return _IntRes2d.NCollection_Sequence_IntRes2d_IntersectionPoint_delNode(*args)

class NCollection_Sequence_IntRes2d_IntersectionPoint_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _IntRes2d.new_NCollection_Sequence_IntRes2d_IntersectionPoint_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _IntRes2d.delete_NCollection_Sequence_IntRes2d_IntersectionPoint_IteratorHelper

    def __next__(self):
        return _IntRes2d.NCollection_Sequence_IntRes2d_IntersectionPoint_IteratorHelper___next__(self)
NCollection_Sequence_IntRes2d_IntersectionPoint_IteratorHelper_swigregister = _IntRes2d.NCollection_Sequence_IntRes2d_IntersectionPoint_IteratorHelper_swigregister
NCollection_Sequence_IntRes2d_IntersectionPoint_IteratorHelper_swigregister(NCollection_Sequence_IntRes2d_IntersectionPoint_IteratorHelper)


try:
	IntRes2d_SequenceOfIntersectionPoint = NCollection_Sequence_IntRes2d_IntersectionPoint
except NameError:
	pass # does not exist, probably ignored

class IntRes2d_IntersectionSegment(object):
    """
    Definition of an intersection curve between
    two 2D curves.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(IntRes2d_IntersectionSegment self) -> IntRes2d_IntersectionSegment
        __init__(IntRes2d_IntersectionSegment self, IntRes2d_IntersectionPoint P1, IntRes2d_IntersectionPoint P2, Standard_Boolean const Oppos, Standard_Boolean const ReverseFlag) -> IntRes2d_IntersectionSegment
        __init__(IntRes2d_IntersectionSegment self, IntRes2d_IntersectionPoint P, Standard_Boolean const First, Standard_Boolean const Oppos, Standard_Boolean const ReverseFlag) -> IntRes2d_IntersectionSegment
        __init__(IntRes2d_IntersectionSegment self, Standard_Boolean const Oppos) -> IntRes2d_IntersectionSegment

        Creates an infinite segment of intersection.

        :type Oppos: bool

        """
        this = _IntRes2d.new_IntRes2d_IntersectionSegment(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def IsOpposite(self, *args):
        """
        IsOpposite(IntRes2d_IntersectionSegment self) -> Standard_Boolean

        Returns FALSE if the intersection segment has got
        the same orientation on both curves.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntRes2d.IntRes2d_IntersectionSegment_IsOpposite(self, *args)


    def HasFirstPoint(self, *args):
        """
        HasFirstPoint(IntRes2d_IntersectionSegment self) -> Standard_Boolean

        Returns True if the segment is  limited by a first
        point.   This  point defines  the lowest parameter
        admitted on the first  curve for the  segment.  If
        IsOpposite  returns  False, it  defines the lowest
        parameter on the  second curve, otherwise,  it  is
        the highest parameter on the second curve.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntRes2d.IntRes2d_IntersectionSegment_HasFirstPoint(self, *args)


    def FirstPoint(self, *args):
        """
        Returns the  first point   of the segment    as an
        IntersectionPoint (with    a    transition).   The
        exception  DomainError  is raised if HasFirstPoint
        returns False.

        :rtype: OCC.wrapper.IntRes2d.IntRes2d_IntersectionPoint

        """
        res = _IntRes2d.IntRes2d_IntersectionSegment_FirstPoint(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def HasLastPoint(self, *args):
        """
        HasLastPoint(IntRes2d_IntersectionSegment self) -> Standard_Boolean

        Returns True if the segment  is  limited by a last
        point.  This point  defines  the highest parameter
        admitted on the  first curve for  the segment.  If
        IsOpposite returns  False, it  defines the highest
        parameter on  the  second curve, otherwise, it  is
        the lowest parameter on the second curve.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntRes2d.IntRes2d_IntersectionSegment_HasLastPoint(self, *args)


    def LastPoint(self, *args):
        """
        Returns   the  last point  of the    segment as an
        IntersectionPoint   (with  a    transition).   The
        exception        DomainError     is   raised    if
        HasLastExtremity returns False.

        :rtype: OCC.wrapper.IntRes2d.IntRes2d_IntersectionPoint

        """
        res = _IntRes2d.IntRes2d_IntersectionSegment_LastPoint(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _IntRes2d.delete_IntRes2d_IntersectionSegment
IntRes2d_IntersectionSegment_swigregister = _IntRes2d.IntRes2d_IntersectionSegment_swigregister
IntRes2d_IntersectionSegment_swigregister(IntRes2d_IntersectionSegment)

class NCollection_Sequence_IntRes2d_IntersectionSegment(NCollection.NCollection_BaseSequence):
    """
    Purpose:     Definition of a sequence of elements indexed by
    an Integer in range of 1..n
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Sequence_IntRes2d_IntersectionSegment self) -> NCollection_Sequence< IntRes2d_IntersectionSegment >::iterator

        Returns an iterator pointing to the first element in the sequence.

        :rtype: iterator

        """
        return _IntRes2d.NCollection_Sequence_IntRes2d_IntersectionSegment_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Sequence_IntRes2d_IntersectionSegment self) -> NCollection_Sequence< IntRes2d_IntersectionSegment >::iterator

        Returns an iterator referring to the past-the-end element in the sequence.

        :rtype: iterator

        """
        return _IntRes2d.NCollection_Sequence_IntRes2d_IntersectionSegment_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Sequence_IntRes2d_IntersectionSegment self) -> NCollection_Sequence< IntRes2d_IntersectionSegment >::const_iterator

        Returns a const iterator pointing to the first element in the sequence.

        :rtype: const_iterator

        """
        return _IntRes2d.NCollection_Sequence_IntRes2d_IntersectionSegment_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Sequence_IntRes2d_IntersectionSegment self) -> NCollection_Sequence< IntRes2d_IntersectionSegment >::const_iterator

        Returns a const iterator referring to the past-the-end element in the sequence.

        :rtype: const_iterator

        """
        return _IntRes2d.NCollection_Sequence_IntRes2d_IntersectionSegment_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     Definition of a sequence of elements indexed by
        an Integer in range of 1..n
        """
        this = _IntRes2d.new_NCollection_Sequence_IntRes2d_IntersectionSegment(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Size(self, *args):
        """
        Size(NCollection_Sequence_IntRes2d_IntersectionSegment self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntRes2d.NCollection_Sequence_IntRes2d_IntersectionSegment_Size(self, *args)


    def Length(self, *args):
        """
        Length(NCollection_Sequence_IntRes2d_IntersectionSegment self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntRes2d.NCollection_Sequence_IntRes2d_IntersectionSegment_Length(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Sequence_IntRes2d_IntersectionSegment self) -> Standard_Integer

        Method for consistency with other collections.
        @return Lower bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntRes2d.NCollection_Sequence_IntRes2d_IntersectionSegment_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Sequence_IntRes2d_IntersectionSegment self) -> Standard_Integer

        Method for consistency with other collections.
        @return Upper bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntRes2d.NCollection_Sequence_IntRes2d_IntersectionSegment_Upper(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Sequence_IntRes2d_IntersectionSegment self) -> Standard_Boolean

        Empty query

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntRes2d.NCollection_Sequence_IntRes2d_IntersectionSegment_IsEmpty(self, *args)


    def Reverse(self, *args):
        """
        Reverse(NCollection_Sequence_IntRes2d_IntersectionSegment self)

        Reverse sequence


        """
        return _IntRes2d.NCollection_Sequence_IntRes2d_IntersectionSegment_Reverse(self, *args)


    def Exchange(self, *args):
        """
        Exchange(NCollection_Sequence_IntRes2d_IntersectionSegment self, Standard_Integer const I, Standard_Integer const J)

        Exchange two members

        :type I: int
        :type J: int

        """
        return _IntRes2d.NCollection_Sequence_IntRes2d_IntersectionSegment_Exchange(self, *args)


    def delNode(*args):
        """
        delNode(NCollection_SeqNode theNode, Handle_NCollection_BaseAllocator theAl)

        Static deleter to be passed to BaseSequence

        :type theNode: OCC.wrapper.NCollection.NCollection_SeqNode
        :type theAl: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _IntRes2d.NCollection_Sequence_IntRes2d_IntersectionSegment_delNode(*args)

    delNode = staticmethod(delNode)

    def Clear(self, *args):
        """
        Clear(NCollection_Sequence_IntRes2d_IntersectionSegment self, Handle_NCollection_BaseAllocator theAllocator=0)

        Clear the items out, take a new allocator if non null

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _IntRes2d.NCollection_Sequence_IntRes2d_IntersectionSegment_Clear(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Sequence_IntRes2d_IntersectionSegment self, NCollection_Sequence_IntRes2d_IntersectionSegment theOther) -> NCollection_Sequence_IntRes2d_IntersectionSegment

        Replace this sequence by the items of theOther.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_Sequence
        :rtype: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _IntRes2d.NCollection_Sequence_IntRes2d_IntersectionSegment_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Sequence_IntRes2d_IntersectionSegment self, NCollection_Sequence_IntRes2d_IntersectionSegment theOther) -> NCollection_Sequence_IntRes2d_IntersectionSegment

        Replacement operator

        :type theOther: OCC.wrapper.NCollection.NCollection_Sequence
        :rtype: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _IntRes2d.NCollection_Sequence_IntRes2d_IntersectionSegment_assign(self, *args)


    def Remove(self, *args):
        """
        Remove(NCollection_Sequence_IntRes2d_IntersectionSegment self, NCollection_Sequence< IntRes2d_IntersectionSegment >::Iterator & thePosition)
        Remove(NCollection_Sequence_IntRes2d_IntersectionSegment self, Standard_Integer const theIndex)
        Remove(NCollection_Sequence_IntRes2d_IntersectionSegment self, Standard_Integer const theFromIndex, Standard_Integer const theToIndex)

        Remove range of items

        :type theFromIndex: int
        :type theToIndex: int

        """
        return _IntRes2d.NCollection_Sequence_IntRes2d_IntersectionSegment_Remove(self, *args)


    def Append(self, *args):
        """
        Append(NCollection_Sequence_IntRes2d_IntersectionSegment self, IntRes2d_IntersectionSegment theItem)
        Append(NCollection_Sequence_IntRes2d_IntersectionSegment self, NCollection_Sequence_IntRes2d_IntersectionSegment theSeq)

        Append another sequence (making it empty)

        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _IntRes2d.NCollection_Sequence_IntRes2d_IntersectionSegment_Append(self, *args)


    def Prepend(self, *args):
        """
        Prepend(NCollection_Sequence_IntRes2d_IntersectionSegment self, IntRes2d_IntersectionSegment theItem)
        Prepend(NCollection_Sequence_IntRes2d_IntersectionSegment self, NCollection_Sequence_IntRes2d_IntersectionSegment theSeq)

        Prepend another sequence (making it empty)

        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _IntRes2d.NCollection_Sequence_IntRes2d_IntersectionSegment_Prepend(self, *args)


    def InsertBefore(self, *args):
        """
        InsertBefore(NCollection_Sequence_IntRes2d_IntersectionSegment self, Standard_Integer const theIndex, IntRes2d_IntersectionSegment theItem)
        InsertBefore(NCollection_Sequence_IntRes2d_IntersectionSegment self, Standard_Integer const theIndex, NCollection_Sequence_IntRes2d_IntersectionSegment theSeq)

        InsertBefore theIndex another sequence

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _IntRes2d.NCollection_Sequence_IntRes2d_IntersectionSegment_InsertBefore(self, *args)


    def InsertAfter(self, *args):
        """
        InsertAfter(NCollection_Sequence_IntRes2d_IntersectionSegment self, NCollection_Sequence< IntRes2d_IntersectionSegment >::Iterator & thePosition, IntRes2d_IntersectionSegment theItem)
        InsertAfter(NCollection_Sequence_IntRes2d_IntersectionSegment self, Standard_Integer const theIndex, NCollection_Sequence_IntRes2d_IntersectionSegment theSeq)
        InsertAfter(NCollection_Sequence_IntRes2d_IntersectionSegment self, Standard_Integer const theIndex, IntRes2d_IntersectionSegment theItem)

        InsertAfter theIndex another sequence

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _IntRes2d.NCollection_Sequence_IntRes2d_IntersectionSegment_InsertAfter(self, *args)


    def Split(self, *args):
        """
        Split(NCollection_Sequence_IntRes2d_IntersectionSegment self, Standard_Integer const theIndex, NCollection_Sequence_IntRes2d_IntersectionSegment theSeq)

        Split in two sequences

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _IntRes2d.NCollection_Sequence_IntRes2d_IntersectionSegment_Split(self, *args)


    def First(self, *args):
        """
        First item access

        :rtype: const TheItemType &

        """
        res = _IntRes2d.NCollection_Sequence_IntRes2d_IntersectionSegment_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Sequence_IntRes2d_IntersectionSegment self) -> IntRes2d_IntersectionSegment

        First item access

        :rtype: TheItemType &

        """
        return _IntRes2d.NCollection_Sequence_IntRes2d_IntersectionSegment_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        Last item access

        :rtype: const TheItemType &

        """
        res = _IntRes2d.NCollection_Sequence_IntRes2d_IntersectionSegment_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Sequence_IntRes2d_IntersectionSegment self) -> IntRes2d_IntersectionSegment

        Last item access

        :rtype: TheItemType &

        """
        return _IntRes2d.NCollection_Sequence_IntRes2d_IntersectionSegment_ChangeLast(self, *args)


    def Value(self, *args):
        """
        Constant item access by theIndex

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _IntRes2d.NCollection_Sequence_IntRes2d_IntersectionSegment_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Sequence_IntRes2d_IntersectionSegment self, Standard_Integer const theIndex) -> IntRes2d_IntersectionSegment

        Variable item access by theIndex

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _IntRes2d.NCollection_Sequence_IntRes2d_IntersectionSegment_ChangeValue(self, *args)


    def __call__(self, *args):
        """
        Constant operator()

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _IntRes2d.NCollection_Sequence_IntRes2d_IntersectionSegment___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetValue(self, *args):
        """
        SetValue(NCollection_Sequence_IntRes2d_IntersectionSegment self, Standard_Integer const theIndex, IntRes2d_IntersectionSegment theItem)

        Set item value by theIndex

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _IntRes2d.NCollection_Sequence_IntRes2d_IntersectionSegment_SetValue(self, *args)


    def __iter__(self):
        return _IntRes2d.NCollection_Sequence_IntRes2d_IntersectionSegment___iter__(self)
    __swig_destroy__ = _IntRes2d.delete_NCollection_Sequence_IntRes2d_IntersectionSegment
NCollection_Sequence_IntRes2d_IntersectionSegment_swigregister = _IntRes2d.NCollection_Sequence_IntRes2d_IntersectionSegment_swigregister
NCollection_Sequence_IntRes2d_IntersectionSegment_swigregister(NCollection_Sequence_IntRes2d_IntersectionSegment)

def NCollection_Sequence_IntRes2d_IntersectionSegment_delNode(*args):
    """
    NCollection_Sequence_IntRes2d_IntersectionSegment_delNode(NCollection_SeqNode theNode, Handle_NCollection_BaseAllocator theAl)

    Static deleter to be passed to BaseSequence

    :type theNode: OCC.wrapper.NCollection.NCollection_SeqNode
    :type theAl: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

    """
    return _IntRes2d.NCollection_Sequence_IntRes2d_IntersectionSegment_delNode(*args)

class NCollection_Sequence_IntRes2d_IntersectionSegment_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _IntRes2d.new_NCollection_Sequence_IntRes2d_IntersectionSegment_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _IntRes2d.delete_NCollection_Sequence_IntRes2d_IntersectionSegment_IteratorHelper

    def __next__(self):
        return _IntRes2d.NCollection_Sequence_IntRes2d_IntersectionSegment_IteratorHelper___next__(self)
NCollection_Sequence_IntRes2d_IntersectionSegment_IteratorHelper_swigregister = _IntRes2d.NCollection_Sequence_IntRes2d_IntersectionSegment_IteratorHelper_swigregister
NCollection_Sequence_IntRes2d_IntersectionSegment_IteratorHelper_swigregister(NCollection_Sequence_IntRes2d_IntersectionSegment_IteratorHelper)


try:
	IntRes2d_SequenceOfIntersectionSegment = NCollection_Sequence_IntRes2d_IntersectionSegment
except NameError:
	pass # does not exist, probably ignored

class IntRes2d_Intersection(object):
    """
    Defines  the root   class  of  all  the  Intersections
    between  two 2D-Curves, and  provides all  the methods
    about the results of the Intersections Algorithms.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def IsDone(self, *args):
        """
        IsDone(IntRes2d_Intersection self) -> Standard_Boolean

        returns TRUE when the computation was successful.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntRes2d.IntRes2d_Intersection_IsDone(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(IntRes2d_Intersection self) -> Standard_Boolean

        Returns TRUE if there is no intersection between the
        given arguments.
        The exception NotDone is raised if IsDone returns FALSE.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntRes2d.IntRes2d_Intersection_IsEmpty(self, *args)


    def NbPoints(self, *args):
        """
        NbPoints(IntRes2d_Intersection self) -> Standard_Integer

        This function returns the number of intersection
        points between the 2 curves.
        The exception NotDone is raised if IsDone returns FALSE.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntRes2d.IntRes2d_Intersection_NbPoints(self, *args)


    def Point(self, *args):
        """
        This function returns the intersection point
        of range N;
        The exception NotDone is raised if IsDone returns FALSE.
        The exception OutOfRange is raised if (N <= 0)
        or (N > NbPoints).

        :type N: int
        :rtype: OCC.wrapper.IntRes2d.IntRes2d_IntersectionPoint

        """
        res = _IntRes2d.IntRes2d_Intersection_Point(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def NbSegments(self, *args):
        """
        NbSegments(IntRes2d_Intersection self) -> Standard_Integer

        This function returns the number of intersection
        segments between the two curves.
        The exception NotDone is raised if IsDone returns FALSE.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntRes2d.IntRes2d_Intersection_NbSegments(self, *args)


    def Segment(self, *args):
        """
        This function returns the intersection segment
        of range N;
        The exception NotDone is raised if IsDone returns FALSE.
        The exception OutOfRange is raised if (N <= 0)
        or (N > NbPoints).

        :type N: int
        :rtype: OCC.wrapper.IntRes2d.IntRes2d_IntersectionSegment

        """
        res = _IntRes2d.IntRes2d_Intersection_Segment(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetReversedParameters(self, *args):
        """
        SetReversedParameters(IntRes2d_Intersection self, Standard_Boolean const Reverseflag)

        :type Reverseflag: bool

        """
        return _IntRes2d.IntRes2d_Intersection_SetReversedParameters(self, *args)

IntRes2d_Intersection_swigregister = _IntRes2d.IntRes2d_Intersection_swigregister
IntRes2d_Intersection_swigregister(IntRes2d_Intersection)

class IntRes2d_Domain(object):
    """
    Definition of the domain of parameter on a 2d-curve.
    Most of the time, a domain is defined by two extremities.
    An extremity is made of :
    - a point in 2d-space (Pnt2d from gp),
    - a parameter on the curve,
    - a tolerance in the 2d-space.
    Sometimes, it can be made of 0 or 1 point ( for an infinite
    or semi-infinite line for example).

    For Intersection algorithms, Ellipses and Circles
    Domains must be closed.
    So, SetEquivalentParameters(.,.) method must be called
    after initializing the first and the last bounds.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(IntRes2d_Domain self) -> IntRes2d_Domain
        __init__(IntRes2d_Domain self, gp_Pnt2d Pnt1, Standard_Real const Par1, Standard_Real const Tol1, gp_Pnt2d Pnt2, Standard_Real const Par2, Standard_Real const Tol2) -> IntRes2d_Domain
        __init__(IntRes2d_Domain self, gp_Pnt2d Pnt, Standard_Real const Par, Standard_Real const Tol, Standard_Boolean const First) -> IntRes2d_Domain

        Creates a semi-infinite Domain. If First is set to
        True, the given point is the first point of the domain,
        otherwise it is the last point.

        :type Pnt: OCC.wrapper.gp.gp_Pnt2d
        :type Par: float
        :type Tol: float
        :type First: bool

        """
        this = _IntRes2d.new_IntRes2d_Domain(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def SetValues(self, *args):
        """
        SetValues(IntRes2d_Domain self, gp_Pnt2d Pnt1, Standard_Real const Par1, Standard_Real const Tol1, gp_Pnt2d Pnt2, Standard_Real const Par2, Standard_Real const Tol2)
        SetValues(IntRes2d_Domain self)
        SetValues(IntRes2d_Domain self, gp_Pnt2d Pnt, Standard_Real const Par, Standard_Real const Tol, Standard_Boolean const First)

        Sets the values for a semi-infinite domain.

        :type Pnt: OCC.wrapper.gp.gp_Pnt2d
        :type Par: float
        :type Tol: float
        :type First: bool

        """
        return _IntRes2d.IntRes2d_Domain_SetValues(self, *args)


    def SetEquivalentParameters(self, *args):
        """
        SetEquivalentParameters(IntRes2d_Domain self, Standard_Real const zero, Standard_Real const period)

        Defines a closed domain.

        :type zero: float
        :type period: float

        """
        return _IntRes2d.IntRes2d_Domain_SetEquivalentParameters(self, *args)


    def HasFirstPoint(self, *args):
        """
        HasFirstPoint(IntRes2d_Domain self) -> Standard_Boolean

        Returns True if the domain has a first point, i-e
        a point defining the lowest admitted parameter on the
        curve.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntRes2d.IntRes2d_Domain_HasFirstPoint(self, *args)


    def FirstParameter(self, *args):
        """
        FirstParameter(IntRes2d_Domain self) -> Standard_Real

        Returns the parameter of the first point of the domain
        The exception DomainError is raised if HasFirstPoint
        returns False.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _IntRes2d.IntRes2d_Domain_FirstParameter(self, *args)


    def FirstPoint(self, *args):
        """
        Returns the first point of the domain.
        The exception DomainError is raised if HasFirstPoint
        returns False.

        :rtype: OCC.wrapper.gp.gp_Pnt2d

        """
        res = _IntRes2d.IntRes2d_Domain_FirstPoint(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def FirstTolerance(self, *args):
        """
        FirstTolerance(IntRes2d_Domain self) -> Standard_Real

        Returns the tolerance of the first (left) bound.
        The exception DomainError is raised if HasFirstPoint
        returns False.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _IntRes2d.IntRes2d_Domain_FirstTolerance(self, *args)


    def HasLastPoint(self, *args):
        """
        HasLastPoint(IntRes2d_Domain self) -> Standard_Boolean

        Returns True if the domain has a last point, i-e
        a point defining the highest admitted parameter on the
        curve.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntRes2d.IntRes2d_Domain_HasLastPoint(self, *args)


    def LastParameter(self, *args):
        """
        LastParameter(IntRes2d_Domain self) -> Standard_Real

        Returns the parameter of the last point of the domain.
        The exception DomainError is raised if HasLastPoint
        returns False.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _IntRes2d.IntRes2d_Domain_LastParameter(self, *args)


    def LastPoint(self, *args):
        """
        Returns the last point of the domain.
        The exception DomainError is raised if HasLastPoint
        returns False.

        :rtype: OCC.wrapper.gp.gp_Pnt2d

        """
        res = _IntRes2d.IntRes2d_Domain_LastPoint(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def LastTolerance(self, *args):
        """
        LastTolerance(IntRes2d_Domain self) -> Standard_Real

        Returns the tolerance of the last (right) bound.
        The exception DomainError is raised if HasLastPoint
        returns False.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _IntRes2d.IntRes2d_Domain_LastTolerance(self, *args)


    def IsClosed(self, *args):
        """
        IsClosed(IntRes2d_Domain self) -> Standard_Boolean

        Returns True if the domain is closed.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntRes2d.IntRes2d_Domain_IsClosed(self, *args)


    def EquivalentParameters(self, *args):
        """
        EquivalentParameters(IntRes2d_Domain self)

        Returns Equivalent parameters if the domain is closed.
        Otherwise, the exception DomainError is raised.

        :type zero: float
        :type zeroplusperiod: float

        """
        return _IntRes2d.IntRes2d_Domain_EquivalentParameters(self, *args)

    __swig_destroy__ = _IntRes2d.delete_IntRes2d_Domain
IntRes2d_Domain_swigregister = _IntRes2d.IntRes2d_Domain_swigregister
IntRes2d_Domain_swigregister(IntRes2d_Domain)

class IntRes2d_Transition(object):
    """
    Definition of    the  type  of   transition    near an
    intersection point between  two curves. The transition
    is either a "true transition", which means that one of
    the curves goes inside or outside  the area defined by
    the other curve  near  the intersection, or  a  "touch
    transition" which means that the  first curve does not
    cross  the  other one,  or an  "undecided" transition,
    which means that the curves are superposed.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(IntRes2d_Transition self) -> IntRes2d_Transition
        __init__(IntRes2d_Transition self, Standard_Boolean const Tangent, IntRes2d_Position const Pos, IntRes2d_TypeTrans const Type) -> IntRes2d_Transition
        __init__(IntRes2d_Transition self, Standard_Boolean const Tangent, IntRes2d_Position const Pos, IntRes2d_Situation const Situ, Standard_Boolean const Oppos) -> IntRes2d_Transition
        __init__(IntRes2d_Transition self, IntRes2d_Position const Pos) -> IntRes2d_Transition

        Creates an UNDECIDED transition.

        :type Pos: OCC.wrapper.IntRes2d.IntRes2d_Position

        """
        this = _IntRes2d.new_IntRes2d_Transition(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def SetValue(self, *args):
        """
        SetValue(IntRes2d_Transition self, Standard_Boolean const Tangent, IntRes2d_Position const Pos, IntRes2d_TypeTrans const Type)
        SetValue(IntRes2d_Transition self, Standard_Boolean const Tangent, IntRes2d_Position const Pos, IntRes2d_Situation const Situ, Standard_Boolean const Oppos)
        SetValue(IntRes2d_Transition self, IntRes2d_Position const Pos)

        Sets the values of an UNDECIDED transition.

        :type Pos: OCC.wrapper.IntRes2d.IntRes2d_Position

        """
        return _IntRes2d.IntRes2d_Transition_SetValue(self, *args)


    def SetPosition(self, *args):
        """
        SetPosition(IntRes2d_Transition self, IntRes2d_Position const Pos)

        Sets the value of the position.

        :type Pos: OCC.wrapper.IntRes2d.IntRes2d_Position

        """
        return _IntRes2d.IntRes2d_Transition_SetPosition(self, *args)


    def PositionOnCurve(self, *args):
        """
        PositionOnCurve(IntRes2d_Transition self) -> IntRes2d_Position

        Indicates if the  intersection is at the beginning
        (IntRes2d_Head),  at the end (IntRes2d_End), or in
        the middle (IntRes2d_Middle) of the curve.

        :rtype: OCC.wrapper.IntRes2d.IntRes2d_Position

        """
        return _IntRes2d.IntRes2d_Transition_PositionOnCurve(self, *args)


    def TransitionType(self, *args):
        """
        TransitionType(IntRes2d_Transition self) -> IntRes2d_TypeTrans

        Returns the type of transition at the intersection.
        It may be IN or OUT or TOUCH, or UNDECIDED if the
        two first derivatives are not enough to give
        the tangent to one of the two curves.

        :rtype: OCC.wrapper.IntRes2d.IntRes2d_TypeTrans

        """
        return _IntRes2d.IntRes2d_Transition_TransitionType(self, *args)


    def IsTangent(self, *args):
        """
        IsTangent(IntRes2d_Transition self) -> Standard_Boolean

        Returns TRUE when the 2 curves are tangent at the
        intersection point.
        Theexception DomainError is raised if the type of
        transition is UNDECIDED.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntRes2d.IntRes2d_Transition_IsTangent(self, *args)


    def Situation(self, *args):
        """
        Situation(IntRes2d_Transition self) -> IntRes2d_Situation

        returns a significant value if TransitionType returns
        TOUCH. In this case, the function returns :
        INSIDE when the curve remains inside the other one,
        OUTSIDE when it remains outside the other one,
        UNKNOWN when the calculus, based on the second derivatives
        cannot give the result.
        If TransitionType returns IN or OUT or UNDECIDED, the
        exception DomainError is raised.

        :rtype: OCC.wrapper.IntRes2d.IntRes2d_Situation

        """
        return _IntRes2d.IntRes2d_Transition_Situation(self, *args)


    def IsOpposite(self, *args):
        """
        IsOpposite(IntRes2d_Transition self) -> Standard_Boolean

        returns a  significant value   if   TransitionType
        returns TOUCH. In this  case, the function returns
        true   when  the  2   curves   locally define  two
        different  parts of the  space.  If TransitionType
        returns  IN or   OUT or UNDECIDED,  the  exception
        DomainError is raised.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntRes2d.IntRes2d_Transition_IsOpposite(self, *args)

    __swig_destroy__ = _IntRes2d.delete_IntRes2d_Transition
IntRes2d_Transition_swigregister = _IntRes2d.IntRes2d_Transition_swigregister
IntRes2d_Transition_swigregister(IntRes2d_Transition)




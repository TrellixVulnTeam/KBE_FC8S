# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_IntTools')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_IntTools')
    _IntTools = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_IntTools', [dirname(__file__)])
        except ImportError:
            import _IntTools
            return _IntTools
        try:
            _mod = imp.load_module('_IntTools', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _IntTools = swig_import_helper()
    del swig_import_helper
else:
    import _IntTools
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


class SwigPyIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _IntTools.delete_SwigPyIterator

    def value(self):
        return _IntTools.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _IntTools.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _IntTools.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _IntTools.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _IntTools.SwigPyIterator_equal(self, x)

    def copy(self):
        return _IntTools.SwigPyIterator_copy(self)

    def next(self):
        return _IntTools.SwigPyIterator_next(self)

    def __next__(self):
        return _IntTools.SwigPyIterator___next__(self)

    def previous(self):
        return _IntTools.SwigPyIterator_previous(self)

    def advance(self, n):
        return _IntTools.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _IntTools.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _IntTools.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _IntTools.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _IntTools.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _IntTools.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _IntTools.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self
SwigPyIterator_swigregister = _IntTools.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

class NCollection_CellFilter_InspectorXYZ(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _IntTools.NCollection_CellFilter_InspectorXYZ_Dimension
    Coord = staticmethod(_IntTools.NCollection_CellFilter_InspectorXYZ_Coord)

    def Shift(self, thePnt, theTol):
        return _IntTools.NCollection_CellFilter_InspectorXYZ_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _IntTools.new_NCollection_CellFilter_InspectorXYZ()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _IntTools.delete_NCollection_CellFilter_InspectorXYZ
NCollection_CellFilter_InspectorXYZ_swigregister = _IntTools.NCollection_CellFilter_InspectorXYZ_swigregister
NCollection_CellFilter_InspectorXYZ_swigregister(NCollection_CellFilter_InspectorXYZ)

def NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt):
    return _IntTools.NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt)
NCollection_CellFilter_InspectorXYZ_Coord = _IntTools.NCollection_CellFilter_InspectorXYZ_Coord

class NCollection_CellFilter_InspectorXY(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _IntTools.NCollection_CellFilter_InspectorXY_Dimension
    Coord = staticmethod(_IntTools.NCollection_CellFilter_InspectorXY_Coord)

    def Shift(self, thePnt, theTol):
        return _IntTools.NCollection_CellFilter_InspectorXY_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _IntTools.new_NCollection_CellFilter_InspectorXY()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _IntTools.delete_NCollection_CellFilter_InspectorXY
NCollection_CellFilter_InspectorXY_swigregister = _IntTools.NCollection_CellFilter_InspectorXY_swigregister
NCollection_CellFilter_InspectorXY_swigregister(NCollection_CellFilter_InspectorXY)

def NCollection_CellFilter_InspectorXY_Coord(i, thePnt):
    return _IntTools.NCollection_CellFilter_InspectorXY_Coord(i, thePnt)
NCollection_CellFilter_InspectorXY_Coord = _IntTools.NCollection_CellFilter_InspectorXY_Coord


def ptr_to_number(item):
    return _IntTools.ptr_to_number(item)
ptr_to_number = _IntTools.ptr_to_number

def HashCode(*args):
    return _IntTools.HashCode(*args)
HashCode = _IntTools.HashCode

def ptr_equal(a, b):
    return _IntTools.ptr_equal(a, b)
ptr_equal = _IntTools.ptr_equal
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopoDS
else:
    import TopoDS
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import NCollection
else:
    import NCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Standard
else:
    import Standard
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopAbs
else:
    import TopAbs
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Message
else:
    import Message
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColStd
else:
    import TColStd
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TCollection
else:
    import TCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopLoc
else:
    import TopLoc
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import gp
else:
    import gp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import GeomAbs
else:
    import GeomAbs
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Geom2d
else:
    import Geom2d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColgp
else:
    import TColgp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import GeomAPI
else:
    import GeomAPI
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Approx
else:
    import Approx
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import AppCont
else:
    import AppCont
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import AppParCurves
else:
    import AppParCurves
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import math
else:
    import math
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import AdvApprox
else:
    import AdvApprox
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import PLib
else:
    import PLib
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Adaptor2d
else:
    import Adaptor2d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Geom
else:
    import Geom
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Adaptor3d
else:
    import Adaptor3d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Extrema
else:
    import Extrema
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import GeomAdaptor
else:
    import GeomAdaptor
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Bnd
else:
    import Bnd
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Geom2dHatch
else:
    import Geom2dHatch
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import HatchGen
else:
    import HatchGen
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import IntRes2d
else:
    import IntRes2d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Geom2dAdaptor
else:
    import Geom2dAdaptor
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Geom2dInt
else:
    import Geom2dInt
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Intf
else:
    import Intf
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import IntCurve
else:
    import IntCurve
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import IntPatch
else:
    import IntPatch
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import IntSurf
else:
    import IntSurf
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import IntAna
else:
    import IntAna
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import IntWalk
else:
    import IntWalk
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import IntImp
else:
    import IntImp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import BRepClass3d
else:
    import BRepClass3d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import IntCurveSurface
else:
    import IntCurveSurface
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import IntCurvesFace
else:
    import IntCurvesFace
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import BRepAdaptor
else:
    import BRepAdaptor
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopTools
else:
    import TopTools
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import GeomInt
else:
    import GeomInt
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import ApproxInt
else:
    import ApproxInt
del _swig_python_version_info
class IntTools_SurfaceRangeSample(object):
    """class for range index management of surface"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(IntTools_SurfaceRangeSample self) -> IntTools_SurfaceRangeSample
        __init__(IntTools_SurfaceRangeSample self, Standard_Integer const theIndexU, Standard_Integer const theDepthU, Standard_Integer const theIndexV, Standard_Integer const theDepthV) -> IntTools_SurfaceRangeSample
        __init__(IntTools_SurfaceRangeSample self, IntTools_CurveRangeSample theRangeU, IntTools_CurveRangeSample theRangeV) -> IntTools_SurfaceRangeSample
        __init__(IntTools_SurfaceRangeSample self, IntTools_SurfaceRangeSample Other) -> IntTools_SurfaceRangeSample

        :type Other: OCC.wrapper.IntTools.IntTools_SurfaceRangeSample

        """
        this = _IntTools.new_IntTools_SurfaceRangeSample(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Assign(self, *args):
        """
        Assign(IntTools_SurfaceRangeSample self, IntTools_SurfaceRangeSample Other) -> IntTools_SurfaceRangeSample

        :type Other: OCC.wrapper.IntTools.IntTools_SurfaceRangeSample
        :rtype: OCC.wrapper.IntTools.IntTools_SurfaceRangeSample

        """
        return _IntTools.IntTools_SurfaceRangeSample_Assign(self, *args)


    def assign(self, *args):
        """
        assign(IntTools_SurfaceRangeSample self, IntTools_SurfaceRangeSample Other) -> IntTools_SurfaceRangeSample

        :type Other: OCC.wrapper.IntTools.IntTools_SurfaceRangeSample
        :rtype: OCC.wrapper.IntTools.IntTools_SurfaceRangeSample

        """
        return _IntTools.IntTools_SurfaceRangeSample_assign(self, *args)


    def SetRanges(self, *args):
        """
        SetRanges(IntTools_SurfaceRangeSample self, IntTools_CurveRangeSample theRangeU, IntTools_CurveRangeSample theRangeV)

        :type theRangeU: OCC.wrapper.IntTools.IntTools_CurveRangeSample
        :type theRangeV: OCC.wrapper.IntTools.IntTools_CurveRangeSample

        """
        return _IntTools.IntTools_SurfaceRangeSample_SetRanges(self, *args)


    def GetRanges(self, *args):
        """
        GetRanges(IntTools_SurfaceRangeSample self, IntTools_CurveRangeSample theRangeU, IntTools_CurveRangeSample theRangeV)

        :type theRangeU: OCC.wrapper.IntTools.IntTools_CurveRangeSample
        :type theRangeV: OCC.wrapper.IntTools.IntTools_CurveRangeSample

        """
        return _IntTools.IntTools_SurfaceRangeSample_GetRanges(self, *args)


    def SetIndexes(self, *args):
        """
        SetIndexes(IntTools_SurfaceRangeSample self, Standard_Integer const theIndexU, Standard_Integer const theIndexV)

        :type theIndexU: int
        :type theIndexV: int

        """
        return _IntTools.IntTools_SurfaceRangeSample_SetIndexes(self, *args)


    def GetIndexes(self, *args):
        """
        GetIndexes(IntTools_SurfaceRangeSample self)

        :type theIndexU: int
        :type theIndexV: int

        """
        return _IntTools.IntTools_SurfaceRangeSample_GetIndexes(self, *args)


    def GetDepths(self, *args):
        """
        GetDepths(IntTools_SurfaceRangeSample self)

        :type theDepthU: int
        :type theDepthV: int

        """
        return _IntTools.IntTools_SurfaceRangeSample_GetDepths(self, *args)


    def SetSampleRangeU(self, *args):
        """
        SetSampleRangeU(IntTools_SurfaceRangeSample self, IntTools_CurveRangeSample theRangeSampleU)

        :type theRangeSampleU: OCC.wrapper.IntTools.IntTools_CurveRangeSample

        """
        return _IntTools.IntTools_SurfaceRangeSample_SetSampleRangeU(self, *args)


    def GetSampleRangeU(self, *args):
        """
        :rtype: OCC.wrapper.IntTools.IntTools_CurveRangeSample

        """
        res = _IntTools.IntTools_SurfaceRangeSample_GetSampleRangeU(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetSampleRangeV(self, *args):
        """
        SetSampleRangeV(IntTools_SurfaceRangeSample self, IntTools_CurveRangeSample theRangeSampleV)

        :type theRangeSampleV: OCC.wrapper.IntTools.IntTools_CurveRangeSample

        """
        return _IntTools.IntTools_SurfaceRangeSample_SetSampleRangeV(self, *args)


    def GetSampleRangeV(self, *args):
        """
        :rtype: OCC.wrapper.IntTools.IntTools_CurveRangeSample

        """
        res = _IntTools.IntTools_SurfaceRangeSample_GetSampleRangeV(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetIndexU(self, *args):
        """
        SetIndexU(IntTools_SurfaceRangeSample self, Standard_Integer const theIndexU)

        :type theIndexU: int

        """
        return _IntTools.IntTools_SurfaceRangeSample_SetIndexU(self, *args)


    def GetIndexU(self, *args):
        """
        GetIndexU(IntTools_SurfaceRangeSample self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntTools.IntTools_SurfaceRangeSample_GetIndexU(self, *args)


    def SetIndexV(self, *args):
        """
        SetIndexV(IntTools_SurfaceRangeSample self, Standard_Integer const theIndexV)

        :type theIndexV: int

        """
        return _IntTools.IntTools_SurfaceRangeSample_SetIndexV(self, *args)


    def GetIndexV(self, *args):
        """
        GetIndexV(IntTools_SurfaceRangeSample self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntTools.IntTools_SurfaceRangeSample_GetIndexV(self, *args)


    def SetDepthU(self, *args):
        """
        SetDepthU(IntTools_SurfaceRangeSample self, Standard_Integer const theDepthU)

        :type theDepthU: int

        """
        return _IntTools.IntTools_SurfaceRangeSample_SetDepthU(self, *args)


    def GetDepthU(self, *args):
        """
        GetDepthU(IntTools_SurfaceRangeSample self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntTools.IntTools_SurfaceRangeSample_GetDepthU(self, *args)


    def SetDepthV(self, *args):
        """
        SetDepthV(IntTools_SurfaceRangeSample self, Standard_Integer const theDepthV)

        :type theDepthV: int

        """
        return _IntTools.IntTools_SurfaceRangeSample_SetDepthV(self, *args)


    def GetDepthV(self, *args):
        """
        GetDepthV(IntTools_SurfaceRangeSample self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntTools.IntTools_SurfaceRangeSample_GetDepthV(self, *args)


    def GetRangeU(self, *args):
        """
        GetRangeU(IntTools_SurfaceRangeSample self, Standard_Real const theFirstU, Standard_Real const theLastU, Standard_Integer const theNbSampleU) -> IntTools_Range

        :type theFirstU: float
        :type theLastU: float
        :type theNbSampleU: int
        :rtype: OCC.wrapper.IntTools.IntTools_Range

        """
        return _IntTools.IntTools_SurfaceRangeSample_GetRangeU(self, *args)


    def GetRangeV(self, *args):
        """
        GetRangeV(IntTools_SurfaceRangeSample self, Standard_Real const theFirstV, Standard_Real const theLastV, Standard_Integer const theNbSampleV) -> IntTools_Range

        :type theFirstV: float
        :type theLastV: float
        :type theNbSampleV: int
        :rtype: OCC.wrapper.IntTools.IntTools_Range

        """
        return _IntTools.IntTools_SurfaceRangeSample_GetRangeV(self, *args)


    def IsEqual(self, *args):
        """
        IsEqual(IntTools_SurfaceRangeSample self, IntTools_SurfaceRangeSample Other) -> Standard_Boolean

        :type Other: OCC.wrapper.IntTools.IntTools_SurfaceRangeSample
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntTools.IntTools_SurfaceRangeSample_IsEqual(self, *args)


    def GetRangeIndexUDeeper(self, *args):
        """
        GetRangeIndexUDeeper(IntTools_SurfaceRangeSample self, Standard_Integer const theNbSampleU) -> Standard_Integer

        :type theNbSampleU: int
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntTools.IntTools_SurfaceRangeSample_GetRangeIndexUDeeper(self, *args)


    def GetRangeIndexVDeeper(self, *args):
        """
        GetRangeIndexVDeeper(IntTools_SurfaceRangeSample self, Standard_Integer const theNbSampleV) -> Standard_Integer

        :type theNbSampleV: int
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntTools.IntTools_SurfaceRangeSample_GetRangeIndexVDeeper(self, *args)

    __swig_destroy__ = _IntTools.delete_IntTools_SurfaceRangeSample
IntTools_SurfaceRangeSample_swigregister = _IntTools.IntTools_SurfaceRangeSample_swigregister
IntTools_SurfaceRangeSample_swigregister(IntTools_SurfaceRangeSample)

class IntTools_SurfaceRangeSampleMapHasher(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def HashCode(*args):
        """
        HashCode(IntTools_SurfaceRangeSample K, Standard_Integer const Upper) -> Standard_Integer

        Returns a HasCode value  for  the  Key <K>  in the
        range 0..Upper.

        :type K: OCC.wrapper.IntTools.IntTools_SurfaceRangeSample
        :type Upper: int
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntTools.IntTools_SurfaceRangeSampleMapHasher_HashCode(*args)

    HashCode = staticmethod(HashCode)

    def IsEqual(*args):
        """
        IsEqual(IntTools_SurfaceRangeSample S1, IntTools_SurfaceRangeSample S2) -> Standard_Boolean

        Returns True  when the two  keys are the same. Two
        same  keys  must   have  the  same  hashcode,  the
        contrary is not necessary.

        :type S1: OCC.wrapper.IntTools.IntTools_SurfaceRangeSample
        :type S2: OCC.wrapper.IntTools.IntTools_SurfaceRangeSample
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntTools.IntTools_SurfaceRangeSampleMapHasher_IsEqual(*args)

    IsEqual = staticmethod(IsEqual)

    def __init__(self):
        this = _IntTools.new_IntTools_SurfaceRangeSampleMapHasher()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _IntTools.delete_IntTools_SurfaceRangeSampleMapHasher
IntTools_SurfaceRangeSampleMapHasher_swigregister = _IntTools.IntTools_SurfaceRangeSampleMapHasher_swigregister
IntTools_SurfaceRangeSampleMapHasher_swigregister(IntTools_SurfaceRangeSampleMapHasher)

def IntTools_SurfaceRangeSampleMapHasher_HashCode(*args):
    """
    IntTools_SurfaceRangeSampleMapHasher_HashCode(IntTools_SurfaceRangeSample K, Standard_Integer const Upper) -> Standard_Integer

    Returns a HasCode value  for  the  Key <K>  in the
    range 0..Upper.

    :type K: OCC.wrapper.IntTools.IntTools_SurfaceRangeSample
    :type Upper: int
    :rtype: OCC.wrapper.Standard.Standard_Integer

    """
    return _IntTools.IntTools_SurfaceRangeSampleMapHasher_HashCode(*args)

def IntTools_SurfaceRangeSampleMapHasher_IsEqual(*args):
    """
    IntTools_SurfaceRangeSampleMapHasher_IsEqual(IntTools_SurfaceRangeSample S1, IntTools_SurfaceRangeSample S2) -> Standard_Boolean

    Returns True  when the two  keys are the same. Two
    same  keys  must   have  the  same  hashcode,  the
    contrary is not necessary.

    :type S1: OCC.wrapper.IntTools.IntTools_SurfaceRangeSample
    :type S2: OCC.wrapper.IntTools.IntTools_SurfaceRangeSample
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _IntTools.IntTools_SurfaceRangeSampleMapHasher_IsEqual(*args)

class IntTools_Range(object):
    """
    The class describes the  1-d range
    [myFirst, myLast].
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(IntTools_Range self) -> IntTools_Range
        __init__(IntTools_Range self, Standard_Real const aFirst, Standard_Real const aLast) -> IntTools_Range

        Initialize me by range boundaries

        :type aFirst: float
        :type aLast: float

        """
        this = _IntTools.new_IntTools_Range(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def SetFirst(self, *args):
        """
        SetFirst(IntTools_Range self, Standard_Real const aFirst)

        Modifier

        :type aFirst: float

        """
        return _IntTools.IntTools_Range_SetFirst(self, *args)


    def SetLast(self, *args):
        """
        SetLast(IntTools_Range self, Standard_Real const aLast)

        Modifier

        :type aLast: float

        """
        return _IntTools.IntTools_Range_SetLast(self, *args)


    def First(self, *args):
        """
        First(IntTools_Range self) -> Standard_Real

        Selector

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _IntTools.IntTools_Range_First(self, *args)


    def Last(self, *args):
        """
        Last(IntTools_Range self) -> Standard_Real

        Selector

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _IntTools.IntTools_Range_Last(self, *args)


    def Range(self, *args):
        """
        Range(IntTools_Range self)

        Selector

        :type aFirst: float
        :type aLast: float

        """
        return _IntTools.IntTools_Range_Range(self, *args)

    __swig_destroy__ = _IntTools.delete_IntTools_Range
IntTools_Range_swigregister = _IntTools.IntTools_Range_swigregister
IntTools_Range_swigregister(IntTools_Range)

class IntTools_BeanFaceIntersector(object):
    """
    The class BeanFaceIntersector computes ranges of parameters on
    the curve of a bean(part of edge) that bound the parts of bean which
    are on the surface of a face according to edge and face tolerances.
    Warning: The real boundaries of the face are not taken into account,
    Most of the result parts of the bean lays only inside the region of the surface,
    which includes the inside of the face. And the parts which are out of this region can be
    excluded from the result.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(IntTools_BeanFaceIntersector self) -> IntTools_BeanFaceIntersector
        __init__(IntTools_BeanFaceIntersector self, TopoDS_Edge theEdge, TopoDS_Face theFace) -> IntTools_BeanFaceIntersector
        __init__(IntTools_BeanFaceIntersector self, BRepAdaptor_Curve theCurve, BRepAdaptor_Surface theSurface, Standard_Real const theBeanTolerance, Standard_Real const theFaceTolerance) -> IntTools_BeanFaceIntersector
        __init__(IntTools_BeanFaceIntersector self, BRepAdaptor_Curve theCurve, BRepAdaptor_Surface theSurface, Standard_Real const theFirstParOnCurve, Standard_Real const theLastParOnCurve, Standard_Real const theUMinParameter, Standard_Real const theUMaxParameter, Standard_Real const theVMinParameter, Standard_Real const theVMaxParameter, Standard_Real const theBeanTolerance, Standard_Real const theFaceTolerance) -> IntTools_BeanFaceIntersector

        Initializes the algorithm
        theUMinParameter, ... are used for
        optimization purposes

        :type theCurve: OCC.wrapper.BRepAdaptor.BRepAdaptor_Curve
        :type theSurface: OCC.wrapper.BRepAdaptor.BRepAdaptor_Surface
        :type theFirstParOnCurve: float
        :type theLastParOnCurve: float
        :type theUMinParameter: float
        :type theUMaxParameter: float
        :type theVMinParameter: float
        :type theVMaxParameter: float
        :type theBeanTolerance: float
        :type theFaceTolerance: float

        """
        this = _IntTools.new_IntTools_BeanFaceIntersector(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(IntTools_BeanFaceIntersector self, TopoDS_Edge theEdge, TopoDS_Face theFace)
        Init(IntTools_BeanFaceIntersector self, BRepAdaptor_Curve theCurve, BRepAdaptor_Surface theSurface, Standard_Real const theBeanTolerance, Standard_Real const theFaceTolerance)
        Init(IntTools_BeanFaceIntersector self, BRepAdaptor_Curve theCurve, BRepAdaptor_Surface theSurface, Standard_Real const theFirstParOnCurve, Standard_Real const theLastParOnCurve, Standard_Real const theUMinParameter, Standard_Real const theUMaxParameter, Standard_Real const theVMinParameter, Standard_Real const theVMaxParameter, Standard_Real const theBeanTolerance, Standard_Real const theFaceTolerance)

        Initializes the algorithm
        theUMinParameter, ... are used for
        optimization purposes

        :type theCurve: OCC.wrapper.BRepAdaptor.BRepAdaptor_Curve
        :type theSurface: OCC.wrapper.BRepAdaptor.BRepAdaptor_Surface
        :type theFirstParOnCurve: float
        :type theLastParOnCurve: float
        :type theUMinParameter: float
        :type theUMaxParameter: float
        :type theVMinParameter: float
        :type theVMaxParameter: float
        :type theBeanTolerance: float
        :type theFaceTolerance: float

        """
        return _IntTools.IntTools_BeanFaceIntersector_Init(self, *args)


    def SetContext(self, *args):
        """
        SetContext(IntTools_BeanFaceIntersector self, Handle_IntTools_Context theContext)

        Sets the intersecton context

        :type theContext: OCC.wrapper.IntTools.Handle_IntTools_Context

        """
        return _IntTools.IntTools_BeanFaceIntersector_SetContext(self, *args)


    def Context(self, *args):
        """
        Gets the intersecton context

        :rtype: OCC.wrapper.IntTools.Handle_IntTools_Context

        """
        res = _IntTools.IntTools_BeanFaceIntersector_Context(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetBeanParameters(self, *args):
        """
        SetBeanParameters(IntTools_BeanFaceIntersector self, Standard_Real const theFirstParOnCurve, Standard_Real const theLastParOnCurve)

        Set restrictions for curve

        :type theFirstParOnCurve: float
        :type theLastParOnCurve: float

        """
        return _IntTools.IntTools_BeanFaceIntersector_SetBeanParameters(self, *args)


    def SetSurfaceParameters(self, *args):
        """
        SetSurfaceParameters(IntTools_BeanFaceIntersector self, Standard_Real const theUMinParameter, Standard_Real const theUMaxParameter, Standard_Real const theVMinParameter, Standard_Real const theVMaxParameter)

        Set restrictions for surface

        :type theUMinParameter: float
        :type theUMaxParameter: float
        :type theVMinParameter: float
        :type theVMaxParameter: float

        """
        return _IntTools.IntTools_BeanFaceIntersector_SetSurfaceParameters(self, *args)


    def Perform(self, *args):
        """
        Perform(IntTools_BeanFaceIntersector self)

        Launches the algorithm


        """
        return _IntTools.IntTools_BeanFaceIntersector_Perform(self, *args)


    def IsDone(self, *args):
        """
        IsDone(IntTools_BeanFaceIntersector self) -> Standard_Boolean

        Returns Done/NotDone state of the algorithm.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntTools.IntTools_BeanFaceIntersector_IsDone(self, *args)


    def Result(self, *args):
        """
        :rtype: OCC.wrapper.IntTools.IntTools_SequenceOfRanges

        """
        res = _IntTools.IntTools_BeanFaceIntersector_Result(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _IntTools.delete_IntTools_BeanFaceIntersector
IntTools_BeanFaceIntersector_swigregister = _IntTools.IntTools_BeanFaceIntersector_swigregister
IntTools_BeanFaceIntersector_swigregister(IntTools_BeanFaceIntersector)

class IntTools_Root(object):
    """
    The class is to describe the root of
    function of one variable  for  Edge/Edge
    and  Edge/Surface  algorithms.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(IntTools_Root self) -> IntTools_Root
        __init__(IntTools_Root self, Standard_Real const aRoot, Standard_Integer const aType) -> IntTools_Root

        Initializes my by range of parameters
        and type of root

        :type aRoot: float
        :type aType: int

        """
        this = _IntTools.new_IntTools_Root(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def SetRoot(self, *args):
        """
        SetRoot(IntTools_Root self, Standard_Real const aRoot)

        Sets the Root's value

        :type aRoot: float

        """
        return _IntTools.IntTools_Root_SetRoot(self, *args)


    def SetType(self, *args):
        """
        SetType(IntTools_Root self, Standard_Integer const aType)

        Sets the Root's Type

        :type aType: int

        """
        return _IntTools.IntTools_Root_SetType(self, *args)


    def SetStateBefore(self, *args):
        """
        SetStateBefore(IntTools_Root self, TopAbs_State const aState)

        Set  the  value of the state before the root
        (at  t=Root-dt)

        :type aState: OCC.wrapper.TopAbs.TopAbs_State

        """
        return _IntTools.IntTools_Root_SetStateBefore(self, *args)


    def SetStateAfter(self, *args):
        """
        SetStateAfter(IntTools_Root self, TopAbs_State const aState)

        Set  the  value of the state after the root
        (at  t=Root-dt)

        :type aState: OCC.wrapper.TopAbs.TopAbs_State

        """
        return _IntTools.IntTools_Root_SetStateAfter(self, *args)


    def SetLayerHeight(self, *args):
        """
        SetLayerHeight(IntTools_Root self, Standard_Real const aHeight)

        Not  used  in  Edge/Edge  algorithm

        :type aHeight: float

        """
        return _IntTools.IntTools_Root_SetLayerHeight(self, *args)


    def SetInterval(self, *args):
        """
        SetInterval(IntTools_Root self, Standard_Real const t1, Standard_Real const t2, Standard_Real const f1, Standard_Real const f2)

        Sets the  interval  from which the Root was
        found [t1,t2] and the  corresponding  values
        of  the  function  on  the  bounds f(t1), f(t2).

        :type t1: float
        :type t2: float
        :type f1: float
        :type f2: float

        """
        return _IntTools.IntTools_Root_SetInterval(self, *args)


    def Root(self, *args):
        """
        Root(IntTools_Root self) -> Standard_Real

        Returns the Root  value

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _IntTools.IntTools_Root_Root(self, *args)


    def Type(self, *args):
        """
        Type(IntTools_Root self) -> Standard_Integer

        Returns the  type  of  the  root
        =0  -  Simple (was  found  by  bisection  method);
        =2  -  Smart when f1=0, f2!=0 or  vice  versa
        (was  found  by  Fibbonacci method);
        =1  -  Pure   (pure  zero  for all t [t1,t2] );

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntTools.IntTools_Root_Type(self, *args)


    def StateBefore(self, *args):
        """
        StateBefore(IntTools_Root self) -> TopAbs_State

        Returns the state before the root

        :rtype: OCC.wrapper.TopAbs.TopAbs_State

        """
        return _IntTools.IntTools_Root_StateBefore(self, *args)


    def StateAfter(self, *args):
        """
        StateAfter(IntTools_Root self) -> TopAbs_State

        Returns the state after the root

        :rtype: OCC.wrapper.TopAbs.TopAbs_State

        """
        return _IntTools.IntTools_Root_StateAfter(self, *args)


    def LayerHeight(self, *args):
        """
        LayerHeight(IntTools_Root self) -> Standard_Real

        Not  used  in  Edge/Edge  algorithm

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _IntTools.IntTools_Root_LayerHeight(self, *args)


    def IsValid(self, *args):
        """
        IsValid(IntTools_Root self) -> Standard_Boolean

        Returns the validity flag for the root,
        True if
        myStateBefore==TopAbs_OUT && myStateAfter==TopAbs_IN or
        myStateBefore==TopAbs_OUT && myStateAfter==TopAbs_ON or
        myStateBefore==TopAbs_ON  && myStateAfter==TopAbs_OUT or
        myStateBefore==TopAbs_IN  && myStateAfter==TopAbs_OUT  .
        For  other  cases it  returns  False.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntTools.IntTools_Root_IsValid(self, *args)

    __swig_destroy__ = _IntTools.delete_IntTools_Root
IntTools_Root_swigregister = _IntTools.IntTools_Root_swigregister
IntTools_Root_swigregister(IntTools_Root)

class IntTools_CurveRangeLocalizeData(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(IntTools_CurveRangeLocalizeData self, Standard_Integer const theNbSample, Standard_Real const theMinRange) -> IntTools_CurveRangeLocalizeData

        :type theNbSample: int
        :type theMinRange: float

        """
        this = _IntTools.new_IntTools_CurveRangeLocalizeData(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def GetNbSample(self, *args):
        """
        GetNbSample(IntTools_CurveRangeLocalizeData self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntTools.IntTools_CurveRangeLocalizeData_GetNbSample(self, *args)


    def GetMinRange(self, *args):
        """
        GetMinRange(IntTools_CurveRangeLocalizeData self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _IntTools.IntTools_CurveRangeLocalizeData_GetMinRange(self, *args)


    def AddOutRange(self, *args):
        """
        AddOutRange(IntTools_CurveRangeLocalizeData self, IntTools_CurveRangeSample theRange)

        :type theRange: OCC.wrapper.IntTools.IntTools_CurveRangeSample

        """
        return _IntTools.IntTools_CurveRangeLocalizeData_AddOutRange(self, *args)


    def AddBox(self, *args):
        """
        AddBox(IntTools_CurveRangeLocalizeData self, IntTools_CurveRangeSample theRange, Bnd_Box theBox)

        :type theRange: OCC.wrapper.IntTools.IntTools_CurveRangeSample
        :type theBox: OCC.wrapper.Bnd.Bnd_Box

        """
        return _IntTools.IntTools_CurveRangeLocalizeData_AddBox(self, *args)


    def FindBox(self, *args):
        """
        FindBox(IntTools_CurveRangeLocalizeData self, IntTools_CurveRangeSample theRange, Bnd_Box theBox) -> Standard_Boolean

        :type theRange: OCC.wrapper.IntTools.IntTools_CurveRangeSample
        :type theBox: OCC.wrapper.Bnd.Bnd_Box
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntTools.IntTools_CurveRangeLocalizeData_FindBox(self, *args)


    def IsRangeOut(self, *args):
        """
        IsRangeOut(IntTools_CurveRangeLocalizeData self, IntTools_CurveRangeSample theRange) -> Standard_Boolean

        :type theRange: OCC.wrapper.IntTools.IntTools_CurveRangeSample
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntTools.IntTools_CurveRangeLocalizeData_IsRangeOut(self, *args)


    def ListRangeOut(self, *args):
        """
        ListRangeOut(IntTools_CurveRangeLocalizeData self, IntTools_ListOfCurveRangeSample & theList)

        :type theList: OCC.wrapper.IntTools.IntTools_ListOfCurveRangeSample

        """
        return _IntTools.IntTools_CurveRangeLocalizeData_ListRangeOut(self, *args)

    __swig_destroy__ = _IntTools.delete_IntTools_CurveRangeLocalizeData
IntTools_CurveRangeLocalizeData_swigregister = _IntTools.IntTools_CurveRangeLocalizeData_swigregister
IntTools_CurveRangeLocalizeData_swigregister(IntTools_CurveRangeLocalizeData)

class IntTools_WLineTool(object):
    """IntTools_WLineTool provides set of static methods related to walking lines."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def NotUseSurfacesForApprox(*args):
        """
        NotUseSurfacesForApprox(TopoDS_Face aF1, TopoDS_Face aF2, Handle_IntPatch_WLine WL, Standard_Integer const ifprm, Standard_Integer const ilprm) -> Standard_Boolean

        :type aF1: OCC.wrapper.TopoDS.TopoDS_Face
        :type aF2: OCC.wrapper.TopoDS.TopoDS_Face
        :type WL: OCC.wrapper.IntPatch.Handle_IntPatch_WLine
        :type ifprm: int
        :type ilprm: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntTools.IntTools_WLineTool_NotUseSurfacesForApprox(*args)

    NotUseSurfacesForApprox = staticmethod(NotUseSurfacesForApprox)

    def DecompositionOfWLine(*args):
        """
        DecompositionOfWLine(Handle_IntPatch_WLine theWLine, Handle_GeomAdaptor_HSurface theSurface1, Handle_GeomAdaptor_HSurface theSurface2, TopoDS_Face theFace1, TopoDS_Face theFace2, GeomInt_LineConstructor theLConstructor, Standard_Boolean const theAvoidLConstructor, Standard_Real const theTol, NCollection_Sequence_Handle_IntPatch_Line theNewLines, Handle_IntTools_Context arg11) -> Standard_Boolean

        :type theWLine: OCC.wrapper.IntPatch.Handle_IntPatch_WLine
        :type theSurface1: OCC.wrapper.GeomAdaptor.Handle_GeomAdaptor_HSurface
        :type theSurface2: OCC.wrapper.GeomAdaptor.Handle_GeomAdaptor_HSurface
        :type theFace1: OCC.wrapper.TopoDS.TopoDS_Face
        :type theFace2: OCC.wrapper.TopoDS.TopoDS_Face
        :type theLConstructor: OCC.wrapper.GeomInt.GeomInt_LineConstructor
        :type theAvoidLConstructor: bool
        :type theTol: float
        :type theNewLines: OCC.wrapper.IntPatch.IntPatch_SequenceOfLine
        :type theReachedTol3d: float
        :type : OCC.wrapper.IntTools.Handle_IntTools_Context
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntTools.IntTools_WLineTool_DecompositionOfWLine(*args)

    DecompositionOfWLine = staticmethod(DecompositionOfWLine)

    def __init__(self):
        """IntTools_WLineTool provides set of static methods related to walking lines."""
        this = _IntTools.new_IntTools_WLineTool()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _IntTools.delete_IntTools_WLineTool
IntTools_WLineTool_swigregister = _IntTools.IntTools_WLineTool_swigregister
IntTools_WLineTool_swigregister(IntTools_WLineTool)

def IntTools_WLineTool_NotUseSurfacesForApprox(*args):
    """
    IntTools_WLineTool_NotUseSurfacesForApprox(TopoDS_Face aF1, TopoDS_Face aF2, Handle_IntPatch_WLine WL, Standard_Integer const ifprm, Standard_Integer const ilprm) -> Standard_Boolean

    :type aF1: OCC.wrapper.TopoDS.TopoDS_Face
    :type aF2: OCC.wrapper.TopoDS.TopoDS_Face
    :type WL: OCC.wrapper.IntPatch.Handle_IntPatch_WLine
    :type ifprm: int
    :type ilprm: int
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _IntTools.IntTools_WLineTool_NotUseSurfacesForApprox(*args)

def IntTools_WLineTool_DecompositionOfWLine(*args):
    """
    IntTools_WLineTool_DecompositionOfWLine(Handle_IntPatch_WLine theWLine, Handle_GeomAdaptor_HSurface theSurface1, Handle_GeomAdaptor_HSurface theSurface2, TopoDS_Face theFace1, TopoDS_Face theFace2, GeomInt_LineConstructor theLConstructor, Standard_Boolean const theAvoidLConstructor, Standard_Real const theTol, NCollection_Sequence_Handle_IntPatch_Line theNewLines, Handle_IntTools_Context arg12) -> Standard_Boolean

    :type theWLine: OCC.wrapper.IntPatch.Handle_IntPatch_WLine
    :type theSurface1: OCC.wrapper.GeomAdaptor.Handle_GeomAdaptor_HSurface
    :type theSurface2: OCC.wrapper.GeomAdaptor.Handle_GeomAdaptor_HSurface
    :type theFace1: OCC.wrapper.TopoDS.TopoDS_Face
    :type theFace2: OCC.wrapper.TopoDS.TopoDS_Face
    :type theLConstructor: OCC.wrapper.GeomInt.GeomInt_LineConstructor
    :type theAvoidLConstructor: bool
    :type theTol: float
    :type theNewLines: OCC.wrapper.IntPatch.IntPatch_SequenceOfLine
    :type theReachedTol3d: float
    :type : OCC.wrapper.IntTools.Handle_IntTools_Context
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _IntTools.IntTools_WLineTool_DecompositionOfWLine(*args)

class IntTools_ShrunkRange(object):
    """
    The class provides the computation of
    a working (shrunk) range [t1, t2] for
    the 3D-curve of the edge.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(IntTools_ShrunkRange self) -> IntTools_ShrunkRange

        The class provides the computation of
        a working (shrunk) range [t1, t2] for
        the 3D-curve of the edge.
        """
        this = _IntTools.new_IntTools_ShrunkRange(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def SetData(self, *args):
        """
        SetData(IntTools_ShrunkRange self, TopoDS_Edge aE, Standard_Real const aT1, Standard_Real const aT2, TopoDS_Vertex aV1, TopoDS_Vertex aV2)

        :type aE: OCC.wrapper.TopoDS.TopoDS_Edge
        :type aT1: float
        :type aT2: float
        :type aV1: OCC.wrapper.TopoDS.TopoDS_Vertex
        :type aV2: OCC.wrapper.TopoDS.TopoDS_Vertex

        """
        return _IntTools.IntTools_ShrunkRange_SetData(self, *args)


    def SetContext(self, *args):
        """
        SetContext(IntTools_ShrunkRange self, Handle_IntTools_Context aCtx)

        :type aCtx: OCC.wrapper.IntTools.Handle_IntTools_Context

        """
        return _IntTools.IntTools_ShrunkRange_SetContext(self, *args)


    def Context(self, *args):
        """
        :rtype: OCC.wrapper.IntTools.Handle_IntTools_Context

        """
        res = _IntTools.IntTools_ShrunkRange_Context(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetShrunkRange(self, *args):
        """
        SetShrunkRange(IntTools_ShrunkRange self, Standard_Real const aT1, Standard_Real const aT2)

        :type aT1: float
        :type aT2: float

        """
        return _IntTools.IntTools_ShrunkRange_SetShrunkRange(self, *args)


    def ShrunkRange(self, *args):
        """
        ShrunkRange(IntTools_ShrunkRange self)

        :type aT1: float
        :type aT2: float

        """
        return _IntTools.IntTools_ShrunkRange_ShrunkRange(self, *args)


    def BndBox(self, *args):
        """
        :rtype: OCC.wrapper.Bnd.Bnd_Box

        """
        res = _IntTools.IntTools_ShrunkRange_BndBox(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Edge(self, *args):
        """
        :rtype: OCC.wrapper.TopoDS.TopoDS_Edge

        """
        res = _IntTools.IntTools_ShrunkRange_Edge(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Perform(self, *args):
        """Perform(IntTools_ShrunkRange self)"""
        return _IntTools.IntTools_ShrunkRange_Perform(self, *args)


    def IsDone(self, *args):
        """
        IsDone(IntTools_ShrunkRange self) -> Standard_Boolean

        Returns TRUE in case the shrunk range is computed

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntTools.IntTools_ShrunkRange_IsDone(self, *args)


    def IsSplittable(self, *args):
        """
        IsSplittable(IntTools_ShrunkRange self) -> Standard_Boolean

        Returns FALSE in case the shrunk range is
        too short and the edge cannot be split,
        otherwise returns TRUE

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntTools.IntTools_ShrunkRange_IsSplittable(self, *args)

    __swig_destroy__ = _IntTools.delete_IntTools_ShrunkRange
IntTools_ShrunkRange_swigregister = _IntTools.IntTools_ShrunkRange_swigregister
IntTools_ShrunkRange_swigregister(IntTools_ShrunkRange)

class IntTools_PntOnFace(object):
    """Contains a Face, a 3d point, corresponded UV parameters and a flag"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(IntTools_PntOnFace self) -> IntTools_PntOnFace

        Empty constructor


        """
        this = _IntTools.new_IntTools_PntOnFace(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(IntTools_PntOnFace self, TopoDS_Face aF, gp_Pnt aP, Standard_Real const U, Standard_Real const V)

        Initializes me by aFace, a 3d point
        and it's UV parameters on face

        :type aF: OCC.wrapper.TopoDS.TopoDS_Face
        :type aP: OCC.wrapper.gp.gp_Pnt
        :type U: float
        :type V: float

        """
        return _IntTools.IntTools_PntOnFace_Init(self, *args)


    def SetFace(self, *args):
        """
        SetFace(IntTools_PntOnFace self, TopoDS_Face aF)

        Modifier

        :type aF: OCC.wrapper.TopoDS.TopoDS_Face

        """
        return _IntTools.IntTools_PntOnFace_SetFace(self, *args)


    def SetPnt(self, *args):
        """
        SetPnt(IntTools_PntOnFace self, gp_Pnt aP)

        Modifier

        :type aP: OCC.wrapper.gp.gp_Pnt

        """
        return _IntTools.IntTools_PntOnFace_SetPnt(self, *args)


    def SetParameters(self, *args):
        """
        SetParameters(IntTools_PntOnFace self, Standard_Real const U, Standard_Real const V)

        Modifier

        :type U: float
        :type V: float

        """
        return _IntTools.IntTools_PntOnFace_SetParameters(self, *args)


    def SetValid(self, *args):
        """
        SetValid(IntTools_PntOnFace self, Standard_Boolean const bF)

        Modifier

        :type bF: bool

        """
        return _IntTools.IntTools_PntOnFace_SetValid(self, *args)


    def Valid(self, *args):
        """
        Valid(IntTools_PntOnFace self) -> Standard_Boolean

        Selector

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntTools.IntTools_PntOnFace_Valid(self, *args)


    def Face(self, *args):
        """
        Selector

        :rtype: OCC.wrapper.TopoDS.TopoDS_Face

        """
        res = _IntTools.IntTools_PntOnFace_Face(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Pnt(self, *args):
        """
        Selector

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        res = _IntTools.IntTools_PntOnFace_Pnt(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Parameters(self, *args):
        """
        Parameters(IntTools_PntOnFace self)

        Selector

        :type U: float
        :type V: float

        """
        return _IntTools.IntTools_PntOnFace_Parameters(self, *args)

    __swig_destroy__ = _IntTools.delete_IntTools_PntOnFace
IntTools_PntOnFace_swigregister = _IntTools.IntTools_PntOnFace_swigregister
IntTools_PntOnFace_swigregister(IntTools_PntOnFace)

class NCollection_DataMap_IntTools_SurfaceRangeSample_Bnd_Box_IntTools_SurfaceRangeSampleMapHasher(NCollection.NCollection_BaseMap):
    """
    Purpose:     The DataMap is a Map to store keys with associated
    Items. See Map  from NCollection for  a discussion
    about the number of buckets.

    The DataMap can be seen as an extended array where
    the Keys  are the   indices.  For this reason  the
    operator () is defined on DataMap to fetch an Item
    from a Key. So the following syntax can be used :

    anItem = aMap(aKey);
    aMap(aKey) = anItem;

    This analogy has its  limit.   aMap(aKey) = anItem
    can  be done only  if aKey was previously bound to
    an item in the map.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_DataMap_IntTools_SurfaceRangeSample_Bnd_Box_IntTools_SurfaceRangeSampleMapHasher self) -> NCollection_DataMap< IntTools_SurfaceRangeSample,Bnd_Box,IntTools_SurfaceRangeSampleMapHasher >::iterator

        Returns an iterator pointing to the first element in the map.

        :rtype: iterator

        """
        return _IntTools.NCollection_DataMap_IntTools_SurfaceRangeSample_Bnd_Box_IntTools_SurfaceRangeSampleMapHasher_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_DataMap_IntTools_SurfaceRangeSample_Bnd_Box_IntTools_SurfaceRangeSampleMapHasher self) -> NCollection_DataMap< IntTools_SurfaceRangeSample,Bnd_Box,IntTools_SurfaceRangeSampleMapHasher >::iterator

        Returns an iterator referring to the past-the-end element in the map.

        :rtype: iterator

        """
        return _IntTools.NCollection_DataMap_IntTools_SurfaceRangeSample_Bnd_Box_IntTools_SurfaceRangeSampleMapHasher_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_DataMap_IntTools_SurfaceRangeSample_Bnd_Box_IntTools_SurfaceRangeSampleMapHasher self) -> NCollection_DataMap< IntTools_SurfaceRangeSample,Bnd_Box,IntTools_SurfaceRangeSampleMapHasher >::const_iterator

        Returns a const iterator pointing to the first element in the map.

        :rtype: const_iterator

        """
        return _IntTools.NCollection_DataMap_IntTools_SurfaceRangeSample_Bnd_Box_IntTools_SurfaceRangeSampleMapHasher_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_DataMap_IntTools_SurfaceRangeSample_Bnd_Box_IntTools_SurfaceRangeSampleMapHasher self) -> NCollection_DataMap< IntTools_SurfaceRangeSample,Bnd_Box,IntTools_SurfaceRangeSampleMapHasher >::const_iterator

        Returns a const iterator referring to the past-the-end element in the map.

        :rtype: const_iterator

        """
        return _IntTools.NCollection_DataMap_IntTools_SurfaceRangeSample_Bnd_Box_IntTools_SurfaceRangeSampleMapHasher_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     The DataMap is a Map to store keys with associated
        Items. See Map  from NCollection for  a discussion
        about the number of buckets.

        The DataMap can be seen as an extended array where
        the Keys  are the   indices.  For this reason  the
        operator () is defined on DataMap to fetch an Item
        from a Key. So the following syntax can be used :

        anItem = aMap(aKey);
        aMap(aKey) = anItem;

        This analogy has its  limit.   aMap(aKey) = anItem
        can  be done only  if aKey was previously bound to
        an item in the map.
        """
        this = _IntTools.new_NCollection_DataMap_IntTools_SurfaceRangeSample_Bnd_Box_IntTools_SurfaceRangeSampleMapHasher(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Exchange(self, *args):
        """
        Exchange(NCollection_DataMap_IntTools_SurfaceRangeSample_Bnd_Box_IntTools_SurfaceRangeSampleMapHasher self, NCollection_DataMap_IntTools_SurfaceRangeSample_Bnd_Box_IntTools_SurfaceRangeSampleMapHasher theOther)

        Exchange the content of two maps without re-allocations.
        Notice that allocators will be swapped as well!

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _IntTools.NCollection_DataMap_IntTools_SurfaceRangeSample_Bnd_Box_IntTools_SurfaceRangeSampleMapHasher_Exchange(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_DataMap_IntTools_SurfaceRangeSample_Bnd_Box_IntTools_SurfaceRangeSampleMapHasher self, NCollection_DataMap_IntTools_SurfaceRangeSample_Bnd_Box_IntTools_SurfaceRangeSampleMapHasher theOther) -> NCollection_DataMap_IntTools_SurfaceRangeSample_Bnd_Box_IntTools_SurfaceRangeSampleMapHasher

        Assignment.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _IntTools.NCollection_DataMap_IntTools_SurfaceRangeSample_Bnd_Box_IntTools_SurfaceRangeSampleMapHasher_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_DataMap_IntTools_SurfaceRangeSample_Bnd_Box_IntTools_SurfaceRangeSampleMapHasher self, NCollection_DataMap_IntTools_SurfaceRangeSample_Bnd_Box_IntTools_SurfaceRangeSampleMapHasher theOther) -> NCollection_DataMap_IntTools_SurfaceRangeSample_Bnd_Box_IntTools_SurfaceRangeSampleMapHasher

        Assignment operator

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _IntTools.NCollection_DataMap_IntTools_SurfaceRangeSample_Bnd_Box_IntTools_SurfaceRangeSampleMapHasher_assign(self, *args)


    def ReSize(self, *args):
        """
        ReSize(NCollection_DataMap_IntTools_SurfaceRangeSample_Bnd_Box_IntTools_SurfaceRangeSampleMapHasher self, Standard_Integer const N)

        ReSize

        :type N: int

        """
        return _IntTools.NCollection_DataMap_IntTools_SurfaceRangeSample_Bnd_Box_IntTools_SurfaceRangeSampleMapHasher_ReSize(self, *args)


    def Bind(self, *args):
        """
        Bind(NCollection_DataMap_IntTools_SurfaceRangeSample_Bnd_Box_IntTools_SurfaceRangeSampleMapHasher self, IntTools_SurfaceRangeSample theKey, Bnd_Box theItem) -> Standard_Boolean

        Bind binds Item to Key in map.
        @param theKey  key to add/update
        @param theItem new item; overrides value previously bound to the key, if any
        @return Standard_True if Key was not bound already

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntTools.NCollection_DataMap_IntTools_SurfaceRangeSample_Bnd_Box_IntTools_SurfaceRangeSampleMapHasher_Bind(self, *args)


    def Bound(self, *args):
        """
        Bound(NCollection_DataMap_IntTools_SurfaceRangeSample_Bnd_Box_IntTools_SurfaceRangeSampleMapHasher self, IntTools_SurfaceRangeSample theKey, Bnd_Box theItem) -> Bnd_Box

        Bound binds Item to Key in map. Returns modifiable Item 

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: TheItemType *

        """
        return _IntTools.NCollection_DataMap_IntTools_SurfaceRangeSample_Bnd_Box_IntTools_SurfaceRangeSampleMapHasher_Bound(self, *args)


    def IsBound(self, *args):
        """
        IsBound(NCollection_DataMap_IntTools_SurfaceRangeSample_Bnd_Box_IntTools_SurfaceRangeSampleMapHasher self, IntTools_SurfaceRangeSample theKey) -> Standard_Boolean

        IsBound

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntTools.NCollection_DataMap_IntTools_SurfaceRangeSample_Bnd_Box_IntTools_SurfaceRangeSampleMapHasher_IsBound(self, *args)


    def UnBind(self, *args):
        """
        UnBind(NCollection_DataMap_IntTools_SurfaceRangeSample_Bnd_Box_IntTools_SurfaceRangeSampleMapHasher self, IntTools_SurfaceRangeSample theKey) -> Standard_Boolean

        UnBind removes Item Key pair from map

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntTools.NCollection_DataMap_IntTools_SurfaceRangeSample_Bnd_Box_IntTools_SurfaceRangeSampleMapHasher_UnBind(self, *args)


    def Seek(self, *args):
        """
        Seek(NCollection_DataMap_IntTools_SurfaceRangeSample_Bnd_Box_IntTools_SurfaceRangeSampleMapHasher self, IntTools_SurfaceRangeSample theKey) -> Bnd_Box

        Seek returns pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: const TheItemType *

        """
        return _IntTools.NCollection_DataMap_IntTools_SurfaceRangeSample_Bnd_Box_IntTools_SurfaceRangeSampleMapHasher_Seek(self, *args)


    def Find(self, *args):
        """
        Find returns the Item for Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _IntTools.NCollection_DataMap_IntTools_SurfaceRangeSample_Bnd_Box_IntTools_SurfaceRangeSampleMapHasher_Find(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeSeek(self, *args):
        """
        ChangeSeek(NCollection_DataMap_IntTools_SurfaceRangeSample_Bnd_Box_IntTools_SurfaceRangeSampleMapHasher self, IntTools_SurfaceRangeSample theKey) -> Bnd_Box

        ChangeSeek returns modifiable pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: TheItemType *

        """
        return _IntTools.NCollection_DataMap_IntTools_SurfaceRangeSample_Bnd_Box_IntTools_SurfaceRangeSampleMapHasher_ChangeSeek(self, *args)


    def ChangeFind(self, *args):
        """
        ChangeFind(NCollection_DataMap_IntTools_SurfaceRangeSample_Bnd_Box_IntTools_SurfaceRangeSampleMapHasher self, IntTools_SurfaceRangeSample theKey) -> Bnd_Box

        ChangeFind returns mofifiable Item by Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: TheItemType &

        """
        return _IntTools.NCollection_DataMap_IntTools_SurfaceRangeSample_Bnd_Box_IntTools_SurfaceRangeSampleMapHasher_ChangeFind(self, *args)


    def __call__(self, *args):
        """
        operator ()

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _IntTools.NCollection_DataMap_IntTools_SurfaceRangeSample_Bnd_Box_IntTools_SurfaceRangeSampleMapHasher___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Clear(self, *args):
        """
        Clear(NCollection_DataMap_IntTools_SurfaceRangeSample_Bnd_Box_IntTools_SurfaceRangeSampleMapHasher self, Standard_Boolean const doReleaseMemory)
        Clear(NCollection_DataMap_IntTools_SurfaceRangeSample_Bnd_Box_IntTools_SurfaceRangeSampleMapHasher self, Handle_NCollection_BaseAllocator theAllocator)

        Clear data and reset allocator

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _IntTools.NCollection_DataMap_IntTools_SurfaceRangeSample_Bnd_Box_IntTools_SurfaceRangeSampleMapHasher_Clear(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_DataMap_IntTools_SurfaceRangeSample_Bnd_Box_IntTools_SurfaceRangeSampleMapHasher self) -> Standard_Integer

        Size

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntTools.NCollection_DataMap_IntTools_SurfaceRangeSample_Bnd_Box_IntTools_SurfaceRangeSampleMapHasher_Size(self, *args)


    def __iter__(self):
        return _IntTools.NCollection_DataMap_IntTools_SurfaceRangeSample_Bnd_Box_IntTools_SurfaceRangeSampleMapHasher___iter__(self)
    __swig_destroy__ = _IntTools.delete_NCollection_DataMap_IntTools_SurfaceRangeSample_Bnd_Box_IntTools_SurfaceRangeSampleMapHasher
NCollection_DataMap_IntTools_SurfaceRangeSample_Bnd_Box_IntTools_SurfaceRangeSampleMapHasher_swigregister = _IntTools.NCollection_DataMap_IntTools_SurfaceRangeSample_Bnd_Box_IntTools_SurfaceRangeSampleMapHasher_swigregister
NCollection_DataMap_IntTools_SurfaceRangeSample_Bnd_Box_IntTools_SurfaceRangeSampleMapHasher_swigregister(NCollection_DataMap_IntTools_SurfaceRangeSample_Bnd_Box_IntTools_SurfaceRangeSampleMapHasher)

class NCollection_DataMap_IntTools_SurfaceRangeSample_Bnd_Box_IntTools_SurfaceRangeSampleMapHasher_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _IntTools.new_NCollection_DataMap_IntTools_SurfaceRangeSample_Bnd_Box_IntTools_SurfaceRangeSampleMapHasher_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _IntTools.delete_NCollection_DataMap_IntTools_SurfaceRangeSample_Bnd_Box_IntTools_SurfaceRangeSampleMapHasher_IteratorHelper

    def __next__(self):
        return _IntTools.NCollection_DataMap_IntTools_SurfaceRangeSample_Bnd_Box_IntTools_SurfaceRangeSampleMapHasher_IteratorHelper___next__(self)
NCollection_DataMap_IntTools_SurfaceRangeSample_Bnd_Box_IntTools_SurfaceRangeSampleMapHasher_IteratorHelper_swigregister = _IntTools.NCollection_DataMap_IntTools_SurfaceRangeSample_Bnd_Box_IntTools_SurfaceRangeSampleMapHasher_IteratorHelper_swigregister
NCollection_DataMap_IntTools_SurfaceRangeSample_Bnd_Box_IntTools_SurfaceRangeSampleMapHasher_IteratorHelper_swigregister(NCollection_DataMap_IntTools_SurfaceRangeSample_Bnd_Box_IntTools_SurfaceRangeSampleMapHasher_IteratorHelper)


try:
	IntTools_DataMapOfSurfaceSampleBox = NCollection_DataMap_IntTools_SurfaceRangeSample_Bnd_Box_IntTools_SurfaceRangeSampleMapHasher
except NameError:
	pass # does not exist, probably ignored

class IntTools_TopolTool(Adaptor3d.Adaptor3d_TopolTool):
    """
    Class redefine methods of TopolTool from Adaptor3d
    concerning sample points
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_IntTools_TopolTool
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_IntTools_TopolTool(self) 
            return h


    def __init__(self, *args):
        """
        __init__(IntTools_TopolTool self) -> IntTools_TopolTool
        __init__(IntTools_TopolTool self, Handle_Adaptor3d_HSurface theSurface) -> IntTools_TopolTool

        Initializes me by surface

        :type theSurface: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface

        """
        this = _IntTools.new_IntTools_TopolTool(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Initialize(self, *args):
        """
        Initialize(IntTools_TopolTool self)
        Initialize(IntTools_TopolTool self, Handle_Adaptor3d_HSurface theSurface)

        Initializes me by surface

        :type theSurface: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface

        """
        return _IntTools.IntTools_TopolTool_Initialize(self, *args)


    def ComputeSamplePoints(self, *args):
        """ComputeSamplePoints(IntTools_TopolTool self)"""
        return _IntTools.IntTools_TopolTool_ComputeSamplePoints(self, *args)


    def NbSamplesU(self, *args):
        """
        NbSamplesU(IntTools_TopolTool self) -> Standard_Integer

        Computes the sample-points for the intersections algorithms

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntTools.IntTools_TopolTool_NbSamplesU(self, *args)


    def NbSamplesV(self, *args):
        """
        NbSamplesV(IntTools_TopolTool self) -> Standard_Integer

        Computes the sample-points for the intersections algorithms

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntTools.IntTools_TopolTool_NbSamplesV(self, *args)


    def NbSamples(self, *args):
        """
        NbSamples(IntTools_TopolTool self) -> Standard_Integer

        Computes the sample-points for the intersections algorithms

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntTools.IntTools_TopolTool_NbSamples(self, *args)


    def SamplePoint(self, *args):
        """
        SamplePoint(IntTools_TopolTool self, Standard_Integer const Index, gp_Pnt2d P2d, gp_Pnt P3d)

        Returns a 2d point from surface myS
        and a corresponded 3d point
        for given index.
        The index should be from 1 to NbSamples()

        :type Index: int
        :type P2d: OCC.wrapper.gp.gp_Pnt2d
        :type P3d: OCC.wrapper.gp.gp_Pnt

        """
        return _IntTools.IntTools_TopolTool_SamplePoint(self, *args)


    def SamplePnts(self, *args):
        """
        SamplePnts(IntTools_TopolTool self, Standard_Real const theDefl, Standard_Integer const theNUmin, Standard_Integer const theNVmin)

        compute the sample-points for the intersections algorithms
        by adaptive algorithm for BSpline surfaces. For other surfaces algorithm
        is the same as in method ComputeSamplePoints(), but only fill arrays of U
        and V sample parameters;
        theDefl is a requred deflection
        theNUmin, theNVmin are minimal nb points for U and V.

        :type theDefl: float
        :type theNUmin: int
        :type theNVmin: int

        """
        return _IntTools.IntTools_TopolTool_SamplePnts(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _IntTools.IntTools_TopolTool_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _IntTools.IntTools_TopolTool_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IntTools.IntTools_TopolTool_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _IntTools.delete_IntTools_TopolTool
IntTools_TopolTool_swigregister = _IntTools.IntTools_TopolTool_swigregister
IntTools_TopolTool_swigregister(IntTools_TopolTool)

def IntTools_TopolTool_get_type_name(*args):
    """
    IntTools_TopolTool_get_type_name() -> char const *

    :rtype: const char *

    """
    return _IntTools.IntTools_TopolTool_get_type_name(*args)

def IntTools_TopolTool_get_type_descriptor(*args):
    """
    IntTools_TopolTool_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _IntTools.IntTools_TopolTool_get_type_descriptor(*args)

class IntTools_Context(Standard.Standard_Transient):
    """
    The intersection Context contains geometrical
    and topological toolkit (classifiers, projectors, etc).
    The intersection Context is for caching the tools
    to increase the performance.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_IntTools_Context
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_IntTools_Context(self) 
            return h


    def __init__(self, *args):
        """
        __init__(IntTools_Context self) -> IntTools_Context
        __init__(IntTools_Context self, Handle_NCollection_BaseAllocator theAllocator) -> IntTools_Context

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        this = _IntTools.new_IntTools_Context(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def FClass2d(self, *args):
        """
        FClass2d(IntTools_Context self, TopoDS_Face aF) -> IntTools_FClass2d

        Returns a reference to point classifier
        for given face

        :type aF: OCC.wrapper.TopoDS.TopoDS_Face
        :rtype: OCC.wrapper.IntTools.IntTools_FClass2d

        """
        return _IntTools.IntTools_Context_FClass2d(self, *args)


    def ProjPS(self, *args):
        """
        ProjPS(IntTools_Context self, TopoDS_Face aF) -> GeomAPI_ProjectPointOnSurf

        Returns a reference to point projector
        for given face

        :type aF: OCC.wrapper.TopoDS.TopoDS_Face
        :rtype: OCC.wrapper.GeomAPI.GeomAPI_ProjectPointOnSurf

        """
        return _IntTools.IntTools_Context_ProjPS(self, *args)


    def ProjPC(self, *args):
        """
        ProjPC(IntTools_Context self, TopoDS_Edge aE) -> GeomAPI_ProjectPointOnCurve

        Returns a reference to point projector
        for given edge

        :type aE: OCC.wrapper.TopoDS.TopoDS_Edge
        :rtype: OCC.wrapper.GeomAPI.GeomAPI_ProjectPointOnCurve

        """
        return _IntTools.IntTools_Context_ProjPC(self, *args)


    def ProjPT(self, *args):
        """
        ProjPT(IntTools_Context self, Handle_Geom_Curve aC) -> GeomAPI_ProjectPointOnCurve

        Returns a reference to point projector
        for given curve

        :type aC: OCC.wrapper.Geom.Handle_Geom_Curve
        :rtype: OCC.wrapper.GeomAPI.GeomAPI_ProjectPointOnCurve

        """
        return _IntTools.IntTools_Context_ProjPT(self, *args)


    def SurfaceData(self, *args):
        """
        SurfaceData(IntTools_Context self, TopoDS_Face aF) -> IntTools_SurfaceRangeLocalizeData

        Returns a reference to surface localization data
        for given face

        :type aF: OCC.wrapper.TopoDS.TopoDS_Face
        :rtype: OCC.wrapper.IntTools.IntTools_SurfaceRangeLocalizeData

        """
        return _IntTools.IntTools_Context_SurfaceData(self, *args)


    def SolidClassifier(self, *args):
        """
        SolidClassifier(IntTools_Context self, TopoDS_Solid aSolid) -> BRepClass3d_SolidClassifier

        Returns a reference to solid classifier
        for given solid

        :type aSolid: OCC.wrapper.TopoDS.TopoDS_Solid
        :rtype: OCC.wrapper.BRepClass3d.BRepClass3d_SolidClassifier

        """
        return _IntTools.IntTools_Context_SolidClassifier(self, *args)


    def Hatcher(self, *args):
        """
        Hatcher(IntTools_Context self, TopoDS_Face aF) -> Geom2dHatch_Hatcher

        Returns a reference to 2D hatcher
        for given face

        :type aF: OCC.wrapper.TopoDS.TopoDS_Face
        :rtype: OCC.wrapper.Geom2dHatch.Geom2dHatch_Hatcher

        """
        return _IntTools.IntTools_Context_Hatcher(self, *args)


    def SurfaceAdaptor(self, *args):
        """
        SurfaceAdaptor(IntTools_Context self, TopoDS_Face theFace) -> BRepAdaptor_Surface

        Returns a reference to surface adaptor for given face

        :type theFace: OCC.wrapper.TopoDS.TopoDS_Face
        :rtype: OCC.wrapper.BRepAdaptor.BRepAdaptor_Surface

        """
        return _IntTools.IntTools_Context_SurfaceAdaptor(self, *args)


    def OBB(self, *args):
        """
        OBB(IntTools_Context self, TopoDS_Shape theShape, Standard_Real const theFuzzyValue) -> Bnd_OBB

        Builds and stores an Oriented Bounding Box for the shape.
        Returns a reference to OBB.

        :type theShape: OCC.wrapper.TopoDS.TopoDS_Shape
        :type theFuzzyValue: float
        :rtype: OCC.wrapper.Bnd.Bnd_OBB

        """
        return _IntTools.IntTools_Context_OBB(self, *args)


    def UVBounds(self, *args):
        """
        UVBounds(IntTools_Context self, TopoDS_Face theFace)

        Computes the boundaries of the face using surface adaptor

        :type theFace: OCC.wrapper.TopoDS.TopoDS_Face
        :type UMin: float
        :type UMax: float
        :type VMin: float
        :type VMax: float

        """
        return _IntTools.IntTools_Context_UVBounds(self, *args)


    def ComputePE(self, *args):
        """
        ComputePE(IntTools_Context self, gp_Pnt theP, Standard_Real const theTolP, TopoDS_Edge theE) -> Standard_Integer

        Computes parameter of the Point theP on
        the edge aE.
        Returns zero if the distance between point
        and edge is less than sum of tolerance value of edge and theTopP,
        otherwise and for following conditions returns
        negative value
        1. the edge is degenerated (-1)
        2. the edge does not contain 3d curve and pcurves (-2)
        3. projection algorithm failed (-3)

        :type theP: OCC.wrapper.gp.gp_Pnt
        :type theTolP: float
        :type theE: OCC.wrapper.TopoDS.TopoDS_Edge
        :type theT: float
        :type theDist: float
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntTools.IntTools_Context_ComputePE(self, *args)


    def ComputeVE(self, *args):
        """
        ComputeVE(IntTools_Context self, TopoDS_Vertex theV, TopoDS_Edge theE, Standard_Real const theFuzz) -> Standard_Integer

        Computes parameter of the vertex aV on
        the edge aE and correct tolerance value for 
        the vertex on the edge.
        Returns zero if the distance between vertex
        and edge is less than sum of tolerances and the fuzzy value,
        otherwise and for following conditions returns
        negative value: <br>
        1. the edge is degenerated (-1) <br>
        2. the edge does not contain 3d curve and pcurves (-2) <br>
        3. projection algorithm failed (-3)

        :type theV: OCC.wrapper.TopoDS.TopoDS_Vertex
        :type theE: OCC.wrapper.TopoDS.TopoDS_Edge
        :type theT: float
        :type theTol: float
        :type theFuzz: float
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntTools.IntTools_Context_ComputeVE(self, *args)


    def ComputeVF(self, *args):
        """
        ComputeVF(IntTools_Context self, TopoDS_Vertex theVertex, TopoDS_Face theFace, Standard_Real const theFuzz) -> Standard_Integer

        Computes UV parameters of the vertex aV on face aF
        and correct tolerance value for the vertex on the face.
        Returns zero if the distance between vertex and face is
        less than or equal the sum of tolerances and the fuzzy value 
        and the projection point lays inside boundaries of the face.
        For following conditions returns negative value <br>
        1. projection algorithm failed (-1) <br>
        2. distance is more than sum of tolerances (-2) <br>
        3. projection point out or on the boundaries of face (-3)

        :type theVertex: OCC.wrapper.TopoDS.TopoDS_Vertex
        :type theFace: OCC.wrapper.TopoDS.TopoDS_Face
        :type theU: float
        :type theV: float
        :type theTol: float
        :type theFuzz: float
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntTools.IntTools_Context_ComputeVF(self, *args)


    def StatePointFace(self, *args):
        """
        StatePointFace(IntTools_Context self, TopoDS_Face aF, gp_Pnt2d aP2D) -> TopAbs_State

        Returns the state of the point aP2D
        relative to face aF

        :type aF: OCC.wrapper.TopoDS.TopoDS_Face
        :type aP2D: OCC.wrapper.gp.gp_Pnt2d
        :rtype: OCC.wrapper.TopAbs.TopAbs_State

        """
        return _IntTools.IntTools_Context_StatePointFace(self, *args)


    def IsPointInFace(self, *args):
        """
        IsPointInFace(IntTools_Context self, TopoDS_Face aF, gp_Pnt2d aP2D) -> Standard_Boolean
        IsPointInFace(IntTools_Context self, gp_Pnt aP3D, TopoDS_Face aF, Standard_Real const aTol) -> Standard_Boolean

        Returns true if the point aP2D is
        inside the boundaries of the face aF,
        otherwise returns false

        :type aP3D: OCC.wrapper.gp.gp_Pnt
        :type aF: OCC.wrapper.TopoDS.TopoDS_Face
        :type aTol: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntTools.IntTools_Context_IsPointInFace(self, *args)


    def IsPointInOnFace(self, *args):
        """
        IsPointInOnFace(IntTools_Context self, TopoDS_Face aF, gp_Pnt2d aP2D) -> Standard_Boolean

        Returns true if the point aP2D is
        inside or on the boundaries of aF

        :type aF: OCC.wrapper.TopoDS.TopoDS_Face
        :type aP2D: OCC.wrapper.gp.gp_Pnt2d
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntTools.IntTools_Context_IsPointInOnFace(self, *args)


    def IsValidPointForFace(self, *args):
        """
        IsValidPointForFace(IntTools_Context self, gp_Pnt aP3D, TopoDS_Face aF, Standard_Real const aTol) -> Standard_Boolean

        Returns true if the distance between point aP3D
        and face aF is less or equal to tolerance aTol
        and projection point is inside or on the boundaries
        of the face aF

        :type aP3D: OCC.wrapper.gp.gp_Pnt
        :type aF: OCC.wrapper.TopoDS.TopoDS_Face
        :type aTol: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntTools.IntTools_Context_IsValidPointForFace(self, *args)


    def IsValidPointForFaces(self, *args):
        """
        IsValidPointForFaces(IntTools_Context self, gp_Pnt aP3D, TopoDS_Face aF1, TopoDS_Face aF2, Standard_Real const aTol) -> Standard_Boolean

        Returns true if IsValidPointForFace returns true
        for both face aF1 and aF2

        :type aP3D: OCC.wrapper.gp.gp_Pnt
        :type aF1: OCC.wrapper.TopoDS.TopoDS_Face
        :type aF2: OCC.wrapper.TopoDS.TopoDS_Face
        :type aTol: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntTools.IntTools_Context_IsValidPointForFaces(self, *args)


    def IsValidBlockForFace(self, *args):
        """
        IsValidBlockForFace(IntTools_Context self, Standard_Real const aT1, Standard_Real const aT2, IntTools_Curve aIC, TopoDS_Face aF, Standard_Real const aTol) -> Standard_Boolean

        Returns true if IsValidPointForFace returns true
        for some 3d point that lay on the curve aIC bounded by
        parameters aT1 and aT2

        :type aT1: float
        :type aT2: float
        :type aIC: OCC.wrapper.IntTools.IntTools_Curve
        :type aF: OCC.wrapper.TopoDS.TopoDS_Face
        :type aTol: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntTools.IntTools_Context_IsValidBlockForFace(self, *args)


    def IsValidBlockForFaces(self, *args):
        """
        IsValidBlockForFaces(IntTools_Context self, Standard_Real const aT1, Standard_Real const aT2, IntTools_Curve aIC, TopoDS_Face aF1, TopoDS_Face aF2, Standard_Real const aTol) -> Standard_Boolean

        Returns true if IsValidBlockForFace returns true
        for both faces aF1 and aF2

        :type aT1: float
        :type aT2: float
        :type aIC: OCC.wrapper.IntTools.IntTools_Curve
        :type aF1: OCC.wrapper.TopoDS.TopoDS_Face
        :type aF2: OCC.wrapper.TopoDS.TopoDS_Face
        :type aTol: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntTools.IntTools_Context_IsValidBlockForFaces(self, *args)


    def IsVertexOnLine(self, *args):
        """
        IsVertexOnLine(IntTools_Context self, TopoDS_Vertex aV, IntTools_Curve aIC, Standard_Real const aTolC) -> Standard_Boolean
        IsVertexOnLine(IntTools_Context self, TopoDS_Vertex aV, Standard_Real const aTolV, IntTools_Curve aIC, Standard_Real const aTolC) -> Standard_Boolean

        Computes parameter of the vertex aV on
        the curve aIC.
        Returns true if the distance between vertex and
        curve is less than sum of tolerance of aV and aTolC,
        otherwise or if projection algorithm failed
        returns false (in this case aT isn't significant)

        :type aV: OCC.wrapper.TopoDS.TopoDS_Vertex
        :type aTolV: float
        :type aIC: OCC.wrapper.IntTools.IntTools_Curve
        :type aTolC: float
        :type aT: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntTools.IntTools_Context_IsVertexOnLine(self, *args)


    def ProjectPointOnEdge(self, *args):
        """
        ProjectPointOnEdge(IntTools_Context self, gp_Pnt aP, TopoDS_Edge aE) -> Standard_Boolean

        Computes parameter of the point aP on
        the edge aE.
        Returns false if projection algorithm failed
        other wiese returns true.

        :type aP: OCC.wrapper.gp.gp_Pnt
        :type aE: OCC.wrapper.TopoDS.TopoDS_Edge
        :type aT: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntTools.IntTools_Context_ProjectPointOnEdge(self, *args)


    def BndBox(self, *args):
        """
        BndBox(IntTools_Context self, TopoDS_Shape theS) -> Bnd_Box

        :type theS: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.Bnd.Bnd_Box

        """
        return _IntTools.IntTools_Context_BndBox(self, *args)


    def IsInfiniteFace(self, *args):
        """
        IsInfiniteFace(IntTools_Context self, TopoDS_Face theFace) -> Standard_Boolean

        Returns true if the solid <theFace> has
        infinite bounds

        :type theFace: OCC.wrapper.TopoDS.TopoDS_Face
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntTools.IntTools_Context_IsInfiniteFace(self, *args)


    def SetPOnSProjectionTolerance(self, *args):
        """
        SetPOnSProjectionTolerance(IntTools_Context self, Standard_Real const theValue)

        Sets tolerance to be used for projection of point on surface.
        Clears map of already cached projectors in order to maintain
        correct value for all projectors

        :type theValue: float

        """
        return _IntTools.IntTools_Context_SetPOnSProjectionTolerance(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _IntTools.IntTools_Context_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _IntTools.IntTools_Context_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IntTools.IntTools_Context_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _IntTools.delete_IntTools_Context
IntTools_Context_swigregister = _IntTools.IntTools_Context_swigregister
IntTools_Context_swigregister(IntTools_Context)

def IntTools_Context_get_type_name(*args):
    """
    IntTools_Context_get_type_name() -> char const *

    :rtype: const char *

    """
    return _IntTools.IntTools_Context_get_type_name(*args)

def IntTools_Context_get_type_descriptor(*args):
    """
    IntTools_Context_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _IntTools.IntTools_Context_get_type_descriptor(*args)

class IntTools_MarkedRangeSet(object):
    """class MarkedRangeSet provides continuous set of ranges marked with flags"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(IntTools_MarkedRangeSet self) -> IntTools_MarkedRangeSet
        __init__(IntTools_MarkedRangeSet self, Standard_Real const theFirstBoundary, Standard_Real const theLastBoundary, Standard_Integer const theInitFlag) -> IntTools_MarkedRangeSet
        __init__(IntTools_MarkedRangeSet self, IntTools_CArray1OfReal theSortedArray, Standard_Integer const theInitFlag) -> IntTools_MarkedRangeSet

        Build set of ranges based on the array of progressive sorted values

        Warning:
        The constructor do not check if the values of array are not sorted
        It should be checked before function invocation

        :type theSortedArray: OCC.wrapper.IntTools.IntTools_CArray1OfReal
        :type theInitFlag: int

        """
        this = _IntTools.new_IntTools_MarkedRangeSet(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def SetBoundaries(self, *args):
        """
        SetBoundaries(IntTools_MarkedRangeSet self, Standard_Real const theFirstBoundary, Standard_Real const theLastBoundary, Standard_Integer const theInitFlag)

        build set of ranges which consists of one range with
        boundary values theFirstBoundary and theLastBoundary

        :type theFirstBoundary: float
        :type theLastBoundary: float
        :type theInitFlag: int

        """
        return _IntTools.IntTools_MarkedRangeSet_SetBoundaries(self, *args)


    def SetRanges(self, *args):
        """
        SetRanges(IntTools_MarkedRangeSet self, IntTools_CArray1OfReal theSortedArray, Standard_Integer const theInitFlag)

        Build set of ranges based on the array of progressive sorted values

        Warning:
        The function do not check if the values of array are not sorted
        It should be checked before function invocation

        :type theSortedArray: OCC.wrapper.IntTools.IntTools_CArray1OfReal
        :type theInitFlag: int

        """
        return _IntTools.IntTools_MarkedRangeSet_SetRanges(self, *args)


    def InsertRange(self, *args):
        """
        InsertRange(IntTools_MarkedRangeSet self, Standard_Real const theFirstBoundary, Standard_Real const theLastBoundary, Standard_Integer const theFlag) -> Standard_Boolean
        InsertRange(IntTools_MarkedRangeSet self, IntTools_Range theRange, Standard_Integer const theFlag) -> Standard_Boolean
        InsertRange(IntTools_MarkedRangeSet self, Standard_Real const theFirstBoundary, Standard_Real const theLastBoundary, Standard_Integer const theFlag, Standard_Integer const theIndex) -> Standard_Boolean
        InsertRange(IntTools_MarkedRangeSet self, IntTools_Range theRange, Standard_Integer const theFlag, Standard_Integer const theIndex) -> Standard_Boolean

        Inserts a new range marked with flag theFlag
        It replace the existing ranges or parts of ranges
        and their flags.
        The index theIndex is a position where the range will be inserted.
        Returns True if the range is inside the initial boundaries,
        otherwise or in case of some error returns False

        :type theRange: OCC.wrapper.IntTools.IntTools_Range
        :type theFlag: int
        :type theIndex: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntTools.IntTools_MarkedRangeSet_InsertRange(self, *args)


    def SetFlag(self, *args):
        """
        SetFlag(IntTools_MarkedRangeSet self, Standard_Integer const theIndex, Standard_Integer const theFlag)

        Set flag theFlag for range with index theIndex

        :type theIndex: int
        :type theFlag: int

        """
        return _IntTools.IntTools_MarkedRangeSet_SetFlag(self, *args)


    def Flag(self, *args):
        """
        Flag(IntTools_MarkedRangeSet self, Standard_Integer const theIndex) -> Standard_Integer

        Returns flag of the range with index theIndex

        :type theIndex: int
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntTools.IntTools_MarkedRangeSet_Flag(self, *args)


    def GetIndices(self, *args):
        """
        :type theValue: float
        :rtype: OCC.wrapper.TColStd.TColStd_SequenceOfInteger

        """
        res = _IntTools.IntTools_MarkedRangeSet_GetIndices(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def GetIndex(self, *args):
        """
        GetIndex(IntTools_MarkedRangeSet self, Standard_Real const theValue) -> Standard_Integer
        GetIndex(IntTools_MarkedRangeSet self, Standard_Real const theValue, Standard_Boolean const UseLower) -> Standard_Integer

        Returns index of range which contains theValue
        If theValue do not belong any range returns 0.
        If UseLower is Standard_True then lower boundary of the range
        can be equal to theValue, otherwise upper boundary of the range
        can be equal to theValue.

        :type theValue: float
        :type UseLower: bool
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntTools.IntTools_MarkedRangeSet_GetIndex(self, *args)


    def Length(self, *args):
        """
        Length(IntTools_MarkedRangeSet self) -> Standard_Integer

        Returns number of ranges

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntTools.IntTools_MarkedRangeSet_Length(self, *args)


    def Range(self, *args):
        """
        Range(IntTools_MarkedRangeSet self, Standard_Integer const theIndex) -> IntTools_Range

        Returns the range with index theIndex.
        the Index can be from 1 to Length()

        :type theIndex: int
        :rtype: OCC.wrapper.IntTools.IntTools_Range

        """
        return _IntTools.IntTools_MarkedRangeSet_Range(self, *args)

    __swig_destroy__ = _IntTools.delete_IntTools_MarkedRangeSet
IntTools_MarkedRangeSet_swigregister = _IntTools.IntTools_MarkedRangeSet_swigregister
IntTools_MarkedRangeSet_swigregister(IntTools_MarkedRangeSet)

class Handle_IntTools_TopolTool(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_IntTools_TopolTool self)

        Nullify the handle


        """
        return _IntTools.Handle_IntTools_TopolTool_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_IntTools_TopolTool self) -> bool

        Check for being null

        :rtype: bool

        """
        return _IntTools.Handle_IntTools_TopolTool_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_IntTools_TopolTool self, IntTools_TopolTool thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _IntTools.Handle_IntTools_TopolTool_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_IntTools_TopolTool self, Handle_IntTools_TopolTool theHandle) -> Handle_IntTools_TopolTool
        assign(Handle_IntTools_TopolTool self, IntTools_TopolTool thePtr) -> Handle_IntTools_TopolTool
        assign(Handle_IntTools_TopolTool self, Handle_IntTools_TopolTool theHandle) -> Handle_IntTools_TopolTool

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _IntTools.Handle_IntTools_TopolTool_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_IntTools_TopolTool self) -> IntTools_TopolTool

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _IntTools.Handle_IntTools_TopolTool_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_IntTools_TopolTool self) -> IntTools_TopolTool

        Member access operator (note non-const)

        :rtype: T *

        """
        return _IntTools.Handle_IntTools_TopolTool___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_IntTools_TopolTool self) -> IntTools_TopolTool

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _IntTools.Handle_IntTools_TopolTool___ref__(self, *args)


    def __hash__(self):
        return _IntTools.Handle_IntTools_TopolTool___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _IntTools.Handle_IntTools_TopolTool___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _IntTools.new_Handle_IntTools_TopolTool(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_IntTools.Handle_IntTools_TopolTool_DownCast)
    __swig_destroy__ = _IntTools.delete_Handle_IntTools_TopolTool

    def Initialize(self, *args):
        """
        Initialize(Handle_IntTools_TopolTool self)
        Initialize(Handle_IntTools_TopolTool self, Handle_Adaptor3d_HSurface theSurface)

        Initializes me by surface

        :type theSurface: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface

        """
        return _IntTools.Handle_IntTools_TopolTool_Initialize(self, *args)


    def ComputeSamplePoints(self, *args):
        """ComputeSamplePoints(Handle_IntTools_TopolTool self)"""
        return _IntTools.Handle_IntTools_TopolTool_ComputeSamplePoints(self, *args)


    def NbSamplesU(self, *args):
        """
        NbSamplesU(Handle_IntTools_TopolTool self) -> Standard_Integer

        Computes the sample-points for the intersections algorithms

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntTools.Handle_IntTools_TopolTool_NbSamplesU(self, *args)


    def NbSamplesV(self, *args):
        """
        NbSamplesV(Handle_IntTools_TopolTool self) -> Standard_Integer

        Computes the sample-points for the intersections algorithms

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntTools.Handle_IntTools_TopolTool_NbSamplesV(self, *args)


    def NbSamples(self, *args):
        """
        NbSamples(Handle_IntTools_TopolTool self) -> Standard_Integer

        Computes the sample-points for the intersections algorithms

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntTools.Handle_IntTools_TopolTool_NbSamples(self, *args)


    def SamplePoint(self, *args):
        """
        SamplePoint(Handle_IntTools_TopolTool self, Standard_Integer const Index, gp_Pnt2d P2d, gp_Pnt P3d)

        Returns a 2d point from surface myS
        and a corresponded 3d point
        for given index.
        The index should be from 1 to NbSamples()

        :type Index: int
        :type P2d: OCC.wrapper.gp.gp_Pnt2d
        :type P3d: OCC.wrapper.gp.gp_Pnt

        """
        return _IntTools.Handle_IntTools_TopolTool_SamplePoint(self, *args)


    def SamplePnts(self, *args):
        """
        SamplePnts(Handle_IntTools_TopolTool self, Standard_Real const theDefl, Standard_Integer const theNUmin, Standard_Integer const theNVmin)

        compute the sample-points for the intersections algorithms
        by adaptive algorithm for BSpline surfaces. For other surfaces algorithm
        is the same as in method ComputeSamplePoints(), but only fill arrays of U
        and V sample parameters;
        theDefl is a requred deflection
        theNUmin, theNVmin are minimal nb points for U and V.

        :type theDefl: float
        :type theNUmin: int
        :type theNVmin: int

        """
        return _IntTools.Handle_IntTools_TopolTool_SamplePnts(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_IntTools_TopolTool self) -> char const *

        :rtype: const char *

        """
        return _IntTools.Handle_IntTools_TopolTool_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IntTools.Handle_IntTools_TopolTool_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IntTools.Handle_IntTools_TopolTool_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Init(self, *args):
        """Init(Handle_IntTools_TopolTool self)"""
        return _IntTools.Handle_IntTools_TopolTool_Init(self, *args)


    def More(self, *args):
        """
        More(Handle_IntTools_TopolTool self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntTools.Handle_IntTools_TopolTool_More(self, *args)


    def Value(self, *args):
        """
        Value(Handle_IntTools_TopolTool self) -> Handle_Adaptor2d_HCurve2d

        :rtype: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d

        """
        return _IntTools.Handle_IntTools_TopolTool_Value(self, *args)


    def Next(self, *args):
        """Next(Handle_IntTools_TopolTool self)"""
        return _IntTools.Handle_IntTools_TopolTool_Next(self, *args)


    def InitVertexIterator(self, *args):
        """InitVertexIterator(Handle_IntTools_TopolTool self)"""
        return _IntTools.Handle_IntTools_TopolTool_InitVertexIterator(self, *args)


    def MoreVertex(self, *args):
        """
        MoreVertex(Handle_IntTools_TopolTool self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntTools.Handle_IntTools_TopolTool_MoreVertex(self, *args)


    def Vertex(self, *args):
        """
        Vertex(Handle_IntTools_TopolTool self) -> Handle_Adaptor3d_HVertex

        :rtype: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HVertex

        """
        return _IntTools.Handle_IntTools_TopolTool_Vertex(self, *args)


    def NextVertex(self, *args):
        """NextVertex(Handle_IntTools_TopolTool self)"""
        return _IntTools.Handle_IntTools_TopolTool_NextVertex(self, *args)


    def Classify(self, *args):
        """
        Classify(Handle_IntTools_TopolTool self, gp_Pnt2d P, Standard_Real const Tol, Standard_Boolean const ReacdreOnPeriodic) -> TopAbs_State

        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type Tol: float
        :type ReacdreOnPeriodic: bool
        :rtype: OCC.wrapper.TopAbs.TopAbs_State

        """
        return _IntTools.Handle_IntTools_TopolTool_Classify(self, *args)


    def IsThePointOn(self, *args):
        """
        IsThePointOn(Handle_IntTools_TopolTool self, gp_Pnt2d P, Standard_Real const Tol, Standard_Boolean const ReacdreOnPeriodic) -> Standard_Boolean

        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type Tol: float
        :type ReacdreOnPeriodic: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntTools.Handle_IntTools_TopolTool_IsThePointOn(self, *args)


    def Orientation(self, *args):
        """
        Orientation(Handle_IntTools_TopolTool self, Handle_Adaptor2d_HCurve2d C) -> TopAbs_Orientation
        Orientation(Handle_IntTools_TopolTool self, Handle_Adaptor3d_HVertex V) -> TopAbs_Orientation

        Returns the orientation of the vertex V.
        The vertex has been found with an exploration on
        a given arc. The orientation is the orientation
        of the vertex on this arc.

        :type V: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HVertex
        :rtype: OCC.wrapper.TopAbs.TopAbs_Orientation

        """
        return _IntTools.Handle_IntTools_TopolTool_Orientation(self, *args)


    def Identical(self, *args):
        """
        Identical(Handle_IntTools_TopolTool self, Handle_Adaptor3d_HVertex V1, Handle_Adaptor3d_HVertex V2) -> Standard_Boolean

        Returns True if the vertices V1 and V2 are identical.
        This method does not take the orientation of the
        vertices in account.

        :type V1: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HVertex
        :type V2: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HVertex
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntTools.Handle_IntTools_TopolTool_Identical(self, *args)


    def Has3d(self, *args):
        """
        Has3d(Handle_IntTools_TopolTool self) -> Standard_Boolean

        answers if arcs and vertices may have 3d representations,
        so that we could use Tol3d and Pnt methods.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntTools.Handle_IntTools_TopolTool_Has3d(self, *args)


    def Tol3d(self, *args):
        """
        Tol3d(Handle_IntTools_TopolTool self, Handle_Adaptor2d_HCurve2d C) -> Standard_Real
        Tol3d(Handle_IntTools_TopolTool self, Handle_Adaptor3d_HVertex V) -> Standard_Real

        returns 3d tolerance of the vertex V

        :type V: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HVertex
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _IntTools.Handle_IntTools_TopolTool_Tol3d(self, *args)


    def Pnt(self, *args):
        """
        Pnt(Handle_IntTools_TopolTool self, Handle_Adaptor3d_HVertex V) -> gp_Pnt

        returns 3d point of the vertex V

        :type V: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HVertex
        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _IntTools.Handle_IntTools_TopolTool_Pnt(self, *args)


    def UParameters(self, *args):
        """
        UParameters(Handle_IntTools_TopolTool self, NCollection_Array1_Standard_Real theArray)

        return the set of U parameters on the surface
        obtained by the method SamplePnts

        :type theArray: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        return _IntTools.Handle_IntTools_TopolTool_UParameters(self, *args)


    def VParameters(self, *args):
        """
        VParameters(Handle_IntTools_TopolTool self, NCollection_Array1_Standard_Real theArray)

        return the set of V parameters on the surface
        obtained by the method SamplePnts

        :type theArray: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        return _IntTools.Handle_IntTools_TopolTool_VParameters(self, *args)


    def DomainIsInfinite(self, *args):
        """
        DomainIsInfinite(Handle_IntTools_TopolTool self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntTools.Handle_IntTools_TopolTool_DomainIsInfinite(self, *args)


    def Edge(self, *args):
        """
        Edge(Handle_IntTools_TopolTool self) -> Standard_Address

        :rtype: OCC.wrapper.Standard.Standard_Address

        """
        return _IntTools.Handle_IntTools_TopolTool_Edge(self, *args)


    def BSplSamplePnts(self, *args):
        """
        BSplSamplePnts(Handle_IntTools_TopolTool self, Standard_Real const theDefl, Standard_Integer const theNUmin, Standard_Integer const theNVmin)

        compute the sample-points for the intersections algorithms
        by adaptive algorithm for BSpline surfaces  -  is  used  in  SamplePnts
        theDefl is a requred deflection
        theNUmin, theNVmin are minimal nb points for U and V.

        :type theDefl: float
        :type theNUmin: int
        :type theNVmin: int

        """
        return _IntTools.Handle_IntTools_TopolTool_BSplSamplePnts(self, *args)


    def IsUniformSampling(self, *args):
        """
        IsUniformSampling(Handle_IntTools_TopolTool self) -> Standard_Boolean

        Returns true if provide uniform sampling of points.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntTools.Handle_IntTools_TopolTool_IsUniformSampling(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_IntTools_TopolTool self)

        Memory deallocator for transient classes


        """
        return _IntTools.Handle_IntTools_TopolTool_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_IntTools_TopolTool self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_IntTools_TopolTool self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntTools.Handle_IntTools_TopolTool_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_IntTools_TopolTool self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_IntTools_TopolTool self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntTools.Handle_IntTools_TopolTool_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_IntTools_TopolTool self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _IntTools.Handle_IntTools_TopolTool_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_IntTools_TopolTool self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntTools.Handle_IntTools_TopolTool_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_IntTools_TopolTool self)

        Increments the reference counter of this object


        """
        return _IntTools.Handle_IntTools_TopolTool_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_IntTools_TopolTool self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntTools.Handle_IntTools_TopolTool_DecrementRefCounter(self, *args)

Handle_IntTools_TopolTool_swigregister = _IntTools.Handle_IntTools_TopolTool_swigregister
Handle_IntTools_TopolTool_swigregister(Handle_IntTools_TopolTool)

def Handle_IntTools_TopolTool_DownCast(thing):
    return _IntTools.Handle_IntTools_TopolTool_DownCast(thing)
Handle_IntTools_TopolTool_DownCast = _IntTools.Handle_IntTools_TopolTool_DownCast

class IntTools_CurveRangeSampleMapHasher(object):
    """class for range index management of curve"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def HashCode(*args):
        """
        HashCode(IntTools_CurveRangeSample K, Standard_Integer const Upper) -> Standard_Integer

        Returns a HasCode value  for  the  Key <K>  in the
        range 0..Upper.

        :type K: OCC.wrapper.IntTools.IntTools_CurveRangeSample
        :type Upper: int
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntTools.IntTools_CurveRangeSampleMapHasher_HashCode(*args)

    HashCode = staticmethod(HashCode)

    def IsEqual(*args):
        """
        IsEqual(IntTools_CurveRangeSample S1, IntTools_CurveRangeSample S2) -> Standard_Boolean

        Returns True  when the two  keys are the same. Two
        same  keys  must   have  the  same  hashcode,  the
        contrary is not necessary.

        :type S1: OCC.wrapper.IntTools.IntTools_CurveRangeSample
        :type S2: OCC.wrapper.IntTools.IntTools_CurveRangeSample
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntTools.IntTools_CurveRangeSampleMapHasher_IsEqual(*args)

    IsEqual = staticmethod(IsEqual)

    def __init__(self):
        """class for range index management of curve"""
        this = _IntTools.new_IntTools_CurveRangeSampleMapHasher()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _IntTools.delete_IntTools_CurveRangeSampleMapHasher
IntTools_CurveRangeSampleMapHasher_swigregister = _IntTools.IntTools_CurveRangeSampleMapHasher_swigregister
IntTools_CurveRangeSampleMapHasher_swigregister(IntTools_CurveRangeSampleMapHasher)

def IntTools_CurveRangeSampleMapHasher_HashCode(*args):
    """
    IntTools_CurveRangeSampleMapHasher_HashCode(IntTools_CurveRangeSample K, Standard_Integer const Upper) -> Standard_Integer

    Returns a HasCode value  for  the  Key <K>  in the
    range 0..Upper.

    :type K: OCC.wrapper.IntTools.IntTools_CurveRangeSample
    :type Upper: int
    :rtype: OCC.wrapper.Standard.Standard_Integer

    """
    return _IntTools.IntTools_CurveRangeSampleMapHasher_HashCode(*args)

def IntTools_CurveRangeSampleMapHasher_IsEqual(*args):
    """
    IntTools_CurveRangeSampleMapHasher_IsEqual(IntTools_CurveRangeSample S1, IntTools_CurveRangeSample S2) -> Standard_Boolean

    Returns True  when the two  keys are the same. Two
    same  keys  must   have  the  same  hashcode,  the
    contrary is not necessary.

    :type S1: OCC.wrapper.IntTools.IntTools_CurveRangeSample
    :type S2: OCC.wrapper.IntTools.IntTools_CurveRangeSample
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _IntTools.IntTools_CurveRangeSampleMapHasher_IsEqual(*args)

class IntTools_(object):
    """
    Contains classes for intersection and classification
    purposes and accompanying classes
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Length(*args):
        """
        Length(TopoDS_Edge E) -> Standard_Real

        returns the length of the edge;

        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _IntTools.IntTools__Length(*args)

    Length = staticmethod(Length)

    def RemoveIdenticalRoots(*args):
        """
        RemoveIdenticalRoots(NCollection_Sequence_IntTools_Root aSeq, Standard_Real const anEpsT)

        Remove from  the  sequence aSeq the Roots  that  have
        values ti and tj such as  |ti-tj]  <  anEpsT.

        :type aSeq: OCC.wrapper.IntTools.IntTools_SequenceOfRoots
        :type anEpsT: float

        """
        return _IntTools.IntTools__RemoveIdenticalRoots(*args)

    RemoveIdenticalRoots = staticmethod(RemoveIdenticalRoots)

    def SortRoots(*args):
        """
        SortRoots(NCollection_Sequence_IntTools_Root aSeq, Standard_Real const anEpsT)

        Sort the sequence aSeq of the Roots to arrange the
        Roons  in  increasing  order

        :type aSeq: OCC.wrapper.IntTools.IntTools_SequenceOfRoots
        :type anEpsT: float

        """
        return _IntTools.IntTools__SortRoots(*args)

    SortRoots = staticmethod(SortRoots)

    def FindRootStates(*args):
        """
        FindRootStates(NCollection_Sequence_IntTools_Root aSeq, Standard_Real const anEpsNull)

        Find the states (before  and  after) for  each  Root
        from  the sequence aSeq

        :type aSeq: OCC.wrapper.IntTools.IntTools_SequenceOfRoots
        :type anEpsNull: float

        """
        return _IntTools.IntTools__FindRootStates(*args)

    FindRootStates = staticmethod(FindRootStates)

    def Parameter(*args):
        """
        Parameter(gp_Pnt P, Handle_Geom_Curve Curve) -> Standard_Integer

        :type P: OCC.wrapper.gp.gp_Pnt
        :type Curve: OCC.wrapper.Geom.Handle_Geom_Curve
        :type aParm: float
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntTools.IntTools__Parameter(*args)

    Parameter = staticmethod(Parameter)

    def GetRadius(*args):
        """
        GetRadius(BRepAdaptor_Curve C, Standard_Real const t1, Standard_Real const t3) -> Standard_Integer

        :type C: OCC.wrapper.BRepAdaptor.BRepAdaptor_Curve
        :type t1: float
        :type t3: float
        :type R: float
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntTools.IntTools__GetRadius(*args)

    GetRadius = staticmethod(GetRadius)

    def PrepareArgs(*args):
        """
        PrepareArgs(BRepAdaptor_Curve C, Standard_Real const tMax, Standard_Real const tMin, Standard_Integer const Discret, Standard_Real const Deflect, IntTools_CArray1OfReal anArgs) -> Standard_Integer

        :type C: OCC.wrapper.BRepAdaptor.BRepAdaptor_Curve
        :type tMax: float
        :type tMin: float
        :type Discret: int
        :type Deflect: float
        :type anArgs: OCC.wrapper.IntTools.IntTools_CArray1OfReal
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntTools.IntTools__PrepareArgs(*args)

    PrepareArgs = staticmethod(PrepareArgs)

    def __init__(self):
        """
        Contains classes for intersection and classification
        purposes and accompanying classes
        """
        this = _IntTools.new_IntTools_()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _IntTools.delete_IntTools_
IntTools__swigregister = _IntTools.IntTools__swigregister
IntTools__swigregister(IntTools_)

def IntTools__Length(*args):
    """
    IntTools__Length(TopoDS_Edge E) -> Standard_Real

    returns the length of the edge;

    :type E: OCC.wrapper.TopoDS.TopoDS_Edge
    :rtype: OCC.wrapper.Standard.Standard_Real

    """
    return _IntTools.IntTools__Length(*args)

def IntTools__RemoveIdenticalRoots(*args):
    """
    IntTools__RemoveIdenticalRoots(NCollection_Sequence_IntTools_Root aSeq, Standard_Real const anEpsT)

    Remove from  the  sequence aSeq the Roots  that  have
    values ti and tj such as  |ti-tj]  <  anEpsT.

    :type aSeq: OCC.wrapper.IntTools.IntTools_SequenceOfRoots
    :type anEpsT: float

    """
    return _IntTools.IntTools__RemoveIdenticalRoots(*args)

def IntTools__SortRoots(*args):
    """
    IntTools__SortRoots(NCollection_Sequence_IntTools_Root aSeq, Standard_Real const anEpsT)

    Sort the sequence aSeq of the Roots to arrange the
    Roons  in  increasing  order

    :type aSeq: OCC.wrapper.IntTools.IntTools_SequenceOfRoots
    :type anEpsT: float

    """
    return _IntTools.IntTools__SortRoots(*args)

def IntTools__FindRootStates(*args):
    """
    IntTools__FindRootStates(NCollection_Sequence_IntTools_Root aSeq, Standard_Real const anEpsNull)

    Find the states (before  and  after) for  each  Root
    from  the sequence aSeq

    :type aSeq: OCC.wrapper.IntTools.IntTools_SequenceOfRoots
    :type anEpsNull: float

    """
    return _IntTools.IntTools__FindRootStates(*args)

def IntTools__Parameter(*args):
    """
    IntTools__Parameter(gp_Pnt P, Handle_Geom_Curve Curve) -> Standard_Integer

    :type P: OCC.wrapper.gp.gp_Pnt
    :type Curve: OCC.wrapper.Geom.Handle_Geom_Curve
    :type aParm: float
    :rtype: OCC.wrapper.Standard.Standard_Integer

    """
    return _IntTools.IntTools__Parameter(*args)

def IntTools__GetRadius(*args):
    """
    IntTools__GetRadius(BRepAdaptor_Curve C, Standard_Real const t1, Standard_Real const t3) -> Standard_Integer

    :type C: OCC.wrapper.BRepAdaptor.BRepAdaptor_Curve
    :type t1: float
    :type t3: float
    :type R: float
    :rtype: OCC.wrapper.Standard.Standard_Integer

    """
    return _IntTools.IntTools__GetRadius(*args)

def IntTools__PrepareArgs(*args):
    """
    IntTools__PrepareArgs(BRepAdaptor_Curve C, Standard_Real const tMax, Standard_Real const tMin, Standard_Integer const Discret, Standard_Real const Deflect, IntTools_CArray1OfReal anArgs) -> Standard_Integer

    :type C: OCC.wrapper.BRepAdaptor.BRepAdaptor_Curve
    :type tMax: float
    :type tMin: float
    :type Discret: int
    :type Deflect: float
    :type anArgs: OCC.wrapper.IntTools.IntTools_CArray1OfReal
    :rtype: OCC.wrapper.Standard.Standard_Integer

    """
    return _IntTools.IntTools__PrepareArgs(*args)

class IntTools_BaseRangeSample(object):
    """base class for range index management"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(IntTools_BaseRangeSample self) -> IntTools_BaseRangeSample
        __init__(IntTools_BaseRangeSample self, Standard_Integer const theDepth) -> IntTools_BaseRangeSample

        :type theDepth: int

        """
        this = _IntTools.new_IntTools_BaseRangeSample(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def SetDepth(self, *args):
        """
        SetDepth(IntTools_BaseRangeSample self, Standard_Integer const theDepth)

        :type theDepth: int

        """
        return _IntTools.IntTools_BaseRangeSample_SetDepth(self, *args)


    def GetDepth(self, *args):
        """
        GetDepth(IntTools_BaseRangeSample self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntTools.IntTools_BaseRangeSample_GetDepth(self, *args)

    __swig_destroy__ = _IntTools.delete_IntTools_BaseRangeSample
IntTools_BaseRangeSample_swigregister = _IntTools.IntTools_BaseRangeSample_swigregister
IntTools_BaseRangeSample_swigregister(IntTools_BaseRangeSample)

class NCollection_Sequence_IntTools_Range(NCollection.NCollection_BaseSequence):
    """
    Purpose:     Definition of a sequence of elements indexed by
    an Integer in range of 1..n
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Sequence_IntTools_Range self) -> NCollection_Sequence< IntTools_Range >::iterator

        Returns an iterator pointing to the first element in the sequence.

        :rtype: iterator

        """
        return _IntTools.NCollection_Sequence_IntTools_Range_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Sequence_IntTools_Range self) -> NCollection_Sequence< IntTools_Range >::iterator

        Returns an iterator referring to the past-the-end element in the sequence.

        :rtype: iterator

        """
        return _IntTools.NCollection_Sequence_IntTools_Range_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Sequence_IntTools_Range self) -> NCollection_Sequence< IntTools_Range >::const_iterator

        Returns a const iterator pointing to the first element in the sequence.

        :rtype: const_iterator

        """
        return _IntTools.NCollection_Sequence_IntTools_Range_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Sequence_IntTools_Range self) -> NCollection_Sequence< IntTools_Range >::const_iterator

        Returns a const iterator referring to the past-the-end element in the sequence.

        :rtype: const_iterator

        """
        return _IntTools.NCollection_Sequence_IntTools_Range_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     Definition of a sequence of elements indexed by
        an Integer in range of 1..n
        """
        this = _IntTools.new_NCollection_Sequence_IntTools_Range(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Size(self, *args):
        """
        Size(NCollection_Sequence_IntTools_Range self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntTools.NCollection_Sequence_IntTools_Range_Size(self, *args)


    def Length(self, *args):
        """
        Length(NCollection_Sequence_IntTools_Range self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntTools.NCollection_Sequence_IntTools_Range_Length(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Sequence_IntTools_Range self) -> Standard_Integer

        Method for consistency with other collections.
        @return Lower bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntTools.NCollection_Sequence_IntTools_Range_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Sequence_IntTools_Range self) -> Standard_Integer

        Method for consistency with other collections.
        @return Upper bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntTools.NCollection_Sequence_IntTools_Range_Upper(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Sequence_IntTools_Range self) -> Standard_Boolean

        Empty query

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntTools.NCollection_Sequence_IntTools_Range_IsEmpty(self, *args)


    def Reverse(self, *args):
        """
        Reverse(NCollection_Sequence_IntTools_Range self)

        Reverse sequence


        """
        return _IntTools.NCollection_Sequence_IntTools_Range_Reverse(self, *args)


    def Exchange(self, *args):
        """
        Exchange(NCollection_Sequence_IntTools_Range self, Standard_Integer const I, Standard_Integer const J)

        Exchange two members

        :type I: int
        :type J: int

        """
        return _IntTools.NCollection_Sequence_IntTools_Range_Exchange(self, *args)


    def delNode(*args):
        """
        delNode(NCollection_SeqNode theNode, Handle_NCollection_BaseAllocator theAl)

        Static deleter to be passed to BaseSequence

        :type theNode: OCC.wrapper.NCollection.NCollection_SeqNode
        :type theAl: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _IntTools.NCollection_Sequence_IntTools_Range_delNode(*args)

    delNode = staticmethod(delNode)

    def Clear(self, *args):
        """
        Clear(NCollection_Sequence_IntTools_Range self, Handle_NCollection_BaseAllocator theAllocator=0)

        Clear the items out, take a new allocator if non null

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _IntTools.NCollection_Sequence_IntTools_Range_Clear(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Sequence_IntTools_Range self, NCollection_Sequence_IntTools_Range theOther) -> NCollection_Sequence_IntTools_Range

        Replace this sequence by the items of theOther.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_Sequence
        :rtype: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _IntTools.NCollection_Sequence_IntTools_Range_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Sequence_IntTools_Range self, NCollection_Sequence_IntTools_Range theOther) -> NCollection_Sequence_IntTools_Range

        Replacement operator

        :type theOther: OCC.wrapper.NCollection.NCollection_Sequence
        :rtype: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _IntTools.NCollection_Sequence_IntTools_Range_assign(self, *args)


    def Remove(self, *args):
        """
        Remove(NCollection_Sequence_IntTools_Range self, NCollection_Sequence< IntTools_Range >::Iterator & thePosition)
        Remove(NCollection_Sequence_IntTools_Range self, Standard_Integer const theIndex)
        Remove(NCollection_Sequence_IntTools_Range self, Standard_Integer const theFromIndex, Standard_Integer const theToIndex)

        Remove range of items

        :type theFromIndex: int
        :type theToIndex: int

        """
        return _IntTools.NCollection_Sequence_IntTools_Range_Remove(self, *args)


    def Append(self, *args):
        """
        Append(NCollection_Sequence_IntTools_Range self, IntTools_Range theItem)
        Append(NCollection_Sequence_IntTools_Range self, NCollection_Sequence_IntTools_Range theSeq)

        Append another sequence (making it empty)

        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _IntTools.NCollection_Sequence_IntTools_Range_Append(self, *args)


    def Prepend(self, *args):
        """
        Prepend(NCollection_Sequence_IntTools_Range self, IntTools_Range theItem)
        Prepend(NCollection_Sequence_IntTools_Range self, NCollection_Sequence_IntTools_Range theSeq)

        Prepend another sequence (making it empty)

        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _IntTools.NCollection_Sequence_IntTools_Range_Prepend(self, *args)


    def InsertBefore(self, *args):
        """
        InsertBefore(NCollection_Sequence_IntTools_Range self, Standard_Integer const theIndex, IntTools_Range theItem)
        InsertBefore(NCollection_Sequence_IntTools_Range self, Standard_Integer const theIndex, NCollection_Sequence_IntTools_Range theSeq)

        InsertBefore theIndex another sequence

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _IntTools.NCollection_Sequence_IntTools_Range_InsertBefore(self, *args)


    def InsertAfter(self, *args):
        """
        InsertAfter(NCollection_Sequence_IntTools_Range self, NCollection_Sequence< IntTools_Range >::Iterator & thePosition, IntTools_Range theItem)
        InsertAfter(NCollection_Sequence_IntTools_Range self, Standard_Integer const theIndex, NCollection_Sequence_IntTools_Range theSeq)
        InsertAfter(NCollection_Sequence_IntTools_Range self, Standard_Integer const theIndex, IntTools_Range theItem)

        InsertAfter theIndex another sequence

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _IntTools.NCollection_Sequence_IntTools_Range_InsertAfter(self, *args)


    def Split(self, *args):
        """
        Split(NCollection_Sequence_IntTools_Range self, Standard_Integer const theIndex, NCollection_Sequence_IntTools_Range theSeq)

        Split in two sequences

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _IntTools.NCollection_Sequence_IntTools_Range_Split(self, *args)


    def First(self, *args):
        """
        First item access

        :rtype: const TheItemType &

        """
        res = _IntTools.NCollection_Sequence_IntTools_Range_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Sequence_IntTools_Range self) -> IntTools_Range

        First item access

        :rtype: TheItemType &

        """
        return _IntTools.NCollection_Sequence_IntTools_Range_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        Last item access

        :rtype: const TheItemType &

        """
        res = _IntTools.NCollection_Sequence_IntTools_Range_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Sequence_IntTools_Range self) -> IntTools_Range

        Last item access

        :rtype: TheItemType &

        """
        return _IntTools.NCollection_Sequence_IntTools_Range_ChangeLast(self, *args)


    def Value(self, *args):
        """
        Constant item access by theIndex

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _IntTools.NCollection_Sequence_IntTools_Range_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Sequence_IntTools_Range self, Standard_Integer const theIndex) -> IntTools_Range

        Variable item access by theIndex

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _IntTools.NCollection_Sequence_IntTools_Range_ChangeValue(self, *args)


    def __call__(self, *args):
        """
        Constant operator()

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _IntTools.NCollection_Sequence_IntTools_Range___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetValue(self, *args):
        """
        SetValue(NCollection_Sequence_IntTools_Range self, Standard_Integer const theIndex, IntTools_Range theItem)

        Set item value by theIndex

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _IntTools.NCollection_Sequence_IntTools_Range_SetValue(self, *args)


    def __iter__(self):
        return _IntTools.NCollection_Sequence_IntTools_Range___iter__(self)
    __swig_destroy__ = _IntTools.delete_NCollection_Sequence_IntTools_Range
NCollection_Sequence_IntTools_Range_swigregister = _IntTools.NCollection_Sequence_IntTools_Range_swigregister
NCollection_Sequence_IntTools_Range_swigregister(NCollection_Sequence_IntTools_Range)

def NCollection_Sequence_IntTools_Range_delNode(*args):
    """
    NCollection_Sequence_IntTools_Range_delNode(NCollection_SeqNode theNode, Handle_NCollection_BaseAllocator theAl)

    Static deleter to be passed to BaseSequence

    :type theNode: OCC.wrapper.NCollection.NCollection_SeqNode
    :type theAl: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

    """
    return _IntTools.NCollection_Sequence_IntTools_Range_delNode(*args)

class NCollection_Sequence_IntTools_Range_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _IntTools.new_NCollection_Sequence_IntTools_Range_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _IntTools.delete_NCollection_Sequence_IntTools_Range_IteratorHelper

    def __next__(self):
        return _IntTools.NCollection_Sequence_IntTools_Range_IteratorHelper___next__(self)
NCollection_Sequence_IntTools_Range_IteratorHelper_swigregister = _IntTools.NCollection_Sequence_IntTools_Range_IteratorHelper_swigregister
NCollection_Sequence_IntTools_Range_IteratorHelper_swigregister(NCollection_Sequence_IntTools_Range_IteratorHelper)


try:
	IntTools_SequenceOfRanges = NCollection_Sequence_IntTools_Range
except NameError:
	pass # does not exist, probably ignored

class IntTools_CurveRangeSample(IntTools_BaseRangeSample):
    """class for range index management of curve"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(IntTools_CurveRangeSample self) -> IntTools_CurveRangeSample
        __init__(IntTools_CurveRangeSample self, Standard_Integer const theIndex) -> IntTools_CurveRangeSample

        :type theIndex: int

        """
        this = _IntTools.new_IntTools_CurveRangeSample(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def SetRangeIndex(self, *args):
        """
        SetRangeIndex(IntTools_CurveRangeSample self, Standard_Integer const theIndex)

        :type theIndex: int

        """
        return _IntTools.IntTools_CurveRangeSample_SetRangeIndex(self, *args)


    def GetRangeIndex(self, *args):
        """
        GetRangeIndex(IntTools_CurveRangeSample self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntTools.IntTools_CurveRangeSample_GetRangeIndex(self, *args)


    def IsEqual(self, *args):
        """
        IsEqual(IntTools_CurveRangeSample self, IntTools_CurveRangeSample Other) -> Standard_Boolean

        :type Other: OCC.wrapper.IntTools.IntTools_CurveRangeSample
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntTools.IntTools_CurveRangeSample_IsEqual(self, *args)


    def GetRange(self, *args):
        """
        GetRange(IntTools_CurveRangeSample self, Standard_Real const theFirst, Standard_Real const theLast, Standard_Integer const theNbSample) -> IntTools_Range

        :type theFirst: float
        :type theLast: float
        :type theNbSample: int
        :rtype: OCC.wrapper.IntTools.IntTools_Range

        """
        return _IntTools.IntTools_CurveRangeSample_GetRange(self, *args)


    def GetRangeIndexDeeper(self, *args):
        """
        GetRangeIndexDeeper(IntTools_CurveRangeSample self, Standard_Integer const theNbSample) -> Standard_Integer

        :type theNbSample: int
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntTools.IntTools_CurveRangeSample_GetRangeIndexDeeper(self, *args)

    __swig_destroy__ = _IntTools.delete_IntTools_CurveRangeSample
IntTools_CurveRangeSample_swigregister = _IntTools.IntTools_CurveRangeSample_swigregister
IntTools_CurveRangeSample_swigregister(IntTools_CurveRangeSample)

class NCollection_Map_IntTools_CurveRangeSample_IntTools_CurveRangeSampleMapHasher(NCollection.NCollection_BaseMap):
    """
    Purpose:     Single hashed Map. This  Map is used  to store and
    retrieve keys in linear time.

    The ::Iterator class can be  used to explore  the
    content of the map. It is not  wise to iterate and
    modify a map in parallel.

    To compute  the hashcode of  the key the  function
    ::HashCode must be defined in the global namespace

    To compare two keys the function ::IsEqual must be
    defined in the global namespace.

    The performance of  a Map is conditionned  by  its
    number of buckets that  should be kept greater  to
    the number   of keys.  This  map has  an automatic
    management of the number of buckets. It is resized
    when  the number of Keys  becomes greater than the
    number of buckets.

    If you have a fair  idea of the number of  objects
    you  can save on automatic   resizing by giving  a
    number of buckets  at creation or using the ReSize
    method. This should be  consider only for  crucial
    optimisation issues.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def cbegin(self, *args):
        """
        cbegin(NCollection_Map_IntTools_CurveRangeSample_IntTools_CurveRangeSampleMapHasher self) -> NCollection_Map< IntTools_CurveRangeSample,IntTools_CurveRangeSampleMapHasher >::const_iterator

        Returns a const iterator pointing to the first element in the map.

        :rtype: const_iterator

        """
        return _IntTools.NCollection_Map_IntTools_CurveRangeSample_IntTools_CurveRangeSampleMapHasher_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Map_IntTools_CurveRangeSample_IntTools_CurveRangeSampleMapHasher self) -> NCollection_Map< IntTools_CurveRangeSample,IntTools_CurveRangeSampleMapHasher >::const_iterator

        Returns a const iterator referring to the past-the-end element in the map.

        :rtype: const_iterator

        """
        return _IntTools.NCollection_Map_IntTools_CurveRangeSample_IntTools_CurveRangeSampleMapHasher_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     Single hashed Map. This  Map is used  to store and
        retrieve keys in linear time.

        The ::Iterator class can be  used to explore  the
        content of the map. It is not  wise to iterate and
        modify a map in parallel.

        To compute  the hashcode of  the key the  function
        ::HashCode must be defined in the global namespace

        To compare two keys the function ::IsEqual must be
        defined in the global namespace.

        The performance of  a Map is conditionned  by  its
        number of buckets that  should be kept greater  to
        the number   of keys.  This  map has  an automatic
        management of the number of buckets. It is resized
        when  the number of Keys  becomes greater than the
        number of buckets.

        If you have a fair  idea of the number of  objects
        you  can save on automatic   resizing by giving  a
        number of buckets  at creation or using the ReSize
        method. This should be  consider only for  crucial
        optimisation issues.
        """
        this = _IntTools.new_NCollection_Map_IntTools_CurveRangeSample_IntTools_CurveRangeSampleMapHasher(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Exchange(self, *args):
        """
        Exchange(NCollection_Map_IntTools_CurveRangeSample_IntTools_CurveRangeSampleMapHasher self, NCollection_Map_IntTools_CurveRangeSample_IntTools_CurveRangeSampleMapHasher theOther)

        Exchange the content of two maps without re-allocations.
        Notice that allocators will be swapped as well!

        :type theOther: OCC.wrapper.NCollection.NCollection_Map

        """
        return _IntTools.NCollection_Map_IntTools_CurveRangeSample_IntTools_CurveRangeSampleMapHasher_Exchange(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Map_IntTools_CurveRangeSample_IntTools_CurveRangeSampleMapHasher self, NCollection_Map_IntTools_CurveRangeSample_IntTools_CurveRangeSampleMapHasher theOther) -> NCollection_Map_IntTools_CurveRangeSample_IntTools_CurveRangeSampleMapHasher

        Assign.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_Map
        :rtype: OCC.wrapper.NCollection.NCollection_Map

        """
        return _IntTools.NCollection_Map_IntTools_CurveRangeSample_IntTools_CurveRangeSampleMapHasher_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Map_IntTools_CurveRangeSample_IntTools_CurveRangeSampleMapHasher self, NCollection_Map_IntTools_CurveRangeSample_IntTools_CurveRangeSampleMapHasher theOther) -> NCollection_Map_IntTools_CurveRangeSample_IntTools_CurveRangeSampleMapHasher

        Assign operator

        :type theOther: OCC.wrapper.NCollection.NCollection_Map
        :rtype: OCC.wrapper.NCollection.NCollection_Map

        """
        return _IntTools.NCollection_Map_IntTools_CurveRangeSample_IntTools_CurveRangeSampleMapHasher_assign(self, *args)


    def ReSize(self, *args):
        """
        ReSize(NCollection_Map_IntTools_CurveRangeSample_IntTools_CurveRangeSampleMapHasher self, Standard_Integer const N)

        ReSize

        :type N: int

        """
        return _IntTools.NCollection_Map_IntTools_CurveRangeSample_IntTools_CurveRangeSampleMapHasher_ReSize(self, *args)


    def Add(self, *args):
        """
        Add(NCollection_Map_IntTools_CurveRangeSample_IntTools_CurveRangeSampleMapHasher self, IntTools_CurveRangeSample K) -> Standard_Boolean

        Add

        :type K: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntTools.NCollection_Map_IntTools_CurveRangeSample_IntTools_CurveRangeSampleMapHasher_Add(self, *args)


    def Added(self, *args):
        """
        Added: add a new key if not yet in the map, and return 
        reference to either newly added or previously existing object

        :type K: const TheKeyType &
        :rtype: const TheKeyType &

        """
        res = _IntTools.NCollection_Map_IntTools_CurveRangeSample_IntTools_CurveRangeSampleMapHasher_Added(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Remove(self, *args):
        """
        Remove(NCollection_Map_IntTools_CurveRangeSample_IntTools_CurveRangeSampleMapHasher self, IntTools_CurveRangeSample K) -> Standard_Boolean

        Remove

        :type K: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntTools.NCollection_Map_IntTools_CurveRangeSample_IntTools_CurveRangeSampleMapHasher_Remove(self, *args)


    def Clear(self, *args):
        """
        Clear(NCollection_Map_IntTools_CurveRangeSample_IntTools_CurveRangeSampleMapHasher self, Standard_Boolean const doReleaseMemory)
        Clear(NCollection_Map_IntTools_CurveRangeSample_IntTools_CurveRangeSampleMapHasher self, Handle_NCollection_BaseAllocator theAllocator)

        Clear data and reset allocator

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _IntTools.NCollection_Map_IntTools_CurveRangeSample_IntTools_CurveRangeSampleMapHasher_Clear(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_Map_IntTools_CurveRangeSample_IntTools_CurveRangeSampleMapHasher self) -> Standard_Integer

        Size

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntTools.NCollection_Map_IntTools_CurveRangeSample_IntTools_CurveRangeSampleMapHasher_Size(self, *args)


    def IsEqual(self, *args):
        """
        IsEqual(NCollection_Map_IntTools_CurveRangeSample_IntTools_CurveRangeSampleMapHasher self, NCollection_Map_IntTools_CurveRangeSample_IntTools_CurveRangeSampleMapHasher theOther) -> Standard_Boolean

        @return true if two maps contains exactly the same keys

        :type theOther: OCC.wrapper.NCollection.NCollection_Map
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntTools.NCollection_Map_IntTools_CurveRangeSample_IntTools_CurveRangeSampleMapHasher_IsEqual(self, *args)


    def Contains(self, *args):
        """
        Contains(NCollection_Map_IntTools_CurveRangeSample_IntTools_CurveRangeSampleMapHasher self, IntTools_CurveRangeSample K) -> Standard_Boolean
        Contains(NCollection_Map_IntTools_CurveRangeSample_IntTools_CurveRangeSampleMapHasher self, NCollection_Map_IntTools_CurveRangeSample_IntTools_CurveRangeSampleMapHasher theOther) -> Standard_Boolean

        @return true if this map contains ALL keys of another map.

        :type theOther: OCC.wrapper.NCollection.NCollection_Map
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntTools.NCollection_Map_IntTools_CurveRangeSample_IntTools_CurveRangeSampleMapHasher_Contains(self, *args)


    def Union(self, *args):
        """
        Union(NCollection_Map_IntTools_CurveRangeSample_IntTools_CurveRangeSampleMapHasher self, NCollection_Map_IntTools_CurveRangeSample_IntTools_CurveRangeSampleMapHasher theLeft, NCollection_Map_IntTools_CurveRangeSample_IntTools_CurveRangeSampleMapHasher theRight)

        Sets this Map to be the result of union (aka addition, fuse, merge, boolean OR) operation between two given Maps
        The new Map contains the values that are contained either in the first map or in the second map or in both.
        All previous content of this Map is cleared.
        This map (result of the boolean operation) can also be passed as one of operands.

        :type theLeft: OCC.wrapper.NCollection.NCollection_Map
        :type theRight: OCC.wrapper.NCollection.NCollection_Map

        """
        return _IntTools.NCollection_Map_IntTools_CurveRangeSample_IntTools_CurveRangeSampleMapHasher_Union(self, *args)


    def Unite(self, *args):
        """
        Unite(NCollection_Map_IntTools_CurveRangeSample_IntTools_CurveRangeSampleMapHasher self, NCollection_Map_IntTools_CurveRangeSample_IntTools_CurveRangeSampleMapHasher theOther) -> Standard_Boolean

        Apply to this Map the boolean operation union (aka addition, fuse, merge, boolean OR) with another (given) Map.
        The result contains the values that were previously contained in this map or contained in the given (operand) map.
        This algorithm is similar to method Union().
        Returns True if contents of this map is changed.

        :type theOther: OCC.wrapper.NCollection.NCollection_Map
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntTools.NCollection_Map_IntTools_CurveRangeSample_IntTools_CurveRangeSampleMapHasher_Unite(self, *args)


    def HasIntersection(self, *args):
        """
        HasIntersection(NCollection_Map_IntTools_CurveRangeSample_IntTools_CurveRangeSampleMapHasher self, NCollection_Map_IntTools_CurveRangeSample_IntTools_CurveRangeSampleMapHasher theMap) -> Standard_Boolean

        Returns true if this and theMap have common elements.

        :type theMap: OCC.wrapper.NCollection.NCollection_Map
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntTools.NCollection_Map_IntTools_CurveRangeSample_IntTools_CurveRangeSampleMapHasher_HasIntersection(self, *args)


    def Intersection(self, *args):
        """
        Intersection(NCollection_Map_IntTools_CurveRangeSample_IntTools_CurveRangeSampleMapHasher self, NCollection_Map_IntTools_CurveRangeSample_IntTools_CurveRangeSampleMapHasher theLeft, NCollection_Map_IntTools_CurveRangeSample_IntTools_CurveRangeSampleMapHasher theRight)

        Sets this Map to be the result of intersection (aka multiplication, common, boolean AND) operation between two given Maps.
        The new Map contains only the values that are contained in both map operands.
        All previous content of this Map is cleared.
        This same map (result of the boolean operation) can also be used as one of operands.

        :type theLeft: OCC.wrapper.NCollection.NCollection_Map
        :type theRight: OCC.wrapper.NCollection.NCollection_Map

        """
        return _IntTools.NCollection_Map_IntTools_CurveRangeSample_IntTools_CurveRangeSampleMapHasher_Intersection(self, *args)


    def Intersect(self, *args):
        """
        Intersect(NCollection_Map_IntTools_CurveRangeSample_IntTools_CurveRangeSampleMapHasher self, NCollection_Map_IntTools_CurveRangeSample_IntTools_CurveRangeSampleMapHasher theOther) -> Standard_Boolean

        Apply to this Map the intersection operation (aka multiplication, common, boolean AND) with another (given) Map.
        The result contains only the values that are contained in both this and the given maps.
        This algorithm is similar to method Intersection().
        Returns True if contents of this map is changed.

        :type theOther: OCC.wrapper.NCollection.NCollection_Map
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntTools.NCollection_Map_IntTools_CurveRangeSample_IntTools_CurveRangeSampleMapHasher_Intersect(self, *args)


    def Subtraction(self, *args):
        """
        Subtraction(NCollection_Map_IntTools_CurveRangeSample_IntTools_CurveRangeSampleMapHasher self, NCollection_Map_IntTools_CurveRangeSample_IntTools_CurveRangeSampleMapHasher theLeft, NCollection_Map_IntTools_CurveRangeSample_IntTools_CurveRangeSampleMapHasher theRight)

        Sets this Map to be the result of subtraction (aka set-theoretic difference, relative complement,
        exclude, cut, boolean NOT) operation between two given Maps.
        The new Map contains only the values that are contained in the first map operands and not contained in the second one.
        All previous content of this Map is cleared.

        :type theLeft: OCC.wrapper.NCollection.NCollection_Map
        :type theRight: OCC.wrapper.NCollection.NCollection_Map

        """
        return _IntTools.NCollection_Map_IntTools_CurveRangeSample_IntTools_CurveRangeSampleMapHasher_Subtraction(self, *args)


    def Subtract(self, *args):
        """
        Subtract(NCollection_Map_IntTools_CurveRangeSample_IntTools_CurveRangeSampleMapHasher self, NCollection_Map_IntTools_CurveRangeSample_IntTools_CurveRangeSampleMapHasher theOther) -> Standard_Boolean

        Apply to this Map the subtraction (aka set-theoretic difference, relative complement,
        exclude, cut, boolean NOT) operation with another (given) Map.
        The result contains only the values that were previously contained in this map and not contained in this map.
        This algorithm is similar to method Subtract() with two operands.
        Returns True if contents of this map is changed.

        :type theOther: OCC.wrapper.NCollection.NCollection_Map
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntTools.NCollection_Map_IntTools_CurveRangeSample_IntTools_CurveRangeSampleMapHasher_Subtract(self, *args)


    def Difference(self, *args):
        """
        Difference(NCollection_Map_IntTools_CurveRangeSample_IntTools_CurveRangeSampleMapHasher self, NCollection_Map_IntTools_CurveRangeSample_IntTools_CurveRangeSampleMapHasher theLeft, NCollection_Map_IntTools_CurveRangeSample_IntTools_CurveRangeSampleMapHasher theRight)

        Sets this Map to be the result of symmetric difference (aka exclusive disjunction, boolean XOR) operation between two given Maps.
        The new Map contains the values that are contained only in the first or the second operand maps but not in both.
        All previous content of this Map is cleared. This map (result of the boolean operation) can also be used as one of operands.

        :type theLeft: OCC.wrapper.NCollection.NCollection_Map
        :type theRight: OCC.wrapper.NCollection.NCollection_Map

        """
        return _IntTools.NCollection_Map_IntTools_CurveRangeSample_IntTools_CurveRangeSampleMapHasher_Difference(self, *args)


    def Differ(self, *args):
        """
        Differ(NCollection_Map_IntTools_CurveRangeSample_IntTools_CurveRangeSampleMapHasher self, NCollection_Map_IntTools_CurveRangeSample_IntTools_CurveRangeSampleMapHasher theOther) -> Standard_Boolean

        Apply to this Map the symmetric difference (aka exclusive disjunction, boolean XOR) operation with another (given) Map.
        The result contains the values that are contained only in this or the operand map, but not in both.
        This algorithm is similar to method Difference().
        Returns True if contents of this map is changed.

        :type theOther: OCC.wrapper.NCollection.NCollection_Map
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntTools.NCollection_Map_IntTools_CurveRangeSample_IntTools_CurveRangeSampleMapHasher_Differ(self, *args)


    def __iter__(self):
        return _IntTools.NCollection_Map_IntTools_CurveRangeSample_IntTools_CurveRangeSampleMapHasher___iter__(self)
    __swig_destroy__ = _IntTools.delete_NCollection_Map_IntTools_CurveRangeSample_IntTools_CurveRangeSampleMapHasher
NCollection_Map_IntTools_CurveRangeSample_IntTools_CurveRangeSampleMapHasher_swigregister = _IntTools.NCollection_Map_IntTools_CurveRangeSample_IntTools_CurveRangeSampleMapHasher_swigregister
NCollection_Map_IntTools_CurveRangeSample_IntTools_CurveRangeSampleMapHasher_swigregister(NCollection_Map_IntTools_CurveRangeSample_IntTools_CurveRangeSampleMapHasher)

class NCollection_Map_IntTools_CurveRangeSample_IntTools_CurveRangeSampleMapHasher_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _IntTools.new_NCollection_Map_IntTools_CurveRangeSample_IntTools_CurveRangeSampleMapHasher_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _IntTools.delete_NCollection_Map_IntTools_CurveRangeSample_IntTools_CurveRangeSampleMapHasher_IteratorHelper

    def __next__(self):
        return _IntTools.NCollection_Map_IntTools_CurveRangeSample_IntTools_CurveRangeSampleMapHasher_IteratorHelper___next__(self)
NCollection_Map_IntTools_CurveRangeSample_IntTools_CurveRangeSampleMapHasher_IteratorHelper_swigregister = _IntTools.NCollection_Map_IntTools_CurveRangeSample_IntTools_CurveRangeSampleMapHasher_IteratorHelper_swigregister
NCollection_Map_IntTools_CurveRangeSample_IntTools_CurveRangeSampleMapHasher_IteratorHelper_swigregister(NCollection_Map_IntTools_CurveRangeSample_IntTools_CurveRangeSampleMapHasher_IteratorHelper)


try:
	IntTools_MapOfCurveSample = NCollection_Map_IntTools_CurveRangeSample_IntTools_CurveRangeSampleMapHasher
except NameError:
	pass # does not exist, probably ignored

class NCollection_List_Bnd_Box_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _IntTools.new_NCollection_List_Bnd_Box_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _IntTools.delete_NCollection_List_Bnd_Box_IteratorHelper

    def __next__(self):
        return _IntTools.NCollection_List_Bnd_Box_IteratorHelper___next__(self)
NCollection_List_Bnd_Box_IteratorHelper_swigregister = _IntTools.NCollection_List_Bnd_Box_IteratorHelper_swigregister
NCollection_List_Bnd_Box_IteratorHelper_swigregister(NCollection_List_Bnd_Box_IteratorHelper)


try:
	IntTools_ListOfBox = NCollection_List_Bnd_Box
except NameError:
	pass # does not exist, probably ignored

class NCollection_Array1_IntTools_Root(object):
    """
    Purpose:     The class Array1 represents unidimensional arrays 
    of fixed size known at run time. 
    The range of the index is user defined.
    An array1 can be constructed with a "C array".
    This functionality is useful to call methods expecting
    an Array1. It allows to carry the bounds inside the arrays.

    Examples:    Item tab[100]; //  An example with a C array
    Array1OfItem ttab (tab[0],1,100);

    Array1OfItem tttab (ttab(10),10,20); // a slice of ttab

    If you want to reindex an array from 1 to Length do :

    Array1 tab1(tab(tab.Lower()),1,tab.Length());

    Warning:     Programs client of such a class must be independant
    of the range of the first element. Then, a C++ for
    loop must be written like this

    for (i = A.Lower(); i <= A.Upper(); i++)

    Changes:     In  comparison  to  TCollection  the  flag  isAllocated  was
    renamed into myDeletable (alike in  the Array2).  For naming
    compatibility the method IsAllocated remained in class along
    with IsDeletable.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Array1_IntTools_Root self) -> NCollection_Array1< IntTools_Root >::iterator

        Returns an iterator pointing to the first element in the array.

        :rtype: iterator

        """
        return _IntTools.NCollection_Array1_IntTools_Root_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Array1_IntTools_Root self) -> NCollection_Array1< IntTools_Root >::iterator

        Returns an iterator referring to the past-the-end element in the array.

        :rtype: iterator

        """
        return _IntTools.NCollection_Array1_IntTools_Root_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Array1_IntTools_Root self) -> NCollection_Array1< IntTools_Root >::const_iterator

        Returns a const iterator pointing to the first element in the array.

        :rtype: const_iterator

        """
        return _IntTools.NCollection_Array1_IntTools_Root_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Array1_IntTools_Root self) -> NCollection_Array1< IntTools_Root >::const_iterator

        Returns a const iterator referring to the past-the-end element in the array.

        :rtype: const_iterator

        """
        return _IntTools.NCollection_Array1_IntTools_Root_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     The class Array1 represents unidimensional arrays 
        of fixed size known at run time. 
        The range of the index is user defined.
        An array1 can be constructed with a "C array".
        This functionality is useful to call methods expecting
        an Array1. It allows to carry the bounds inside the arrays.

        Examples:    Item tab[100]; //  An example with a C array
        Array1OfItem ttab (tab[0],1,100);

        Array1OfItem tttab (ttab(10),10,20); // a slice of ttab

        If you want to reindex an array from 1 to Length do :

        Array1 tab1(tab(tab.Lower()),1,tab.Length());

        Warning:     Programs client of such a class must be independant
        of the range of the first element. Then, a C++ for
        loop must be written like this

        for (i = A.Lower(); i <= A.Upper(); i++)

        Changes:     In  comparison  to  TCollection  the  flag  isAllocated  was
        renamed into myDeletable (alike in  the Array2).  For naming
        compatibility the method IsAllocated remained in class along
        with IsDeletable.
        """
        this = _IntTools.new_NCollection_Array1_IntTools_Root(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(NCollection_Array1_IntTools_Root self, IntTools_Root theValue)

        Initialise the items with theValue

        :type theValue: const TheItemType &

        """
        return _IntTools.NCollection_Array1_IntTools_Root_Init(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_Array1_IntTools_Root self) -> Standard_Integer

        Size query

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntTools.NCollection_Array1_IntTools_Root_Size(self, *args)


    def Length(self, *args):
        """
        Length(NCollection_Array1_IntTools_Root self) -> Standard_Integer

        Length query (the same)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntTools.NCollection_Array1_IntTools_Root_Length(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Array1_IntTools_Root self) -> Standard_Boolean

        Return TRUE if array has zero length.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntTools.NCollection_Array1_IntTools_Root_IsEmpty(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Array1_IntTools_Root self) -> Standard_Integer

        Lower bound

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntTools.NCollection_Array1_IntTools_Root_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Array1_IntTools_Root self) -> Standard_Integer

        Upper bound

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntTools.NCollection_Array1_IntTools_Root_Upper(self, *args)


    def IsDeletable(self, *args):
        """
        IsDeletable(NCollection_Array1_IntTools_Root self) -> Standard_Boolean

        myDeletable flag

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntTools.NCollection_Array1_IntTools_Root_IsDeletable(self, *args)


    def IsAllocated(self, *args):
        """
        IsAllocated(NCollection_Array1_IntTools_Root self) -> Standard_Boolean

        IsAllocated flag - for naming compatibility

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntTools.NCollection_Array1_IntTools_Root_IsAllocated(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Array1_IntTools_Root self, NCollection_Array1_IntTools_Root theOther) -> NCollection_Array1_IntTools_Root

        Copies data of theOther array to this.
        This array should be pre-allocated and have the same length as theOther;
        otherwise exception Standard_DimensionMismatch is thrown.

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _IntTools.NCollection_Array1_IntTools_Root_Assign(self, *args)


    def Move(self, *args):
        """
        Move(NCollection_Array1_IntTools_Root self, NCollection_Array1_IntTools_Root theOther) -> NCollection_Array1_IntTools_Root

        Move assignment.
        This array will borrow all the data from theOther.
        The moved object will keep pointer to the memory buffer and
        range, but it will not free the buffer on destruction.

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _IntTools.NCollection_Array1_IntTools_Root_Move(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Array1_IntTools_Root self, NCollection_Array1_IntTools_Root theOther) -> NCollection_Array1_IntTools_Root
        assign(NCollection_Array1_IntTools_Root self, NCollection_Array1_IntTools_Root theOther) -> NCollection_Array1_IntTools_Root

        Move assignment operator; @sa Move()

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1<TheItemType> &&
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _IntTools.NCollection_Array1_IntTools_Root_assign(self, *args)


    def First(self, *args):
        """
        @return first element

        :rtype: const TheItemType &

        """
        res = _IntTools.NCollection_Array1_IntTools_Root_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Array1_IntTools_Root self) -> IntTools_Root

        @return first element

        :rtype: TheItemType &

        """
        return _IntTools.NCollection_Array1_IntTools_Root_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        @return last element

        :rtype: const TheItemType &

        """
        res = _IntTools.NCollection_Array1_IntTools_Root_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Array1_IntTools_Root self) -> IntTools_Root

        @return last element

        :rtype: TheItemType &

        """
        return _IntTools.NCollection_Array1_IntTools_Root_ChangeLast(self, *args)


    def Value(self, *args):
        """
        Constant value access

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _IntTools.NCollection_Array1_IntTools_Root_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Array1_IntTools_Root self, Standard_Integer const theIndex) -> IntTools_Root

        Variable value access

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _IntTools.NCollection_Array1_IntTools_Root_ChangeValue(self, *args)


    def __call__(self, *args):
        """
        operator() - alias to Value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _IntTools.NCollection_Array1_IntTools_Root___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __getitem__(self, *args):
        """
        operator[] - alias to Value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _IntTools.NCollection_Array1_IntTools_Root_at(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetValue(self, *args):
        """
        SetValue(NCollection_Array1_IntTools_Root self, Standard_Integer const theIndex, IntTools_Root theItem)

        Set value 

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _IntTools.NCollection_Array1_IntTools_Root_SetValue(self, *args)


    def Resize(self, *args):
        """
        Resize(NCollection_Array1_IntTools_Root self, Standard_Integer const theLower, Standard_Integer const theUpper, Standard_Boolean const theToCopyData)

        Resizes the array to specified bounds.
        No re-allocation will be done if length of array does not change,
        but existing values will not be discarded if theToCopyData set to FALSE.
        @param theLower new lower bound of array
        @param theUpper new upper bound of array
        @param theToCopyData flag to copy existing data into new array

        :type theLower: int
        :type theUpper: int
        :type theToCopyData: bool

        """
        return _IntTools.NCollection_Array1_IntTools_Root_Resize(self, *args)

    __swig_destroy__ = _IntTools.delete_NCollection_Array1_IntTools_Root
NCollection_Array1_IntTools_Root_swigregister = _IntTools.NCollection_Array1_IntTools_Root_swigregister
NCollection_Array1_IntTools_Root_swigregister(NCollection_Array1_IntTools_Root)


try:
	IntTools_Array1OfRoots = NCollection_Array1_IntTools_Root
except NameError:
	pass # does not exist, probably ignored

class IntTools_Curve(object):
    """
    The class is a container of one 3D curve, two 2D curves and two Tolerance values.<br>
    It is used in the Face/Face intersection algorithm to store the results
    of intersection. In this context:<br>
    **the 3D curve** is the intersection curve;<br>
    **the 2D curves** are the PCurves of the 3D curve on the intersecting faces;<br>
    **the tolerance** is the valid tolerance for 3D curve computed as
    maximal deviation between 3D curve and 2D curves (or surfaces in case there are no 2D curves);<br>
    **the tangential tolerance** is the maximal distance from 3D curve to the
    end of the tangential zone between faces in terms of their tolerance values.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(IntTools_Curve self) -> IntTools_Curve
        __init__(IntTools_Curve self, Handle_Geom_Curve the3dCurve3d, Handle_Geom2d_Curve the2dCurve1, Handle_Geom2d_Curve the2dCurve2, Standard_Real const theTolerance=0.0, Standard_Real const theTangentialTolerance=0.0) -> IntTools_Curve

        Constructor taking 3d curve, two 2d curves and two tolerance values

        :type the3dCurve3d: OCC.wrapper.Geom.Handle_Geom_Curve
        :type the2dCurve1: OCC.wrapper.Geom2d.Handle_Geom2d_Curve
        :type the2dCurve2: OCC.wrapper.Geom2d.Handle_Geom2d_Curve
        :type theTolerance: float
        :type theTangentialTolerance: float

        """
        this = _IntTools.new_IntTools_Curve(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def SetCurves(self, *args):
        """
        SetCurves(IntTools_Curve self, Handle_Geom_Curve the3dCurve, Handle_Geom2d_Curve the2dCurve1, Handle_Geom2d_Curve the2dCurve2)

        Sets the curves

        :type the3dCurve: OCC.wrapper.Geom.Handle_Geom_Curve
        :type the2dCurve1: OCC.wrapper.Geom2d.Handle_Geom2d_Curve
        :type the2dCurve2: OCC.wrapper.Geom2d.Handle_Geom2d_Curve

        """
        return _IntTools.IntTools_Curve_SetCurves(self, *args)


    def SetCurve(self, *args):
        """
        SetCurve(IntTools_Curve self, Handle_Geom_Curve the3dCurve)

        Sets the 3d curve

        :type the3dCurve: OCC.wrapper.Geom.Handle_Geom_Curve

        """
        return _IntTools.IntTools_Curve_SetCurve(self, *args)


    def SetFirstCurve2d(self, *args):
        """
        SetFirstCurve2d(IntTools_Curve self, Handle_Geom2d_Curve the2dCurve1)

        Sets the first 2d curve

        :type the2dCurve1: OCC.wrapper.Geom2d.Handle_Geom2d_Curve

        """
        return _IntTools.IntTools_Curve_SetFirstCurve2d(self, *args)


    def SetSecondCurve2d(self, *args):
        """
        SetSecondCurve2d(IntTools_Curve self, Handle_Geom2d_Curve the2dCurve2)

        Sets the second 2d curve

        :type the2dCurve2: OCC.wrapper.Geom2d.Handle_Geom2d_Curve

        """
        return _IntTools.IntTools_Curve_SetSecondCurve2d(self, *args)


    def SetTolerance(self, *args):
        """
        SetTolerance(IntTools_Curve self, Standard_Real const theTolerance)

        Sets the tolerance for the curve

        :type theTolerance: float

        """
        return _IntTools.IntTools_Curve_SetTolerance(self, *args)


    def SetTangentialTolerance(self, *args):
        """
        SetTangentialTolerance(IntTools_Curve self, Standard_Real const theTangentialTolerance)

        Sets the tangential tolerance

        :type theTangentialTolerance: float

        """
        return _IntTools.IntTools_Curve_SetTangentialTolerance(self, *args)


    def Curve(self, *args):
        """
        Returns 3d curve

        :rtype: OCC.wrapper.Geom.Handle_Geom_Curve

        """
        res = _IntTools.IntTools_Curve_Curve(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def FirstCurve2d(self, *args):
        """
        Returns first 2d curve

        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Curve

        """
        res = _IntTools.IntTools_Curve_FirstCurve2d(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SecondCurve2d(self, *args):
        """
        Returns second 2d curve

        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Curve

        """
        res = _IntTools.IntTools_Curve_SecondCurve2d(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Tolerance(self, *args):
        """
        Tolerance(IntTools_Curve self) -> Standard_Real

        Returns the tolerance

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _IntTools.IntTools_Curve_Tolerance(self, *args)


    def TangentialTolerance(self, *args):
        """
        TangentialTolerance(IntTools_Curve self) -> Standard_Real

        Returns the tangential tolerance

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _IntTools.IntTools_Curve_TangentialTolerance(self, *args)


    def HasBounds(self, *args):
        """
        HasBounds(IntTools_Curve self) -> Standard_Boolean

        Returns TRUE if 3d curve is BoundedCurve

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntTools.IntTools_Curve_HasBounds(self, *args)


    def Bounds(self, *args):
        """
        Bounds(IntTools_Curve self, gp_Pnt theFirstPnt, gp_Pnt theLastPnt) -> Standard_Boolean

        If the 3d curve is bounded curve the method will return TRUE
        and modify the output parameters with boundary parameters of
        the curve and corresponded 3d points.<br>
        If the curve does not have bounds, the method will return false
        and the output parameters will stay untouched.

        :type theFirst: float
        :type theLast: float
        :type theFirstPnt: OCC.wrapper.gp.gp_Pnt
        :type theLastPnt: OCC.wrapper.gp.gp_Pnt
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntTools.IntTools_Curve_Bounds(self, *args)


    def D0(self, *args):
        """
        D0(IntTools_Curve self, Standard_Real const & thePar, gp_Pnt thePnt) -> Standard_Boolean

        Computes 3d point corresponded to the given parameter if this
        parameter is inside the boundaries of the curve.
        Returns TRUE in this case. <br>
        Otherwise, the point will not be computed and the method will return FALSE.

        :type thePar: float
        :type thePnt: OCC.wrapper.gp.gp_Pnt
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntTools.IntTools_Curve_D0(self, *args)


    def Type(self, *args):
        """
        Type(IntTools_Curve self) -> GeomAbs_CurveType

        Returns the type of the 3d curve

        :rtype: OCC.wrapper.GeomAbs.GeomAbs_CurveType

        """
        return _IntTools.IntTools_Curve_Type(self, *args)

    __swig_destroy__ = _IntTools.delete_IntTools_Curve
IntTools_Curve_swigregister = _IntTools.IntTools_Curve_swigregister
IntTools_Curve_swigregister(IntTools_Curve)

class NCollection_Sequence_IntTools_Curve(NCollection.NCollection_BaseSequence):
    """
    Purpose:     Definition of a sequence of elements indexed by
    an Integer in range of 1..n
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Sequence_IntTools_Curve self) -> NCollection_Sequence< IntTools_Curve >::iterator

        Returns an iterator pointing to the first element in the sequence.

        :rtype: iterator

        """
        return _IntTools.NCollection_Sequence_IntTools_Curve_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Sequence_IntTools_Curve self) -> NCollection_Sequence< IntTools_Curve >::iterator

        Returns an iterator referring to the past-the-end element in the sequence.

        :rtype: iterator

        """
        return _IntTools.NCollection_Sequence_IntTools_Curve_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Sequence_IntTools_Curve self) -> NCollection_Sequence< IntTools_Curve >::const_iterator

        Returns a const iterator pointing to the first element in the sequence.

        :rtype: const_iterator

        """
        return _IntTools.NCollection_Sequence_IntTools_Curve_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Sequence_IntTools_Curve self) -> NCollection_Sequence< IntTools_Curve >::const_iterator

        Returns a const iterator referring to the past-the-end element in the sequence.

        :rtype: const_iterator

        """
        return _IntTools.NCollection_Sequence_IntTools_Curve_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     Definition of a sequence of elements indexed by
        an Integer in range of 1..n
        """
        this = _IntTools.new_NCollection_Sequence_IntTools_Curve(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Size(self, *args):
        """
        Size(NCollection_Sequence_IntTools_Curve self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntTools.NCollection_Sequence_IntTools_Curve_Size(self, *args)


    def Length(self, *args):
        """
        Length(NCollection_Sequence_IntTools_Curve self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntTools.NCollection_Sequence_IntTools_Curve_Length(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Sequence_IntTools_Curve self) -> Standard_Integer

        Method for consistency with other collections.
        @return Lower bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntTools.NCollection_Sequence_IntTools_Curve_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Sequence_IntTools_Curve self) -> Standard_Integer

        Method for consistency with other collections.
        @return Upper bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntTools.NCollection_Sequence_IntTools_Curve_Upper(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Sequence_IntTools_Curve self) -> Standard_Boolean

        Empty query

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntTools.NCollection_Sequence_IntTools_Curve_IsEmpty(self, *args)


    def Reverse(self, *args):
        """
        Reverse(NCollection_Sequence_IntTools_Curve self)

        Reverse sequence


        """
        return _IntTools.NCollection_Sequence_IntTools_Curve_Reverse(self, *args)


    def Exchange(self, *args):
        """
        Exchange(NCollection_Sequence_IntTools_Curve self, Standard_Integer const I, Standard_Integer const J)

        Exchange two members

        :type I: int
        :type J: int

        """
        return _IntTools.NCollection_Sequence_IntTools_Curve_Exchange(self, *args)


    def delNode(*args):
        """
        delNode(NCollection_SeqNode theNode, Handle_NCollection_BaseAllocator theAl)

        Static deleter to be passed to BaseSequence

        :type theNode: OCC.wrapper.NCollection.NCollection_SeqNode
        :type theAl: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _IntTools.NCollection_Sequence_IntTools_Curve_delNode(*args)

    delNode = staticmethod(delNode)

    def Clear(self, *args):
        """
        Clear(NCollection_Sequence_IntTools_Curve self, Handle_NCollection_BaseAllocator theAllocator=0)

        Clear the items out, take a new allocator if non null

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _IntTools.NCollection_Sequence_IntTools_Curve_Clear(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Sequence_IntTools_Curve self, NCollection_Sequence_IntTools_Curve theOther) -> NCollection_Sequence_IntTools_Curve

        Replace this sequence by the items of theOther.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_Sequence
        :rtype: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _IntTools.NCollection_Sequence_IntTools_Curve_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Sequence_IntTools_Curve self, NCollection_Sequence_IntTools_Curve theOther) -> NCollection_Sequence_IntTools_Curve

        Replacement operator

        :type theOther: OCC.wrapper.NCollection.NCollection_Sequence
        :rtype: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _IntTools.NCollection_Sequence_IntTools_Curve_assign(self, *args)


    def Remove(self, *args):
        """
        Remove(NCollection_Sequence_IntTools_Curve self, NCollection_Sequence< IntTools_Curve >::Iterator & thePosition)
        Remove(NCollection_Sequence_IntTools_Curve self, Standard_Integer const theIndex)
        Remove(NCollection_Sequence_IntTools_Curve self, Standard_Integer const theFromIndex, Standard_Integer const theToIndex)

        Remove range of items

        :type theFromIndex: int
        :type theToIndex: int

        """
        return _IntTools.NCollection_Sequence_IntTools_Curve_Remove(self, *args)


    def Append(self, *args):
        """
        Append(NCollection_Sequence_IntTools_Curve self, IntTools_Curve theItem)
        Append(NCollection_Sequence_IntTools_Curve self, NCollection_Sequence_IntTools_Curve theSeq)

        Append another sequence (making it empty)

        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _IntTools.NCollection_Sequence_IntTools_Curve_Append(self, *args)


    def Prepend(self, *args):
        """
        Prepend(NCollection_Sequence_IntTools_Curve self, IntTools_Curve theItem)
        Prepend(NCollection_Sequence_IntTools_Curve self, NCollection_Sequence_IntTools_Curve theSeq)

        Prepend another sequence (making it empty)

        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _IntTools.NCollection_Sequence_IntTools_Curve_Prepend(self, *args)


    def InsertBefore(self, *args):
        """
        InsertBefore(NCollection_Sequence_IntTools_Curve self, Standard_Integer const theIndex, IntTools_Curve theItem)
        InsertBefore(NCollection_Sequence_IntTools_Curve self, Standard_Integer const theIndex, NCollection_Sequence_IntTools_Curve theSeq)

        InsertBefore theIndex another sequence

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _IntTools.NCollection_Sequence_IntTools_Curve_InsertBefore(self, *args)


    def InsertAfter(self, *args):
        """
        InsertAfter(NCollection_Sequence_IntTools_Curve self, NCollection_Sequence< IntTools_Curve >::Iterator & thePosition, IntTools_Curve theItem)
        InsertAfter(NCollection_Sequence_IntTools_Curve self, Standard_Integer const theIndex, NCollection_Sequence_IntTools_Curve theSeq)
        InsertAfter(NCollection_Sequence_IntTools_Curve self, Standard_Integer const theIndex, IntTools_Curve theItem)

        InsertAfter theIndex another sequence

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _IntTools.NCollection_Sequence_IntTools_Curve_InsertAfter(self, *args)


    def Split(self, *args):
        """
        Split(NCollection_Sequence_IntTools_Curve self, Standard_Integer const theIndex, NCollection_Sequence_IntTools_Curve theSeq)

        Split in two sequences

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _IntTools.NCollection_Sequence_IntTools_Curve_Split(self, *args)


    def First(self, *args):
        """
        First item access

        :rtype: const TheItemType &

        """
        res = _IntTools.NCollection_Sequence_IntTools_Curve_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Sequence_IntTools_Curve self) -> IntTools_Curve

        First item access

        :rtype: TheItemType &

        """
        return _IntTools.NCollection_Sequence_IntTools_Curve_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        Last item access

        :rtype: const TheItemType &

        """
        res = _IntTools.NCollection_Sequence_IntTools_Curve_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Sequence_IntTools_Curve self) -> IntTools_Curve

        Last item access

        :rtype: TheItemType &

        """
        return _IntTools.NCollection_Sequence_IntTools_Curve_ChangeLast(self, *args)


    def Value(self, *args):
        """
        Constant item access by theIndex

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _IntTools.NCollection_Sequence_IntTools_Curve_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Sequence_IntTools_Curve self, Standard_Integer const theIndex) -> IntTools_Curve

        Variable item access by theIndex

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _IntTools.NCollection_Sequence_IntTools_Curve_ChangeValue(self, *args)


    def __call__(self, *args):
        """
        Constant operator()

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _IntTools.NCollection_Sequence_IntTools_Curve___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetValue(self, *args):
        """
        SetValue(NCollection_Sequence_IntTools_Curve self, Standard_Integer const theIndex, IntTools_Curve theItem)

        Set item value by theIndex

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _IntTools.NCollection_Sequence_IntTools_Curve_SetValue(self, *args)


    def __iter__(self):
        return _IntTools.NCollection_Sequence_IntTools_Curve___iter__(self)
    __swig_destroy__ = _IntTools.delete_NCollection_Sequence_IntTools_Curve
NCollection_Sequence_IntTools_Curve_swigregister = _IntTools.NCollection_Sequence_IntTools_Curve_swigregister
NCollection_Sequence_IntTools_Curve_swigregister(NCollection_Sequence_IntTools_Curve)

def NCollection_Sequence_IntTools_Curve_delNode(*args):
    """
    NCollection_Sequence_IntTools_Curve_delNode(NCollection_SeqNode theNode, Handle_NCollection_BaseAllocator theAl)

    Static deleter to be passed to BaseSequence

    :type theNode: OCC.wrapper.NCollection.NCollection_SeqNode
    :type theAl: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

    """
    return _IntTools.NCollection_Sequence_IntTools_Curve_delNode(*args)

class NCollection_Sequence_IntTools_Curve_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _IntTools.new_NCollection_Sequence_IntTools_Curve_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _IntTools.delete_NCollection_Sequence_IntTools_Curve_IteratorHelper

    def __next__(self):
        return _IntTools.NCollection_Sequence_IntTools_Curve_IteratorHelper___next__(self)
NCollection_Sequence_IntTools_Curve_IteratorHelper_swigregister = _IntTools.NCollection_Sequence_IntTools_Curve_IteratorHelper_swigregister
NCollection_Sequence_IntTools_Curve_IteratorHelper_swigregister(NCollection_Sequence_IntTools_Curve_IteratorHelper)


try:
	IntTools_SequenceOfCurves = NCollection_Sequence_IntTools_Curve
except NameError:
	pass # does not exist, probably ignored

class IntTools_PntOn2Faces(object):
    """Contains two points PntOnFace from IntTools and a flag"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(IntTools_PntOn2Faces self) -> IntTools_PntOn2Faces
        __init__(IntTools_PntOn2Faces self, IntTools_PntOnFace aP1, IntTools_PntOnFace aP2) -> IntTools_PntOn2Faces

        Initializes me by two points aP1 and aP2

        :type aP1: OCC.wrapper.IntTools.IntTools_PntOnFace
        :type aP2: OCC.wrapper.IntTools.IntTools_PntOnFace

        """
        this = _IntTools.new_IntTools_PntOn2Faces(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def SetP1(self, *args):
        """
        SetP1(IntTools_PntOn2Faces self, IntTools_PntOnFace aP1)

        Modifier

        :type aP1: OCC.wrapper.IntTools.IntTools_PntOnFace

        """
        return _IntTools.IntTools_PntOn2Faces_SetP1(self, *args)


    def SetP2(self, *args):
        """
        SetP2(IntTools_PntOn2Faces self, IntTools_PntOnFace aP2)

        Modifier

        :type aP2: OCC.wrapper.IntTools.IntTools_PntOnFace

        """
        return _IntTools.IntTools_PntOn2Faces_SetP2(self, *args)


    def SetValid(self, *args):
        """
        SetValid(IntTools_PntOn2Faces self, Standard_Boolean const bF)

        Modifier

        :type bF: bool

        """
        return _IntTools.IntTools_PntOn2Faces_SetValid(self, *args)


    def P1(self, *args):
        """
        Selector

        :rtype: OCC.wrapper.IntTools.IntTools_PntOnFace

        """
        res = _IntTools.IntTools_PntOn2Faces_P1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def P2(self, *args):
        """
        Selector

        :rtype: OCC.wrapper.IntTools.IntTools_PntOnFace

        """
        res = _IntTools.IntTools_PntOn2Faces_P2(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def IsValid(self, *args):
        """
        IsValid(IntTools_PntOn2Faces self) -> Standard_Boolean

        Selector

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntTools.IntTools_PntOn2Faces_IsValid(self, *args)

    __swig_destroy__ = _IntTools.delete_IntTools_PntOn2Faces
IntTools_PntOn2Faces_swigregister = _IntTools.IntTools_PntOn2Faces_swigregister
IntTools_PntOn2Faces_swigregister(IntTools_PntOn2Faces)

class NCollection_List_IntTools_CurveRangeSample_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _IntTools.new_NCollection_List_IntTools_CurveRangeSample_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _IntTools.delete_NCollection_List_IntTools_CurveRangeSample_IteratorHelper

    def __next__(self):
        return _IntTools.NCollection_List_IntTools_CurveRangeSample_IteratorHelper___next__(self)
NCollection_List_IntTools_CurveRangeSample_IteratorHelper_swigregister = _IntTools.NCollection_List_IntTools_CurveRangeSample_IteratorHelper_swigregister
NCollection_List_IntTools_CurveRangeSample_IteratorHelper_swigregister(NCollection_List_IntTools_CurveRangeSample_IteratorHelper)


try:
	IntTools_ListOfCurveRangeSample = NCollection_List_IntTools_CurveRangeSample
except NameError:
	pass # does not exist, probably ignored

class NCollection_Sequence_IntTools_PntOn2Faces(NCollection.NCollection_BaseSequence):
    """
    Purpose:     Definition of a sequence of elements indexed by
    an Integer in range of 1..n
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Sequence_IntTools_PntOn2Faces self) -> NCollection_Sequence< IntTools_PntOn2Faces >::iterator

        Returns an iterator pointing to the first element in the sequence.

        :rtype: iterator

        """
        return _IntTools.NCollection_Sequence_IntTools_PntOn2Faces_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Sequence_IntTools_PntOn2Faces self) -> NCollection_Sequence< IntTools_PntOn2Faces >::iterator

        Returns an iterator referring to the past-the-end element in the sequence.

        :rtype: iterator

        """
        return _IntTools.NCollection_Sequence_IntTools_PntOn2Faces_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Sequence_IntTools_PntOn2Faces self) -> NCollection_Sequence< IntTools_PntOn2Faces >::const_iterator

        Returns a const iterator pointing to the first element in the sequence.

        :rtype: const_iterator

        """
        return _IntTools.NCollection_Sequence_IntTools_PntOn2Faces_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Sequence_IntTools_PntOn2Faces self) -> NCollection_Sequence< IntTools_PntOn2Faces >::const_iterator

        Returns a const iterator referring to the past-the-end element in the sequence.

        :rtype: const_iterator

        """
        return _IntTools.NCollection_Sequence_IntTools_PntOn2Faces_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     Definition of a sequence of elements indexed by
        an Integer in range of 1..n
        """
        this = _IntTools.new_NCollection_Sequence_IntTools_PntOn2Faces(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Size(self, *args):
        """
        Size(NCollection_Sequence_IntTools_PntOn2Faces self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntTools.NCollection_Sequence_IntTools_PntOn2Faces_Size(self, *args)


    def Length(self, *args):
        """
        Length(NCollection_Sequence_IntTools_PntOn2Faces self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntTools.NCollection_Sequence_IntTools_PntOn2Faces_Length(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Sequence_IntTools_PntOn2Faces self) -> Standard_Integer

        Method for consistency with other collections.
        @return Lower bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntTools.NCollection_Sequence_IntTools_PntOn2Faces_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Sequence_IntTools_PntOn2Faces self) -> Standard_Integer

        Method for consistency with other collections.
        @return Upper bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntTools.NCollection_Sequence_IntTools_PntOn2Faces_Upper(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Sequence_IntTools_PntOn2Faces self) -> Standard_Boolean

        Empty query

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntTools.NCollection_Sequence_IntTools_PntOn2Faces_IsEmpty(self, *args)


    def Reverse(self, *args):
        """
        Reverse(NCollection_Sequence_IntTools_PntOn2Faces self)

        Reverse sequence


        """
        return _IntTools.NCollection_Sequence_IntTools_PntOn2Faces_Reverse(self, *args)


    def Exchange(self, *args):
        """
        Exchange(NCollection_Sequence_IntTools_PntOn2Faces self, Standard_Integer const I, Standard_Integer const J)

        Exchange two members

        :type I: int
        :type J: int

        """
        return _IntTools.NCollection_Sequence_IntTools_PntOn2Faces_Exchange(self, *args)


    def delNode(*args):
        """
        delNode(NCollection_SeqNode theNode, Handle_NCollection_BaseAllocator theAl)

        Static deleter to be passed to BaseSequence

        :type theNode: OCC.wrapper.NCollection.NCollection_SeqNode
        :type theAl: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _IntTools.NCollection_Sequence_IntTools_PntOn2Faces_delNode(*args)

    delNode = staticmethod(delNode)

    def Clear(self, *args):
        """
        Clear(NCollection_Sequence_IntTools_PntOn2Faces self, Handle_NCollection_BaseAllocator theAllocator=0)

        Clear the items out, take a new allocator if non null

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _IntTools.NCollection_Sequence_IntTools_PntOn2Faces_Clear(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Sequence_IntTools_PntOn2Faces self, NCollection_Sequence_IntTools_PntOn2Faces theOther) -> NCollection_Sequence_IntTools_PntOn2Faces

        Replace this sequence by the items of theOther.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_Sequence
        :rtype: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _IntTools.NCollection_Sequence_IntTools_PntOn2Faces_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Sequence_IntTools_PntOn2Faces self, NCollection_Sequence_IntTools_PntOn2Faces theOther) -> NCollection_Sequence_IntTools_PntOn2Faces

        Replacement operator

        :type theOther: OCC.wrapper.NCollection.NCollection_Sequence
        :rtype: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _IntTools.NCollection_Sequence_IntTools_PntOn2Faces_assign(self, *args)


    def Remove(self, *args):
        """
        Remove(NCollection_Sequence_IntTools_PntOn2Faces self, NCollection_Sequence< IntTools_PntOn2Faces >::Iterator & thePosition)
        Remove(NCollection_Sequence_IntTools_PntOn2Faces self, Standard_Integer const theIndex)
        Remove(NCollection_Sequence_IntTools_PntOn2Faces self, Standard_Integer const theFromIndex, Standard_Integer const theToIndex)

        Remove range of items

        :type theFromIndex: int
        :type theToIndex: int

        """
        return _IntTools.NCollection_Sequence_IntTools_PntOn2Faces_Remove(self, *args)


    def Append(self, *args):
        """
        Append(NCollection_Sequence_IntTools_PntOn2Faces self, IntTools_PntOn2Faces theItem)
        Append(NCollection_Sequence_IntTools_PntOn2Faces self, NCollection_Sequence_IntTools_PntOn2Faces theSeq)

        Append another sequence (making it empty)

        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _IntTools.NCollection_Sequence_IntTools_PntOn2Faces_Append(self, *args)


    def Prepend(self, *args):
        """
        Prepend(NCollection_Sequence_IntTools_PntOn2Faces self, IntTools_PntOn2Faces theItem)
        Prepend(NCollection_Sequence_IntTools_PntOn2Faces self, NCollection_Sequence_IntTools_PntOn2Faces theSeq)

        Prepend another sequence (making it empty)

        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _IntTools.NCollection_Sequence_IntTools_PntOn2Faces_Prepend(self, *args)


    def InsertBefore(self, *args):
        """
        InsertBefore(NCollection_Sequence_IntTools_PntOn2Faces self, Standard_Integer const theIndex, IntTools_PntOn2Faces theItem)
        InsertBefore(NCollection_Sequence_IntTools_PntOn2Faces self, Standard_Integer const theIndex, NCollection_Sequence_IntTools_PntOn2Faces theSeq)

        InsertBefore theIndex another sequence

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _IntTools.NCollection_Sequence_IntTools_PntOn2Faces_InsertBefore(self, *args)


    def InsertAfter(self, *args):
        """
        InsertAfter(NCollection_Sequence_IntTools_PntOn2Faces self, NCollection_Sequence< IntTools_PntOn2Faces >::Iterator & thePosition, IntTools_PntOn2Faces theItem)
        InsertAfter(NCollection_Sequence_IntTools_PntOn2Faces self, Standard_Integer const theIndex, NCollection_Sequence_IntTools_PntOn2Faces theSeq)
        InsertAfter(NCollection_Sequence_IntTools_PntOn2Faces self, Standard_Integer const theIndex, IntTools_PntOn2Faces theItem)

        InsertAfter theIndex another sequence

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _IntTools.NCollection_Sequence_IntTools_PntOn2Faces_InsertAfter(self, *args)


    def Split(self, *args):
        """
        Split(NCollection_Sequence_IntTools_PntOn2Faces self, Standard_Integer const theIndex, NCollection_Sequence_IntTools_PntOn2Faces theSeq)

        Split in two sequences

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _IntTools.NCollection_Sequence_IntTools_PntOn2Faces_Split(self, *args)


    def First(self, *args):
        """
        First item access

        :rtype: const TheItemType &

        """
        res = _IntTools.NCollection_Sequence_IntTools_PntOn2Faces_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Sequence_IntTools_PntOn2Faces self) -> IntTools_PntOn2Faces

        First item access

        :rtype: TheItemType &

        """
        return _IntTools.NCollection_Sequence_IntTools_PntOn2Faces_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        Last item access

        :rtype: const TheItemType &

        """
        res = _IntTools.NCollection_Sequence_IntTools_PntOn2Faces_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Sequence_IntTools_PntOn2Faces self) -> IntTools_PntOn2Faces

        Last item access

        :rtype: TheItemType &

        """
        return _IntTools.NCollection_Sequence_IntTools_PntOn2Faces_ChangeLast(self, *args)


    def Value(self, *args):
        """
        Constant item access by theIndex

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _IntTools.NCollection_Sequence_IntTools_PntOn2Faces_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Sequence_IntTools_PntOn2Faces self, Standard_Integer const theIndex) -> IntTools_PntOn2Faces

        Variable item access by theIndex

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _IntTools.NCollection_Sequence_IntTools_PntOn2Faces_ChangeValue(self, *args)


    def __call__(self, *args):
        """
        Constant operator()

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _IntTools.NCollection_Sequence_IntTools_PntOn2Faces___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetValue(self, *args):
        """
        SetValue(NCollection_Sequence_IntTools_PntOn2Faces self, Standard_Integer const theIndex, IntTools_PntOn2Faces theItem)

        Set item value by theIndex

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _IntTools.NCollection_Sequence_IntTools_PntOn2Faces_SetValue(self, *args)


    def __iter__(self):
        return _IntTools.NCollection_Sequence_IntTools_PntOn2Faces___iter__(self)
    __swig_destroy__ = _IntTools.delete_NCollection_Sequence_IntTools_PntOn2Faces
NCollection_Sequence_IntTools_PntOn2Faces_swigregister = _IntTools.NCollection_Sequence_IntTools_PntOn2Faces_swigregister
NCollection_Sequence_IntTools_PntOn2Faces_swigregister(NCollection_Sequence_IntTools_PntOn2Faces)

def NCollection_Sequence_IntTools_PntOn2Faces_delNode(*args):
    """
    NCollection_Sequence_IntTools_PntOn2Faces_delNode(NCollection_SeqNode theNode, Handle_NCollection_BaseAllocator theAl)

    Static deleter to be passed to BaseSequence

    :type theNode: OCC.wrapper.NCollection.NCollection_SeqNode
    :type theAl: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

    """
    return _IntTools.NCollection_Sequence_IntTools_PntOn2Faces_delNode(*args)

class NCollection_Sequence_IntTools_PntOn2Faces_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _IntTools.new_NCollection_Sequence_IntTools_PntOn2Faces_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _IntTools.delete_NCollection_Sequence_IntTools_PntOn2Faces_IteratorHelper

    def __next__(self):
        return _IntTools.NCollection_Sequence_IntTools_PntOn2Faces_IteratorHelper___next__(self)
NCollection_Sequence_IntTools_PntOn2Faces_IteratorHelper_swigregister = _IntTools.NCollection_Sequence_IntTools_PntOn2Faces_IteratorHelper_swigregister
NCollection_Sequence_IntTools_PntOn2Faces_IteratorHelper_swigregister(NCollection_Sequence_IntTools_PntOn2Faces_IteratorHelper)


try:
	IntTools_SequenceOfPntOn2Faces = NCollection_Sequence_IntTools_PntOn2Faces
except NameError:
	pass # does not exist, probably ignored

class IntTools_CArray1OfReal(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(IntTools_CArray1OfReal self, Standard_Integer const Length=0) -> IntTools_CArray1OfReal
        __init__(IntTools_CArray1OfReal self, Standard_Real const & Item, Standard_Integer const Length) -> IntTools_CArray1OfReal

        Creates an array sharing datas with an other.
        Example:
        Item tab[100];
        CArray1OfItem thetab (tab[0],100);

        CArray1OfItem aArray1(100);
        CArray1OfItem anSharedArray1(aArray1.ChangeValue(0),aArray1.Length());

        Warning:
        The validity of length are under the responsability
        of the user.
        The sahred array must have a valid address during the life of
        the Array1.

        :type Item: float
        :type Length: int

        """
        this = _IntTools.new_IntTools_CArray1OfReal(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(IntTools_CArray1OfReal self, Standard_Real const & V)

        Initializes the array with a given value.

        :type V: float

        """
        return _IntTools.IntTools_CArray1OfReal_Init(self, *args)


    def Resize(self, *args):
        """
        Resize(IntTools_CArray1OfReal self, Standard_Integer const theNewLength)

        destroy current content and realloc the new size
        does nothing if Length() == theLength

        :type theNewLength: int

        """
        return _IntTools.IntTools_CArray1OfReal_Resize(self, *args)


    def Destroy(self, *args):
        """
        Destroy(IntTools_CArray1OfReal self)

        Frees the  allocated   area  corresponding  to the
        array.


        """
        return _IntTools.IntTools_CArray1OfReal_Destroy(self, *args)


    def Length(self, *args):
        """
        Length(IntTools_CArray1OfReal self) -> Standard_Integer

        Returns the number of elements of <me>.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntTools.IntTools_CArray1OfReal_Length(self, *args)


    def Append(self, *args):
        """
        Append(IntTools_CArray1OfReal self, Standard_Real const & Value)

        :type Value: float

        """
        return _IntTools.IntTools_CArray1OfReal_Append(self, *args)


    def SetValue(self, *args):
        """
        SetValue(IntTools_CArray1OfReal self, Standard_Integer const Index, Standard_Real const & Value)

        Sets  the   <Index>th  element  of   the  array to
        <Value>.

        :type Index: int
        :type Value: float

        """
        return _IntTools.IntTools_CArray1OfReal_SetValue(self, *args)


    def Value(self, *args):
        """
        Value(IntTools_CArray1OfReal self, Standard_Integer const Index) -> Standard_Real const &

        Returns the value of  the  <Index>th element of the
        array.

        :type Index: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _IntTools.IntTools_CArray1OfReal_Value(self, *args)


    def ChangeValue(self, *args):
        """
        ChangeValue(IntTools_CArray1OfReal self, Standard_Integer const Index) -> Standard_Real &

        Returns the value  of the <Index>th element  of the
        array.

        :type Index: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _IntTools.IntTools_CArray1OfReal_ChangeValue(self, *args)


    def __call__(self, *args):
        """
        __call__(IntTools_CArray1OfReal self, Standard_Integer const Index) -> Standard_Real const
        __call__(IntTools_CArray1OfReal self, Standard_Integer const Index) -> Standard_Real &

        :type Index: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _IntTools.IntTools_CArray1OfReal___call__(self, *args)


    def IsEqual(self, *args):
        """
        IsEqual(IntTools_CArray1OfReal self, IntTools_CArray1OfReal Other) -> Standard_Boolean

        Applys the == operator on each array item

        :type Other: OCC.wrapper.IntTools.IntTools_CArray1OfReal
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntTools.IntTools_CArray1OfReal_IsEqual(self, *args)


    def __eq__(self, *args):
        """
        __eq__(IntTools_CArray1OfReal self, IntTools_CArray1OfReal Other) -> Standard_Boolean

        :type Other: OCC.wrapper.IntTools.IntTools_CArray1OfReal
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntTools.IntTools_CArray1OfReal___eq__(self, *args)

    __swig_destroy__ = _IntTools.delete_IntTools_CArray1OfReal
IntTools_CArray1OfReal_swigregister = _IntTools.IntTools_CArray1OfReal_swigregister
IntTools_CArray1OfReal_swigregister(IntTools_CArray1OfReal)

class IntTools_FClass2d(object):
    """
    Class provides an algorithm to classify a 2d Point
    in 2d space of face using boundaries of the face.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(IntTools_FClass2d self) -> IntTools_FClass2d
        __init__(IntTools_FClass2d self, TopoDS_Face F, Standard_Real const Tol) -> IntTools_FClass2d

        Initializes algorithm by the face F
        and tolerance Tol

        :type F: OCC.wrapper.TopoDS.TopoDS_Face
        :type Tol: float

        """
        this = _IntTools.new_IntTools_FClass2d(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(IntTools_FClass2d self, TopoDS_Face F, Standard_Real const Tol)

        Initializes algorithm by the face F
        and tolerance Tol

        :type F: OCC.wrapper.TopoDS.TopoDS_Face
        :type Tol: float

        """
        return _IntTools.IntTools_FClass2d_Init(self, *args)


    def PerformInfinitePoint(self, *args):
        """
        PerformInfinitePoint(IntTools_FClass2d self) -> TopAbs_State

        Returns state of infinite 2d point relatively to (0, 0)

        :rtype: OCC.wrapper.TopAbs.TopAbs_State

        """
        return _IntTools.IntTools_FClass2d_PerformInfinitePoint(self, *args)


    def Perform(self, *args):
        """
        Perform(IntTools_FClass2d self, gp_Pnt2d Puv, Standard_Boolean const RecadreOnPeriodic) -> TopAbs_State

        Returns state of the 2d point Puv.
        If RecadreOnPeriodic is true (defalut value),
        for the periodic surface 2d point, adjusted to period, is
        classified.

        :type Puv: OCC.wrapper.gp.gp_Pnt2d
        :type RecadreOnPeriodic: bool
        :rtype: OCC.wrapper.TopAbs.TopAbs_State

        """
        return _IntTools.IntTools_FClass2d_Perform(self, *args)


    def Destroy(self, *args):
        """
        Destroy(IntTools_FClass2d self)

        Destructor


        """
        return _IntTools.IntTools_FClass2d_Destroy(self, *args)


    def TestOnRestriction(self, *args):
        """
        TestOnRestriction(IntTools_FClass2d self, gp_Pnt2d Puv, Standard_Real const Tol, Standard_Boolean const RecadreOnPeriodic) -> TopAbs_State

        Test a point with +- an offset (Tol) and returns
        On if some points are OUT an some are IN
        (Caution: Internal use . see the code for more details)

        :type Puv: OCC.wrapper.gp.gp_Pnt2d
        :type Tol: float
        :type RecadreOnPeriodic: bool
        :rtype: OCC.wrapper.TopAbs.TopAbs_State

        """
        return _IntTools.IntTools_FClass2d_TestOnRestriction(self, *args)


    def IsHole(self, *args):
        """
        IsHole(IntTools_FClass2d self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntTools.IntTools_FClass2d_IsHole(self, *args)

    __swig_destroy__ = _IntTools.delete_IntTools_FClass2d
IntTools_FClass2d_swigregister = _IntTools.IntTools_FClass2d_swigregister
IntTools_FClass2d_swigregister(IntTools_FClass2d)

class IntTools_CArray1OfInteger(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(IntTools_CArray1OfInteger self, Standard_Integer const Length=0) -> IntTools_CArray1OfInteger
        __init__(IntTools_CArray1OfInteger self, Standard_Integer const & Item, Standard_Integer const Length) -> IntTools_CArray1OfInteger

        Creates an array sharing datas with an other.
        Example:
        Item tab[100];
        CArray1OfItem thetab (tab[0],100);

        CArray1OfItem aArray1(100);
        CArray1OfItem anSharedArray1(aArray1.ChangeValue(0),aArray1.Length());

        Warning:
        The validity of length are under the responsability
        of the user.
        The sahred array must have a valid address during the life of
        the Array1.

        :type Item: int
        :type Length: int

        """
        this = _IntTools.new_IntTools_CArray1OfInteger(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(IntTools_CArray1OfInteger self, Standard_Integer const & V)

        Initializes the array with a given value.

        :type V: int

        """
        return _IntTools.IntTools_CArray1OfInteger_Init(self, *args)


    def Resize(self, *args):
        """
        Resize(IntTools_CArray1OfInteger self, Standard_Integer const theNewLength)

        destroy current content and realloc the new size
        does nothing if Length() == theLength

        :type theNewLength: int

        """
        return _IntTools.IntTools_CArray1OfInteger_Resize(self, *args)


    def Destroy(self, *args):
        """
        Destroy(IntTools_CArray1OfInteger self)

        Frees the  allocated   area  corresponding  to the
        array.


        """
        return _IntTools.IntTools_CArray1OfInteger_Destroy(self, *args)


    def Length(self, *args):
        """
        Length(IntTools_CArray1OfInteger self) -> Standard_Integer

        Returns the number of elements of <me>.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntTools.IntTools_CArray1OfInteger_Length(self, *args)


    def Append(self, *args):
        """
        Append(IntTools_CArray1OfInteger self, Standard_Integer const & Value)

        :type Value: int

        """
        return _IntTools.IntTools_CArray1OfInteger_Append(self, *args)


    def SetValue(self, *args):
        """
        SetValue(IntTools_CArray1OfInteger self, Standard_Integer const Index, Standard_Integer const & Value)

        Sets  the   <Index>th  element  of   the  array to
        <Value>.

        :type Index: int
        :type Value: int

        """
        return _IntTools.IntTools_CArray1OfInteger_SetValue(self, *args)


    def Value(self, *args):
        """
        Value(IntTools_CArray1OfInteger self, Standard_Integer const Index) -> Standard_Integer const &

        Returns the value of  the  <Index>th element of the
        array.

        :type Index: int
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntTools.IntTools_CArray1OfInteger_Value(self, *args)


    def ChangeValue(self, *args):
        """
        ChangeValue(IntTools_CArray1OfInteger self, Standard_Integer const Index) -> Standard_Integer &

        Returns the value  of the <Index>th element  of the
        array.

        :type Index: int
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntTools.IntTools_CArray1OfInteger_ChangeValue(self, *args)


    def __call__(self, *args):
        """
        __call__(IntTools_CArray1OfInteger self, Standard_Integer const Index) -> Standard_Integer const
        __call__(IntTools_CArray1OfInteger self, Standard_Integer const Index) -> Standard_Integer &

        :type Index: int
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntTools.IntTools_CArray1OfInteger___call__(self, *args)


    def IsEqual(self, *args):
        """
        IsEqual(IntTools_CArray1OfInteger self, IntTools_CArray1OfInteger Other) -> Standard_Boolean

        Applys the == operator on each array item

        :type Other: OCC.wrapper.IntTools.IntTools_CArray1OfInteger
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntTools.IntTools_CArray1OfInteger_IsEqual(self, *args)


    def __eq__(self, *args):
        """
        __eq__(IntTools_CArray1OfInteger self, IntTools_CArray1OfInteger Other) -> Standard_Boolean

        :type Other: OCC.wrapper.IntTools.IntTools_CArray1OfInteger
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntTools.IntTools_CArray1OfInteger___eq__(self, *args)

    __swig_destroy__ = _IntTools.delete_IntTools_CArray1OfInteger
IntTools_CArray1OfInteger_swigregister = _IntTools.IntTools_CArray1OfInteger_swigregister
IntTools_CArray1OfInteger_swigregister(IntTools_CArray1OfInteger)


try:
	TColStd_MapTransientHasher = TColStd.NCollection_DefaultHasher_Handle_Standard_Transient
except AttributeError:
	pass # does not exist, probably ignored

class IntTools_EdgeFace(object):
    """
    The class provides Edge/Face intersection algorithm to determine
    common parts between edge and face in 3-d space.
    Common parts between Edge and Face can be:
    - Vertices - in case of intersection or touching;
    - Edge - in case of full coincidence of the edge with the face.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(IntTools_EdgeFace self) -> IntTools_EdgeFace

        Empty Constructor


        """
        this = _IntTools.new_IntTools_EdgeFace(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def SetEdge(self, *args):
        """
        SetEdge(IntTools_EdgeFace self, TopoDS_Edge theEdge)

        Sets the edge for intersection

        :type theEdge: OCC.wrapper.TopoDS.TopoDS_Edge

        """
        return _IntTools.IntTools_EdgeFace_SetEdge(self, *args)


    def Edge(self, *args):
        """
        Returns the edge

        :rtype: OCC.wrapper.TopoDS.TopoDS_Edge

        """
        res = _IntTools.IntTools_EdgeFace_Edge(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetFace(self, *args):
        """
        SetFace(IntTools_EdgeFace self, TopoDS_Face theFace)

        Sets the face for intersection

        :type theFace: OCC.wrapper.TopoDS.TopoDS_Face

        """
        return _IntTools.IntTools_EdgeFace_SetFace(self, *args)


    def Face(self, *args):
        """
        Returns the face

        :rtype: OCC.wrapper.TopoDS.TopoDS_Face

        """
        res = _IntTools.IntTools_EdgeFace_Face(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetRange(self, *args):
        """
        SetRange(IntTools_EdgeFace self, IntTools_Range theRange)
        SetRange(IntTools_EdgeFace self, Standard_Real const theFirst, Standard_Real const theLast)

        Sets the boundaries for the edge.
        The algorithm processes edge inside these boundaries.

        :type theFirst: float
        :type theLast: float

        """
        return _IntTools.IntTools_EdgeFace_SetRange(self, *args)


    def Range(self, *args):
        """
        Returns intersection range of the edge

        :rtype: OCC.wrapper.IntTools.IntTools_Range

        """
        res = _IntTools.IntTools_EdgeFace_Range(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetContext(self, *args):
        """
        SetContext(IntTools_EdgeFace self, Handle_IntTools_Context theContext)

        Sets the intersection context

        :type theContext: OCC.wrapper.IntTools.Handle_IntTools_Context

        """
        return _IntTools.IntTools_EdgeFace_SetContext(self, *args)


    def Context(self, *args):
        """
        Returns the intersection context

        :rtype: OCC.wrapper.IntTools.Handle_IntTools_Context

        """
        res = _IntTools.IntTools_EdgeFace_Context(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetFuzzyValue(self, *args):
        """
        SetFuzzyValue(IntTools_EdgeFace self, Standard_Real const theFuzz)

        Sets the Fuzzy value

        :type theFuzz: float

        """
        return _IntTools.IntTools_EdgeFace_SetFuzzyValue(self, *args)


    def FuzzyValue(self, *args):
        """
        FuzzyValue(IntTools_EdgeFace self) -> Standard_Real

        Returns the Fuzzy value

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _IntTools.IntTools_EdgeFace_FuzzyValue(self, *args)


    def UseQuickCoincidenceCheck(self, *args):
        """
        UseQuickCoincidenceCheck(IntTools_EdgeFace self, Standard_Boolean const theFlag)

        Sets the flag for quick coincidence check.
        It is safe to use the quick check for coincidence only if both
        of the following conditions are met:
        - The vertices of edge are lying on the face;
        - The edge does not intersect the boundaries of the face on the given range.

        :type theFlag: bool

        """
        return _IntTools.IntTools_EdgeFace_UseQuickCoincidenceCheck(self, *args)


    def IsCoincidenceCheckedQuickly(self, *args):
        """
        IsCoincidenceCheckedQuickly(IntTools_EdgeFace self) -> Standard_Boolean

        Returns the flag myQuickCoincidenceCheck

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntTools.IntTools_EdgeFace_IsCoincidenceCheckedQuickly(self, *args)


    def Perform(self, *args):
        """
        Perform(IntTools_EdgeFace self)

        Launches the process


        """
        return _IntTools.IntTools_EdgeFace_Perform(self, *args)


    def IsDone(self, *args):
        """
        IsDone(IntTools_EdgeFace self) -> Standard_Boolean

        Returns TRUE if computation was successful.
        Otherwise returns FALSE.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntTools.IntTools_EdgeFace_IsDone(self, *args)


    def ErrorStatus(self, *args):
        """
        ErrorStatus(IntTools_EdgeFace self) -> Standard_Integer

        Returns the code of completion:
        0 - means successful completion;
        1 - the process was not started;
        2,3 - invalid source data for the algorithm;
        4 - projection failed.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntTools.IntTools_EdgeFace_ErrorStatus(self, *args)


    def CommonParts(self, *args):
        """
        Returns resulting common parts

        :rtype: OCC.wrapper.IntTools.IntTools_SequenceOfCommonPrts

        """
        res = _IntTools.IntTools_EdgeFace_CommonParts(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _IntTools.delete_IntTools_EdgeFace
IntTools_EdgeFace_swigregister = _IntTools.IntTools_EdgeFace_swigregister
IntTools_EdgeFace_swigregister(IntTools_EdgeFace)

class NCollection_Sequence_IntTools_Root(NCollection.NCollection_BaseSequence):
    """
    Purpose:     Definition of a sequence of elements indexed by
    an Integer in range of 1..n
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Sequence_IntTools_Root self) -> NCollection_Sequence< IntTools_Root >::iterator

        Returns an iterator pointing to the first element in the sequence.

        :rtype: iterator

        """
        return _IntTools.NCollection_Sequence_IntTools_Root_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Sequence_IntTools_Root self) -> NCollection_Sequence< IntTools_Root >::iterator

        Returns an iterator referring to the past-the-end element in the sequence.

        :rtype: iterator

        """
        return _IntTools.NCollection_Sequence_IntTools_Root_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Sequence_IntTools_Root self) -> NCollection_Sequence< IntTools_Root >::const_iterator

        Returns a const iterator pointing to the first element in the sequence.

        :rtype: const_iterator

        """
        return _IntTools.NCollection_Sequence_IntTools_Root_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Sequence_IntTools_Root self) -> NCollection_Sequence< IntTools_Root >::const_iterator

        Returns a const iterator referring to the past-the-end element in the sequence.

        :rtype: const_iterator

        """
        return _IntTools.NCollection_Sequence_IntTools_Root_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     Definition of a sequence of elements indexed by
        an Integer in range of 1..n
        """
        this = _IntTools.new_NCollection_Sequence_IntTools_Root(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Size(self, *args):
        """
        Size(NCollection_Sequence_IntTools_Root self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntTools.NCollection_Sequence_IntTools_Root_Size(self, *args)


    def Length(self, *args):
        """
        Length(NCollection_Sequence_IntTools_Root self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntTools.NCollection_Sequence_IntTools_Root_Length(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Sequence_IntTools_Root self) -> Standard_Integer

        Method for consistency with other collections.
        @return Lower bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntTools.NCollection_Sequence_IntTools_Root_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Sequence_IntTools_Root self) -> Standard_Integer

        Method for consistency with other collections.
        @return Upper bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntTools.NCollection_Sequence_IntTools_Root_Upper(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Sequence_IntTools_Root self) -> Standard_Boolean

        Empty query

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntTools.NCollection_Sequence_IntTools_Root_IsEmpty(self, *args)


    def Reverse(self, *args):
        """
        Reverse(NCollection_Sequence_IntTools_Root self)

        Reverse sequence


        """
        return _IntTools.NCollection_Sequence_IntTools_Root_Reverse(self, *args)


    def Exchange(self, *args):
        """
        Exchange(NCollection_Sequence_IntTools_Root self, Standard_Integer const I, Standard_Integer const J)

        Exchange two members

        :type I: int
        :type J: int

        """
        return _IntTools.NCollection_Sequence_IntTools_Root_Exchange(self, *args)


    def delNode(*args):
        """
        delNode(NCollection_SeqNode theNode, Handle_NCollection_BaseAllocator theAl)

        Static deleter to be passed to BaseSequence

        :type theNode: OCC.wrapper.NCollection.NCollection_SeqNode
        :type theAl: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _IntTools.NCollection_Sequence_IntTools_Root_delNode(*args)

    delNode = staticmethod(delNode)

    def Clear(self, *args):
        """
        Clear(NCollection_Sequence_IntTools_Root self, Handle_NCollection_BaseAllocator theAllocator=0)

        Clear the items out, take a new allocator if non null

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _IntTools.NCollection_Sequence_IntTools_Root_Clear(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Sequence_IntTools_Root self, NCollection_Sequence_IntTools_Root theOther) -> NCollection_Sequence_IntTools_Root

        Replace this sequence by the items of theOther.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_Sequence
        :rtype: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _IntTools.NCollection_Sequence_IntTools_Root_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Sequence_IntTools_Root self, NCollection_Sequence_IntTools_Root theOther) -> NCollection_Sequence_IntTools_Root

        Replacement operator

        :type theOther: OCC.wrapper.NCollection.NCollection_Sequence
        :rtype: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _IntTools.NCollection_Sequence_IntTools_Root_assign(self, *args)


    def Remove(self, *args):
        """
        Remove(NCollection_Sequence_IntTools_Root self, NCollection_Sequence< IntTools_Root >::Iterator & thePosition)
        Remove(NCollection_Sequence_IntTools_Root self, Standard_Integer const theIndex)
        Remove(NCollection_Sequence_IntTools_Root self, Standard_Integer const theFromIndex, Standard_Integer const theToIndex)

        Remove range of items

        :type theFromIndex: int
        :type theToIndex: int

        """
        return _IntTools.NCollection_Sequence_IntTools_Root_Remove(self, *args)


    def Append(self, *args):
        """
        Append(NCollection_Sequence_IntTools_Root self, IntTools_Root theItem)
        Append(NCollection_Sequence_IntTools_Root self, NCollection_Sequence_IntTools_Root theSeq)

        Append another sequence (making it empty)

        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _IntTools.NCollection_Sequence_IntTools_Root_Append(self, *args)


    def Prepend(self, *args):
        """
        Prepend(NCollection_Sequence_IntTools_Root self, IntTools_Root theItem)
        Prepend(NCollection_Sequence_IntTools_Root self, NCollection_Sequence_IntTools_Root theSeq)

        Prepend another sequence (making it empty)

        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _IntTools.NCollection_Sequence_IntTools_Root_Prepend(self, *args)


    def InsertBefore(self, *args):
        """
        InsertBefore(NCollection_Sequence_IntTools_Root self, Standard_Integer const theIndex, IntTools_Root theItem)
        InsertBefore(NCollection_Sequence_IntTools_Root self, Standard_Integer const theIndex, NCollection_Sequence_IntTools_Root theSeq)

        InsertBefore theIndex another sequence

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _IntTools.NCollection_Sequence_IntTools_Root_InsertBefore(self, *args)


    def InsertAfter(self, *args):
        """
        InsertAfter(NCollection_Sequence_IntTools_Root self, NCollection_Sequence< IntTools_Root >::Iterator & thePosition, IntTools_Root theItem)
        InsertAfter(NCollection_Sequence_IntTools_Root self, Standard_Integer const theIndex, NCollection_Sequence_IntTools_Root theSeq)
        InsertAfter(NCollection_Sequence_IntTools_Root self, Standard_Integer const theIndex, IntTools_Root theItem)

        InsertAfter theIndex another sequence

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _IntTools.NCollection_Sequence_IntTools_Root_InsertAfter(self, *args)


    def Split(self, *args):
        """
        Split(NCollection_Sequence_IntTools_Root self, Standard_Integer const theIndex, NCollection_Sequence_IntTools_Root theSeq)

        Split in two sequences

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _IntTools.NCollection_Sequence_IntTools_Root_Split(self, *args)


    def First(self, *args):
        """
        First item access

        :rtype: const TheItemType &

        """
        res = _IntTools.NCollection_Sequence_IntTools_Root_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Sequence_IntTools_Root self) -> IntTools_Root

        First item access

        :rtype: TheItemType &

        """
        return _IntTools.NCollection_Sequence_IntTools_Root_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        Last item access

        :rtype: const TheItemType &

        """
        res = _IntTools.NCollection_Sequence_IntTools_Root_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Sequence_IntTools_Root self) -> IntTools_Root

        Last item access

        :rtype: TheItemType &

        """
        return _IntTools.NCollection_Sequence_IntTools_Root_ChangeLast(self, *args)


    def Value(self, *args):
        """
        Constant item access by theIndex

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _IntTools.NCollection_Sequence_IntTools_Root_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Sequence_IntTools_Root self, Standard_Integer const theIndex) -> IntTools_Root

        Variable item access by theIndex

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _IntTools.NCollection_Sequence_IntTools_Root_ChangeValue(self, *args)


    def __call__(self, *args):
        """
        Constant operator()

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _IntTools.NCollection_Sequence_IntTools_Root___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetValue(self, *args):
        """
        SetValue(NCollection_Sequence_IntTools_Root self, Standard_Integer const theIndex, IntTools_Root theItem)

        Set item value by theIndex

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _IntTools.NCollection_Sequence_IntTools_Root_SetValue(self, *args)


    def __iter__(self):
        return _IntTools.NCollection_Sequence_IntTools_Root___iter__(self)
    __swig_destroy__ = _IntTools.delete_NCollection_Sequence_IntTools_Root
NCollection_Sequence_IntTools_Root_swigregister = _IntTools.NCollection_Sequence_IntTools_Root_swigregister
NCollection_Sequence_IntTools_Root_swigregister(NCollection_Sequence_IntTools_Root)

def NCollection_Sequence_IntTools_Root_delNode(*args):
    """
    NCollection_Sequence_IntTools_Root_delNode(NCollection_SeqNode theNode, Handle_NCollection_BaseAllocator theAl)

    Static deleter to be passed to BaseSequence

    :type theNode: OCC.wrapper.NCollection.NCollection_SeqNode
    :type theAl: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

    """
    return _IntTools.NCollection_Sequence_IntTools_Root_delNode(*args)

class NCollection_Sequence_IntTools_Root_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _IntTools.new_NCollection_Sequence_IntTools_Root_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _IntTools.delete_NCollection_Sequence_IntTools_Root_IteratorHelper

    def __next__(self):
        return _IntTools.NCollection_Sequence_IntTools_Root_IteratorHelper___next__(self)
NCollection_Sequence_IntTools_Root_IteratorHelper_swigregister = _IntTools.NCollection_Sequence_IntTools_Root_IteratorHelper_swigregister
NCollection_Sequence_IntTools_Root_IteratorHelper_swigregister(NCollection_Sequence_IntTools_Root_IteratorHelper)


try:
	IntTools_SequenceOfRoots = NCollection_Sequence_IntTools_Root
except NameError:
	pass # does not exist, probably ignored

class NCollection_Map_IntTools_SurfaceRangeSample_IntTools_SurfaceRangeSampleMapHasher(NCollection.NCollection_BaseMap):
    """
    Purpose:     Single hashed Map. This  Map is used  to store and
    retrieve keys in linear time.

    The ::Iterator class can be  used to explore  the
    content of the map. It is not  wise to iterate and
    modify a map in parallel.

    To compute  the hashcode of  the key the  function
    ::HashCode must be defined in the global namespace

    To compare two keys the function ::IsEqual must be
    defined in the global namespace.

    The performance of  a Map is conditionned  by  its
    number of buckets that  should be kept greater  to
    the number   of keys.  This  map has  an automatic
    management of the number of buckets. It is resized
    when  the number of Keys  becomes greater than the
    number of buckets.

    If you have a fair  idea of the number of  objects
    you  can save on automatic   resizing by giving  a
    number of buckets  at creation or using the ReSize
    method. This should be  consider only for  crucial
    optimisation issues.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def cbegin(self, *args):
        """
        cbegin(NCollection_Map_IntTools_SurfaceRangeSample_IntTools_SurfaceRangeSampleMapHasher self) -> NCollection_Map< IntTools_SurfaceRangeSample,IntTools_SurfaceRangeSampleMapHasher >::const_iterator

        Returns a const iterator pointing to the first element in the map.

        :rtype: const_iterator

        """
        return _IntTools.NCollection_Map_IntTools_SurfaceRangeSample_IntTools_SurfaceRangeSampleMapHasher_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Map_IntTools_SurfaceRangeSample_IntTools_SurfaceRangeSampleMapHasher self) -> NCollection_Map< IntTools_SurfaceRangeSample,IntTools_SurfaceRangeSampleMapHasher >::const_iterator

        Returns a const iterator referring to the past-the-end element in the map.

        :rtype: const_iterator

        """
        return _IntTools.NCollection_Map_IntTools_SurfaceRangeSample_IntTools_SurfaceRangeSampleMapHasher_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     Single hashed Map. This  Map is used  to store and
        retrieve keys in linear time.

        The ::Iterator class can be  used to explore  the
        content of the map. It is not  wise to iterate and
        modify a map in parallel.

        To compute  the hashcode of  the key the  function
        ::HashCode must be defined in the global namespace

        To compare two keys the function ::IsEqual must be
        defined in the global namespace.

        The performance of  a Map is conditionned  by  its
        number of buckets that  should be kept greater  to
        the number   of keys.  This  map has  an automatic
        management of the number of buckets. It is resized
        when  the number of Keys  becomes greater than the
        number of buckets.

        If you have a fair  idea of the number of  objects
        you  can save on automatic   resizing by giving  a
        number of buckets  at creation or using the ReSize
        method. This should be  consider only for  crucial
        optimisation issues.
        """
        this = _IntTools.new_NCollection_Map_IntTools_SurfaceRangeSample_IntTools_SurfaceRangeSampleMapHasher(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Exchange(self, *args):
        """
        Exchange(NCollection_Map_IntTools_SurfaceRangeSample_IntTools_SurfaceRangeSampleMapHasher self, NCollection_Map_IntTools_SurfaceRangeSample_IntTools_SurfaceRangeSampleMapHasher theOther)

        Exchange the content of two maps without re-allocations.
        Notice that allocators will be swapped as well!

        :type theOther: OCC.wrapper.NCollection.NCollection_Map

        """
        return _IntTools.NCollection_Map_IntTools_SurfaceRangeSample_IntTools_SurfaceRangeSampleMapHasher_Exchange(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Map_IntTools_SurfaceRangeSample_IntTools_SurfaceRangeSampleMapHasher self, NCollection_Map_IntTools_SurfaceRangeSample_IntTools_SurfaceRangeSampleMapHasher theOther) -> NCollection_Map_IntTools_SurfaceRangeSample_IntTools_SurfaceRangeSampleMapHasher

        Assign.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_Map
        :rtype: OCC.wrapper.NCollection.NCollection_Map

        """
        return _IntTools.NCollection_Map_IntTools_SurfaceRangeSample_IntTools_SurfaceRangeSampleMapHasher_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Map_IntTools_SurfaceRangeSample_IntTools_SurfaceRangeSampleMapHasher self, NCollection_Map_IntTools_SurfaceRangeSample_IntTools_SurfaceRangeSampleMapHasher theOther) -> NCollection_Map_IntTools_SurfaceRangeSample_IntTools_SurfaceRangeSampleMapHasher

        Assign operator

        :type theOther: OCC.wrapper.NCollection.NCollection_Map
        :rtype: OCC.wrapper.NCollection.NCollection_Map

        """
        return _IntTools.NCollection_Map_IntTools_SurfaceRangeSample_IntTools_SurfaceRangeSampleMapHasher_assign(self, *args)


    def ReSize(self, *args):
        """
        ReSize(NCollection_Map_IntTools_SurfaceRangeSample_IntTools_SurfaceRangeSampleMapHasher self, Standard_Integer const N)

        ReSize

        :type N: int

        """
        return _IntTools.NCollection_Map_IntTools_SurfaceRangeSample_IntTools_SurfaceRangeSampleMapHasher_ReSize(self, *args)


    def Add(self, *args):
        """
        Add(NCollection_Map_IntTools_SurfaceRangeSample_IntTools_SurfaceRangeSampleMapHasher self, IntTools_SurfaceRangeSample K) -> Standard_Boolean

        Add

        :type K: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntTools.NCollection_Map_IntTools_SurfaceRangeSample_IntTools_SurfaceRangeSampleMapHasher_Add(self, *args)


    def Added(self, *args):
        """
        Added: add a new key if not yet in the map, and return 
        reference to either newly added or previously existing object

        :type K: const TheKeyType &
        :rtype: const TheKeyType &

        """
        res = _IntTools.NCollection_Map_IntTools_SurfaceRangeSample_IntTools_SurfaceRangeSampleMapHasher_Added(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Remove(self, *args):
        """
        Remove(NCollection_Map_IntTools_SurfaceRangeSample_IntTools_SurfaceRangeSampleMapHasher self, IntTools_SurfaceRangeSample K) -> Standard_Boolean

        Remove

        :type K: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntTools.NCollection_Map_IntTools_SurfaceRangeSample_IntTools_SurfaceRangeSampleMapHasher_Remove(self, *args)


    def Clear(self, *args):
        """
        Clear(NCollection_Map_IntTools_SurfaceRangeSample_IntTools_SurfaceRangeSampleMapHasher self, Standard_Boolean const doReleaseMemory)
        Clear(NCollection_Map_IntTools_SurfaceRangeSample_IntTools_SurfaceRangeSampleMapHasher self, Handle_NCollection_BaseAllocator theAllocator)

        Clear data and reset allocator

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _IntTools.NCollection_Map_IntTools_SurfaceRangeSample_IntTools_SurfaceRangeSampleMapHasher_Clear(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_Map_IntTools_SurfaceRangeSample_IntTools_SurfaceRangeSampleMapHasher self) -> Standard_Integer

        Size

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntTools.NCollection_Map_IntTools_SurfaceRangeSample_IntTools_SurfaceRangeSampleMapHasher_Size(self, *args)


    def IsEqual(self, *args):
        """
        IsEqual(NCollection_Map_IntTools_SurfaceRangeSample_IntTools_SurfaceRangeSampleMapHasher self, NCollection_Map_IntTools_SurfaceRangeSample_IntTools_SurfaceRangeSampleMapHasher theOther) -> Standard_Boolean

        @return true if two maps contains exactly the same keys

        :type theOther: OCC.wrapper.NCollection.NCollection_Map
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntTools.NCollection_Map_IntTools_SurfaceRangeSample_IntTools_SurfaceRangeSampleMapHasher_IsEqual(self, *args)


    def Contains(self, *args):
        """
        Contains(NCollection_Map_IntTools_SurfaceRangeSample_IntTools_SurfaceRangeSampleMapHasher self, IntTools_SurfaceRangeSample K) -> Standard_Boolean
        Contains(NCollection_Map_IntTools_SurfaceRangeSample_IntTools_SurfaceRangeSampleMapHasher self, NCollection_Map_IntTools_SurfaceRangeSample_IntTools_SurfaceRangeSampleMapHasher theOther) -> Standard_Boolean

        @return true if this map contains ALL keys of another map.

        :type theOther: OCC.wrapper.NCollection.NCollection_Map
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntTools.NCollection_Map_IntTools_SurfaceRangeSample_IntTools_SurfaceRangeSampleMapHasher_Contains(self, *args)


    def Union(self, *args):
        """
        Union(NCollection_Map_IntTools_SurfaceRangeSample_IntTools_SurfaceRangeSampleMapHasher self, NCollection_Map_IntTools_SurfaceRangeSample_IntTools_SurfaceRangeSampleMapHasher theLeft, NCollection_Map_IntTools_SurfaceRangeSample_IntTools_SurfaceRangeSampleMapHasher theRight)

        Sets this Map to be the result of union (aka addition, fuse, merge, boolean OR) operation between two given Maps
        The new Map contains the values that are contained either in the first map or in the second map or in both.
        All previous content of this Map is cleared.
        This map (result of the boolean operation) can also be passed as one of operands.

        :type theLeft: OCC.wrapper.NCollection.NCollection_Map
        :type theRight: OCC.wrapper.NCollection.NCollection_Map

        """
        return _IntTools.NCollection_Map_IntTools_SurfaceRangeSample_IntTools_SurfaceRangeSampleMapHasher_Union(self, *args)


    def Unite(self, *args):
        """
        Unite(NCollection_Map_IntTools_SurfaceRangeSample_IntTools_SurfaceRangeSampleMapHasher self, NCollection_Map_IntTools_SurfaceRangeSample_IntTools_SurfaceRangeSampleMapHasher theOther) -> Standard_Boolean

        Apply to this Map the boolean operation union (aka addition, fuse, merge, boolean OR) with another (given) Map.
        The result contains the values that were previously contained in this map or contained in the given (operand) map.
        This algorithm is similar to method Union().
        Returns True if contents of this map is changed.

        :type theOther: OCC.wrapper.NCollection.NCollection_Map
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntTools.NCollection_Map_IntTools_SurfaceRangeSample_IntTools_SurfaceRangeSampleMapHasher_Unite(self, *args)


    def HasIntersection(self, *args):
        """
        HasIntersection(NCollection_Map_IntTools_SurfaceRangeSample_IntTools_SurfaceRangeSampleMapHasher self, NCollection_Map_IntTools_SurfaceRangeSample_IntTools_SurfaceRangeSampleMapHasher theMap) -> Standard_Boolean

        Returns true if this and theMap have common elements.

        :type theMap: OCC.wrapper.NCollection.NCollection_Map
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntTools.NCollection_Map_IntTools_SurfaceRangeSample_IntTools_SurfaceRangeSampleMapHasher_HasIntersection(self, *args)


    def Intersection(self, *args):
        """
        Intersection(NCollection_Map_IntTools_SurfaceRangeSample_IntTools_SurfaceRangeSampleMapHasher self, NCollection_Map_IntTools_SurfaceRangeSample_IntTools_SurfaceRangeSampleMapHasher theLeft, NCollection_Map_IntTools_SurfaceRangeSample_IntTools_SurfaceRangeSampleMapHasher theRight)

        Sets this Map to be the result of intersection (aka multiplication, common, boolean AND) operation between two given Maps.
        The new Map contains only the values that are contained in both map operands.
        All previous content of this Map is cleared.
        This same map (result of the boolean operation) can also be used as one of operands.

        :type theLeft: OCC.wrapper.NCollection.NCollection_Map
        :type theRight: OCC.wrapper.NCollection.NCollection_Map

        """
        return _IntTools.NCollection_Map_IntTools_SurfaceRangeSample_IntTools_SurfaceRangeSampleMapHasher_Intersection(self, *args)


    def Intersect(self, *args):
        """
        Intersect(NCollection_Map_IntTools_SurfaceRangeSample_IntTools_SurfaceRangeSampleMapHasher self, NCollection_Map_IntTools_SurfaceRangeSample_IntTools_SurfaceRangeSampleMapHasher theOther) -> Standard_Boolean

        Apply to this Map the intersection operation (aka multiplication, common, boolean AND) with another (given) Map.
        The result contains only the values that are contained in both this and the given maps.
        This algorithm is similar to method Intersection().
        Returns True if contents of this map is changed.

        :type theOther: OCC.wrapper.NCollection.NCollection_Map
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntTools.NCollection_Map_IntTools_SurfaceRangeSample_IntTools_SurfaceRangeSampleMapHasher_Intersect(self, *args)


    def Subtraction(self, *args):
        """
        Subtraction(NCollection_Map_IntTools_SurfaceRangeSample_IntTools_SurfaceRangeSampleMapHasher self, NCollection_Map_IntTools_SurfaceRangeSample_IntTools_SurfaceRangeSampleMapHasher theLeft, NCollection_Map_IntTools_SurfaceRangeSample_IntTools_SurfaceRangeSampleMapHasher theRight)

        Sets this Map to be the result of subtraction (aka set-theoretic difference, relative complement,
        exclude, cut, boolean NOT) operation between two given Maps.
        The new Map contains only the values that are contained in the first map operands and not contained in the second one.
        All previous content of this Map is cleared.

        :type theLeft: OCC.wrapper.NCollection.NCollection_Map
        :type theRight: OCC.wrapper.NCollection.NCollection_Map

        """
        return _IntTools.NCollection_Map_IntTools_SurfaceRangeSample_IntTools_SurfaceRangeSampleMapHasher_Subtraction(self, *args)


    def Subtract(self, *args):
        """
        Subtract(NCollection_Map_IntTools_SurfaceRangeSample_IntTools_SurfaceRangeSampleMapHasher self, NCollection_Map_IntTools_SurfaceRangeSample_IntTools_SurfaceRangeSampleMapHasher theOther) -> Standard_Boolean

        Apply to this Map the subtraction (aka set-theoretic difference, relative complement,
        exclude, cut, boolean NOT) operation with another (given) Map.
        The result contains only the values that were previously contained in this map and not contained in this map.
        This algorithm is similar to method Subtract() with two operands.
        Returns True if contents of this map is changed.

        :type theOther: OCC.wrapper.NCollection.NCollection_Map
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntTools.NCollection_Map_IntTools_SurfaceRangeSample_IntTools_SurfaceRangeSampleMapHasher_Subtract(self, *args)


    def Difference(self, *args):
        """
        Difference(NCollection_Map_IntTools_SurfaceRangeSample_IntTools_SurfaceRangeSampleMapHasher self, NCollection_Map_IntTools_SurfaceRangeSample_IntTools_SurfaceRangeSampleMapHasher theLeft, NCollection_Map_IntTools_SurfaceRangeSample_IntTools_SurfaceRangeSampleMapHasher theRight)

        Sets this Map to be the result of symmetric difference (aka exclusive disjunction, boolean XOR) operation between two given Maps.
        The new Map contains the values that are contained only in the first or the second operand maps but not in both.
        All previous content of this Map is cleared. This map (result of the boolean operation) can also be used as one of operands.

        :type theLeft: OCC.wrapper.NCollection.NCollection_Map
        :type theRight: OCC.wrapper.NCollection.NCollection_Map

        """
        return _IntTools.NCollection_Map_IntTools_SurfaceRangeSample_IntTools_SurfaceRangeSampleMapHasher_Difference(self, *args)


    def Differ(self, *args):
        """
        Differ(NCollection_Map_IntTools_SurfaceRangeSample_IntTools_SurfaceRangeSampleMapHasher self, NCollection_Map_IntTools_SurfaceRangeSample_IntTools_SurfaceRangeSampleMapHasher theOther) -> Standard_Boolean

        Apply to this Map the symmetric difference (aka exclusive disjunction, boolean XOR) operation with another (given) Map.
        The result contains the values that are contained only in this or the operand map, but not in both.
        This algorithm is similar to method Difference().
        Returns True if contents of this map is changed.

        :type theOther: OCC.wrapper.NCollection.NCollection_Map
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntTools.NCollection_Map_IntTools_SurfaceRangeSample_IntTools_SurfaceRangeSampleMapHasher_Differ(self, *args)


    def __iter__(self):
        return _IntTools.NCollection_Map_IntTools_SurfaceRangeSample_IntTools_SurfaceRangeSampleMapHasher___iter__(self)
    __swig_destroy__ = _IntTools.delete_NCollection_Map_IntTools_SurfaceRangeSample_IntTools_SurfaceRangeSampleMapHasher
NCollection_Map_IntTools_SurfaceRangeSample_IntTools_SurfaceRangeSampleMapHasher_swigregister = _IntTools.NCollection_Map_IntTools_SurfaceRangeSample_IntTools_SurfaceRangeSampleMapHasher_swigregister
NCollection_Map_IntTools_SurfaceRangeSample_IntTools_SurfaceRangeSampleMapHasher_swigregister(NCollection_Map_IntTools_SurfaceRangeSample_IntTools_SurfaceRangeSampleMapHasher)

class NCollection_Map_IntTools_SurfaceRangeSample_IntTools_SurfaceRangeSampleMapHasher_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _IntTools.new_NCollection_Map_IntTools_SurfaceRangeSample_IntTools_SurfaceRangeSampleMapHasher_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _IntTools.delete_NCollection_Map_IntTools_SurfaceRangeSample_IntTools_SurfaceRangeSampleMapHasher_IteratorHelper

    def __next__(self):
        return _IntTools.NCollection_Map_IntTools_SurfaceRangeSample_IntTools_SurfaceRangeSampleMapHasher_IteratorHelper___next__(self)
NCollection_Map_IntTools_SurfaceRangeSample_IntTools_SurfaceRangeSampleMapHasher_IteratorHelper_swigregister = _IntTools.NCollection_Map_IntTools_SurfaceRangeSample_IntTools_SurfaceRangeSampleMapHasher_IteratorHelper_swigregister
NCollection_Map_IntTools_SurfaceRangeSample_IntTools_SurfaceRangeSampleMapHasher_IteratorHelper_swigregister(NCollection_Map_IntTools_SurfaceRangeSample_IntTools_SurfaceRangeSampleMapHasher_IteratorHelper)


try:
	IntTools_MapOfSurfaceSample = NCollection_Map_IntTools_SurfaceRangeSample_IntTools_SurfaceRangeSampleMapHasher
except NameError:
	pass # does not exist, probably ignored

class IntTools_EdgeEdge(object):
    """
    The class provides Edge/Edge intersection algorithm
    based on the intersection between edges bounding boxes.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(IntTools_EdgeEdge self) -> IntTools_EdgeEdge
        __init__(IntTools_EdgeEdge self, TopoDS_Edge theEdge1, TopoDS_Edge theEdge2) -> IntTools_EdgeEdge
        __init__(IntTools_EdgeEdge self, TopoDS_Edge theEdge1, Standard_Real const aT11, Standard_Real const aT12, TopoDS_Edge theEdge2, Standard_Real const aT21, Standard_Real const aT22) -> IntTools_EdgeEdge

        Contructor

        :type theEdge1: OCC.wrapper.TopoDS.TopoDS_Edge
        :type aT11: float
        :type aT12: float
        :type theEdge2: OCC.wrapper.TopoDS.TopoDS_Edge
        :type aT21: float
        :type aT22: float

        """
        this = _IntTools.new_IntTools_EdgeEdge(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def SetEdge1(self, *args):
        """
        SetEdge1(IntTools_EdgeEdge self, TopoDS_Edge theEdge)
        SetEdge1(IntTools_EdgeEdge self, TopoDS_Edge theEdge, Standard_Real const aT1, Standard_Real const aT2)

        Sets the first edge and its range

        :type theEdge: OCC.wrapper.TopoDS.TopoDS_Edge
        :type aT1: float
        :type aT2: float

        """
        return _IntTools.IntTools_EdgeEdge_SetEdge1(self, *args)


    def SetRange1(self, *args):
        """
        SetRange1(IntTools_EdgeEdge self, IntTools_Range theRange1)
        SetRange1(IntTools_EdgeEdge self, Standard_Real const aT1, Standard_Real const aT2)

        Sets the range for the first edge

        :type aT1: float
        :type aT2: float

        """
        return _IntTools.IntTools_EdgeEdge_SetRange1(self, *args)


    def SetEdge2(self, *args):
        """
        SetEdge2(IntTools_EdgeEdge self, TopoDS_Edge theEdge)
        SetEdge2(IntTools_EdgeEdge self, TopoDS_Edge theEdge, Standard_Real const aT1, Standard_Real const aT2)

        Sets the first edge and its range

        :type theEdge: OCC.wrapper.TopoDS.TopoDS_Edge
        :type aT1: float
        :type aT2: float

        """
        return _IntTools.IntTools_EdgeEdge_SetEdge2(self, *args)


    def SetRange2(self, *args):
        """
        SetRange2(IntTools_EdgeEdge self, IntTools_Range theRange)
        SetRange2(IntTools_EdgeEdge self, Standard_Real const aT1, Standard_Real const aT2)

        Sets the range for the second edge

        :type aT1: float
        :type aT2: float

        """
        return _IntTools.IntTools_EdgeEdge_SetRange2(self, *args)


    def SetFuzzyValue(self, *args):
        """
        SetFuzzyValue(IntTools_EdgeEdge self, Standard_Real const theFuzz)

        Sets the Fuzzy value

        :type theFuzz: float

        """
        return _IntTools.IntTools_EdgeEdge_SetFuzzyValue(self, *args)


    def Perform(self, *args):
        """
        Perform(IntTools_EdgeEdge self)

        Performs the intersection between edges


        """
        return _IntTools.IntTools_EdgeEdge_Perform(self, *args)


    def IsDone(self, *args):
        """
        IsDone(IntTools_EdgeEdge self) -> Standard_Boolean

        Returns TRUE if common part(s) is(are) found

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntTools.IntTools_EdgeEdge_IsDone(self, *args)


    def FuzzyValue(self, *args):
        """
        FuzzyValue(IntTools_EdgeEdge self) -> Standard_Real

        Returns Fuzzy value

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _IntTools.IntTools_EdgeEdge_FuzzyValue(self, *args)


    def CommonParts(self, *args):
        """
        Returns common parts

        :rtype: OCC.wrapper.IntTools.IntTools_SequenceOfCommonPrts

        """
        res = _IntTools.IntTools_EdgeEdge_CommonParts(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def UseQuickCoincidenceCheck(self, *args):
        """
        UseQuickCoincidenceCheck(IntTools_EdgeEdge self, Standard_Boolean const bFlag)

        Sets the flag myQuickCoincidenceCheck

        :type bFlag: bool

        """
        return _IntTools.IntTools_EdgeEdge_UseQuickCoincidenceCheck(self, *args)


    def IsCoincidenceCheckedQuickly(self, *args):
        """
        IsCoincidenceCheckedQuickly(IntTools_EdgeEdge self) -> Standard_Boolean

        Returns the flag myQuickCoincidenceCheck

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntTools.IntTools_EdgeEdge_IsCoincidenceCheckedQuickly(self, *args)

    __swig_destroy__ = _IntTools.delete_IntTools_EdgeEdge
IntTools_EdgeEdge_swigregister = _IntTools.IntTools_EdgeEdge_swigregister
IntTools_EdgeEdge_swigregister(IntTools_EdgeEdge)

class NCollection_DataMap_IntTools_CurveRangeSample_Bnd_Box_IntTools_CurveRangeSampleMapHasher(NCollection.NCollection_BaseMap):
    """
    Purpose:     The DataMap is a Map to store keys with associated
    Items. See Map  from NCollection for  a discussion
    about the number of buckets.

    The DataMap can be seen as an extended array where
    the Keys  are the   indices.  For this reason  the
    operator () is defined on DataMap to fetch an Item
    from a Key. So the following syntax can be used :

    anItem = aMap(aKey);
    aMap(aKey) = anItem;

    This analogy has its  limit.   aMap(aKey) = anItem
    can  be done only  if aKey was previously bound to
    an item in the map.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_DataMap_IntTools_CurveRangeSample_Bnd_Box_IntTools_CurveRangeSampleMapHasher self) -> NCollection_DataMap< IntTools_CurveRangeSample,Bnd_Box,IntTools_CurveRangeSampleMapHasher >::iterator

        Returns an iterator pointing to the first element in the map.

        :rtype: iterator

        """
        return _IntTools.NCollection_DataMap_IntTools_CurveRangeSample_Bnd_Box_IntTools_CurveRangeSampleMapHasher_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_DataMap_IntTools_CurveRangeSample_Bnd_Box_IntTools_CurveRangeSampleMapHasher self) -> NCollection_DataMap< IntTools_CurveRangeSample,Bnd_Box,IntTools_CurveRangeSampleMapHasher >::iterator

        Returns an iterator referring to the past-the-end element in the map.

        :rtype: iterator

        """
        return _IntTools.NCollection_DataMap_IntTools_CurveRangeSample_Bnd_Box_IntTools_CurveRangeSampleMapHasher_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_DataMap_IntTools_CurveRangeSample_Bnd_Box_IntTools_CurveRangeSampleMapHasher self) -> NCollection_DataMap< IntTools_CurveRangeSample,Bnd_Box,IntTools_CurveRangeSampleMapHasher >::const_iterator

        Returns a const iterator pointing to the first element in the map.

        :rtype: const_iterator

        """
        return _IntTools.NCollection_DataMap_IntTools_CurveRangeSample_Bnd_Box_IntTools_CurveRangeSampleMapHasher_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_DataMap_IntTools_CurveRangeSample_Bnd_Box_IntTools_CurveRangeSampleMapHasher self) -> NCollection_DataMap< IntTools_CurveRangeSample,Bnd_Box,IntTools_CurveRangeSampleMapHasher >::const_iterator

        Returns a const iterator referring to the past-the-end element in the map.

        :rtype: const_iterator

        """
        return _IntTools.NCollection_DataMap_IntTools_CurveRangeSample_Bnd_Box_IntTools_CurveRangeSampleMapHasher_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     The DataMap is a Map to store keys with associated
        Items. See Map  from NCollection for  a discussion
        about the number of buckets.

        The DataMap can be seen as an extended array where
        the Keys  are the   indices.  For this reason  the
        operator () is defined on DataMap to fetch an Item
        from a Key. So the following syntax can be used :

        anItem = aMap(aKey);
        aMap(aKey) = anItem;

        This analogy has its  limit.   aMap(aKey) = anItem
        can  be done only  if aKey was previously bound to
        an item in the map.
        """
        this = _IntTools.new_NCollection_DataMap_IntTools_CurveRangeSample_Bnd_Box_IntTools_CurveRangeSampleMapHasher(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Exchange(self, *args):
        """
        Exchange(NCollection_DataMap_IntTools_CurveRangeSample_Bnd_Box_IntTools_CurveRangeSampleMapHasher self, NCollection_DataMap_IntTools_CurveRangeSample_Bnd_Box_IntTools_CurveRangeSampleMapHasher theOther)

        Exchange the content of two maps without re-allocations.
        Notice that allocators will be swapped as well!

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _IntTools.NCollection_DataMap_IntTools_CurveRangeSample_Bnd_Box_IntTools_CurveRangeSampleMapHasher_Exchange(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_DataMap_IntTools_CurveRangeSample_Bnd_Box_IntTools_CurveRangeSampleMapHasher self, NCollection_DataMap_IntTools_CurveRangeSample_Bnd_Box_IntTools_CurveRangeSampleMapHasher theOther) -> NCollection_DataMap_IntTools_CurveRangeSample_Bnd_Box_IntTools_CurveRangeSampleMapHasher

        Assignment.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _IntTools.NCollection_DataMap_IntTools_CurveRangeSample_Bnd_Box_IntTools_CurveRangeSampleMapHasher_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_DataMap_IntTools_CurveRangeSample_Bnd_Box_IntTools_CurveRangeSampleMapHasher self, NCollection_DataMap_IntTools_CurveRangeSample_Bnd_Box_IntTools_CurveRangeSampleMapHasher theOther) -> NCollection_DataMap_IntTools_CurveRangeSample_Bnd_Box_IntTools_CurveRangeSampleMapHasher

        Assignment operator

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _IntTools.NCollection_DataMap_IntTools_CurveRangeSample_Bnd_Box_IntTools_CurveRangeSampleMapHasher_assign(self, *args)


    def ReSize(self, *args):
        """
        ReSize(NCollection_DataMap_IntTools_CurveRangeSample_Bnd_Box_IntTools_CurveRangeSampleMapHasher self, Standard_Integer const N)

        ReSize

        :type N: int

        """
        return _IntTools.NCollection_DataMap_IntTools_CurveRangeSample_Bnd_Box_IntTools_CurveRangeSampleMapHasher_ReSize(self, *args)


    def Bind(self, *args):
        """
        Bind(NCollection_DataMap_IntTools_CurveRangeSample_Bnd_Box_IntTools_CurveRangeSampleMapHasher self, IntTools_CurveRangeSample theKey, Bnd_Box theItem) -> Standard_Boolean

        Bind binds Item to Key in map.
        @param theKey  key to add/update
        @param theItem new item; overrides value previously bound to the key, if any
        @return Standard_True if Key was not bound already

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntTools.NCollection_DataMap_IntTools_CurveRangeSample_Bnd_Box_IntTools_CurveRangeSampleMapHasher_Bind(self, *args)


    def Bound(self, *args):
        """
        Bound(NCollection_DataMap_IntTools_CurveRangeSample_Bnd_Box_IntTools_CurveRangeSampleMapHasher self, IntTools_CurveRangeSample theKey, Bnd_Box theItem) -> Bnd_Box

        Bound binds Item to Key in map. Returns modifiable Item 

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: TheItemType *

        """
        return _IntTools.NCollection_DataMap_IntTools_CurveRangeSample_Bnd_Box_IntTools_CurveRangeSampleMapHasher_Bound(self, *args)


    def IsBound(self, *args):
        """
        IsBound(NCollection_DataMap_IntTools_CurveRangeSample_Bnd_Box_IntTools_CurveRangeSampleMapHasher self, IntTools_CurveRangeSample theKey) -> Standard_Boolean

        IsBound

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntTools.NCollection_DataMap_IntTools_CurveRangeSample_Bnd_Box_IntTools_CurveRangeSampleMapHasher_IsBound(self, *args)


    def UnBind(self, *args):
        """
        UnBind(NCollection_DataMap_IntTools_CurveRangeSample_Bnd_Box_IntTools_CurveRangeSampleMapHasher self, IntTools_CurveRangeSample theKey) -> Standard_Boolean

        UnBind removes Item Key pair from map

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntTools.NCollection_DataMap_IntTools_CurveRangeSample_Bnd_Box_IntTools_CurveRangeSampleMapHasher_UnBind(self, *args)


    def Seek(self, *args):
        """
        Seek(NCollection_DataMap_IntTools_CurveRangeSample_Bnd_Box_IntTools_CurveRangeSampleMapHasher self, IntTools_CurveRangeSample theKey) -> Bnd_Box

        Seek returns pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: const TheItemType *

        """
        return _IntTools.NCollection_DataMap_IntTools_CurveRangeSample_Bnd_Box_IntTools_CurveRangeSampleMapHasher_Seek(self, *args)


    def Find(self, *args):
        """
        Find returns the Item for Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _IntTools.NCollection_DataMap_IntTools_CurveRangeSample_Bnd_Box_IntTools_CurveRangeSampleMapHasher_Find(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeSeek(self, *args):
        """
        ChangeSeek(NCollection_DataMap_IntTools_CurveRangeSample_Bnd_Box_IntTools_CurveRangeSampleMapHasher self, IntTools_CurveRangeSample theKey) -> Bnd_Box

        ChangeSeek returns modifiable pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: TheItemType *

        """
        return _IntTools.NCollection_DataMap_IntTools_CurveRangeSample_Bnd_Box_IntTools_CurveRangeSampleMapHasher_ChangeSeek(self, *args)


    def ChangeFind(self, *args):
        """
        ChangeFind(NCollection_DataMap_IntTools_CurveRangeSample_Bnd_Box_IntTools_CurveRangeSampleMapHasher self, IntTools_CurveRangeSample theKey) -> Bnd_Box

        ChangeFind returns mofifiable Item by Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: TheItemType &

        """
        return _IntTools.NCollection_DataMap_IntTools_CurveRangeSample_Bnd_Box_IntTools_CurveRangeSampleMapHasher_ChangeFind(self, *args)


    def __call__(self, *args):
        """
        operator ()

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _IntTools.NCollection_DataMap_IntTools_CurveRangeSample_Bnd_Box_IntTools_CurveRangeSampleMapHasher___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Clear(self, *args):
        """
        Clear(NCollection_DataMap_IntTools_CurveRangeSample_Bnd_Box_IntTools_CurveRangeSampleMapHasher self, Standard_Boolean const doReleaseMemory)
        Clear(NCollection_DataMap_IntTools_CurveRangeSample_Bnd_Box_IntTools_CurveRangeSampleMapHasher self, Handle_NCollection_BaseAllocator theAllocator)

        Clear data and reset allocator

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _IntTools.NCollection_DataMap_IntTools_CurveRangeSample_Bnd_Box_IntTools_CurveRangeSampleMapHasher_Clear(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_DataMap_IntTools_CurveRangeSample_Bnd_Box_IntTools_CurveRangeSampleMapHasher self) -> Standard_Integer

        Size

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntTools.NCollection_DataMap_IntTools_CurveRangeSample_Bnd_Box_IntTools_CurveRangeSampleMapHasher_Size(self, *args)


    def __iter__(self):
        return _IntTools.NCollection_DataMap_IntTools_CurveRangeSample_Bnd_Box_IntTools_CurveRangeSampleMapHasher___iter__(self)
    __swig_destroy__ = _IntTools.delete_NCollection_DataMap_IntTools_CurveRangeSample_Bnd_Box_IntTools_CurveRangeSampleMapHasher
NCollection_DataMap_IntTools_CurveRangeSample_Bnd_Box_IntTools_CurveRangeSampleMapHasher_swigregister = _IntTools.NCollection_DataMap_IntTools_CurveRangeSample_Bnd_Box_IntTools_CurveRangeSampleMapHasher_swigregister
NCollection_DataMap_IntTools_CurveRangeSample_Bnd_Box_IntTools_CurveRangeSampleMapHasher_swigregister(NCollection_DataMap_IntTools_CurveRangeSample_Bnd_Box_IntTools_CurveRangeSampleMapHasher)

class NCollection_DataMap_IntTools_CurveRangeSample_Bnd_Box_IntTools_CurveRangeSampleMapHasher_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _IntTools.new_NCollection_DataMap_IntTools_CurveRangeSample_Bnd_Box_IntTools_CurveRangeSampleMapHasher_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _IntTools.delete_NCollection_DataMap_IntTools_CurveRangeSample_Bnd_Box_IntTools_CurveRangeSampleMapHasher_IteratorHelper

    def __next__(self):
        return _IntTools.NCollection_DataMap_IntTools_CurveRangeSample_Bnd_Box_IntTools_CurveRangeSampleMapHasher_IteratorHelper___next__(self)
NCollection_DataMap_IntTools_CurveRangeSample_Bnd_Box_IntTools_CurveRangeSampleMapHasher_IteratorHelper_swigregister = _IntTools.NCollection_DataMap_IntTools_CurveRangeSample_Bnd_Box_IntTools_CurveRangeSampleMapHasher_IteratorHelper_swigregister
NCollection_DataMap_IntTools_CurveRangeSample_Bnd_Box_IntTools_CurveRangeSampleMapHasher_IteratorHelper_swigregister(NCollection_DataMap_IntTools_CurveRangeSample_Bnd_Box_IntTools_CurveRangeSampleMapHasher_IteratorHelper)


try:
	IntTools_DataMapOfCurveSampleBox = NCollection_DataMap_IntTools_CurveRangeSample_Bnd_Box_IntTools_CurveRangeSampleMapHasher
except NameError:
	pass # does not exist, probably ignored

class IntTools_SurfaceRangeLocalizeData(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(IntTools_SurfaceRangeLocalizeData self) -> IntTools_SurfaceRangeLocalizeData
        __init__(IntTools_SurfaceRangeLocalizeData self, Standard_Integer const theNbSampleU, Standard_Integer const theNbSampleV, Standard_Real const theMinRangeU, Standard_Real const theMinRangeV) -> IntTools_SurfaceRangeLocalizeData
        __init__(IntTools_SurfaceRangeLocalizeData self, IntTools_SurfaceRangeLocalizeData Other) -> IntTools_SurfaceRangeLocalizeData

        :type Other: OCC.wrapper.IntTools.IntTools_SurfaceRangeLocalizeData

        """
        this = _IntTools.new_IntTools_SurfaceRangeLocalizeData(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Assign(self, *args):
        """
        Assign(IntTools_SurfaceRangeLocalizeData self, IntTools_SurfaceRangeLocalizeData Other) -> IntTools_SurfaceRangeLocalizeData

        :type Other: OCC.wrapper.IntTools.IntTools_SurfaceRangeLocalizeData
        :rtype: OCC.wrapper.IntTools.IntTools_SurfaceRangeLocalizeData

        """
        return _IntTools.IntTools_SurfaceRangeLocalizeData_Assign(self, *args)


    def assign(self, *args):
        """
        assign(IntTools_SurfaceRangeLocalizeData self, IntTools_SurfaceRangeLocalizeData Other) -> IntTools_SurfaceRangeLocalizeData

        :type Other: OCC.wrapper.IntTools.IntTools_SurfaceRangeLocalizeData
        :rtype: OCC.wrapper.IntTools.IntTools_SurfaceRangeLocalizeData

        """
        return _IntTools.IntTools_SurfaceRangeLocalizeData_assign(self, *args)


    def GetNbSampleU(self, *args):
        """
        GetNbSampleU(IntTools_SurfaceRangeLocalizeData self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntTools.IntTools_SurfaceRangeLocalizeData_GetNbSampleU(self, *args)


    def GetNbSampleV(self, *args):
        """
        GetNbSampleV(IntTools_SurfaceRangeLocalizeData self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntTools.IntTools_SurfaceRangeLocalizeData_GetNbSampleV(self, *args)


    def GetMinRangeU(self, *args):
        """
        GetMinRangeU(IntTools_SurfaceRangeLocalizeData self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _IntTools.IntTools_SurfaceRangeLocalizeData_GetMinRangeU(self, *args)


    def GetMinRangeV(self, *args):
        """
        GetMinRangeV(IntTools_SurfaceRangeLocalizeData self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _IntTools.IntTools_SurfaceRangeLocalizeData_GetMinRangeV(self, *args)


    def AddOutRange(self, *args):
        """
        AddOutRange(IntTools_SurfaceRangeLocalizeData self, IntTools_SurfaceRangeSample theRange)

        :type theRange: OCC.wrapper.IntTools.IntTools_SurfaceRangeSample

        """
        return _IntTools.IntTools_SurfaceRangeLocalizeData_AddOutRange(self, *args)


    def AddBox(self, *args):
        """
        AddBox(IntTools_SurfaceRangeLocalizeData self, IntTools_SurfaceRangeSample theRange, Bnd_Box theBox)

        :type theRange: OCC.wrapper.IntTools.IntTools_SurfaceRangeSample
        :type theBox: OCC.wrapper.Bnd.Bnd_Box

        """
        return _IntTools.IntTools_SurfaceRangeLocalizeData_AddBox(self, *args)


    def FindBox(self, *args):
        """
        FindBox(IntTools_SurfaceRangeLocalizeData self, IntTools_SurfaceRangeSample theRange, Bnd_Box theBox) -> Standard_Boolean

        :type theRange: OCC.wrapper.IntTools.IntTools_SurfaceRangeSample
        :type theBox: OCC.wrapper.Bnd.Bnd_Box
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntTools.IntTools_SurfaceRangeLocalizeData_FindBox(self, *args)


    def IsRangeOut(self, *args):
        """
        IsRangeOut(IntTools_SurfaceRangeLocalizeData self, IntTools_SurfaceRangeSample theRange) -> Standard_Boolean

        :type theRange: OCC.wrapper.IntTools.IntTools_SurfaceRangeSample
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntTools.IntTools_SurfaceRangeLocalizeData_IsRangeOut(self, *args)


    def ListRangeOut(self, *args):
        """
        ListRangeOut(IntTools_SurfaceRangeLocalizeData self, IntTools_ListOfSurfaceRangeSample & theList)

        :type theList: OCC.wrapper.IntTools.IntTools_ListOfSurfaceRangeSample

        """
        return _IntTools.IntTools_SurfaceRangeLocalizeData_ListRangeOut(self, *args)


    def RemoveRangeOutAll(self, *args):
        """RemoveRangeOutAll(IntTools_SurfaceRangeLocalizeData self)"""
        return _IntTools.IntTools_SurfaceRangeLocalizeData_RemoveRangeOutAll(self, *args)


    def SetGridDeflection(self, *args):
        """
        SetGridDeflection(IntTools_SurfaceRangeLocalizeData self, Standard_Real const theDeflection)

        Set the grid deflection.

        :type theDeflection: float

        """
        return _IntTools.IntTools_SurfaceRangeLocalizeData_SetGridDeflection(self, *args)


    def GetGridDeflection(self, *args):
        """
        GetGridDeflection(IntTools_SurfaceRangeLocalizeData self) -> Standard_Real

        Query the grid deflection.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _IntTools.IntTools_SurfaceRangeLocalizeData_GetGridDeflection(self, *args)


    def SetRangeUGrid(self, *args):
        """
        SetRangeUGrid(IntTools_SurfaceRangeLocalizeData self, Standard_Integer const theNbUGrid)

        Set the range U of the grid of points.

        :type theNbUGrid: int

        """
        return _IntTools.IntTools_SurfaceRangeLocalizeData_SetRangeUGrid(self, *args)


    def GetRangeUGrid(self, *args):
        """
        GetRangeUGrid(IntTools_SurfaceRangeLocalizeData self) -> Standard_Integer

        Query the range U of the grid of points.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntTools.IntTools_SurfaceRangeLocalizeData_GetRangeUGrid(self, *args)


    def SetUParam(self, *args):
        """
        SetUParam(IntTools_SurfaceRangeLocalizeData self, Standard_Integer const theIndex, Standard_Real const theUParam)

        Set the U parameter of the grid points at that index.

        :type theIndex: int
        :type theUParam: float

        """
        return _IntTools.IntTools_SurfaceRangeLocalizeData_SetUParam(self, *args)


    def GetUParam(self, *args):
        """
        GetUParam(IntTools_SurfaceRangeLocalizeData self, Standard_Integer const theIndex) -> Standard_Real

        Query the U parameter of the grid points at that index.

        :type theIndex: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _IntTools.IntTools_SurfaceRangeLocalizeData_GetUParam(self, *args)


    def SetRangeVGrid(self, *args):
        """
        SetRangeVGrid(IntTools_SurfaceRangeLocalizeData self, Standard_Integer const theNbVGrid)

        Set the range V of the grid of points.

        :type theNbVGrid: int

        """
        return _IntTools.IntTools_SurfaceRangeLocalizeData_SetRangeVGrid(self, *args)


    def GetRangeVGrid(self, *args):
        """
        GetRangeVGrid(IntTools_SurfaceRangeLocalizeData self) -> Standard_Integer

        Query the range V of the grid of points.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntTools.IntTools_SurfaceRangeLocalizeData_GetRangeVGrid(self, *args)


    def SetVParam(self, *args):
        """
        SetVParam(IntTools_SurfaceRangeLocalizeData self, Standard_Integer const theIndex, Standard_Real const theVParam)

        Set the V parameter of the grid points at that index.

        :type theIndex: int
        :type theVParam: float

        """
        return _IntTools.IntTools_SurfaceRangeLocalizeData_SetVParam(self, *args)


    def GetVParam(self, *args):
        """
        GetVParam(IntTools_SurfaceRangeLocalizeData self, Standard_Integer const theIndex) -> Standard_Real

        Query the V parameter of the grid points at that index.

        :type theIndex: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _IntTools.IntTools_SurfaceRangeLocalizeData_GetVParam(self, *args)


    def SetGridPoint(self, *args):
        """
        SetGridPoint(IntTools_SurfaceRangeLocalizeData self, Standard_Integer const theUIndex, Standard_Integer const theVIndex, gp_Pnt thePoint)

        Set the grid point.

        :type theUIndex: int
        :type theVIndex: int
        :type thePoint: OCC.wrapper.gp.gp_Pnt

        """
        return _IntTools.IntTools_SurfaceRangeLocalizeData_SetGridPoint(self, *args)


    def GetGridPoint(self, *args):
        """
        Set the grid point.

        :type theUIndex: int
        :type theVIndex: int
        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        res = _IntTools.IntTools_SurfaceRangeLocalizeData_GetGridPoint(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetFrame(self, *args):
        """
        SetFrame(IntTools_SurfaceRangeLocalizeData self, Standard_Real const theUMin, Standard_Real const theUMax, Standard_Real const theVMin, Standard_Real const theVMax)

        Sets the frame area. Used to work with grid points.

        :type theUMin: float
        :type theUMax: float
        :type theVMin: float
        :type theVMax: float

        """
        return _IntTools.IntTools_SurfaceRangeLocalizeData_SetFrame(self, *args)


    def GetNBUPointsInFrame(self, *args):
        """
        GetNBUPointsInFrame(IntTools_SurfaceRangeLocalizeData self) -> Standard_Integer

        Returns the number of grid points on U direction in frame.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntTools.IntTools_SurfaceRangeLocalizeData_GetNBUPointsInFrame(self, *args)


    def GetNBVPointsInFrame(self, *args):
        """
        GetNBVPointsInFrame(IntTools_SurfaceRangeLocalizeData self) -> Standard_Integer

        Returns the number of grid points on V direction in frame.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntTools.IntTools_SurfaceRangeLocalizeData_GetNBVPointsInFrame(self, *args)


    def GetPointInFrame(self, *args):
        """
        Returns the grid point in frame.

        :type theUIndex: int
        :type theVIndex: int
        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        res = _IntTools.IntTools_SurfaceRangeLocalizeData_GetPointInFrame(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def GetUParamInFrame(self, *args):
        """
        GetUParamInFrame(IntTools_SurfaceRangeLocalizeData self, Standard_Integer const theIndex) -> Standard_Real

        Query the U parameter of the grid points
        at that index in frame.

        :type theIndex: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _IntTools.IntTools_SurfaceRangeLocalizeData_GetUParamInFrame(self, *args)


    def GetVParamInFrame(self, *args):
        """
        GetVParamInFrame(IntTools_SurfaceRangeLocalizeData self, Standard_Integer const theIndex) -> Standard_Real

        Query the V parameter of the grid points
        at that index in frame.

        :type theIndex: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _IntTools.IntTools_SurfaceRangeLocalizeData_GetVParamInFrame(self, *args)


    def ClearGrid(self, *args):
        """
        ClearGrid(IntTools_SurfaceRangeLocalizeData self)

        Clears the grid of points.


        """
        return _IntTools.IntTools_SurfaceRangeLocalizeData_ClearGrid(self, *args)

    __swig_destroy__ = _IntTools.delete_IntTools_SurfaceRangeLocalizeData
IntTools_SurfaceRangeLocalizeData_swigregister = _IntTools.IntTools_SurfaceRangeLocalizeData_swigregister
IntTools_SurfaceRangeLocalizeData_swigregister(IntTools_SurfaceRangeLocalizeData)

class IntTools_Tools(object):
    """
    The class contains handy static functions
    dealing with the geometry and topology.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def ComputeVV(*args):
        """
        ComputeVV(TopoDS_Vertex V1, TopoDS_Vertex V2) -> Standard_Integer

        Computes distance between vertex V1 and vertex V2,
        if the distance is less than sum of vertex tolerances
        returns zero,
        otherwise returns negative value

        :type V1: OCC.wrapper.TopoDS.TopoDS_Vertex
        :type V2: OCC.wrapper.TopoDS.TopoDS_Vertex
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntTools.IntTools_Tools_ComputeVV(*args)

    ComputeVV = staticmethod(ComputeVV)

    def HasInternalEdge(*args):
        """
        HasInternalEdge(TopoDS_Wire aW) -> Standard_Boolean

        Returns True if wire aW contains edges
        with INTERNAL orientation

        :type aW: OCC.wrapper.TopoDS.TopoDS_Wire
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntTools.IntTools_Tools_HasInternalEdge(*args)

    HasInternalEdge = staticmethod(HasInternalEdge)

    def MakeFaceFromWireAndFace(*args):
        """
        MakeFaceFromWireAndFace(TopoDS_Wire aW, TopoDS_Face aF, TopoDS_Face aFNew)

        Build a face based on surface of given face aF
        and bounded by wire aW

        :type aW: OCC.wrapper.TopoDS.TopoDS_Wire
        :type aF: OCC.wrapper.TopoDS.TopoDS_Face
        :type aFNew: OCC.wrapper.TopoDS.TopoDS_Face

        """
        return _IntTools.IntTools_Tools_MakeFaceFromWireAndFace(*args)

    MakeFaceFromWireAndFace = staticmethod(MakeFaceFromWireAndFace)

    def ClassifyPointByFace(*args):
        """
        ClassifyPointByFace(TopoDS_Face aF, gp_Pnt2d P) -> TopAbs_State

        :type aF: OCC.wrapper.TopoDS.TopoDS_Face
        :type P: OCC.wrapper.gp.gp_Pnt2d
        :rtype: OCC.wrapper.TopAbs.TopAbs_State

        """
        return _IntTools.IntTools_Tools_ClassifyPointByFace(*args)

    ClassifyPointByFace = staticmethod(ClassifyPointByFace)

    def IsMiddlePointsEqual(*args):
        """
        IsMiddlePointsEqual(TopoDS_Edge E1, TopoDS_Edge E2) -> Standard_Boolean

        Gets boundary of parameters of E1 and E2.
        Computes 3d points on each corresponded to average parameters.
        Returns True if distance between computed points is less than
        sum of edge tolerance, otherwise returns False.

        :type E1: OCC.wrapper.TopoDS.TopoDS_Edge
        :type E2: OCC.wrapper.TopoDS.TopoDS_Edge
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntTools.IntTools_Tools_IsMiddlePointsEqual(*args)

    IsMiddlePointsEqual = staticmethod(IsMiddlePointsEqual)

    def IsVertex(*args):
        """
        IsVertex(TopoDS_Edge E, Standard_Real const t) -> Standard_Boolean
        IsVertex(TopoDS_Edge E, TopoDS_Vertex V, Standard_Real const t) -> Standard_Boolean
        IsVertex(IntTools_CommonPrt aCmnPrt) -> Standard_Boolean
        IsVertex(gp_Pnt aP, Standard_Real const aTolPV, TopoDS_Vertex aV) -> Standard_Boolean

        Returns True if the distance between point aP and
        vertex aV is less or equal to sum of aTolPV and
        vertex tolerance, otherwise returns False

        :type aP: OCC.wrapper.gp.gp_Pnt
        :type aTolPV: float
        :type aV: OCC.wrapper.TopoDS.TopoDS_Vertex
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntTools.IntTools_Tools_IsVertex(*args)

    IsVertex = staticmethod(IsVertex)

    def IntermediatePoint(*args):
        """
        IntermediatePoint(Standard_Real const aFirst, Standard_Real const aLast) -> Standard_Real

        Returns some value between aFirst and aLast

        :type aFirst: float
        :type aLast: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _IntTools.IntTools_Tools_IntermediatePoint(*args)

    IntermediatePoint = staticmethod(IntermediatePoint)

    def SplitCurve(*args):
        """
        SplitCurve(IntTools_Curve aC, NCollection_Sequence_IntTools_Curve aS) -> Standard_Integer

        Split aC by average parameter if aC is closed in 3D.
        Returns positive value if splitting has been done,
        otherwise returns zero.

        :type aC: OCC.wrapper.IntTools.IntTools_Curve
        :type aS: OCC.wrapper.IntTools.IntTools_SequenceOfCurves
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntTools.IntTools_Tools_SplitCurve(*args)

    SplitCurve = staticmethod(SplitCurve)

    def RejectLines(*args):
        """
        RejectLines(NCollection_Sequence_IntTools_Curve aSIn, NCollection_Sequence_IntTools_Curve aSOut)

        Puts curves from aSIn to aSOut except those curves that
        are coincide with first curve from aSIn.

        :type aSIn: OCC.wrapper.IntTools.IntTools_SequenceOfCurves
        :type aSOut: OCC.wrapper.IntTools.IntTools_SequenceOfCurves

        """
        return _IntTools.IntTools_Tools_RejectLines(*args)

    RejectLines = staticmethod(RejectLines)

    def IsDirsCoinside(*args):
        """
        IsDirsCoinside(gp_Dir D1, gp_Dir D2) -> Standard_Boolean
        IsDirsCoinside(gp_Dir D1, gp_Dir D2, Standard_Real const aTol) -> Standard_Boolean

        Returns True if D1 and D2 coinside with given tolerance

        :type D1: OCC.wrapper.gp.gp_Dir
        :type D2: OCC.wrapper.gp.gp_Dir
        :type aTol: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntTools.IntTools_Tools_IsDirsCoinside(*args)

    IsDirsCoinside = staticmethod(IsDirsCoinside)

    def IsClosed(*args):
        """
        IsClosed(Handle_Geom_Curve aC) -> Standard_Boolean

        Returns True if aC is BoundedCurve from Geom and
        the distance between first point
        of the curve aC and last point
        is less than 1.e-12

        :type aC: OCC.wrapper.Geom.Handle_Geom_Curve
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntTools.IntTools_Tools_IsClosed(*args)

    IsClosed = staticmethod(IsClosed)

    def CurveTolerance(*args):
        """
        CurveTolerance(Handle_Geom_Curve aC, Standard_Real const aTolBase) -> Standard_Real

        Returns adaptive tolerance for given aTolBase
        if aC is trimmed curve and basis curve is parabola,
        otherwise returns value of aTolBase

        :type aC: OCC.wrapper.Geom.Handle_Geom_Curve
        :type aTolBase: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _IntTools.IntTools_Tools_CurveTolerance(*args)

    CurveTolerance = staticmethod(CurveTolerance)

    def CheckCurve(*args):
        """
        CheckCurve(IntTools_Curve theCurve, Bnd_Box theBox) -> Standard_Boolean

        Checks if the curve is not covered by the default tolerance (confusion).<br>
        Builds bounding box for the curve and stores it into <theBox>.

        :type theCurve: OCC.wrapper.IntTools.IntTools_Curve
        :type theBox: OCC.wrapper.Bnd.Bnd_Box
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntTools.IntTools_Tools_CheckCurve(*args)

    CheckCurve = staticmethod(CheckCurve)

    def IsOnPave(*args):
        """
        IsOnPave(Standard_Real const theT, IntTools_Range theRange, Standard_Real const theTol) -> Standard_Boolean

        :type theT: float
        :type theRange: OCC.wrapper.IntTools.IntTools_Range
        :type theTol: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntTools.IntTools_Tools_IsOnPave(*args)

    IsOnPave = staticmethod(IsOnPave)

    def VertexParameters(*args):
        """
        VertexParameters(IntTools_CommonPrt theCP)

        :type theCP: OCC.wrapper.IntTools.IntTools_CommonPrt
        :type theT1: float
        :type theT2: float

        """
        return _IntTools.IntTools_Tools_VertexParameters(*args)

    VertexParameters = staticmethod(VertexParameters)

    def VertexParameter(*args):
        """
        VertexParameter(IntTools_CommonPrt theCP)

        :type theCP: OCC.wrapper.IntTools.IntTools_CommonPrt
        :type theT: float

        """
        return _IntTools.IntTools_Tools_VertexParameter(*args)

    VertexParameter = staticmethod(VertexParameter)

    def IsOnPave1(*args):
        """
        IsOnPave1(Standard_Real const theT, IntTools_Range theRange, Standard_Real const theTol) -> Standard_Boolean

        :type theT: float
        :type theRange: OCC.wrapper.IntTools.IntTools_Range
        :type theTol: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntTools.IntTools_Tools_IsOnPave1(*args)

    IsOnPave1 = staticmethod(IsOnPave1)

    def IsInRange(*args):
        """
        IsInRange(IntTools_Range theRRef, IntTools_Range theR, Standard_Real const theTol) -> Standard_Boolean

        Checks if the range <theR> interfere with the range <theRRef>

        :type theRRef: OCC.wrapper.IntTools.IntTools_Range
        :type theR: OCC.wrapper.IntTools.IntTools_Range
        :type theTol: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntTools.IntTools_Tools_IsInRange(*args)

    IsInRange = staticmethod(IsInRange)

    def SegPln(*args):
        """
        SegPln(gp_Lin theLin, Standard_Real const theTLin1, Standard_Real const theTLin2, Standard_Real const theTolLin, gp_Pln thePln, Standard_Real const theTolPln, gp_Pnt theP) -> Standard_Integer

        :type theLin: OCC.wrapper.gp.gp_Lin
        :type theTLin1: float
        :type theTLin2: float
        :type theTolLin: float
        :type thePln: OCC.wrapper.gp.gp_Pln
        :type theTolPln: float
        :type theP: OCC.wrapper.gp.gp_Pnt
        :type theT: float
        :type theTolP: float
        :type theTmin: float
        :type theTmax: float
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntTools.IntTools_Tools_SegPln(*args)

    SegPln = staticmethod(SegPln)

    def ComputeTolerance(*args):
        """
        ComputeTolerance(Handle_Geom_Curve theCurve3D, Handle_Geom2d_Curve theCurve2D, Handle_Geom_Surface theSurf, Standard_Real const theFirst, Standard_Real const theLast, Standard_Real const theTolRange) -> Standard_Boolean

        Computes the max distance between points
        taken from 3D and 2D curves by the same parameter

        :type theCurve3D: OCC.wrapper.Geom.Handle_Geom_Curve
        :type theCurve2D: OCC.wrapper.Geom2d.Handle_Geom2d_Curve
        :type theSurf: OCC.wrapper.Geom.Handle_Geom_Surface
        :type theFirst: float
        :type theLast: float
        :type theMaxDist: float
        :type theMaxPar: float
        :type theTolRange: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntTools.IntTools_Tools_ComputeTolerance(*args)

    ComputeTolerance = staticmethod(ComputeTolerance)

    def ComputeIntRange(*args):
        """
        ComputeIntRange(Standard_Real const theTol1, Standard_Real const theTol2, Standard_Real const theAngle) -> Standard_Real

        Computes the correct Intersection range for 
        Line/Line, Line/Plane and Plane/Plane intersections

        :type theTol1: float
        :type theTol2: float
        :type theAngle: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _IntTools.IntTools_Tools_ComputeIntRange(*args)

    ComputeIntRange = staticmethod(ComputeIntRange)

    def __init__(self):
        """
        The class contains handy static functions
        dealing with the geometry and topology.
        """
        this = _IntTools.new_IntTools_Tools()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _IntTools.delete_IntTools_Tools
IntTools_Tools_swigregister = _IntTools.IntTools_Tools_swigregister
IntTools_Tools_swigregister(IntTools_Tools)

def IntTools_Tools_ComputeVV(*args):
    """
    IntTools_Tools_ComputeVV(TopoDS_Vertex V1, TopoDS_Vertex V2) -> Standard_Integer

    Computes distance between vertex V1 and vertex V2,
    if the distance is less than sum of vertex tolerances
    returns zero,
    otherwise returns negative value

    :type V1: OCC.wrapper.TopoDS.TopoDS_Vertex
    :type V2: OCC.wrapper.TopoDS.TopoDS_Vertex
    :rtype: OCC.wrapper.Standard.Standard_Integer

    """
    return _IntTools.IntTools_Tools_ComputeVV(*args)

def IntTools_Tools_HasInternalEdge(*args):
    """
    IntTools_Tools_HasInternalEdge(TopoDS_Wire aW) -> Standard_Boolean

    Returns True if wire aW contains edges
    with INTERNAL orientation

    :type aW: OCC.wrapper.TopoDS.TopoDS_Wire
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _IntTools.IntTools_Tools_HasInternalEdge(*args)

def IntTools_Tools_MakeFaceFromWireAndFace(*args):
    """
    IntTools_Tools_MakeFaceFromWireAndFace(TopoDS_Wire aW, TopoDS_Face aF, TopoDS_Face aFNew)

    Build a face based on surface of given face aF
    and bounded by wire aW

    :type aW: OCC.wrapper.TopoDS.TopoDS_Wire
    :type aF: OCC.wrapper.TopoDS.TopoDS_Face
    :type aFNew: OCC.wrapper.TopoDS.TopoDS_Face

    """
    return _IntTools.IntTools_Tools_MakeFaceFromWireAndFace(*args)

def IntTools_Tools_ClassifyPointByFace(*args):
    """
    IntTools_Tools_ClassifyPointByFace(TopoDS_Face aF, gp_Pnt2d P) -> TopAbs_State

    :type aF: OCC.wrapper.TopoDS.TopoDS_Face
    :type P: OCC.wrapper.gp.gp_Pnt2d
    :rtype: OCC.wrapper.TopAbs.TopAbs_State

    """
    return _IntTools.IntTools_Tools_ClassifyPointByFace(*args)

def IntTools_Tools_IsMiddlePointsEqual(*args):
    """
    IntTools_Tools_IsMiddlePointsEqual(TopoDS_Edge E1, TopoDS_Edge E2) -> Standard_Boolean

    Gets boundary of parameters of E1 and E2.
    Computes 3d points on each corresponded to average parameters.
    Returns True if distance between computed points is less than
    sum of edge tolerance, otherwise returns False.

    :type E1: OCC.wrapper.TopoDS.TopoDS_Edge
    :type E2: OCC.wrapper.TopoDS.TopoDS_Edge
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _IntTools.IntTools_Tools_IsMiddlePointsEqual(*args)

def IntTools_Tools_IsVertex(*args):
    """
    IsVertex(TopoDS_Edge E, Standard_Real const t) -> Standard_Boolean
    IsVertex(TopoDS_Edge E, TopoDS_Vertex V, Standard_Real const t) -> Standard_Boolean
    IsVertex(IntTools_CommonPrt aCmnPrt) -> Standard_Boolean
    IntTools_Tools_IsVertex(gp_Pnt aP, Standard_Real const aTolPV, TopoDS_Vertex aV) -> Standard_Boolean

    Returns True if the distance between point aP and
    vertex aV is less or equal to sum of aTolPV and
    vertex tolerance, otherwise returns False

    :type aP: OCC.wrapper.gp.gp_Pnt
    :type aTolPV: float
    :type aV: OCC.wrapper.TopoDS.TopoDS_Vertex
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _IntTools.IntTools_Tools_IsVertex(*args)

def IntTools_Tools_IntermediatePoint(*args):
    """
    IntTools_Tools_IntermediatePoint(Standard_Real const aFirst, Standard_Real const aLast) -> Standard_Real

    Returns some value between aFirst and aLast

    :type aFirst: float
    :type aLast: float
    :rtype: OCC.wrapper.Standard.Standard_Real

    """
    return _IntTools.IntTools_Tools_IntermediatePoint(*args)

def IntTools_Tools_SplitCurve(*args):
    """
    IntTools_Tools_SplitCurve(IntTools_Curve aC, NCollection_Sequence_IntTools_Curve aS) -> Standard_Integer

    Split aC by average parameter if aC is closed in 3D.
    Returns positive value if splitting has been done,
    otherwise returns zero.

    :type aC: OCC.wrapper.IntTools.IntTools_Curve
    :type aS: OCC.wrapper.IntTools.IntTools_SequenceOfCurves
    :rtype: OCC.wrapper.Standard.Standard_Integer

    """
    return _IntTools.IntTools_Tools_SplitCurve(*args)

def IntTools_Tools_RejectLines(*args):
    """
    IntTools_Tools_RejectLines(NCollection_Sequence_IntTools_Curve aSIn, NCollection_Sequence_IntTools_Curve aSOut)

    Puts curves from aSIn to aSOut except those curves that
    are coincide with first curve from aSIn.

    :type aSIn: OCC.wrapper.IntTools.IntTools_SequenceOfCurves
    :type aSOut: OCC.wrapper.IntTools.IntTools_SequenceOfCurves

    """
    return _IntTools.IntTools_Tools_RejectLines(*args)

def IntTools_Tools_IsDirsCoinside(*args):
    """
    IsDirsCoinside(gp_Dir D1, gp_Dir D2) -> Standard_Boolean
    IntTools_Tools_IsDirsCoinside(gp_Dir D1, gp_Dir D2, Standard_Real const aTol) -> Standard_Boolean

    Returns True if D1 and D2 coinside with given tolerance

    :type D1: OCC.wrapper.gp.gp_Dir
    :type D2: OCC.wrapper.gp.gp_Dir
    :type aTol: float
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _IntTools.IntTools_Tools_IsDirsCoinside(*args)

def IntTools_Tools_IsClosed(*args):
    """
    IntTools_Tools_IsClosed(Handle_Geom_Curve aC) -> Standard_Boolean

    Returns True if aC is BoundedCurve from Geom and
    the distance between first point
    of the curve aC and last point
    is less than 1.e-12

    :type aC: OCC.wrapper.Geom.Handle_Geom_Curve
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _IntTools.IntTools_Tools_IsClosed(*args)

def IntTools_Tools_CurveTolerance(*args):
    """
    IntTools_Tools_CurveTolerance(Handle_Geom_Curve aC, Standard_Real const aTolBase) -> Standard_Real

    Returns adaptive tolerance for given aTolBase
    if aC is trimmed curve and basis curve is parabola,
    otherwise returns value of aTolBase

    :type aC: OCC.wrapper.Geom.Handle_Geom_Curve
    :type aTolBase: float
    :rtype: OCC.wrapper.Standard.Standard_Real

    """
    return _IntTools.IntTools_Tools_CurveTolerance(*args)

def IntTools_Tools_CheckCurve(*args):
    """
    IntTools_Tools_CheckCurve(IntTools_Curve theCurve, Bnd_Box theBox) -> Standard_Boolean

    Checks if the curve is not covered by the default tolerance (confusion).<br>
    Builds bounding box for the curve and stores it into <theBox>.

    :type theCurve: OCC.wrapper.IntTools.IntTools_Curve
    :type theBox: OCC.wrapper.Bnd.Bnd_Box
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _IntTools.IntTools_Tools_CheckCurve(*args)

def IntTools_Tools_IsOnPave(*args):
    """
    IntTools_Tools_IsOnPave(Standard_Real const theT, IntTools_Range theRange, Standard_Real const theTol) -> Standard_Boolean

    :type theT: float
    :type theRange: OCC.wrapper.IntTools.IntTools_Range
    :type theTol: float
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _IntTools.IntTools_Tools_IsOnPave(*args)

def IntTools_Tools_VertexParameters(*args):
    """
    IntTools_Tools_VertexParameters(IntTools_CommonPrt theCP)

    :type theCP: OCC.wrapper.IntTools.IntTools_CommonPrt
    :type theT1: float
    :type theT2: float

    """
    return _IntTools.IntTools_Tools_VertexParameters(*args)

def IntTools_Tools_VertexParameter(*args):
    """
    IntTools_Tools_VertexParameter(IntTools_CommonPrt theCP)

    :type theCP: OCC.wrapper.IntTools.IntTools_CommonPrt
    :type theT: float

    """
    return _IntTools.IntTools_Tools_VertexParameter(*args)

def IntTools_Tools_IsOnPave1(*args):
    """
    IntTools_Tools_IsOnPave1(Standard_Real const theT, IntTools_Range theRange, Standard_Real const theTol) -> Standard_Boolean

    :type theT: float
    :type theRange: OCC.wrapper.IntTools.IntTools_Range
    :type theTol: float
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _IntTools.IntTools_Tools_IsOnPave1(*args)

def IntTools_Tools_IsInRange(*args):
    """
    IntTools_Tools_IsInRange(IntTools_Range theRRef, IntTools_Range theR, Standard_Real const theTol) -> Standard_Boolean

    Checks if the range <theR> interfere with the range <theRRef>

    :type theRRef: OCC.wrapper.IntTools.IntTools_Range
    :type theR: OCC.wrapper.IntTools.IntTools_Range
    :type theTol: float
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _IntTools.IntTools_Tools_IsInRange(*args)

def IntTools_Tools_SegPln(*args):
    """
    IntTools_Tools_SegPln(gp_Lin theLin, Standard_Real const theTLin1, Standard_Real const theTLin2, Standard_Real const theTolLin, gp_Pln thePln, Standard_Real const theTolPln, gp_Pnt theP) -> Standard_Integer

    :type theLin: OCC.wrapper.gp.gp_Lin
    :type theTLin1: float
    :type theTLin2: float
    :type theTolLin: float
    :type thePln: OCC.wrapper.gp.gp_Pln
    :type theTolPln: float
    :type theP: OCC.wrapper.gp.gp_Pnt
    :type theT: float
    :type theTolP: float
    :type theTmin: float
    :type theTmax: float
    :rtype: OCC.wrapper.Standard.Standard_Integer

    """
    return _IntTools.IntTools_Tools_SegPln(*args)

def IntTools_Tools_ComputeTolerance(*args):
    """
    IntTools_Tools_ComputeTolerance(Handle_Geom_Curve theCurve3D, Handle_Geom2d_Curve theCurve2D, Handle_Geom_Surface theSurf, Standard_Real const theFirst, Standard_Real const theLast, Standard_Real const theTolRange) -> Standard_Boolean

    Computes the max distance between points
    taken from 3D and 2D curves by the same parameter

    :type theCurve3D: OCC.wrapper.Geom.Handle_Geom_Curve
    :type theCurve2D: OCC.wrapper.Geom2d.Handle_Geom2d_Curve
    :type theSurf: OCC.wrapper.Geom.Handle_Geom_Surface
    :type theFirst: float
    :type theLast: float
    :type theMaxDist: float
    :type theMaxPar: float
    :type theTolRange: float
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _IntTools.IntTools_Tools_ComputeTolerance(*args)

def IntTools_Tools_ComputeIntRange(*args):
    """
    IntTools_Tools_ComputeIntRange(Standard_Real const theTol1, Standard_Real const theTol2, Standard_Real const theAngle) -> Standard_Real

    Computes the correct Intersection range for 
    Line/Line, Line/Plane and Plane/Plane intersections

    :type theTol1: float
    :type theTol2: float
    :type theAngle: float
    :rtype: OCC.wrapper.Standard.Standard_Real

    """
    return _IntTools.IntTools_Tools_ComputeIntRange(*args)

class NCollection_List_IntTools_SurfaceRangeSample_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _IntTools.new_NCollection_List_IntTools_SurfaceRangeSample_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _IntTools.delete_NCollection_List_IntTools_SurfaceRangeSample_IteratorHelper

    def __next__(self):
        return _IntTools.NCollection_List_IntTools_SurfaceRangeSample_IteratorHelper___next__(self)
NCollection_List_IntTools_SurfaceRangeSample_IteratorHelper_swigregister = _IntTools.NCollection_List_IntTools_SurfaceRangeSample_IteratorHelper_swigregister
NCollection_List_IntTools_SurfaceRangeSample_IteratorHelper_swigregister(NCollection_List_IntTools_SurfaceRangeSample_IteratorHelper)


try:
	IntTools_ListOfSurfaceRangeSample = NCollection_List_IntTools_SurfaceRangeSample
except NameError:
	pass # does not exist, probably ignored

class IntTools_CommonPrt(object):
    """
    The class  is  to  describe a  common  part
    between two edges in  3-d space.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(IntTools_CommonPrt self) -> IntTools_CommonPrt
        __init__(IntTools_CommonPrt self, IntTools_CommonPrt aCPrt) -> IntTools_CommonPrt

        Copy  constructor

        :type aCPrt: OCC.wrapper.IntTools.IntTools_CommonPrt

        """
        this = _IntTools.new_IntTools_CommonPrt(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Assign(self, *args):
        """
        Assign(IntTools_CommonPrt self, IntTools_CommonPrt Other) -> IntTools_CommonPrt

        :type Other: OCC.wrapper.IntTools.IntTools_CommonPrt
        :rtype: OCC.wrapper.IntTools.IntTools_CommonPrt

        """
        return _IntTools.IntTools_CommonPrt_Assign(self, *args)


    def assign(self, *args):
        """
        assign(IntTools_CommonPrt self, IntTools_CommonPrt Other) -> IntTools_CommonPrt

        :type Other: OCC.wrapper.IntTools.IntTools_CommonPrt
        :rtype: OCC.wrapper.IntTools.IntTools_CommonPrt

        """
        return _IntTools.IntTools_CommonPrt_assign(self, *args)


    def SetEdge1(self, *args):
        """
        SetEdge1(IntTools_CommonPrt self, TopoDS_Edge anE)

        Sets the first edge.

        :type anE: OCC.wrapper.TopoDS.TopoDS_Edge

        """
        return _IntTools.IntTools_CommonPrt_SetEdge1(self, *args)


    def SetEdge2(self, *args):
        """
        SetEdge2(IntTools_CommonPrt self, TopoDS_Edge anE)

        Sets the second edge.

        :type anE: OCC.wrapper.TopoDS.TopoDS_Edge

        """
        return _IntTools.IntTools_CommonPrt_SetEdge2(self, *args)


    def SetType(self, *args):
        """
        SetType(IntTools_CommonPrt self, TopAbs_ShapeEnum const aType)

        Sets the type of  the common  part
        Vertex  or  Edge

        :type aType: OCC.wrapper.TopAbs.TopAbs_ShapeEnum

        """
        return _IntTools.IntTools_CommonPrt_SetType(self, *args)


    def SetRange1(self, *args):
        """
        SetRange1(IntTools_CommonPrt self, IntTools_Range aR)
        SetRange1(IntTools_CommonPrt self, Standard_Real const tf, Standard_Real const tl)

        Sets the range of first edge.

        :type tf: float
        :type tl: float

        """
        return _IntTools.IntTools_CommonPrt_SetRange1(self, *args)


    def AppendRange2(self, *args):
        """
        AppendRange2(IntTools_CommonPrt self, IntTools_Range aR)
        AppendRange2(IntTools_CommonPrt self, Standard_Real const tf, Standard_Real const tl)

        Appends the range of second edge.

        :type tf: float
        :type tl: float

        """
        return _IntTools.IntTools_CommonPrt_AppendRange2(self, *args)


    def SetVertexParameter1(self, *args):
        """
        SetVertexParameter1(IntTools_CommonPrt self, Standard_Real const tV)

        Sets a parameter of first vertex

        :type tV: float

        """
        return _IntTools.IntTools_CommonPrt_SetVertexParameter1(self, *args)


    def SetVertexParameter2(self, *args):
        """
        SetVertexParameter2(IntTools_CommonPrt self, Standard_Real const tV)

        Sets a parameter of second vertex

        :type tV: float

        """
        return _IntTools.IntTools_CommonPrt_SetVertexParameter2(self, *args)


    def Edge1(self, *args):
        """
        Returns the first edge.

        :rtype: OCC.wrapper.TopoDS.TopoDS_Edge

        """
        res = _IntTools.IntTools_CommonPrt_Edge1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Edge2(self, *args):
        """
        Returns the second edge

        :rtype: OCC.wrapper.TopoDS.TopoDS_Edge

        """
        res = _IntTools.IntTools_CommonPrt_Edge2(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Type(self, *args):
        """
        Type(IntTools_CommonPrt self) -> TopAbs_ShapeEnum

        Returns the type of  the common  part

        :rtype: OCC.wrapper.TopAbs.TopAbs_ShapeEnum

        """
        return _IntTools.IntTools_CommonPrt_Type(self, *args)


    def Range1(self, *args):
        """
        Returns the range of first edge

        :rtype: OCC.wrapper.IntTools.IntTools_Range

        """
        res = _IntTools.IntTools_CommonPrt_Range1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Ranges2(self, *args):
        """
        Returns the  ranges of second edge.

        :rtype: OCC.wrapper.IntTools.IntTools_SequenceOfRanges

        """
        res = _IntTools.IntTools_CommonPrt_Ranges2(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeRanges2(self, *args):
        """
        ChangeRanges2(IntTools_CommonPrt self) -> NCollection_Sequence_IntTools_Range

        Returns the  ranges of second edge.

        :rtype: OCC.wrapper.IntTools.IntTools_SequenceOfRanges

        """
        return _IntTools.IntTools_CommonPrt_ChangeRanges2(self, *args)


    def VertexParameter1(self, *args):
        """
        VertexParameter1(IntTools_CommonPrt self) -> Standard_Real

        Returns parameter of first vertex

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _IntTools.IntTools_CommonPrt_VertexParameter1(self, *args)


    def VertexParameter2(self, *args):
        """
        VertexParameter2(IntTools_CommonPrt self) -> Standard_Real

        Returns parameter of second vertex

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _IntTools.IntTools_CommonPrt_VertexParameter2(self, *args)


    def Copy(self, *args):
        """
        Copy(IntTools_CommonPrt self, IntTools_CommonPrt anOther)

        Copies me to anOther

        :type anOther: OCC.wrapper.IntTools.IntTools_CommonPrt

        """
        return _IntTools.IntTools_CommonPrt_Copy(self, *args)


    def AllNullFlag(self, *args):
        """
        AllNullFlag(IntTools_CommonPrt self) -> Standard_Boolean

        Modifier

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntTools.IntTools_CommonPrt_AllNullFlag(self, *args)


    def SetAllNullFlag(self, *args):
        """
        SetAllNullFlag(IntTools_CommonPrt self, Standard_Boolean const aFlag)

        Selector

        :type aFlag: bool

        """
        return _IntTools.IntTools_CommonPrt_SetAllNullFlag(self, *args)


    def SetBoundingPoints(self, *args):
        """
        SetBoundingPoints(IntTools_CommonPrt self, gp_Pnt aP1, gp_Pnt aP2)

        Modifier

        :type aP1: OCC.wrapper.gp.gp_Pnt
        :type aP2: OCC.wrapper.gp.gp_Pnt

        """
        return _IntTools.IntTools_CommonPrt_SetBoundingPoints(self, *args)


    def BoundingPoints(self, *args):
        """
        BoundingPoints(IntTools_CommonPrt self, gp_Pnt aP1, gp_Pnt aP2)

        Selector

        :type aP1: OCC.wrapper.gp.gp_Pnt
        :type aP2: OCC.wrapper.gp.gp_Pnt

        """
        return _IntTools.IntTools_CommonPrt_BoundingPoints(self, *args)

    __swig_destroy__ = _IntTools.delete_IntTools_CommonPrt
IntTools_CommonPrt_swigregister = _IntTools.IntTools_CommonPrt_swigregister
IntTools_CommonPrt_swigregister(IntTools_CommonPrt)

class NCollection_Array1_IntTools_Range(object):
    """
    Purpose:     The class Array1 represents unidimensional arrays 
    of fixed size known at run time. 
    The range of the index is user defined.
    An array1 can be constructed with a "C array".
    This functionality is useful to call methods expecting
    an Array1. It allows to carry the bounds inside the arrays.

    Examples:    Item tab[100]; //  An example with a C array
    Array1OfItem ttab (tab[0],1,100);

    Array1OfItem tttab (ttab(10),10,20); // a slice of ttab

    If you want to reindex an array from 1 to Length do :

    Array1 tab1(tab(tab.Lower()),1,tab.Length());

    Warning:     Programs client of such a class must be independant
    of the range of the first element. Then, a C++ for
    loop must be written like this

    for (i = A.Lower(); i <= A.Upper(); i++)

    Changes:     In  comparison  to  TCollection  the  flag  isAllocated  was
    renamed into myDeletable (alike in  the Array2).  For naming
    compatibility the method IsAllocated remained in class along
    with IsDeletable.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Array1_IntTools_Range self) -> NCollection_Array1< IntTools_Range >::iterator

        Returns an iterator pointing to the first element in the array.

        :rtype: iterator

        """
        return _IntTools.NCollection_Array1_IntTools_Range_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Array1_IntTools_Range self) -> NCollection_Array1< IntTools_Range >::iterator

        Returns an iterator referring to the past-the-end element in the array.

        :rtype: iterator

        """
        return _IntTools.NCollection_Array1_IntTools_Range_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Array1_IntTools_Range self) -> NCollection_Array1< IntTools_Range >::const_iterator

        Returns a const iterator pointing to the first element in the array.

        :rtype: const_iterator

        """
        return _IntTools.NCollection_Array1_IntTools_Range_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Array1_IntTools_Range self) -> NCollection_Array1< IntTools_Range >::const_iterator

        Returns a const iterator referring to the past-the-end element in the array.

        :rtype: const_iterator

        """
        return _IntTools.NCollection_Array1_IntTools_Range_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     The class Array1 represents unidimensional arrays 
        of fixed size known at run time. 
        The range of the index is user defined.
        An array1 can be constructed with a "C array".
        This functionality is useful to call methods expecting
        an Array1. It allows to carry the bounds inside the arrays.

        Examples:    Item tab[100]; //  An example with a C array
        Array1OfItem ttab (tab[0],1,100);

        Array1OfItem tttab (ttab(10),10,20); // a slice of ttab

        If you want to reindex an array from 1 to Length do :

        Array1 tab1(tab(tab.Lower()),1,tab.Length());

        Warning:     Programs client of such a class must be independant
        of the range of the first element. Then, a C++ for
        loop must be written like this

        for (i = A.Lower(); i <= A.Upper(); i++)

        Changes:     In  comparison  to  TCollection  the  flag  isAllocated  was
        renamed into myDeletable (alike in  the Array2).  For naming
        compatibility the method IsAllocated remained in class along
        with IsDeletable.
        """
        this = _IntTools.new_NCollection_Array1_IntTools_Range(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(NCollection_Array1_IntTools_Range self, IntTools_Range theValue)

        Initialise the items with theValue

        :type theValue: const TheItemType &

        """
        return _IntTools.NCollection_Array1_IntTools_Range_Init(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_Array1_IntTools_Range self) -> Standard_Integer

        Size query

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntTools.NCollection_Array1_IntTools_Range_Size(self, *args)


    def Length(self, *args):
        """
        Length(NCollection_Array1_IntTools_Range self) -> Standard_Integer

        Length query (the same)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntTools.NCollection_Array1_IntTools_Range_Length(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Array1_IntTools_Range self) -> Standard_Boolean

        Return TRUE if array has zero length.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntTools.NCollection_Array1_IntTools_Range_IsEmpty(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Array1_IntTools_Range self) -> Standard_Integer

        Lower bound

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntTools.NCollection_Array1_IntTools_Range_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Array1_IntTools_Range self) -> Standard_Integer

        Upper bound

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntTools.NCollection_Array1_IntTools_Range_Upper(self, *args)


    def IsDeletable(self, *args):
        """
        IsDeletable(NCollection_Array1_IntTools_Range self) -> Standard_Boolean

        myDeletable flag

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntTools.NCollection_Array1_IntTools_Range_IsDeletable(self, *args)


    def IsAllocated(self, *args):
        """
        IsAllocated(NCollection_Array1_IntTools_Range self) -> Standard_Boolean

        IsAllocated flag - for naming compatibility

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntTools.NCollection_Array1_IntTools_Range_IsAllocated(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Array1_IntTools_Range self, NCollection_Array1_IntTools_Range theOther) -> NCollection_Array1_IntTools_Range

        Copies data of theOther array to this.
        This array should be pre-allocated and have the same length as theOther;
        otherwise exception Standard_DimensionMismatch is thrown.

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _IntTools.NCollection_Array1_IntTools_Range_Assign(self, *args)


    def Move(self, *args):
        """
        Move(NCollection_Array1_IntTools_Range self, NCollection_Array1_IntTools_Range theOther) -> NCollection_Array1_IntTools_Range

        Move assignment.
        This array will borrow all the data from theOther.
        The moved object will keep pointer to the memory buffer and
        range, but it will not free the buffer on destruction.

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _IntTools.NCollection_Array1_IntTools_Range_Move(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Array1_IntTools_Range self, NCollection_Array1_IntTools_Range theOther) -> NCollection_Array1_IntTools_Range
        assign(NCollection_Array1_IntTools_Range self, NCollection_Array1_IntTools_Range theOther) -> NCollection_Array1_IntTools_Range

        Move assignment operator; @sa Move()

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1<TheItemType> &&
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _IntTools.NCollection_Array1_IntTools_Range_assign(self, *args)


    def First(self, *args):
        """
        @return first element

        :rtype: const TheItemType &

        """
        res = _IntTools.NCollection_Array1_IntTools_Range_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Array1_IntTools_Range self) -> IntTools_Range

        @return first element

        :rtype: TheItemType &

        """
        return _IntTools.NCollection_Array1_IntTools_Range_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        @return last element

        :rtype: const TheItemType &

        """
        res = _IntTools.NCollection_Array1_IntTools_Range_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Array1_IntTools_Range self) -> IntTools_Range

        @return last element

        :rtype: TheItemType &

        """
        return _IntTools.NCollection_Array1_IntTools_Range_ChangeLast(self, *args)


    def Value(self, *args):
        """
        Constant value access

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _IntTools.NCollection_Array1_IntTools_Range_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Array1_IntTools_Range self, Standard_Integer const theIndex) -> IntTools_Range

        Variable value access

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _IntTools.NCollection_Array1_IntTools_Range_ChangeValue(self, *args)


    def __call__(self, *args):
        """
        operator() - alias to Value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _IntTools.NCollection_Array1_IntTools_Range___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __getitem__(self, *args):
        """
        operator[] - alias to Value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _IntTools.NCollection_Array1_IntTools_Range_at(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetValue(self, *args):
        """
        SetValue(NCollection_Array1_IntTools_Range self, Standard_Integer const theIndex, IntTools_Range theItem)

        Set value 

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _IntTools.NCollection_Array1_IntTools_Range_SetValue(self, *args)


    def Resize(self, *args):
        """
        Resize(NCollection_Array1_IntTools_Range self, Standard_Integer const theLower, Standard_Integer const theUpper, Standard_Boolean const theToCopyData)

        Resizes the array to specified bounds.
        No re-allocation will be done if length of array does not change,
        but existing values will not be discarded if theToCopyData set to FALSE.
        @param theLower new lower bound of array
        @param theUpper new upper bound of array
        @param theToCopyData flag to copy existing data into new array

        :type theLower: int
        :type theUpper: int
        :type theToCopyData: bool

        """
        return _IntTools.NCollection_Array1_IntTools_Range_Resize(self, *args)

    __swig_destroy__ = _IntTools.delete_NCollection_Array1_IntTools_Range
NCollection_Array1_IntTools_Range_swigregister = _IntTools.NCollection_Array1_IntTools_Range_swigregister
NCollection_Array1_IntTools_Range_swigregister(NCollection_Array1_IntTools_Range)


try:
	IntTools_Array1OfRange = NCollection_Array1_IntTools_Range
except NameError:
	pass # does not exist, probably ignored

class NCollection_Sequence_IntTools_CommonPrt(NCollection.NCollection_BaseSequence):
    """
    Purpose:     Definition of a sequence of elements indexed by
    an Integer in range of 1..n
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Sequence_IntTools_CommonPrt self) -> NCollection_Sequence< IntTools_CommonPrt >::iterator

        Returns an iterator pointing to the first element in the sequence.

        :rtype: iterator

        """
        return _IntTools.NCollection_Sequence_IntTools_CommonPrt_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Sequence_IntTools_CommonPrt self) -> NCollection_Sequence< IntTools_CommonPrt >::iterator

        Returns an iterator referring to the past-the-end element in the sequence.

        :rtype: iterator

        """
        return _IntTools.NCollection_Sequence_IntTools_CommonPrt_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Sequence_IntTools_CommonPrt self) -> NCollection_Sequence< IntTools_CommonPrt >::const_iterator

        Returns a const iterator pointing to the first element in the sequence.

        :rtype: const_iterator

        """
        return _IntTools.NCollection_Sequence_IntTools_CommonPrt_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Sequence_IntTools_CommonPrt self) -> NCollection_Sequence< IntTools_CommonPrt >::const_iterator

        Returns a const iterator referring to the past-the-end element in the sequence.

        :rtype: const_iterator

        """
        return _IntTools.NCollection_Sequence_IntTools_CommonPrt_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     Definition of a sequence of elements indexed by
        an Integer in range of 1..n
        """
        this = _IntTools.new_NCollection_Sequence_IntTools_CommonPrt(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Size(self, *args):
        """
        Size(NCollection_Sequence_IntTools_CommonPrt self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntTools.NCollection_Sequence_IntTools_CommonPrt_Size(self, *args)


    def Length(self, *args):
        """
        Length(NCollection_Sequence_IntTools_CommonPrt self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntTools.NCollection_Sequence_IntTools_CommonPrt_Length(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Sequence_IntTools_CommonPrt self) -> Standard_Integer

        Method for consistency with other collections.
        @return Lower bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntTools.NCollection_Sequence_IntTools_CommonPrt_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Sequence_IntTools_CommonPrt self) -> Standard_Integer

        Method for consistency with other collections.
        @return Upper bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntTools.NCollection_Sequence_IntTools_CommonPrt_Upper(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Sequence_IntTools_CommonPrt self) -> Standard_Boolean

        Empty query

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntTools.NCollection_Sequence_IntTools_CommonPrt_IsEmpty(self, *args)


    def Reverse(self, *args):
        """
        Reverse(NCollection_Sequence_IntTools_CommonPrt self)

        Reverse sequence


        """
        return _IntTools.NCollection_Sequence_IntTools_CommonPrt_Reverse(self, *args)


    def Exchange(self, *args):
        """
        Exchange(NCollection_Sequence_IntTools_CommonPrt self, Standard_Integer const I, Standard_Integer const J)

        Exchange two members

        :type I: int
        :type J: int

        """
        return _IntTools.NCollection_Sequence_IntTools_CommonPrt_Exchange(self, *args)


    def delNode(*args):
        """
        delNode(NCollection_SeqNode theNode, Handle_NCollection_BaseAllocator theAl)

        Static deleter to be passed to BaseSequence

        :type theNode: OCC.wrapper.NCollection.NCollection_SeqNode
        :type theAl: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _IntTools.NCollection_Sequence_IntTools_CommonPrt_delNode(*args)

    delNode = staticmethod(delNode)

    def Clear(self, *args):
        """
        Clear(NCollection_Sequence_IntTools_CommonPrt self, Handle_NCollection_BaseAllocator theAllocator=0)

        Clear the items out, take a new allocator if non null

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _IntTools.NCollection_Sequence_IntTools_CommonPrt_Clear(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Sequence_IntTools_CommonPrt self, NCollection_Sequence_IntTools_CommonPrt theOther) -> NCollection_Sequence_IntTools_CommonPrt

        Replace this sequence by the items of theOther.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_Sequence
        :rtype: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _IntTools.NCollection_Sequence_IntTools_CommonPrt_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Sequence_IntTools_CommonPrt self, NCollection_Sequence_IntTools_CommonPrt theOther) -> NCollection_Sequence_IntTools_CommonPrt

        Replacement operator

        :type theOther: OCC.wrapper.NCollection.NCollection_Sequence
        :rtype: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _IntTools.NCollection_Sequence_IntTools_CommonPrt_assign(self, *args)


    def Remove(self, *args):
        """
        Remove(NCollection_Sequence_IntTools_CommonPrt self, NCollection_Sequence< IntTools_CommonPrt >::Iterator & thePosition)
        Remove(NCollection_Sequence_IntTools_CommonPrt self, Standard_Integer const theIndex)
        Remove(NCollection_Sequence_IntTools_CommonPrt self, Standard_Integer const theFromIndex, Standard_Integer const theToIndex)

        Remove range of items

        :type theFromIndex: int
        :type theToIndex: int

        """
        return _IntTools.NCollection_Sequence_IntTools_CommonPrt_Remove(self, *args)


    def Append(self, *args):
        """
        Append(NCollection_Sequence_IntTools_CommonPrt self, IntTools_CommonPrt theItem)
        Append(NCollection_Sequence_IntTools_CommonPrt self, NCollection_Sequence_IntTools_CommonPrt theSeq)

        Append another sequence (making it empty)

        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _IntTools.NCollection_Sequence_IntTools_CommonPrt_Append(self, *args)


    def Prepend(self, *args):
        """
        Prepend(NCollection_Sequence_IntTools_CommonPrt self, IntTools_CommonPrt theItem)
        Prepend(NCollection_Sequence_IntTools_CommonPrt self, NCollection_Sequence_IntTools_CommonPrt theSeq)

        Prepend another sequence (making it empty)

        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _IntTools.NCollection_Sequence_IntTools_CommonPrt_Prepend(self, *args)


    def InsertBefore(self, *args):
        """
        InsertBefore(NCollection_Sequence_IntTools_CommonPrt self, Standard_Integer const theIndex, IntTools_CommonPrt theItem)
        InsertBefore(NCollection_Sequence_IntTools_CommonPrt self, Standard_Integer const theIndex, NCollection_Sequence_IntTools_CommonPrt theSeq)

        InsertBefore theIndex another sequence

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _IntTools.NCollection_Sequence_IntTools_CommonPrt_InsertBefore(self, *args)


    def InsertAfter(self, *args):
        """
        InsertAfter(NCollection_Sequence_IntTools_CommonPrt self, NCollection_Sequence< IntTools_CommonPrt >::Iterator & thePosition, IntTools_CommonPrt theItem)
        InsertAfter(NCollection_Sequence_IntTools_CommonPrt self, Standard_Integer const theIndex, NCollection_Sequence_IntTools_CommonPrt theSeq)
        InsertAfter(NCollection_Sequence_IntTools_CommonPrt self, Standard_Integer const theIndex, IntTools_CommonPrt theItem)

        InsertAfter theIndex another sequence

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _IntTools.NCollection_Sequence_IntTools_CommonPrt_InsertAfter(self, *args)


    def Split(self, *args):
        """
        Split(NCollection_Sequence_IntTools_CommonPrt self, Standard_Integer const theIndex, NCollection_Sequence_IntTools_CommonPrt theSeq)

        Split in two sequences

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _IntTools.NCollection_Sequence_IntTools_CommonPrt_Split(self, *args)


    def First(self, *args):
        """
        First item access

        :rtype: const TheItemType &

        """
        res = _IntTools.NCollection_Sequence_IntTools_CommonPrt_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Sequence_IntTools_CommonPrt self) -> IntTools_CommonPrt

        First item access

        :rtype: TheItemType &

        """
        return _IntTools.NCollection_Sequence_IntTools_CommonPrt_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        Last item access

        :rtype: const TheItemType &

        """
        res = _IntTools.NCollection_Sequence_IntTools_CommonPrt_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Sequence_IntTools_CommonPrt self) -> IntTools_CommonPrt

        Last item access

        :rtype: TheItemType &

        """
        return _IntTools.NCollection_Sequence_IntTools_CommonPrt_ChangeLast(self, *args)


    def Value(self, *args):
        """
        Constant item access by theIndex

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _IntTools.NCollection_Sequence_IntTools_CommonPrt_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Sequence_IntTools_CommonPrt self, Standard_Integer const theIndex) -> IntTools_CommonPrt

        Variable item access by theIndex

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _IntTools.NCollection_Sequence_IntTools_CommonPrt_ChangeValue(self, *args)


    def __call__(self, *args):
        """
        Constant operator()

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _IntTools.NCollection_Sequence_IntTools_CommonPrt___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetValue(self, *args):
        """
        SetValue(NCollection_Sequence_IntTools_CommonPrt self, Standard_Integer const theIndex, IntTools_CommonPrt theItem)

        Set item value by theIndex

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _IntTools.NCollection_Sequence_IntTools_CommonPrt_SetValue(self, *args)


    def __iter__(self):
        return _IntTools.NCollection_Sequence_IntTools_CommonPrt___iter__(self)
    __swig_destroy__ = _IntTools.delete_NCollection_Sequence_IntTools_CommonPrt
NCollection_Sequence_IntTools_CommonPrt_swigregister = _IntTools.NCollection_Sequence_IntTools_CommonPrt_swigregister
NCollection_Sequence_IntTools_CommonPrt_swigregister(NCollection_Sequence_IntTools_CommonPrt)

def NCollection_Sequence_IntTools_CommonPrt_delNode(*args):
    """
    NCollection_Sequence_IntTools_CommonPrt_delNode(NCollection_SeqNode theNode, Handle_NCollection_BaseAllocator theAl)

    Static deleter to be passed to BaseSequence

    :type theNode: OCC.wrapper.NCollection.NCollection_SeqNode
    :type theAl: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

    """
    return _IntTools.NCollection_Sequence_IntTools_CommonPrt_delNode(*args)

class NCollection_Sequence_IntTools_CommonPrt_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _IntTools.new_NCollection_Sequence_IntTools_CommonPrt_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _IntTools.delete_NCollection_Sequence_IntTools_CommonPrt_IteratorHelper

    def __next__(self):
        return _IntTools.NCollection_Sequence_IntTools_CommonPrt_IteratorHelper___next__(self)
NCollection_Sequence_IntTools_CommonPrt_IteratorHelper_swigregister = _IntTools.NCollection_Sequence_IntTools_CommonPrt_IteratorHelper_swigregister
NCollection_Sequence_IntTools_CommonPrt_IteratorHelper_swigregister(NCollection_Sequence_IntTools_CommonPrt_IteratorHelper)


try:
	IntTools_SequenceOfCommonPrts = NCollection_Sequence_IntTools_CommonPrt
except NameError:
	pass # does not exist, probably ignored

class IntTools_FaceFace(object):
    """
    This class provides the intersection of
    face's underlying surfaces.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(IntTools_FaceFace self) -> IntTools_FaceFace

        Empty constructor.


        """
        this = _IntTools.new_IntTools_FaceFace(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def SetParameters(self, *args):
        """
        SetParameters(IntTools_FaceFace self, Standard_Boolean const ApproxCurves, Standard_Boolean const ComputeCurveOnS1, Standard_Boolean const ComputeCurveOnS2, Standard_Real const ApproximationTolerance)

        Modifier

        :type ApproxCurves: bool
        :type ComputeCurveOnS1: bool
        :type ComputeCurveOnS2: bool
        :type ApproximationTolerance: float

        """
        return _IntTools.IntTools_FaceFace_SetParameters(self, *args)


    def Perform(self, *args):
        """
        Perform(IntTools_FaceFace self, TopoDS_Face F1, TopoDS_Face F2)

        Intersects underliing surfaces of F1 and F2
        Use sum of tolerance of F1 and F2 as intersection
        criteria

        :type F1: OCC.wrapper.TopoDS.TopoDS_Face
        :type F2: OCC.wrapper.TopoDS.TopoDS_Face

        """
        return _IntTools.IntTools_FaceFace_Perform(self, *args)


    def IsDone(self, *args):
        """
        IsDone(IntTools_FaceFace self) -> Standard_Boolean

        Returns True if the intersection was successful

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntTools.IntTools_FaceFace_IsDone(self, *args)


    def Lines(self, *args):
        """
        Returns sequence of 3d curves as result of intersection

        :rtype: OCC.wrapper.IntTools.IntTools_SequenceOfCurves

        """
        res = _IntTools.IntTools_FaceFace_Lines(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Points(self, *args):
        """
        Returns sequence of 3d curves as result of intersection

        :rtype: OCC.wrapper.IntTools.IntTools_SequenceOfPntOn2Faces

        """
        res = _IntTools.IntTools_FaceFace_Points(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Face1(self, *args):
        """
        Returns first of processed faces

        :rtype: OCC.wrapper.TopoDS.TopoDS_Face

        """
        res = _IntTools.IntTools_FaceFace_Face1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Face2(self, *args):
        """
        Returns second of processed faces

        :rtype: OCC.wrapper.TopoDS.TopoDS_Face

        """
        res = _IntTools.IntTools_FaceFace_Face2(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def TangentFaces(self, *args):
        """
        TangentFaces(IntTools_FaceFace self) -> Standard_Boolean

        Returns True if faces are tangent

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntTools.IntTools_FaceFace_TangentFaces(self, *args)


    def PrepareLines3D(self, *args):
        """
        PrepareLines3D(IntTools_FaceFace self, Standard_Boolean const bToSplit)

        Provides post-processing the result lines.
        <bToSplit> - the flag.
        In case of <bToSplit> is true the closed 3D-curves will be splitted
        on parts.
        In case of <bToSplit> is false the closed 3D-curves remain untouched.

        :type bToSplit: bool

        """
        return _IntTools.IntTools_FaceFace_PrepareLines3D(self, *args)


    def SetList(self, *args):
        """
        SetList(IntTools_FaceFace self, IntSurf_ListOfPntOn2S & ListOfPnts)

        :type ListOfPnts: OCC.wrapper.IntSurf.IntSurf_ListOfPntOn2S

        """
        return _IntTools.IntTools_FaceFace_SetList(self, *args)


    def SetContext(self, *args):
        """
        SetContext(IntTools_FaceFace self, Handle_IntTools_Context aContext)

        Sets the intersecton context

        :type aContext: OCC.wrapper.IntTools.Handle_IntTools_Context

        """
        return _IntTools.IntTools_FaceFace_SetContext(self, *args)


    def SetFuzzyValue(self, *args):
        """
        SetFuzzyValue(IntTools_FaceFace self, Standard_Real const theFuzz)

        Sets the Fuzzy value

        :type theFuzz: float

        """
        return _IntTools.IntTools_FaceFace_SetFuzzyValue(self, *args)


    def FuzzyValue(self, *args):
        """
        FuzzyValue(IntTools_FaceFace self) -> Standard_Real

        Returns Fuzzy value

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _IntTools.IntTools_FaceFace_FuzzyValue(self, *args)


    def Context(self, *args):
        """
        Gets the intersecton context

        :rtype: OCC.wrapper.IntTools.Handle_IntTools_Context

        """
        res = _IntTools.IntTools_FaceFace_Context(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _IntTools.delete_IntTools_FaceFace
IntTools_FaceFace_swigregister = _IntTools.IntTools_FaceFace_swigregister
IntTools_FaceFace_swigregister(IntTools_FaceFace)

class Handle_IntTools_Context(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_IntTools_Context self)

        Nullify the handle


        """
        return _IntTools.Handle_IntTools_Context_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_IntTools_Context self) -> bool

        Check for being null

        :rtype: bool

        """
        return _IntTools.Handle_IntTools_Context_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_IntTools_Context self, IntTools_Context thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _IntTools.Handle_IntTools_Context_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_IntTools_Context self, Handle_IntTools_Context theHandle) -> Handle_IntTools_Context
        assign(Handle_IntTools_Context self, IntTools_Context thePtr) -> Handle_IntTools_Context
        assign(Handle_IntTools_Context self, Handle_IntTools_Context theHandle) -> Handle_IntTools_Context

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _IntTools.Handle_IntTools_Context_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_IntTools_Context self) -> IntTools_Context

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _IntTools.Handle_IntTools_Context_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_IntTools_Context self) -> IntTools_Context

        Member access operator (note non-const)

        :rtype: T *

        """
        return _IntTools.Handle_IntTools_Context___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_IntTools_Context self) -> IntTools_Context

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _IntTools.Handle_IntTools_Context___ref__(self, *args)


    def __hash__(self):
        return _IntTools.Handle_IntTools_Context___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _IntTools.Handle_IntTools_Context___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _IntTools.new_Handle_IntTools_Context(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_IntTools.Handle_IntTools_Context_DownCast)
    __swig_destroy__ = _IntTools.delete_Handle_IntTools_Context

    def FClass2d(self, *args):
        """
        FClass2d(Handle_IntTools_Context self, TopoDS_Face aF) -> IntTools_FClass2d

        Returns a reference to point classifier
        for given face

        :type aF: OCC.wrapper.TopoDS.TopoDS_Face
        :rtype: OCC.wrapper.IntTools.IntTools_FClass2d

        """
        return _IntTools.Handle_IntTools_Context_FClass2d(self, *args)


    def ProjPS(self, *args):
        """
        ProjPS(Handle_IntTools_Context self, TopoDS_Face aF) -> GeomAPI_ProjectPointOnSurf

        Returns a reference to point projector
        for given face

        :type aF: OCC.wrapper.TopoDS.TopoDS_Face
        :rtype: OCC.wrapper.GeomAPI.GeomAPI_ProjectPointOnSurf

        """
        return _IntTools.Handle_IntTools_Context_ProjPS(self, *args)


    def ProjPC(self, *args):
        """
        ProjPC(Handle_IntTools_Context self, TopoDS_Edge aE) -> GeomAPI_ProjectPointOnCurve

        Returns a reference to point projector
        for given edge

        :type aE: OCC.wrapper.TopoDS.TopoDS_Edge
        :rtype: OCC.wrapper.GeomAPI.GeomAPI_ProjectPointOnCurve

        """
        return _IntTools.Handle_IntTools_Context_ProjPC(self, *args)


    def ProjPT(self, *args):
        """
        ProjPT(Handle_IntTools_Context self, Handle_Geom_Curve aC) -> GeomAPI_ProjectPointOnCurve

        Returns a reference to point projector
        for given curve

        :type aC: OCC.wrapper.Geom.Handle_Geom_Curve
        :rtype: OCC.wrapper.GeomAPI.GeomAPI_ProjectPointOnCurve

        """
        return _IntTools.Handle_IntTools_Context_ProjPT(self, *args)


    def SurfaceData(self, *args):
        """
        SurfaceData(Handle_IntTools_Context self, TopoDS_Face aF) -> IntTools_SurfaceRangeLocalizeData

        Returns a reference to surface localization data
        for given face

        :type aF: OCC.wrapper.TopoDS.TopoDS_Face
        :rtype: OCC.wrapper.IntTools.IntTools_SurfaceRangeLocalizeData

        """
        return _IntTools.Handle_IntTools_Context_SurfaceData(self, *args)


    def SolidClassifier(self, *args):
        """
        SolidClassifier(Handle_IntTools_Context self, TopoDS_Solid aSolid) -> BRepClass3d_SolidClassifier

        Returns a reference to solid classifier
        for given solid

        :type aSolid: OCC.wrapper.TopoDS.TopoDS_Solid
        :rtype: OCC.wrapper.BRepClass3d.BRepClass3d_SolidClassifier

        """
        return _IntTools.Handle_IntTools_Context_SolidClassifier(self, *args)


    def Hatcher(self, *args):
        """
        Hatcher(Handle_IntTools_Context self, TopoDS_Face aF) -> Geom2dHatch_Hatcher

        Returns a reference to 2D hatcher
        for given face

        :type aF: OCC.wrapper.TopoDS.TopoDS_Face
        :rtype: OCC.wrapper.Geom2dHatch.Geom2dHatch_Hatcher

        """
        return _IntTools.Handle_IntTools_Context_Hatcher(self, *args)


    def SurfaceAdaptor(self, *args):
        """
        SurfaceAdaptor(Handle_IntTools_Context self, TopoDS_Face theFace) -> BRepAdaptor_Surface

        Returns a reference to surface adaptor for given face

        :type theFace: OCC.wrapper.TopoDS.TopoDS_Face
        :rtype: OCC.wrapper.BRepAdaptor.BRepAdaptor_Surface

        """
        return _IntTools.Handle_IntTools_Context_SurfaceAdaptor(self, *args)


    def OBB(self, *args):
        """
        OBB(Handle_IntTools_Context self, TopoDS_Shape theShape, Standard_Real const theFuzzyValue) -> Bnd_OBB

        Builds and stores an Oriented Bounding Box for the shape.
        Returns a reference to OBB.

        :type theShape: OCC.wrapper.TopoDS.TopoDS_Shape
        :type theFuzzyValue: float
        :rtype: OCC.wrapper.Bnd.Bnd_OBB

        """
        return _IntTools.Handle_IntTools_Context_OBB(self, *args)


    def UVBounds(self, *args):
        """
        UVBounds(Handle_IntTools_Context self, TopoDS_Face theFace)

        Computes the boundaries of the face using surface adaptor

        :type theFace: OCC.wrapper.TopoDS.TopoDS_Face
        :type UMin: float
        :type UMax: float
        :type VMin: float
        :type VMax: float

        """
        return _IntTools.Handle_IntTools_Context_UVBounds(self, *args)


    def ComputePE(self, *args):
        """
        ComputePE(Handle_IntTools_Context self, gp_Pnt theP, Standard_Real const theTolP, TopoDS_Edge theE) -> Standard_Integer

        Computes parameter of the Point theP on
        the edge aE.
        Returns zero if the distance between point
        and edge is less than sum of tolerance value of edge and theTopP,
        otherwise and for following conditions returns
        negative value
        1. the edge is degenerated (-1)
        2. the edge does not contain 3d curve and pcurves (-2)
        3. projection algorithm failed (-3)

        :type theP: OCC.wrapper.gp.gp_Pnt
        :type theTolP: float
        :type theE: OCC.wrapper.TopoDS.TopoDS_Edge
        :type theT: float
        :type theDist: float
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntTools.Handle_IntTools_Context_ComputePE(self, *args)


    def ComputeVE(self, *args):
        """
        ComputeVE(Handle_IntTools_Context self, TopoDS_Vertex theV, TopoDS_Edge theE, Standard_Real const theFuzz) -> Standard_Integer

        Computes parameter of the vertex aV on
        the edge aE and correct tolerance value for 
        the vertex on the edge.
        Returns zero if the distance between vertex
        and edge is less than sum of tolerances and the fuzzy value,
        otherwise and for following conditions returns
        negative value: <br>
        1. the edge is degenerated (-1) <br>
        2. the edge does not contain 3d curve and pcurves (-2) <br>
        3. projection algorithm failed (-3)

        :type theV: OCC.wrapper.TopoDS.TopoDS_Vertex
        :type theE: OCC.wrapper.TopoDS.TopoDS_Edge
        :type theT: float
        :type theTol: float
        :type theFuzz: float
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntTools.Handle_IntTools_Context_ComputeVE(self, *args)


    def ComputeVF(self, *args):
        """
        ComputeVF(Handle_IntTools_Context self, TopoDS_Vertex theVertex, TopoDS_Face theFace, Standard_Real const theFuzz) -> Standard_Integer

        Computes UV parameters of the vertex aV on face aF
        and correct tolerance value for the vertex on the face.
        Returns zero if the distance between vertex and face is
        less than or equal the sum of tolerances and the fuzzy value 
        and the projection point lays inside boundaries of the face.
        For following conditions returns negative value <br>
        1. projection algorithm failed (-1) <br>
        2. distance is more than sum of tolerances (-2) <br>
        3. projection point out or on the boundaries of face (-3)

        :type theVertex: OCC.wrapper.TopoDS.TopoDS_Vertex
        :type theFace: OCC.wrapper.TopoDS.TopoDS_Face
        :type theU: float
        :type theV: float
        :type theTol: float
        :type theFuzz: float
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntTools.Handle_IntTools_Context_ComputeVF(self, *args)


    def StatePointFace(self, *args):
        """
        StatePointFace(Handle_IntTools_Context self, TopoDS_Face aF, gp_Pnt2d aP2D) -> TopAbs_State

        Returns the state of the point aP2D
        relative to face aF

        :type aF: OCC.wrapper.TopoDS.TopoDS_Face
        :type aP2D: OCC.wrapper.gp.gp_Pnt2d
        :rtype: OCC.wrapper.TopAbs.TopAbs_State

        """
        return _IntTools.Handle_IntTools_Context_StatePointFace(self, *args)


    def IsPointInFace(self, *args):
        """
        IsPointInFace(Handle_IntTools_Context self, TopoDS_Face aF, gp_Pnt2d aP2D) -> Standard_Boolean
        IsPointInFace(Handle_IntTools_Context self, gp_Pnt aP3D, TopoDS_Face aF, Standard_Real const aTol) -> Standard_Boolean

        Returns true if the point aP2D is
        inside the boundaries of the face aF,
        otherwise returns false

        :type aP3D: OCC.wrapper.gp.gp_Pnt
        :type aF: OCC.wrapper.TopoDS.TopoDS_Face
        :type aTol: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntTools.Handle_IntTools_Context_IsPointInFace(self, *args)


    def IsPointInOnFace(self, *args):
        """
        IsPointInOnFace(Handle_IntTools_Context self, TopoDS_Face aF, gp_Pnt2d aP2D) -> Standard_Boolean

        Returns true if the point aP2D is
        inside or on the boundaries of aF

        :type aF: OCC.wrapper.TopoDS.TopoDS_Face
        :type aP2D: OCC.wrapper.gp.gp_Pnt2d
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntTools.Handle_IntTools_Context_IsPointInOnFace(self, *args)


    def IsValidPointForFace(self, *args):
        """
        IsValidPointForFace(Handle_IntTools_Context self, gp_Pnt aP3D, TopoDS_Face aF, Standard_Real const aTol) -> Standard_Boolean

        Returns true if the distance between point aP3D
        and face aF is less or equal to tolerance aTol
        and projection point is inside or on the boundaries
        of the face aF

        :type aP3D: OCC.wrapper.gp.gp_Pnt
        :type aF: OCC.wrapper.TopoDS.TopoDS_Face
        :type aTol: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntTools.Handle_IntTools_Context_IsValidPointForFace(self, *args)


    def IsValidPointForFaces(self, *args):
        """
        IsValidPointForFaces(Handle_IntTools_Context self, gp_Pnt aP3D, TopoDS_Face aF1, TopoDS_Face aF2, Standard_Real const aTol) -> Standard_Boolean

        Returns true if IsValidPointForFace returns true
        for both face aF1 and aF2

        :type aP3D: OCC.wrapper.gp.gp_Pnt
        :type aF1: OCC.wrapper.TopoDS.TopoDS_Face
        :type aF2: OCC.wrapper.TopoDS.TopoDS_Face
        :type aTol: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntTools.Handle_IntTools_Context_IsValidPointForFaces(self, *args)


    def IsValidBlockForFace(self, *args):
        """
        IsValidBlockForFace(Handle_IntTools_Context self, Standard_Real const aT1, Standard_Real const aT2, IntTools_Curve aIC, TopoDS_Face aF, Standard_Real const aTol) -> Standard_Boolean

        Returns true if IsValidPointForFace returns true
        for some 3d point that lay on the curve aIC bounded by
        parameters aT1 and aT2

        :type aT1: float
        :type aT2: float
        :type aIC: OCC.wrapper.IntTools.IntTools_Curve
        :type aF: OCC.wrapper.TopoDS.TopoDS_Face
        :type aTol: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntTools.Handle_IntTools_Context_IsValidBlockForFace(self, *args)


    def IsValidBlockForFaces(self, *args):
        """
        IsValidBlockForFaces(Handle_IntTools_Context self, Standard_Real const aT1, Standard_Real const aT2, IntTools_Curve aIC, TopoDS_Face aF1, TopoDS_Face aF2, Standard_Real const aTol) -> Standard_Boolean

        Returns true if IsValidBlockForFace returns true
        for both faces aF1 and aF2

        :type aT1: float
        :type aT2: float
        :type aIC: OCC.wrapper.IntTools.IntTools_Curve
        :type aF1: OCC.wrapper.TopoDS.TopoDS_Face
        :type aF2: OCC.wrapper.TopoDS.TopoDS_Face
        :type aTol: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntTools.Handle_IntTools_Context_IsValidBlockForFaces(self, *args)


    def IsVertexOnLine(self, *args):
        """
        IsVertexOnLine(Handle_IntTools_Context self, TopoDS_Vertex aV, IntTools_Curve aIC, Standard_Real const aTolC) -> Standard_Boolean
        IsVertexOnLine(Handle_IntTools_Context self, TopoDS_Vertex aV, Standard_Real const aTolV, IntTools_Curve aIC, Standard_Real const aTolC) -> Standard_Boolean

        Computes parameter of the vertex aV on
        the curve aIC.
        Returns true if the distance between vertex and
        curve is less than sum of tolerance of aV and aTolC,
        otherwise or if projection algorithm failed
        returns false (in this case aT isn't significant)

        :type aV: OCC.wrapper.TopoDS.TopoDS_Vertex
        :type aTolV: float
        :type aIC: OCC.wrapper.IntTools.IntTools_Curve
        :type aTolC: float
        :type aT: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntTools.Handle_IntTools_Context_IsVertexOnLine(self, *args)


    def ProjectPointOnEdge(self, *args):
        """
        ProjectPointOnEdge(Handle_IntTools_Context self, gp_Pnt aP, TopoDS_Edge aE) -> Standard_Boolean

        Computes parameter of the point aP on
        the edge aE.
        Returns false if projection algorithm failed
        other wiese returns true.

        :type aP: OCC.wrapper.gp.gp_Pnt
        :type aE: OCC.wrapper.TopoDS.TopoDS_Edge
        :type aT: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntTools.Handle_IntTools_Context_ProjectPointOnEdge(self, *args)


    def BndBox(self, *args):
        """
        BndBox(Handle_IntTools_Context self, TopoDS_Shape theS) -> Bnd_Box

        :type theS: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.Bnd.Bnd_Box

        """
        return _IntTools.Handle_IntTools_Context_BndBox(self, *args)


    def IsInfiniteFace(self, *args):
        """
        IsInfiniteFace(Handle_IntTools_Context self, TopoDS_Face theFace) -> Standard_Boolean

        Returns true if the solid <theFace> has
        infinite bounds

        :type theFace: OCC.wrapper.TopoDS.TopoDS_Face
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntTools.Handle_IntTools_Context_IsInfiniteFace(self, *args)


    def SetPOnSProjectionTolerance(self, *args):
        """
        SetPOnSProjectionTolerance(Handle_IntTools_Context self, Standard_Real const theValue)

        Sets tolerance to be used for projection of point on surface.
        Clears map of already cached projectors in order to maintain
        correct value for all projectors

        :type theValue: float

        """
        return _IntTools.Handle_IntTools_Context_SetPOnSProjectionTolerance(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_IntTools_Context self) -> char const *

        :rtype: const char *

        """
        return _IntTools.Handle_IntTools_Context_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IntTools.Handle_IntTools_Context_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IntTools.Handle_IntTools_Context_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_IntTools_Context self)

        Memory deallocator for transient classes


        """
        return _IntTools.Handle_IntTools_Context_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_IntTools_Context self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_IntTools_Context self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntTools.Handle_IntTools_Context_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_IntTools_Context self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_IntTools_Context self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntTools.Handle_IntTools_Context_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_IntTools_Context self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _IntTools.Handle_IntTools_Context_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_IntTools_Context self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntTools.Handle_IntTools_Context_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_IntTools_Context self)

        Increments the reference counter of this object


        """
        return _IntTools.Handle_IntTools_Context_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_IntTools_Context self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntTools.Handle_IntTools_Context_DecrementRefCounter(self, *args)

Handle_IntTools_Context_swigregister = _IntTools.Handle_IntTools_Context_swigregister
Handle_IntTools_Context_swigregister(Handle_IntTools_Context)

def Handle_IntTools_Context_DownCast(thing):
    return _IntTools.Handle_IntTools_Context_DownCast(thing)
Handle_IntTools_Context_DownCast = _IntTools.Handle_IntTools_Context_DownCast




# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_BlendFunc')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_BlendFunc')
    _BlendFunc = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_BlendFunc', [dirname(__file__)])
        except ImportError:
            import _BlendFunc
            return _BlendFunc
        try:
            _mod = imp.load_module('_BlendFunc', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _BlendFunc = swig_import_helper()
    del swig_import_helper
else:
    import _BlendFunc
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


class SwigPyIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _BlendFunc.delete_SwigPyIterator

    def value(self):
        return _BlendFunc.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _BlendFunc.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _BlendFunc.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _BlendFunc.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _BlendFunc.SwigPyIterator_equal(self, x)

    def copy(self):
        return _BlendFunc.SwigPyIterator_copy(self)

    def next(self):
        return _BlendFunc.SwigPyIterator_next(self)

    def __next__(self):
        return _BlendFunc.SwigPyIterator___next__(self)

    def previous(self):
        return _BlendFunc.SwigPyIterator_previous(self)

    def advance(self, n):
        return _BlendFunc.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _BlendFunc.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _BlendFunc.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _BlendFunc.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _BlendFunc.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _BlendFunc.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _BlendFunc.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self
SwigPyIterator_swigregister = _BlendFunc.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

class NCollection_CellFilter_InspectorXYZ(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _BlendFunc.NCollection_CellFilter_InspectorXYZ_Dimension
    Coord = staticmethod(_BlendFunc.NCollection_CellFilter_InspectorXYZ_Coord)

    def Shift(self, thePnt, theTol):
        return _BlendFunc.NCollection_CellFilter_InspectorXYZ_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _BlendFunc.new_NCollection_CellFilter_InspectorXYZ()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _BlendFunc.delete_NCollection_CellFilter_InspectorXYZ
NCollection_CellFilter_InspectorXYZ_swigregister = _BlendFunc.NCollection_CellFilter_InspectorXYZ_swigregister
NCollection_CellFilter_InspectorXYZ_swigregister(NCollection_CellFilter_InspectorXYZ)

def NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt):
    return _BlendFunc.NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt)
NCollection_CellFilter_InspectorXYZ_Coord = _BlendFunc.NCollection_CellFilter_InspectorXYZ_Coord

class NCollection_CellFilter_InspectorXY(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _BlendFunc.NCollection_CellFilter_InspectorXY_Dimension
    Coord = staticmethod(_BlendFunc.NCollection_CellFilter_InspectorXY_Coord)

    def Shift(self, thePnt, theTol):
        return _BlendFunc.NCollection_CellFilter_InspectorXY_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _BlendFunc.new_NCollection_CellFilter_InspectorXY()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _BlendFunc.delete_NCollection_CellFilter_InspectorXY
NCollection_CellFilter_InspectorXY_swigregister = _BlendFunc.NCollection_CellFilter_InspectorXY_swigregister
NCollection_CellFilter_InspectorXY_swigregister(NCollection_CellFilter_InspectorXY)

def NCollection_CellFilter_InspectorXY_Coord(i, thePnt):
    return _BlendFunc.NCollection_CellFilter_InspectorXY_Coord(i, thePnt)
NCollection_CellFilter_InspectorXY_Coord = _BlendFunc.NCollection_CellFilter_InspectorXY_Coord


def ptr_to_number(item):
    return _BlendFunc.ptr_to_number(item)
ptr_to_number = _BlendFunc.ptr_to_number

def HashCode(*args):
    return _BlendFunc.HashCode(*args)
HashCode = _BlendFunc.HashCode

def ptr_equal(a, b):
    return _BlendFunc.ptr_equal(a, b)
ptr_equal = _BlendFunc.ptr_equal
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Convert
else:
    import Convert
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import NCollection
else:
    import NCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Standard
else:
    import Standard
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import gp
else:
    import gp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColStd
else:
    import TColStd
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TCollection
else:
    import TCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColgp
else:
    import TColgp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import GeomAbs
else:
    import GeomAbs
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Adaptor2d
else:
    import Adaptor2d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Geom2d
else:
    import Geom2d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Adaptor3d
else:
    import Adaptor3d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopAbs
else:
    import TopAbs
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Geom
else:
    import Geom
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import math
else:
    import math
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Law
else:
    import Law
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Blend
else:
    import Blend
del _swig_python_version_info
BlendFunc_Rational = _BlendFunc.BlendFunc_Rational
BlendFunc_QuasiAngular = _BlendFunc.BlendFunc_QuasiAngular
BlendFunc_Polynomial = _BlendFunc.BlendFunc_Polynomial
BlendFunc_Linear = _BlendFunc.BlendFunc_Linear
class BlendFunc_Corde(object):
    """
    This function calculates point (pts) on the curve of
    intersection between the normal to a curve (guide)
    in a chosen parameter and a surface  (surf), so
    that pts was at a given distance from the guide.
    X(1),X(2) are the parameters U,V of pts on surf.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BlendFunc_Corde self, Handle_Adaptor3d_HSurface S, Handle_Adaptor3d_HCurve CGuide) -> BlendFunc_Corde

        :type S: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface
        :type CGuide: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HCurve

        """
        this = _BlendFunc.new_BlendFunc_Corde(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def SetParam(self, *args):
        """
        SetParam(BlendFunc_Corde self, Standard_Real const Param)

        :type Param: float

        """
        return _BlendFunc.BlendFunc_Corde_SetParam(self, *args)


    def SetDist(self, *args):
        """
        SetDist(BlendFunc_Corde self, Standard_Real const Dist)

        :type Dist: float

        """
        return _BlendFunc.BlendFunc_Corde_SetDist(self, *args)


    def Value(self, *args):
        """
        Value(BlendFunc_Corde self, math_Vector X, math_Vector F) -> Standard_Boolean

        computes the values <F> of the Function for the
        variable <X>.
        Returns True if the computation was done successfully,
        False otherwise.

        :type X: OCC.wrapper.math.math_Vector
        :type F: OCC.wrapper.math.math_Vector
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BlendFunc.BlendFunc_Corde_Value(self, *args)


    def Derivatives(self, *args):
        """
        Derivatives(BlendFunc_Corde self, math_Vector X, math_Matrix D) -> Standard_Boolean

        returns the values <D> of the derivatives for the
        variable <X>.
        Returns True if the computation was done successfully,
        False otherwise.

        :type X: OCC.wrapper.math.math_Vector
        :type D: OCC.wrapper.math.math_Matrix
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BlendFunc.BlendFunc_Corde_Derivatives(self, *args)


    def PointOnS(self, *args):
        """
        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        res = _BlendFunc.BlendFunc_Corde_PointOnS(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def PointOnGuide(self, *args):
        """
        returns the point of parameter <Param> on CGuide

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        res = _BlendFunc.BlendFunc_Corde_PointOnGuide(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def NPlan(self, *args):
        """
        returns the normal to CGuide at Ptgui.

        :rtype: OCC.wrapper.gp.gp_Vec

        """
        res = _BlendFunc.BlendFunc_Corde_NPlan(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def IsTangencyPoint(self, *args):
        """
        IsTangencyPoint(BlendFunc_Corde self) -> Standard_Boolean

        Returns True when it is not possible to compute
        the tangent vectors at PointOnS.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BlendFunc.BlendFunc_Corde_IsTangencyPoint(self, *args)


    def TangentOnS(self, *args):
        """
        Returns the tangent vector at PointOnS, in 3d space.

        :rtype: OCC.wrapper.gp.gp_Vec

        """
        res = _BlendFunc.BlendFunc_Corde_TangentOnS(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Tangent2dOnS(self, *args):
        """
        Returns the tangent vector at PointOnS, in the
        parametric space of the first surface.

        :rtype: OCC.wrapper.gp.gp_Vec2d

        """
        res = _BlendFunc.BlendFunc_Corde_Tangent2dOnS(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DerFguide(self, *args):
        """
        DerFguide(BlendFunc_Corde self, math_Vector Sol, gp_Vec2d DerF)

        Derived of the function compared to the parameter
        of the guideline

        :type Sol: OCC.wrapper.math.math_Vector
        :type DerF: OCC.wrapper.gp.gp_Vec2d

        """
        return _BlendFunc.BlendFunc_Corde_DerFguide(self, *args)


    def IsSolution(self, *args):
        """
        IsSolution(BlendFunc_Corde self, math_Vector Sol, Standard_Real const Tol) -> Standard_Boolean

        Returns False if Sol is not solution else returns
        True and updates the fields tgs and tg2d

        :type Sol: OCC.wrapper.math.math_Vector
        :type Tol: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BlendFunc.BlendFunc_Corde_IsSolution(self, *args)

    __swig_destroy__ = _BlendFunc.delete_BlendFunc_Corde
BlendFunc_Corde_swigregister = _BlendFunc.BlendFunc_Corde_swigregister
BlendFunc_Corde_swigregister(BlendFunc_Corde)

class BlendFunc_ChAsymInv(Blend.Blend_FuncInv):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BlendFunc_ChAsymInv self, Handle_Adaptor3d_HSurface S1, Handle_Adaptor3d_HSurface S2, Handle_Adaptor3d_HCurve C) -> BlendFunc_ChAsymInv

        :type S1: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface
        :type S2: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface
        :type C: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HCurve

        """
        this = _BlendFunc.new_BlendFunc_ChAsymInv(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def GetTolerance(self, *args):
        """
        GetTolerance(BlendFunc_ChAsymInv self, math_Vector Tolerance, Standard_Real const Tol)

        :type Tolerance: OCC.wrapper.math.math_Vector
        :type Tol: float

        """
        return _BlendFunc.BlendFunc_ChAsymInv_GetTolerance(self, *args)


    def GetBounds(self, *args):
        """
        GetBounds(BlendFunc_ChAsymInv self, math_Vector InfBound, math_Vector SupBound)

        :type InfBound: OCC.wrapper.math.math_Vector
        :type SupBound: OCC.wrapper.math.math_Vector

        """
        return _BlendFunc.BlendFunc_ChAsymInv_GetBounds(self, *args)


    def IsSolution(self, *args):
        """
        IsSolution(BlendFunc_ChAsymInv self, math_Vector Sol, Standard_Real const Tol) -> Standard_Boolean

        :type Sol: OCC.wrapper.math.math_Vector
        :type Tol: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BlendFunc.BlendFunc_ChAsymInv_IsSolution(self, *args)


    def NbEquations(self, *args):
        """
        NbEquations(BlendFunc_ChAsymInv self) -> Standard_Integer

        returns the number of equations of the function.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BlendFunc.BlendFunc_ChAsymInv_NbEquations(self, *args)


    def ComputeValues(self, *args):
        """
        ComputeValues(BlendFunc_ChAsymInv self, math_Vector X, Standard_Integer const DegF, Standard_Integer const DegL) -> Standard_Boolean

        computes the values <F> of the derivatives for the
        variable <X> between DegF and DegL.
        Returns True if the computation was done successfully,
        False otherwise.

        :type X: OCC.wrapper.math.math_Vector
        :type DegF: int
        :type DegL: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BlendFunc.BlendFunc_ChAsymInv_ComputeValues(self, *args)


    def Value(self, *args):
        """
        Value(BlendFunc_ChAsymInv self, math_Vector X, math_Vector F) -> Standard_Boolean

        computes the values <F> of the Functions for the
        variable <X>.
        Returns True if the computation was done successfully,
        False otherwise.

        :type X: OCC.wrapper.math.math_Vector
        :type F: OCC.wrapper.math.math_Vector
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BlendFunc.BlendFunc_ChAsymInv_Value(self, *args)


    def Derivatives(self, *args):
        """
        Derivatives(BlendFunc_ChAsymInv self, math_Vector X, math_Matrix D) -> Standard_Boolean

        returns the values <D> of the derivatives for the
        variable <X>.
        Returns True if the computation was done successfully,
        False otherwise.

        :type X: OCC.wrapper.math.math_Vector
        :type D: OCC.wrapper.math.math_Matrix
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BlendFunc.BlendFunc_ChAsymInv_Derivatives(self, *args)


    def Values(self, *args):
        """
        Values(BlendFunc_ChAsymInv self, math_Vector X, math_Vector F, math_Matrix D) -> Standard_Boolean

        returns the values <F> of the functions and the derivatives
        <D> for the variable <X>.
        Returns True if the computation was done successfully,
        False otherwise.

        :type X: OCC.wrapper.math.math_Vector
        :type F: OCC.wrapper.math.math_Vector
        :type D: OCC.wrapper.math.math_Matrix
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BlendFunc.BlendFunc_ChAsymInv_Values(self, *args)


    def Set(self, *args):
        """
        Set(BlendFunc_ChAsymInv self, Standard_Boolean const OnFirst, Handle_Adaptor2d_HCurve2d COnSurf)
        Set(BlendFunc_ChAsymInv self, Standard_Real const Dist1, Standard_Real const Angle, Standard_Integer const Choix)

        :type Dist1: float
        :type Angle: float
        :type Choix: int

        """
        return _BlendFunc.BlendFunc_ChAsymInv_Set(self, *args)

    __swig_destroy__ = _BlendFunc.delete_BlendFunc_ChAsymInv
BlendFunc_ChAsymInv_swigregister = _BlendFunc.BlendFunc_ChAsymInv_swigregister
BlendFunc_ChAsymInv_swigregister(BlendFunc_ChAsymInv)

class BlendFunc_RuledInv(Blend.Blend_FuncInv):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BlendFunc_RuledInv self, Handle_Adaptor3d_HSurface S1, Handle_Adaptor3d_HSurface S2, Handle_Adaptor3d_HCurve C) -> BlendFunc_RuledInv

        :type S1: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface
        :type S2: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface
        :type C: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HCurve

        """
        this = _BlendFunc.new_BlendFunc_RuledInv(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Set(self, *args):
        """
        Set(BlendFunc_RuledInv self, Standard_Boolean const OnFirst, Handle_Adaptor2d_HCurve2d COnSurf)

        :type OnFirst: bool
        :type COnSurf: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d

        """
        return _BlendFunc.BlendFunc_RuledInv_Set(self, *args)


    def GetTolerance(self, *args):
        """
        GetTolerance(BlendFunc_RuledInv self, math_Vector Tolerance, Standard_Real const Tol)

        :type Tolerance: OCC.wrapper.math.math_Vector
        :type Tol: float

        """
        return _BlendFunc.BlendFunc_RuledInv_GetTolerance(self, *args)


    def GetBounds(self, *args):
        """
        GetBounds(BlendFunc_RuledInv self, math_Vector InfBound, math_Vector SupBound)

        :type InfBound: OCC.wrapper.math.math_Vector
        :type SupBound: OCC.wrapper.math.math_Vector

        """
        return _BlendFunc.BlendFunc_RuledInv_GetBounds(self, *args)


    def IsSolution(self, *args):
        """
        IsSolution(BlendFunc_RuledInv self, math_Vector Sol, Standard_Real const Tol) -> Standard_Boolean

        :type Sol: OCC.wrapper.math.math_Vector
        :type Tol: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BlendFunc.BlendFunc_RuledInv_IsSolution(self, *args)


    def NbEquations(self, *args):
        """
        NbEquations(BlendFunc_RuledInv self) -> Standard_Integer

        returns the number of equations of the function.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BlendFunc.BlendFunc_RuledInv_NbEquations(self, *args)


    def Value(self, *args):
        """
        Value(BlendFunc_RuledInv self, math_Vector X, math_Vector F) -> Standard_Boolean

        computes the values <F> of the Functions for the
        variable <X>.
        Returns True if the computation was done successfully,
        False otherwise.

        :type X: OCC.wrapper.math.math_Vector
        :type F: OCC.wrapper.math.math_Vector
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BlendFunc.BlendFunc_RuledInv_Value(self, *args)


    def Derivatives(self, *args):
        """
        Derivatives(BlendFunc_RuledInv self, math_Vector X, math_Matrix D) -> Standard_Boolean

        returns the values <D> of the derivatives for the
        variable <X>.
        Returns True if the computation was done successfully,
        False otherwise.

        :type X: OCC.wrapper.math.math_Vector
        :type D: OCC.wrapper.math.math_Matrix
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BlendFunc.BlendFunc_RuledInv_Derivatives(self, *args)


    def Values(self, *args):
        """
        Values(BlendFunc_RuledInv self, math_Vector X, math_Vector F, math_Matrix D) -> Standard_Boolean

        returns the values <F> of the functions and the derivatives
        <D> for the variable <X>.
        Returns True if the computation was done successfully,
        False otherwise.

        :type X: OCC.wrapper.math.math_Vector
        :type F: OCC.wrapper.math.math_Vector
        :type D: OCC.wrapper.math.math_Matrix
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BlendFunc.BlendFunc_RuledInv_Values(self, *args)

    __swig_destroy__ = _BlendFunc.delete_BlendFunc_RuledInv
BlendFunc_RuledInv_swigregister = _BlendFunc.BlendFunc_RuledInv_swigregister
BlendFunc_RuledInv_swigregister(BlendFunc_RuledInv)

class BlendFunc_ConstRad(Blend.Blend_Function):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BlendFunc_ConstRad self, Handle_Adaptor3d_HSurface S1, Handle_Adaptor3d_HSurface S2, Handle_Adaptor3d_HCurve C) -> BlendFunc_ConstRad

        :type S1: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface
        :type S2: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface
        :type C: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HCurve

        """
        this = _BlendFunc.new_BlendFunc_ConstRad(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def NbEquations(self, *args):
        """
        NbEquations(BlendFunc_ConstRad self) -> Standard_Integer

        returns the number of equations of the function.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BlendFunc.BlendFunc_ConstRad_NbEquations(self, *args)


    def Value(self, *args):
        """
        Value(BlendFunc_ConstRad self, math_Vector X, math_Vector F) -> Standard_Boolean

        computes the values <F> of the Functions for the
        variable <X>.
        Returns True if the computation was done successfully,
        False otherwise.

        :type X: OCC.wrapper.math.math_Vector
        :type F: OCC.wrapper.math.math_Vector
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BlendFunc.BlendFunc_ConstRad_Value(self, *args)


    def Derivatives(self, *args):
        """
        Derivatives(BlendFunc_ConstRad self, math_Vector X, math_Matrix D) -> Standard_Boolean

        returns the values <D> of the derivatives for the
        variable <X>.
        Returns True if the computation was done successfully,
        False otherwise.

        :type X: OCC.wrapper.math.math_Vector
        :type D: OCC.wrapper.math.math_Matrix
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BlendFunc.BlendFunc_ConstRad_Derivatives(self, *args)


    def Values(self, *args):
        """
        Values(BlendFunc_ConstRad self, math_Vector X, math_Vector F, math_Matrix D) -> Standard_Boolean

        returns the values <F> of the functions and the derivatives
        <D> for the variable <X>.
        Returns True if the computation was done successfully,
        False otherwise.

        :type X: OCC.wrapper.math.math_Vector
        :type F: OCC.wrapper.math.math_Vector
        :type D: OCC.wrapper.math.math_Matrix
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BlendFunc.BlendFunc_ConstRad_Values(self, *args)


    def GetBounds(self, *args):
        """
        GetBounds(BlendFunc_ConstRad self, math_Vector InfBound, math_Vector SupBound)

        :type InfBound: OCC.wrapper.math.math_Vector
        :type SupBound: OCC.wrapper.math.math_Vector

        """
        return _BlendFunc.BlendFunc_ConstRad_GetBounds(self, *args)


    def IsSolution(self, *args):
        """
        IsSolution(BlendFunc_ConstRad self, math_Vector Sol, Standard_Real const Tol) -> Standard_Boolean

        :type Sol: OCC.wrapper.math.math_Vector
        :type Tol: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BlendFunc.BlendFunc_ConstRad_IsSolution(self, *args)


    def GetMinimalDistance(self, *args):
        """
        GetMinimalDistance(BlendFunc_ConstRad self) -> Standard_Real

        Returns   the    minimal  Distance  beetween   two
        extremitys of calculed sections.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _BlendFunc.BlendFunc_ConstRad_GetMinimalDistance(self, *args)


    def PointOnS1(self, *args):
        """
        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        res = _BlendFunc.BlendFunc_ConstRad_PointOnS1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def PointOnS2(self, *args):
        """
        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        res = _BlendFunc.BlendFunc_ConstRad_PointOnS2(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def IsTangencyPoint(self, *args):
        """
        IsTangencyPoint(BlendFunc_ConstRad self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BlendFunc.BlendFunc_ConstRad_IsTangencyPoint(self, *args)


    def TangentOnS1(self, *args):
        """
        :rtype: OCC.wrapper.gp.gp_Vec

        """
        res = _BlendFunc.BlendFunc_ConstRad_TangentOnS1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Tangent2dOnS1(self, *args):
        """
        :rtype: OCC.wrapper.gp.gp_Vec2d

        """
        res = _BlendFunc.BlendFunc_ConstRad_Tangent2dOnS1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def TangentOnS2(self, *args):
        """
        :rtype: OCC.wrapper.gp.gp_Vec

        """
        res = _BlendFunc.BlendFunc_ConstRad_TangentOnS2(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Tangent2dOnS2(self, *args):
        """
        :rtype: OCC.wrapper.gp.gp_Vec2d

        """
        res = _BlendFunc.BlendFunc_ConstRad_Tangent2dOnS2(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Tangent(self, *args):
        """
        Tangent(BlendFunc_ConstRad self, Standard_Real const U1, Standard_Real const V1, Standard_Real const U2, Standard_Real const V2, gp_Vec TgFirst, gp_Vec TgLast, gp_Vec NormFirst, gp_Vec NormLast)

        Returns the tangent vector at the section,
        at the beginning and the end of the section, and
        returns the normal (of the surfaces) at
        these points.

        :type U1: float
        :type V1: float
        :type U2: float
        :type V2: float
        :type TgFirst: OCC.wrapper.gp.gp_Vec
        :type TgLast: OCC.wrapper.gp.gp_Vec
        :type NormFirst: OCC.wrapper.gp.gp_Vec
        :type NormLast: OCC.wrapper.gp.gp_Vec

        """
        return _BlendFunc.BlendFunc_ConstRad_Tangent(self, *args)


    def TwistOnS1(self, *args):
        """
        TwistOnS1(BlendFunc_ConstRad self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BlendFunc.BlendFunc_ConstRad_TwistOnS1(self, *args)


    def TwistOnS2(self, *args):
        """
        TwistOnS2(BlendFunc_ConstRad self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BlendFunc.BlendFunc_ConstRad_TwistOnS2(self, *args)


    def Set(self, *args):
        """
        Set(BlendFunc_ConstRad self, Standard_Real const Param)
        Set(BlendFunc_ConstRad self, Standard_Real const First, Standard_Real const Last)
        Set(BlendFunc_ConstRad self, Standard_Real const Radius, Standard_Integer const Choix)
        Set(BlendFunc_ConstRad self, BlendFunc_SectionShape const TypeSection)

        Sets  the  type  of   section generation   for the
        approximations.

        :type TypeSection: OCC.wrapper.BlendFunc.BlendFunc_SectionShape

        """
        return _BlendFunc.BlendFunc_ConstRad_Set(self, *args)


    def IsRational(self, *args):
        """
        IsRational(BlendFunc_ConstRad self) -> Standard_Boolean

        Returns  if the section is rationnal

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BlendFunc.BlendFunc_ConstRad_IsRational(self, *args)


    def GetSectionSize(self, *args):
        """
        GetSectionSize(BlendFunc_ConstRad self) -> Standard_Real

        Returns the length of the maximum section

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _BlendFunc.BlendFunc_ConstRad_GetSectionSize(self, *args)


    def GetMinimalWeight(self, *args):
        """
        GetMinimalWeight(BlendFunc_ConstRad self, NCollection_Array1_Standard_Real Weigths)

        Compute the minimal value of weight for each poles
        of all sections.

        :type Weigths: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        return _BlendFunc.BlendFunc_ConstRad_GetMinimalWeight(self, *args)


    def NbIntervals(self, *args):
        """
        NbIntervals(BlendFunc_ConstRad self, GeomAbs_Shape const S) -> Standard_Integer

        Returns  the number  of  intervals for  continuity
        <S>. May be one if Continuity(me) >= <S>

        :type S: OCC.wrapper.GeomAbs.GeomAbs_Shape
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BlendFunc.BlendFunc_ConstRad_NbIntervals(self, *args)


    def Intervals(self, *args):
        """
        Intervals(BlendFunc_ConstRad self, NCollection_Array1_Standard_Real T, GeomAbs_Shape const S)

        Stores in <T> the  parameters bounding the intervals
        of continuity <S>.

        The array must provide  enough room to  accomodate
        for the parameters. i.e. T.Length() > NbIntervals()

        :type T: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type S: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _BlendFunc.BlendFunc_ConstRad_Intervals(self, *args)


    def GetShape(self, *args):
        """
        GetShape(BlendFunc_ConstRad self)

        :type NbPoles: int
        :type NbKnots: int
        :type Degree: int
        :type NbPoles2d: int

        """
        return _BlendFunc.BlendFunc_ConstRad_GetShape(self, *args)


    def GetTolerance(self, *args):
        """
        GetTolerance(BlendFunc_ConstRad self, math_Vector Tolerance, Standard_Real const Tol)
        GetTolerance(BlendFunc_ConstRad self, Standard_Real const BoundTol, Standard_Real const SurfTol, Standard_Real const AngleTol, math_Vector Tol3d, math_Vector Tol1D)

        Returns the tolerance to reach in approximation
        to respecte
        BoundTol error at the Boundary
        AngleTol tangent error at the Boundary
        SurfTol error inside the surface.

        :type BoundTol: float
        :type SurfTol: float
        :type AngleTol: float
        :type Tol3d: OCC.wrapper.math.math_Vector
        :type Tol1D: OCC.wrapper.math.math_Vector

        """
        return _BlendFunc.BlendFunc_ConstRad_GetTolerance(self, *args)


    def Knots(self, *args):
        """
        Knots(BlendFunc_ConstRad self, NCollection_Array1_Standard_Real TKnots)

        :type TKnots: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        return _BlendFunc.BlendFunc_ConstRad_Knots(self, *args)


    def Mults(self, *args):
        """
        Mults(BlendFunc_ConstRad self, NCollection_Array1_Standard_Integer TMults)

        :type TMults: OCC.wrapper.TColStd.TColStd_Array1OfInteger

        """
        return _BlendFunc.BlendFunc_ConstRad_Mults(self, *args)


    def Section(self, *args):
        """
        Section(BlendFunc_ConstRad self, Standard_Real const Param, Standard_Real const U1, Standard_Real const V1, Standard_Real const U2, Standard_Real const V2, gp_Circ C)
        Section(BlendFunc_ConstRad self, Blend_Point P, NCollection_Array1_gp_Pnt Poles, NCollection_Array1_gp_Vec DPoles, NCollection_Array1_gp_Vec D2Poles, NCollection_Array1_gp_Pnt2d Poles2d, NCollection_Array1_gp_Vec2d DPoles2d, NCollection_Array1_gp_Vec2d D2Poles2d, NCollection_Array1_Standard_Real Weigths, NCollection_Array1_Standard_Real DWeigths, NCollection_Array1_Standard_Real D2Weigths) -> Standard_Boolean
        Section(BlendFunc_ConstRad self, Blend_Point P, NCollection_Array1_gp_Pnt Poles, NCollection_Array1_gp_Vec DPoles, NCollection_Array1_gp_Pnt2d Poles2d, NCollection_Array1_gp_Vec2d DPoles2d, NCollection_Array1_Standard_Real Weigths, NCollection_Array1_Standard_Real DWeigths) -> Standard_Boolean
        Section(BlendFunc_ConstRad self, Blend_Point P, NCollection_Array1_gp_Pnt Poles, NCollection_Array1_gp_Pnt2d Poles2d, NCollection_Array1_Standard_Real Weigths)

        :type P: OCC.wrapper.Blend.Blend_Point
        :type Poles: OCC.wrapper.TColgp.TColgp_Array1OfPnt
        :type Poles2d: OCC.wrapper.TColgp.TColgp_Array1OfPnt2d
        :type Weigths: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        return _BlendFunc.BlendFunc_ConstRad_Section(self, *args)


    def AxeRot(self, *args):
        """
        AxeRot(BlendFunc_ConstRad self, Standard_Real const Prm) -> gp_Ax1

        :type Prm: float
        :rtype: OCC.wrapper.gp.gp_Ax1

        """
        return _BlendFunc.BlendFunc_ConstRad_AxeRot(self, *args)


    def Resolution(self, *args):
        """
        Resolution(BlendFunc_ConstRad self, Standard_Integer const IC2d, Standard_Real const Tol)

        :type IC2d: int
        :type Tol: float
        :type TolU: float
        :type TolV: float

        """
        return _BlendFunc.BlendFunc_ConstRad_Resolution(self, *args)

    __swig_destroy__ = _BlendFunc.delete_BlendFunc_ConstRad
BlendFunc_ConstRad_swigregister = _BlendFunc.BlendFunc_ConstRad_swigregister
BlendFunc_ConstRad_swigregister(BlendFunc_ConstRad)

class BlendFunc_Ruled(Blend.Blend_Function):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BlendFunc_Ruled self, Handle_Adaptor3d_HSurface S1, Handle_Adaptor3d_HSurface S2, Handle_Adaptor3d_HCurve C) -> BlendFunc_Ruled

        :type S1: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface
        :type S2: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface
        :type C: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HCurve

        """
        this = _BlendFunc.new_BlendFunc_Ruled(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def NbEquations(self, *args):
        """
        NbEquations(BlendFunc_Ruled self) -> Standard_Integer

        returns the number of equations of the function.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BlendFunc.BlendFunc_Ruled_NbEquations(self, *args)


    def Value(self, *args):
        """
        Value(BlendFunc_Ruled self, math_Vector X, math_Vector F) -> Standard_Boolean

        computes the values <F> of the Functions for the
        variable <X>.
        Returns True if the computation was done successfully,
        False otherwise.

        :type X: OCC.wrapper.math.math_Vector
        :type F: OCC.wrapper.math.math_Vector
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BlendFunc.BlendFunc_Ruled_Value(self, *args)


    def Derivatives(self, *args):
        """
        Derivatives(BlendFunc_Ruled self, math_Vector X, math_Matrix D) -> Standard_Boolean

        returns the values <D> of the derivatives for the
        variable <X>.
        Returns True if the computation was done successfully,
        False otherwise.

        :type X: OCC.wrapper.math.math_Vector
        :type D: OCC.wrapper.math.math_Matrix
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BlendFunc.BlendFunc_Ruled_Derivatives(self, *args)


    def Values(self, *args):
        """
        Values(BlendFunc_Ruled self, math_Vector X, math_Vector F, math_Matrix D) -> Standard_Boolean

        returns the values <F> of the functions and the derivatives
        <D> for the variable <X>.
        Returns True if the computation was done successfully,
        False otherwise.

        :type X: OCC.wrapper.math.math_Vector
        :type F: OCC.wrapper.math.math_Vector
        :type D: OCC.wrapper.math.math_Matrix
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BlendFunc.BlendFunc_Ruled_Values(self, *args)


    def Set(self, *args):
        """
        Set(BlendFunc_Ruled self, Standard_Real const Param)
        Set(BlendFunc_Ruled self, Standard_Real const First, Standard_Real const Last)

        :type First: float
        :type Last: float

        """
        return _BlendFunc.BlendFunc_Ruled_Set(self, *args)


    def GetBounds(self, *args):
        """
        GetBounds(BlendFunc_Ruled self, math_Vector InfBound, math_Vector SupBound)

        :type InfBound: OCC.wrapper.math.math_Vector
        :type SupBound: OCC.wrapper.math.math_Vector

        """
        return _BlendFunc.BlendFunc_Ruled_GetBounds(self, *args)


    def IsSolution(self, *args):
        """
        IsSolution(BlendFunc_Ruled self, math_Vector Sol, Standard_Real const Tol) -> Standard_Boolean

        :type Sol: OCC.wrapper.math.math_Vector
        :type Tol: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BlendFunc.BlendFunc_Ruled_IsSolution(self, *args)


    def GetMinimalDistance(self, *args):
        """
        GetMinimalDistance(BlendFunc_Ruled self) -> Standard_Real

        Returns   the    minimal  Distance  beetween   two
        extremitys of calculed sections.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _BlendFunc.BlendFunc_Ruled_GetMinimalDistance(self, *args)


    def PointOnS1(self, *args):
        """
        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        res = _BlendFunc.BlendFunc_Ruled_PointOnS1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def PointOnS2(self, *args):
        """
        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        res = _BlendFunc.BlendFunc_Ruled_PointOnS2(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def IsTangencyPoint(self, *args):
        """
        IsTangencyPoint(BlendFunc_Ruled self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BlendFunc.BlendFunc_Ruled_IsTangencyPoint(self, *args)


    def TangentOnS1(self, *args):
        """
        :rtype: OCC.wrapper.gp.gp_Vec

        """
        res = _BlendFunc.BlendFunc_Ruled_TangentOnS1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Tangent2dOnS1(self, *args):
        """
        :rtype: OCC.wrapper.gp.gp_Vec2d

        """
        res = _BlendFunc.BlendFunc_Ruled_Tangent2dOnS1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def TangentOnS2(self, *args):
        """
        :rtype: OCC.wrapper.gp.gp_Vec

        """
        res = _BlendFunc.BlendFunc_Ruled_TangentOnS2(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Tangent2dOnS2(self, *args):
        """
        :rtype: OCC.wrapper.gp.gp_Vec2d

        """
        res = _BlendFunc.BlendFunc_Ruled_Tangent2dOnS2(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Tangent(self, *args):
        """
        Tangent(BlendFunc_Ruled self, Standard_Real const U1, Standard_Real const V1, Standard_Real const U2, Standard_Real const V2, gp_Vec TgFirst, gp_Vec TgLast, gp_Vec NormFirst, gp_Vec NormLast)

        Returns the tangent vector at the section,
        at the beginning and the end of the section, and
        returns the normal (of the surfaces) at
        these points.

        :type U1: float
        :type V1: float
        :type U2: float
        :type V2: float
        :type TgFirst: OCC.wrapper.gp.gp_Vec
        :type TgLast: OCC.wrapper.gp.gp_Vec
        :type NormFirst: OCC.wrapper.gp.gp_Vec
        :type NormLast: OCC.wrapper.gp.gp_Vec

        """
        return _BlendFunc.BlendFunc_Ruled_Tangent(self, *args)


    def GetSection(self, *args):
        """
        GetSection(BlendFunc_Ruled self, Standard_Real const Param, Standard_Real const U1, Standard_Real const V1, Standard_Real const U2, Standard_Real const V2, NCollection_Array1_gp_Pnt tabP, NCollection_Array1_gp_Vec tabV) -> Standard_Boolean

        :type Param: float
        :type U1: float
        :type V1: float
        :type U2: float
        :type V2: float
        :type tabP: OCC.wrapper.TColgp.TColgp_Array1OfPnt
        :type tabV: OCC.wrapper.TColgp.TColgp_Array1OfVec
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BlendFunc.BlendFunc_Ruled_GetSection(self, *args)


    def IsRational(self, *args):
        """
        IsRational(BlendFunc_Ruled self) -> Standard_Boolean

        Returns False

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BlendFunc.BlendFunc_Ruled_IsRational(self, *args)


    def GetSectionSize(self, *args):
        """
        GetSectionSize(BlendFunc_Ruled self) -> Standard_Real

        Returns the length of the maximum section

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _BlendFunc.BlendFunc_Ruled_GetSectionSize(self, *args)


    def GetMinimalWeight(self, *args):
        """
        GetMinimalWeight(BlendFunc_Ruled self, NCollection_Array1_Standard_Real Weigths)

        Compute the minimal value of weight for each poles
        of all sections.

        :type Weigths: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        return _BlendFunc.BlendFunc_Ruled_GetMinimalWeight(self, *args)


    def NbIntervals(self, *args):
        """
        NbIntervals(BlendFunc_Ruled self, GeomAbs_Shape const S) -> Standard_Integer

        Returns  the number  of  intervals for  continuity
        <S>. May be one if Continuity(me) >= <S>

        :type S: OCC.wrapper.GeomAbs.GeomAbs_Shape
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BlendFunc.BlendFunc_Ruled_NbIntervals(self, *args)


    def Intervals(self, *args):
        """
        Intervals(BlendFunc_Ruled self, NCollection_Array1_Standard_Real T, GeomAbs_Shape const S)

        Stores in <T> the  parameters bounding the intervals
        of continuity <S>.

        The array must provide  enough room to  accomodate
        for the parameters. i.e. T.Length() > NbIntervals()
        raises
        OutOfRange from Standard

        :type T: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type S: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _BlendFunc.BlendFunc_Ruled_Intervals(self, *args)


    def GetShape(self, *args):
        """
        GetShape(BlendFunc_Ruled self)

        :type NbPoles: int
        :type NbKnots: int
        :type Degree: int
        :type NbPoles2d: int

        """
        return _BlendFunc.BlendFunc_Ruled_GetShape(self, *args)


    def GetTolerance(self, *args):
        """
        GetTolerance(BlendFunc_Ruled self, math_Vector Tolerance, Standard_Real const Tol)
        GetTolerance(BlendFunc_Ruled self, Standard_Real const BoundTol, Standard_Real const SurfTol, Standard_Real const AngleTol, math_Vector Tol3d, math_Vector Tol1D)

        Returns the tolerance to reach in approximation
        to respecte
        BoundTol error at the Boundary
        AngleTol tangent error at the Boundary
        SurfTol error inside the surface.

        :type BoundTol: float
        :type SurfTol: float
        :type AngleTol: float
        :type Tol3d: OCC.wrapper.math.math_Vector
        :type Tol1D: OCC.wrapper.math.math_Vector

        """
        return _BlendFunc.BlendFunc_Ruled_GetTolerance(self, *args)


    def Knots(self, *args):
        """
        Knots(BlendFunc_Ruled self, NCollection_Array1_Standard_Real TKnots)

        :type TKnots: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        return _BlendFunc.BlendFunc_Ruled_Knots(self, *args)


    def Mults(self, *args):
        """
        Mults(BlendFunc_Ruled self, NCollection_Array1_Standard_Integer TMults)

        :type TMults: OCC.wrapper.TColStd.TColStd_Array1OfInteger

        """
        return _BlendFunc.BlendFunc_Ruled_Mults(self, *args)


    def Section(self, *args):
        """
        Section(BlendFunc_Ruled self, Blend_Point P, NCollection_Array1_gp_Pnt Poles, NCollection_Array1_gp_Vec DPoles, NCollection_Array1_gp_Vec D2Poles, NCollection_Array1_gp_Pnt2d Poles2d, NCollection_Array1_gp_Vec2d DPoles2d, NCollection_Array1_gp_Vec2d D2Poles2d, NCollection_Array1_Standard_Real Weigths, NCollection_Array1_Standard_Real DWeigths, NCollection_Array1_Standard_Real D2Weigths) -> Standard_Boolean
        Section(BlendFunc_Ruled self, Blend_Point P, NCollection_Array1_gp_Pnt Poles, NCollection_Array1_gp_Vec DPoles, NCollection_Array1_gp_Pnt2d Poles2d, NCollection_Array1_gp_Vec2d DPoles2d, NCollection_Array1_Standard_Real Weigths, NCollection_Array1_Standard_Real DWeigths) -> Standard_Boolean
        Section(BlendFunc_Ruled self, Blend_Point P, NCollection_Array1_gp_Pnt Poles, NCollection_Array1_gp_Pnt2d Poles2d, NCollection_Array1_Standard_Real Weigths)

        :type P: OCC.wrapper.Blend.Blend_Point
        :type Poles: OCC.wrapper.TColgp.TColgp_Array1OfPnt
        :type Poles2d: OCC.wrapper.TColgp.TColgp_Array1OfPnt2d
        :type Weigths: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        return _BlendFunc.BlendFunc_Ruled_Section(self, *args)


    def AxeRot(self, *args):
        """
        AxeRot(BlendFunc_Ruled self, Standard_Real const Prm) -> gp_Ax1

        :type Prm: float
        :rtype: OCC.wrapper.gp.gp_Ax1

        """
        return _BlendFunc.BlendFunc_Ruled_AxeRot(self, *args)


    def Resolution(self, *args):
        """
        Resolution(BlendFunc_Ruled self, Standard_Integer const IC2d, Standard_Real const Tol)

        :type IC2d: int
        :type Tol: float
        :type TolU: float
        :type TolV: float

        """
        return _BlendFunc.BlendFunc_Ruled_Resolution(self, *args)

    __swig_destroy__ = _BlendFunc.delete_BlendFunc_Ruled
BlendFunc_Ruled_swigregister = _BlendFunc.BlendFunc_Ruled_swigregister
BlendFunc_Ruled_swigregister(BlendFunc_Ruled)

class BlendFunc_ConstRadInv(Blend.Blend_FuncInv):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BlendFunc_ConstRadInv self, Handle_Adaptor3d_HSurface S1, Handle_Adaptor3d_HSurface S2, Handle_Adaptor3d_HCurve C) -> BlendFunc_ConstRadInv

        :type S1: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface
        :type S2: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface
        :type C: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HCurve

        """
        this = _BlendFunc.new_BlendFunc_ConstRadInv(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def GetTolerance(self, *args):
        """
        GetTolerance(BlendFunc_ConstRadInv self, math_Vector Tolerance, Standard_Real const Tol)

        :type Tolerance: OCC.wrapper.math.math_Vector
        :type Tol: float

        """
        return _BlendFunc.BlendFunc_ConstRadInv_GetTolerance(self, *args)


    def GetBounds(self, *args):
        """
        GetBounds(BlendFunc_ConstRadInv self, math_Vector InfBound, math_Vector SupBound)

        :type InfBound: OCC.wrapper.math.math_Vector
        :type SupBound: OCC.wrapper.math.math_Vector

        """
        return _BlendFunc.BlendFunc_ConstRadInv_GetBounds(self, *args)


    def IsSolution(self, *args):
        """
        IsSolution(BlendFunc_ConstRadInv self, math_Vector Sol, Standard_Real const Tol) -> Standard_Boolean

        :type Sol: OCC.wrapper.math.math_Vector
        :type Tol: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BlendFunc.BlendFunc_ConstRadInv_IsSolution(self, *args)


    def NbEquations(self, *args):
        """
        NbEquations(BlendFunc_ConstRadInv self) -> Standard_Integer

        returns the number of equations of the function.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BlendFunc.BlendFunc_ConstRadInv_NbEquations(self, *args)


    def Value(self, *args):
        """
        Value(BlendFunc_ConstRadInv self, math_Vector X, math_Vector F) -> Standard_Boolean

        computes the values <F> of the Functions for the
        variable <X>.
        Returns True if the computation was done successfully,
        False otherwise.

        :type X: OCC.wrapper.math.math_Vector
        :type F: OCC.wrapper.math.math_Vector
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BlendFunc.BlendFunc_ConstRadInv_Value(self, *args)


    def Derivatives(self, *args):
        """
        Derivatives(BlendFunc_ConstRadInv self, math_Vector X, math_Matrix D) -> Standard_Boolean

        returns the values <D> of the derivatives for the
        variable <X>.
        Returns True if the computation was done successfully,
        False otherwise.

        :type X: OCC.wrapper.math.math_Vector
        :type D: OCC.wrapper.math.math_Matrix
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BlendFunc.BlendFunc_ConstRadInv_Derivatives(self, *args)


    def Values(self, *args):
        """
        Values(BlendFunc_ConstRadInv self, math_Vector X, math_Vector F, math_Matrix D) -> Standard_Boolean

        returns the values <F> of the functions and the derivatives
        <D> for the variable <X>.
        Returns True if the computation was done successfully,
        False otherwise.

        :type X: OCC.wrapper.math.math_Vector
        :type F: OCC.wrapper.math.math_Vector
        :type D: OCC.wrapper.math.math_Matrix
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BlendFunc.BlendFunc_ConstRadInv_Values(self, *args)


    def Set(self, *args):
        """
        Set(BlendFunc_ConstRadInv self, Standard_Boolean const OnFirst, Handle_Adaptor2d_HCurve2d COnSurf)
        Set(BlendFunc_ConstRadInv self, Standard_Real const R, Standard_Integer const Choix)

        :type R: float
        :type Choix: int

        """
        return _BlendFunc.BlendFunc_ConstRadInv_Set(self, *args)

    __swig_destroy__ = _BlendFunc.delete_BlendFunc_ConstRadInv
BlendFunc_ConstRadInv_swigregister = _BlendFunc.BlendFunc_ConstRadInv_swigregister
BlendFunc_ConstRadInv_swigregister(BlendFunc_ConstRadInv)

class BlendFunc_Chamfer(Blend.Blend_Function):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BlendFunc_Chamfer self, Handle_Adaptor3d_HSurface S1, Handle_Adaptor3d_HSurface S2, Handle_Adaptor3d_HCurve CG) -> BlendFunc_Chamfer

        :type S1: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface
        :type S2: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface
        :type CG: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HCurve

        """
        this = _BlendFunc.new_BlendFunc_Chamfer(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def NbEquations(self, *args):
        """
        NbEquations(BlendFunc_Chamfer self) -> Standard_Integer

        returns the number of equations of the function.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BlendFunc.BlendFunc_Chamfer_NbEquations(self, *args)


    def Value(self, *args):
        """
        Value(BlendFunc_Chamfer self, math_Vector X, math_Vector F) -> Standard_Boolean

        computes the values <F> of the Functions for the
        variable <X>.
        Returns True if the computation was done successfully,
        False otherwise.

        :type X: OCC.wrapper.math.math_Vector
        :type F: OCC.wrapper.math.math_Vector
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BlendFunc.BlendFunc_Chamfer_Value(self, *args)


    def Derivatives(self, *args):
        """
        Derivatives(BlendFunc_Chamfer self, math_Vector X, math_Matrix D) -> Standard_Boolean

        returns the values <D> of the derivatives for the
        variable <X>.
        Returns True if the computation was done successfully,
        False otherwise.

        :type X: OCC.wrapper.math.math_Vector
        :type D: OCC.wrapper.math.math_Matrix
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BlendFunc.BlendFunc_Chamfer_Derivatives(self, *args)


    def Values(self, *args):
        """
        Values(BlendFunc_Chamfer self, math_Vector X, math_Vector F, math_Matrix D) -> Standard_Boolean

        returns the values <F> of the functions and the derivatives
        <D> for the variable <X>.
        Returns True if the computation was done successfully,
        False otherwise.

        :type X: OCC.wrapper.math.math_Vector
        :type F: OCC.wrapper.math.math_Vector
        :type D: OCC.wrapper.math.math_Matrix
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BlendFunc.BlendFunc_Chamfer_Values(self, *args)


    def GetBounds(self, *args):
        """
        GetBounds(BlendFunc_Chamfer self, math_Vector InfBound, math_Vector SupBound)

        :type InfBound: OCC.wrapper.math.math_Vector
        :type SupBound: OCC.wrapper.math.math_Vector

        """
        return _BlendFunc.BlendFunc_Chamfer_GetBounds(self, *args)


    def IsSolution(self, *args):
        """
        IsSolution(BlendFunc_Chamfer self, math_Vector Sol, Standard_Real const Tol) -> Standard_Boolean

        :type Sol: OCC.wrapper.math.math_Vector
        :type Tol: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BlendFunc.BlendFunc_Chamfer_IsSolution(self, *args)


    def GetMinimalDistance(self, *args):
        """
        GetMinimalDistance(BlendFunc_Chamfer self) -> Standard_Real

        Returns   the    minimal  Distance  beetween   two
        extremitys of calculed sections.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _BlendFunc.BlendFunc_Chamfer_GetMinimalDistance(self, *args)


    def PointOnS1(self, *args):
        """
        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        res = _BlendFunc.BlendFunc_Chamfer_PointOnS1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def PointOnS2(self, *args):
        """
        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        res = _BlendFunc.BlendFunc_Chamfer_PointOnS2(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def IsTangencyPoint(self, *args):
        """
        IsTangencyPoint(BlendFunc_Chamfer self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BlendFunc.BlendFunc_Chamfer_IsTangencyPoint(self, *args)


    def TangentOnS1(self, *args):
        """
        :rtype: OCC.wrapper.gp.gp_Vec

        """
        res = _BlendFunc.BlendFunc_Chamfer_TangentOnS1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Tangent2dOnS1(self, *args):
        """
        :rtype: OCC.wrapper.gp.gp_Vec2d

        """
        res = _BlendFunc.BlendFunc_Chamfer_Tangent2dOnS1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def TangentOnS2(self, *args):
        """
        :rtype: OCC.wrapper.gp.gp_Vec

        """
        res = _BlendFunc.BlendFunc_Chamfer_TangentOnS2(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Tangent2dOnS2(self, *args):
        """
        :rtype: OCC.wrapper.gp.gp_Vec2d

        """
        res = _BlendFunc.BlendFunc_Chamfer_Tangent2dOnS2(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Tangent(self, *args):
        """
        Tangent(BlendFunc_Chamfer self, Standard_Real const U1, Standard_Real const V1, Standard_Real const U2, Standard_Real const V2, gp_Vec TgFirst, gp_Vec TgLast, gp_Vec NormFirst, gp_Vec NormLast)

        Returns the tangent vector at the section,
        at the beginning and the end of the section, and
        returns the normal (of the surfaces) at
        these points.

        :type U1: float
        :type V1: float
        :type U2: float
        :type V2: float
        :type TgFirst: OCC.wrapper.gp.gp_Vec
        :type TgLast: OCC.wrapper.gp.gp_Vec
        :type NormFirst: OCC.wrapper.gp.gp_Vec
        :type NormLast: OCC.wrapper.gp.gp_Vec

        """
        return _BlendFunc.BlendFunc_Chamfer_Tangent(self, *args)


    def Set(self, *args):
        """
        Set(BlendFunc_Chamfer self, Standard_Real const Param)
        Set(BlendFunc_Chamfer self, Standard_Real const First, Standard_Real const Last)
        Set(BlendFunc_Chamfer self, Standard_Real const Dist1, Standard_Real const Dist2, Standard_Integer const Choix)

        Sets the distances and the "quadrant".

        :type Dist1: float
        :type Dist2: float
        :type Choix: int

        """
        return _BlendFunc.BlendFunc_Chamfer_Set(self, *args)


    def IsRational(self, *args):
        """
        IsRational(BlendFunc_Chamfer self) -> Standard_Boolean

        Returns False

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BlendFunc.BlendFunc_Chamfer_IsRational(self, *args)


    def GetSectionSize(self, *args):
        """
        GetSectionSize(BlendFunc_Chamfer self) -> Standard_Real

        Returns the length of the maximum section

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _BlendFunc.BlendFunc_Chamfer_GetSectionSize(self, *args)


    def GetMinimalWeight(self, *args):
        """
        GetMinimalWeight(BlendFunc_Chamfer self, NCollection_Array1_Standard_Real Weigths)

        Compute the minimal value of weight for each poles
        of all sections.

        :type Weigths: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        return _BlendFunc.BlendFunc_Chamfer_GetMinimalWeight(self, *args)


    def NbIntervals(self, *args):
        """
        NbIntervals(BlendFunc_Chamfer self, GeomAbs_Shape const S) -> Standard_Integer

        Returns  the number  of  intervals for  continuity
        <S>. May be one if Continuity(me) >= <S>

        :type S: OCC.wrapper.GeomAbs.GeomAbs_Shape
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BlendFunc.BlendFunc_Chamfer_NbIntervals(self, *args)


    def Intervals(self, *args):
        """
        Intervals(BlendFunc_Chamfer self, NCollection_Array1_Standard_Real T, GeomAbs_Shape const S)

        Stores in <T> the  parameters bounding the intervals
        of continuity <S>.

        The array must provide  enough room to  accomodate
        for the parameters. i.e. T.Length() > NbIntervals()
        raises
        OutOfRange from Standard

        :type T: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type S: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _BlendFunc.BlendFunc_Chamfer_Intervals(self, *args)


    def GetShape(self, *args):
        """
        GetShape(BlendFunc_Chamfer self)

        :type NbPoles: int
        :type NbKnots: int
        :type Degree: int
        :type NbPoles2d: int

        """
        return _BlendFunc.BlendFunc_Chamfer_GetShape(self, *args)


    def GetTolerance(self, *args):
        """
        GetTolerance(BlendFunc_Chamfer self, math_Vector Tolerance, Standard_Real const Tol)
        GetTolerance(BlendFunc_Chamfer self, Standard_Real const BoundTol, Standard_Real const SurfTol, Standard_Real const AngleTol, math_Vector Tol3d, math_Vector Tol1D)

        Returns the tolerance to reach in approximation
        to respecte
        BoundTol error at the Boundary
        AngleTol tangent error at the Boundary
        SurfTol error inside the surface.

        :type BoundTol: float
        :type SurfTol: float
        :type AngleTol: float
        :type Tol3d: OCC.wrapper.math.math_Vector
        :type Tol1D: OCC.wrapper.math.math_Vector

        """
        return _BlendFunc.BlendFunc_Chamfer_GetTolerance(self, *args)


    def Knots(self, *args):
        """
        Knots(BlendFunc_Chamfer self, NCollection_Array1_Standard_Real TKnots)

        :type TKnots: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        return _BlendFunc.BlendFunc_Chamfer_Knots(self, *args)


    def Mults(self, *args):
        """
        Mults(BlendFunc_Chamfer self, NCollection_Array1_Standard_Integer TMults)

        :type TMults: OCC.wrapper.TColStd.TColStd_Array1OfInteger

        """
        return _BlendFunc.BlendFunc_Chamfer_Mults(self, *args)


    def Section(self, *args):
        """
        Section(BlendFunc_Chamfer self, Standard_Real const Param, Standard_Real const U1, Standard_Real const V1, Standard_Real const U2, Standard_Real const V2, gp_Lin C)
        Section(BlendFunc_Chamfer self, Blend_Point P, NCollection_Array1_gp_Pnt Poles, NCollection_Array1_gp_Vec DPoles, NCollection_Array1_gp_Vec D2Poles, NCollection_Array1_gp_Pnt2d Poles2d, NCollection_Array1_gp_Vec2d DPoles2d, NCollection_Array1_gp_Vec2d D2Poles2d, NCollection_Array1_Standard_Real Weigths, NCollection_Array1_Standard_Real DWeigths, NCollection_Array1_Standard_Real D2Weigths) -> Standard_Boolean
        Section(BlendFunc_Chamfer self, Blend_Point P, NCollection_Array1_gp_Pnt Poles, NCollection_Array1_gp_Vec DPoles, NCollection_Array1_gp_Pnt2d Poles2d, NCollection_Array1_gp_Vec2d DPoles2d, NCollection_Array1_Standard_Real Weigths, NCollection_Array1_Standard_Real DWeigths) -> Standard_Boolean
        Section(BlendFunc_Chamfer self, Blend_Point P, NCollection_Array1_gp_Pnt Poles, NCollection_Array1_gp_Pnt2d Poles2d, NCollection_Array1_Standard_Real Weigths)

        :type P: OCC.wrapper.Blend.Blend_Point
        :type Poles: OCC.wrapper.TColgp.TColgp_Array1OfPnt
        :type Poles2d: OCC.wrapper.TColgp.TColgp_Array1OfPnt2d
        :type Weigths: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        return _BlendFunc.BlendFunc_Chamfer_Section(self, *args)


    def Resolution(self, *args):
        """
        Resolution(BlendFunc_Chamfer self, Standard_Integer const IC2d, Standard_Real const Tol)

        :type IC2d: int
        :type Tol: float
        :type TolU: float
        :type TolV: float

        """
        return _BlendFunc.BlendFunc_Chamfer_Resolution(self, *args)

    __swig_destroy__ = _BlendFunc.delete_BlendFunc_Chamfer
BlendFunc_Chamfer_swigregister = _BlendFunc.BlendFunc_Chamfer_swigregister
BlendFunc_Chamfer_swigregister(BlendFunc_Chamfer)

class BlendFunc_(object):
    """
    This package provides a set of generic functions, that can
    instantiated to compute blendings between two surfaces
    (Constant radius, Evolutive radius, Ruled surface).
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def GetShape(*args):
        """
        GetShape(BlendFunc_SectionShape const SectShape, Standard_Real const MaxAng)

        :type SectShape: OCC.wrapper.BlendFunc.BlendFunc_SectionShape
        :type MaxAng: float
        :type NbPoles: int
        :type NbKnots: int
        :type Degree: int
        :type TypeConv: OCC.wrapper.Convert.Convert_ParameterisationType

        """
        return _BlendFunc.BlendFunc__GetShape(*args)

    GetShape = staticmethod(GetShape)

    def GetMinimalWeights(*args):
        """
        GetMinimalWeights(BlendFunc_SectionShape const SectShape, Convert_ParameterisationType const TConv, Standard_Real const AngleMin, Standard_Real const AngleMax, NCollection_Array1_Standard_Real Weigths)

        :type SectShape: OCC.wrapper.BlendFunc.BlendFunc_SectionShape
        :type TConv: OCC.wrapper.Convert.Convert_ParameterisationType
        :type AngleMin: float
        :type AngleMax: float
        :type Weigths: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        return _BlendFunc.BlendFunc__GetMinimalWeights(*args)

    GetMinimalWeights = staticmethod(GetMinimalWeights)

    def NextShape(*args):
        """
        NextShape(GeomAbs_Shape const S) -> GeomAbs_Shape

        Used  to obtain the next level of continuity.

        :type S: OCC.wrapper.GeomAbs.GeomAbs_Shape
        :rtype: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _BlendFunc.BlendFunc__NextShape(*args)

    NextShape = staticmethod(NextShape)

    def ComputeNormal(*args):
        """
        ComputeNormal(Handle_Adaptor3d_HSurface Surf, gp_Pnt2d p2d, gp_Vec Normal) -> Standard_Boolean

        :type Surf: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface
        :type p2d: OCC.wrapper.gp.gp_Pnt2d
        :type Normal: OCC.wrapper.gp.gp_Vec
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BlendFunc.BlendFunc__ComputeNormal(*args)

    ComputeNormal = staticmethod(ComputeNormal)

    def ComputeDNormal(*args):
        """
        ComputeDNormal(Handle_Adaptor3d_HSurface Surf, gp_Pnt2d p2d, gp_Vec Normal, gp_Vec DNu, gp_Vec DNv) -> Standard_Boolean

        :type Surf: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface
        :type p2d: OCC.wrapper.gp.gp_Pnt2d
        :type Normal: OCC.wrapper.gp.gp_Vec
        :type DNu: OCC.wrapper.gp.gp_Vec
        :type DNv: OCC.wrapper.gp.gp_Vec
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BlendFunc.BlendFunc__ComputeDNormal(*args)

    ComputeDNormal = staticmethod(ComputeDNormal)

    def __init__(self):
        """
        This package provides a set of generic functions, that can
        instantiated to compute blendings between two surfaces
        (Constant radius, Evolutive radius, Ruled surface).
        """
        this = _BlendFunc.new_BlendFunc_()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _BlendFunc.delete_BlendFunc_
BlendFunc__swigregister = _BlendFunc.BlendFunc__swigregister
BlendFunc__swigregister(BlendFunc_)

def BlendFunc__GetShape(*args):
    """
    BlendFunc__GetShape(BlendFunc_SectionShape const SectShape, Standard_Real const MaxAng)

    :type SectShape: OCC.wrapper.BlendFunc.BlendFunc_SectionShape
    :type MaxAng: float
    :type NbPoles: int
    :type NbKnots: int
    :type Degree: int
    :type TypeConv: OCC.wrapper.Convert.Convert_ParameterisationType

    """
    return _BlendFunc.BlendFunc__GetShape(*args)

def BlendFunc__GetMinimalWeights(*args):
    """
    BlendFunc__GetMinimalWeights(BlendFunc_SectionShape const SectShape, Convert_ParameterisationType const TConv, Standard_Real const AngleMin, Standard_Real const AngleMax, NCollection_Array1_Standard_Real Weigths)

    :type SectShape: OCC.wrapper.BlendFunc.BlendFunc_SectionShape
    :type TConv: OCC.wrapper.Convert.Convert_ParameterisationType
    :type AngleMin: float
    :type AngleMax: float
    :type Weigths: OCC.wrapper.TColStd.TColStd_Array1OfReal

    """
    return _BlendFunc.BlendFunc__GetMinimalWeights(*args)

def BlendFunc__NextShape(*args):
    """
    BlendFunc__NextShape(GeomAbs_Shape const S) -> GeomAbs_Shape

    Used  to obtain the next level of continuity.

    :type S: OCC.wrapper.GeomAbs.GeomAbs_Shape
    :rtype: OCC.wrapper.GeomAbs.GeomAbs_Shape

    """
    return _BlendFunc.BlendFunc__NextShape(*args)

def BlendFunc__ComputeNormal(*args):
    """
    BlendFunc__ComputeNormal(Handle_Adaptor3d_HSurface Surf, gp_Pnt2d p2d, gp_Vec Normal) -> Standard_Boolean

    :type Surf: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface
    :type p2d: OCC.wrapper.gp.gp_Pnt2d
    :type Normal: OCC.wrapper.gp.gp_Vec
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _BlendFunc.BlendFunc__ComputeNormal(*args)

def BlendFunc__ComputeDNormal(*args):
    """
    BlendFunc__ComputeDNormal(Handle_Adaptor3d_HSurface Surf, gp_Pnt2d p2d, gp_Vec Normal, gp_Vec DNu, gp_Vec DNv) -> Standard_Boolean

    :type Surf: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface
    :type p2d: OCC.wrapper.gp.gp_Pnt2d
    :type Normal: OCC.wrapper.gp.gp_Vec
    :type DNu: OCC.wrapper.gp.gp_Vec
    :type DNv: OCC.wrapper.gp.gp_Vec
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _BlendFunc.BlendFunc__ComputeDNormal(*args)

class BlendFunc_ChAsym(Blend.Blend_Function):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BlendFunc_ChAsym self, Handle_Adaptor3d_HSurface S1, Handle_Adaptor3d_HSurface S2, Handle_Adaptor3d_HCurve C) -> BlendFunc_ChAsym

        :type S1: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface
        :type S2: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface
        :type C: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HCurve

        """
        this = _BlendFunc.new_BlendFunc_ChAsym(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def NbEquations(self, *args):
        """
        NbEquations(BlendFunc_ChAsym self) -> Standard_Integer

        returns the number of equations of the function.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BlendFunc.BlendFunc_ChAsym_NbEquations(self, *args)


    def GetBounds(self, *args):
        """
        GetBounds(BlendFunc_ChAsym self, math_Vector InfBound, math_Vector SupBound)

        :type InfBound: OCC.wrapper.math.math_Vector
        :type SupBound: OCC.wrapper.math.math_Vector

        """
        return _BlendFunc.BlendFunc_ChAsym_GetBounds(self, *args)


    def IsSolution(self, *args):
        """
        IsSolution(BlendFunc_ChAsym self, math_Vector Sol, Standard_Real const Tol) -> Standard_Boolean

        :type Sol: OCC.wrapper.math.math_Vector
        :type Tol: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BlendFunc.BlendFunc_ChAsym_IsSolution(self, *args)


    def GetMinimalDistance(self, *args):
        """
        GetMinimalDistance(BlendFunc_ChAsym self) -> Standard_Real

        Returns   the    minimal  Distance  beetween   two
        extremitys of calculed sections.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _BlendFunc.BlendFunc_ChAsym_GetMinimalDistance(self, *args)


    def ComputeValues(self, *args):
        """
        ComputeValues(BlendFunc_ChAsym self, math_Vector X, Standard_Integer const DegF, Standard_Integer const DegL) -> Standard_Boolean

        computes the values <F> of the derivatives for the
        variable <X> between DegF and DegL.
        Returns True if the computation was done successfully,
        False otherwise.

        :type X: OCC.wrapper.math.math_Vector
        :type DegF: int
        :type DegL: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BlendFunc.BlendFunc_ChAsym_ComputeValues(self, *args)


    def Value(self, *args):
        """
        Value(BlendFunc_ChAsym self, math_Vector X, math_Vector F) -> Standard_Boolean

        computes the values <F> of the Functions for the
        variable <X>.
        Returns True if the computation was done successfully,
        False otherwise.

        :type X: OCC.wrapper.math.math_Vector
        :type F: OCC.wrapper.math.math_Vector
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BlendFunc.BlendFunc_ChAsym_Value(self, *args)


    def Derivatives(self, *args):
        """
        Derivatives(BlendFunc_ChAsym self, math_Vector X, math_Matrix D) -> Standard_Boolean

        returns the values <D> of the derivatives for the
        variable <X>.
        Returns True if the computation was done successfully,
        False otherwise.

        :type X: OCC.wrapper.math.math_Vector
        :type D: OCC.wrapper.math.math_Matrix
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BlendFunc.BlendFunc_ChAsym_Derivatives(self, *args)


    def Values(self, *args):
        """
        Values(BlendFunc_ChAsym self, math_Vector X, math_Vector F, math_Matrix D) -> Standard_Boolean

        returns the values <F> of the functions and the derivatives
        <D> for the variable <X>.
        Returns True if the computation was done successfully,
        False otherwise.

        :type X: OCC.wrapper.math.math_Vector
        :type F: OCC.wrapper.math.math_Vector
        :type D: OCC.wrapper.math.math_Matrix
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BlendFunc.BlendFunc_ChAsym_Values(self, *args)


    def PointOnS1(self, *args):
        """
        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        res = _BlendFunc.BlendFunc_ChAsym_PointOnS1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def PointOnS2(self, *args):
        """
        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        res = _BlendFunc.BlendFunc_ChAsym_PointOnS2(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def IsTangencyPoint(self, *args):
        """
        IsTangencyPoint(BlendFunc_ChAsym self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BlendFunc.BlendFunc_ChAsym_IsTangencyPoint(self, *args)


    def TangentOnS1(self, *args):
        """
        :rtype: OCC.wrapper.gp.gp_Vec

        """
        res = _BlendFunc.BlendFunc_ChAsym_TangentOnS1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Tangent2dOnS1(self, *args):
        """
        :rtype: OCC.wrapper.gp.gp_Vec2d

        """
        res = _BlendFunc.BlendFunc_ChAsym_Tangent2dOnS1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def TangentOnS2(self, *args):
        """
        :rtype: OCC.wrapper.gp.gp_Vec

        """
        res = _BlendFunc.BlendFunc_ChAsym_TangentOnS2(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Tangent2dOnS2(self, *args):
        """
        :rtype: OCC.wrapper.gp.gp_Vec2d

        """
        res = _BlendFunc.BlendFunc_ChAsym_Tangent2dOnS2(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def TwistOnS1(self, *args):
        """
        TwistOnS1(BlendFunc_ChAsym self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BlendFunc.BlendFunc_ChAsym_TwistOnS1(self, *args)


    def TwistOnS2(self, *args):
        """
        TwistOnS2(BlendFunc_ChAsym self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BlendFunc.BlendFunc_ChAsym_TwistOnS2(self, *args)


    def Tangent(self, *args):
        """
        Tangent(BlendFunc_ChAsym self, Standard_Real const U1, Standard_Real const V1, Standard_Real const U2, Standard_Real const V2, gp_Vec TgFirst, gp_Vec TgLast, gp_Vec NormFirst, gp_Vec NormLast)

        Returns the tangent vector at the section,
        at the beginning and the end of the section, and
        returns the normal (of the surfaces) at
        these points.

        :type U1: float
        :type V1: float
        :type U2: float
        :type V2: float
        :type TgFirst: OCC.wrapper.gp.gp_Vec
        :type TgLast: OCC.wrapper.gp.gp_Vec
        :type NormFirst: OCC.wrapper.gp.gp_Vec
        :type NormLast: OCC.wrapper.gp.gp_Vec

        """
        return _BlendFunc.BlendFunc_ChAsym_Tangent(self, *args)


    def IsRational(self, *args):
        """
        IsRational(BlendFunc_ChAsym self) -> Standard_Boolean

        Returns  if the section is rationnal

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BlendFunc.BlendFunc_ChAsym_IsRational(self, *args)


    def GetSectionSize(self, *args):
        """
        GetSectionSize(BlendFunc_ChAsym self) -> Standard_Real

        Returns the length of the maximum section

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _BlendFunc.BlendFunc_ChAsym_GetSectionSize(self, *args)


    def GetMinimalWeight(self, *args):
        """
        GetMinimalWeight(BlendFunc_ChAsym self, NCollection_Array1_Standard_Real Weigths)

        Compute the minimal value of weight for each poles
        of all sections.

        :type Weigths: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        return _BlendFunc.BlendFunc_ChAsym_GetMinimalWeight(self, *args)


    def NbIntervals(self, *args):
        """
        NbIntervals(BlendFunc_ChAsym self, GeomAbs_Shape const S) -> Standard_Integer

        Returns  the number  of  intervals for  continuity
        <S>. May be one if Continuity(me) >= <S>

        :type S: OCC.wrapper.GeomAbs.GeomAbs_Shape
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BlendFunc.BlendFunc_ChAsym_NbIntervals(self, *args)


    def Intervals(self, *args):
        """
        Intervals(BlendFunc_ChAsym self, NCollection_Array1_Standard_Real T, GeomAbs_Shape const S)

        Stores in <T> the  parameters bounding the intervals
        of continuity <S>.

        The array must provide  enough room to  accomodate
        for the parameters. i.e. T.Length() > NbIntervals()

        :type T: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type S: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _BlendFunc.BlendFunc_ChAsym_Intervals(self, *args)


    def GetShape(self, *args):
        """
        GetShape(BlendFunc_ChAsym self)

        :type NbPoles: int
        :type NbKnots: int
        :type Degree: int
        :type NbPoles2d: int

        """
        return _BlendFunc.BlendFunc_ChAsym_GetShape(self, *args)


    def GetTolerance(self, *args):
        """
        GetTolerance(BlendFunc_ChAsym self, math_Vector Tolerance, Standard_Real const Tol)
        GetTolerance(BlendFunc_ChAsym self, Standard_Real const BoundTol, Standard_Real const SurfTol, Standard_Real const AngleTol, math_Vector Tol3d, math_Vector Tol1D)

        Returns the tolerance to reach in approximation
        to respecte
        BoundTol error at the Boundary
        AngleTol tangent error at the Boundary
        SurfTol error inside the surface.

        :type BoundTol: float
        :type SurfTol: float
        :type AngleTol: float
        :type Tol3d: OCC.wrapper.math.math_Vector
        :type Tol1D: OCC.wrapper.math.math_Vector

        """
        return _BlendFunc.BlendFunc_ChAsym_GetTolerance(self, *args)


    def Knots(self, *args):
        """
        Knots(BlendFunc_ChAsym self, NCollection_Array1_Standard_Real TKnots)

        :type TKnots: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        return _BlendFunc.BlendFunc_ChAsym_Knots(self, *args)


    def Mults(self, *args):
        """
        Mults(BlendFunc_ChAsym self, NCollection_Array1_Standard_Integer TMults)

        :type TMults: OCC.wrapper.TColStd.TColStd_Array1OfInteger

        """
        return _BlendFunc.BlendFunc_ChAsym_Mults(self, *args)


    def Section(self, *args):
        """
        Section(BlendFunc_ChAsym self, Standard_Real const Param, Standard_Real const U1, Standard_Real const V1, Standard_Real const U2, Standard_Real const V2, gp_Lin C)
        Section(BlendFunc_ChAsym self, Blend_Point P, NCollection_Array1_gp_Pnt Poles, NCollection_Array1_gp_Pnt2d Poles2d, NCollection_Array1_Standard_Real Weigths)
        Section(BlendFunc_ChAsym self, Blend_Point P, NCollection_Array1_gp_Pnt Poles, NCollection_Array1_gp_Vec DPoles, NCollection_Array1_gp_Pnt2d Poles2d, NCollection_Array1_gp_Vec2d DPoles2d, NCollection_Array1_Standard_Real Weigths, NCollection_Array1_Standard_Real DWeigths) -> Standard_Boolean
        Section(BlendFunc_ChAsym self, Blend_Point P, NCollection_Array1_gp_Pnt Poles, NCollection_Array1_gp_Vec DPoles, NCollection_Array1_gp_Vec D2Poles, NCollection_Array1_gp_Pnt2d Poles2d, NCollection_Array1_gp_Vec2d DPoles2d, NCollection_Array1_gp_Vec2d D2Poles2d, NCollection_Array1_Standard_Real Weigths, NCollection_Array1_Standard_Real DWeigths, NCollection_Array1_Standard_Real D2Weigths) -> Standard_Boolean

        Used for the first and last section

        :type P: OCC.wrapper.Blend.Blend_Point
        :type Poles: OCC.wrapper.TColgp.TColgp_Array1OfPnt
        :type DPoles: OCC.wrapper.TColgp.TColgp_Array1OfVec
        :type D2Poles: OCC.wrapper.TColgp.TColgp_Array1OfVec
        :type Poles2d: OCC.wrapper.TColgp.TColgp_Array1OfPnt2d
        :type DPoles2d: OCC.wrapper.TColgp.TColgp_Array1OfVec2d
        :type D2Poles2d: OCC.wrapper.TColgp.TColgp_Array1OfVec2d
        :type Weigths: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type DWeigths: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type D2Weigths: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BlendFunc.BlendFunc_ChAsym_Section(self, *args)


    def Resolution(self, *args):
        """
        Resolution(BlendFunc_ChAsym self, Standard_Integer const IC2d, Standard_Real const Tol)

        :type IC2d: int
        :type Tol: float
        :type TolU: float
        :type TolV: float

        """
        return _BlendFunc.BlendFunc_ChAsym_Resolution(self, *args)


    def Set(self, *args):
        """
        Set(BlendFunc_ChAsym self, Standard_Real const Param)
        Set(BlendFunc_ChAsym self, Standard_Real const First, Standard_Real const Last)
        Set(BlendFunc_ChAsym self, Standard_Real const Dist1, Standard_Real const Angle, Standard_Integer const Choix)

        Sets the distances and the angle.

        :type Dist1: float
        :type Angle: float
        :type Choix: int

        """
        return _BlendFunc.BlendFunc_ChAsym_Set(self, *args)

    __swig_destroy__ = _BlendFunc.delete_BlendFunc_ChAsym
BlendFunc_ChAsym_swigregister = _BlendFunc.BlendFunc_ChAsym_swigregister
BlendFunc_ChAsym_swigregister(BlendFunc_ChAsym)

class BlendFunc_ChamfInv(Blend.Blend_FuncInv):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BlendFunc_ChamfInv self, Handle_Adaptor3d_HSurface S1, Handle_Adaptor3d_HSurface S2, Handle_Adaptor3d_HCurve C) -> BlendFunc_ChamfInv

        :type S1: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface
        :type S2: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface
        :type C: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HCurve

        """
        this = _BlendFunc.new_BlendFunc_ChamfInv(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def GetTolerance(self, *args):
        """
        GetTolerance(BlendFunc_ChamfInv self, math_Vector Tolerance, Standard_Real const Tol)

        :type Tolerance: OCC.wrapper.math.math_Vector
        :type Tol: float

        """
        return _BlendFunc.BlendFunc_ChamfInv_GetTolerance(self, *args)


    def GetBounds(self, *args):
        """
        GetBounds(BlendFunc_ChamfInv self, math_Vector InfBound, math_Vector SupBound)

        :type InfBound: OCC.wrapper.math.math_Vector
        :type SupBound: OCC.wrapper.math.math_Vector

        """
        return _BlendFunc.BlendFunc_ChamfInv_GetBounds(self, *args)


    def IsSolution(self, *args):
        """
        IsSolution(BlendFunc_ChamfInv self, math_Vector Sol, Standard_Real const Tol) -> Standard_Boolean

        :type Sol: OCC.wrapper.math.math_Vector
        :type Tol: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BlendFunc.BlendFunc_ChamfInv_IsSolution(self, *args)


    def NbEquations(self, *args):
        """
        NbEquations(BlendFunc_ChamfInv self) -> Standard_Integer

        returns the number of equations of the function.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BlendFunc.BlendFunc_ChamfInv_NbEquations(self, *args)


    def Value(self, *args):
        """
        Value(BlendFunc_ChamfInv self, math_Vector X, math_Vector F) -> Standard_Boolean

        computes the values <F> of the Functions for the
        variable <X>.
        Returns True if the computation was done successfully,
        False otherwise.

        :type X: OCC.wrapper.math.math_Vector
        :type F: OCC.wrapper.math.math_Vector
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BlendFunc.BlendFunc_ChamfInv_Value(self, *args)


    def Derivatives(self, *args):
        """
        Derivatives(BlendFunc_ChamfInv self, math_Vector X, math_Matrix D) -> Standard_Boolean

        returns the values <D> of the derivatives for the
        variable <X>.
        Returns True if the computation was done successfully,
        False otherwise.

        :type X: OCC.wrapper.math.math_Vector
        :type D: OCC.wrapper.math.math_Matrix
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BlendFunc.BlendFunc_ChamfInv_Derivatives(self, *args)


    def Values(self, *args):
        """
        Values(BlendFunc_ChamfInv self, math_Vector X, math_Vector F, math_Matrix D) -> Standard_Boolean

        returns the values <F> of the functions and the derivatives
        <D> for the variable <X>.
        Returns True if the computation was done successfully,
        False otherwise.

        :type X: OCC.wrapper.math.math_Vector
        :type F: OCC.wrapper.math.math_Vector
        :type D: OCC.wrapper.math.math_Matrix
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BlendFunc.BlendFunc_ChamfInv_Values(self, *args)


    def Set(self, *args):
        """
        Set(BlendFunc_ChamfInv self, Standard_Boolean const OnFirst, Handle_Adaptor2d_HCurve2d COnSurf)
        Set(BlendFunc_ChamfInv self, Standard_Real const Dist1, Standard_Real const Dist2, Standard_Integer const Choix)

        :type Dist1: float
        :type Dist2: float
        :type Choix: int

        """
        return _BlendFunc.BlendFunc_ChamfInv_Set(self, *args)

    __swig_destroy__ = _BlendFunc.delete_BlendFunc_ChamfInv
BlendFunc_ChamfInv_swigregister = _BlendFunc.BlendFunc_ChamfInv_swigregister
BlendFunc_ChamfInv_swigregister(BlendFunc_ChamfInv)

class BlendFunc_EvolRad(Blend.Blend_Function):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BlendFunc_EvolRad self, Handle_Adaptor3d_HSurface S1, Handle_Adaptor3d_HSurface S2, Handle_Adaptor3d_HCurve C, Handle_Law_Function Law) -> BlendFunc_EvolRad

        :type S1: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface
        :type S2: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface
        :type C: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HCurve
        :type Law: OCC.wrapper.Law.Handle_Law_Function

        """
        this = _BlendFunc.new_BlendFunc_EvolRad(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def NbEquations(self, *args):
        """
        NbEquations(BlendFunc_EvolRad self) -> Standard_Integer

        returns the number of equations of the function.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BlendFunc.BlendFunc_EvolRad_NbEquations(self, *args)


    def Value(self, *args):
        """
        Value(BlendFunc_EvolRad self, math_Vector X, math_Vector F) -> Standard_Boolean

        computes the values <F> of the Functions for the
        variable <X>.
        Returns True if the computation was done successfully,
        False otherwise.

        :type X: OCC.wrapper.math.math_Vector
        :type F: OCC.wrapper.math.math_Vector
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BlendFunc.BlendFunc_EvolRad_Value(self, *args)


    def Derivatives(self, *args):
        """
        Derivatives(BlendFunc_EvolRad self, math_Vector X, math_Matrix D) -> Standard_Boolean

        returns the values <D> of the derivatives for the
        variable <X>.
        Returns True if the computation was done successfully,
        False otherwise.

        :type X: OCC.wrapper.math.math_Vector
        :type D: OCC.wrapper.math.math_Matrix
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BlendFunc.BlendFunc_EvolRad_Derivatives(self, *args)


    def Values(self, *args):
        """
        Values(BlendFunc_EvolRad self, math_Vector X, math_Vector F, math_Matrix D) -> Standard_Boolean

        returns the values <F> of the functions and the derivatives
        <D> for the variable <X>.
        Returns True if the computation was done successfully,
        False otherwise.

        :type X: OCC.wrapper.math.math_Vector
        :type F: OCC.wrapper.math.math_Vector
        :type D: OCC.wrapper.math.math_Matrix
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BlendFunc.BlendFunc_EvolRad_Values(self, *args)


    def GetBounds(self, *args):
        """
        GetBounds(BlendFunc_EvolRad self, math_Vector InfBound, math_Vector SupBound)

        :type InfBound: OCC.wrapper.math.math_Vector
        :type SupBound: OCC.wrapper.math.math_Vector

        """
        return _BlendFunc.BlendFunc_EvolRad_GetBounds(self, *args)


    def IsSolution(self, *args):
        """
        IsSolution(BlendFunc_EvolRad self, math_Vector Sol, Standard_Real const Tol) -> Standard_Boolean

        :type Sol: OCC.wrapper.math.math_Vector
        :type Tol: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BlendFunc.BlendFunc_EvolRad_IsSolution(self, *args)


    def GetMinimalDistance(self, *args):
        """
        GetMinimalDistance(BlendFunc_EvolRad self) -> Standard_Real

        Returns   the    minimal  Distance  beetween   two
        extremitys of calculed sections.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _BlendFunc.BlendFunc_EvolRad_GetMinimalDistance(self, *args)


    def PointOnS1(self, *args):
        """
        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        res = _BlendFunc.BlendFunc_EvolRad_PointOnS1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def PointOnS2(self, *args):
        """
        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        res = _BlendFunc.BlendFunc_EvolRad_PointOnS2(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def IsTangencyPoint(self, *args):
        """
        IsTangencyPoint(BlendFunc_EvolRad self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BlendFunc.BlendFunc_EvolRad_IsTangencyPoint(self, *args)


    def TangentOnS1(self, *args):
        """
        :rtype: OCC.wrapper.gp.gp_Vec

        """
        res = _BlendFunc.BlendFunc_EvolRad_TangentOnS1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Tangent2dOnS1(self, *args):
        """
        :rtype: OCC.wrapper.gp.gp_Vec2d

        """
        res = _BlendFunc.BlendFunc_EvolRad_Tangent2dOnS1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def TangentOnS2(self, *args):
        """
        :rtype: OCC.wrapper.gp.gp_Vec

        """
        res = _BlendFunc.BlendFunc_EvolRad_TangentOnS2(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Tangent2dOnS2(self, *args):
        """
        :rtype: OCC.wrapper.gp.gp_Vec2d

        """
        res = _BlendFunc.BlendFunc_EvolRad_Tangent2dOnS2(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Tangent(self, *args):
        """
        Tangent(BlendFunc_EvolRad self, Standard_Real const U1, Standard_Real const V1, Standard_Real const U2, Standard_Real const V2, gp_Vec TgFirst, gp_Vec TgLast, gp_Vec NormFirst, gp_Vec NormLast)

        Returns the tangent vector at the section,
        at the beginning and the end of the section, and
        returns the normal (of the surfaces) at
        these points.

        :type U1: float
        :type V1: float
        :type U2: float
        :type V2: float
        :type TgFirst: OCC.wrapper.gp.gp_Vec
        :type TgLast: OCC.wrapper.gp.gp_Vec
        :type NormFirst: OCC.wrapper.gp.gp_Vec
        :type NormLast: OCC.wrapper.gp.gp_Vec

        """
        return _BlendFunc.BlendFunc_EvolRad_Tangent(self, *args)


    def TwistOnS1(self, *args):
        """
        TwistOnS1(BlendFunc_EvolRad self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BlendFunc.BlendFunc_EvolRad_TwistOnS1(self, *args)


    def TwistOnS2(self, *args):
        """
        TwistOnS2(BlendFunc_EvolRad self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BlendFunc.BlendFunc_EvolRad_TwistOnS2(self, *args)


    def Set(self, *args):
        """
        Set(BlendFunc_EvolRad self, Standard_Real const Param)
        Set(BlendFunc_EvolRad self, Standard_Real const First, Standard_Real const Last)
        Set(BlendFunc_EvolRad self, Standard_Integer const Choix)
        Set(BlendFunc_EvolRad self, BlendFunc_SectionShape const TypeSection)

        Sets  the  type  of   section generation   for the
        approximations.

        :type TypeSection: OCC.wrapper.BlendFunc.BlendFunc_SectionShape

        """
        return _BlendFunc.BlendFunc_EvolRad_Set(self, *args)


    def IsRational(self, *args):
        """
        IsRational(BlendFunc_EvolRad self) -> Standard_Boolean

        Returns  if the section is rationnal

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BlendFunc.BlendFunc_EvolRad_IsRational(self, *args)


    def GetSectionSize(self, *args):
        """
        GetSectionSize(BlendFunc_EvolRad self) -> Standard_Real

        Returns the length of the maximum section

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _BlendFunc.BlendFunc_EvolRad_GetSectionSize(self, *args)


    def GetMinimalWeight(self, *args):
        """
        GetMinimalWeight(BlendFunc_EvolRad self, NCollection_Array1_Standard_Real Weigths)

        Compute the minimal value of weight for each poles
        of all sections.

        :type Weigths: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        return _BlendFunc.BlendFunc_EvolRad_GetMinimalWeight(self, *args)


    def NbIntervals(self, *args):
        """
        NbIntervals(BlendFunc_EvolRad self, GeomAbs_Shape const S) -> Standard_Integer

        Returns  the number  of  intervals for  continuity
        <S>. May be one if Continuity(me) >= <S>

        :type S: OCC.wrapper.GeomAbs.GeomAbs_Shape
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BlendFunc.BlendFunc_EvolRad_NbIntervals(self, *args)


    def Intervals(self, *args):
        """
        Intervals(BlendFunc_EvolRad self, NCollection_Array1_Standard_Real T, GeomAbs_Shape const S)

        Stores in <T> the  parameters bounding the intervals
        of continuity <S>.

        The array must provide  enough room to  accomodate
        for the parameters. i.e. T.Length() > NbIntervals()

        :type T: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type S: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _BlendFunc.BlendFunc_EvolRad_Intervals(self, *args)


    def GetShape(self, *args):
        """
        GetShape(BlendFunc_EvolRad self)

        :type NbPoles: int
        :type NbKnots: int
        :type Degree: int
        :type NbPoles2d: int

        """
        return _BlendFunc.BlendFunc_EvolRad_GetShape(self, *args)


    def GetTolerance(self, *args):
        """
        GetTolerance(BlendFunc_EvolRad self, math_Vector Tolerance, Standard_Real const Tol)
        GetTolerance(BlendFunc_EvolRad self, Standard_Real const BoundTol, Standard_Real const SurfTol, Standard_Real const AngleTol, math_Vector Tol3d, math_Vector Tol1D)

        Returns the tolerance to reach in approximation
        to respecte
        BoundTol error at the Boundary
        AngleTol tangent error at the Boundary
        SurfTol error inside the surface.

        :type BoundTol: float
        :type SurfTol: float
        :type AngleTol: float
        :type Tol3d: OCC.wrapper.math.math_Vector
        :type Tol1D: OCC.wrapper.math.math_Vector

        """
        return _BlendFunc.BlendFunc_EvolRad_GetTolerance(self, *args)


    def Knots(self, *args):
        """
        Knots(BlendFunc_EvolRad self, NCollection_Array1_Standard_Real TKnots)

        :type TKnots: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        return _BlendFunc.BlendFunc_EvolRad_Knots(self, *args)


    def Mults(self, *args):
        """
        Mults(BlendFunc_EvolRad self, NCollection_Array1_Standard_Integer TMults)

        :type TMults: OCC.wrapper.TColStd.TColStd_Array1OfInteger

        """
        return _BlendFunc.BlendFunc_EvolRad_Mults(self, *args)


    def Section(self, *args):
        """
        Section(BlendFunc_EvolRad self, Standard_Real const Param, Standard_Real const U1, Standard_Real const V1, Standard_Real const U2, Standard_Real const V2, gp_Circ C)
        Section(BlendFunc_EvolRad self, Blend_Point P, NCollection_Array1_gp_Pnt Poles, NCollection_Array1_gp_Vec DPoles, NCollection_Array1_gp_Vec D2Poles, NCollection_Array1_gp_Pnt2d Poles2d, NCollection_Array1_gp_Vec2d DPoles2d, NCollection_Array1_gp_Vec2d D2Poles2d, NCollection_Array1_Standard_Real Weigths, NCollection_Array1_Standard_Real DWeigths, NCollection_Array1_Standard_Real D2Weigths) -> Standard_Boolean
        Section(BlendFunc_EvolRad self, Blend_Point P, NCollection_Array1_gp_Pnt Poles, NCollection_Array1_gp_Vec DPoles, NCollection_Array1_gp_Pnt2d Poles2d, NCollection_Array1_gp_Vec2d DPoles2d, NCollection_Array1_Standard_Real Weigths, NCollection_Array1_Standard_Real DWeigths) -> Standard_Boolean
        Section(BlendFunc_EvolRad self, Blend_Point P, NCollection_Array1_gp_Pnt Poles, NCollection_Array1_gp_Pnt2d Poles2d, NCollection_Array1_Standard_Real Weigths)

        :type P: OCC.wrapper.Blend.Blend_Point
        :type Poles: OCC.wrapper.TColgp.TColgp_Array1OfPnt
        :type Poles2d: OCC.wrapper.TColgp.TColgp_Array1OfPnt2d
        :type Weigths: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        return _BlendFunc.BlendFunc_EvolRad_Section(self, *args)


    def Resolution(self, *args):
        """
        Resolution(BlendFunc_EvolRad self, Standard_Integer const IC2d, Standard_Real const Tol)

        :type IC2d: int
        :type Tol: float
        :type TolU: float
        :type TolV: float

        """
        return _BlendFunc.BlendFunc_EvolRad_Resolution(self, *args)

    __swig_destroy__ = _BlendFunc.delete_BlendFunc_EvolRad
BlendFunc_EvolRad_swigregister = _BlendFunc.BlendFunc_EvolRad_swigregister
BlendFunc_EvolRad_swigregister(BlendFunc_EvolRad)

class BlendFunc_CSConstRad(Blend.Blend_CSFunction):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BlendFunc_CSConstRad self, Handle_Adaptor3d_HSurface S, Handle_Adaptor3d_HCurve C, Handle_Adaptor3d_HCurve CGuide) -> BlendFunc_CSConstRad

        :type S: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface
        :type C: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HCurve
        :type CGuide: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HCurve

        """
        this = _BlendFunc.new_BlendFunc_CSConstRad(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def NbEquations(self, *args):
        """
        NbEquations(BlendFunc_CSConstRad self) -> Standard_Integer

        returns the number of equations of the function (3).

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BlendFunc.BlendFunc_CSConstRad_NbEquations(self, *args)


    def Value(self, *args):
        """
        Value(BlendFunc_CSConstRad self, math_Vector X, math_Vector F) -> Standard_Boolean

        computes the values <F> of the Functions for the
        variable <X>.
        Returns True if the computation was done successfully,
        False otherwise.

        :type X: OCC.wrapper.math.math_Vector
        :type F: OCC.wrapper.math.math_Vector
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BlendFunc.BlendFunc_CSConstRad_Value(self, *args)


    def Derivatives(self, *args):
        """
        Derivatives(BlendFunc_CSConstRad self, math_Vector X, math_Matrix D) -> Standard_Boolean

        returns the values <D> of the derivatives for the
        variable <X>.
        Returns True if the computation was done successfully,
        False otherwise.

        :type X: OCC.wrapper.math.math_Vector
        :type D: OCC.wrapper.math.math_Matrix
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BlendFunc.BlendFunc_CSConstRad_Derivatives(self, *args)


    def Values(self, *args):
        """
        Values(BlendFunc_CSConstRad self, math_Vector X, math_Vector F, math_Matrix D) -> Standard_Boolean

        returns the values <F> of the functions and the derivatives
        <D> for the variable <X>.
        Returns True if the computation was done successfully,
        False otherwise.

        :type X: OCC.wrapper.math.math_Vector
        :type F: OCC.wrapper.math.math_Vector
        :type D: OCC.wrapper.math.math_Matrix
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BlendFunc.BlendFunc_CSConstRad_Values(self, *args)


    def GetBounds(self, *args):
        """
        GetBounds(BlendFunc_CSConstRad self, math_Vector InfBound, math_Vector SupBound)

        :type InfBound: OCC.wrapper.math.math_Vector
        :type SupBound: OCC.wrapper.math.math_Vector

        """
        return _BlendFunc.BlendFunc_CSConstRad_GetBounds(self, *args)


    def IsSolution(self, *args):
        """
        IsSolution(BlendFunc_CSConstRad self, math_Vector Sol, Standard_Real const Tol) -> Standard_Boolean

        :type Sol: OCC.wrapper.math.math_Vector
        :type Tol: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BlendFunc.BlendFunc_CSConstRad_IsSolution(self, *args)


    def PointOnS(self, *args):
        """
        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        res = _BlendFunc.BlendFunc_CSConstRad_PointOnS(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def PointOnC(self, *args):
        """
        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        res = _BlendFunc.BlendFunc_CSConstRad_PointOnC(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Pnt2d(self, *args):
        """
        Returns U,V coordinates of the point on the surface.

        :rtype: OCC.wrapper.gp.gp_Pnt2d

        """
        res = _BlendFunc.BlendFunc_CSConstRad_Pnt2d(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ParameterOnC(self, *args):
        """
        ParameterOnC(BlendFunc_CSConstRad self) -> Standard_Real

        Returns parameter of the point on the curve.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _BlendFunc.BlendFunc_CSConstRad_ParameterOnC(self, *args)


    def IsTangencyPoint(self, *args):
        """
        IsTangencyPoint(BlendFunc_CSConstRad self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BlendFunc.BlendFunc_CSConstRad_IsTangencyPoint(self, *args)


    def TangentOnS(self, *args):
        """
        :rtype: OCC.wrapper.gp.gp_Vec

        """
        res = _BlendFunc.BlendFunc_CSConstRad_TangentOnS(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Tangent2d(self, *args):
        """
        :rtype: OCC.wrapper.gp.gp_Vec2d

        """
        res = _BlendFunc.BlendFunc_CSConstRad_Tangent2d(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def TangentOnC(self, *args):
        """
        :rtype: OCC.wrapper.gp.gp_Vec

        """
        res = _BlendFunc.BlendFunc_CSConstRad_TangentOnC(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Tangent(self, *args):
        """
        Tangent(BlendFunc_CSConstRad self, Standard_Real const U, Standard_Real const V, gp_Vec TgS, gp_Vec NormS)

        Returns the tangent vector at the section,
        at the beginning and the end of the section, and
        returns the normal (of the surface) at
        these points.

        :type U: float
        :type V: float
        :type TgS: OCC.wrapper.gp.gp_Vec
        :type NormS: OCC.wrapper.gp.gp_Vec

        """
        return _BlendFunc.BlendFunc_CSConstRad_Tangent(self, *args)


    def Set(self, *args):
        """
        Set(BlendFunc_CSConstRad self, Standard_Real const Param)
        Set(BlendFunc_CSConstRad self, Standard_Real const First, Standard_Real const Last)
        Set(BlendFunc_CSConstRad self, Standard_Real const Radius, Standard_Integer const Choix)
        Set(BlendFunc_CSConstRad self, BlendFunc_SectionShape const TypeSection)

        Sets  the  type  of   section generation   for the
        approximations.

        :type TypeSection: OCC.wrapper.BlendFunc.BlendFunc_SectionShape

        """
        return _BlendFunc.BlendFunc_CSConstRad_Set(self, *args)


    def GetSection(self, *args):
        """
        GetSection(BlendFunc_CSConstRad self, Standard_Real const Param, Standard_Real const U, Standard_Real const V, Standard_Real const W, NCollection_Array1_gp_Pnt tabP, NCollection_Array1_gp_Vec tabV) -> Standard_Boolean

        :type Param: float
        :type U: float
        :type V: float
        :type W: float
        :type tabP: OCC.wrapper.TColgp.TColgp_Array1OfPnt
        :type tabV: OCC.wrapper.TColgp.TColgp_Array1OfVec
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BlendFunc.BlendFunc_CSConstRad_GetSection(self, *args)


    def IsRational(self, *args):
        """
        IsRational(BlendFunc_CSConstRad self) -> Standard_Boolean

        Returns  if the section is rationnal

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BlendFunc.BlendFunc_CSConstRad_IsRational(self, *args)


    def GetSectionSize(self, *args):
        """
        GetSectionSize(BlendFunc_CSConstRad self) -> Standard_Real

        Returns the length of the maximum section

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _BlendFunc.BlendFunc_CSConstRad_GetSectionSize(self, *args)


    def GetMinimalWeight(self, *args):
        """
        GetMinimalWeight(BlendFunc_CSConstRad self, NCollection_Array1_Standard_Real Weigths)

        Compute the minimal value of weight for each poles
        of all sections.

        :type Weigths: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        return _BlendFunc.BlendFunc_CSConstRad_GetMinimalWeight(self, *args)


    def NbIntervals(self, *args):
        """
        NbIntervals(BlendFunc_CSConstRad self, GeomAbs_Shape const S) -> Standard_Integer

        Returns  the number  of  intervals for  continuity
        <S>. May be one if Continuity(me) >= <S>

        :type S: OCC.wrapper.GeomAbs.GeomAbs_Shape
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BlendFunc.BlendFunc_CSConstRad_NbIntervals(self, *args)


    def Intervals(self, *args):
        """
        Intervals(BlendFunc_CSConstRad self, NCollection_Array1_Standard_Real T, GeomAbs_Shape const S)

        Stores in <T> the  parameters bounding the intervals
        of continuity <S>.
        The array must provide  enough room to  accomodate
        for the parameters. i.e. T.Length() > NbIntervals()
        raises
        OutOfRange from Standard

        :type T: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type S: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _BlendFunc.BlendFunc_CSConstRad_Intervals(self, *args)


    def GetShape(self, *args):
        """
        GetShape(BlendFunc_CSConstRad self)

        :type NbPoles: int
        :type NbKnots: int
        :type Degree: int
        :type NbPoles2d: int

        """
        return _BlendFunc.BlendFunc_CSConstRad_GetShape(self, *args)


    def GetTolerance(self, *args):
        """
        GetTolerance(BlendFunc_CSConstRad self, math_Vector Tolerance, Standard_Real const Tol)
        GetTolerance(BlendFunc_CSConstRad self, Standard_Real const BoundTol, Standard_Real const SurfTol, Standard_Real const AngleTol, math_Vector Tol3d, math_Vector Tol1D)

        Returns the tolerance to reach in approximation
        to respecte
        BoundTol error at the Boundary
        AngleTol tangent error at the Boundary
        SurfTol error inside the surface.

        :type BoundTol: float
        :type SurfTol: float
        :type AngleTol: float
        :type Tol3d: OCC.wrapper.math.math_Vector
        :type Tol1D: OCC.wrapper.math.math_Vector

        """
        return _BlendFunc.BlendFunc_CSConstRad_GetTolerance(self, *args)


    def Knots(self, *args):
        """
        Knots(BlendFunc_CSConstRad self, NCollection_Array1_Standard_Real TKnots)

        :type TKnots: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        return _BlendFunc.BlendFunc_CSConstRad_Knots(self, *args)


    def Mults(self, *args):
        """
        Mults(BlendFunc_CSConstRad self, NCollection_Array1_Standard_Integer TMults)

        :type TMults: OCC.wrapper.TColStd.TColStd_Array1OfInteger

        """
        return _BlendFunc.BlendFunc_CSConstRad_Mults(self, *args)


    def Section(self, *args):
        """
        Section(BlendFunc_CSConstRad self, Standard_Real const Param, Standard_Real const U, Standard_Real const V, Standard_Real const W, gp_Circ C)
        Section(BlendFunc_CSConstRad self, Blend_Point P, NCollection_Array1_gp_Pnt Poles, NCollection_Array1_gp_Vec DPoles, NCollection_Array1_gp_Vec D2Poles, NCollection_Array1_gp_Pnt2d Poles2d, NCollection_Array1_gp_Vec2d DPoles2d, NCollection_Array1_gp_Vec2d D2Poles2d, NCollection_Array1_Standard_Real Weigths, NCollection_Array1_Standard_Real DWeigths, NCollection_Array1_Standard_Real D2Weigths) -> Standard_Boolean
        Section(BlendFunc_CSConstRad self, Blend_Point P, NCollection_Array1_gp_Pnt Poles, NCollection_Array1_gp_Vec DPoles, NCollection_Array1_gp_Pnt2d Poles2d, NCollection_Array1_gp_Vec2d DPoles2d, NCollection_Array1_Standard_Real Weigths, NCollection_Array1_Standard_Real DWeigths) -> Standard_Boolean
        Section(BlendFunc_CSConstRad self, Blend_Point P, NCollection_Array1_gp_Pnt Poles, NCollection_Array1_gp_Pnt2d Poles2d, NCollection_Array1_Standard_Real Weigths)

        :type P: OCC.wrapper.Blend.Blend_Point
        :type Poles: OCC.wrapper.TColgp.TColgp_Array1OfPnt
        :type Poles2d: OCC.wrapper.TColgp.TColgp_Array1OfPnt2d
        :type Weigths: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        return _BlendFunc.BlendFunc_CSConstRad_Section(self, *args)


    def Resolution(self, *args):
        """
        Resolution(BlendFunc_CSConstRad self, Standard_Integer const IC2d, Standard_Real const Tol)

        :type IC2d: int
        :type Tol: float
        :type TolU: float
        :type TolV: float

        """
        return _BlendFunc.BlendFunc_CSConstRad_Resolution(self, *args)

    __swig_destroy__ = _BlendFunc.delete_BlendFunc_CSConstRad
BlendFunc_CSConstRad_swigregister = _BlendFunc.BlendFunc_CSConstRad_swigregister
BlendFunc_CSConstRad_swigregister(BlendFunc_CSConstRad)

class BlendFunc_CSCircular(Blend.Blend_CSFunction):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BlendFunc_CSCircular self, Handle_Adaptor3d_HSurface S, Handle_Adaptor3d_HCurve C, Handle_Adaptor3d_HCurve CGuide, Handle_Law_Function L) -> BlendFunc_CSCircular

        Creates a function for a circular blending between
        a curve  <C> and a surface  <S>.  The direction of
        the planes are given by <CGuide>.  The position of
        the plane is  determined on  the  curve <C>.   <L>
        defines  the change of  parameter between  <C> and
        <CGuide>.  So, the planes are defined as described
        below :
        t is the current parameter on the guide line.
        Pguide = C(L(t)); Nguide = CGuide'(t)/||CGuide'(t)||

        :type S: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface
        :type C: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HCurve
        :type CGuide: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HCurve
        :type L: OCC.wrapper.Law.Handle_Law_Function

        """
        this = _BlendFunc.new_BlendFunc_CSCircular(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def NbVariables(self, *args):
        """
        NbVariables(BlendFunc_CSCircular self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BlendFunc.BlendFunc_CSCircular_NbVariables(self, *args)


    def NbEquations(self, *args):
        """
        NbEquations(BlendFunc_CSCircular self) -> Standard_Integer

        returns the number of equations of the function (3).

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BlendFunc.BlendFunc_CSCircular_NbEquations(self, *args)


    def Value(self, *args):
        """
        Value(BlendFunc_CSCircular self, math_Vector X, math_Vector F) -> Standard_Boolean

        computes the values <F> of the Functions for the
        variable <X>.
        Returns True if the computation was done successfully,
        False otherwise.

        :type X: OCC.wrapper.math.math_Vector
        :type F: OCC.wrapper.math.math_Vector
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BlendFunc.BlendFunc_CSCircular_Value(self, *args)


    def Derivatives(self, *args):
        """
        Derivatives(BlendFunc_CSCircular self, math_Vector X, math_Matrix D) -> Standard_Boolean

        returns the values <D> of the derivatives for the
        variable <X>.
        Returns True if the computation was done successfully,
        False otherwise.

        :type X: OCC.wrapper.math.math_Vector
        :type D: OCC.wrapper.math.math_Matrix
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BlendFunc.BlendFunc_CSCircular_Derivatives(self, *args)


    def Values(self, *args):
        """
        Values(BlendFunc_CSCircular self, math_Vector X, math_Vector F, math_Matrix D) -> Standard_Boolean

        returns the values <F> of the functions and the derivatives
        <D> for the variable <X>.
        Returns True if the computation was done successfully,
        False otherwise.

        :type X: OCC.wrapper.math.math_Vector
        :type F: OCC.wrapper.math.math_Vector
        :type D: OCC.wrapper.math.math_Matrix
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BlendFunc.BlendFunc_CSCircular_Values(self, *args)


    def GetBounds(self, *args):
        """
        GetBounds(BlendFunc_CSCircular self, math_Vector InfBound, math_Vector SupBound)

        :type InfBound: OCC.wrapper.math.math_Vector
        :type SupBound: OCC.wrapper.math.math_Vector

        """
        return _BlendFunc.BlendFunc_CSCircular_GetBounds(self, *args)


    def IsSolution(self, *args):
        """
        IsSolution(BlendFunc_CSCircular self, math_Vector Sol, Standard_Real const Tol) -> Standard_Boolean

        :type Sol: OCC.wrapper.math.math_Vector
        :type Tol: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BlendFunc.BlendFunc_CSCircular_IsSolution(self, *args)


    def PointOnS(self, *args):
        """
        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        res = _BlendFunc.BlendFunc_CSCircular_PointOnS(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def PointOnC(self, *args):
        """
        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        res = _BlendFunc.BlendFunc_CSCircular_PointOnC(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Pnt2d(self, *args):
        """
        Returns U,V coordinates of the point on the surface.

        :rtype: OCC.wrapper.gp.gp_Pnt2d

        """
        res = _BlendFunc.BlendFunc_CSCircular_Pnt2d(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ParameterOnC(self, *args):
        """
        ParameterOnC(BlendFunc_CSCircular self) -> Standard_Real

        Returns parameter of the point on the curve.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _BlendFunc.BlendFunc_CSCircular_ParameterOnC(self, *args)


    def IsTangencyPoint(self, *args):
        """
        IsTangencyPoint(BlendFunc_CSCircular self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BlendFunc.BlendFunc_CSCircular_IsTangencyPoint(self, *args)


    def TangentOnS(self, *args):
        """
        :rtype: OCC.wrapper.gp.gp_Vec

        """
        res = _BlendFunc.BlendFunc_CSCircular_TangentOnS(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Tangent2d(self, *args):
        """
        :rtype: OCC.wrapper.gp.gp_Vec2d

        """
        res = _BlendFunc.BlendFunc_CSCircular_Tangent2d(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def TangentOnC(self, *args):
        """
        :rtype: OCC.wrapper.gp.gp_Vec

        """
        res = _BlendFunc.BlendFunc_CSCircular_TangentOnC(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Tangent(self, *args):
        """
        Tangent(BlendFunc_CSCircular self, Standard_Real const U, Standard_Real const V, gp_Vec TgS, gp_Vec NormS)

        Returns the tangent vector at the section,
        at the beginning and the end of the section, and
        returns the normal (of the surface) at
        these points.

        :type U: float
        :type V: float
        :type TgS: OCC.wrapper.gp.gp_Vec
        :type NormS: OCC.wrapper.gp.gp_Vec

        """
        return _BlendFunc.BlendFunc_CSCircular_Tangent(self, *args)


    def Set(self, *args):
        """
        Set(BlendFunc_CSCircular self, Standard_Real const Param)
        Set(BlendFunc_CSCircular self, Standard_Real const First, Standard_Real const Last)
        Set(BlendFunc_CSCircular self, Standard_Real const Radius, Standard_Integer const Choix)
        Set(BlendFunc_CSCircular self, BlendFunc_SectionShape const TypeSection)

        Sets  the  type  of   section generation   for the
        approximations.

        :type TypeSection: OCC.wrapper.BlendFunc.BlendFunc_SectionShape

        """
        return _BlendFunc.BlendFunc_CSCircular_Set(self, *args)


    def GetSection(self, *args):
        """
        GetSection(BlendFunc_CSCircular self, Standard_Real const Param, Standard_Real const U, Standard_Real const V, Standard_Real const W, NCollection_Array1_gp_Pnt tabP, NCollection_Array1_gp_Vec tabV) -> Standard_Boolean

        :type Param: float
        :type U: float
        :type V: float
        :type W: float
        :type tabP: OCC.wrapper.TColgp.TColgp_Array1OfPnt
        :type tabV: OCC.wrapper.TColgp.TColgp_Array1OfVec
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BlendFunc.BlendFunc_CSCircular_GetSection(self, *args)


    def IsRational(self, *args):
        """
        IsRational(BlendFunc_CSCircular self) -> Standard_Boolean

        Returns  if the section is rationnal

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BlendFunc.BlendFunc_CSCircular_IsRational(self, *args)


    def GetSectionSize(self, *args):
        """
        GetSectionSize(BlendFunc_CSCircular self) -> Standard_Real

        Returns the length of the maximum section

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _BlendFunc.BlendFunc_CSCircular_GetSectionSize(self, *args)


    def GetMinimalWeight(self, *args):
        """
        GetMinimalWeight(BlendFunc_CSCircular self, NCollection_Array1_Standard_Real Weigths)

        Compute the minimal value of weight for each poles
        of all sections.

        :type Weigths: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        return _BlendFunc.BlendFunc_CSCircular_GetMinimalWeight(self, *args)


    def NbIntervals(self, *args):
        """
        NbIntervals(BlendFunc_CSCircular self, GeomAbs_Shape const S) -> Standard_Integer

        Returns  the number  of  intervals for  continuity
        <S>. May be one if Continuity(me) >= <S>

        :type S: OCC.wrapper.GeomAbs.GeomAbs_Shape
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BlendFunc.BlendFunc_CSCircular_NbIntervals(self, *args)


    def Intervals(self, *args):
        """
        Intervals(BlendFunc_CSCircular self, NCollection_Array1_Standard_Real T, GeomAbs_Shape const S)

        Stores in <T> the  parameters bounding the intervals
        of continuity <S>.

        The array must provide  enough room to  accomodate
        for the parameters. i.e. T.Length() > NbIntervals()
        raises
        OutOfRange from Standard

        :type T: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type S: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _BlendFunc.BlendFunc_CSCircular_Intervals(self, *args)


    def GetShape(self, *args):
        """
        GetShape(BlendFunc_CSCircular self)

        :type NbPoles: int
        :type NbKnots: int
        :type Degree: int
        :type NbPoles2d: int

        """
        return _BlendFunc.BlendFunc_CSCircular_GetShape(self, *args)


    def GetTolerance(self, *args):
        """
        GetTolerance(BlendFunc_CSCircular self, math_Vector Tolerance, Standard_Real const Tol)
        GetTolerance(BlendFunc_CSCircular self, Standard_Real const BoundTol, Standard_Real const SurfTol, Standard_Real const AngleTol, math_Vector Tol3d, math_Vector Tol1D)

        Returns the tolerance to reach in approximation
        to respecte
        BoundTol error at the Boundary
        AngleTol tangent error at the Boundary
        SurfTol error inside the surface.

        :type BoundTol: float
        :type SurfTol: float
        :type AngleTol: float
        :type Tol3d: OCC.wrapper.math.math_Vector
        :type Tol1D: OCC.wrapper.math.math_Vector

        """
        return _BlendFunc.BlendFunc_CSCircular_GetTolerance(self, *args)


    def Knots(self, *args):
        """
        Knots(BlendFunc_CSCircular self, NCollection_Array1_Standard_Real TKnots)

        :type TKnots: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        return _BlendFunc.BlendFunc_CSCircular_Knots(self, *args)


    def Mults(self, *args):
        """
        Mults(BlendFunc_CSCircular self, NCollection_Array1_Standard_Integer TMults)

        :type TMults: OCC.wrapper.TColStd.TColStd_Array1OfInteger

        """
        return _BlendFunc.BlendFunc_CSCircular_Mults(self, *args)


    def Section(self, *args):
        """
        Section(BlendFunc_CSCircular self, Standard_Real const Param, Standard_Real const U, Standard_Real const V, Standard_Real const W, gp_Circ C)
        Section(BlendFunc_CSCircular self, Blend_Point P, NCollection_Array1_gp_Pnt Poles, NCollection_Array1_gp_Vec DPoles, NCollection_Array1_gp_Vec D2Poles, NCollection_Array1_gp_Pnt2d Poles2d, NCollection_Array1_gp_Vec2d DPoles2d, NCollection_Array1_gp_Vec2d D2Poles2d, NCollection_Array1_Standard_Real Weigths, NCollection_Array1_Standard_Real DWeigths, NCollection_Array1_Standard_Real D2Weigths) -> Standard_Boolean
        Section(BlendFunc_CSCircular self, Blend_Point P, NCollection_Array1_gp_Pnt Poles, NCollection_Array1_gp_Vec DPoles, NCollection_Array1_gp_Pnt2d Poles2d, NCollection_Array1_gp_Vec2d DPoles2d, NCollection_Array1_Standard_Real Weigths, NCollection_Array1_Standard_Real DWeigths) -> Standard_Boolean
        Section(BlendFunc_CSCircular self, Blend_Point P, NCollection_Array1_gp_Pnt Poles, NCollection_Array1_gp_Pnt2d Poles2d, NCollection_Array1_Standard_Real Weigths)

        :type P: OCC.wrapper.Blend.Blend_Point
        :type Poles: OCC.wrapper.TColgp.TColgp_Array1OfPnt
        :type Poles2d: OCC.wrapper.TColgp.TColgp_Array1OfPnt2d
        :type Weigths: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        return _BlendFunc.BlendFunc_CSCircular_Section(self, *args)


    def Resolution(self, *args):
        """
        Resolution(BlendFunc_CSCircular self, Standard_Integer const IC2d, Standard_Real const Tol)

        :type IC2d: int
        :type Tol: float
        :type TolU: float
        :type TolV: float

        """
        return _BlendFunc.BlendFunc_CSCircular_Resolution(self, *args)

    __swig_destroy__ = _BlendFunc.delete_BlendFunc_CSCircular
BlendFunc_CSCircular_swigregister = _BlendFunc.BlendFunc_CSCircular_swigregister
BlendFunc_CSCircular_swigregister(BlendFunc_CSCircular)

class BlendFunc_Tensor(object):
    """used to store the "gradient of gradient" """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BlendFunc_Tensor self, Standard_Integer const NbRow, Standard_Integer const NbCol, Standard_Integer const NbMat) -> BlendFunc_Tensor

        :type NbRow: int
        :type NbCol: int
        :type NbMat: int

        """
        this = _BlendFunc.new_BlendFunc_Tensor(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(BlendFunc_Tensor self, Standard_Real const InitialValue)

        Initialize all the elements of a Tensor to InitialValue.

        :type InitialValue: float

        """
        return _BlendFunc.BlendFunc_Tensor_Init(self, *args)


    def Value(self, *args):
        """
        Value(BlendFunc_Tensor self, Standard_Integer const Row, Standard_Integer const Col, Standard_Integer const Mat) -> Standard_Real const &

        accesses (in read or write mode) the value of index <Row>,
        <Col> and <Mat> of a Tensor.
        An exception is raised if <Row>, <Col> or <Mat> are not
        in the correct range.

        :type Row: int
        :type Col: int
        :type Mat: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _BlendFunc.BlendFunc_Tensor_Value(self, *args)


    def ChangeValue(self, *args):
        """
        ChangeValue(BlendFunc_Tensor self, Standard_Integer const Row, Standard_Integer const Col, Standard_Integer const Mat) -> Standard_Real &

        accesses (in read or write mode) the value of index <Row>,
        <Col> and <Mat> of a Tensor.
        An exception is raised if <Row>, <Col> or <Mat> are not
        in the correct range.

        :type Row: int
        :type Col: int
        :type Mat: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _BlendFunc.BlendFunc_Tensor_ChangeValue(self, *args)


    def __call__(self, *args):
        """
        __call__(BlendFunc_Tensor self, Standard_Integer const Row, Standard_Integer const Col, Standard_Integer const Mat) -> Standard_Real const
        __call__(BlendFunc_Tensor self, Standard_Integer const Row, Standard_Integer const Col, Standard_Integer const Mat) -> Standard_Real &

        :type Row: int
        :type Col: int
        :type Mat: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _BlendFunc.BlendFunc_Tensor___call__(self, *args)


    def Multiply(self, *args):
        """
        Multiply(BlendFunc_Tensor self, math_Vector Right, math_Matrix Product)

        :type Right: OCC.wrapper.math.math_Vector
        :type Product: OCC.wrapper.math.math_Matrix

        """
        return _BlendFunc.BlendFunc_Tensor_Multiply(self, *args)

    __swig_destroy__ = _BlendFunc.delete_BlendFunc_Tensor
BlendFunc_Tensor_swigregister = _BlendFunc.BlendFunc_Tensor_swigregister
BlendFunc_Tensor_swigregister(BlendFunc_Tensor)

class BlendFunc_EvolRadInv(Blend.Blend_FuncInv):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BlendFunc_EvolRadInv self, Handle_Adaptor3d_HSurface S1, Handle_Adaptor3d_HSurface S2, Handle_Adaptor3d_HCurve C, Handle_Law_Function Law) -> BlendFunc_EvolRadInv

        :type S1: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface
        :type S2: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface
        :type C: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HCurve
        :type Law: OCC.wrapper.Law.Handle_Law_Function

        """
        this = _BlendFunc.new_BlendFunc_EvolRadInv(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def GetTolerance(self, *args):
        """
        GetTolerance(BlendFunc_EvolRadInv self, math_Vector Tolerance, Standard_Real const Tol)

        :type Tolerance: OCC.wrapper.math.math_Vector
        :type Tol: float

        """
        return _BlendFunc.BlendFunc_EvolRadInv_GetTolerance(self, *args)


    def GetBounds(self, *args):
        """
        GetBounds(BlendFunc_EvolRadInv self, math_Vector InfBound, math_Vector SupBound)

        :type InfBound: OCC.wrapper.math.math_Vector
        :type SupBound: OCC.wrapper.math.math_Vector

        """
        return _BlendFunc.BlendFunc_EvolRadInv_GetBounds(self, *args)


    def IsSolution(self, *args):
        """
        IsSolution(BlendFunc_EvolRadInv self, math_Vector Sol, Standard_Real const Tol) -> Standard_Boolean

        :type Sol: OCC.wrapper.math.math_Vector
        :type Tol: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BlendFunc.BlendFunc_EvolRadInv_IsSolution(self, *args)


    def NbEquations(self, *args):
        """
        NbEquations(BlendFunc_EvolRadInv self) -> Standard_Integer

        returns the number of equations of the function.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BlendFunc.BlendFunc_EvolRadInv_NbEquations(self, *args)


    def Value(self, *args):
        """
        Value(BlendFunc_EvolRadInv self, math_Vector X, math_Vector F) -> Standard_Boolean

        computes the values <F> of the Functions for the
        variable <X>.
        Returns True if the computation was done successfully,
        False otherwise.

        :type X: OCC.wrapper.math.math_Vector
        :type F: OCC.wrapper.math.math_Vector
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BlendFunc.BlendFunc_EvolRadInv_Value(self, *args)


    def Derivatives(self, *args):
        """
        Derivatives(BlendFunc_EvolRadInv self, math_Vector X, math_Matrix D) -> Standard_Boolean

        returns the values <D> of the derivatives for the
        variable <X>.
        Returns True if the computation was done successfully,
        False otherwise.

        :type X: OCC.wrapper.math.math_Vector
        :type D: OCC.wrapper.math.math_Matrix
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BlendFunc.BlendFunc_EvolRadInv_Derivatives(self, *args)


    def Values(self, *args):
        """
        Values(BlendFunc_EvolRadInv self, math_Vector X, math_Vector F, math_Matrix D) -> Standard_Boolean

        returns the values <F> of the functions and the derivatives
        <D> for the variable <X>.
        Returns True if the computation was done successfully,
        False otherwise.

        :type X: OCC.wrapper.math.math_Vector
        :type F: OCC.wrapper.math.math_Vector
        :type D: OCC.wrapper.math.math_Matrix
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BlendFunc.BlendFunc_EvolRadInv_Values(self, *args)


    def Set(self, *args):
        """
        Set(BlendFunc_EvolRadInv self, Standard_Boolean const OnFirst, Handle_Adaptor2d_HCurve2d COnSurf)
        Set(BlendFunc_EvolRadInv self, Standard_Integer const Choix)

        :type Choix: int

        """
        return _BlendFunc.BlendFunc_EvolRadInv_Set(self, *args)

    __swig_destroy__ = _BlendFunc.delete_BlendFunc_EvolRadInv
BlendFunc_EvolRadInv_swigregister = _BlendFunc.BlendFunc_EvolRadInv_swigregister
BlendFunc_EvolRadInv_swigregister(BlendFunc_EvolRadInv)




# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_Aspect')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_Aspect')
    _Aspect = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_Aspect', [dirname(__file__)])
        except ImportError:
            import _Aspect
            return _Aspect
        try:
            _mod = imp.load_module('_Aspect', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _Aspect = swig_import_helper()
    del swig_import_helper
else:
    import _Aspect
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


class SwigPyIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _Aspect.delete_SwigPyIterator

    def value(self):
        return _Aspect.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _Aspect.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _Aspect.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _Aspect.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _Aspect.SwigPyIterator_equal(self, x)

    def copy(self):
        return _Aspect.SwigPyIterator_copy(self)

    def next(self):
        return _Aspect.SwigPyIterator_next(self)

    def __next__(self):
        return _Aspect.SwigPyIterator___next__(self)

    def previous(self):
        return _Aspect.SwigPyIterator_previous(self)

    def advance(self, n):
        return _Aspect.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _Aspect.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _Aspect.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _Aspect.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _Aspect.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _Aspect.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _Aspect.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self
SwigPyIterator_swigregister = _Aspect.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

class NCollection_CellFilter_InspectorXYZ(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _Aspect.NCollection_CellFilter_InspectorXYZ_Dimension
    Coord = staticmethod(_Aspect.NCollection_CellFilter_InspectorXYZ_Coord)

    def Shift(self, thePnt, theTol):
        return _Aspect.NCollection_CellFilter_InspectorXYZ_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _Aspect.new_NCollection_CellFilter_InspectorXYZ()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _Aspect.delete_NCollection_CellFilter_InspectorXYZ
NCollection_CellFilter_InspectorXYZ_swigregister = _Aspect.NCollection_CellFilter_InspectorXYZ_swigregister
NCollection_CellFilter_InspectorXYZ_swigregister(NCollection_CellFilter_InspectorXYZ)

def NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt):
    return _Aspect.NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt)
NCollection_CellFilter_InspectorXYZ_Coord = _Aspect.NCollection_CellFilter_InspectorXYZ_Coord

class NCollection_CellFilter_InspectorXY(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _Aspect.NCollection_CellFilter_InspectorXY_Dimension
    Coord = staticmethod(_Aspect.NCollection_CellFilter_InspectorXY_Coord)

    def Shift(self, thePnt, theTol):
        return _Aspect.NCollection_CellFilter_InspectorXY_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _Aspect.new_NCollection_CellFilter_InspectorXY()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _Aspect.delete_NCollection_CellFilter_InspectorXY
NCollection_CellFilter_InspectorXY_swigregister = _Aspect.NCollection_CellFilter_InspectorXY_swigregister
NCollection_CellFilter_InspectorXY_swigregister(NCollection_CellFilter_InspectorXY)

def NCollection_CellFilter_InspectorXY_Coord(i, thePnt):
    return _Aspect.NCollection_CellFilter_InspectorXY_Coord(i, thePnt)
NCollection_CellFilter_InspectorXY_Coord = _Aspect.NCollection_CellFilter_InspectorXY_Coord


def ptr_to_number(item):
    return _Aspect.ptr_to_number(item)
ptr_to_number = _Aspect.ptr_to_number

def HashCode(*args):
    return _Aspect.HashCode(*args)
HashCode = _Aspect.HashCode

def ptr_equal(a, b):
    return _Aspect.ptr_equal(a, b)
ptr_equal = _Aspect.ptr_equal
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Quantity
else:
    import Quantity
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Standard
else:
    import Standard
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import NCollection
else:
    import NCollection
del _swig_python_version_info
Aspect_GDM_Lines = _Aspect.Aspect_GDM_Lines
Aspect_GDM_Points = _Aspect.Aspect_GDM_Points
Aspect_GDM_None = _Aspect.Aspect_GDM_None
Aspect_XA_DELETE_WINDOW = _Aspect.Aspect_XA_DELETE_WINDOW
Aspect_FM_NONE = _Aspect.Aspect_FM_NONE
Aspect_FM_CENTERED = _Aspect.Aspect_FM_CENTERED
Aspect_FM_TILED = _Aspect.Aspect_FM_TILED
Aspect_FM_STRETCH = _Aspect.Aspect_FM_STRETCH
Aspect_GFM_NONE = _Aspect.Aspect_GFM_NONE
Aspect_GFM_HOR = _Aspect.Aspect_GFM_HOR
Aspect_GFM_VER = _Aspect.Aspect_GFM_VER
Aspect_GFM_DIAG1 = _Aspect.Aspect_GFM_DIAG1
Aspect_GFM_DIAG2 = _Aspect.Aspect_GFM_DIAG2
Aspect_GFM_CORNER1 = _Aspect.Aspect_GFM_CORNER1
Aspect_GFM_CORNER2 = _Aspect.Aspect_GFM_CORNER2
Aspect_GFM_CORNER3 = _Aspect.Aspect_GFM_CORNER3
Aspect_GFM_CORNER4 = _Aspect.Aspect_GFM_CORNER4
Aspect_GT_Rectangular = _Aspect.Aspect_GT_Rectangular
Aspect_GT_Circular = _Aspect.Aspect_GT_Circular
Aspect_TOR_UNKNOWN = _Aspect.Aspect_TOR_UNKNOWN
Aspect_TOR_NO_BORDER = _Aspect.Aspect_TOR_NO_BORDER
Aspect_TOR_TOP_BORDER = _Aspect.Aspect_TOR_TOP_BORDER
Aspect_TOR_RIGHT_BORDER = _Aspect.Aspect_TOR_RIGHT_BORDER
Aspect_TOR_BOTTOM_BORDER = _Aspect.Aspect_TOR_BOTTOM_BORDER
Aspect_TOR_LEFT_BORDER = _Aspect.Aspect_TOR_LEFT_BORDER
Aspect_TOR_TOP_AND_RIGHT_BORDER = _Aspect.Aspect_TOR_TOP_AND_RIGHT_BORDER
Aspect_TOR_RIGHT_AND_BOTTOM_BORDER = _Aspect.Aspect_TOR_RIGHT_AND_BOTTOM_BORDER
Aspect_TOR_BOTTOM_AND_LEFT_BORDER = _Aspect.Aspect_TOR_BOTTOM_AND_LEFT_BORDER
Aspect_TOR_LEFT_AND_TOP_BORDER = _Aspect.Aspect_TOR_LEFT_AND_TOP_BORDER
Aspect_HS_SOLID = _Aspect.Aspect_HS_SOLID
Aspect_HS_HORIZONTAL = _Aspect.Aspect_HS_HORIZONTAL
Aspect_HS_HORIZONTAL_WIDE = _Aspect.Aspect_HS_HORIZONTAL_WIDE
Aspect_HS_VERTICAL = _Aspect.Aspect_HS_VERTICAL
Aspect_HS_VERTICAL_WIDE = _Aspect.Aspect_HS_VERTICAL_WIDE
Aspect_HS_DIAGONAL_45 = _Aspect.Aspect_HS_DIAGONAL_45
Aspect_HS_DIAGONAL_45_WIDE = _Aspect.Aspect_HS_DIAGONAL_45_WIDE
Aspect_HS_DIAGONAL_135 = _Aspect.Aspect_HS_DIAGONAL_135
Aspect_HS_DIAGONAL_135_WIDE = _Aspect.Aspect_HS_DIAGONAL_135_WIDE
Aspect_HS_GRID = _Aspect.Aspect_HS_GRID
Aspect_HS_GRID_WIDE = _Aspect.Aspect_HS_GRID_WIDE
Aspect_HS_GRID_DIAGONAL = _Aspect.Aspect_HS_GRID_DIAGONAL
Aspect_HS_GRID_DIAGONAL_WIDE = _Aspect.Aspect_HS_GRID_DIAGONAL_WIDE
Aspect_HS_NB = _Aspect.Aspect_HS_NB
Aspect_IS_EMPTY = _Aspect.Aspect_IS_EMPTY
Aspect_IS_HOLLOW = _Aspect.Aspect_IS_HOLLOW
Aspect_IS_HATCH = _Aspect.Aspect_IS_HATCH
Aspect_IS_SOLID = _Aspect.Aspect_IS_SOLID
Aspect_IS_HIDDENLINE = _Aspect.Aspect_IS_HIDDENLINE
Aspect_IS_POINT = _Aspect.Aspect_IS_POINT
Aspect_POM_Off = _Aspect.Aspect_POM_Off
Aspect_POM_Fill = _Aspect.Aspect_POM_Fill
Aspect_POM_Line = _Aspect.Aspect_POM_Line
Aspect_POM_Point = _Aspect.Aspect_POM_Point
Aspect_POM_All = _Aspect.Aspect_POM_All
Aspect_POM_None = _Aspect.Aspect_POM_None
Aspect_POM_Mask = _Aspect.Aspect_POM_Mask
Aspect_TOCSD_AUTO = _Aspect.Aspect_TOCSD_AUTO
Aspect_TOCSD_USER = _Aspect.Aspect_TOCSD_USER
Aspect_TOCSO_NONE = _Aspect.Aspect_TOCSO_NONE
Aspect_TOCSO_LEFT = _Aspect.Aspect_TOCSO_LEFT
Aspect_TOCSO_RIGHT = _Aspect.Aspect_TOCSO_RIGHT
Aspect_TOCSO_CENTER = _Aspect.Aspect_TOCSO_CENTER
Aspect_TOCSP_NONE = _Aspect.Aspect_TOCSP_NONE
Aspect_TOCSP_LEFT = _Aspect.Aspect_TOCSP_LEFT
Aspect_TOCSP_RIGHT = _Aspect.Aspect_TOCSP_RIGHT
Aspect_TOCSP_CENTER = _Aspect.Aspect_TOCSP_CENTER
Aspect_TOD_RELATIVE = _Aspect.Aspect_TOD_RELATIVE
Aspect_TOD_ABSOLUTE = _Aspect.Aspect_TOD_ABSOLUTE
Aspect_TODT_NORMAL = _Aspect.Aspect_TODT_NORMAL
Aspect_TODT_SUBTITLE = _Aspect.Aspect_TODT_SUBTITLE
Aspect_TODT_DEKALE = _Aspect.Aspect_TODT_DEKALE
Aspect_TODT_BLEND = _Aspect.Aspect_TODT_BLEND
Aspect_TODT_DIMENSION = _Aspect.Aspect_TODT_DIMENSION
Aspect_TODT_SHADOW = _Aspect.Aspect_TODT_SHADOW
Aspect_TOFM_BOTH_SIDE = _Aspect.Aspect_TOFM_BOTH_SIDE
Aspect_TOFM_BACK_SIDE = _Aspect.Aspect_TOFM_BACK_SIDE
Aspect_TOFM_FRONT_SIDE = _Aspect.Aspect_TOFM_FRONT_SIDE
Aspect_TOHM_COLOR = _Aspect.Aspect_TOHM_COLOR
Aspect_TOHM_BOUNDBOX = _Aspect.Aspect_TOHM_BOUNDBOX
Aspect_TOL_EMPTY = _Aspect.Aspect_TOL_EMPTY
Aspect_TOL_SOLID = _Aspect.Aspect_TOL_SOLID
Aspect_TOL_DASH = _Aspect.Aspect_TOL_DASH
Aspect_TOL_DOT = _Aspect.Aspect_TOL_DOT
Aspect_TOL_DOTDASH = _Aspect.Aspect_TOL_DOTDASH
Aspect_TOL_USERDEFINED = _Aspect.Aspect_TOL_USERDEFINED
Aspect_TOM_EMPTY = _Aspect.Aspect_TOM_EMPTY
Aspect_TOM_POINT = _Aspect.Aspect_TOM_POINT
Aspect_TOM_PLUS = _Aspect.Aspect_TOM_PLUS
Aspect_TOM_STAR = _Aspect.Aspect_TOM_STAR
Aspect_TOM_X = _Aspect.Aspect_TOM_X
Aspect_TOM_O = _Aspect.Aspect_TOM_O
Aspect_TOM_O_POINT = _Aspect.Aspect_TOM_O_POINT
Aspect_TOM_O_PLUS = _Aspect.Aspect_TOM_O_PLUS
Aspect_TOM_O_STAR = _Aspect.Aspect_TOM_O_STAR
Aspect_TOM_O_X = _Aspect.Aspect_TOM_O_X
Aspect_TOM_RING1 = _Aspect.Aspect_TOM_RING1
Aspect_TOM_RING2 = _Aspect.Aspect_TOM_RING2
Aspect_TOM_RING3 = _Aspect.Aspect_TOM_RING3
Aspect_TOM_BALL = _Aspect.Aspect_TOM_BALL
Aspect_TOM_USERDEFINED = _Aspect.Aspect_TOM_USERDEFINED
Aspect_TOST_NORMAL = _Aspect.Aspect_TOST_NORMAL
Aspect_TOST_ANNOTATION = _Aspect.Aspect_TOST_ANNOTATION
Aspect_TOTP_CENTER = _Aspect.Aspect_TOTP_CENTER
Aspect_TOTP_TOP = _Aspect.Aspect_TOTP_TOP
Aspect_TOTP_BOTTOM = _Aspect.Aspect_TOTP_BOTTOM
Aspect_TOTP_LEFT = _Aspect.Aspect_TOTP_LEFT
Aspect_TOTP_RIGHT = _Aspect.Aspect_TOTP_RIGHT
Aspect_TOTP_LEFT_LOWER = _Aspect.Aspect_TOTP_LEFT_LOWER
Aspect_TOTP_LEFT_UPPER = _Aspect.Aspect_TOTP_LEFT_UPPER
Aspect_TOTP_RIGHT_LOWER = _Aspect.Aspect_TOTP_RIGHT_LOWER
Aspect_TOTP_RIGHT_UPPER = _Aspect.Aspect_TOTP_RIGHT_UPPER
Aspect_WOL_THIN = _Aspect.Aspect_WOL_THIN
Aspect_WOL_MEDIUM = _Aspect.Aspect_WOL_MEDIUM
Aspect_WOL_THICK = _Aspect.Aspect_WOL_THICK
Aspect_WOL_VERYTHICK = _Aspect.Aspect_WOL_VERYTHICK
Aspect_WOL_USERDEFINED = _Aspect.Aspect_WOL_USERDEFINED
class Aspect_Window(Standard.Standard_Transient):
    """Defines a window."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Aspect_Window
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Aspect_Window(self) 
            return h


    def SetBackground(self, *args):
        """
        SetBackground(Aspect_Window self, Aspect_Background ABack)
        SetBackground(Aspect_Window self, Quantity_Color color)
        SetBackground(Aspect_Window self, Aspect_GradientBackground ABackground)
        SetBackground(Aspect_Window self, Quantity_Color theFirstColor, Quantity_Color theSecondColor, Aspect_GradientFillMethod const theFillMethod)

        Modifies the window gradient background.

        :type theFirstColor: OCC.wrapper.Quantity.Quantity_Color
        :type theSecondColor: OCC.wrapper.Quantity.Quantity_Color
        :type theFillMethod: OCC.wrapper.Aspect.Aspect_GradientFillMethod

        """
        return _Aspect.Aspect_Window_SetBackground(self, *args)


    def Map(self, *args):
        """
        Map(Aspect_Window self)

        Opens the window <me>.


        """
        return _Aspect.Aspect_Window_Map(self, *args)


    def Unmap(self, *args):
        """
        Unmap(Aspect_Window self)

        Closes the window <me>.


        """
        return _Aspect.Aspect_Window_Unmap(self, *args)


    def DoResize(self, *args):
        """
        DoResize(Aspect_Window self) -> Aspect_TypeOfResize

        Apply the resizing to the window <me>.

        :rtype: OCC.wrapper.Aspect.Aspect_TypeOfResize

        """
        return _Aspect.Aspect_Window_DoResize(self, *args)


    def DoMapping(self, *args):
        """
        DoMapping(Aspect_Window self) -> Standard_Boolean

        Apply the mapping change to the window <me>.
        and returns TRUE if the window is mapped at screen.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Aspect.Aspect_Window_DoMapping(self, *args)


    def Background(self, *args):
        """
        Background(Aspect_Window self) -> Aspect_Background

        Returns the window background.

        :rtype: OCC.wrapper.Aspect.Aspect_Background

        """
        return _Aspect.Aspect_Window_Background(self, *args)


    def BackgroundFillMethod(self, *args):
        """
        BackgroundFillMethod(Aspect_Window self) -> Aspect_FillMethod

        Returns the current image background fill mode.

        :rtype: OCC.wrapper.Aspect.Aspect_FillMethod

        """
        return _Aspect.Aspect_Window_BackgroundFillMethod(self, *args)


    def GradientBackground(self, *args):
        """
        GradientBackground(Aspect_Window self) -> Aspect_GradientBackground

        Returns the window gradient background.

        :rtype: OCC.wrapper.Aspect.Aspect_GradientBackground

        """
        return _Aspect.Aspect_Window_GradientBackground(self, *args)


    def IsMapped(self, *args):
        """
        IsMapped(Aspect_Window self) -> Standard_Boolean

        Returns True if the window <me> is opened
        and False if the window is closed.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Aspect.Aspect_Window_IsMapped(self, *args)


    def IsVirtual(self, *args):
        """
        IsVirtual(Aspect_Window self) -> Standard_Boolean

        Returns True if the window <me> is virtual

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Aspect.Aspect_Window_IsVirtual(self, *args)


    def SetVirtual(self, *args):
        """
        SetVirtual(Aspect_Window self, Standard_Boolean const theVirtual)

        Setup the virtual state

        :type theVirtual: bool

        """
        return _Aspect.Aspect_Window_SetVirtual(self, *args)


    def Ratio(self, *args):
        """
        Ratio(Aspect_Window self) -> Standard_Real

        Returns The Window RATIO equal to the physical
        WIDTH/HEIGHT dimensions

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Aspect.Aspect_Window_Ratio(self, *args)


    def Position(self, *args):
        """
        Position(Aspect_Window self)

        Returns The Window POSITION in PIXEL

        :type X1: int
        :type Y1: int
        :type X2: int
        :type Y2: int

        """
        return _Aspect.Aspect_Window_Position(self, *args)


    def Size(self, *args):
        """
        Size(Aspect_Window self)

        Returns The Window SIZE in PIXEL

        :type Width: int
        :type Height: int

        """
        return _Aspect.Aspect_Window_Size(self, *args)


    def NativeFBConfig(self, *args):
        """
        NativeFBConfig(Aspect_Window self) -> Aspect_FBConfig

        Returns native Window FB config (GLXFBConfig on Xlib)

        :rtype: OCC.wrapper.Aspect.Aspect_FBConfig

        """
        return _Aspect.Aspect_Window_NativeFBConfig(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Aspect.Aspect_Window_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Aspect.Aspect_Window_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Aspect.Aspect_Window_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Aspect.delete_Aspect_Window
Aspect_Window_swigregister = _Aspect.Aspect_Window_swigregister
Aspect_Window_swigregister(Aspect_Window)

def Aspect_Window_get_type_name(*args):
    """
    Aspect_Window_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Aspect.Aspect_Window_get_type_name(*args)

def Aspect_Window_get_type_descriptor(*args):
    """
    Aspect_Window_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Aspect.Aspect_Window_get_type_descriptor(*args)

class Aspect_NeutralWindow(Aspect_Window):
    """
    Defines a platform-neutral window.
    This class is intended to be used in context when window management (including OpenGL context creation)
    is performed on application side (e.g. using external framework).

    Window properties should be managed by application and assigned to this class as properties.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Aspect_NeutralWindow
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Aspect_NeutralWindow(self) 
            return h


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Aspect.Aspect_NeutralWindow_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Aspect.Aspect_NeutralWindow_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Aspect.Aspect_NeutralWindow_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __init__(self, *args):
        """
        __init__(Aspect_NeutralWindow self) -> Aspect_NeutralWindow

        Empty constructor.
        Note that window is considered "mapped" by default.


        """
        this = _Aspect.new_Aspect_NeutralWindow(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def NativeFBConfig(self, *args):
        """
        NativeFBConfig(Aspect_NeutralWindow self) -> Aspect_FBConfig

        Return FBConfig.

        :rtype: OCC.wrapper.Aspect.Aspect_FBConfig

        """
        return _Aspect.Aspect_NeutralWindow_NativeFBConfig(self, *args)


    def IsMapped(self, *args):
        """
        IsMapped(Aspect_NeutralWindow self) -> Standard_Boolean

        Return true if window is not hidden.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Aspect.Aspect_NeutralWindow_IsMapped(self, *args)


    def Map(self, *args):
        """
        Map(Aspect_NeutralWindow self)

        Change window mapped flag to TRUE.


        """
        return _Aspect.Aspect_NeutralWindow_Map(self, *args)


    def Unmap(self, *args):
        """
        Unmap(Aspect_NeutralWindow self)

        Change window mapped flag to FALSE.


        """
        return _Aspect.Aspect_NeutralWindow_Unmap(self, *args)


    def DoResize(self, *args):
        """
        DoResize(Aspect_NeutralWindow self) -> Aspect_TypeOfResize

        Resize window - do nothing.

        :rtype: OCC.wrapper.Aspect.Aspect_TypeOfResize

        """
        return _Aspect.Aspect_NeutralWindow_DoResize(self, *args)


    def DoMapping(self, *args):
        """
        DoMapping(Aspect_NeutralWindow self) -> Standard_Boolean

        Map window - do nothing.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Aspect.Aspect_NeutralWindow_DoMapping(self, *args)


    def Ratio(self, *args):
        """
        Ratio(Aspect_NeutralWindow self) -> Standard_Real

        Returns window ratio equal to the physical width/height dimensions.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Aspect.Aspect_NeutralWindow_Ratio(self, *args)


    def Position(self, *args):
        """
        Position(Aspect_NeutralWindow self)

        Return the window position.

        :type theX1: int
        :type theY1: int
        :type theX2: int
        :type theY2: int

        """
        return _Aspect.Aspect_NeutralWindow_Position(self, *args)


    def SetPosition(self, *args):
        """
        SetPosition(Aspect_NeutralWindow self, Standard_Integer theX1, Standard_Integer theY1) -> Standard_Boolean
        SetPosition(Aspect_NeutralWindow self, Standard_Integer theX1, Standard_Integer theY1, Standard_Integer theX2, Standard_Integer theY2) -> Standard_Boolean

        Set the window position.
        @return true if position has been changed

        :type theX1: int
        :type theY1: int
        :type theX2: int
        :type theY2: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Aspect.Aspect_NeutralWindow_SetPosition(self, *args)


    def Size(self, *args):
        """
        Size(Aspect_NeutralWindow self)

        Return the window size.

        :type theWidth: int
        :type theHeight: int

        """
        return _Aspect.Aspect_NeutralWindow_Size(self, *args)


    def SetSize(self, *args):
        """
        SetSize(Aspect_NeutralWindow self, Standard_Integer const theWidth, Standard_Integer const theHeight) -> Standard_Boolean

        Set the window size.
        @return true if size has been changed

        :type theWidth: int
        :type theHeight: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Aspect.Aspect_NeutralWindow_SetSize(self, *args)

    __swig_destroy__ = _Aspect.delete_Aspect_NeutralWindow
Aspect_NeutralWindow_swigregister = _Aspect.Aspect_NeutralWindow_swigregister
Aspect_NeutralWindow_swigregister(Aspect_NeutralWindow)

def Aspect_NeutralWindow_get_type_name(*args):
    """
    Aspect_NeutralWindow_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Aspect.Aspect_NeutralWindow_get_type_name(*args)

def Aspect_NeutralWindow_get_type_descriptor(*args):
    """
    Aspect_NeutralWindow_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Aspect.Aspect_NeutralWindow_get_type_descriptor(*args)

class Aspect_Grid(Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Aspect_Grid
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Aspect_Grid(self) 
            return h


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Aspect.Aspect_Grid_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Aspect.Aspect_Grid_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Aspect.Aspect_Grid_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetXOrigin(self, *args):
        """
        SetXOrigin(Aspect_Grid self, Standard_Real const anOrigin)

        defines the x Origin of the grid.

        :type anOrigin: float

        """
        return _Aspect.Aspect_Grid_SetXOrigin(self, *args)


    def SetYOrigin(self, *args):
        """
        SetYOrigin(Aspect_Grid self, Standard_Real const anOrigin)

        defines the y Origin of the grid.

        :type anOrigin: float

        """
        return _Aspect.Aspect_Grid_SetYOrigin(self, *args)


    def SetRotationAngle(self, *args):
        """
        SetRotationAngle(Aspect_Grid self, Standard_Real const anAngle)

        defines the orientation of the grid.

        :type anAngle: float

        """
        return _Aspect.Aspect_Grid_SetRotationAngle(self, *args)


    def Rotate(self, *args):
        """
        Rotate(Aspect_Grid self, Standard_Real const anAngle)

        Rotate the grid from a relative angle.

        :type anAngle: float

        """
        return _Aspect.Aspect_Grid_Rotate(self, *args)


    def Translate(self, *args):
        """
        Translate(Aspect_Grid self, Standard_Real const aDx, Standard_Real const aDy)

        Translate the grid from a relative distance.

        :type aDx: float
        :type aDy: float

        """
        return _Aspect.Aspect_Grid_Translate(self, *args)


    def SetColors(self, *args):
        """
        SetColors(Aspect_Grid self, Quantity_Color aColor, Quantity_Color aTenthColor)

        Change the colors of the grid

        :type aColor: OCC.wrapper.Quantity.Quantity_Color
        :type aTenthColor: OCC.wrapper.Quantity.Quantity_Color

        """
        return _Aspect.Aspect_Grid_SetColors(self, *args)


    def Hit(self, *args):
        """
        Hit(Aspect_Grid self, Standard_Real const X, Standard_Real const Y)

        returns the point of the grid the closest to the point X,Y
        if the grid is active. If the grid is not active returns
        X,Y.

        :type X: float
        :type Y: float
        :type gridX: float
        :type gridY: float

        """
        return _Aspect.Aspect_Grid_Hit(self, *args)


    def Compute(self, *args):
        """
        Compute(Aspect_Grid self, Standard_Real const X, Standard_Real const Y)

        returns the point of the grid the closest to the point X,Y

        :type X: float
        :type Y: float
        :type gridX: float
        :type gridY: float

        """
        return _Aspect.Aspect_Grid_Compute(self, *args)


    def Activate(self, *args):
        """
        Activate(Aspect_Grid self)

        activates the grid. The Hit method will return
        gridx and gridx computed according to the steps
        of the grid.


        """
        return _Aspect.Aspect_Grid_Activate(self, *args)


    def Deactivate(self, *args):
        """
        Deactivate(Aspect_Grid self)

        deactivates the grid. The hit method will return
        gridx and gridx as the enter value X & Y.


        """
        return _Aspect.Aspect_Grid_Deactivate(self, *args)


    def XOrigin(self, *args):
        """
        XOrigin(Aspect_Grid self) -> Standard_Real

        returns the x Origin of the grid.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Aspect.Aspect_Grid_XOrigin(self, *args)


    def YOrigin(self, *args):
        """
        YOrigin(Aspect_Grid self) -> Standard_Real

        returns the x Origin of the grid.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Aspect.Aspect_Grid_YOrigin(self, *args)


    def RotationAngle(self, *args):
        """
        RotationAngle(Aspect_Grid self) -> Standard_Real

        returns the x Angle of the grid.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Aspect.Aspect_Grid_RotationAngle(self, *args)


    def IsActive(self, *args):
        """
        IsActive(Aspect_Grid self) -> Standard_Boolean

        Returns TRUE when the grid is active.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Aspect.Aspect_Grid_IsActive(self, *args)


    def Colors(self, *args):
        """
        Colors(Aspect_Grid self, Quantity_Color aColor, Quantity_Color aTenthColor)

        Returns the colors of the grid.

        :type aColor: OCC.wrapper.Quantity.Quantity_Color
        :type aTenthColor: OCC.wrapper.Quantity.Quantity_Color

        """
        return _Aspect.Aspect_Grid_Colors(self, *args)


    def SetDrawMode(self, *args):
        """
        SetDrawMode(Aspect_Grid self, Aspect_GridDrawMode const aDrawMode)

        Change the grid aspect.

        :type aDrawMode: OCC.wrapper.Aspect.Aspect_GridDrawMode

        """
        return _Aspect.Aspect_Grid_SetDrawMode(self, *args)


    def DrawMode(self, *args):
        """
        DrawMode(Aspect_Grid self) -> Aspect_GridDrawMode

        Returns the grid aspect.

        :rtype: OCC.wrapper.Aspect.Aspect_GridDrawMode

        """
        return _Aspect.Aspect_Grid_DrawMode(self, *args)


    def Display(self, *args):
        """
        Display(Aspect_Grid self)

        Display the grid at screen.


        """
        return _Aspect.Aspect_Grid_Display(self, *args)


    def Erase(self, *args):
        """
        Erase(Aspect_Grid self)

        Erase the grid from screen.


        """
        return _Aspect.Aspect_Grid_Erase(self, *args)


    def IsDisplayed(self, *args):
        """
        IsDisplayed(Aspect_Grid self) -> Standard_Boolean

        Returns TRUE when the grid is displayed at screen.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Aspect.Aspect_Grid_IsDisplayed(self, *args)


    def Init(self, *args):
        """Init(Aspect_Grid self)"""
        return _Aspect.Aspect_Grid_Init(self, *args)

    __swig_destroy__ = _Aspect.delete_Aspect_Grid
Aspect_Grid_swigregister = _Aspect.Aspect_Grid_swigregister
Aspect_Grid_swigregister(Aspect_Grid)

def Aspect_Grid_get_type_name(*args):
    """
    Aspect_Grid_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Aspect.Aspect_Grid_get_type_name(*args)

def Aspect_Grid_get_type_descriptor(*args):
    """
    Aspect_Grid_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Aspect.Aspect_Grid_get_type_descriptor(*args)

class Aspect_AspectLineDefinitionError(Standard.Standard_OutOfRange):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Aspect_AspectLineDefinitionError
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Aspect_AspectLineDefinitionError(self) 
            return h


    def __init__(self, *args):
        """
        __init__(Aspect_AspectLineDefinitionError self) -> Aspect_AspectLineDefinitionError
        __init__(Aspect_AspectLineDefinitionError self, Standard_CString const theMessage) -> Aspect_AspectLineDefinitionError

        :type theMessage: OCC.wrapper.Standard.Standard_CString

        """
        this = _Aspect.new_Aspect_AspectLineDefinitionError(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def NewInstance(*args):
        """
        NewInstance(Standard_CString const theMessage) -> Handle_Aspect_AspectLineDefinitionError

        :type theMessage: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Aspect.Handle_Aspect_AspectLineDefinitionError

        """
        return _Aspect.Aspect_AspectLineDefinitionError_NewInstance(*args)

    NewInstance = staticmethod(NewInstance)

    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Aspect.Aspect_AspectLineDefinitionError_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Aspect.Aspect_AspectLineDefinitionError_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Aspect.Aspect_AspectLineDefinitionError_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Aspect.delete_Aspect_AspectLineDefinitionError
Aspect_AspectLineDefinitionError_swigregister = _Aspect.Aspect_AspectLineDefinitionError_swigregister
Aspect_AspectLineDefinitionError_swigregister(Aspect_AspectLineDefinitionError)

def Aspect_AspectLineDefinitionError_NewInstance(*args):
    """
    Aspect_AspectLineDefinitionError_NewInstance(Standard_CString const theMessage) -> Handle_Aspect_AspectLineDefinitionError

    :type theMessage: OCC.wrapper.Standard.Standard_CString
    :rtype: OCC.wrapper.Aspect.Handle_Aspect_AspectLineDefinitionError

    """
    return _Aspect.Aspect_AspectLineDefinitionError_NewInstance(*args)

def Aspect_AspectLineDefinitionError_get_type_name(*args):
    """
    Aspect_AspectLineDefinitionError_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Aspect.Aspect_AspectLineDefinitionError_get_type_name(*args)

def Aspect_AspectLineDefinitionError_get_type_descriptor(*args):
    """
    Aspect_AspectLineDefinitionError_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Aspect.Aspect_AspectLineDefinitionError_get_type_descriptor(*args)

class Aspect_Background(object):
    """
    This class allows the definition of
    a window background.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Aspect_Background self) -> Aspect_Background
        __init__(Aspect_Background self, Quantity_Color AColor) -> Aspect_Background

        Creates a window background with the colour <AColor>.

        :type AColor: OCC.wrapper.Quantity.Quantity_Color

        """
        this = _Aspect.new_Aspect_Background(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def SetColor(self, *args):
        """
        SetColor(Aspect_Background self, Quantity_Color AColor)

        Modifies the colour of the window background <me>.

        :type AColor: OCC.wrapper.Quantity.Quantity_Color

        """
        return _Aspect.Aspect_Background_SetColor(self, *args)


    def Color(self, *args):
        """
        Color(Aspect_Background self) -> Quantity_Color

        Returns the colour of the window background <me>.

        :rtype: OCC.wrapper.Quantity.Quantity_Color

        """
        return _Aspect.Aspect_Background_Color(self, *args)

    __swig_destroy__ = _Aspect.delete_Aspect_Background
Aspect_Background_swigregister = _Aspect.Aspect_Background_swigregister
Aspect_Background_swigregister(Aspect_Background)

class Aspect_GraphicDeviceDefinitionError(Standard.Standard_OutOfRange):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Aspect_GraphicDeviceDefinitionError
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Aspect_GraphicDeviceDefinitionError(self) 
            return h


    def __init__(self, *args):
        """
        __init__(Aspect_GraphicDeviceDefinitionError self) -> Aspect_GraphicDeviceDefinitionError
        __init__(Aspect_GraphicDeviceDefinitionError self, Standard_CString const theMessage) -> Aspect_GraphicDeviceDefinitionError

        :type theMessage: OCC.wrapper.Standard.Standard_CString

        """
        this = _Aspect.new_Aspect_GraphicDeviceDefinitionError(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def NewInstance(*args):
        """
        NewInstance(Standard_CString const theMessage) -> Handle_Aspect_GraphicDeviceDefinitionError

        :type theMessage: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Aspect.Handle_Aspect_GraphicDeviceDefinitionError

        """
        return _Aspect.Aspect_GraphicDeviceDefinitionError_NewInstance(*args)

    NewInstance = staticmethod(NewInstance)

    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Aspect.Aspect_GraphicDeviceDefinitionError_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Aspect.Aspect_GraphicDeviceDefinitionError_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Aspect.Aspect_GraphicDeviceDefinitionError_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Aspect.delete_Aspect_GraphicDeviceDefinitionError
Aspect_GraphicDeviceDefinitionError_swigregister = _Aspect.Aspect_GraphicDeviceDefinitionError_swigregister
Aspect_GraphicDeviceDefinitionError_swigregister(Aspect_GraphicDeviceDefinitionError)

def Aspect_GraphicDeviceDefinitionError_NewInstance(*args):
    """
    Aspect_GraphicDeviceDefinitionError_NewInstance(Standard_CString const theMessage) -> Handle_Aspect_GraphicDeviceDefinitionError

    :type theMessage: OCC.wrapper.Standard.Standard_CString
    :rtype: OCC.wrapper.Aspect.Handle_Aspect_GraphicDeviceDefinitionError

    """
    return _Aspect.Aspect_GraphicDeviceDefinitionError_NewInstance(*args)

def Aspect_GraphicDeviceDefinitionError_get_type_name(*args):
    """
    Aspect_GraphicDeviceDefinitionError_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Aspect.Aspect_GraphicDeviceDefinitionError_get_type_name(*args)

def Aspect_GraphicDeviceDefinitionError_get_type_descriptor(*args):
    """
    Aspect_GraphicDeviceDefinitionError_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Aspect.Aspect_GraphicDeviceDefinitionError_get_type_descriptor(*args)

class Aspect_WindowDefinitionError(Standard.Standard_OutOfRange):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Aspect_WindowDefinitionError
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Aspect_WindowDefinitionError(self) 
            return h


    def __init__(self, *args):
        """
        __init__(Aspect_WindowDefinitionError self) -> Aspect_WindowDefinitionError
        __init__(Aspect_WindowDefinitionError self, Standard_CString const theMessage) -> Aspect_WindowDefinitionError

        :type theMessage: OCC.wrapper.Standard.Standard_CString

        """
        this = _Aspect.new_Aspect_WindowDefinitionError(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def NewInstance(*args):
        """
        NewInstance(Standard_CString const theMessage) -> Handle_Aspect_WindowDefinitionError

        :type theMessage: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Aspect.Handle_Aspect_WindowDefinitionError

        """
        return _Aspect.Aspect_WindowDefinitionError_NewInstance(*args)

    NewInstance = staticmethod(NewInstance)

    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Aspect.Aspect_WindowDefinitionError_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Aspect.Aspect_WindowDefinitionError_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Aspect.Aspect_WindowDefinitionError_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Aspect.delete_Aspect_WindowDefinitionError
Aspect_WindowDefinitionError_swigregister = _Aspect.Aspect_WindowDefinitionError_swigregister
Aspect_WindowDefinitionError_swigregister(Aspect_WindowDefinitionError)

def Aspect_WindowDefinitionError_NewInstance(*args):
    """
    Aspect_WindowDefinitionError_NewInstance(Standard_CString const theMessage) -> Handle_Aspect_WindowDefinitionError

    :type theMessage: OCC.wrapper.Standard.Standard_CString
    :rtype: OCC.wrapper.Aspect.Handle_Aspect_WindowDefinitionError

    """
    return _Aspect.Aspect_WindowDefinitionError_NewInstance(*args)

def Aspect_WindowDefinitionError_get_type_name(*args):
    """
    Aspect_WindowDefinitionError_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Aspect.Aspect_WindowDefinitionError_get_type_name(*args)

def Aspect_WindowDefinitionError_get_type_descriptor(*args):
    """
    Aspect_WindowDefinitionError_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Aspect.Aspect_WindowDefinitionError_get_type_descriptor(*args)

class Aspect_GradientBackground(Aspect_Background):
    """
    This class allows the definition of
    a window gradient background.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Aspect_GradientBackground self) -> Aspect_GradientBackground
        __init__(Aspect_GradientBackground self, Quantity_Color AColor1, Quantity_Color AColor2, Aspect_GradientFillMethod const AMethod=Aspect_GFM_HOR) -> Aspect_GradientBackground

        Creates a window gradient background with colours <AColor1, AColor2>.

        :type AColor1: OCC.wrapper.Quantity.Quantity_Color
        :type AColor2: OCC.wrapper.Quantity.Quantity_Color
        :type AMethod: OCC.wrapper.Aspect.Aspect_GradientFillMethod

        """
        this = _Aspect.new_Aspect_GradientBackground(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def SetColors(self, *args):
        """
        SetColors(Aspect_GradientBackground self, Quantity_Color AColor1, Quantity_Color AColor2, Aspect_GradientFillMethod const AMethod=Aspect_GFM_HOR)

        Modifies the colours of the window gradient background <me>.

        :type AColor1: OCC.wrapper.Quantity.Quantity_Color
        :type AColor2: OCC.wrapper.Quantity.Quantity_Color
        :type AMethod: OCC.wrapper.Aspect.Aspect_GradientFillMethod

        """
        return _Aspect.Aspect_GradientBackground_SetColors(self, *args)


    def Colors(self, *args):
        """
        Colors(Aspect_GradientBackground self, Quantity_Color AColor1, Quantity_Color AColor2)

        Returns colours of the window gradient background <me>.

        :type AColor1: OCC.wrapper.Quantity.Quantity_Color
        :type AColor2: OCC.wrapper.Quantity.Quantity_Color

        """
        return _Aspect.Aspect_GradientBackground_Colors(self, *args)


    def BgGradientFillMethod(self, *args):
        """
        BgGradientFillMethod(Aspect_GradientBackground self) -> Aspect_GradientFillMethod

        Returns the current gradient background fill mode.

        :rtype: OCC.wrapper.Aspect.Aspect_GradientFillMethod

        """
        return _Aspect.Aspect_GradientBackground_BgGradientFillMethod(self, *args)

    __swig_destroy__ = _Aspect.delete_Aspect_GradientBackground
Aspect_GradientBackground_swigregister = _Aspect.Aspect_GradientBackground_swigregister
Aspect_GradientBackground_swigregister(Aspect_GradientBackground)

class Aspect_CircularGrid(Aspect_Grid):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Aspect_CircularGrid
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Aspect_CircularGrid(self) 
            return h


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Aspect.Aspect_CircularGrid_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Aspect.Aspect_CircularGrid_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Aspect.Aspect_CircularGrid_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetRadiusStep(self, *args):
        """
        SetRadiusStep(Aspect_CircularGrid self, Standard_Real const aStep)

        defines the x step of the grid.

        :type aStep: float

        """
        return _Aspect.Aspect_CircularGrid_SetRadiusStep(self, *args)


    def SetDivisionNumber(self, *args):
        """
        SetDivisionNumber(Aspect_CircularGrid self, Standard_Integer const aNumber)

        defines the step of the grid.

        :type aNumber: int

        """
        return _Aspect.Aspect_CircularGrid_SetDivisionNumber(self, *args)


    def SetGridValues(self, *args):
        """
        SetGridValues(Aspect_CircularGrid self, Standard_Real const XOrigin, Standard_Real const YOrigin, Standard_Real const RadiusStep, Standard_Integer const DivisionNumber, Standard_Real const RotationAngle)

        :type XOrigin: float
        :type YOrigin: float
        :type RadiusStep: float
        :type DivisionNumber: int
        :type RotationAngle: float

        """
        return _Aspect.Aspect_CircularGrid_SetGridValues(self, *args)


    def Compute(self, *args):
        """
        Compute(Aspect_CircularGrid self, Standard_Real const X, Standard_Real const Y)

        returns the point of the grid the closest to the point X,Y

        :type X: float
        :type Y: float
        :type gridX: float
        :type gridY: float

        """
        return _Aspect.Aspect_CircularGrid_Compute(self, *args)


    def RadiusStep(self, *args):
        """
        RadiusStep(Aspect_CircularGrid self) -> Standard_Real

        returns the x step of the grid.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Aspect.Aspect_CircularGrid_RadiusStep(self, *args)


    def DivisionNumber(self, *args):
        """
        DivisionNumber(Aspect_CircularGrid self) -> Standard_Integer

        returns the x step of the grid.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Aspect.Aspect_CircularGrid_DivisionNumber(self, *args)


    def Init(self, *args):
        """Init(Aspect_CircularGrid self)"""
        return _Aspect.Aspect_CircularGrid_Init(self, *args)

    __swig_destroy__ = _Aspect.delete_Aspect_CircularGrid
Aspect_CircularGrid_swigregister = _Aspect.Aspect_CircularGrid_swigregister
Aspect_CircularGrid_swigregister(Aspect_CircularGrid)

def Aspect_CircularGrid_get_type_name(*args):
    """
    Aspect_CircularGrid_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Aspect.Aspect_CircularGrid_get_type_name(*args)

def Aspect_CircularGrid_get_type_descriptor(*args):
    """
    Aspect_CircularGrid_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Aspect.Aspect_CircularGrid_get_type_descriptor(*args)

class Aspect_AspectMarkerDefinitionError(Standard.Standard_OutOfRange):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Aspect_AspectMarkerDefinitionError
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Aspect_AspectMarkerDefinitionError(self) 
            return h


    def __init__(self, *args):
        """
        __init__(Aspect_AspectMarkerDefinitionError self) -> Aspect_AspectMarkerDefinitionError
        __init__(Aspect_AspectMarkerDefinitionError self, Standard_CString const theMessage) -> Aspect_AspectMarkerDefinitionError

        :type theMessage: OCC.wrapper.Standard.Standard_CString

        """
        this = _Aspect.new_Aspect_AspectMarkerDefinitionError(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def NewInstance(*args):
        """
        NewInstance(Standard_CString const theMessage) -> Handle_Aspect_AspectMarkerDefinitionError

        :type theMessage: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Aspect.Handle_Aspect_AspectMarkerDefinitionError

        """
        return _Aspect.Aspect_AspectMarkerDefinitionError_NewInstance(*args)

    NewInstance = staticmethod(NewInstance)

    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Aspect.Aspect_AspectMarkerDefinitionError_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Aspect.Aspect_AspectMarkerDefinitionError_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Aspect.Aspect_AspectMarkerDefinitionError_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Aspect.delete_Aspect_AspectMarkerDefinitionError
Aspect_AspectMarkerDefinitionError_swigregister = _Aspect.Aspect_AspectMarkerDefinitionError_swigregister
Aspect_AspectMarkerDefinitionError_swigregister(Aspect_AspectMarkerDefinitionError)

def Aspect_AspectMarkerDefinitionError_NewInstance(*args):
    """
    Aspect_AspectMarkerDefinitionError_NewInstance(Standard_CString const theMessage) -> Handle_Aspect_AspectMarkerDefinitionError

    :type theMessage: OCC.wrapper.Standard.Standard_CString
    :rtype: OCC.wrapper.Aspect.Handle_Aspect_AspectMarkerDefinitionError

    """
    return _Aspect.Aspect_AspectMarkerDefinitionError_NewInstance(*args)

def Aspect_AspectMarkerDefinitionError_get_type_name(*args):
    """
    Aspect_AspectMarkerDefinitionError_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Aspect.Aspect_AspectMarkerDefinitionError_get_type_name(*args)

def Aspect_AspectMarkerDefinitionError_get_type_descriptor(*args):
    """
    Aspect_AspectMarkerDefinitionError_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Aspect.Aspect_AspectMarkerDefinitionError_get_type_descriptor(*args)

class Handle_Aspect_NeutralWindow(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Aspect_NeutralWindow self)

        Nullify the handle


        """
        return _Aspect.Handle_Aspect_NeutralWindow_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Aspect_NeutralWindow self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Aspect.Handle_Aspect_NeutralWindow_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Aspect_NeutralWindow self, Aspect_NeutralWindow thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Aspect.Handle_Aspect_NeutralWindow_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Aspect_NeutralWindow self, Handle_Aspect_NeutralWindow theHandle) -> Handle_Aspect_NeutralWindow
        assign(Handle_Aspect_NeutralWindow self, Aspect_NeutralWindow thePtr) -> Handle_Aspect_NeutralWindow
        assign(Handle_Aspect_NeutralWindow self, Handle_Aspect_NeutralWindow theHandle) -> Handle_Aspect_NeutralWindow

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Aspect.Handle_Aspect_NeutralWindow_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Aspect_NeutralWindow self) -> Aspect_NeutralWindow

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Aspect.Handle_Aspect_NeutralWindow_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Aspect_NeutralWindow self) -> Aspect_NeutralWindow

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Aspect.Handle_Aspect_NeutralWindow___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Aspect_NeutralWindow self) -> Aspect_NeutralWindow

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Aspect.Handle_Aspect_NeutralWindow___ref__(self, *args)


    def __hash__(self):
        return _Aspect.Handle_Aspect_NeutralWindow___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Aspect.Handle_Aspect_NeutralWindow___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Aspect.new_Handle_Aspect_NeutralWindow(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Aspect.Handle_Aspect_NeutralWindow_DownCast)
    __swig_destroy__ = _Aspect.delete_Handle_Aspect_NeutralWindow

    def get_type_name(self, *args):
        """
        get_type_name(Handle_Aspect_NeutralWindow self) -> char const *

        :rtype: const char *

        """
        return _Aspect.Handle_Aspect_NeutralWindow_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Aspect.Handle_Aspect_NeutralWindow_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Aspect.Handle_Aspect_NeutralWindow_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def NativeFBConfig(self, *args):
        """
        NativeFBConfig(Handle_Aspect_NeutralWindow self) -> Aspect_FBConfig

        Return FBConfig.

        :rtype: OCC.wrapper.Aspect.Aspect_FBConfig

        """
        return _Aspect.Handle_Aspect_NeutralWindow_NativeFBConfig(self, *args)


    def IsMapped(self, *args):
        """
        IsMapped(Handle_Aspect_NeutralWindow self) -> Standard_Boolean

        Return true if window is not hidden.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Aspect.Handle_Aspect_NeutralWindow_IsMapped(self, *args)


    def Map(self, *args):
        """
        Map(Handle_Aspect_NeutralWindow self)

        Change window mapped flag to TRUE.


        """
        return _Aspect.Handle_Aspect_NeutralWindow_Map(self, *args)


    def Unmap(self, *args):
        """
        Unmap(Handle_Aspect_NeutralWindow self)

        Change window mapped flag to FALSE.


        """
        return _Aspect.Handle_Aspect_NeutralWindow_Unmap(self, *args)


    def DoResize(self, *args):
        """
        DoResize(Handle_Aspect_NeutralWindow self) -> Aspect_TypeOfResize

        Resize window - do nothing.

        :rtype: OCC.wrapper.Aspect.Aspect_TypeOfResize

        """
        return _Aspect.Handle_Aspect_NeutralWindow_DoResize(self, *args)


    def DoMapping(self, *args):
        """
        DoMapping(Handle_Aspect_NeutralWindow self) -> Standard_Boolean

        Map window - do nothing.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Aspect.Handle_Aspect_NeutralWindow_DoMapping(self, *args)


    def Ratio(self, *args):
        """
        Ratio(Handle_Aspect_NeutralWindow self) -> Standard_Real

        Returns window ratio equal to the physical width/height dimensions.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Aspect.Handle_Aspect_NeutralWindow_Ratio(self, *args)


    def Position(self, *args):
        """
        Position(Handle_Aspect_NeutralWindow self)

        Return the window position.

        :type theX1: int
        :type theY1: int
        :type theX2: int
        :type theY2: int

        """
        return _Aspect.Handle_Aspect_NeutralWindow_Position(self, *args)


    def SetPosition(self, *args):
        """
        SetPosition(Handle_Aspect_NeutralWindow self, Standard_Integer theX1, Standard_Integer theY1) -> Standard_Boolean
        SetPosition(Handle_Aspect_NeutralWindow self, Standard_Integer theX1, Standard_Integer theY1, Standard_Integer theX2, Standard_Integer theY2) -> Standard_Boolean

        Set the window position.
        @return true if position has been changed

        :type theX1: int
        :type theY1: int
        :type theX2: int
        :type theY2: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Aspect.Handle_Aspect_NeutralWindow_SetPosition(self, *args)


    def Size(self, *args):
        """
        Size(Handle_Aspect_NeutralWindow self)

        Return the window size.

        :type theWidth: int
        :type theHeight: int

        """
        return _Aspect.Handle_Aspect_NeutralWindow_Size(self, *args)


    def SetSize(self, *args):
        """
        SetSize(Handle_Aspect_NeutralWindow self, Standard_Integer const theWidth, Standard_Integer const theHeight) -> Standard_Boolean

        Set the window size.
        @return true if size has been changed

        :type theWidth: int
        :type theHeight: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Aspect.Handle_Aspect_NeutralWindow_SetSize(self, *args)


    def SetBackground(self, *args):
        """
        SetBackground(Handle_Aspect_NeutralWindow self, Aspect_Background ABack)
        SetBackground(Handle_Aspect_NeutralWindow self, Quantity_Color color)
        SetBackground(Handle_Aspect_NeutralWindow self, Aspect_GradientBackground ABackground)
        SetBackground(Handle_Aspect_NeutralWindow self, Quantity_Color theFirstColor, Quantity_Color theSecondColor, Aspect_GradientFillMethod const theFillMethod)

        Modifies the window gradient background.

        :type theFirstColor: OCC.wrapper.Quantity.Quantity_Color
        :type theSecondColor: OCC.wrapper.Quantity.Quantity_Color
        :type theFillMethod: OCC.wrapper.Aspect.Aspect_GradientFillMethod

        """
        return _Aspect.Handle_Aspect_NeutralWindow_SetBackground(self, *args)


    def Background(self, *args):
        """
        Background(Handle_Aspect_NeutralWindow self) -> Aspect_Background

        Returns the window background.

        :rtype: OCC.wrapper.Aspect.Aspect_Background

        """
        return _Aspect.Handle_Aspect_NeutralWindow_Background(self, *args)


    def BackgroundFillMethod(self, *args):
        """
        BackgroundFillMethod(Handle_Aspect_NeutralWindow self) -> Aspect_FillMethod

        Returns the current image background fill mode.

        :rtype: OCC.wrapper.Aspect.Aspect_FillMethod

        """
        return _Aspect.Handle_Aspect_NeutralWindow_BackgroundFillMethod(self, *args)


    def GradientBackground(self, *args):
        """
        GradientBackground(Handle_Aspect_NeutralWindow self) -> Aspect_GradientBackground

        Returns the window gradient background.

        :rtype: OCC.wrapper.Aspect.Aspect_GradientBackground

        """
        return _Aspect.Handle_Aspect_NeutralWindow_GradientBackground(self, *args)


    def IsVirtual(self, *args):
        """
        IsVirtual(Handle_Aspect_NeutralWindow self) -> Standard_Boolean

        Returns True if the window <me> is virtual

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Aspect.Handle_Aspect_NeutralWindow_IsVirtual(self, *args)


    def SetVirtual(self, *args):
        """
        SetVirtual(Handle_Aspect_NeutralWindow self, Standard_Boolean const theVirtual)

        Setup the virtual state

        :type theVirtual: bool

        """
        return _Aspect.Handle_Aspect_NeutralWindow_SetVirtual(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_Aspect_NeutralWindow self)

        Memory deallocator for transient classes


        """
        return _Aspect.Handle_Aspect_NeutralWindow_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Aspect_NeutralWindow self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Aspect_NeutralWindow self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Aspect.Handle_Aspect_NeutralWindow_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Aspect_NeutralWindow self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Aspect_NeutralWindow self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Aspect.Handle_Aspect_NeutralWindow_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Aspect_NeutralWindow self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Aspect.Handle_Aspect_NeutralWindow_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Aspect_NeutralWindow self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Aspect.Handle_Aspect_NeutralWindow_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Aspect_NeutralWindow self)

        Increments the reference counter of this object


        """
        return _Aspect.Handle_Aspect_NeutralWindow_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Aspect_NeutralWindow self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Aspect.Handle_Aspect_NeutralWindow_DecrementRefCounter(self, *args)

Handle_Aspect_NeutralWindow_swigregister = _Aspect.Handle_Aspect_NeutralWindow_swigregister
Handle_Aspect_NeutralWindow_swigregister(Handle_Aspect_NeutralWindow)

def Handle_Aspect_NeutralWindow_DownCast(thing):
    return _Aspect.Handle_Aspect_NeutralWindow_DownCast(thing)
Handle_Aspect_NeutralWindow_DownCast = _Aspect.Handle_Aspect_NeutralWindow_DownCast

class Handle_Aspect_AspectLineDefinitionError(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Aspect_AspectLineDefinitionError self)

        Nullify the handle


        """
        return _Aspect.Handle_Aspect_AspectLineDefinitionError_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Aspect_AspectLineDefinitionError self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Aspect.Handle_Aspect_AspectLineDefinitionError_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Aspect_AspectLineDefinitionError self, Aspect_AspectLineDefinitionError thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Aspect.Handle_Aspect_AspectLineDefinitionError_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Aspect_AspectLineDefinitionError self, Handle_Aspect_AspectLineDefinitionError theHandle) -> Handle_Aspect_AspectLineDefinitionError
        assign(Handle_Aspect_AspectLineDefinitionError self, Aspect_AspectLineDefinitionError thePtr) -> Handle_Aspect_AspectLineDefinitionError
        assign(Handle_Aspect_AspectLineDefinitionError self, Handle_Aspect_AspectLineDefinitionError theHandle) -> Handle_Aspect_AspectLineDefinitionError

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Aspect.Handle_Aspect_AspectLineDefinitionError_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Aspect_AspectLineDefinitionError self) -> Aspect_AspectLineDefinitionError

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Aspect.Handle_Aspect_AspectLineDefinitionError_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Aspect_AspectLineDefinitionError self) -> Aspect_AspectLineDefinitionError

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Aspect.Handle_Aspect_AspectLineDefinitionError___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Aspect_AspectLineDefinitionError self) -> Aspect_AspectLineDefinitionError

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Aspect.Handle_Aspect_AspectLineDefinitionError___ref__(self, *args)


    def __hash__(self):
        return _Aspect.Handle_Aspect_AspectLineDefinitionError___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Aspect.Handle_Aspect_AspectLineDefinitionError___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Aspect.new_Handle_Aspect_AspectLineDefinitionError(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Aspect.Handle_Aspect_AspectLineDefinitionError_DownCast)
    __swig_destroy__ = _Aspect.delete_Handle_Aspect_AspectLineDefinitionError

    def NewInstance(self, *args):
        """
        NewInstance(Handle_Aspect_AspectLineDefinitionError self, Standard_CString const theMessage) -> Handle_Aspect_AspectLineDefinitionError

        :type theMessage: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Aspect.Handle_Aspect_AspectLineDefinitionError

        """
        return _Aspect.Handle_Aspect_AspectLineDefinitionError_NewInstance(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Aspect_AspectLineDefinitionError self) -> char const *

        :rtype: const char *

        """
        return _Aspect.Handle_Aspect_AspectLineDefinitionError_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Aspect.Handle_Aspect_AspectLineDefinitionError_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Aspect.Handle_Aspect_AspectLineDefinitionError_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Print(self, *args):
        """
        Print(Handle_Aspect_AspectLineDefinitionError self, Standard_OStream & s)

        Prints on the stream <s> the exception name followed by
        the error message.
        Level: Advanced
        Warning:
        The operator "OStream& operator<< (Standard_OStream&,
        Handle(Standard_Failure)&)"
        is implemented. (This operator uses the method Print)

        :type s: OCC.wrapper.Standard.Standard_OStream

        """
        return _Aspect.Handle_Aspect_AspectLineDefinitionError_Print(self, *args)


    def GetMessageString(self, *args):
        """
        GetMessageString(Handle_Aspect_AspectLineDefinitionError self) -> Standard_CString

        Returns error message

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _Aspect.Handle_Aspect_AspectLineDefinitionError_GetMessageString(self, *args)


    def SetMessageString(self, *args):
        """
        SetMessageString(Handle_Aspect_AspectLineDefinitionError self, Standard_CString const aMessage)

        Sets error message

        :type aMessage: OCC.wrapper.Standard.Standard_CString

        """
        return _Aspect.Handle_Aspect_AspectLineDefinitionError_SetMessageString(self, *args)


    def Reraise(self, *args):
        """
        Reraise(Handle_Aspect_AspectLineDefinitionError self)
        Reraise(Handle_Aspect_AspectLineDefinitionError self, Standard_CString const aMessage)
        Reraise(Handle_Aspect_AspectLineDefinitionError self, Standard_SStream const & aReason)

        Reraises a caught exception and changes its error message.

        :type aReason: OCC.wrapper.Standard.Standard_SStream

        """
        return _Aspect.Handle_Aspect_AspectLineDefinitionError_Reraise(self, *args)


    def Jump(self, *args):
        """
        Jump(Handle_Aspect_AspectLineDefinitionError self)

        Used to throw CASCADE exception from C signal handler.
        On platforms that do not allow throwing C++ exceptions
        from this handler (e.g. Linux), uses longjump to get to
        the current active signal handler, and only then is
        converted to C++ exception.


        """
        return _Aspect.Handle_Aspect_AspectLineDefinitionError_Jump(self, *args)


    def Caught(self, *args):
        """
        Caught(Handle_Aspect_AspectLineDefinitionError self) -> Handle_Standard_Failure

        Returns the last caught exception.
        Needed when exceptions are emulated by C longjumps,
        in other cases is also provided for compatibility.

        :rtype: OCC.wrapper.Standard.Handle_Standard_Failure

        """
        return _Aspect.Handle_Aspect_AspectLineDefinitionError_Caught(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_Aspect_AspectLineDefinitionError self)

        Memory deallocator for transient classes


        """
        return _Aspect.Handle_Aspect_AspectLineDefinitionError_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Aspect_AspectLineDefinitionError self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Aspect_AspectLineDefinitionError self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Aspect.Handle_Aspect_AspectLineDefinitionError_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Aspect_AspectLineDefinitionError self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Aspect_AspectLineDefinitionError self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Aspect.Handle_Aspect_AspectLineDefinitionError_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Aspect_AspectLineDefinitionError self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Aspect.Handle_Aspect_AspectLineDefinitionError_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Aspect_AspectLineDefinitionError self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Aspect.Handle_Aspect_AspectLineDefinitionError_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Aspect_AspectLineDefinitionError self)

        Increments the reference counter of this object


        """
        return _Aspect.Handle_Aspect_AspectLineDefinitionError_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Aspect_AspectLineDefinitionError self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Aspect.Handle_Aspect_AspectLineDefinitionError_DecrementRefCounter(self, *args)

Handle_Aspect_AspectLineDefinitionError_swigregister = _Aspect.Handle_Aspect_AspectLineDefinitionError_swigregister
Handle_Aspect_AspectLineDefinitionError_swigregister(Handle_Aspect_AspectLineDefinitionError)

def Handle_Aspect_AspectLineDefinitionError_DownCast(thing):
    return _Aspect.Handle_Aspect_AspectLineDefinitionError_DownCast(thing)
Handle_Aspect_AspectLineDefinitionError_DownCast = _Aspect.Handle_Aspect_AspectLineDefinitionError_DownCast

class Aspect_WindowError(Standard.Standard_OutOfRange):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Aspect_WindowError
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Aspect_WindowError(self) 
            return h


    def __init__(self, *args):
        """
        __init__(Aspect_WindowError self) -> Aspect_WindowError
        __init__(Aspect_WindowError self, Standard_CString const theMessage) -> Aspect_WindowError

        :type theMessage: OCC.wrapper.Standard.Standard_CString

        """
        this = _Aspect.new_Aspect_WindowError(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def NewInstance(*args):
        """
        NewInstance(Standard_CString const theMessage) -> Handle_Aspect_WindowError

        :type theMessage: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Aspect.Handle_Aspect_WindowError

        """
        return _Aspect.Aspect_WindowError_NewInstance(*args)

    NewInstance = staticmethod(NewInstance)

    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Aspect.Aspect_WindowError_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Aspect.Aspect_WindowError_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Aspect.Aspect_WindowError_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Aspect.delete_Aspect_WindowError
Aspect_WindowError_swigregister = _Aspect.Aspect_WindowError_swigregister
Aspect_WindowError_swigregister(Aspect_WindowError)

def Aspect_WindowError_NewInstance(*args):
    """
    Aspect_WindowError_NewInstance(Standard_CString const theMessage) -> Handle_Aspect_WindowError

    :type theMessage: OCC.wrapper.Standard.Standard_CString
    :rtype: OCC.wrapper.Aspect.Handle_Aspect_WindowError

    """
    return _Aspect.Aspect_WindowError_NewInstance(*args)

def Aspect_WindowError_get_type_name(*args):
    """
    Aspect_WindowError_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Aspect.Aspect_WindowError_get_type_name(*args)

def Aspect_WindowError_get_type_descriptor(*args):
    """
    Aspect_WindowError_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Aspect.Aspect_WindowError_get_type_descriptor(*args)

class Aspect_DisplayConnection(Standard.Standard_Transient):
    """
    This class creates and provides connection with X server.
    Raises exception if can not connect to X server.
    On Windows and Mac OS X (in case when Cocoa used) platforms this class do nothing.
    WARRNING: Do not close display connection manualy!
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Aspect_DisplayConnection
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Aspect_DisplayConnection(self) 
            return h


    def __init__(self, *args):
        """
        __init__(Aspect_DisplayConnection self) -> Aspect_DisplayConnection

        Default constructor. Creates connection with display name taken from "DISPLAY" environment variable


        """
        this = _Aspect.new_Aspect_DisplayConnection(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Aspect.Aspect_DisplayConnection_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Aspect.Aspect_DisplayConnection_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Aspect.Aspect_DisplayConnection_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Aspect.delete_Aspect_DisplayConnection
Aspect_DisplayConnection_swigregister = _Aspect.Aspect_DisplayConnection_swigregister
Aspect_DisplayConnection_swigregister(Aspect_DisplayConnection)

def Aspect_DisplayConnection_get_type_name(*args):
    """
    Aspect_DisplayConnection_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Aspect.Aspect_DisplayConnection_get_type_name(*args)

def Aspect_DisplayConnection_get_type_descriptor(*args):
    """
    Aspect_DisplayConnection_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Aspect.Aspect_DisplayConnection_get_type_descriptor(*args)

class Handle_Aspect_AspectMarkerDefinitionError(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Aspect_AspectMarkerDefinitionError self)

        Nullify the handle


        """
        return _Aspect.Handle_Aspect_AspectMarkerDefinitionError_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Aspect_AspectMarkerDefinitionError self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Aspect.Handle_Aspect_AspectMarkerDefinitionError_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Aspect_AspectMarkerDefinitionError self, Aspect_AspectMarkerDefinitionError thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Aspect.Handle_Aspect_AspectMarkerDefinitionError_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Aspect_AspectMarkerDefinitionError self, Handle_Aspect_AspectMarkerDefinitionError theHandle) -> Handle_Aspect_AspectMarkerDefinitionError
        assign(Handle_Aspect_AspectMarkerDefinitionError self, Aspect_AspectMarkerDefinitionError thePtr) -> Handle_Aspect_AspectMarkerDefinitionError
        assign(Handle_Aspect_AspectMarkerDefinitionError self, Handle_Aspect_AspectMarkerDefinitionError theHandle) -> Handle_Aspect_AspectMarkerDefinitionError

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Aspect.Handle_Aspect_AspectMarkerDefinitionError_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Aspect_AspectMarkerDefinitionError self) -> Aspect_AspectMarkerDefinitionError

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Aspect.Handle_Aspect_AspectMarkerDefinitionError_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Aspect_AspectMarkerDefinitionError self) -> Aspect_AspectMarkerDefinitionError

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Aspect.Handle_Aspect_AspectMarkerDefinitionError___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Aspect_AspectMarkerDefinitionError self) -> Aspect_AspectMarkerDefinitionError

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Aspect.Handle_Aspect_AspectMarkerDefinitionError___ref__(self, *args)


    def __hash__(self):
        return _Aspect.Handle_Aspect_AspectMarkerDefinitionError___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Aspect.Handle_Aspect_AspectMarkerDefinitionError___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Aspect.new_Handle_Aspect_AspectMarkerDefinitionError(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Aspect.Handle_Aspect_AspectMarkerDefinitionError_DownCast)
    __swig_destroy__ = _Aspect.delete_Handle_Aspect_AspectMarkerDefinitionError

    def NewInstance(self, *args):
        """
        NewInstance(Handle_Aspect_AspectMarkerDefinitionError self, Standard_CString const theMessage) -> Handle_Aspect_AspectMarkerDefinitionError

        :type theMessage: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Aspect.Handle_Aspect_AspectMarkerDefinitionError

        """
        return _Aspect.Handle_Aspect_AspectMarkerDefinitionError_NewInstance(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Aspect_AspectMarkerDefinitionError self) -> char const *

        :rtype: const char *

        """
        return _Aspect.Handle_Aspect_AspectMarkerDefinitionError_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Aspect.Handle_Aspect_AspectMarkerDefinitionError_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Aspect.Handle_Aspect_AspectMarkerDefinitionError_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Print(self, *args):
        """
        Print(Handle_Aspect_AspectMarkerDefinitionError self, Standard_OStream & s)

        Prints on the stream <s> the exception name followed by
        the error message.
        Level: Advanced
        Warning:
        The operator "OStream& operator<< (Standard_OStream&,
        Handle(Standard_Failure)&)"
        is implemented. (This operator uses the method Print)

        :type s: OCC.wrapper.Standard.Standard_OStream

        """
        return _Aspect.Handle_Aspect_AspectMarkerDefinitionError_Print(self, *args)


    def GetMessageString(self, *args):
        """
        GetMessageString(Handle_Aspect_AspectMarkerDefinitionError self) -> Standard_CString

        Returns error message

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _Aspect.Handle_Aspect_AspectMarkerDefinitionError_GetMessageString(self, *args)


    def SetMessageString(self, *args):
        """
        SetMessageString(Handle_Aspect_AspectMarkerDefinitionError self, Standard_CString const aMessage)

        Sets error message

        :type aMessage: OCC.wrapper.Standard.Standard_CString

        """
        return _Aspect.Handle_Aspect_AspectMarkerDefinitionError_SetMessageString(self, *args)


    def Reraise(self, *args):
        """
        Reraise(Handle_Aspect_AspectMarkerDefinitionError self)
        Reraise(Handle_Aspect_AspectMarkerDefinitionError self, Standard_CString const aMessage)
        Reraise(Handle_Aspect_AspectMarkerDefinitionError self, Standard_SStream const & aReason)

        Reraises a caught exception and changes its error message.

        :type aReason: OCC.wrapper.Standard.Standard_SStream

        """
        return _Aspect.Handle_Aspect_AspectMarkerDefinitionError_Reraise(self, *args)


    def Jump(self, *args):
        """
        Jump(Handle_Aspect_AspectMarkerDefinitionError self)

        Used to throw CASCADE exception from C signal handler.
        On platforms that do not allow throwing C++ exceptions
        from this handler (e.g. Linux), uses longjump to get to
        the current active signal handler, and only then is
        converted to C++ exception.


        """
        return _Aspect.Handle_Aspect_AspectMarkerDefinitionError_Jump(self, *args)


    def Caught(self, *args):
        """
        Caught(Handle_Aspect_AspectMarkerDefinitionError self) -> Handle_Standard_Failure

        Returns the last caught exception.
        Needed when exceptions are emulated by C longjumps,
        in other cases is also provided for compatibility.

        :rtype: OCC.wrapper.Standard.Handle_Standard_Failure

        """
        return _Aspect.Handle_Aspect_AspectMarkerDefinitionError_Caught(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_Aspect_AspectMarkerDefinitionError self)

        Memory deallocator for transient classes


        """
        return _Aspect.Handle_Aspect_AspectMarkerDefinitionError_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Aspect_AspectMarkerDefinitionError self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Aspect_AspectMarkerDefinitionError self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Aspect.Handle_Aspect_AspectMarkerDefinitionError_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Aspect_AspectMarkerDefinitionError self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Aspect_AspectMarkerDefinitionError self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Aspect.Handle_Aspect_AspectMarkerDefinitionError_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Aspect_AspectMarkerDefinitionError self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Aspect.Handle_Aspect_AspectMarkerDefinitionError_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Aspect_AspectMarkerDefinitionError self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Aspect.Handle_Aspect_AspectMarkerDefinitionError_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Aspect_AspectMarkerDefinitionError self)

        Increments the reference counter of this object


        """
        return _Aspect.Handle_Aspect_AspectMarkerDefinitionError_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Aspect_AspectMarkerDefinitionError self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Aspect.Handle_Aspect_AspectMarkerDefinitionError_DecrementRefCounter(self, *args)

Handle_Aspect_AspectMarkerDefinitionError_swigregister = _Aspect.Handle_Aspect_AspectMarkerDefinitionError_swigregister
Handle_Aspect_AspectMarkerDefinitionError_swigregister(Handle_Aspect_AspectMarkerDefinitionError)

def Handle_Aspect_AspectMarkerDefinitionError_DownCast(thing):
    return _Aspect.Handle_Aspect_AspectMarkerDefinitionError_DownCast(thing)
Handle_Aspect_AspectMarkerDefinitionError_DownCast = _Aspect.Handle_Aspect_AspectMarkerDefinitionError_DownCast

class Aspect_AspectFillAreaDefinitionError(Standard.Standard_OutOfRange):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Aspect_AspectFillAreaDefinitionError
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Aspect_AspectFillAreaDefinitionError(self) 
            return h


    def __init__(self, *args):
        """
        __init__(Aspect_AspectFillAreaDefinitionError self) -> Aspect_AspectFillAreaDefinitionError
        __init__(Aspect_AspectFillAreaDefinitionError self, Standard_CString const theMessage) -> Aspect_AspectFillAreaDefinitionError

        :type theMessage: OCC.wrapper.Standard.Standard_CString

        """
        this = _Aspect.new_Aspect_AspectFillAreaDefinitionError(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def NewInstance(*args):
        """
        NewInstance(Standard_CString const theMessage) -> Handle_Aspect_AspectFillAreaDefinitionError

        :type theMessage: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Aspect.Handle_Aspect_AspectFillAreaDefinitionError

        """
        return _Aspect.Aspect_AspectFillAreaDefinitionError_NewInstance(*args)

    NewInstance = staticmethod(NewInstance)

    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Aspect.Aspect_AspectFillAreaDefinitionError_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Aspect.Aspect_AspectFillAreaDefinitionError_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Aspect.Aspect_AspectFillAreaDefinitionError_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Aspect.delete_Aspect_AspectFillAreaDefinitionError
Aspect_AspectFillAreaDefinitionError_swigregister = _Aspect.Aspect_AspectFillAreaDefinitionError_swigregister
Aspect_AspectFillAreaDefinitionError_swigregister(Aspect_AspectFillAreaDefinitionError)

def Aspect_AspectFillAreaDefinitionError_NewInstance(*args):
    """
    Aspect_AspectFillAreaDefinitionError_NewInstance(Standard_CString const theMessage) -> Handle_Aspect_AspectFillAreaDefinitionError

    :type theMessage: OCC.wrapper.Standard.Standard_CString
    :rtype: OCC.wrapper.Aspect.Handle_Aspect_AspectFillAreaDefinitionError

    """
    return _Aspect.Aspect_AspectFillAreaDefinitionError_NewInstance(*args)

def Aspect_AspectFillAreaDefinitionError_get_type_name(*args):
    """
    Aspect_AspectFillAreaDefinitionError_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Aspect.Aspect_AspectFillAreaDefinitionError_get_type_name(*args)

def Aspect_AspectFillAreaDefinitionError_get_type_descriptor(*args):
    """
    Aspect_AspectFillAreaDefinitionError_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Aspect.Aspect_AspectFillAreaDefinitionError_get_type_descriptor(*args)

class Aspect_RectangularGrid(Aspect_Grid):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Aspect_RectangularGrid
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Aspect_RectangularGrid(self) 
            return h


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Aspect.Aspect_RectangularGrid_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Aspect.Aspect_RectangularGrid_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Aspect.Aspect_RectangularGrid_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetXStep(self, *args):
        """
        SetXStep(Aspect_RectangularGrid self, Standard_Real const aStep)

        defines the x step of the grid.

        :type aStep: float

        """
        return _Aspect.Aspect_RectangularGrid_SetXStep(self, *args)


    def SetYStep(self, *args):
        """
        SetYStep(Aspect_RectangularGrid self, Standard_Real const aStep)

        defines the y step of the grid.

        :type aStep: float

        """
        return _Aspect.Aspect_RectangularGrid_SetYStep(self, *args)


    def SetAngle(self, *args):
        """
        SetAngle(Aspect_RectangularGrid self, Standard_Real const anAngle1, Standard_Real const anAngle2)

        defines the angle of the second network
        the fist angle is given relatively to the horizontal.
        the second angle is given relatively to the vertical.

        :type anAngle1: float
        :type anAngle2: float

        """
        return _Aspect.Aspect_RectangularGrid_SetAngle(self, *args)


    def SetGridValues(self, *args):
        """
        SetGridValues(Aspect_RectangularGrid self, Standard_Real const XOrigin, Standard_Real const YOrigin, Standard_Real const XStep, Standard_Real const YStep, Standard_Real const RotationAngle)

        :type XOrigin: float
        :type YOrigin: float
        :type XStep: float
        :type YStep: float
        :type RotationAngle: float

        """
        return _Aspect.Aspect_RectangularGrid_SetGridValues(self, *args)


    def Compute(self, *args):
        """
        Compute(Aspect_RectangularGrid self, Standard_Real const X, Standard_Real const Y)

        returns the point of the grid the closest to the point X,Y

        :type X: float
        :type Y: float
        :type gridX: float
        :type gridY: float

        """
        return _Aspect.Aspect_RectangularGrid_Compute(self, *args)


    def XStep(self, *args):
        """
        XStep(Aspect_RectangularGrid self) -> Standard_Real

        returns the x step of the grid.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Aspect.Aspect_RectangularGrid_XStep(self, *args)


    def YStep(self, *args):
        """
        YStep(Aspect_RectangularGrid self) -> Standard_Real

        returns the x step of the grid.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Aspect.Aspect_RectangularGrid_YStep(self, *args)


    def FirstAngle(self, *args):
        """
        FirstAngle(Aspect_RectangularGrid self) -> Standard_Real

        returns the x Angle of the grid, relatively to the horizontal.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Aspect.Aspect_RectangularGrid_FirstAngle(self, *args)


    def SecondAngle(self, *args):
        """
        SecondAngle(Aspect_RectangularGrid self) -> Standard_Real

        returns the y Angle of the grid, relatively to the vertical.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Aspect.Aspect_RectangularGrid_SecondAngle(self, *args)


    def Init(self, *args):
        """Init(Aspect_RectangularGrid self)"""
        return _Aspect.Aspect_RectangularGrid_Init(self, *args)

    __swig_destroy__ = _Aspect.delete_Aspect_RectangularGrid
Aspect_RectangularGrid_swigregister = _Aspect.Aspect_RectangularGrid_swigregister
Aspect_RectangularGrid_swigregister(Aspect_RectangularGrid)

def Aspect_RectangularGrid_get_type_name(*args):
    """
    Aspect_RectangularGrid_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Aspect.Aspect_RectangularGrid_get_type_name(*args)

def Aspect_RectangularGrid_get_type_descriptor(*args):
    """
    Aspect_RectangularGrid_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Aspect.Aspect_RectangularGrid_get_type_descriptor(*args)

class Aspect_DisplayConnectionDefinitionError(Standard.Standard_OutOfRange):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Aspect_DisplayConnectionDefinitionError
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Aspect_DisplayConnectionDefinitionError(self) 
            return h


    def __init__(self, *args):
        """
        __init__(Aspect_DisplayConnectionDefinitionError self) -> Aspect_DisplayConnectionDefinitionError
        __init__(Aspect_DisplayConnectionDefinitionError self, Standard_CString const theMessage) -> Aspect_DisplayConnectionDefinitionError

        :type theMessage: OCC.wrapper.Standard.Standard_CString

        """
        this = _Aspect.new_Aspect_DisplayConnectionDefinitionError(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def NewInstance(*args):
        """
        NewInstance(Standard_CString const theMessage) -> Handle_Aspect_DisplayConnectionDefinitionError

        :type theMessage: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Aspect.Handle_Aspect_DisplayConnectionDefinitionError

        """
        return _Aspect.Aspect_DisplayConnectionDefinitionError_NewInstance(*args)

    NewInstance = staticmethod(NewInstance)

    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Aspect.Aspect_DisplayConnectionDefinitionError_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Aspect.Aspect_DisplayConnectionDefinitionError_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Aspect.Aspect_DisplayConnectionDefinitionError_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Aspect.delete_Aspect_DisplayConnectionDefinitionError
Aspect_DisplayConnectionDefinitionError_swigregister = _Aspect.Aspect_DisplayConnectionDefinitionError_swigregister
Aspect_DisplayConnectionDefinitionError_swigregister(Aspect_DisplayConnectionDefinitionError)

def Aspect_DisplayConnectionDefinitionError_NewInstance(*args):
    """
    Aspect_DisplayConnectionDefinitionError_NewInstance(Standard_CString const theMessage) -> Handle_Aspect_DisplayConnectionDefinitionError

    :type theMessage: OCC.wrapper.Standard.Standard_CString
    :rtype: OCC.wrapper.Aspect.Handle_Aspect_DisplayConnectionDefinitionError

    """
    return _Aspect.Aspect_DisplayConnectionDefinitionError_NewInstance(*args)

def Aspect_DisplayConnectionDefinitionError_get_type_name(*args):
    """
    Aspect_DisplayConnectionDefinitionError_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Aspect.Aspect_DisplayConnectionDefinitionError_get_type_name(*args)

def Aspect_DisplayConnectionDefinitionError_get_type_descriptor(*args):
    """
    Aspect_DisplayConnectionDefinitionError_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Aspect.Aspect_DisplayConnectionDefinitionError_get_type_descriptor(*args)

class Handle_Aspect_RectangularGrid(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Aspect_RectangularGrid self)

        Nullify the handle


        """
        return _Aspect.Handle_Aspect_RectangularGrid_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Aspect_RectangularGrid self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Aspect.Handle_Aspect_RectangularGrid_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Aspect_RectangularGrid self, Aspect_RectangularGrid thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Aspect.Handle_Aspect_RectangularGrid_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Aspect_RectangularGrid self, Handle_Aspect_RectangularGrid theHandle) -> Handle_Aspect_RectangularGrid
        assign(Handle_Aspect_RectangularGrid self, Aspect_RectangularGrid thePtr) -> Handle_Aspect_RectangularGrid
        assign(Handle_Aspect_RectangularGrid self, Handle_Aspect_RectangularGrid theHandle) -> Handle_Aspect_RectangularGrid

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Aspect.Handle_Aspect_RectangularGrid_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Aspect_RectangularGrid self) -> Aspect_RectangularGrid

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Aspect.Handle_Aspect_RectangularGrid_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Aspect_RectangularGrid self) -> Aspect_RectangularGrid

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Aspect.Handle_Aspect_RectangularGrid___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Aspect_RectangularGrid self) -> Aspect_RectangularGrid

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Aspect.Handle_Aspect_RectangularGrid___ref__(self, *args)


    def __hash__(self):
        return _Aspect.Handle_Aspect_RectangularGrid___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Aspect.Handle_Aspect_RectangularGrid___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Aspect.new_Handle_Aspect_RectangularGrid(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Aspect.Handle_Aspect_RectangularGrid_DownCast)
    __swig_destroy__ = _Aspect.delete_Handle_Aspect_RectangularGrid

    def get_type_name(self, *args):
        """
        get_type_name(Handle_Aspect_RectangularGrid self) -> char const *

        :rtype: const char *

        """
        return _Aspect.Handle_Aspect_RectangularGrid_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Aspect.Handle_Aspect_RectangularGrid_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Aspect.Handle_Aspect_RectangularGrid_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetXStep(self, *args):
        """
        SetXStep(Handle_Aspect_RectangularGrid self, Standard_Real const aStep)

        defines the x step of the grid.

        :type aStep: float

        """
        return _Aspect.Handle_Aspect_RectangularGrid_SetXStep(self, *args)


    def SetYStep(self, *args):
        """
        SetYStep(Handle_Aspect_RectangularGrid self, Standard_Real const aStep)

        defines the y step of the grid.

        :type aStep: float

        """
        return _Aspect.Handle_Aspect_RectangularGrid_SetYStep(self, *args)


    def SetAngle(self, *args):
        """
        SetAngle(Handle_Aspect_RectangularGrid self, Standard_Real const anAngle1, Standard_Real const anAngle2)

        defines the angle of the second network
        the fist angle is given relatively to the horizontal.
        the second angle is given relatively to the vertical.

        :type anAngle1: float
        :type anAngle2: float

        """
        return _Aspect.Handle_Aspect_RectangularGrid_SetAngle(self, *args)


    def SetGridValues(self, *args):
        """
        SetGridValues(Handle_Aspect_RectangularGrid self, Standard_Real const XOrigin, Standard_Real const YOrigin, Standard_Real const XStep, Standard_Real const YStep, Standard_Real const RotationAngle)

        :type XOrigin: float
        :type YOrigin: float
        :type XStep: float
        :type YStep: float
        :type RotationAngle: float

        """
        return _Aspect.Handle_Aspect_RectangularGrid_SetGridValues(self, *args)


    def Compute(self, *args):
        """
        Compute(Handle_Aspect_RectangularGrid self, Standard_Real const X, Standard_Real const Y)

        returns the point of the grid the closest to the point X,Y

        :type X: float
        :type Y: float
        :type gridX: float
        :type gridY: float

        """
        return _Aspect.Handle_Aspect_RectangularGrid_Compute(self, *args)


    def XStep(self, *args):
        """
        XStep(Handle_Aspect_RectangularGrid self) -> Standard_Real

        returns the x step of the grid.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Aspect.Handle_Aspect_RectangularGrid_XStep(self, *args)


    def YStep(self, *args):
        """
        YStep(Handle_Aspect_RectangularGrid self) -> Standard_Real

        returns the x step of the grid.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Aspect.Handle_Aspect_RectangularGrid_YStep(self, *args)


    def FirstAngle(self, *args):
        """
        FirstAngle(Handle_Aspect_RectangularGrid self) -> Standard_Real

        returns the x Angle of the grid, relatively to the horizontal.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Aspect.Handle_Aspect_RectangularGrid_FirstAngle(self, *args)


    def SecondAngle(self, *args):
        """
        SecondAngle(Handle_Aspect_RectangularGrid self) -> Standard_Real

        returns the y Angle of the grid, relatively to the vertical.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Aspect.Handle_Aspect_RectangularGrid_SecondAngle(self, *args)


    def Init(self, *args):
        """Init(Handle_Aspect_RectangularGrid self)"""
        return _Aspect.Handle_Aspect_RectangularGrid_Init(self, *args)


    def SetXOrigin(self, *args):
        """
        SetXOrigin(Handle_Aspect_RectangularGrid self, Standard_Real const anOrigin)

        defines the x Origin of the grid.

        :type anOrigin: float

        """
        return _Aspect.Handle_Aspect_RectangularGrid_SetXOrigin(self, *args)


    def SetYOrigin(self, *args):
        """
        SetYOrigin(Handle_Aspect_RectangularGrid self, Standard_Real const anOrigin)

        defines the y Origin of the grid.

        :type anOrigin: float

        """
        return _Aspect.Handle_Aspect_RectangularGrid_SetYOrigin(self, *args)


    def SetRotationAngle(self, *args):
        """
        SetRotationAngle(Handle_Aspect_RectangularGrid self, Standard_Real const anAngle)

        defines the orientation of the grid.

        :type anAngle: float

        """
        return _Aspect.Handle_Aspect_RectangularGrid_SetRotationAngle(self, *args)


    def Rotate(self, *args):
        """
        Rotate(Handle_Aspect_RectangularGrid self, Standard_Real const anAngle)

        Rotate the grid from a relative angle.

        :type anAngle: float

        """
        return _Aspect.Handle_Aspect_RectangularGrid_Rotate(self, *args)


    def Translate(self, *args):
        """
        Translate(Handle_Aspect_RectangularGrid self, Standard_Real const aDx, Standard_Real const aDy)

        Translate the grid from a relative distance.

        :type aDx: float
        :type aDy: float

        """
        return _Aspect.Handle_Aspect_RectangularGrid_Translate(self, *args)


    def SetColors(self, *args):
        """
        SetColors(Handle_Aspect_RectangularGrid self, Quantity_Color aColor, Quantity_Color aTenthColor)

        Change the colors of the grid

        :type aColor: OCC.wrapper.Quantity.Quantity_Color
        :type aTenthColor: OCC.wrapper.Quantity.Quantity_Color

        """
        return _Aspect.Handle_Aspect_RectangularGrid_SetColors(self, *args)


    def Hit(self, *args):
        """
        Hit(Handle_Aspect_RectangularGrid self, Standard_Real const X, Standard_Real const Y)

        returns the point of the grid the closest to the point X,Y
        if the grid is active. If the grid is not active returns
        X,Y.

        :type X: float
        :type Y: float
        :type gridX: float
        :type gridY: float

        """
        return _Aspect.Handle_Aspect_RectangularGrid_Hit(self, *args)


    def Activate(self, *args):
        """
        Activate(Handle_Aspect_RectangularGrid self)

        activates the grid. The Hit method will return
        gridx and gridx computed according to the steps
        of the grid.


        """
        return _Aspect.Handle_Aspect_RectangularGrid_Activate(self, *args)


    def Deactivate(self, *args):
        """
        Deactivate(Handle_Aspect_RectangularGrid self)

        deactivates the grid. The hit method will return
        gridx and gridx as the enter value X & Y.


        """
        return _Aspect.Handle_Aspect_RectangularGrid_Deactivate(self, *args)


    def XOrigin(self, *args):
        """
        XOrigin(Handle_Aspect_RectangularGrid self) -> Standard_Real

        returns the x Origin of the grid.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Aspect.Handle_Aspect_RectangularGrid_XOrigin(self, *args)


    def YOrigin(self, *args):
        """
        YOrigin(Handle_Aspect_RectangularGrid self) -> Standard_Real

        returns the x Origin of the grid.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Aspect.Handle_Aspect_RectangularGrid_YOrigin(self, *args)


    def RotationAngle(self, *args):
        """
        RotationAngle(Handle_Aspect_RectangularGrid self) -> Standard_Real

        returns the x Angle of the grid.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Aspect.Handle_Aspect_RectangularGrid_RotationAngle(self, *args)


    def IsActive(self, *args):
        """
        IsActive(Handle_Aspect_RectangularGrid self) -> Standard_Boolean

        Returns TRUE when the grid is active.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Aspect.Handle_Aspect_RectangularGrid_IsActive(self, *args)


    def Colors(self, *args):
        """
        Colors(Handle_Aspect_RectangularGrid self, Quantity_Color aColor, Quantity_Color aTenthColor)

        Returns the colors of the grid.

        :type aColor: OCC.wrapper.Quantity.Quantity_Color
        :type aTenthColor: OCC.wrapper.Quantity.Quantity_Color

        """
        return _Aspect.Handle_Aspect_RectangularGrid_Colors(self, *args)


    def SetDrawMode(self, *args):
        """
        SetDrawMode(Handle_Aspect_RectangularGrid self, Aspect_GridDrawMode const aDrawMode)

        Change the grid aspect.

        :type aDrawMode: OCC.wrapper.Aspect.Aspect_GridDrawMode

        """
        return _Aspect.Handle_Aspect_RectangularGrid_SetDrawMode(self, *args)


    def DrawMode(self, *args):
        """
        DrawMode(Handle_Aspect_RectangularGrid self) -> Aspect_GridDrawMode

        Returns the grid aspect.

        :rtype: OCC.wrapper.Aspect.Aspect_GridDrawMode

        """
        return _Aspect.Handle_Aspect_RectangularGrid_DrawMode(self, *args)


    def Display(self, *args):
        """
        Display(Handle_Aspect_RectangularGrid self)

        Display the grid at screen.


        """
        return _Aspect.Handle_Aspect_RectangularGrid_Display(self, *args)


    def Erase(self, *args):
        """
        Erase(Handle_Aspect_RectangularGrid self)

        Erase the grid from screen.


        """
        return _Aspect.Handle_Aspect_RectangularGrid_Erase(self, *args)


    def IsDisplayed(self, *args):
        """
        IsDisplayed(Handle_Aspect_RectangularGrid self) -> Standard_Boolean

        Returns TRUE when the grid is displayed at screen.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Aspect.Handle_Aspect_RectangularGrid_IsDisplayed(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_Aspect_RectangularGrid self)

        Memory deallocator for transient classes


        """
        return _Aspect.Handle_Aspect_RectangularGrid_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Aspect_RectangularGrid self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Aspect_RectangularGrid self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Aspect.Handle_Aspect_RectangularGrid_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Aspect_RectangularGrid self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Aspect_RectangularGrid self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Aspect.Handle_Aspect_RectangularGrid_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Aspect_RectangularGrid self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Aspect.Handle_Aspect_RectangularGrid_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Aspect_RectangularGrid self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Aspect.Handle_Aspect_RectangularGrid_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Aspect_RectangularGrid self)

        Increments the reference counter of this object


        """
        return _Aspect.Handle_Aspect_RectangularGrid_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Aspect_RectangularGrid self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Aspect.Handle_Aspect_RectangularGrid_DecrementRefCounter(self, *args)

Handle_Aspect_RectangularGrid_swigregister = _Aspect.Handle_Aspect_RectangularGrid_swigregister
Handle_Aspect_RectangularGrid_swigregister(Handle_Aspect_RectangularGrid)

def Handle_Aspect_RectangularGrid_DownCast(thing):
    return _Aspect.Handle_Aspect_RectangularGrid_DownCast(thing)
Handle_Aspect_RectangularGrid_DownCast = _Aspect.Handle_Aspect_RectangularGrid_DownCast

class Aspect_IdentDefinitionError(Standard.Standard_OutOfRange):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Aspect_IdentDefinitionError
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Aspect_IdentDefinitionError(self) 
            return h


    def __init__(self, *args):
        """
        __init__(Aspect_IdentDefinitionError self) -> Aspect_IdentDefinitionError
        __init__(Aspect_IdentDefinitionError self, Standard_CString const theMessage) -> Aspect_IdentDefinitionError

        :type theMessage: OCC.wrapper.Standard.Standard_CString

        """
        this = _Aspect.new_Aspect_IdentDefinitionError(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def NewInstance(*args):
        """
        NewInstance(Standard_CString const theMessage) -> Handle_Aspect_IdentDefinitionError

        :type theMessage: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Aspect.Handle_Aspect_IdentDefinitionError

        """
        return _Aspect.Aspect_IdentDefinitionError_NewInstance(*args)

    NewInstance = staticmethod(NewInstance)

    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Aspect.Aspect_IdentDefinitionError_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Aspect.Aspect_IdentDefinitionError_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Aspect.Aspect_IdentDefinitionError_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Aspect.delete_Aspect_IdentDefinitionError
Aspect_IdentDefinitionError_swigregister = _Aspect.Aspect_IdentDefinitionError_swigregister
Aspect_IdentDefinitionError_swigregister(Aspect_IdentDefinitionError)

def Aspect_IdentDefinitionError_NewInstance(*args):
    """
    Aspect_IdentDefinitionError_NewInstance(Standard_CString const theMessage) -> Handle_Aspect_IdentDefinitionError

    :type theMessage: OCC.wrapper.Standard.Standard_CString
    :rtype: OCC.wrapper.Aspect.Handle_Aspect_IdentDefinitionError

    """
    return _Aspect.Aspect_IdentDefinitionError_NewInstance(*args)

def Aspect_IdentDefinitionError_get_type_name(*args):
    """
    Aspect_IdentDefinitionError_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Aspect.Aspect_IdentDefinitionError_get_type_name(*args)

def Aspect_IdentDefinitionError_get_type_descriptor(*args):
    """
    Aspect_IdentDefinitionError_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Aspect.Aspect_IdentDefinitionError_get_type_descriptor(*args)

class Handle_Aspect_CircularGrid(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Aspect_CircularGrid self)

        Nullify the handle


        """
        return _Aspect.Handle_Aspect_CircularGrid_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Aspect_CircularGrid self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Aspect.Handle_Aspect_CircularGrid_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Aspect_CircularGrid self, Aspect_CircularGrid thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Aspect.Handle_Aspect_CircularGrid_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Aspect_CircularGrid self, Handle_Aspect_CircularGrid theHandle) -> Handle_Aspect_CircularGrid
        assign(Handle_Aspect_CircularGrid self, Aspect_CircularGrid thePtr) -> Handle_Aspect_CircularGrid
        assign(Handle_Aspect_CircularGrid self, Handle_Aspect_CircularGrid theHandle) -> Handle_Aspect_CircularGrid

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Aspect.Handle_Aspect_CircularGrid_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Aspect_CircularGrid self) -> Aspect_CircularGrid

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Aspect.Handle_Aspect_CircularGrid_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Aspect_CircularGrid self) -> Aspect_CircularGrid

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Aspect.Handle_Aspect_CircularGrid___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Aspect_CircularGrid self) -> Aspect_CircularGrid

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Aspect.Handle_Aspect_CircularGrid___ref__(self, *args)


    def __hash__(self):
        return _Aspect.Handle_Aspect_CircularGrid___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Aspect.Handle_Aspect_CircularGrid___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Aspect.new_Handle_Aspect_CircularGrid(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Aspect.Handle_Aspect_CircularGrid_DownCast)
    __swig_destroy__ = _Aspect.delete_Handle_Aspect_CircularGrid

    def get_type_name(self, *args):
        """
        get_type_name(Handle_Aspect_CircularGrid self) -> char const *

        :rtype: const char *

        """
        return _Aspect.Handle_Aspect_CircularGrid_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Aspect.Handle_Aspect_CircularGrid_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Aspect.Handle_Aspect_CircularGrid_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetRadiusStep(self, *args):
        """
        SetRadiusStep(Handle_Aspect_CircularGrid self, Standard_Real const aStep)

        defines the x step of the grid.

        :type aStep: float

        """
        return _Aspect.Handle_Aspect_CircularGrid_SetRadiusStep(self, *args)


    def SetDivisionNumber(self, *args):
        """
        SetDivisionNumber(Handle_Aspect_CircularGrid self, Standard_Integer const aNumber)

        defines the step of the grid.

        :type aNumber: int

        """
        return _Aspect.Handle_Aspect_CircularGrid_SetDivisionNumber(self, *args)


    def SetGridValues(self, *args):
        """
        SetGridValues(Handle_Aspect_CircularGrid self, Standard_Real const XOrigin, Standard_Real const YOrigin, Standard_Real const RadiusStep, Standard_Integer const DivisionNumber, Standard_Real const RotationAngle)

        :type XOrigin: float
        :type YOrigin: float
        :type RadiusStep: float
        :type DivisionNumber: int
        :type RotationAngle: float

        """
        return _Aspect.Handle_Aspect_CircularGrid_SetGridValues(self, *args)


    def Compute(self, *args):
        """
        Compute(Handle_Aspect_CircularGrid self, Standard_Real const X, Standard_Real const Y)

        returns the point of the grid the closest to the point X,Y

        :type X: float
        :type Y: float
        :type gridX: float
        :type gridY: float

        """
        return _Aspect.Handle_Aspect_CircularGrid_Compute(self, *args)


    def RadiusStep(self, *args):
        """
        RadiusStep(Handle_Aspect_CircularGrid self) -> Standard_Real

        returns the x step of the grid.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Aspect.Handle_Aspect_CircularGrid_RadiusStep(self, *args)


    def DivisionNumber(self, *args):
        """
        DivisionNumber(Handle_Aspect_CircularGrid self) -> Standard_Integer

        returns the x step of the grid.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Aspect.Handle_Aspect_CircularGrid_DivisionNumber(self, *args)


    def Init(self, *args):
        """Init(Handle_Aspect_CircularGrid self)"""
        return _Aspect.Handle_Aspect_CircularGrid_Init(self, *args)


    def SetXOrigin(self, *args):
        """
        SetXOrigin(Handle_Aspect_CircularGrid self, Standard_Real const anOrigin)

        defines the x Origin of the grid.

        :type anOrigin: float

        """
        return _Aspect.Handle_Aspect_CircularGrid_SetXOrigin(self, *args)


    def SetYOrigin(self, *args):
        """
        SetYOrigin(Handle_Aspect_CircularGrid self, Standard_Real const anOrigin)

        defines the y Origin of the grid.

        :type anOrigin: float

        """
        return _Aspect.Handle_Aspect_CircularGrid_SetYOrigin(self, *args)


    def SetRotationAngle(self, *args):
        """
        SetRotationAngle(Handle_Aspect_CircularGrid self, Standard_Real const anAngle)

        defines the orientation of the grid.

        :type anAngle: float

        """
        return _Aspect.Handle_Aspect_CircularGrid_SetRotationAngle(self, *args)


    def Rotate(self, *args):
        """
        Rotate(Handle_Aspect_CircularGrid self, Standard_Real const anAngle)

        Rotate the grid from a relative angle.

        :type anAngle: float

        """
        return _Aspect.Handle_Aspect_CircularGrid_Rotate(self, *args)


    def Translate(self, *args):
        """
        Translate(Handle_Aspect_CircularGrid self, Standard_Real const aDx, Standard_Real const aDy)

        Translate the grid from a relative distance.

        :type aDx: float
        :type aDy: float

        """
        return _Aspect.Handle_Aspect_CircularGrid_Translate(self, *args)


    def SetColors(self, *args):
        """
        SetColors(Handle_Aspect_CircularGrid self, Quantity_Color aColor, Quantity_Color aTenthColor)

        Change the colors of the grid

        :type aColor: OCC.wrapper.Quantity.Quantity_Color
        :type aTenthColor: OCC.wrapper.Quantity.Quantity_Color

        """
        return _Aspect.Handle_Aspect_CircularGrid_SetColors(self, *args)


    def Hit(self, *args):
        """
        Hit(Handle_Aspect_CircularGrid self, Standard_Real const X, Standard_Real const Y)

        returns the point of the grid the closest to the point X,Y
        if the grid is active. If the grid is not active returns
        X,Y.

        :type X: float
        :type Y: float
        :type gridX: float
        :type gridY: float

        """
        return _Aspect.Handle_Aspect_CircularGrid_Hit(self, *args)


    def Activate(self, *args):
        """
        Activate(Handle_Aspect_CircularGrid self)

        activates the grid. The Hit method will return
        gridx and gridx computed according to the steps
        of the grid.


        """
        return _Aspect.Handle_Aspect_CircularGrid_Activate(self, *args)


    def Deactivate(self, *args):
        """
        Deactivate(Handle_Aspect_CircularGrid self)

        deactivates the grid. The hit method will return
        gridx and gridx as the enter value X & Y.


        """
        return _Aspect.Handle_Aspect_CircularGrid_Deactivate(self, *args)


    def XOrigin(self, *args):
        """
        XOrigin(Handle_Aspect_CircularGrid self) -> Standard_Real

        returns the x Origin of the grid.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Aspect.Handle_Aspect_CircularGrid_XOrigin(self, *args)


    def YOrigin(self, *args):
        """
        YOrigin(Handle_Aspect_CircularGrid self) -> Standard_Real

        returns the x Origin of the grid.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Aspect.Handle_Aspect_CircularGrid_YOrigin(self, *args)


    def RotationAngle(self, *args):
        """
        RotationAngle(Handle_Aspect_CircularGrid self) -> Standard_Real

        returns the x Angle of the grid.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Aspect.Handle_Aspect_CircularGrid_RotationAngle(self, *args)


    def IsActive(self, *args):
        """
        IsActive(Handle_Aspect_CircularGrid self) -> Standard_Boolean

        Returns TRUE when the grid is active.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Aspect.Handle_Aspect_CircularGrid_IsActive(self, *args)


    def Colors(self, *args):
        """
        Colors(Handle_Aspect_CircularGrid self, Quantity_Color aColor, Quantity_Color aTenthColor)

        Returns the colors of the grid.

        :type aColor: OCC.wrapper.Quantity.Quantity_Color
        :type aTenthColor: OCC.wrapper.Quantity.Quantity_Color

        """
        return _Aspect.Handle_Aspect_CircularGrid_Colors(self, *args)


    def SetDrawMode(self, *args):
        """
        SetDrawMode(Handle_Aspect_CircularGrid self, Aspect_GridDrawMode const aDrawMode)

        Change the grid aspect.

        :type aDrawMode: OCC.wrapper.Aspect.Aspect_GridDrawMode

        """
        return _Aspect.Handle_Aspect_CircularGrid_SetDrawMode(self, *args)


    def DrawMode(self, *args):
        """
        DrawMode(Handle_Aspect_CircularGrid self) -> Aspect_GridDrawMode

        Returns the grid aspect.

        :rtype: OCC.wrapper.Aspect.Aspect_GridDrawMode

        """
        return _Aspect.Handle_Aspect_CircularGrid_DrawMode(self, *args)


    def Display(self, *args):
        """
        Display(Handle_Aspect_CircularGrid self)

        Display the grid at screen.


        """
        return _Aspect.Handle_Aspect_CircularGrid_Display(self, *args)


    def Erase(self, *args):
        """
        Erase(Handle_Aspect_CircularGrid self)

        Erase the grid from screen.


        """
        return _Aspect.Handle_Aspect_CircularGrid_Erase(self, *args)


    def IsDisplayed(self, *args):
        """
        IsDisplayed(Handle_Aspect_CircularGrid self) -> Standard_Boolean

        Returns TRUE when the grid is displayed at screen.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Aspect.Handle_Aspect_CircularGrid_IsDisplayed(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_Aspect_CircularGrid self)

        Memory deallocator for transient classes


        """
        return _Aspect.Handle_Aspect_CircularGrid_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Aspect_CircularGrid self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Aspect_CircularGrid self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Aspect.Handle_Aspect_CircularGrid_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Aspect_CircularGrid self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Aspect_CircularGrid self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Aspect.Handle_Aspect_CircularGrid_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Aspect_CircularGrid self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Aspect.Handle_Aspect_CircularGrid_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Aspect_CircularGrid self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Aspect.Handle_Aspect_CircularGrid_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Aspect_CircularGrid self)

        Increments the reference counter of this object


        """
        return _Aspect.Handle_Aspect_CircularGrid_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Aspect_CircularGrid self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Aspect.Handle_Aspect_CircularGrid_DecrementRefCounter(self, *args)

Handle_Aspect_CircularGrid_swigregister = _Aspect.Handle_Aspect_CircularGrid_swigregister
Handle_Aspect_CircularGrid_swigregister(Handle_Aspect_CircularGrid)

def Handle_Aspect_CircularGrid_DownCast(thing):
    return _Aspect.Handle_Aspect_CircularGrid_DownCast(thing)
Handle_Aspect_CircularGrid_DownCast = _Aspect.Handle_Aspect_CircularGrid_DownCast

class Handle_Aspect_DisplayConnection(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Aspect_DisplayConnection self)

        Nullify the handle


        """
        return _Aspect.Handle_Aspect_DisplayConnection_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Aspect_DisplayConnection self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Aspect.Handle_Aspect_DisplayConnection_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Aspect_DisplayConnection self, Aspect_DisplayConnection thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Aspect.Handle_Aspect_DisplayConnection_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Aspect_DisplayConnection self, Handle_Aspect_DisplayConnection theHandle) -> Handle_Aspect_DisplayConnection
        assign(Handle_Aspect_DisplayConnection self, Aspect_DisplayConnection thePtr) -> Handle_Aspect_DisplayConnection
        assign(Handle_Aspect_DisplayConnection self, Handle_Aspect_DisplayConnection theHandle) -> Handle_Aspect_DisplayConnection

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Aspect.Handle_Aspect_DisplayConnection_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Aspect_DisplayConnection self) -> Aspect_DisplayConnection

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Aspect.Handle_Aspect_DisplayConnection_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Aspect_DisplayConnection self) -> Aspect_DisplayConnection

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Aspect.Handle_Aspect_DisplayConnection___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Aspect_DisplayConnection self) -> Aspect_DisplayConnection

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Aspect.Handle_Aspect_DisplayConnection___ref__(self, *args)


    def __hash__(self):
        return _Aspect.Handle_Aspect_DisplayConnection___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Aspect.Handle_Aspect_DisplayConnection___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Aspect.new_Handle_Aspect_DisplayConnection(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Aspect.Handle_Aspect_DisplayConnection_DownCast)
    __swig_destroy__ = _Aspect.delete_Handle_Aspect_DisplayConnection

    def get_type_name(self, *args):
        """
        get_type_name(Handle_Aspect_DisplayConnection self) -> char const *

        :rtype: const char *

        """
        return _Aspect.Handle_Aspect_DisplayConnection_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Aspect.Handle_Aspect_DisplayConnection_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Aspect.Handle_Aspect_DisplayConnection_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_Aspect_DisplayConnection self)

        Memory deallocator for transient classes


        """
        return _Aspect.Handle_Aspect_DisplayConnection_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Aspect_DisplayConnection self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Aspect_DisplayConnection self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Aspect.Handle_Aspect_DisplayConnection_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Aspect_DisplayConnection self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Aspect_DisplayConnection self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Aspect.Handle_Aspect_DisplayConnection_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Aspect_DisplayConnection self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Aspect.Handle_Aspect_DisplayConnection_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Aspect_DisplayConnection self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Aspect.Handle_Aspect_DisplayConnection_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Aspect_DisplayConnection self)

        Increments the reference counter of this object


        """
        return _Aspect.Handle_Aspect_DisplayConnection_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Aspect_DisplayConnection self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Aspect.Handle_Aspect_DisplayConnection_DecrementRefCounter(self, *args)

Handle_Aspect_DisplayConnection_swigregister = _Aspect.Handle_Aspect_DisplayConnection_swigregister
Handle_Aspect_DisplayConnection_swigregister(Handle_Aspect_DisplayConnection)

def Handle_Aspect_DisplayConnection_DownCast(thing):
    return _Aspect.Handle_Aspect_DisplayConnection_DownCast(thing)
Handle_Aspect_DisplayConnection_DownCast = _Aspect.Handle_Aspect_DisplayConnection_DownCast

class Aspect_GenId(object):
    """This class permits the creation and control of integer identifiers."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Aspect_GenId self) -> Aspect_GenId
        __init__(Aspect_GenId self, Standard_Integer const theLow, Standard_Integer const theUpper) -> Aspect_GenId

        Creates an available set of identifiers with specified range.
        Raises IdentDefinitionError if theUpper is less than theLow.

        :type theLow: int
        :type theUpper: int

        """
        this = _Aspect.new_Aspect_GenId(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Free(self, *args):
        """
        Free(Aspect_GenId self)
        Free(Aspect_GenId self, Standard_Integer const theId)

        Free specified identifier. Warning - method has no protection against double-freeing!

        :type theId: int

        """
        return _Aspect.Aspect_GenId_Free(self, *args)


    def HasFree(self, *args):
        """
        HasFree(Aspect_GenId self) -> Standard_Boolean

        Returns true if there are available identifiers in range.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Aspect.Aspect_GenId_HasFree(self, *args)


    def Available(self, *args):
        """
        Available(Aspect_GenId self) -> Standard_Integer

        Returns the number of available identifiers.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Aspect.Aspect_GenId_Available(self, *args)


    def Lower(self, *args):
        """
        Lower(Aspect_GenId self) -> Standard_Integer

        Returns the lower identifier in range.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Aspect.Aspect_GenId_Lower(self, *args)


    def Next(self, *args):
        """
        Next(Aspect_GenId self) -> Standard_Integer

        Returns the next available identifier.
        Warning: Raises IdentDefinitionError if all identifiers are busy.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Aspect.Aspect_GenId_Next(self, *args)


    def Upper(self, *args):
        """
        Upper(Aspect_GenId self) -> Standard_Integer

        Returns the upper identifier in range.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Aspect.Aspect_GenId_Upper(self, *args)

    __swig_destroy__ = _Aspect.delete_Aspect_GenId
Aspect_GenId_swigregister = _Aspect.Aspect_GenId_swigregister
Aspect_GenId_swigregister(Aspect_GenId)

class Handle_Aspect_IdentDefinitionError(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Aspect_IdentDefinitionError self)

        Nullify the handle


        """
        return _Aspect.Handle_Aspect_IdentDefinitionError_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Aspect_IdentDefinitionError self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Aspect.Handle_Aspect_IdentDefinitionError_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Aspect_IdentDefinitionError self, Aspect_IdentDefinitionError thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Aspect.Handle_Aspect_IdentDefinitionError_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Aspect_IdentDefinitionError self, Handle_Aspect_IdentDefinitionError theHandle) -> Handle_Aspect_IdentDefinitionError
        assign(Handle_Aspect_IdentDefinitionError self, Aspect_IdentDefinitionError thePtr) -> Handle_Aspect_IdentDefinitionError
        assign(Handle_Aspect_IdentDefinitionError self, Handle_Aspect_IdentDefinitionError theHandle) -> Handle_Aspect_IdentDefinitionError

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Aspect.Handle_Aspect_IdentDefinitionError_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Aspect_IdentDefinitionError self) -> Aspect_IdentDefinitionError

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Aspect.Handle_Aspect_IdentDefinitionError_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Aspect_IdentDefinitionError self) -> Aspect_IdentDefinitionError

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Aspect.Handle_Aspect_IdentDefinitionError___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Aspect_IdentDefinitionError self) -> Aspect_IdentDefinitionError

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Aspect.Handle_Aspect_IdentDefinitionError___ref__(self, *args)


    def __hash__(self):
        return _Aspect.Handle_Aspect_IdentDefinitionError___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Aspect.Handle_Aspect_IdentDefinitionError___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Aspect.new_Handle_Aspect_IdentDefinitionError(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Aspect.Handle_Aspect_IdentDefinitionError_DownCast)
    __swig_destroy__ = _Aspect.delete_Handle_Aspect_IdentDefinitionError

    def NewInstance(self, *args):
        """
        NewInstance(Handle_Aspect_IdentDefinitionError self, Standard_CString const theMessage) -> Handle_Aspect_IdentDefinitionError

        :type theMessage: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Aspect.Handle_Aspect_IdentDefinitionError

        """
        return _Aspect.Handle_Aspect_IdentDefinitionError_NewInstance(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Aspect_IdentDefinitionError self) -> char const *

        :rtype: const char *

        """
        return _Aspect.Handle_Aspect_IdentDefinitionError_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Aspect.Handle_Aspect_IdentDefinitionError_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Aspect.Handle_Aspect_IdentDefinitionError_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Print(self, *args):
        """
        Print(Handle_Aspect_IdentDefinitionError self, Standard_OStream & s)

        Prints on the stream <s> the exception name followed by
        the error message.
        Level: Advanced
        Warning:
        The operator "OStream& operator<< (Standard_OStream&,
        Handle(Standard_Failure)&)"
        is implemented. (This operator uses the method Print)

        :type s: OCC.wrapper.Standard.Standard_OStream

        """
        return _Aspect.Handle_Aspect_IdentDefinitionError_Print(self, *args)


    def GetMessageString(self, *args):
        """
        GetMessageString(Handle_Aspect_IdentDefinitionError self) -> Standard_CString

        Returns error message

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _Aspect.Handle_Aspect_IdentDefinitionError_GetMessageString(self, *args)


    def SetMessageString(self, *args):
        """
        SetMessageString(Handle_Aspect_IdentDefinitionError self, Standard_CString const aMessage)

        Sets error message

        :type aMessage: OCC.wrapper.Standard.Standard_CString

        """
        return _Aspect.Handle_Aspect_IdentDefinitionError_SetMessageString(self, *args)


    def Reraise(self, *args):
        """
        Reraise(Handle_Aspect_IdentDefinitionError self)
        Reraise(Handle_Aspect_IdentDefinitionError self, Standard_CString const aMessage)
        Reraise(Handle_Aspect_IdentDefinitionError self, Standard_SStream const & aReason)

        Reraises a caught exception and changes its error message.

        :type aReason: OCC.wrapper.Standard.Standard_SStream

        """
        return _Aspect.Handle_Aspect_IdentDefinitionError_Reraise(self, *args)


    def Jump(self, *args):
        """
        Jump(Handle_Aspect_IdentDefinitionError self)

        Used to throw CASCADE exception from C signal handler.
        On platforms that do not allow throwing C++ exceptions
        from this handler (e.g. Linux), uses longjump to get to
        the current active signal handler, and only then is
        converted to C++ exception.


        """
        return _Aspect.Handle_Aspect_IdentDefinitionError_Jump(self, *args)


    def Caught(self, *args):
        """
        Caught(Handle_Aspect_IdentDefinitionError self) -> Handle_Standard_Failure

        Returns the last caught exception.
        Needed when exceptions are emulated by C longjumps,
        in other cases is also provided for compatibility.

        :rtype: OCC.wrapper.Standard.Handle_Standard_Failure

        """
        return _Aspect.Handle_Aspect_IdentDefinitionError_Caught(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_Aspect_IdentDefinitionError self)

        Memory deallocator for transient classes


        """
        return _Aspect.Handle_Aspect_IdentDefinitionError_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Aspect_IdentDefinitionError self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Aspect_IdentDefinitionError self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Aspect.Handle_Aspect_IdentDefinitionError_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Aspect_IdentDefinitionError self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Aspect_IdentDefinitionError self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Aspect.Handle_Aspect_IdentDefinitionError_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Aspect_IdentDefinitionError self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Aspect.Handle_Aspect_IdentDefinitionError_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Aspect_IdentDefinitionError self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Aspect.Handle_Aspect_IdentDefinitionError_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Aspect_IdentDefinitionError self)

        Increments the reference counter of this object


        """
        return _Aspect.Handle_Aspect_IdentDefinitionError_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Aspect_IdentDefinitionError self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Aspect.Handle_Aspect_IdentDefinitionError_DecrementRefCounter(self, *args)

Handle_Aspect_IdentDefinitionError_swigregister = _Aspect.Handle_Aspect_IdentDefinitionError_swigregister
Handle_Aspect_IdentDefinitionError_swigregister(Handle_Aspect_IdentDefinitionError)

def Handle_Aspect_IdentDefinitionError_DownCast(thing):
    return _Aspect.Handle_Aspect_IdentDefinitionError_DownCast(thing)
Handle_Aspect_IdentDefinitionError_DownCast = _Aspect.Handle_Aspect_IdentDefinitionError_DownCast

class Handle_Aspect_AspectFillAreaDefinitionError(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Aspect_AspectFillAreaDefinitionError self)

        Nullify the handle


        """
        return _Aspect.Handle_Aspect_AspectFillAreaDefinitionError_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Aspect_AspectFillAreaDefinitionError self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Aspect.Handle_Aspect_AspectFillAreaDefinitionError_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Aspect_AspectFillAreaDefinitionError self, Aspect_AspectFillAreaDefinitionError thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Aspect.Handle_Aspect_AspectFillAreaDefinitionError_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Aspect_AspectFillAreaDefinitionError self, Handle_Aspect_AspectFillAreaDefinitionError theHandle) -> Handle_Aspect_AspectFillAreaDefinitionError
        assign(Handle_Aspect_AspectFillAreaDefinitionError self, Aspect_AspectFillAreaDefinitionError thePtr) -> Handle_Aspect_AspectFillAreaDefinitionError
        assign(Handle_Aspect_AspectFillAreaDefinitionError self, Handle_Aspect_AspectFillAreaDefinitionError theHandle) -> Handle_Aspect_AspectFillAreaDefinitionError

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Aspect.Handle_Aspect_AspectFillAreaDefinitionError_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Aspect_AspectFillAreaDefinitionError self) -> Aspect_AspectFillAreaDefinitionError

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Aspect.Handle_Aspect_AspectFillAreaDefinitionError_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Aspect_AspectFillAreaDefinitionError self) -> Aspect_AspectFillAreaDefinitionError

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Aspect.Handle_Aspect_AspectFillAreaDefinitionError___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Aspect_AspectFillAreaDefinitionError self) -> Aspect_AspectFillAreaDefinitionError

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Aspect.Handle_Aspect_AspectFillAreaDefinitionError___ref__(self, *args)


    def __hash__(self):
        return _Aspect.Handle_Aspect_AspectFillAreaDefinitionError___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Aspect.Handle_Aspect_AspectFillAreaDefinitionError___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Aspect.new_Handle_Aspect_AspectFillAreaDefinitionError(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Aspect.Handle_Aspect_AspectFillAreaDefinitionError_DownCast)
    __swig_destroy__ = _Aspect.delete_Handle_Aspect_AspectFillAreaDefinitionError

    def NewInstance(self, *args):
        """
        NewInstance(Handle_Aspect_AspectFillAreaDefinitionError self, Standard_CString const theMessage) -> Handle_Aspect_AspectFillAreaDefinitionError

        :type theMessage: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Aspect.Handle_Aspect_AspectFillAreaDefinitionError

        """
        return _Aspect.Handle_Aspect_AspectFillAreaDefinitionError_NewInstance(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Aspect_AspectFillAreaDefinitionError self) -> char const *

        :rtype: const char *

        """
        return _Aspect.Handle_Aspect_AspectFillAreaDefinitionError_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Aspect.Handle_Aspect_AspectFillAreaDefinitionError_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Aspect.Handle_Aspect_AspectFillAreaDefinitionError_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Print(self, *args):
        """
        Print(Handle_Aspect_AspectFillAreaDefinitionError self, Standard_OStream & s)

        Prints on the stream <s> the exception name followed by
        the error message.
        Level: Advanced
        Warning:
        The operator "OStream& operator<< (Standard_OStream&,
        Handle(Standard_Failure)&)"
        is implemented. (This operator uses the method Print)

        :type s: OCC.wrapper.Standard.Standard_OStream

        """
        return _Aspect.Handle_Aspect_AspectFillAreaDefinitionError_Print(self, *args)


    def GetMessageString(self, *args):
        """
        GetMessageString(Handle_Aspect_AspectFillAreaDefinitionError self) -> Standard_CString

        Returns error message

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _Aspect.Handle_Aspect_AspectFillAreaDefinitionError_GetMessageString(self, *args)


    def SetMessageString(self, *args):
        """
        SetMessageString(Handle_Aspect_AspectFillAreaDefinitionError self, Standard_CString const aMessage)

        Sets error message

        :type aMessage: OCC.wrapper.Standard.Standard_CString

        """
        return _Aspect.Handle_Aspect_AspectFillAreaDefinitionError_SetMessageString(self, *args)


    def Reraise(self, *args):
        """
        Reraise(Handle_Aspect_AspectFillAreaDefinitionError self)
        Reraise(Handle_Aspect_AspectFillAreaDefinitionError self, Standard_CString const aMessage)
        Reraise(Handle_Aspect_AspectFillAreaDefinitionError self, Standard_SStream const & aReason)

        Reraises a caught exception and changes its error message.

        :type aReason: OCC.wrapper.Standard.Standard_SStream

        """
        return _Aspect.Handle_Aspect_AspectFillAreaDefinitionError_Reraise(self, *args)


    def Jump(self, *args):
        """
        Jump(Handle_Aspect_AspectFillAreaDefinitionError self)

        Used to throw CASCADE exception from C signal handler.
        On platforms that do not allow throwing C++ exceptions
        from this handler (e.g. Linux), uses longjump to get to
        the current active signal handler, and only then is
        converted to C++ exception.


        """
        return _Aspect.Handle_Aspect_AspectFillAreaDefinitionError_Jump(self, *args)


    def Caught(self, *args):
        """
        Caught(Handle_Aspect_AspectFillAreaDefinitionError self) -> Handle_Standard_Failure

        Returns the last caught exception.
        Needed when exceptions are emulated by C longjumps,
        in other cases is also provided for compatibility.

        :rtype: OCC.wrapper.Standard.Handle_Standard_Failure

        """
        return _Aspect.Handle_Aspect_AspectFillAreaDefinitionError_Caught(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_Aspect_AspectFillAreaDefinitionError self)

        Memory deallocator for transient classes


        """
        return _Aspect.Handle_Aspect_AspectFillAreaDefinitionError_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Aspect_AspectFillAreaDefinitionError self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Aspect_AspectFillAreaDefinitionError self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Aspect.Handle_Aspect_AspectFillAreaDefinitionError_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Aspect_AspectFillAreaDefinitionError self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Aspect_AspectFillAreaDefinitionError self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Aspect.Handle_Aspect_AspectFillAreaDefinitionError_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Aspect_AspectFillAreaDefinitionError self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Aspect.Handle_Aspect_AspectFillAreaDefinitionError_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Aspect_AspectFillAreaDefinitionError self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Aspect.Handle_Aspect_AspectFillAreaDefinitionError_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Aspect_AspectFillAreaDefinitionError self)

        Increments the reference counter of this object


        """
        return _Aspect.Handle_Aspect_AspectFillAreaDefinitionError_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Aspect_AspectFillAreaDefinitionError self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Aspect.Handle_Aspect_AspectFillAreaDefinitionError_DecrementRefCounter(self, *args)

Handle_Aspect_AspectFillAreaDefinitionError_swigregister = _Aspect.Handle_Aspect_AspectFillAreaDefinitionError_swigregister
Handle_Aspect_AspectFillAreaDefinitionError_swigregister(Handle_Aspect_AspectFillAreaDefinitionError)

def Handle_Aspect_AspectFillAreaDefinitionError_DownCast(thing):
    return _Aspect.Handle_Aspect_AspectFillAreaDefinitionError_DownCast(thing)
Handle_Aspect_AspectFillAreaDefinitionError_DownCast = _Aspect.Handle_Aspect_AspectFillAreaDefinitionError_DownCast

class Handle_Aspect_WindowDefinitionError(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Aspect_WindowDefinitionError self)

        Nullify the handle


        """
        return _Aspect.Handle_Aspect_WindowDefinitionError_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Aspect_WindowDefinitionError self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Aspect.Handle_Aspect_WindowDefinitionError_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Aspect_WindowDefinitionError self, Aspect_WindowDefinitionError thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Aspect.Handle_Aspect_WindowDefinitionError_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Aspect_WindowDefinitionError self, Handle_Aspect_WindowDefinitionError theHandle) -> Handle_Aspect_WindowDefinitionError
        assign(Handle_Aspect_WindowDefinitionError self, Aspect_WindowDefinitionError thePtr) -> Handle_Aspect_WindowDefinitionError
        assign(Handle_Aspect_WindowDefinitionError self, Handle_Aspect_WindowDefinitionError theHandle) -> Handle_Aspect_WindowDefinitionError

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Aspect.Handle_Aspect_WindowDefinitionError_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Aspect_WindowDefinitionError self) -> Aspect_WindowDefinitionError

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Aspect.Handle_Aspect_WindowDefinitionError_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Aspect_WindowDefinitionError self) -> Aspect_WindowDefinitionError

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Aspect.Handle_Aspect_WindowDefinitionError___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Aspect_WindowDefinitionError self) -> Aspect_WindowDefinitionError

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Aspect.Handle_Aspect_WindowDefinitionError___ref__(self, *args)


    def __hash__(self):
        return _Aspect.Handle_Aspect_WindowDefinitionError___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Aspect.Handle_Aspect_WindowDefinitionError___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Aspect.new_Handle_Aspect_WindowDefinitionError(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Aspect.Handle_Aspect_WindowDefinitionError_DownCast)
    __swig_destroy__ = _Aspect.delete_Handle_Aspect_WindowDefinitionError

    def NewInstance(self, *args):
        """
        NewInstance(Handle_Aspect_WindowDefinitionError self, Standard_CString const theMessage) -> Handle_Aspect_WindowDefinitionError

        :type theMessage: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Aspect.Handle_Aspect_WindowDefinitionError

        """
        return _Aspect.Handle_Aspect_WindowDefinitionError_NewInstance(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Aspect_WindowDefinitionError self) -> char const *

        :rtype: const char *

        """
        return _Aspect.Handle_Aspect_WindowDefinitionError_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Aspect.Handle_Aspect_WindowDefinitionError_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Aspect.Handle_Aspect_WindowDefinitionError_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Print(self, *args):
        """
        Print(Handle_Aspect_WindowDefinitionError self, Standard_OStream & s)

        Prints on the stream <s> the exception name followed by
        the error message.
        Level: Advanced
        Warning:
        The operator "OStream& operator<< (Standard_OStream&,
        Handle(Standard_Failure)&)"
        is implemented. (This operator uses the method Print)

        :type s: OCC.wrapper.Standard.Standard_OStream

        """
        return _Aspect.Handle_Aspect_WindowDefinitionError_Print(self, *args)


    def GetMessageString(self, *args):
        """
        GetMessageString(Handle_Aspect_WindowDefinitionError self) -> Standard_CString

        Returns error message

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _Aspect.Handle_Aspect_WindowDefinitionError_GetMessageString(self, *args)


    def SetMessageString(self, *args):
        """
        SetMessageString(Handle_Aspect_WindowDefinitionError self, Standard_CString const aMessage)

        Sets error message

        :type aMessage: OCC.wrapper.Standard.Standard_CString

        """
        return _Aspect.Handle_Aspect_WindowDefinitionError_SetMessageString(self, *args)


    def Reraise(self, *args):
        """
        Reraise(Handle_Aspect_WindowDefinitionError self)
        Reraise(Handle_Aspect_WindowDefinitionError self, Standard_CString const aMessage)
        Reraise(Handle_Aspect_WindowDefinitionError self, Standard_SStream const & aReason)

        Reraises a caught exception and changes its error message.

        :type aReason: OCC.wrapper.Standard.Standard_SStream

        """
        return _Aspect.Handle_Aspect_WindowDefinitionError_Reraise(self, *args)


    def Jump(self, *args):
        """
        Jump(Handle_Aspect_WindowDefinitionError self)

        Used to throw CASCADE exception from C signal handler.
        On platforms that do not allow throwing C++ exceptions
        from this handler (e.g. Linux), uses longjump to get to
        the current active signal handler, and only then is
        converted to C++ exception.


        """
        return _Aspect.Handle_Aspect_WindowDefinitionError_Jump(self, *args)


    def Caught(self, *args):
        """
        Caught(Handle_Aspect_WindowDefinitionError self) -> Handle_Standard_Failure

        Returns the last caught exception.
        Needed when exceptions are emulated by C longjumps,
        in other cases is also provided for compatibility.

        :rtype: OCC.wrapper.Standard.Handle_Standard_Failure

        """
        return _Aspect.Handle_Aspect_WindowDefinitionError_Caught(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_Aspect_WindowDefinitionError self)

        Memory deallocator for transient classes


        """
        return _Aspect.Handle_Aspect_WindowDefinitionError_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Aspect_WindowDefinitionError self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Aspect_WindowDefinitionError self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Aspect.Handle_Aspect_WindowDefinitionError_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Aspect_WindowDefinitionError self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Aspect_WindowDefinitionError self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Aspect.Handle_Aspect_WindowDefinitionError_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Aspect_WindowDefinitionError self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Aspect.Handle_Aspect_WindowDefinitionError_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Aspect_WindowDefinitionError self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Aspect.Handle_Aspect_WindowDefinitionError_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Aspect_WindowDefinitionError self)

        Increments the reference counter of this object


        """
        return _Aspect.Handle_Aspect_WindowDefinitionError_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Aspect_WindowDefinitionError self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Aspect.Handle_Aspect_WindowDefinitionError_DecrementRefCounter(self, *args)

Handle_Aspect_WindowDefinitionError_swigregister = _Aspect.Handle_Aspect_WindowDefinitionError_swigregister
Handle_Aspect_WindowDefinitionError_swigregister(Handle_Aspect_WindowDefinitionError)

def Handle_Aspect_WindowDefinitionError_DownCast(thing):
    return _Aspect.Handle_Aspect_WindowDefinitionError_DownCast(thing)
Handle_Aspect_WindowDefinitionError_DownCast = _Aspect.Handle_Aspect_WindowDefinitionError_DownCast

class Handle_Aspect_Window(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Aspect_Window self)

        Nullify the handle


        """
        return _Aspect.Handle_Aspect_Window_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Aspect_Window self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Aspect.Handle_Aspect_Window_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Aspect_Window self, Aspect_Window thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Aspect.Handle_Aspect_Window_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Aspect_Window self, Handle_Aspect_Window theHandle) -> Handle_Aspect_Window
        assign(Handle_Aspect_Window self, Aspect_Window thePtr) -> Handle_Aspect_Window
        assign(Handle_Aspect_Window self, Handle_Aspect_Window theHandle) -> Handle_Aspect_Window

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Aspect.Handle_Aspect_Window_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Aspect_Window self) -> Aspect_Window

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Aspect.Handle_Aspect_Window_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Aspect_Window self) -> Aspect_Window

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Aspect.Handle_Aspect_Window___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Aspect_Window self) -> Aspect_Window

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Aspect.Handle_Aspect_Window___ref__(self, *args)


    def __hash__(self):
        return _Aspect.Handle_Aspect_Window___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Aspect.Handle_Aspect_Window___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Aspect.new_Handle_Aspect_Window(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Aspect.Handle_Aspect_Window_DownCast)
    __swig_destroy__ = _Aspect.delete_Handle_Aspect_Window

    def SetBackground(self, *args):
        """
        SetBackground(Handle_Aspect_Window self, Aspect_Background ABack)
        SetBackground(Handle_Aspect_Window self, Quantity_Color color)
        SetBackground(Handle_Aspect_Window self, Aspect_GradientBackground ABackground)
        SetBackground(Handle_Aspect_Window self, Quantity_Color theFirstColor, Quantity_Color theSecondColor, Aspect_GradientFillMethod const theFillMethod)

        Modifies the window gradient background.

        :type theFirstColor: OCC.wrapper.Quantity.Quantity_Color
        :type theSecondColor: OCC.wrapper.Quantity.Quantity_Color
        :type theFillMethod: OCC.wrapper.Aspect.Aspect_GradientFillMethod

        """
        return _Aspect.Handle_Aspect_Window_SetBackground(self, *args)


    def Map(self, *args):
        """
        Map(Handle_Aspect_Window self)

        Opens the window <me>.


        """
        return _Aspect.Handle_Aspect_Window_Map(self, *args)


    def Unmap(self, *args):
        """
        Unmap(Handle_Aspect_Window self)

        Closes the window <me>.


        """
        return _Aspect.Handle_Aspect_Window_Unmap(self, *args)


    def DoResize(self, *args):
        """
        DoResize(Handle_Aspect_Window self) -> Aspect_TypeOfResize

        Apply the resizing to the window <me>.

        :rtype: OCC.wrapper.Aspect.Aspect_TypeOfResize

        """
        return _Aspect.Handle_Aspect_Window_DoResize(self, *args)


    def DoMapping(self, *args):
        """
        DoMapping(Handle_Aspect_Window self) -> Standard_Boolean

        Apply the mapping change to the window <me>.
        and returns TRUE if the window is mapped at screen.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Aspect.Handle_Aspect_Window_DoMapping(self, *args)


    def Background(self, *args):
        """
        Background(Handle_Aspect_Window self) -> Aspect_Background

        Returns the window background.

        :rtype: OCC.wrapper.Aspect.Aspect_Background

        """
        return _Aspect.Handle_Aspect_Window_Background(self, *args)


    def BackgroundFillMethod(self, *args):
        """
        BackgroundFillMethod(Handle_Aspect_Window self) -> Aspect_FillMethod

        Returns the current image background fill mode.

        :rtype: OCC.wrapper.Aspect.Aspect_FillMethod

        """
        return _Aspect.Handle_Aspect_Window_BackgroundFillMethod(self, *args)


    def GradientBackground(self, *args):
        """
        GradientBackground(Handle_Aspect_Window self) -> Aspect_GradientBackground

        Returns the window gradient background.

        :rtype: OCC.wrapper.Aspect.Aspect_GradientBackground

        """
        return _Aspect.Handle_Aspect_Window_GradientBackground(self, *args)


    def IsMapped(self, *args):
        """
        IsMapped(Handle_Aspect_Window self) -> Standard_Boolean

        Returns True if the window <me> is opened
        and False if the window is closed.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Aspect.Handle_Aspect_Window_IsMapped(self, *args)


    def IsVirtual(self, *args):
        """
        IsVirtual(Handle_Aspect_Window self) -> Standard_Boolean

        Returns True if the window <me> is virtual

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Aspect.Handle_Aspect_Window_IsVirtual(self, *args)


    def SetVirtual(self, *args):
        """
        SetVirtual(Handle_Aspect_Window self, Standard_Boolean const theVirtual)

        Setup the virtual state

        :type theVirtual: bool

        """
        return _Aspect.Handle_Aspect_Window_SetVirtual(self, *args)


    def Ratio(self, *args):
        """
        Ratio(Handle_Aspect_Window self) -> Standard_Real

        Returns The Window RATIO equal to the physical
        WIDTH/HEIGHT dimensions

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Aspect.Handle_Aspect_Window_Ratio(self, *args)


    def Position(self, *args):
        """
        Position(Handle_Aspect_Window self)

        Returns The Window POSITION in PIXEL

        :type X1: int
        :type Y1: int
        :type X2: int
        :type Y2: int

        """
        return _Aspect.Handle_Aspect_Window_Position(self, *args)


    def Size(self, *args):
        """
        Size(Handle_Aspect_Window self)

        Returns The Window SIZE in PIXEL

        :type Width: int
        :type Height: int

        """
        return _Aspect.Handle_Aspect_Window_Size(self, *args)


    def NativeFBConfig(self, *args):
        """
        NativeFBConfig(Handle_Aspect_Window self) -> Aspect_FBConfig

        Returns native Window FB config (GLXFBConfig on Xlib)

        :rtype: OCC.wrapper.Aspect.Aspect_FBConfig

        """
        return _Aspect.Handle_Aspect_Window_NativeFBConfig(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Aspect_Window self) -> char const *

        :rtype: const char *

        """
        return _Aspect.Handle_Aspect_Window_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Aspect.Handle_Aspect_Window_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Aspect.Handle_Aspect_Window_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_Aspect_Window self)

        Memory deallocator for transient classes


        """
        return _Aspect.Handle_Aspect_Window_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Aspect_Window self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Aspect_Window self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Aspect.Handle_Aspect_Window_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Aspect_Window self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Aspect_Window self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Aspect.Handle_Aspect_Window_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Aspect_Window self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Aspect.Handle_Aspect_Window_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Aspect_Window self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Aspect.Handle_Aspect_Window_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Aspect_Window self)

        Increments the reference counter of this object


        """
        return _Aspect.Handle_Aspect_Window_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Aspect_Window self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Aspect.Handle_Aspect_Window_DecrementRefCounter(self, *args)

Handle_Aspect_Window_swigregister = _Aspect.Handle_Aspect_Window_swigregister
Handle_Aspect_Window_swigregister(Handle_Aspect_Window)

def Handle_Aspect_Window_DownCast(thing):
    return _Aspect.Handle_Aspect_Window_DownCast(thing)
Handle_Aspect_Window_DownCast = _Aspect.Handle_Aspect_Window_DownCast

class Handle_Aspect_DisplayConnectionDefinitionError(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Aspect_DisplayConnectionDefinitionError self)

        Nullify the handle


        """
        return _Aspect.Handle_Aspect_DisplayConnectionDefinitionError_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Aspect_DisplayConnectionDefinitionError self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Aspect.Handle_Aspect_DisplayConnectionDefinitionError_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Aspect_DisplayConnectionDefinitionError self, Aspect_DisplayConnectionDefinitionError thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Aspect.Handle_Aspect_DisplayConnectionDefinitionError_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Aspect_DisplayConnectionDefinitionError self, Handle_Aspect_DisplayConnectionDefinitionError theHandle) -> Handle_Aspect_DisplayConnectionDefinitionError
        assign(Handle_Aspect_DisplayConnectionDefinitionError self, Aspect_DisplayConnectionDefinitionError thePtr) -> Handle_Aspect_DisplayConnectionDefinitionError
        assign(Handle_Aspect_DisplayConnectionDefinitionError self, Handle_Aspect_DisplayConnectionDefinitionError theHandle) -> Handle_Aspect_DisplayConnectionDefinitionError

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Aspect.Handle_Aspect_DisplayConnectionDefinitionError_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Aspect_DisplayConnectionDefinitionError self) -> Aspect_DisplayConnectionDefinitionError

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Aspect.Handle_Aspect_DisplayConnectionDefinitionError_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Aspect_DisplayConnectionDefinitionError self) -> Aspect_DisplayConnectionDefinitionError

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Aspect.Handle_Aspect_DisplayConnectionDefinitionError___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Aspect_DisplayConnectionDefinitionError self) -> Aspect_DisplayConnectionDefinitionError

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Aspect.Handle_Aspect_DisplayConnectionDefinitionError___ref__(self, *args)


    def __hash__(self):
        return _Aspect.Handle_Aspect_DisplayConnectionDefinitionError___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Aspect.Handle_Aspect_DisplayConnectionDefinitionError___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Aspect.new_Handle_Aspect_DisplayConnectionDefinitionError(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Aspect.Handle_Aspect_DisplayConnectionDefinitionError_DownCast)
    __swig_destroy__ = _Aspect.delete_Handle_Aspect_DisplayConnectionDefinitionError

    def NewInstance(self, *args):
        """
        NewInstance(Handle_Aspect_DisplayConnectionDefinitionError self, Standard_CString const theMessage) -> Handle_Aspect_DisplayConnectionDefinitionError

        :type theMessage: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Aspect.Handle_Aspect_DisplayConnectionDefinitionError

        """
        return _Aspect.Handle_Aspect_DisplayConnectionDefinitionError_NewInstance(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Aspect_DisplayConnectionDefinitionError self) -> char const *

        :rtype: const char *

        """
        return _Aspect.Handle_Aspect_DisplayConnectionDefinitionError_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Aspect.Handle_Aspect_DisplayConnectionDefinitionError_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Aspect.Handle_Aspect_DisplayConnectionDefinitionError_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Print(self, *args):
        """
        Print(Handle_Aspect_DisplayConnectionDefinitionError self, Standard_OStream & s)

        Prints on the stream <s> the exception name followed by
        the error message.
        Level: Advanced
        Warning:
        The operator "OStream& operator<< (Standard_OStream&,
        Handle(Standard_Failure)&)"
        is implemented. (This operator uses the method Print)

        :type s: OCC.wrapper.Standard.Standard_OStream

        """
        return _Aspect.Handle_Aspect_DisplayConnectionDefinitionError_Print(self, *args)


    def GetMessageString(self, *args):
        """
        GetMessageString(Handle_Aspect_DisplayConnectionDefinitionError self) -> Standard_CString

        Returns error message

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _Aspect.Handle_Aspect_DisplayConnectionDefinitionError_GetMessageString(self, *args)


    def SetMessageString(self, *args):
        """
        SetMessageString(Handle_Aspect_DisplayConnectionDefinitionError self, Standard_CString const aMessage)

        Sets error message

        :type aMessage: OCC.wrapper.Standard.Standard_CString

        """
        return _Aspect.Handle_Aspect_DisplayConnectionDefinitionError_SetMessageString(self, *args)


    def Reraise(self, *args):
        """
        Reraise(Handle_Aspect_DisplayConnectionDefinitionError self)
        Reraise(Handle_Aspect_DisplayConnectionDefinitionError self, Standard_CString const aMessage)
        Reraise(Handle_Aspect_DisplayConnectionDefinitionError self, Standard_SStream const & aReason)

        Reraises a caught exception and changes its error message.

        :type aReason: OCC.wrapper.Standard.Standard_SStream

        """
        return _Aspect.Handle_Aspect_DisplayConnectionDefinitionError_Reraise(self, *args)


    def Jump(self, *args):
        """
        Jump(Handle_Aspect_DisplayConnectionDefinitionError self)

        Used to throw CASCADE exception from C signal handler.
        On platforms that do not allow throwing C++ exceptions
        from this handler (e.g. Linux), uses longjump to get to
        the current active signal handler, and only then is
        converted to C++ exception.


        """
        return _Aspect.Handle_Aspect_DisplayConnectionDefinitionError_Jump(self, *args)


    def Caught(self, *args):
        """
        Caught(Handle_Aspect_DisplayConnectionDefinitionError self) -> Handle_Standard_Failure

        Returns the last caught exception.
        Needed when exceptions are emulated by C longjumps,
        in other cases is also provided for compatibility.

        :rtype: OCC.wrapper.Standard.Handle_Standard_Failure

        """
        return _Aspect.Handle_Aspect_DisplayConnectionDefinitionError_Caught(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_Aspect_DisplayConnectionDefinitionError self)

        Memory deallocator for transient classes


        """
        return _Aspect.Handle_Aspect_DisplayConnectionDefinitionError_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Aspect_DisplayConnectionDefinitionError self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Aspect_DisplayConnectionDefinitionError self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Aspect.Handle_Aspect_DisplayConnectionDefinitionError_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Aspect_DisplayConnectionDefinitionError self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Aspect_DisplayConnectionDefinitionError self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Aspect.Handle_Aspect_DisplayConnectionDefinitionError_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Aspect_DisplayConnectionDefinitionError self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Aspect.Handle_Aspect_DisplayConnectionDefinitionError_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Aspect_DisplayConnectionDefinitionError self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Aspect.Handle_Aspect_DisplayConnectionDefinitionError_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Aspect_DisplayConnectionDefinitionError self)

        Increments the reference counter of this object


        """
        return _Aspect.Handle_Aspect_DisplayConnectionDefinitionError_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Aspect_DisplayConnectionDefinitionError self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Aspect.Handle_Aspect_DisplayConnectionDefinitionError_DecrementRefCounter(self, *args)

Handle_Aspect_DisplayConnectionDefinitionError_swigregister = _Aspect.Handle_Aspect_DisplayConnectionDefinitionError_swigregister
Handle_Aspect_DisplayConnectionDefinitionError_swigregister(Handle_Aspect_DisplayConnectionDefinitionError)

def Handle_Aspect_DisplayConnectionDefinitionError_DownCast(thing):
    return _Aspect.Handle_Aspect_DisplayConnectionDefinitionError_DownCast(thing)
Handle_Aspect_DisplayConnectionDefinitionError_DownCast = _Aspect.Handle_Aspect_DisplayConnectionDefinitionError_DownCast

class Handle_Aspect_WindowError(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Aspect_WindowError self)

        Nullify the handle


        """
        return _Aspect.Handle_Aspect_WindowError_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Aspect_WindowError self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Aspect.Handle_Aspect_WindowError_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Aspect_WindowError self, Aspect_WindowError thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Aspect.Handle_Aspect_WindowError_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Aspect_WindowError self, Handle_Aspect_WindowError theHandle) -> Handle_Aspect_WindowError
        assign(Handle_Aspect_WindowError self, Aspect_WindowError thePtr) -> Handle_Aspect_WindowError
        assign(Handle_Aspect_WindowError self, Handle_Aspect_WindowError theHandle) -> Handle_Aspect_WindowError

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Aspect.Handle_Aspect_WindowError_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Aspect_WindowError self) -> Aspect_WindowError

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Aspect.Handle_Aspect_WindowError_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Aspect_WindowError self) -> Aspect_WindowError

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Aspect.Handle_Aspect_WindowError___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Aspect_WindowError self) -> Aspect_WindowError

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Aspect.Handle_Aspect_WindowError___ref__(self, *args)


    def __hash__(self):
        return _Aspect.Handle_Aspect_WindowError___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Aspect.Handle_Aspect_WindowError___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Aspect.new_Handle_Aspect_WindowError(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Aspect.Handle_Aspect_WindowError_DownCast)
    __swig_destroy__ = _Aspect.delete_Handle_Aspect_WindowError

    def NewInstance(self, *args):
        """
        NewInstance(Handle_Aspect_WindowError self, Standard_CString const theMessage) -> Handle_Aspect_WindowError

        :type theMessage: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Aspect.Handle_Aspect_WindowError

        """
        return _Aspect.Handle_Aspect_WindowError_NewInstance(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Aspect_WindowError self) -> char const *

        :rtype: const char *

        """
        return _Aspect.Handle_Aspect_WindowError_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Aspect.Handle_Aspect_WindowError_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Aspect.Handle_Aspect_WindowError_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Print(self, *args):
        """
        Print(Handle_Aspect_WindowError self, Standard_OStream & s)

        Prints on the stream <s> the exception name followed by
        the error message.
        Level: Advanced
        Warning:
        The operator "OStream& operator<< (Standard_OStream&,
        Handle(Standard_Failure)&)"
        is implemented. (This operator uses the method Print)

        :type s: OCC.wrapper.Standard.Standard_OStream

        """
        return _Aspect.Handle_Aspect_WindowError_Print(self, *args)


    def GetMessageString(self, *args):
        """
        GetMessageString(Handle_Aspect_WindowError self) -> Standard_CString

        Returns error message

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _Aspect.Handle_Aspect_WindowError_GetMessageString(self, *args)


    def SetMessageString(self, *args):
        """
        SetMessageString(Handle_Aspect_WindowError self, Standard_CString const aMessage)

        Sets error message

        :type aMessage: OCC.wrapper.Standard.Standard_CString

        """
        return _Aspect.Handle_Aspect_WindowError_SetMessageString(self, *args)


    def Reraise(self, *args):
        """
        Reraise(Handle_Aspect_WindowError self)
        Reraise(Handle_Aspect_WindowError self, Standard_CString const aMessage)
        Reraise(Handle_Aspect_WindowError self, Standard_SStream const & aReason)

        Reraises a caught exception and changes its error message.

        :type aReason: OCC.wrapper.Standard.Standard_SStream

        """
        return _Aspect.Handle_Aspect_WindowError_Reraise(self, *args)


    def Jump(self, *args):
        """
        Jump(Handle_Aspect_WindowError self)

        Used to throw CASCADE exception from C signal handler.
        On platforms that do not allow throwing C++ exceptions
        from this handler (e.g. Linux), uses longjump to get to
        the current active signal handler, and only then is
        converted to C++ exception.


        """
        return _Aspect.Handle_Aspect_WindowError_Jump(self, *args)


    def Caught(self, *args):
        """
        Caught(Handle_Aspect_WindowError self) -> Handle_Standard_Failure

        Returns the last caught exception.
        Needed when exceptions are emulated by C longjumps,
        in other cases is also provided for compatibility.

        :rtype: OCC.wrapper.Standard.Handle_Standard_Failure

        """
        return _Aspect.Handle_Aspect_WindowError_Caught(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_Aspect_WindowError self)

        Memory deallocator for transient classes


        """
        return _Aspect.Handle_Aspect_WindowError_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Aspect_WindowError self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Aspect_WindowError self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Aspect.Handle_Aspect_WindowError_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Aspect_WindowError self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Aspect_WindowError self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Aspect.Handle_Aspect_WindowError_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Aspect_WindowError self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Aspect.Handle_Aspect_WindowError_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Aspect_WindowError self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Aspect.Handle_Aspect_WindowError_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Aspect_WindowError self)

        Increments the reference counter of this object


        """
        return _Aspect.Handle_Aspect_WindowError_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Aspect_WindowError self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Aspect.Handle_Aspect_WindowError_DecrementRefCounter(self, *args)

Handle_Aspect_WindowError_swigregister = _Aspect.Handle_Aspect_WindowError_swigregister
Handle_Aspect_WindowError_swigregister(Handle_Aspect_WindowError)

def Handle_Aspect_WindowError_DownCast(thing):
    return _Aspect.Handle_Aspect_WindowError_DownCast(thing)
Handle_Aspect_WindowError_DownCast = _Aspect.Handle_Aspect_WindowError_DownCast

class Handle_Aspect_GraphicDeviceDefinitionError(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Aspect_GraphicDeviceDefinitionError self)

        Nullify the handle


        """
        return _Aspect.Handle_Aspect_GraphicDeviceDefinitionError_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Aspect_GraphicDeviceDefinitionError self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Aspect.Handle_Aspect_GraphicDeviceDefinitionError_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Aspect_GraphicDeviceDefinitionError self, Aspect_GraphicDeviceDefinitionError thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Aspect.Handle_Aspect_GraphicDeviceDefinitionError_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Aspect_GraphicDeviceDefinitionError self, Handle_Aspect_GraphicDeviceDefinitionError theHandle) -> Handle_Aspect_GraphicDeviceDefinitionError
        assign(Handle_Aspect_GraphicDeviceDefinitionError self, Aspect_GraphicDeviceDefinitionError thePtr) -> Handle_Aspect_GraphicDeviceDefinitionError
        assign(Handle_Aspect_GraphicDeviceDefinitionError self, Handle_Aspect_GraphicDeviceDefinitionError theHandle) -> Handle_Aspect_GraphicDeviceDefinitionError

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Aspect.Handle_Aspect_GraphicDeviceDefinitionError_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Aspect_GraphicDeviceDefinitionError self) -> Aspect_GraphicDeviceDefinitionError

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Aspect.Handle_Aspect_GraphicDeviceDefinitionError_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Aspect_GraphicDeviceDefinitionError self) -> Aspect_GraphicDeviceDefinitionError

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Aspect.Handle_Aspect_GraphicDeviceDefinitionError___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Aspect_GraphicDeviceDefinitionError self) -> Aspect_GraphicDeviceDefinitionError

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Aspect.Handle_Aspect_GraphicDeviceDefinitionError___ref__(self, *args)


    def __hash__(self):
        return _Aspect.Handle_Aspect_GraphicDeviceDefinitionError___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Aspect.Handle_Aspect_GraphicDeviceDefinitionError___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Aspect.new_Handle_Aspect_GraphicDeviceDefinitionError(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Aspect.Handle_Aspect_GraphicDeviceDefinitionError_DownCast)
    __swig_destroy__ = _Aspect.delete_Handle_Aspect_GraphicDeviceDefinitionError

    def NewInstance(self, *args):
        """
        NewInstance(Handle_Aspect_GraphicDeviceDefinitionError self, Standard_CString const theMessage) -> Handle_Aspect_GraphicDeviceDefinitionError

        :type theMessage: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Aspect.Handle_Aspect_GraphicDeviceDefinitionError

        """
        return _Aspect.Handle_Aspect_GraphicDeviceDefinitionError_NewInstance(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Aspect_GraphicDeviceDefinitionError self) -> char const *

        :rtype: const char *

        """
        return _Aspect.Handle_Aspect_GraphicDeviceDefinitionError_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Aspect.Handle_Aspect_GraphicDeviceDefinitionError_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Aspect.Handle_Aspect_GraphicDeviceDefinitionError_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Print(self, *args):
        """
        Print(Handle_Aspect_GraphicDeviceDefinitionError self, Standard_OStream & s)

        Prints on the stream <s> the exception name followed by
        the error message.
        Level: Advanced
        Warning:
        The operator "OStream& operator<< (Standard_OStream&,
        Handle(Standard_Failure)&)"
        is implemented. (This operator uses the method Print)

        :type s: OCC.wrapper.Standard.Standard_OStream

        """
        return _Aspect.Handle_Aspect_GraphicDeviceDefinitionError_Print(self, *args)


    def GetMessageString(self, *args):
        """
        GetMessageString(Handle_Aspect_GraphicDeviceDefinitionError self) -> Standard_CString

        Returns error message

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _Aspect.Handle_Aspect_GraphicDeviceDefinitionError_GetMessageString(self, *args)


    def SetMessageString(self, *args):
        """
        SetMessageString(Handle_Aspect_GraphicDeviceDefinitionError self, Standard_CString const aMessage)

        Sets error message

        :type aMessage: OCC.wrapper.Standard.Standard_CString

        """
        return _Aspect.Handle_Aspect_GraphicDeviceDefinitionError_SetMessageString(self, *args)


    def Reraise(self, *args):
        """
        Reraise(Handle_Aspect_GraphicDeviceDefinitionError self)
        Reraise(Handle_Aspect_GraphicDeviceDefinitionError self, Standard_CString const aMessage)
        Reraise(Handle_Aspect_GraphicDeviceDefinitionError self, Standard_SStream const & aReason)

        Reraises a caught exception and changes its error message.

        :type aReason: OCC.wrapper.Standard.Standard_SStream

        """
        return _Aspect.Handle_Aspect_GraphicDeviceDefinitionError_Reraise(self, *args)


    def Jump(self, *args):
        """
        Jump(Handle_Aspect_GraphicDeviceDefinitionError self)

        Used to throw CASCADE exception from C signal handler.
        On platforms that do not allow throwing C++ exceptions
        from this handler (e.g. Linux), uses longjump to get to
        the current active signal handler, and only then is
        converted to C++ exception.


        """
        return _Aspect.Handle_Aspect_GraphicDeviceDefinitionError_Jump(self, *args)


    def Caught(self, *args):
        """
        Caught(Handle_Aspect_GraphicDeviceDefinitionError self) -> Handle_Standard_Failure

        Returns the last caught exception.
        Needed when exceptions are emulated by C longjumps,
        in other cases is also provided for compatibility.

        :rtype: OCC.wrapper.Standard.Handle_Standard_Failure

        """
        return _Aspect.Handle_Aspect_GraphicDeviceDefinitionError_Caught(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_Aspect_GraphicDeviceDefinitionError self)

        Memory deallocator for transient classes


        """
        return _Aspect.Handle_Aspect_GraphicDeviceDefinitionError_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Aspect_GraphicDeviceDefinitionError self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Aspect_GraphicDeviceDefinitionError self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Aspect.Handle_Aspect_GraphicDeviceDefinitionError_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Aspect_GraphicDeviceDefinitionError self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Aspect_GraphicDeviceDefinitionError self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Aspect.Handle_Aspect_GraphicDeviceDefinitionError_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Aspect_GraphicDeviceDefinitionError self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Aspect.Handle_Aspect_GraphicDeviceDefinitionError_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Aspect_GraphicDeviceDefinitionError self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Aspect.Handle_Aspect_GraphicDeviceDefinitionError_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Aspect_GraphicDeviceDefinitionError self)

        Increments the reference counter of this object


        """
        return _Aspect.Handle_Aspect_GraphicDeviceDefinitionError_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Aspect_GraphicDeviceDefinitionError self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Aspect.Handle_Aspect_GraphicDeviceDefinitionError_DecrementRefCounter(self, *args)

Handle_Aspect_GraphicDeviceDefinitionError_swigregister = _Aspect.Handle_Aspect_GraphicDeviceDefinitionError_swigregister
Handle_Aspect_GraphicDeviceDefinitionError_swigregister(Handle_Aspect_GraphicDeviceDefinitionError)

def Handle_Aspect_GraphicDeviceDefinitionError_DownCast(thing):
    return _Aspect.Handle_Aspect_GraphicDeviceDefinitionError_DownCast(thing)
Handle_Aspect_GraphicDeviceDefinitionError_DownCast = _Aspect.Handle_Aspect_GraphicDeviceDefinitionError_DownCast

class Handle_Aspect_Grid(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Aspect_Grid self)

        Nullify the handle


        """
        return _Aspect.Handle_Aspect_Grid_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Aspect_Grid self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Aspect.Handle_Aspect_Grid_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Aspect_Grid self, Aspect_Grid thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Aspect.Handle_Aspect_Grid_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Aspect_Grid self, Handle_Aspect_Grid theHandle) -> Handle_Aspect_Grid
        assign(Handle_Aspect_Grid self, Aspect_Grid thePtr) -> Handle_Aspect_Grid
        assign(Handle_Aspect_Grid self, Handle_Aspect_Grid theHandle) -> Handle_Aspect_Grid

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Aspect.Handle_Aspect_Grid_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Aspect_Grid self) -> Aspect_Grid

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Aspect.Handle_Aspect_Grid_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Aspect_Grid self) -> Aspect_Grid

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Aspect.Handle_Aspect_Grid___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Aspect_Grid self) -> Aspect_Grid

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Aspect.Handle_Aspect_Grid___ref__(self, *args)


    def __hash__(self):
        return _Aspect.Handle_Aspect_Grid___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Aspect.Handle_Aspect_Grid___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Aspect.new_Handle_Aspect_Grid(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Aspect.Handle_Aspect_Grid_DownCast)
    __swig_destroy__ = _Aspect.delete_Handle_Aspect_Grid

    def get_type_name(self, *args):
        """
        get_type_name(Handle_Aspect_Grid self) -> char const *

        :rtype: const char *

        """
        return _Aspect.Handle_Aspect_Grid_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Aspect.Handle_Aspect_Grid_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Aspect.Handle_Aspect_Grid_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetXOrigin(self, *args):
        """
        SetXOrigin(Handle_Aspect_Grid self, Standard_Real const anOrigin)

        defines the x Origin of the grid.

        :type anOrigin: float

        """
        return _Aspect.Handle_Aspect_Grid_SetXOrigin(self, *args)


    def SetYOrigin(self, *args):
        """
        SetYOrigin(Handle_Aspect_Grid self, Standard_Real const anOrigin)

        defines the y Origin of the grid.

        :type anOrigin: float

        """
        return _Aspect.Handle_Aspect_Grid_SetYOrigin(self, *args)


    def SetRotationAngle(self, *args):
        """
        SetRotationAngle(Handle_Aspect_Grid self, Standard_Real const anAngle)

        defines the orientation of the grid.

        :type anAngle: float

        """
        return _Aspect.Handle_Aspect_Grid_SetRotationAngle(self, *args)


    def Rotate(self, *args):
        """
        Rotate(Handle_Aspect_Grid self, Standard_Real const anAngle)

        Rotate the grid from a relative angle.

        :type anAngle: float

        """
        return _Aspect.Handle_Aspect_Grid_Rotate(self, *args)


    def Translate(self, *args):
        """
        Translate(Handle_Aspect_Grid self, Standard_Real const aDx, Standard_Real const aDy)

        Translate the grid from a relative distance.

        :type aDx: float
        :type aDy: float

        """
        return _Aspect.Handle_Aspect_Grid_Translate(self, *args)


    def SetColors(self, *args):
        """
        SetColors(Handle_Aspect_Grid self, Quantity_Color aColor, Quantity_Color aTenthColor)

        Change the colors of the grid

        :type aColor: OCC.wrapper.Quantity.Quantity_Color
        :type aTenthColor: OCC.wrapper.Quantity.Quantity_Color

        """
        return _Aspect.Handle_Aspect_Grid_SetColors(self, *args)


    def Hit(self, *args):
        """
        Hit(Handle_Aspect_Grid self, Standard_Real const X, Standard_Real const Y)

        returns the point of the grid the closest to the point X,Y
        if the grid is active. If the grid is not active returns
        X,Y.

        :type X: float
        :type Y: float
        :type gridX: float
        :type gridY: float

        """
        return _Aspect.Handle_Aspect_Grid_Hit(self, *args)


    def Compute(self, *args):
        """
        Compute(Handle_Aspect_Grid self, Standard_Real const X, Standard_Real const Y)

        returns the point of the grid the closest to the point X,Y

        :type X: float
        :type Y: float
        :type gridX: float
        :type gridY: float

        """
        return _Aspect.Handle_Aspect_Grid_Compute(self, *args)


    def Activate(self, *args):
        """
        Activate(Handle_Aspect_Grid self)

        activates the grid. The Hit method will return
        gridx and gridx computed according to the steps
        of the grid.


        """
        return _Aspect.Handle_Aspect_Grid_Activate(self, *args)


    def Deactivate(self, *args):
        """
        Deactivate(Handle_Aspect_Grid self)

        deactivates the grid. The hit method will return
        gridx and gridx as the enter value X & Y.


        """
        return _Aspect.Handle_Aspect_Grid_Deactivate(self, *args)


    def XOrigin(self, *args):
        """
        XOrigin(Handle_Aspect_Grid self) -> Standard_Real

        returns the x Origin of the grid.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Aspect.Handle_Aspect_Grid_XOrigin(self, *args)


    def YOrigin(self, *args):
        """
        YOrigin(Handle_Aspect_Grid self) -> Standard_Real

        returns the x Origin of the grid.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Aspect.Handle_Aspect_Grid_YOrigin(self, *args)


    def RotationAngle(self, *args):
        """
        RotationAngle(Handle_Aspect_Grid self) -> Standard_Real

        returns the x Angle of the grid.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Aspect.Handle_Aspect_Grid_RotationAngle(self, *args)


    def IsActive(self, *args):
        """
        IsActive(Handle_Aspect_Grid self) -> Standard_Boolean

        Returns TRUE when the grid is active.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Aspect.Handle_Aspect_Grid_IsActive(self, *args)


    def Colors(self, *args):
        """
        Colors(Handle_Aspect_Grid self, Quantity_Color aColor, Quantity_Color aTenthColor)

        Returns the colors of the grid.

        :type aColor: OCC.wrapper.Quantity.Quantity_Color
        :type aTenthColor: OCC.wrapper.Quantity.Quantity_Color

        """
        return _Aspect.Handle_Aspect_Grid_Colors(self, *args)


    def SetDrawMode(self, *args):
        """
        SetDrawMode(Handle_Aspect_Grid self, Aspect_GridDrawMode const aDrawMode)

        Change the grid aspect.

        :type aDrawMode: OCC.wrapper.Aspect.Aspect_GridDrawMode

        """
        return _Aspect.Handle_Aspect_Grid_SetDrawMode(self, *args)


    def DrawMode(self, *args):
        """
        DrawMode(Handle_Aspect_Grid self) -> Aspect_GridDrawMode

        Returns the grid aspect.

        :rtype: OCC.wrapper.Aspect.Aspect_GridDrawMode

        """
        return _Aspect.Handle_Aspect_Grid_DrawMode(self, *args)


    def Display(self, *args):
        """
        Display(Handle_Aspect_Grid self)

        Display the grid at screen.


        """
        return _Aspect.Handle_Aspect_Grid_Display(self, *args)


    def Erase(self, *args):
        """
        Erase(Handle_Aspect_Grid self)

        Erase the grid from screen.


        """
        return _Aspect.Handle_Aspect_Grid_Erase(self, *args)


    def IsDisplayed(self, *args):
        """
        IsDisplayed(Handle_Aspect_Grid self) -> Standard_Boolean

        Returns TRUE when the grid is displayed at screen.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Aspect.Handle_Aspect_Grid_IsDisplayed(self, *args)


    def Init(self, *args):
        """Init(Handle_Aspect_Grid self)"""
        return _Aspect.Handle_Aspect_Grid_Init(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_Aspect_Grid self)

        Memory deallocator for transient classes


        """
        return _Aspect.Handle_Aspect_Grid_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Aspect_Grid self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Aspect_Grid self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Aspect.Handle_Aspect_Grid_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Aspect_Grid self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Aspect_Grid self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Aspect.Handle_Aspect_Grid_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Aspect_Grid self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Aspect.Handle_Aspect_Grid_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Aspect_Grid self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Aspect.Handle_Aspect_Grid_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Aspect_Grid self)

        Increments the reference counter of this object


        """
        return _Aspect.Handle_Aspect_Grid_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Aspect_Grid self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Aspect.Handle_Aspect_Grid_DecrementRefCounter(self, *args)

Handle_Aspect_Grid_swigregister = _Aspect.Handle_Aspect_Grid_swigregister
Handle_Aspect_Grid_swigregister(Handle_Aspect_Grid)

def Handle_Aspect_Grid_DownCast(thing):
    return _Aspect.Handle_Aspect_Grid_DownCast(thing)
Handle_Aspect_Grid_DownCast = _Aspect.Handle_Aspect_Grid_DownCast

class NCollection_Sequence_Quantity_Color(NCollection.NCollection_BaseSequence):
    """
    Purpose:     Definition of a sequence of elements indexed by
    an Integer in range of 1..n
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Sequence_Quantity_Color self) -> NCollection_Sequence< Quantity_Color >::iterator

        Returns an iterator pointing to the first element in the sequence.

        :rtype: iterator

        """
        return _Aspect.NCollection_Sequence_Quantity_Color_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Sequence_Quantity_Color self) -> NCollection_Sequence< Quantity_Color >::iterator

        Returns an iterator referring to the past-the-end element in the sequence.

        :rtype: iterator

        """
        return _Aspect.NCollection_Sequence_Quantity_Color_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Sequence_Quantity_Color self) -> NCollection_Sequence< Quantity_Color >::const_iterator

        Returns a const iterator pointing to the first element in the sequence.

        :rtype: const_iterator

        """
        return _Aspect.NCollection_Sequence_Quantity_Color_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Sequence_Quantity_Color self) -> NCollection_Sequence< Quantity_Color >::const_iterator

        Returns a const iterator referring to the past-the-end element in the sequence.

        :rtype: const_iterator

        """
        return _Aspect.NCollection_Sequence_Quantity_Color_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     Definition of a sequence of elements indexed by
        an Integer in range of 1..n
        """
        this = _Aspect.new_NCollection_Sequence_Quantity_Color(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Size(self, *args):
        """
        Size(NCollection_Sequence_Quantity_Color self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Aspect.NCollection_Sequence_Quantity_Color_Size(self, *args)


    def Length(self, *args):
        """
        Length(NCollection_Sequence_Quantity_Color self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Aspect.NCollection_Sequence_Quantity_Color_Length(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Sequence_Quantity_Color self) -> Standard_Integer

        Method for consistency with other collections.
        @return Lower bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Aspect.NCollection_Sequence_Quantity_Color_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Sequence_Quantity_Color self) -> Standard_Integer

        Method for consistency with other collections.
        @return Upper bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Aspect.NCollection_Sequence_Quantity_Color_Upper(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Sequence_Quantity_Color self) -> Standard_Boolean

        Empty query

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Aspect.NCollection_Sequence_Quantity_Color_IsEmpty(self, *args)


    def Reverse(self, *args):
        """
        Reverse(NCollection_Sequence_Quantity_Color self)

        Reverse sequence


        """
        return _Aspect.NCollection_Sequence_Quantity_Color_Reverse(self, *args)


    def Exchange(self, *args):
        """
        Exchange(NCollection_Sequence_Quantity_Color self, Standard_Integer const I, Standard_Integer const J)

        Exchange two members

        :type I: int
        :type J: int

        """
        return _Aspect.NCollection_Sequence_Quantity_Color_Exchange(self, *args)


    def delNode(*args):
        """
        delNode(NCollection_SeqNode theNode, Handle_NCollection_BaseAllocator theAl)

        Static deleter to be passed to BaseSequence

        :type theNode: OCC.wrapper.NCollection.NCollection_SeqNode
        :type theAl: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _Aspect.NCollection_Sequence_Quantity_Color_delNode(*args)

    delNode = staticmethod(delNode)

    def Clear(self, *args):
        """
        Clear(NCollection_Sequence_Quantity_Color self, Handle_NCollection_BaseAllocator theAllocator=0)

        Clear the items out, take a new allocator if non null

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _Aspect.NCollection_Sequence_Quantity_Color_Clear(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Sequence_Quantity_Color self, NCollection_Sequence_Quantity_Color theOther) -> NCollection_Sequence_Quantity_Color

        Replace this sequence by the items of theOther.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_Sequence
        :rtype: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _Aspect.NCollection_Sequence_Quantity_Color_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Sequence_Quantity_Color self, NCollection_Sequence_Quantity_Color theOther) -> NCollection_Sequence_Quantity_Color

        Replacement operator

        :type theOther: OCC.wrapper.NCollection.NCollection_Sequence
        :rtype: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _Aspect.NCollection_Sequence_Quantity_Color_assign(self, *args)


    def Remove(self, *args):
        """
        Remove(NCollection_Sequence_Quantity_Color self, NCollection_Sequence< Quantity_Color >::Iterator & thePosition)
        Remove(NCollection_Sequence_Quantity_Color self, Standard_Integer const theIndex)
        Remove(NCollection_Sequence_Quantity_Color self, Standard_Integer const theFromIndex, Standard_Integer const theToIndex)

        Remove range of items

        :type theFromIndex: int
        :type theToIndex: int

        """
        return _Aspect.NCollection_Sequence_Quantity_Color_Remove(self, *args)


    def Append(self, *args):
        """
        Append(NCollection_Sequence_Quantity_Color self, Quantity_Color theItem)
        Append(NCollection_Sequence_Quantity_Color self, NCollection_Sequence_Quantity_Color theSeq)

        Append another sequence (making it empty)

        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _Aspect.NCollection_Sequence_Quantity_Color_Append(self, *args)


    def Prepend(self, *args):
        """
        Prepend(NCollection_Sequence_Quantity_Color self, Quantity_Color theItem)
        Prepend(NCollection_Sequence_Quantity_Color self, NCollection_Sequence_Quantity_Color theSeq)

        Prepend another sequence (making it empty)

        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _Aspect.NCollection_Sequence_Quantity_Color_Prepend(self, *args)


    def InsertBefore(self, *args):
        """
        InsertBefore(NCollection_Sequence_Quantity_Color self, Standard_Integer const theIndex, Quantity_Color theItem)
        InsertBefore(NCollection_Sequence_Quantity_Color self, Standard_Integer const theIndex, NCollection_Sequence_Quantity_Color theSeq)

        InsertBefore theIndex another sequence

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _Aspect.NCollection_Sequence_Quantity_Color_InsertBefore(self, *args)


    def InsertAfter(self, *args):
        """
        InsertAfter(NCollection_Sequence_Quantity_Color self, NCollection_Sequence< Quantity_Color >::Iterator & thePosition, Quantity_Color theItem)
        InsertAfter(NCollection_Sequence_Quantity_Color self, Standard_Integer const theIndex, NCollection_Sequence_Quantity_Color theSeq)
        InsertAfter(NCollection_Sequence_Quantity_Color self, Standard_Integer const theIndex, Quantity_Color theItem)

        InsertAfter theIndex another sequence

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _Aspect.NCollection_Sequence_Quantity_Color_InsertAfter(self, *args)


    def Split(self, *args):
        """
        Split(NCollection_Sequence_Quantity_Color self, Standard_Integer const theIndex, NCollection_Sequence_Quantity_Color theSeq)

        Split in two sequences

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _Aspect.NCollection_Sequence_Quantity_Color_Split(self, *args)


    def First(self, *args):
        """
        First item access

        :rtype: const TheItemType &

        """
        res = _Aspect.NCollection_Sequence_Quantity_Color_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Sequence_Quantity_Color self) -> Quantity_Color

        First item access

        :rtype: TheItemType &

        """
        return _Aspect.NCollection_Sequence_Quantity_Color_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        Last item access

        :rtype: const TheItemType &

        """
        res = _Aspect.NCollection_Sequence_Quantity_Color_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Sequence_Quantity_Color self) -> Quantity_Color

        Last item access

        :rtype: TheItemType &

        """
        return _Aspect.NCollection_Sequence_Quantity_Color_ChangeLast(self, *args)


    def Value(self, *args):
        """
        Constant item access by theIndex

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _Aspect.NCollection_Sequence_Quantity_Color_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Sequence_Quantity_Color self, Standard_Integer const theIndex) -> Quantity_Color

        Variable item access by theIndex

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _Aspect.NCollection_Sequence_Quantity_Color_ChangeValue(self, *args)


    def __call__(self, *args):
        """
        Constant operator()

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _Aspect.NCollection_Sequence_Quantity_Color___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetValue(self, *args):
        """
        SetValue(NCollection_Sequence_Quantity_Color self, Standard_Integer const theIndex, Quantity_Color theItem)

        Set item value by theIndex

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _Aspect.NCollection_Sequence_Quantity_Color_SetValue(self, *args)


    def __iter__(self):
        return _Aspect.NCollection_Sequence_Quantity_Color___iter__(self)
    __swig_destroy__ = _Aspect.delete_NCollection_Sequence_Quantity_Color
NCollection_Sequence_Quantity_Color_swigregister = _Aspect.NCollection_Sequence_Quantity_Color_swigregister
NCollection_Sequence_Quantity_Color_swigregister(NCollection_Sequence_Quantity_Color)

def NCollection_Sequence_Quantity_Color_delNode(*args):
    """
    NCollection_Sequence_Quantity_Color_delNode(NCollection_SeqNode theNode, Handle_NCollection_BaseAllocator theAl)

    Static deleter to be passed to BaseSequence

    :type theNode: OCC.wrapper.NCollection.NCollection_SeqNode
    :type theAl: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

    """
    return _Aspect.NCollection_Sequence_Quantity_Color_delNode(*args)

class NCollection_Sequence_Quantity_Color_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _Aspect.new_NCollection_Sequence_Quantity_Color_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _Aspect.delete_NCollection_Sequence_Quantity_Color_IteratorHelper

    def __next__(self):
        return _Aspect.NCollection_Sequence_Quantity_Color_IteratorHelper___next__(self)
NCollection_Sequence_Quantity_Color_IteratorHelper_swigregister = _Aspect.NCollection_Sequence_Quantity_Color_IteratorHelper_swigregister
NCollection_Sequence_Quantity_Color_IteratorHelper_swigregister(NCollection_Sequence_Quantity_Color_IteratorHelper)


try:
	Aspect_SequenceOfColor = NCollection_Sequence_Quantity_Color
except NameError:
	pass # does not exist, probably ignored




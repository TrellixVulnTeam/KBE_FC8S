# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_BRepTools')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_BRepTools')
    _BRepTools = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_BRepTools', [dirname(__file__)])
        except ImportError:
            import _BRepTools
            return _BRepTools
        try:
            _mod = imp.load_module('_BRepTools', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _BRepTools = swig_import_helper()
    del swig_import_helper
else:
    import _BRepTools
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


class SwigPyIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _BRepTools.delete_SwigPyIterator

    def value(self):
        return _BRepTools.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _BRepTools.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _BRepTools.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _BRepTools.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _BRepTools.SwigPyIterator_equal(self, x)

    def copy(self):
        return _BRepTools.SwigPyIterator_copy(self)

    def next(self):
        return _BRepTools.SwigPyIterator_next(self)

    def __next__(self):
        return _BRepTools.SwigPyIterator___next__(self)

    def previous(self):
        return _BRepTools.SwigPyIterator_previous(self)

    def advance(self, n):
        return _BRepTools.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _BRepTools.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _BRepTools.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _BRepTools.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _BRepTools.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _BRepTools.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _BRepTools.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self
SwigPyIterator_swigregister = _BRepTools.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

class NCollection_CellFilter_InspectorXYZ(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _BRepTools.NCollection_CellFilter_InspectorXYZ_Dimension
    Coord = staticmethod(_BRepTools.NCollection_CellFilter_InspectorXYZ_Coord)

    def Shift(self, thePnt, theTol):
        return _BRepTools.NCollection_CellFilter_InspectorXYZ_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _BRepTools.new_NCollection_CellFilter_InspectorXYZ()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _BRepTools.delete_NCollection_CellFilter_InspectorXYZ
NCollection_CellFilter_InspectorXYZ_swigregister = _BRepTools.NCollection_CellFilter_InspectorXYZ_swigregister
NCollection_CellFilter_InspectorXYZ_swigregister(NCollection_CellFilter_InspectorXYZ)

def NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt):
    return _BRepTools.NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt)
NCollection_CellFilter_InspectorXYZ_Coord = _BRepTools.NCollection_CellFilter_InspectorXYZ_Coord

class NCollection_CellFilter_InspectorXY(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _BRepTools.NCollection_CellFilter_InspectorXY_Dimension
    Coord = staticmethod(_BRepTools.NCollection_CellFilter_InspectorXY_Coord)

    def Shift(self, thePnt, theTol):
        return _BRepTools.NCollection_CellFilter_InspectorXY_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _BRepTools.new_NCollection_CellFilter_InspectorXY()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _BRepTools.delete_NCollection_CellFilter_InspectorXY
NCollection_CellFilter_InspectorXY_swigregister = _BRepTools.NCollection_CellFilter_InspectorXY_swigregister
NCollection_CellFilter_InspectorXY_swigregister(NCollection_CellFilter_InspectorXY)

def NCollection_CellFilter_InspectorXY_Coord(i, thePnt):
    return _BRepTools.NCollection_CellFilter_InspectorXY_Coord(i, thePnt)
NCollection_CellFilter_InspectorXY_Coord = _BRepTools.NCollection_CellFilter_InspectorXY_Coord


def ptr_to_number(item):
    return _BRepTools.ptr_to_number(item)
ptr_to_number = _BRepTools.ptr_to_number

def HashCode(*args):
    return _BRepTools.HashCode(*args)
HashCode = _BRepTools.HashCode

def ptr_equal(a, b):
    return _BRepTools.ptr_equal(a, b)
ptr_equal = _BRepTools.ptr_equal
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Geom2d
else:
    import Geom2d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import GeomAbs
else:
    import GeomAbs
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColStd
else:
    import TColStd
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TCollection
else:
    import TCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Standard
else:
    import Standard
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import NCollection
else:
    import NCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import gp
else:
    import gp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColgp
else:
    import TColgp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Bnd
else:
    import Bnd
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Poly
else:
    import Poly
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TShort
else:
    import TShort
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopAbs
else:
    import TopAbs
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Geom
else:
    import Geom
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Message
else:
    import Message
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopLoc
else:
    import TopLoc
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopoDS
else:
    import TopoDS
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopTools
else:
    import TopTools
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import BRep
else:
    import BRep
del _swig_python_version_info
class BRepTools_Modification(Standard.Standard_Transient):
    """
    Defines geometric modifications to a shape, i.e.
    changes to faces, edges and vertices.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_BRepTools_Modification
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_BRepTools_Modification(self) 
            return h


    def NewSurface(self, *args):
        """
        NewSurface(BRepTools_Modification self, TopoDS_Face F, Handle_Geom_Surface S, TopLoc_Location L) -> Standard_Boolean

        Returns true if the face, F, has been modified.
        If the face has been modified:
        - S is the new geometry of the face,
        - L is its new location, and
        - Tol is the new tolerance.
        The flag, RevWires, is set to true when the
        modification reverses the normal of the surface, (i.e.
        the wires have to be reversed).
        The flag, RevFace, is set to true if the orientation of
        the modified face changes in the shells which contain it.
        If the face has not been modified this function returns
        false, and the values of S, L, Tol, RevWires and
        RevFace are not significant.

        :type F: OCC.wrapper.TopoDS.TopoDS_Face
        :type S: OCC.wrapper.Geom.Handle_Geom_Surface
        :type L: OCC.wrapper.TopLoc.TopLoc_Location
        :type Tol: float
        :type RevWires: bool
        :type RevFace: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepTools.BRepTools_Modification_NewSurface(self, *args)


    def NewTriangulation(self, *args):
        """
        NewTriangulation(BRepTools_Modification self, TopoDS_Face F, Handle_Poly_Triangulation T) -> Standard_Boolean

        Returns true if the face has been modified according to changed triangulation.
        If the face has been modified:
        - T is a new triangulation on the face

        :type F: OCC.wrapper.TopoDS.TopoDS_Face
        :type T: OCC.wrapper.Poly.Handle_Poly_Triangulation
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepTools.BRepTools_Modification_NewTriangulation(self, *args)


    def NewCurve(self, *args):
        """
        NewCurve(BRepTools_Modification self, TopoDS_Edge E, Handle_Geom_Curve C, TopLoc_Location L) -> Standard_Boolean

        Returns true if the edge, E, has been modified.
        If the edge has been modified:
        - C is the new geometry associated with the edge,
        - L is its new location, and
        - Tol is the new tolerance.
        If the edge has not been modified, this function
        returns false, and the values of C, L and Tol are not significant.

        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :type C: OCC.wrapper.Geom.Handle_Geom_Curve
        :type L: OCC.wrapper.TopLoc.TopLoc_Location
        :type Tol: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepTools.BRepTools_Modification_NewCurve(self, *args)


    def NewPolygon(self, *args):
        """
        NewPolygon(BRepTools_Modification self, TopoDS_Edge E, Handle_Poly_Polygon3D P) -> Standard_Boolean

        Returns true if the edge has been modified according to changed polygon.
        If the edge has been modified:
        - P is a new polygon

        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :type P: OCC.wrapper.Poly.Handle_Poly_Polygon3D
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepTools.BRepTools_Modification_NewPolygon(self, *args)


    def NewPolygonOnTriangulation(self, *args):
        """
        NewPolygonOnTriangulation(BRepTools_Modification self, TopoDS_Edge E, TopoDS_Face F, Handle_Poly_PolygonOnTriangulation P) -> Standard_Boolean

        Returns true if the edge has been modified according to changed polygon on triangulation.
        If the edge has been modified:
        - P is a new polygon on triangulation

        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :type F: OCC.wrapper.TopoDS.TopoDS_Face
        :type P: OCC.wrapper.Poly.Handle_Poly_PolygonOnTriangulation
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepTools.BRepTools_Modification_NewPolygonOnTriangulation(self, *args)


    def NewPoint(self, *args):
        """
        NewPoint(BRepTools_Modification self, TopoDS_Vertex V, gp_Pnt P) -> Standard_Boolean

        Returns true if the vertex V has been modified.
        If V has been modified:
        - P is the new geometry of the vertex, and
        - Tol is the new tolerance.
        If the vertex has not been modified this function
        returns false, and the values of P and Tol are not significant.

        :type V: OCC.wrapper.TopoDS.TopoDS_Vertex
        :type P: OCC.wrapper.gp.gp_Pnt
        :type Tol: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepTools.BRepTools_Modification_NewPoint(self, *args)


    def NewCurve2d(self, *args):
        """
        NewCurve2d(BRepTools_Modification self, TopoDS_Edge E, TopoDS_Face F, TopoDS_Edge NewE, TopoDS_Face NewF, Handle_Geom2d_Curve C) -> Standard_Boolean

        Returns true if the edge, E, has a new curve on
        surface on the face, F.
        If a new curve exists:
        - C is the new geometry of the edge,
        - L is the new location, and
        - Tol is the new tolerance.
        NewE is the new edge created from E, and NewF is
        the new face created from F.
        If there is no new curve on the face, this function
        returns false, and the values of C, L and Tol are not significant.

        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :type F: OCC.wrapper.TopoDS.TopoDS_Face
        :type NewE: OCC.wrapper.TopoDS.TopoDS_Edge
        :type NewF: OCC.wrapper.TopoDS.TopoDS_Face
        :type C: OCC.wrapper.Geom2d.Handle_Geom2d_Curve
        :type Tol: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepTools.BRepTools_Modification_NewCurve2d(self, *args)


    def NewParameter(self, *args):
        """
        NewParameter(BRepTools_Modification self, TopoDS_Vertex V, TopoDS_Edge E) -> Standard_Boolean

        Returns true if the vertex V has a new parameter on the edge E.
        If a new parameter exists:
        - P is the parameter, and
        - Tol is the new tolerance.
        If there is no new parameter this function returns
        false, and the values of P and Tol are not significant.

        :type V: OCC.wrapper.TopoDS.TopoDS_Vertex
        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :type P: float
        :type Tol: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepTools.BRepTools_Modification_NewParameter(self, *args)


    def Continuity(self, *args):
        """
        Continuity(BRepTools_Modification self, TopoDS_Edge E, TopoDS_Face F1, TopoDS_Face F2, TopoDS_Edge NewE, TopoDS_Face NewF1, TopoDS_Face NewF2) -> GeomAbs_Shape

        Returns the  continuity of  <NewE> between <NewF1>
        and <NewF2>.
        <NewE> is the new  edge created from <E>.  <NewF1>
        (resp. <NewF2>) is the new  face created from <F1>
        (resp. <F2>).

        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :type F1: OCC.wrapper.TopoDS.TopoDS_Face
        :type F2: OCC.wrapper.TopoDS.TopoDS_Face
        :type NewE: OCC.wrapper.TopoDS.TopoDS_Edge
        :type NewF1: OCC.wrapper.TopoDS.TopoDS_Face
        :type NewF2: OCC.wrapper.TopoDS.TopoDS_Face
        :rtype: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _BRepTools.BRepTools_Modification_Continuity(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _BRepTools.BRepTools_Modification_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _BRepTools.BRepTools_Modification_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _BRepTools.BRepTools_Modification_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _BRepTools.delete_BRepTools_Modification
BRepTools_Modification_swigregister = _BRepTools.BRepTools_Modification_swigregister
BRepTools_Modification_swigregister(BRepTools_Modification)

def BRepTools_Modification_get_type_name(*args):
    """
    BRepTools_Modification_get_type_name() -> char const *

    :rtype: const char *

    """
    return _BRepTools.BRepTools_Modification_get_type_name(*args)

def BRepTools_Modification_get_type_descriptor(*args):
    """
    BRepTools_Modification_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _BRepTools.BRepTools_Modification_get_type_descriptor(*args)

class BRepTools_NurbsConvertModification(BRepTools_Modification):
    """
    Defines a modification of the  geometry by a  Trsf
    from gp. All methods return True and transform the
    geometry.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_BRepTools_NurbsConvertModification
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_BRepTools_NurbsConvertModification(self) 
            return h


    def __init__(self, *args):
        """
        __init__(BRepTools_NurbsConvertModification self) -> BRepTools_NurbsConvertModification

        Defines a modification of the  geometry by a  Trsf
        from gp. All methods return True and transform the
        geometry.
        """
        this = _BRepTools.new_BRepTools_NurbsConvertModification(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def NewSurface(self, *args):
        """
        NewSurface(BRepTools_NurbsConvertModification self, TopoDS_Face F, Handle_Geom_Surface S, TopLoc_Location L) -> Standard_Boolean

        Returns Standard_True  if  the face  <F> has  been
        modified.  In this  case, <S> is the new geometric
        support of  the  face, <L> the  new location,<Tol>
        the new  tolerance.<RevWires> has  to  be set   to
        Standard_True   when the modification reverses the
        normal of  the   surface.(the wires   have  to  be
        reversed).   <RevFace>   has   to   be   set    to
        Standard_True if  the orientation  of the modified
        face changes in the  shells which contain  it.  --
        Here, <RevFace>  will  return Standard_True if the
        -- gp_Trsf is negative.

        :type F: OCC.wrapper.TopoDS.TopoDS_Face
        :type S: OCC.wrapper.Geom.Handle_Geom_Surface
        :type L: OCC.wrapper.TopLoc.TopLoc_Location
        :type Tol: float
        :type RevWires: bool
        :type RevFace: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepTools.BRepTools_NurbsConvertModification_NewSurface(self, *args)


    def NewCurve(self, *args):
        """
        NewCurve(BRepTools_NurbsConvertModification self, TopoDS_Edge E, Handle_Geom_Curve C, TopLoc_Location L) -> Standard_Boolean

        Returns Standard_True  if  the edge  <E> has  been
        modified.  In this case,  <C> is the new geometric
        support of the  edge, <L> the  new location, <Tol>
        the         new    tolerance.   Otherwise, returns
        Standard_False,    and  <C>,  <L>,   <Tol> are not
        significant.

        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :type C: OCC.wrapper.Geom.Handle_Geom_Curve
        :type L: OCC.wrapper.TopLoc.TopLoc_Location
        :type Tol: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepTools.BRepTools_NurbsConvertModification_NewCurve(self, *args)


    def NewPoint(self, *args):
        """
        NewPoint(BRepTools_NurbsConvertModification self, TopoDS_Vertex V, gp_Pnt P) -> Standard_Boolean

        Returns  Standard_True if the  vertex <V> has been
        modified.  In this  case, <P> is the new geometric
        support of the vertex,   <Tol> the new  tolerance.
        Otherwise, returns Standard_False, and <P>,  <Tol>
        are not significant.

        :type V: OCC.wrapper.TopoDS.TopoDS_Vertex
        :type P: OCC.wrapper.gp.gp_Pnt
        :type Tol: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepTools.BRepTools_NurbsConvertModification_NewPoint(self, *args)


    def NewCurve2d(self, *args):
        """
        NewCurve2d(BRepTools_NurbsConvertModification self, TopoDS_Edge E, TopoDS_Face F, TopoDS_Edge NewE, TopoDS_Face NewF, Handle_Geom2d_Curve C) -> Standard_Boolean

        Returns Standard_True if  the edge  <E> has a  new
        curve on surface on the face <F>.In this case, <C>
        is the new geometric support of  the edge, <L> the
        new location, <Tol> the new tolerance.
        Otherwise, returns  Standard_False, and <C>,  <L>,
        <Tol> are not significant.

        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :type F: OCC.wrapper.TopoDS.TopoDS_Face
        :type NewE: OCC.wrapper.TopoDS.TopoDS_Edge
        :type NewF: OCC.wrapper.TopoDS.TopoDS_Face
        :type C: OCC.wrapper.Geom2d.Handle_Geom2d_Curve
        :type Tol: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepTools.BRepTools_NurbsConvertModification_NewCurve2d(self, *args)


    def NewParameter(self, *args):
        """
        NewParameter(BRepTools_NurbsConvertModification self, TopoDS_Vertex V, TopoDS_Edge E) -> Standard_Boolean

        Returns Standard_True if the Vertex  <V> has a new
        parameter on the  edge <E>. In  this case,  <P> is
        the parameter,    <Tol>  the     new    tolerance.
        Otherwise, returns Standard_False, and <P>,  <Tol>
        are not significant.

        :type V: OCC.wrapper.TopoDS.TopoDS_Vertex
        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :type P: float
        :type Tol: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepTools.BRepTools_NurbsConvertModification_NewParameter(self, *args)


    def Continuity(self, *args):
        """
        Continuity(BRepTools_NurbsConvertModification self, TopoDS_Edge E, TopoDS_Face F1, TopoDS_Face F2, TopoDS_Edge NewE, TopoDS_Face NewF1, TopoDS_Face NewF2) -> GeomAbs_Shape

        Returns the  continuity of  <NewE> between <NewF1>
        and <NewF2>.

        <NewE> is the new  edge created from <E>.  <NewF1>
        (resp. <NewF2>) is the new  face created from <F1>
        (resp. <F2>).

        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :type F1: OCC.wrapper.TopoDS.TopoDS_Face
        :type F2: OCC.wrapper.TopoDS.TopoDS_Face
        :type NewE: OCC.wrapper.TopoDS.TopoDS_Edge
        :type NewF1: OCC.wrapper.TopoDS.TopoDS_Face
        :type NewF2: OCC.wrapper.TopoDS.TopoDS_Face
        :rtype: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _BRepTools.BRepTools_NurbsConvertModification_Continuity(self, *args)


    def GetUpdatedEdges(self, *args):
        """
        :rtype: OCC.wrapper.TopTools.TopTools_ListOfShape

        """
        res = _BRepTools.BRepTools_NurbsConvertModification_GetUpdatedEdges(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _BRepTools.BRepTools_NurbsConvertModification_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _BRepTools.BRepTools_NurbsConvertModification_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _BRepTools.BRepTools_NurbsConvertModification_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _BRepTools.delete_BRepTools_NurbsConvertModification
BRepTools_NurbsConvertModification_swigregister = _BRepTools.BRepTools_NurbsConvertModification_swigregister
BRepTools_NurbsConvertModification_swigregister(BRepTools_NurbsConvertModification)

def BRepTools_NurbsConvertModification_get_type_name(*args):
    """
    BRepTools_NurbsConvertModification_get_type_name() -> char const *

    :rtype: const char *

    """
    return _BRepTools.BRepTools_NurbsConvertModification_get_type_name(*args)

def BRepTools_NurbsConvertModification_get_type_descriptor(*args):
    """
    BRepTools_NurbsConvertModification_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _BRepTools.BRepTools_NurbsConvertModification_get_type_descriptor(*args)

class BRepTools_TrsfModification(BRepTools_Modification):
    """
    Describes a modification that uses a gp_Trsf to
    change the geometry of a shape. All functions return
    true and transform the geometry of the shape.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_BRepTools_TrsfModification
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_BRepTools_TrsfModification(self) 
            return h


    def __init__(self, *args):
        """
        __init__(BRepTools_TrsfModification self, gp_Trsf T) -> BRepTools_TrsfModification

        :type T: OCC.wrapper.gp.gp_Trsf

        """
        this = _BRepTools.new_BRepTools_TrsfModification(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Trsf(self, *args):
        """
        Trsf(BRepTools_TrsfModification self) -> gp_Trsf

        Provides access to the gp_Trsf associated with this
        modification. The transformation can be changed.

        :rtype: OCC.wrapper.gp.gp_Trsf

        """
        return _BRepTools.BRepTools_TrsfModification_Trsf(self, *args)


    def NewSurface(self, *args):
        """
        NewSurface(BRepTools_TrsfModification self, TopoDS_Face F, Handle_Geom_Surface S, TopLoc_Location L) -> Standard_Boolean

        Returns true if the face F has been modified.
        If the face has been modified:
        - S is the new geometry of the face,
        - L is its new location, and
        - Tol is the new tolerance.
        RevWires is set to true when the modification
        reverses the normal of the surface (the wires have to be reversed).
        RevFace is set to true if the orientation of the
        modified face changes in the shells which contain it.
        For this class, RevFace returns true if the gp_Trsf
        associated with this modification is negative.

        :type F: OCC.wrapper.TopoDS.TopoDS_Face
        :type S: OCC.wrapper.Geom.Handle_Geom_Surface
        :type L: OCC.wrapper.TopLoc.TopLoc_Location
        :type Tol: float
        :type RevWires: bool
        :type RevFace: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepTools.BRepTools_TrsfModification_NewSurface(self, *args)


    def NewCurve(self, *args):
        """
        NewCurve(BRepTools_TrsfModification self, TopoDS_Edge E, Handle_Geom_Curve C, TopLoc_Location L) -> Standard_Boolean

        Returns true if the edge E has been modified.
        If the edge has been modified:
        - C is the new geometric support of the edge,
        - L is the new location, and
        - Tol is the new tolerance.
        If the edge has not been modified, this function
        returns false, and the values of C, L and Tol are not significant.

        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :type C: OCC.wrapper.Geom.Handle_Geom_Curve
        :type L: OCC.wrapper.TopLoc.TopLoc_Location
        :type Tol: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepTools.BRepTools_TrsfModification_NewCurve(self, *args)


    def NewPoint(self, *args):
        """
        NewPoint(BRepTools_TrsfModification self, TopoDS_Vertex V, gp_Pnt P) -> Standard_Boolean

        Returns true if the vertex V has been modified.
        If the vertex has been modified:
        - P is the new geometry of the vertex, and
        - Tol is the new tolerance.
        If the vertex has not been modified this function
        returns false, and the values of P and Tol are not significant.

        :type V: OCC.wrapper.TopoDS.TopoDS_Vertex
        :type P: OCC.wrapper.gp.gp_Pnt
        :type Tol: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepTools.BRepTools_TrsfModification_NewPoint(self, *args)


    def NewCurve2d(self, *args):
        """
        NewCurve2d(BRepTools_TrsfModification self, TopoDS_Edge E, TopoDS_Face F, TopoDS_Edge NewE, TopoDS_Face NewF, Handle_Geom2d_Curve C) -> Standard_Boolean

        Returns true if the edge E has a new curve on surface on the face F.
        If a new curve exists:
        - C is the new geometric support of the edge,
        - L is the new location, and
        - Tol the new tolerance.
        If no new curve exists, this function returns false, and
        the values of C, L and Tol are not significant.

        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :type F: OCC.wrapper.TopoDS.TopoDS_Face
        :type NewE: OCC.wrapper.TopoDS.TopoDS_Edge
        :type NewF: OCC.wrapper.TopoDS.TopoDS_Face
        :type C: OCC.wrapper.Geom2d.Handle_Geom2d_Curve
        :type Tol: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepTools.BRepTools_TrsfModification_NewCurve2d(self, *args)


    def NewParameter(self, *args):
        """
        NewParameter(BRepTools_TrsfModification self, TopoDS_Vertex V, TopoDS_Edge E) -> Standard_Boolean

        Returns true if the Vertex V has a new parameter on the edge E.
        If a new parameter exists:
        - P is the parameter, and
        - Tol is the new tolerance.
        If no new parameter exists, this function returns false,
        and the values of P and Tol are not significant.

        :type V: OCC.wrapper.TopoDS.TopoDS_Vertex
        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :type P: float
        :type Tol: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepTools.BRepTools_TrsfModification_NewParameter(self, *args)


    def Continuity(self, *args):
        """
        Continuity(BRepTools_TrsfModification self, TopoDS_Edge E, TopoDS_Face F1, TopoDS_Face F2, TopoDS_Edge NewE, TopoDS_Face NewF1, TopoDS_Face NewF2) -> GeomAbs_Shape

        Returns the  continuity of  <NewE> between <NewF1>
        and <NewF2>.

        <NewE> is the new  edge created from <E>.  <NewF1>
        (resp. <NewF2>) is the new  face created from <F1>
        (resp. <F2>).

        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :type F1: OCC.wrapper.TopoDS.TopoDS_Face
        :type F2: OCC.wrapper.TopoDS.TopoDS_Face
        :type NewE: OCC.wrapper.TopoDS.TopoDS_Edge
        :type NewF1: OCC.wrapper.TopoDS.TopoDS_Face
        :type NewF2: OCC.wrapper.TopoDS.TopoDS_Face
        :rtype: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _BRepTools.BRepTools_TrsfModification_Continuity(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _BRepTools.BRepTools_TrsfModification_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _BRepTools.BRepTools_TrsfModification_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _BRepTools.BRepTools_TrsfModification_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _BRepTools.delete_BRepTools_TrsfModification
BRepTools_TrsfModification_swigregister = _BRepTools.BRepTools_TrsfModification_swigregister
BRepTools_TrsfModification_swigregister(BRepTools_TrsfModification)

def BRepTools_TrsfModification_get_type_name(*args):
    """
    BRepTools_TrsfModification_get_type_name() -> char const *

    :rtype: const char *

    """
    return _BRepTools.BRepTools_TrsfModification_get_type_name(*args)

def BRepTools_TrsfModification_get_type_descriptor(*args):
    """
    BRepTools_TrsfModification_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _BRepTools.BRepTools_TrsfModification_get_type_descriptor(*args)

class BRepTools_History(Standard.Standard_Transient):
    """
    The history keeps the following relations between the input shapes
    (S1, ..., Sm) and output shapes (T1, ..., Tn):
    1) an output shape Tj is generated from an input shape Si: Tj <= G(Si);
    2) a output shape Tj is modified from an input shape Si: Tj <= M(Si);
    3) an input shape (Si) is removed: R(Si) == 1.

    The relations are kept only for shapes of types vertex, edge, face, and
    solid.

    The last relation means that:
    1) shape Si is not an output shape and
    2) no any shape is generated or modified (produced) from shape Si:
    R(Si) == 1 ==> Si != Tj, G(Si) == 0, M(Si) == 0.

    No any shape could be generated and modified from the same shape
    simultaneously: sets G(Si) and M(Si) are not intersected
    (G(Si) ^ M(Si) == 0).

    Each output shape should be:
    1) an input shape or
    2) generated or modified from an input shape (even generated from the
    implicit null shape if necessary):
    Tj == Si V (exists Si that Tj <= G(Si) U M(Si)).

    Recommendations to choose between relations 'generated' and 'modified':
    1) a shape is generated from input shapes if it dimension is greater or
    smaller than the dimensions of the input shapes;
    2) a shape is generated from input shapes if these shapes are also output
    shapes;
    3) a shape is generated from input shapes of the same dimension if it is
    produced by joining shapes generated from these shapes;
    4) a shape is modified from an input shape if it replaces the input shape by
    changes of the location, the tolerance, the bounds of the parametrical
    space (the faces for a solid), the parametrization and/or by applying of
    an approximation;
    5) a shape is modified from input shapes of the same dimension if it is
    produced by joining shapes modified from these shapes.

    Two sequential histories:
    - one history (H12) of shapes S1, ..., Sm to shapes T1, ..., Tn and
    - another history (H23) of shapes T1, ..., Tn to shapes Q1, ..., Ql
    could be merged to the single history (H13) of shapes S1, ..., Sm to shapes
    Q1, ..., Ql.

    During the merge:
    1) if shape Tj is generated from shape Si then each shape generated or
    modified from shape Tj is considered as a shape generated from shape Si
    among shapes Q1, ..., Ql:
    Tj <= G12(Si), Qk <= G23(Tj) U M23(Tj) ==> Qk <= G13(Si).
    2) if shape Tj is modified from shape Si, shape Qk is generated from shape
    Tj then shape Qk is considered as a shape generated from shape Si among
    shapes Q1, ..., Ql:
    Tj <= M12(Si), Qk <= G23(Tj) ==> Qk <= G13(Si);
    3) if shape Tj is modified from shape Si, shape Qk is modified from shape
    Tj then shape Qk is considered as a shape modified from shape Si among
    shapes Q1, ..., Ql:
    Tj <= M12(Si), Qk <= M23(Tj) ==> Qk <= M13(Si);
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_BRepTools_History
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_BRepTools_History(self) 
            return h

    TRelationType_Removed = _BRepTools.BRepTools_History_TRelationType_Removed
    TRelationType_Generated = _BRepTools.BRepTools_History_TRelationType_Generated
    TRelationType_Modified = _BRepTools.BRepTools_History_TRelationType_Modified

    def __init__(self, *args):
        """
        __init__(BRepTools_History self) -> BRepTools_History

        Empty constructor


        """
        this = _BRepTools.new_BRepTools_History(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def IsSupportedType(*args):
        """
        IsSupportedType(TopoDS_Shape theShape) -> Standard_Boolean

        Returns 'true' if the type of the shape is supported by the history.

        :type theShape: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepTools.BRepTools_History_IsSupportedType(*args)

    IsSupportedType = staticmethod(IsSupportedType)

    def AddGenerated(self, *args):
        """
        AddGenerated(BRepTools_History self, TopoDS_Shape theInitial, TopoDS_Shape theGenerated)

        Set the second shape as generated one from the first shape.

        :type theInitial: OCC.wrapper.TopoDS.TopoDS_Shape
        :type theGenerated: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _BRepTools.BRepTools_History_AddGenerated(self, *args)


    def AddModified(self, *args):
        """
        AddModified(BRepTools_History self, TopoDS_Shape theInitial, TopoDS_Shape theModified)

        Set the second shape as modified one from the first shape.

        :type theInitial: OCC.wrapper.TopoDS.TopoDS_Shape
        :type theModified: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _BRepTools.BRepTools_History_AddModified(self, *args)


    def Remove(self, *args):
        """
        Remove(BRepTools_History self, TopoDS_Shape theRemoved)

        Set the shape as removed one.

        :type theRemoved: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _BRepTools.BRepTools_History_Remove(self, *args)


    def ReplaceGenerated(self, *args):
        """
        ReplaceGenerated(BRepTools_History self, TopoDS_Shape theInitial, TopoDS_Shape theGenerated)

        Set the second shape as the only generated one from the first one.

        :type theInitial: OCC.wrapper.TopoDS.TopoDS_Shape
        :type theGenerated: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _BRepTools.BRepTools_History_ReplaceGenerated(self, *args)


    def ReplaceModified(self, *args):
        """
        ReplaceModified(BRepTools_History self, TopoDS_Shape theInitial, TopoDS_Shape theModified)

        Set the second shape as the only modified one from the first one.

        :type theInitial: OCC.wrapper.TopoDS.TopoDS_Shape
        :type theModified: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _BRepTools.BRepTools_History_ReplaceModified(self, *args)


    def Clear(self, *args):
        """
        Clear(BRepTools_History self)

        Clears the history.


        """
        return _BRepTools.BRepTools_History_Clear(self, *args)


    def Generated(self, *args):
        """
        Returns all shapes generated from the shape.

        :type theInitial: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.TopTools.TopTools_ListOfShape

        """
        res = _BRepTools.BRepTools_History_Generated(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Modified(self, *args):
        """
        Returns all shapes modified from the shape.

        :type theInitial: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.TopTools.TopTools_ListOfShape

        """
        res = _BRepTools.BRepTools_History_Modified(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def IsRemoved(self, *args):
        """
        IsRemoved(BRepTools_History self, TopoDS_Shape theInitial) -> Standard_Boolean

        Returns 'true' if the shape is removed.

        :type theInitial: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepTools.BRepTools_History_IsRemoved(self, *args)


    def Merge(self, *args):
        """
        Merge(BRepTools_History self, Handle_BRepTools_History theHistory23)
        Merge(BRepTools_History self, BRepTools_History theHistory23)

        Merges the next history to this history.

        :type theHistory23: OCC.wrapper.BRepTools.BRepTools_History

        """
        return _BRepTools.BRepTools_History_Merge(self, *args)


    def Dump(self, *args):
        """
        Dump(BRepTools_History self, Standard_OStream & theS)

        Prints the brief description of the history into a stream

        :type theS: OCC.wrapper.Standard.Standard_OStream

        """
        return _BRepTools.BRepTools_History_Dump(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _BRepTools.BRepTools_History_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _BRepTools.BRepTools_History_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _BRepTools.BRepTools_History_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _BRepTools.delete_BRepTools_History
BRepTools_History_swigregister = _BRepTools.BRepTools_History_swigregister
BRepTools_History_swigregister(BRepTools_History)

def BRepTools_History_IsSupportedType(*args):
    """
    BRepTools_History_IsSupportedType(TopoDS_Shape theShape) -> Standard_Boolean

    Returns 'true' if the type of the shape is supported by the history.

    :type theShape: OCC.wrapper.TopoDS.TopoDS_Shape
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _BRepTools.BRepTools_History_IsSupportedType(*args)

def BRepTools_History_get_type_name(*args):
    """
    BRepTools_History_get_type_name() -> char const *

    :rtype: const char *

    """
    return _BRepTools.BRepTools_History_get_type_name(*args)

def BRepTools_History_get_type_descriptor(*args):
    """
    BRepTools_History_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _BRepTools.BRepTools_History_get_type_descriptor(*args)

class BRepTools_ReShape(Standard.Standard_Transient):
    """
    Rebuilds a Shape by making pre-defined substitutions on some
    of its components

    In a first phase, it records requests to replace or remove
    some individual shapes
    For each shape, the last given request is recorded
    Requests may be applied "Oriented" (i.e. only to an item with
    the SAME orientation) or not (the orientation of replacing
    shape is respectful of that of the original one)

    Then, these requests may be applied to any shape which may
    contain one or more of these individual shapes

    Supports the 'BRepTools_History' history by method 'History'.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_BRepTools_ReShape
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_BRepTools_ReShape(self) 
            return h


    def __init__(self, *args):
        """
        __init__(BRepTools_ReShape self) -> BRepTools_ReShape

        Returns an empty Reshape


        """
        this = _BRepTools.new_BRepTools_ReShape(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Clear(self, *args):
        """
        Clear(BRepTools_ReShape self)

        Clears all substitutions requests


        """
        return _BRepTools.BRepTools_ReShape_Clear(self, *args)


    def Remove(self, *args):
        """
        Remove(BRepTools_ReShape self, TopoDS_Shape shape)

        Sets a request to Remove a Shape whatever the orientation

        :type shape: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _BRepTools.BRepTools_ReShape_Remove(self, *args)


    def Replace(self, *args):
        """
        Replace(BRepTools_ReShape self, TopoDS_Shape shape, TopoDS_Shape newshape)

        Sets a request to Replace a Shape by a new one.

        :type shape: OCC.wrapper.TopoDS.TopoDS_Shape
        :type newshape: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _BRepTools.BRepTools_ReShape_Replace(self, *args)


    def IsRecorded(self, *args):
        """
        IsRecorded(BRepTools_ReShape self, TopoDS_Shape shape) -> Standard_Boolean

        Tells if a shape is recorded for Replace/Remove

        :type shape: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepTools.BRepTools_ReShape_IsRecorded(self, *args)


    def Value(self, *args):
        """
        Value(BRepTools_ReShape self, TopoDS_Shape shape) -> TopoDS_Shape

        Returns the new value for an individual shape
        If not recorded, returns the original shape itself
        If to be Removed, returns a Null Shape
        Else, returns the replacing item

        :type shape: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _BRepTools.BRepTools_ReShape_Value(self, *args)


    def Status(self, *args):
        """
        Status(BRepTools_ReShape self, TopoDS_Shape shape, TopoDS_Shape newsh, Standard_Boolean const last) -> Standard_Integer

        Returns a complete substitution status for a shape
        0  : not recorded,   <newsh> = original <shape>
        < 0: to be removed,  <newsh> is NULL
        > 0: to be replaced, <newsh> is a new item
        If <last> is False, returns status and new shape recorded in
        the map directly for the shape, if True and status > 0 then
        recursively searches for the last status and new shape.

        :type shape: OCC.wrapper.TopoDS.TopoDS_Shape
        :type newsh: OCC.wrapper.TopoDS.TopoDS_Shape
        :type last: bool
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepTools.BRepTools_ReShape_Status(self, *args)


    def Apply(self, *args):
        """
        Apply(BRepTools_ReShape self, TopoDS_Shape shape, TopAbs_ShapeEnum const until=TopAbs_SHAPE) -> TopoDS_Shape

        Applies the substitutions requests to a shape.

        <until> gives the level of type until which requests are taken
        into account. For subshapes of the type <until> no rebuild
        and futher exploring are done.

        NOTE: each subshape can be replaced by shape of the same type
        or by shape containing only shapes of that type (for
        example, TopoDS_Edge can be replaced by TopoDS_Edge,
        TopoDS_Wire or TopoDS_Compound containing TopoDS_Edges).
        If incompatible shape type is encountered, it is ignored
        and flag FAIL1 is set in Status.

        :type shape: OCC.wrapper.TopoDS.TopoDS_Shape
        :type until: OCC.wrapper.TopAbs.TopAbs_ShapeEnum
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _BRepTools.BRepTools_ReShape_Apply(self, *args)


    def ModeConsiderLocation(self, *args):
        """
        ModeConsiderLocation(BRepTools_ReShape self) -> Standard_Boolean &

        Returns (modifiable) the flag which defines whether Location of shape take into account
        during replacing shapes.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepTools.BRepTools_ReShape_ModeConsiderLocation(self, *args)


    def CopyVertex(self, *args):
        """
        CopyVertex(BRepTools_ReShape self, TopoDS_Vertex theV, Standard_Real const theTol=-1.0) -> TopoDS_Vertex
        CopyVertex(BRepTools_ReShape self, TopoDS_Vertex theV, gp_Pnt theNewPos, Standard_Real const aTol) -> TopoDS_Vertex

        :type theV: OCC.wrapper.TopoDS.TopoDS_Vertex
        :type theNewPos: OCC.wrapper.gp.gp_Pnt
        :type aTol: float
        :rtype: OCC.wrapper.TopoDS.TopoDS_Vertex

        """
        return _BRepTools.BRepTools_ReShape_CopyVertex(self, *args)


    def IsNewShape(self, *args):
        """
        IsNewShape(BRepTools_ReShape self, TopoDS_Shape theShape) -> Standard_Boolean

        :type theShape: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepTools.BRepTools_ReShape_IsNewShape(self, *args)


    def History(self, *args):
        """
        History(BRepTools_ReShape self) -> Handle_BRepTools_History

        Returns the history of the substituted shapes.

        :rtype: OCC.wrapper.BRepTools.Handle_BRepTools_History

        """
        return _BRepTools.BRepTools_ReShape_History(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _BRepTools.BRepTools_ReShape_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _BRepTools.BRepTools_ReShape_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _BRepTools.BRepTools_ReShape_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _BRepTools.delete_BRepTools_ReShape
BRepTools_ReShape_swigregister = _BRepTools.BRepTools_ReShape_swigregister
BRepTools_ReShape_swigregister(BRepTools_ReShape)

def BRepTools_ReShape_get_type_name(*args):
    """
    BRepTools_ReShape_get_type_name() -> char const *

    :rtype: const char *

    """
    return _BRepTools.BRepTools_ReShape_get_type_name(*args)

def BRepTools_ReShape_get_type_descriptor(*args):
    """
    BRepTools_ReShape_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _BRepTools.BRepTools_ReShape_get_type_descriptor(*args)

class BRepTools_(object):
    """
    The BRepTools package provides  utilities for BRep
    data structures.

    * WireExplorer : A tool to explore the topology of
    a wire in the order of the edges.

    * ShapeSet :  Tools used for  dumping, writing and
    reading.

    * UVBounds : Methods to compute the  limits of the
    boundary  of a  face,  a wire or   an edge in  the
    parametric space of a face.

    *  Update : Methods  to call when   a topology has
    been created to compute all missing data.

    * UpdateFaceUVPoints: Method to update the UV points
    stored with the edges on a face.

    * Compare : Method to compare two vertices.

    * Compare : Method to compare two edges.

    * OuterWire : A method to find the outer wire of a
    face.

    * Map3DEdges : A method to map all the 3D Edges of
    a Shape.

    * Dump : A method to dump a BRep object.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def UVBounds(*args):
        """
        UVBounds(TopoDS_Face F)
        UVBounds(TopoDS_Face F, TopoDS_Wire W)
        UVBounds(TopoDS_Face F, TopoDS_Edge E)

        Returns in UMin,  UMax, VMin,  VMax  the  bounding
        values of the edge in the parametric space of F.

        :type F: OCC.wrapper.TopoDS.TopoDS_Face
        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :type UMin: float
        :type UMax: float
        :type VMin: float
        :type VMax: float

        """
        return _BRepTools.BRepTools__UVBounds(*args)

    UVBounds = staticmethod(UVBounds)

    def AddUVBounds(*args):
        """
        AddUVBounds(TopoDS_Face F, Bnd_Box2d B)
        AddUVBounds(TopoDS_Face F, TopoDS_Wire W, Bnd_Box2d B)
        AddUVBounds(TopoDS_Face F, TopoDS_Edge E, Bnd_Box2d B)

        Adds to  the box <B>  the  bounding values  of the
        edge in the parametric space of F.

        :type F: OCC.wrapper.TopoDS.TopoDS_Face
        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :type B: OCC.wrapper.Bnd.Bnd_Box2d

        """
        return _BRepTools.BRepTools__AddUVBounds(*args)

    AddUVBounds = staticmethod(AddUVBounds)

    def Update(*args):
        """
        Update(TopoDS_Vertex V)
        Update(TopoDS_Edge E)
        Update(TopoDS_Wire W)
        Update(TopoDS_Face F)
        Update(TopoDS_Shell S)
        Update(TopoDS_Solid S)
        Update(TopoDS_CompSolid C)
        Update(TopoDS_Compound C)
        Update(TopoDS_Shape S)

        Update a shape, call the corect update.

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _BRepTools.BRepTools__Update(*args)

    Update = staticmethod(Update)

    def UpdateFaceUVPoints(*args):
        """
        UpdateFaceUVPoints(TopoDS_Face theF)

        For each edge of the face <F> reset the UV points
        to the bounding points of the parametric curve of the
        edge on the face.

        :type theF: OCC.wrapper.TopoDS.TopoDS_Face

        """
        return _BRepTools.BRepTools__UpdateFaceUVPoints(*args)

    UpdateFaceUVPoints = staticmethod(UpdateFaceUVPoints)

    def Clean(*args):
        """
        Clean(TopoDS_Shape S)

        Removes all the triangulations of the faces of <S>
        and removes all polygons on triangulations of the
        edges.

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _BRepTools.BRepTools__Clean(*args)

    Clean = staticmethod(Clean)

    def RemoveUnusedPCurves(*args):
        """
        RemoveUnusedPCurves(TopoDS_Shape S)

        Removes all the pcurves of the edges of <S> that
        refer to surfaces not belonging to any face of <S>

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _BRepTools.BRepTools__RemoveUnusedPCurves(*args)

    RemoveUnusedPCurves = staticmethod(RemoveUnusedPCurves)

    def Triangulation(*args):
        """
        Triangulation(TopoDS_Shape S, Standard_Real const deflec) -> Standard_Boolean

        verifies that each face from the shape <S> has got
        a triangulation  with a  deflection <= deflec  and
        the edges a discretisation on  this triangulation.

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :type deflec: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepTools.BRepTools__Triangulation(*args)

    Triangulation = staticmethod(Triangulation)

    def Compare(*args):
        """
        Compare(TopoDS_Vertex V1, TopoDS_Vertex V2) -> Standard_Boolean
        Compare(TopoDS_Edge E1, TopoDS_Edge E2) -> Standard_Boolean

        Returns  True if  the    distance between the  two
        edges is lower than their tolerance.

        :type E1: OCC.wrapper.TopoDS.TopoDS_Edge
        :type E2: OCC.wrapper.TopoDS.TopoDS_Edge
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepTools.BRepTools__Compare(*args)

    Compare = staticmethod(Compare)

    def OuterWire(*args):
        """
        OuterWire(TopoDS_Face F) -> TopoDS_Wire

        Returns the outer most wire of <F>. Returns a Null
        wire if <F> has no wires.

        :type F: OCC.wrapper.TopoDS.TopoDS_Face
        :rtype: OCC.wrapper.TopoDS.TopoDS_Wire

        """
        return _BRepTools.BRepTools__OuterWire(*args)

    OuterWire = staticmethod(OuterWire)

    def Map3DEdges(*args):
        """
        Map3DEdges(TopoDS_Shape S, NCollection_IndexedMap_TopoDS_Shape_TopTools_ShapeMapHasher M)

        Stores in the map  <M> all the 3D topology edges
        of <S>.

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :type M: OCC.wrapper.TopTools.TopTools_IndexedMapOfShape

        """
        return _BRepTools.BRepTools__Map3DEdges(*args)

    Map3DEdges = staticmethod(Map3DEdges)

    def IsReallyClosed(*args):
        """
        IsReallyClosed(TopoDS_Edge E, TopoDS_Face F) -> Standard_Boolean

        Verifies that the edge  <E> is found two  times on
        the face <F> before calling BRep_Tool::IsClosed.

        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :type F: OCC.wrapper.TopoDS.TopoDS_Face
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepTools.BRepTools__IsReallyClosed(*args)

    IsReallyClosed = staticmethod(IsReallyClosed)

    def DetectClosedness(*args):
        """
        DetectClosedness(TopoDS_Face theFace)

        Detect closedness of face in U and V directions

        :type theFace: OCC.wrapper.TopoDS.TopoDS_Face
        :type theUclosed: bool
        :type theVclosed: bool

        """
        return _BRepTools.BRepTools__DetectClosedness(*args)

    DetectClosedness = staticmethod(DetectClosedness)

    def Dump(*args):
        """
        Dump(TopoDS_Shape Sh, Standard_OStream & S)

        Dumps the topological structure and the geometry
        of <Sh> on the stream <S>.

        :type Sh: OCC.wrapper.TopoDS.TopoDS_Shape
        :type S: OCC.wrapper.Standard.Standard_OStream

        """
        return _BRepTools.BRepTools__Dump(*args)

    Dump = staticmethod(Dump)

    def Write(*args):
        """
        Write(TopoDS_Shape Sh, Standard_OStream & S, Handle_Message_ProgressIndicator PR=0)
        Write(TopoDS_Shape Sh, Standard_CString const File, Handle_Message_ProgressIndicator PR=0) -> Standard_Boolean

        Writes <Sh> in <File>.

        :type Sh: OCC.wrapper.TopoDS.TopoDS_Shape
        :type File: OCC.wrapper.Standard.Standard_CString
        :type PR: OCC.wrapper.Message.Handle_Message_ProgressIndicator
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepTools.BRepTools__Write(*args)

    Write = staticmethod(Write)

    def Read(*args):
        """
        Read(TopoDS_Shape Sh, Standard_IStream & S, BRep_Builder B, Handle_Message_ProgressIndicator PR=0)
        Read(TopoDS_Shape Sh, Standard_CString const File, BRep_Builder B, Handle_Message_ProgressIndicator PR=0) -> Standard_Boolean

        Reads a Shape  from <File>,  returns it in  <Sh>.
        <B> is used to build the shape.

        :type Sh: OCC.wrapper.TopoDS.TopoDS_Shape
        :type File: OCC.wrapper.Standard.Standard_CString
        :type B: OCC.wrapper.BRep.BRep_Builder
        :type PR: OCC.wrapper.Message.Handle_Message_ProgressIndicator
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepTools.BRepTools__Read(*args)

    Read = staticmethod(Read)

    def EvalAndUpdateTol(*args):
        """
        EvalAndUpdateTol(TopoDS_Edge theE, Handle_Geom_Curve theC3d, Handle_Geom2d_Curve theC2d, Handle_Geom_Surface theS, Standard_Real const theF, Standard_Real const theL) -> Standard_Real

        Evals real tolerance of edge  <theE>.
        <theC3d>, <theC2d>, <theS>, <theF>, <theL> are
        correspondently 3d curve of edge, 2d curve on surface <theS> and
        rang of edge
        If calculated tolerance is more then current edge tolerance, edge is updated.
        Method returns actual tolerance of edge

        :type theE: OCC.wrapper.TopoDS.TopoDS_Edge
        :type theC3d: OCC.wrapper.Geom.Handle_Geom_Curve
        :type theC2d: OCC.wrapper.Geom2d.Handle_Geom2d_Curve
        :type theS: OCC.wrapper.Geom.Handle_Geom_Surface
        :type theF: float
        :type theL: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _BRepTools.BRepTools__EvalAndUpdateTol(*args)

    EvalAndUpdateTol = staticmethod(EvalAndUpdateTol)

    def __init__(self):
        """
        The BRepTools package provides  utilities for BRep
        data structures.

        * WireExplorer : A tool to explore the topology of
        a wire in the order of the edges.

        * ShapeSet :  Tools used for  dumping, writing and
        reading.

        * UVBounds : Methods to compute the  limits of the
        boundary  of a  face,  a wire or   an edge in  the
        parametric space of a face.

        *  Update : Methods  to call when   a topology has
        been created to compute all missing data.

        * UpdateFaceUVPoints: Method to update the UV points
        stored with the edges on a face.

        * Compare : Method to compare two vertices.

        * Compare : Method to compare two edges.

        * OuterWire : A method to find the outer wire of a
        face.

        * Map3DEdges : A method to map all the 3D Edges of
        a Shape.

        * Dump : A method to dump a BRep object.
        """
        this = _BRepTools.new_BRepTools_()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _BRepTools.delete_BRepTools_
BRepTools__swigregister = _BRepTools.BRepTools__swigregister
BRepTools__swigregister(BRepTools_)

def BRepTools__UVBounds(*args):
    """
    UVBounds(TopoDS_Face F)
    UVBounds(TopoDS_Face F, TopoDS_Wire W)
    BRepTools__UVBounds(TopoDS_Face F, TopoDS_Edge E)

    Returns in UMin,  UMax, VMin,  VMax  the  bounding
    values of the edge in the parametric space of F.

    :type F: OCC.wrapper.TopoDS.TopoDS_Face
    :type E: OCC.wrapper.TopoDS.TopoDS_Edge
    :type UMin: float
    :type UMax: float
    :type VMin: float
    :type VMax: float

    """
    return _BRepTools.BRepTools__UVBounds(*args)

def BRepTools__AddUVBounds(*args):
    """
    AddUVBounds(TopoDS_Face F, Bnd_Box2d B)
    AddUVBounds(TopoDS_Face F, TopoDS_Wire W, Bnd_Box2d B)
    BRepTools__AddUVBounds(TopoDS_Face F, TopoDS_Edge E, Bnd_Box2d B)

    Adds to  the box <B>  the  bounding values  of the
    edge in the parametric space of F.

    :type F: OCC.wrapper.TopoDS.TopoDS_Face
    :type E: OCC.wrapper.TopoDS.TopoDS_Edge
    :type B: OCC.wrapper.Bnd.Bnd_Box2d

    """
    return _BRepTools.BRepTools__AddUVBounds(*args)

def BRepTools__Update(*args):
    """
    Update(TopoDS_Vertex V)
    Update(TopoDS_Edge E)
    Update(TopoDS_Wire W)
    Update(TopoDS_Face F)
    Update(TopoDS_Shell S)
    Update(TopoDS_Solid S)
    Update(TopoDS_CompSolid C)
    Update(TopoDS_Compound C)
    BRepTools__Update(TopoDS_Shape S)

    Update a shape, call the corect update.

    :type S: OCC.wrapper.TopoDS.TopoDS_Shape

    """
    return _BRepTools.BRepTools__Update(*args)

def BRepTools__UpdateFaceUVPoints(*args):
    """
    BRepTools__UpdateFaceUVPoints(TopoDS_Face theF)

    For each edge of the face <F> reset the UV points
    to the bounding points of the parametric curve of the
    edge on the face.

    :type theF: OCC.wrapper.TopoDS.TopoDS_Face

    """
    return _BRepTools.BRepTools__UpdateFaceUVPoints(*args)

def BRepTools__Clean(*args):
    """
    BRepTools__Clean(TopoDS_Shape S)

    Removes all the triangulations of the faces of <S>
    and removes all polygons on triangulations of the
    edges.

    :type S: OCC.wrapper.TopoDS.TopoDS_Shape

    """
    return _BRepTools.BRepTools__Clean(*args)

def BRepTools__RemoveUnusedPCurves(*args):
    """
    BRepTools__RemoveUnusedPCurves(TopoDS_Shape S)

    Removes all the pcurves of the edges of <S> that
    refer to surfaces not belonging to any face of <S>

    :type S: OCC.wrapper.TopoDS.TopoDS_Shape

    """
    return _BRepTools.BRepTools__RemoveUnusedPCurves(*args)

def BRepTools__Triangulation(*args):
    """
    BRepTools__Triangulation(TopoDS_Shape S, Standard_Real const deflec) -> Standard_Boolean

    verifies that each face from the shape <S> has got
    a triangulation  with a  deflection <= deflec  and
    the edges a discretisation on  this triangulation.

    :type S: OCC.wrapper.TopoDS.TopoDS_Shape
    :type deflec: float
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _BRepTools.BRepTools__Triangulation(*args)

def BRepTools__Compare(*args):
    """
    Compare(TopoDS_Vertex V1, TopoDS_Vertex V2) -> Standard_Boolean
    BRepTools__Compare(TopoDS_Edge E1, TopoDS_Edge E2) -> Standard_Boolean

    Returns  True if  the    distance between the  two
    edges is lower than their tolerance.

    :type E1: OCC.wrapper.TopoDS.TopoDS_Edge
    :type E2: OCC.wrapper.TopoDS.TopoDS_Edge
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _BRepTools.BRepTools__Compare(*args)

def BRepTools__OuterWire(*args):
    """
    BRepTools__OuterWire(TopoDS_Face F) -> TopoDS_Wire

    Returns the outer most wire of <F>. Returns a Null
    wire if <F> has no wires.

    :type F: OCC.wrapper.TopoDS.TopoDS_Face
    :rtype: OCC.wrapper.TopoDS.TopoDS_Wire

    """
    return _BRepTools.BRepTools__OuterWire(*args)

def BRepTools__Map3DEdges(*args):
    """
    BRepTools__Map3DEdges(TopoDS_Shape S, NCollection_IndexedMap_TopoDS_Shape_TopTools_ShapeMapHasher M)

    Stores in the map  <M> all the 3D topology edges
    of <S>.

    :type S: OCC.wrapper.TopoDS.TopoDS_Shape
    :type M: OCC.wrapper.TopTools.TopTools_IndexedMapOfShape

    """
    return _BRepTools.BRepTools__Map3DEdges(*args)

def BRepTools__IsReallyClosed(*args):
    """
    BRepTools__IsReallyClosed(TopoDS_Edge E, TopoDS_Face F) -> Standard_Boolean

    Verifies that the edge  <E> is found two  times on
    the face <F> before calling BRep_Tool::IsClosed.

    :type E: OCC.wrapper.TopoDS.TopoDS_Edge
    :type F: OCC.wrapper.TopoDS.TopoDS_Face
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _BRepTools.BRepTools__IsReallyClosed(*args)

def BRepTools__DetectClosedness(*args):
    """
    BRepTools__DetectClosedness(TopoDS_Face theFace)

    Detect closedness of face in U and V directions

    :type theFace: OCC.wrapper.TopoDS.TopoDS_Face
    :type theUclosed: bool
    :type theVclosed: bool

    """
    return _BRepTools.BRepTools__DetectClosedness(*args)

def BRepTools__Dump(*args):
    """
    BRepTools__Dump(TopoDS_Shape Sh, Standard_OStream & S)

    Dumps the topological structure and the geometry
    of <Sh> on the stream <S>.

    :type Sh: OCC.wrapper.TopoDS.TopoDS_Shape
    :type S: OCC.wrapper.Standard.Standard_OStream

    """
    return _BRepTools.BRepTools__Dump(*args)

def BRepTools__Write(*args):
    """
    Write(TopoDS_Shape Sh, Standard_OStream & S, Handle_Message_ProgressIndicator PR=0)
    BRepTools__Write(TopoDS_Shape Sh, Standard_CString const File, Handle_Message_ProgressIndicator PR=0) -> Standard_Boolean

    Writes <Sh> in <File>.

    :type Sh: OCC.wrapper.TopoDS.TopoDS_Shape
    :type File: OCC.wrapper.Standard.Standard_CString
    :type PR: OCC.wrapper.Message.Handle_Message_ProgressIndicator
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _BRepTools.BRepTools__Write(*args)

def BRepTools__Read(*args):
    """
    Read(TopoDS_Shape Sh, Standard_IStream & S, BRep_Builder B, Handle_Message_ProgressIndicator PR=0)
    BRepTools__Read(TopoDS_Shape Sh, Standard_CString const File, BRep_Builder B, Handle_Message_ProgressIndicator PR=0) -> Standard_Boolean

    Reads a Shape  from <File>,  returns it in  <Sh>.
    <B> is used to build the shape.

    :type Sh: OCC.wrapper.TopoDS.TopoDS_Shape
    :type File: OCC.wrapper.Standard.Standard_CString
    :type B: OCC.wrapper.BRep.BRep_Builder
    :type PR: OCC.wrapper.Message.Handle_Message_ProgressIndicator
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _BRepTools.BRepTools__Read(*args)

def BRepTools__EvalAndUpdateTol(*args):
    """
    BRepTools__EvalAndUpdateTol(TopoDS_Edge theE, Handle_Geom_Curve theC3d, Handle_Geom2d_Curve theC2d, Handle_Geom_Surface theS, Standard_Real const theF, Standard_Real const theL) -> Standard_Real

    Evals real tolerance of edge  <theE>.
    <theC3d>, <theC2d>, <theS>, <theF>, <theL> are
    correspondently 3d curve of edge, 2d curve on surface <theS> and
    rang of edge
    If calculated tolerance is more then current edge tolerance, edge is updated.
    Method returns actual tolerance of edge

    :type theE: OCC.wrapper.TopoDS.TopoDS_Edge
    :type theC3d: OCC.wrapper.Geom.Handle_Geom_Curve
    :type theC2d: OCC.wrapper.Geom2d.Handle_Geom2d_Curve
    :type theS: OCC.wrapper.Geom.Handle_Geom_Surface
    :type theF: float
    :type theL: float
    :rtype: OCC.wrapper.Standard.Standard_Real

    """
    return _BRepTools.BRepTools__EvalAndUpdateTol(*args)

class Handle_BRepTools_NurbsConvertModification(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_BRepTools_NurbsConvertModification self)

        Nullify the handle


        """
        return _BRepTools.Handle_BRepTools_NurbsConvertModification_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_BRepTools_NurbsConvertModification self) -> bool

        Check for being null

        :rtype: bool

        """
        return _BRepTools.Handle_BRepTools_NurbsConvertModification_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_BRepTools_NurbsConvertModification self, BRepTools_NurbsConvertModification thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _BRepTools.Handle_BRepTools_NurbsConvertModification_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_BRepTools_NurbsConvertModification self, Handle_BRepTools_NurbsConvertModification theHandle) -> Handle_BRepTools_NurbsConvertModification
        assign(Handle_BRepTools_NurbsConvertModification self, BRepTools_NurbsConvertModification thePtr) -> Handle_BRepTools_NurbsConvertModification
        assign(Handle_BRepTools_NurbsConvertModification self, Handle_BRepTools_NurbsConvertModification theHandle) -> Handle_BRepTools_NurbsConvertModification

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _BRepTools.Handle_BRepTools_NurbsConvertModification_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_BRepTools_NurbsConvertModification self) -> BRepTools_NurbsConvertModification

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _BRepTools.Handle_BRepTools_NurbsConvertModification_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_BRepTools_NurbsConvertModification self) -> BRepTools_NurbsConvertModification

        Member access operator (note non-const)

        :rtype: T *

        """
        return _BRepTools.Handle_BRepTools_NurbsConvertModification___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_BRepTools_NurbsConvertModification self) -> BRepTools_NurbsConvertModification

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _BRepTools.Handle_BRepTools_NurbsConvertModification___ref__(self, *args)


    def __hash__(self):
        return _BRepTools.Handle_BRepTools_NurbsConvertModification___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _BRepTools.Handle_BRepTools_NurbsConvertModification___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _BRepTools.new_Handle_BRepTools_NurbsConvertModification(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_BRepTools.Handle_BRepTools_NurbsConvertModification_DownCast)
    __swig_destroy__ = _BRepTools.delete_Handle_BRepTools_NurbsConvertModification

    def NewSurface(self, *args):
        """
        NewSurface(Handle_BRepTools_NurbsConvertModification self, TopoDS_Face F, Handle_Geom_Surface S, TopLoc_Location L) -> Standard_Boolean

        Returns Standard_True  if  the face  <F> has  been
        modified.  In this  case, <S> is the new geometric
        support of  the  face, <L> the  new location,<Tol>
        the new  tolerance.<RevWires> has  to  be set   to
        Standard_True   when the modification reverses the
        normal of  the   surface.(the wires   have  to  be
        reversed).   <RevFace>   has   to   be   set    to
        Standard_True if  the orientation  of the modified
        face changes in the  shells which contain  it.  --
        Here, <RevFace>  will  return Standard_True if the
        -- gp_Trsf is negative.

        :type F: OCC.wrapper.TopoDS.TopoDS_Face
        :type S: OCC.wrapper.Geom.Handle_Geom_Surface
        :type L: OCC.wrapper.TopLoc.TopLoc_Location
        :type Tol: float
        :type RevWires: bool
        :type RevFace: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepTools.Handle_BRepTools_NurbsConvertModification_NewSurface(self, *args)


    def NewCurve(self, *args):
        """
        NewCurve(Handle_BRepTools_NurbsConvertModification self, TopoDS_Edge E, Handle_Geom_Curve C, TopLoc_Location L) -> Standard_Boolean

        Returns Standard_True  if  the edge  <E> has  been
        modified.  In this case,  <C> is the new geometric
        support of the  edge, <L> the  new location, <Tol>
        the         new    tolerance.   Otherwise, returns
        Standard_False,    and  <C>,  <L>,   <Tol> are not
        significant.

        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :type C: OCC.wrapper.Geom.Handle_Geom_Curve
        :type L: OCC.wrapper.TopLoc.TopLoc_Location
        :type Tol: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepTools.Handle_BRepTools_NurbsConvertModification_NewCurve(self, *args)


    def NewPoint(self, *args):
        """
        NewPoint(Handle_BRepTools_NurbsConvertModification self, TopoDS_Vertex V, gp_Pnt P) -> Standard_Boolean

        Returns  Standard_True if the  vertex <V> has been
        modified.  In this  case, <P> is the new geometric
        support of the vertex,   <Tol> the new  tolerance.
        Otherwise, returns Standard_False, and <P>,  <Tol>
        are not significant.

        :type V: OCC.wrapper.TopoDS.TopoDS_Vertex
        :type P: OCC.wrapper.gp.gp_Pnt
        :type Tol: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepTools.Handle_BRepTools_NurbsConvertModification_NewPoint(self, *args)


    def NewCurve2d(self, *args):
        """
        NewCurve2d(Handle_BRepTools_NurbsConvertModification self, TopoDS_Edge E, TopoDS_Face F, TopoDS_Edge NewE, TopoDS_Face NewF, Handle_Geom2d_Curve C) -> Standard_Boolean

        Returns Standard_True if  the edge  <E> has a  new
        curve on surface on the face <F>.In this case, <C>
        is the new geometric support of  the edge, <L> the
        new location, <Tol> the new tolerance.
        Otherwise, returns  Standard_False, and <C>,  <L>,
        <Tol> are not significant.

        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :type F: OCC.wrapper.TopoDS.TopoDS_Face
        :type NewE: OCC.wrapper.TopoDS.TopoDS_Edge
        :type NewF: OCC.wrapper.TopoDS.TopoDS_Face
        :type C: OCC.wrapper.Geom2d.Handle_Geom2d_Curve
        :type Tol: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepTools.Handle_BRepTools_NurbsConvertModification_NewCurve2d(self, *args)


    def NewParameter(self, *args):
        """
        NewParameter(Handle_BRepTools_NurbsConvertModification self, TopoDS_Vertex V, TopoDS_Edge E) -> Standard_Boolean

        Returns Standard_True if the Vertex  <V> has a new
        parameter on the  edge <E>. In  this case,  <P> is
        the parameter,    <Tol>  the     new    tolerance.
        Otherwise, returns Standard_False, and <P>,  <Tol>
        are not significant.

        :type V: OCC.wrapper.TopoDS.TopoDS_Vertex
        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :type P: float
        :type Tol: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepTools.Handle_BRepTools_NurbsConvertModification_NewParameter(self, *args)


    def Continuity(self, *args):
        """
        Continuity(Handle_BRepTools_NurbsConvertModification self, TopoDS_Edge E, TopoDS_Face F1, TopoDS_Face F2, TopoDS_Edge NewE, TopoDS_Face NewF1, TopoDS_Face NewF2) -> GeomAbs_Shape

        Returns the  continuity of  <NewE> between <NewF1>
        and <NewF2>.

        <NewE> is the new  edge created from <E>.  <NewF1>
        (resp. <NewF2>) is the new  face created from <F1>
        (resp. <F2>).

        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :type F1: OCC.wrapper.TopoDS.TopoDS_Face
        :type F2: OCC.wrapper.TopoDS.TopoDS_Face
        :type NewE: OCC.wrapper.TopoDS.TopoDS_Edge
        :type NewF1: OCC.wrapper.TopoDS.TopoDS_Face
        :type NewF2: OCC.wrapper.TopoDS.TopoDS_Face
        :rtype: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _BRepTools.Handle_BRepTools_NurbsConvertModification_Continuity(self, *args)


    def GetUpdatedEdges(self, *args):
        """
        :rtype: OCC.wrapper.TopTools.TopTools_ListOfShape

        """
        res = _BRepTools.Handle_BRepTools_NurbsConvertModification_GetUpdatedEdges(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def get_type_name(self, *args):
        """
        get_type_name(Handle_BRepTools_NurbsConvertModification self) -> char const *

        :rtype: const char *

        """
        return _BRepTools.Handle_BRepTools_NurbsConvertModification_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _BRepTools.Handle_BRepTools_NurbsConvertModification_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _BRepTools.Handle_BRepTools_NurbsConvertModification_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def NewTriangulation(self, *args):
        """
        NewTriangulation(Handle_BRepTools_NurbsConvertModification self, TopoDS_Face F, Handle_Poly_Triangulation T) -> Standard_Boolean

        Returns true if the face has been modified according to changed triangulation.
        If the face has been modified:
        - T is a new triangulation on the face

        :type F: OCC.wrapper.TopoDS.TopoDS_Face
        :type T: OCC.wrapper.Poly.Handle_Poly_Triangulation
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepTools.Handle_BRepTools_NurbsConvertModification_NewTriangulation(self, *args)


    def NewPolygon(self, *args):
        """
        NewPolygon(Handle_BRepTools_NurbsConvertModification self, TopoDS_Edge E, Handle_Poly_Polygon3D P) -> Standard_Boolean

        Returns true if the edge has been modified according to changed polygon.
        If the edge has been modified:
        - P is a new polygon

        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :type P: OCC.wrapper.Poly.Handle_Poly_Polygon3D
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepTools.Handle_BRepTools_NurbsConvertModification_NewPolygon(self, *args)


    def NewPolygonOnTriangulation(self, *args):
        """
        NewPolygonOnTriangulation(Handle_BRepTools_NurbsConvertModification self, TopoDS_Edge E, TopoDS_Face F, Handle_Poly_PolygonOnTriangulation P) -> Standard_Boolean

        Returns true if the edge has been modified according to changed polygon on triangulation.
        If the edge has been modified:
        - P is a new polygon on triangulation

        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :type F: OCC.wrapper.TopoDS.TopoDS_Face
        :type P: OCC.wrapper.Poly.Handle_Poly_PolygonOnTriangulation
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepTools.Handle_BRepTools_NurbsConvertModification_NewPolygonOnTriangulation(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_BRepTools_NurbsConvertModification self)

        Memory deallocator for transient classes


        """
        return _BRepTools.Handle_BRepTools_NurbsConvertModification_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_BRepTools_NurbsConvertModification self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_BRepTools_NurbsConvertModification self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepTools.Handle_BRepTools_NurbsConvertModification_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_BRepTools_NurbsConvertModification self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_BRepTools_NurbsConvertModification self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepTools.Handle_BRepTools_NurbsConvertModification_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_BRepTools_NurbsConvertModification self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _BRepTools.Handle_BRepTools_NurbsConvertModification_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_BRepTools_NurbsConvertModification self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepTools.Handle_BRepTools_NurbsConvertModification_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_BRepTools_NurbsConvertModification self)

        Increments the reference counter of this object


        """
        return _BRepTools.Handle_BRepTools_NurbsConvertModification_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_BRepTools_NurbsConvertModification self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepTools.Handle_BRepTools_NurbsConvertModification_DecrementRefCounter(self, *args)

Handle_BRepTools_NurbsConvertModification_swigregister = _BRepTools.Handle_BRepTools_NurbsConvertModification_swigregister
Handle_BRepTools_NurbsConvertModification_swigregister(Handle_BRepTools_NurbsConvertModification)

def Handle_BRepTools_NurbsConvertModification_DownCast(thing):
    return _BRepTools.Handle_BRepTools_NurbsConvertModification_DownCast(thing)
Handle_BRepTools_NurbsConvertModification_DownCast = _BRepTools.Handle_BRepTools_NurbsConvertModification_DownCast

class Handle_BRepTools_TrsfModification(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_BRepTools_TrsfModification self)

        Nullify the handle


        """
        return _BRepTools.Handle_BRepTools_TrsfModification_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_BRepTools_TrsfModification self) -> bool

        Check for being null

        :rtype: bool

        """
        return _BRepTools.Handle_BRepTools_TrsfModification_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_BRepTools_TrsfModification self, BRepTools_TrsfModification thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _BRepTools.Handle_BRepTools_TrsfModification_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_BRepTools_TrsfModification self, Handle_BRepTools_TrsfModification theHandle) -> Handle_BRepTools_TrsfModification
        assign(Handle_BRepTools_TrsfModification self, BRepTools_TrsfModification thePtr) -> Handle_BRepTools_TrsfModification
        assign(Handle_BRepTools_TrsfModification self, Handle_BRepTools_TrsfModification theHandle) -> Handle_BRepTools_TrsfModification

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _BRepTools.Handle_BRepTools_TrsfModification_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_BRepTools_TrsfModification self) -> BRepTools_TrsfModification

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _BRepTools.Handle_BRepTools_TrsfModification_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_BRepTools_TrsfModification self) -> BRepTools_TrsfModification

        Member access operator (note non-const)

        :rtype: T *

        """
        return _BRepTools.Handle_BRepTools_TrsfModification___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_BRepTools_TrsfModification self) -> BRepTools_TrsfModification

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _BRepTools.Handle_BRepTools_TrsfModification___ref__(self, *args)


    def __hash__(self):
        return _BRepTools.Handle_BRepTools_TrsfModification___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _BRepTools.Handle_BRepTools_TrsfModification___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _BRepTools.new_Handle_BRepTools_TrsfModification(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_BRepTools.Handle_BRepTools_TrsfModification_DownCast)
    __swig_destroy__ = _BRepTools.delete_Handle_BRepTools_TrsfModification

    def Trsf(self, *args):
        """
        Trsf(Handle_BRepTools_TrsfModification self) -> gp_Trsf

        Provides access to the gp_Trsf associated with this
        modification. The transformation can be changed.

        :rtype: OCC.wrapper.gp.gp_Trsf

        """
        return _BRepTools.Handle_BRepTools_TrsfModification_Trsf(self, *args)


    def NewSurface(self, *args):
        """
        NewSurface(Handle_BRepTools_TrsfModification self, TopoDS_Face F, Handle_Geom_Surface S, TopLoc_Location L) -> Standard_Boolean

        Returns true if the face F has been modified.
        If the face has been modified:
        - S is the new geometry of the face,
        - L is its new location, and
        - Tol is the new tolerance.
        RevWires is set to true when the modification
        reverses the normal of the surface (the wires have to be reversed).
        RevFace is set to true if the orientation of the
        modified face changes in the shells which contain it.
        For this class, RevFace returns true if the gp_Trsf
        associated with this modification is negative.

        :type F: OCC.wrapper.TopoDS.TopoDS_Face
        :type S: OCC.wrapper.Geom.Handle_Geom_Surface
        :type L: OCC.wrapper.TopLoc.TopLoc_Location
        :type Tol: float
        :type RevWires: bool
        :type RevFace: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepTools.Handle_BRepTools_TrsfModification_NewSurface(self, *args)


    def NewCurve(self, *args):
        """
        NewCurve(Handle_BRepTools_TrsfModification self, TopoDS_Edge E, Handle_Geom_Curve C, TopLoc_Location L) -> Standard_Boolean

        Returns true if the edge E has been modified.
        If the edge has been modified:
        - C is the new geometric support of the edge,
        - L is the new location, and
        - Tol is the new tolerance.
        If the edge has not been modified, this function
        returns false, and the values of C, L and Tol are not significant.

        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :type C: OCC.wrapper.Geom.Handle_Geom_Curve
        :type L: OCC.wrapper.TopLoc.TopLoc_Location
        :type Tol: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepTools.Handle_BRepTools_TrsfModification_NewCurve(self, *args)


    def NewPoint(self, *args):
        """
        NewPoint(Handle_BRepTools_TrsfModification self, TopoDS_Vertex V, gp_Pnt P) -> Standard_Boolean

        Returns true if the vertex V has been modified.
        If the vertex has been modified:
        - P is the new geometry of the vertex, and
        - Tol is the new tolerance.
        If the vertex has not been modified this function
        returns false, and the values of P and Tol are not significant.

        :type V: OCC.wrapper.TopoDS.TopoDS_Vertex
        :type P: OCC.wrapper.gp.gp_Pnt
        :type Tol: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepTools.Handle_BRepTools_TrsfModification_NewPoint(self, *args)


    def NewCurve2d(self, *args):
        """
        NewCurve2d(Handle_BRepTools_TrsfModification self, TopoDS_Edge E, TopoDS_Face F, TopoDS_Edge NewE, TopoDS_Face NewF, Handle_Geom2d_Curve C) -> Standard_Boolean

        Returns true if the edge E has a new curve on surface on the face F.
        If a new curve exists:
        - C is the new geometric support of the edge,
        - L is the new location, and
        - Tol the new tolerance.
        If no new curve exists, this function returns false, and
        the values of C, L and Tol are not significant.

        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :type F: OCC.wrapper.TopoDS.TopoDS_Face
        :type NewE: OCC.wrapper.TopoDS.TopoDS_Edge
        :type NewF: OCC.wrapper.TopoDS.TopoDS_Face
        :type C: OCC.wrapper.Geom2d.Handle_Geom2d_Curve
        :type Tol: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepTools.Handle_BRepTools_TrsfModification_NewCurve2d(self, *args)


    def NewParameter(self, *args):
        """
        NewParameter(Handle_BRepTools_TrsfModification self, TopoDS_Vertex V, TopoDS_Edge E) -> Standard_Boolean

        Returns true if the Vertex V has a new parameter on the edge E.
        If a new parameter exists:
        - P is the parameter, and
        - Tol is the new tolerance.
        If no new parameter exists, this function returns false,
        and the values of P and Tol are not significant.

        :type V: OCC.wrapper.TopoDS.TopoDS_Vertex
        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :type P: float
        :type Tol: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepTools.Handle_BRepTools_TrsfModification_NewParameter(self, *args)


    def Continuity(self, *args):
        """
        Continuity(Handle_BRepTools_TrsfModification self, TopoDS_Edge E, TopoDS_Face F1, TopoDS_Face F2, TopoDS_Edge NewE, TopoDS_Face NewF1, TopoDS_Face NewF2) -> GeomAbs_Shape

        Returns the  continuity of  <NewE> between <NewF1>
        and <NewF2>.

        <NewE> is the new  edge created from <E>.  <NewF1>
        (resp. <NewF2>) is the new  face created from <F1>
        (resp. <F2>).

        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :type F1: OCC.wrapper.TopoDS.TopoDS_Face
        :type F2: OCC.wrapper.TopoDS.TopoDS_Face
        :type NewE: OCC.wrapper.TopoDS.TopoDS_Edge
        :type NewF1: OCC.wrapper.TopoDS.TopoDS_Face
        :type NewF2: OCC.wrapper.TopoDS.TopoDS_Face
        :rtype: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _BRepTools.Handle_BRepTools_TrsfModification_Continuity(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_BRepTools_TrsfModification self) -> char const *

        :rtype: const char *

        """
        return _BRepTools.Handle_BRepTools_TrsfModification_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _BRepTools.Handle_BRepTools_TrsfModification_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _BRepTools.Handle_BRepTools_TrsfModification_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def NewTriangulation(self, *args):
        """
        NewTriangulation(Handle_BRepTools_TrsfModification self, TopoDS_Face F, Handle_Poly_Triangulation T) -> Standard_Boolean

        Returns true if the face has been modified according to changed triangulation.
        If the face has been modified:
        - T is a new triangulation on the face

        :type F: OCC.wrapper.TopoDS.TopoDS_Face
        :type T: OCC.wrapper.Poly.Handle_Poly_Triangulation
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepTools.Handle_BRepTools_TrsfModification_NewTriangulation(self, *args)


    def NewPolygon(self, *args):
        """
        NewPolygon(Handle_BRepTools_TrsfModification self, TopoDS_Edge E, Handle_Poly_Polygon3D P) -> Standard_Boolean

        Returns true if the edge has been modified according to changed polygon.
        If the edge has been modified:
        - P is a new polygon

        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :type P: OCC.wrapper.Poly.Handle_Poly_Polygon3D
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepTools.Handle_BRepTools_TrsfModification_NewPolygon(self, *args)


    def NewPolygonOnTriangulation(self, *args):
        """
        NewPolygonOnTriangulation(Handle_BRepTools_TrsfModification self, TopoDS_Edge E, TopoDS_Face F, Handle_Poly_PolygonOnTriangulation P) -> Standard_Boolean

        Returns true if the edge has been modified according to changed polygon on triangulation.
        If the edge has been modified:
        - P is a new polygon on triangulation

        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :type F: OCC.wrapper.TopoDS.TopoDS_Face
        :type P: OCC.wrapper.Poly.Handle_Poly_PolygonOnTriangulation
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepTools.Handle_BRepTools_TrsfModification_NewPolygonOnTriangulation(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_BRepTools_TrsfModification self)

        Memory deallocator for transient classes


        """
        return _BRepTools.Handle_BRepTools_TrsfModification_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_BRepTools_TrsfModification self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_BRepTools_TrsfModification self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepTools.Handle_BRepTools_TrsfModification_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_BRepTools_TrsfModification self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_BRepTools_TrsfModification self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepTools.Handle_BRepTools_TrsfModification_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_BRepTools_TrsfModification self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _BRepTools.Handle_BRepTools_TrsfModification_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_BRepTools_TrsfModification self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepTools.Handle_BRepTools_TrsfModification_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_BRepTools_TrsfModification self)

        Increments the reference counter of this object


        """
        return _BRepTools.Handle_BRepTools_TrsfModification_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_BRepTools_TrsfModification self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepTools.Handle_BRepTools_TrsfModification_DecrementRefCounter(self, *args)

Handle_BRepTools_TrsfModification_swigregister = _BRepTools.Handle_BRepTools_TrsfModification_swigregister
Handle_BRepTools_TrsfModification_swigregister(Handle_BRepTools_TrsfModification)

def Handle_BRepTools_TrsfModification_DownCast(thing):
    return _BRepTools.Handle_BRepTools_TrsfModification_DownCast(thing)
Handle_BRepTools_TrsfModification_DownCast = _BRepTools.Handle_BRepTools_TrsfModification_DownCast

class BRepTools_GTrsfModification(BRepTools_Modification):
    """
    Defines a modification of the  geometry by a  GTrsf
    from gp. All methods return True and transform the
    geometry.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_BRepTools_GTrsfModification
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_BRepTools_GTrsfModification(self) 
            return h


    def __init__(self, *args):
        """
        __init__(BRepTools_GTrsfModification self, gp_GTrsf T) -> BRepTools_GTrsfModification

        :type T: OCC.wrapper.gp.gp_GTrsf

        """
        this = _BRepTools.new_BRepTools_GTrsfModification(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def GTrsf(self, *args):
        """
        GTrsf(BRepTools_GTrsfModification self) -> gp_GTrsf

        Gives an access on the GTrsf.

        :rtype: OCC.wrapper.gp.gp_GTrsf

        """
        return _BRepTools.BRepTools_GTrsfModification_GTrsf(self, *args)


    def NewSurface(self, *args):
        """
        NewSurface(BRepTools_GTrsfModification self, TopoDS_Face F, Handle_Geom_Surface S, TopLoc_Location L) -> Standard_Boolean

        Returns Standard_True  if  the face  <F> has  been
        modified.  In this  case, <S> is the new geometric
        support of  the  face, <L> the  new location,<Tol>
        the new  tolerance.<RevWires> has  to  be set   to
        Standard_True   when the modification reverses the
        normal of  the   surface.(the wires   have  to  be
        reversed).   <RevFace>   has   to   be   set    to
        Standard_True if  the orientation  of the modified
        face changes in the  shells which contain  it.  --
        Here, <RevFace>  will  return Standard_True if the
        -- gp_Trsf is negative.

        :type F: OCC.wrapper.TopoDS.TopoDS_Face
        :type S: OCC.wrapper.Geom.Handle_Geom_Surface
        :type L: OCC.wrapper.TopLoc.TopLoc_Location
        :type Tol: float
        :type RevWires: bool
        :type RevFace: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepTools.BRepTools_GTrsfModification_NewSurface(self, *args)


    def NewCurve(self, *args):
        """
        NewCurve(BRepTools_GTrsfModification self, TopoDS_Edge E, Handle_Geom_Curve C, TopLoc_Location L) -> Standard_Boolean

        Returns Standard_True  if  the edge  <E> has  been
        modified.  In this case,  <C> is the new geometric
        support of the  edge, <L> the  new location, <Tol>
        the         new    tolerance.   Otherwise, returns
        Standard_False,    and  <C>,  <L>,   <Tol> are not
        significant.

        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :type C: OCC.wrapper.Geom.Handle_Geom_Curve
        :type L: OCC.wrapper.TopLoc.TopLoc_Location
        :type Tol: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepTools.BRepTools_GTrsfModification_NewCurve(self, *args)


    def NewPoint(self, *args):
        """
        NewPoint(BRepTools_GTrsfModification self, TopoDS_Vertex V, gp_Pnt P) -> Standard_Boolean

        Returns  Standard_True if the  vertex <V> has been
        modified.  In this  case, <P> is the new geometric
        support of the vertex,   <Tol> the new  tolerance.
        Otherwise, returns Standard_False, and <P>,  <Tol>
        are not significant.

        :type V: OCC.wrapper.TopoDS.TopoDS_Vertex
        :type P: OCC.wrapper.gp.gp_Pnt
        :type Tol: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepTools.BRepTools_GTrsfModification_NewPoint(self, *args)


    def NewCurve2d(self, *args):
        """
        NewCurve2d(BRepTools_GTrsfModification self, TopoDS_Edge E, TopoDS_Face F, TopoDS_Edge NewE, TopoDS_Face NewF, Handle_Geom2d_Curve C) -> Standard_Boolean

        Returns Standard_True if  the edge  <E> has a  new
        curve on surface on the face <F>.In this case, <C>
        is the new geometric support of  the edge, <L> the
        new location, <Tol> the new tolerance.
        Otherwise, returns  Standard_False, and <C>,  <L>,
        <Tol> are not significant.

        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :type F: OCC.wrapper.TopoDS.TopoDS_Face
        :type NewE: OCC.wrapper.TopoDS.TopoDS_Edge
        :type NewF: OCC.wrapper.TopoDS.TopoDS_Face
        :type C: OCC.wrapper.Geom2d.Handle_Geom2d_Curve
        :type Tol: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepTools.BRepTools_GTrsfModification_NewCurve2d(self, *args)


    def NewParameter(self, *args):
        """
        NewParameter(BRepTools_GTrsfModification self, TopoDS_Vertex V, TopoDS_Edge E) -> Standard_Boolean

        Returns Standard_True if the Vertex  <V> has a new
        parameter on the  edge <E>. In  this case,  <P> is
        the parameter,    <Tol>  the     new    tolerance.
        Otherwise, returns Standard_False, and <P>,  <Tol>
        are not significant.

        :type V: OCC.wrapper.TopoDS.TopoDS_Vertex
        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :type P: float
        :type Tol: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepTools.BRepTools_GTrsfModification_NewParameter(self, *args)


    def Continuity(self, *args):
        """
        Continuity(BRepTools_GTrsfModification self, TopoDS_Edge E, TopoDS_Face F1, TopoDS_Face F2, TopoDS_Edge NewE, TopoDS_Face NewF1, TopoDS_Face NewF2) -> GeomAbs_Shape

        Returns the  continuity of  <NewE> between <NewF1>
        and <NewF2>.

        <NewE> is the new  edge created from <E>.  <NewF1>
        (resp. <NewF2>) is the new  face created from <F1>
        (resp. <F2>).

        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :type F1: OCC.wrapper.TopoDS.TopoDS_Face
        :type F2: OCC.wrapper.TopoDS.TopoDS_Face
        :type NewE: OCC.wrapper.TopoDS.TopoDS_Edge
        :type NewF1: OCC.wrapper.TopoDS.TopoDS_Face
        :type NewF2: OCC.wrapper.TopoDS.TopoDS_Face
        :rtype: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _BRepTools.BRepTools_GTrsfModification_Continuity(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _BRepTools.BRepTools_GTrsfModification_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _BRepTools.BRepTools_GTrsfModification_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _BRepTools.BRepTools_GTrsfModification_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _BRepTools.delete_BRepTools_GTrsfModification
BRepTools_GTrsfModification_swigregister = _BRepTools.BRepTools_GTrsfModification_swigregister
BRepTools_GTrsfModification_swigregister(BRepTools_GTrsfModification)

def BRepTools_GTrsfModification_get_type_name(*args):
    """
    BRepTools_GTrsfModification_get_type_name() -> char const *

    :rtype: const char *

    """
    return _BRepTools.BRepTools_GTrsfModification_get_type_name(*args)

def BRepTools_GTrsfModification_get_type_descriptor(*args):
    """
    BRepTools_GTrsfModification_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _BRepTools.BRepTools_GTrsfModification_get_type_descriptor(*args)

class Handle_BRepTools_Modification(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_BRepTools_Modification self)

        Nullify the handle


        """
        return _BRepTools.Handle_BRepTools_Modification_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_BRepTools_Modification self) -> bool

        Check for being null

        :rtype: bool

        """
        return _BRepTools.Handle_BRepTools_Modification_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_BRepTools_Modification self, BRepTools_Modification thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _BRepTools.Handle_BRepTools_Modification_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_BRepTools_Modification self, Handle_BRepTools_Modification theHandle) -> Handle_BRepTools_Modification
        assign(Handle_BRepTools_Modification self, BRepTools_Modification thePtr) -> Handle_BRepTools_Modification
        assign(Handle_BRepTools_Modification self, Handle_BRepTools_Modification theHandle) -> Handle_BRepTools_Modification

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _BRepTools.Handle_BRepTools_Modification_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_BRepTools_Modification self) -> BRepTools_Modification

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _BRepTools.Handle_BRepTools_Modification_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_BRepTools_Modification self) -> BRepTools_Modification

        Member access operator (note non-const)

        :rtype: T *

        """
        return _BRepTools.Handle_BRepTools_Modification___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_BRepTools_Modification self) -> BRepTools_Modification

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _BRepTools.Handle_BRepTools_Modification___ref__(self, *args)


    def __hash__(self):
        return _BRepTools.Handle_BRepTools_Modification___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _BRepTools.Handle_BRepTools_Modification___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _BRepTools.new_Handle_BRepTools_Modification(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_BRepTools.Handle_BRepTools_Modification_DownCast)
    __swig_destroy__ = _BRepTools.delete_Handle_BRepTools_Modification

    def NewSurface(self, *args):
        """
        NewSurface(Handle_BRepTools_Modification self, TopoDS_Face F, Handle_Geom_Surface S, TopLoc_Location L) -> Standard_Boolean

        Returns true if the face, F, has been modified.
        If the face has been modified:
        - S is the new geometry of the face,
        - L is its new location, and
        - Tol is the new tolerance.
        The flag, RevWires, is set to true when the
        modification reverses the normal of the surface, (i.e.
        the wires have to be reversed).
        The flag, RevFace, is set to true if the orientation of
        the modified face changes in the shells which contain it.
        If the face has not been modified this function returns
        false, and the values of S, L, Tol, RevWires and
        RevFace are not significant.

        :type F: OCC.wrapper.TopoDS.TopoDS_Face
        :type S: OCC.wrapper.Geom.Handle_Geom_Surface
        :type L: OCC.wrapper.TopLoc.TopLoc_Location
        :type Tol: float
        :type RevWires: bool
        :type RevFace: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepTools.Handle_BRepTools_Modification_NewSurface(self, *args)


    def NewTriangulation(self, *args):
        """
        NewTriangulation(Handle_BRepTools_Modification self, TopoDS_Face F, Handle_Poly_Triangulation T) -> Standard_Boolean

        Returns true if the face has been modified according to changed triangulation.
        If the face has been modified:
        - T is a new triangulation on the face

        :type F: OCC.wrapper.TopoDS.TopoDS_Face
        :type T: OCC.wrapper.Poly.Handle_Poly_Triangulation
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepTools.Handle_BRepTools_Modification_NewTriangulation(self, *args)


    def NewCurve(self, *args):
        """
        NewCurve(Handle_BRepTools_Modification self, TopoDS_Edge E, Handle_Geom_Curve C, TopLoc_Location L) -> Standard_Boolean

        Returns true if the edge, E, has been modified.
        If the edge has been modified:
        - C is the new geometry associated with the edge,
        - L is its new location, and
        - Tol is the new tolerance.
        If the edge has not been modified, this function
        returns false, and the values of C, L and Tol are not significant.

        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :type C: OCC.wrapper.Geom.Handle_Geom_Curve
        :type L: OCC.wrapper.TopLoc.TopLoc_Location
        :type Tol: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepTools.Handle_BRepTools_Modification_NewCurve(self, *args)


    def NewPolygon(self, *args):
        """
        NewPolygon(Handle_BRepTools_Modification self, TopoDS_Edge E, Handle_Poly_Polygon3D P) -> Standard_Boolean

        Returns true if the edge has been modified according to changed polygon.
        If the edge has been modified:
        - P is a new polygon

        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :type P: OCC.wrapper.Poly.Handle_Poly_Polygon3D
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepTools.Handle_BRepTools_Modification_NewPolygon(self, *args)


    def NewPolygonOnTriangulation(self, *args):
        """
        NewPolygonOnTriangulation(Handle_BRepTools_Modification self, TopoDS_Edge E, TopoDS_Face F, Handle_Poly_PolygonOnTriangulation P) -> Standard_Boolean

        Returns true if the edge has been modified according to changed polygon on triangulation.
        If the edge has been modified:
        - P is a new polygon on triangulation

        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :type F: OCC.wrapper.TopoDS.TopoDS_Face
        :type P: OCC.wrapper.Poly.Handle_Poly_PolygonOnTriangulation
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepTools.Handle_BRepTools_Modification_NewPolygonOnTriangulation(self, *args)


    def NewPoint(self, *args):
        """
        NewPoint(Handle_BRepTools_Modification self, TopoDS_Vertex V, gp_Pnt P) -> Standard_Boolean

        Returns true if the vertex V has been modified.
        If V has been modified:
        - P is the new geometry of the vertex, and
        - Tol is the new tolerance.
        If the vertex has not been modified this function
        returns false, and the values of P and Tol are not significant.

        :type V: OCC.wrapper.TopoDS.TopoDS_Vertex
        :type P: OCC.wrapper.gp.gp_Pnt
        :type Tol: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepTools.Handle_BRepTools_Modification_NewPoint(self, *args)


    def NewCurve2d(self, *args):
        """
        NewCurve2d(Handle_BRepTools_Modification self, TopoDS_Edge E, TopoDS_Face F, TopoDS_Edge NewE, TopoDS_Face NewF, Handle_Geom2d_Curve C) -> Standard_Boolean

        Returns true if the edge, E, has a new curve on
        surface on the face, F.
        If a new curve exists:
        - C is the new geometry of the edge,
        - L is the new location, and
        - Tol is the new tolerance.
        NewE is the new edge created from E, and NewF is
        the new face created from F.
        If there is no new curve on the face, this function
        returns false, and the values of C, L and Tol are not significant.

        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :type F: OCC.wrapper.TopoDS.TopoDS_Face
        :type NewE: OCC.wrapper.TopoDS.TopoDS_Edge
        :type NewF: OCC.wrapper.TopoDS.TopoDS_Face
        :type C: OCC.wrapper.Geom2d.Handle_Geom2d_Curve
        :type Tol: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepTools.Handle_BRepTools_Modification_NewCurve2d(self, *args)


    def NewParameter(self, *args):
        """
        NewParameter(Handle_BRepTools_Modification self, TopoDS_Vertex V, TopoDS_Edge E) -> Standard_Boolean

        Returns true if the vertex V has a new parameter on the edge E.
        If a new parameter exists:
        - P is the parameter, and
        - Tol is the new tolerance.
        If there is no new parameter this function returns
        false, and the values of P and Tol are not significant.

        :type V: OCC.wrapper.TopoDS.TopoDS_Vertex
        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :type P: float
        :type Tol: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepTools.Handle_BRepTools_Modification_NewParameter(self, *args)


    def Continuity(self, *args):
        """
        Continuity(Handle_BRepTools_Modification self, TopoDS_Edge E, TopoDS_Face F1, TopoDS_Face F2, TopoDS_Edge NewE, TopoDS_Face NewF1, TopoDS_Face NewF2) -> GeomAbs_Shape

        Returns the  continuity of  <NewE> between <NewF1>
        and <NewF2>.
        <NewE> is the new  edge created from <E>.  <NewF1>
        (resp. <NewF2>) is the new  face created from <F1>
        (resp. <F2>).

        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :type F1: OCC.wrapper.TopoDS.TopoDS_Face
        :type F2: OCC.wrapper.TopoDS.TopoDS_Face
        :type NewE: OCC.wrapper.TopoDS.TopoDS_Edge
        :type NewF1: OCC.wrapper.TopoDS.TopoDS_Face
        :type NewF2: OCC.wrapper.TopoDS.TopoDS_Face
        :rtype: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _BRepTools.Handle_BRepTools_Modification_Continuity(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_BRepTools_Modification self) -> char const *

        :rtype: const char *

        """
        return _BRepTools.Handle_BRepTools_Modification_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _BRepTools.Handle_BRepTools_Modification_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _BRepTools.Handle_BRepTools_Modification_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_BRepTools_Modification self)

        Memory deallocator for transient classes


        """
        return _BRepTools.Handle_BRepTools_Modification_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_BRepTools_Modification self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_BRepTools_Modification self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepTools.Handle_BRepTools_Modification_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_BRepTools_Modification self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_BRepTools_Modification self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepTools.Handle_BRepTools_Modification_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_BRepTools_Modification self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _BRepTools.Handle_BRepTools_Modification_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_BRepTools_Modification self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepTools.Handle_BRepTools_Modification_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_BRepTools_Modification self)

        Increments the reference counter of this object


        """
        return _BRepTools.Handle_BRepTools_Modification_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_BRepTools_Modification self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepTools.Handle_BRepTools_Modification_DecrementRefCounter(self, *args)

Handle_BRepTools_Modification_swigregister = _BRepTools.Handle_BRepTools_Modification_swigregister
Handle_BRepTools_Modification_swigregister(Handle_BRepTools_Modification)

def Handle_BRepTools_Modification_DownCast(thing):
    return _BRepTools.Handle_BRepTools_Modification_DownCast(thing)
Handle_BRepTools_Modification_DownCast = _BRepTools.Handle_BRepTools_Modification_DownCast

class Handle_BRepTools_History(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_BRepTools_History self)

        Nullify the handle


        """
        return _BRepTools.Handle_BRepTools_History_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_BRepTools_History self) -> bool

        Check for being null

        :rtype: bool

        """
        return _BRepTools.Handle_BRepTools_History_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_BRepTools_History self, BRepTools_History thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _BRepTools.Handle_BRepTools_History_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_BRepTools_History self, Handle_BRepTools_History theHandle) -> Handle_BRepTools_History
        assign(Handle_BRepTools_History self, BRepTools_History thePtr) -> Handle_BRepTools_History
        assign(Handle_BRepTools_History self, Handle_BRepTools_History theHandle) -> Handle_BRepTools_History

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _BRepTools.Handle_BRepTools_History_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_BRepTools_History self) -> BRepTools_History

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _BRepTools.Handle_BRepTools_History_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_BRepTools_History self) -> BRepTools_History

        Member access operator (note non-const)

        :rtype: T *

        """
        return _BRepTools.Handle_BRepTools_History___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_BRepTools_History self) -> BRepTools_History

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _BRepTools.Handle_BRepTools_History___ref__(self, *args)


    def __hash__(self):
        return _BRepTools.Handle_BRepTools_History___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _BRepTools.Handle_BRepTools_History___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _BRepTools.new_Handle_BRepTools_History(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_BRepTools.Handle_BRepTools_History_DownCast)
    __swig_destroy__ = _BRepTools.delete_Handle_BRepTools_History

    def IsSupportedType(self, *args):
        """
        IsSupportedType(Handle_BRepTools_History self, TopoDS_Shape theShape) -> Standard_Boolean

        Returns 'true' if the type of the shape is supported by the history.

        :type theShape: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepTools.Handle_BRepTools_History_IsSupportedType(self, *args)


    def AddGenerated(self, *args):
        """
        AddGenerated(Handle_BRepTools_History self, TopoDS_Shape theInitial, TopoDS_Shape theGenerated)

        Set the second shape as generated one from the first shape.

        :type theInitial: OCC.wrapper.TopoDS.TopoDS_Shape
        :type theGenerated: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _BRepTools.Handle_BRepTools_History_AddGenerated(self, *args)


    def AddModified(self, *args):
        """
        AddModified(Handle_BRepTools_History self, TopoDS_Shape theInitial, TopoDS_Shape theModified)

        Set the second shape as modified one from the first shape.

        :type theInitial: OCC.wrapper.TopoDS.TopoDS_Shape
        :type theModified: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _BRepTools.Handle_BRepTools_History_AddModified(self, *args)


    def Remove(self, *args):
        """
        Remove(Handle_BRepTools_History self, TopoDS_Shape theRemoved)

        Set the shape as removed one.

        :type theRemoved: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _BRepTools.Handle_BRepTools_History_Remove(self, *args)


    def ReplaceGenerated(self, *args):
        """
        ReplaceGenerated(Handle_BRepTools_History self, TopoDS_Shape theInitial, TopoDS_Shape theGenerated)

        Set the second shape as the only generated one from the first one.

        :type theInitial: OCC.wrapper.TopoDS.TopoDS_Shape
        :type theGenerated: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _BRepTools.Handle_BRepTools_History_ReplaceGenerated(self, *args)


    def ReplaceModified(self, *args):
        """
        ReplaceModified(Handle_BRepTools_History self, TopoDS_Shape theInitial, TopoDS_Shape theModified)

        Set the second shape as the only modified one from the first one.

        :type theInitial: OCC.wrapper.TopoDS.TopoDS_Shape
        :type theModified: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _BRepTools.Handle_BRepTools_History_ReplaceModified(self, *args)


    def Clear(self, *args):
        """
        Clear(Handle_BRepTools_History self)

        Clears the history.


        """
        return _BRepTools.Handle_BRepTools_History_Clear(self, *args)


    def Generated(self, *args):
        """
        Returns all shapes generated from the shape.

        :type theInitial: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.TopTools.TopTools_ListOfShape

        """
        res = _BRepTools.Handle_BRepTools_History_Generated(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Modified(self, *args):
        """
        Returns all shapes modified from the shape.

        :type theInitial: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.TopTools.TopTools_ListOfShape

        """
        res = _BRepTools.Handle_BRepTools_History_Modified(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def IsRemoved(self, *args):
        """
        IsRemoved(Handle_BRepTools_History self, TopoDS_Shape theInitial) -> Standard_Boolean

        Returns 'true' if the shape is removed.

        :type theInitial: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepTools.Handle_BRepTools_History_IsRemoved(self, *args)


    def Merge(self, *args):
        """
        Merge(Handle_BRepTools_History self, Handle_BRepTools_History theHistory23)
        Merge(Handle_BRepTools_History self, BRepTools_History theHistory23)

        Merges the next history to this history.

        :type theHistory23: OCC.wrapper.BRepTools.BRepTools_History

        """
        return _BRepTools.Handle_BRepTools_History_Merge(self, *args)


    def Dump(self, *args):
        """
        Dump(Handle_BRepTools_History self, Standard_OStream & theS)

        Prints the brief description of the history into a stream

        :type theS: OCC.wrapper.Standard.Standard_OStream

        """
        return _BRepTools.Handle_BRepTools_History_Dump(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_BRepTools_History self) -> char const *

        :rtype: const char *

        """
        return _BRepTools.Handle_BRepTools_History_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _BRepTools.Handle_BRepTools_History_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _BRepTools.Handle_BRepTools_History_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_BRepTools_History self)

        Memory deallocator for transient classes


        """
        return _BRepTools.Handle_BRepTools_History_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_BRepTools_History self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_BRepTools_History self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepTools.Handle_BRepTools_History_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_BRepTools_History self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_BRepTools_History self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepTools.Handle_BRepTools_History_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_BRepTools_History self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _BRepTools.Handle_BRepTools_History_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_BRepTools_History self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepTools.Handle_BRepTools_History_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_BRepTools_History self)

        Increments the reference counter of this object


        """
        return _BRepTools.Handle_BRepTools_History_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_BRepTools_History self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepTools.Handle_BRepTools_History_DecrementRefCounter(self, *args)

Handle_BRepTools_History_swigregister = _BRepTools.Handle_BRepTools_History_swigregister
Handle_BRepTools_History_swigregister(Handle_BRepTools_History)

def Handle_BRepTools_History_DownCast(thing):
    return _BRepTools.Handle_BRepTools_History_DownCast(thing)
Handle_BRepTools_History_DownCast = _BRepTools.Handle_BRepTools_History_DownCast

class BRepTools_Quilt(object):
    """
    A  Tool    to  glue faces  at  common    edges and
    reconstruct shells.

    The user designate pairs of common edges using the
    method Bind. One edge is designated as the edge to
    use  in place of the  other one (they are supposed
    to   be    geometrically confused,  but  this  not
    checked). They can be of opposite directions, this
    is specified by the orientations.

    The user can add  shapes with the Add method,  all
    the faces are  registred and  copies of faces  and
    edges are made to glue at the bound edges.

    The user can call the Shells  methods to compute a
    compound of shells from the current set of faces.

    If no  binding is made  this class can  be used to
    make shell from faces already sharing their edges.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BRepTools_Quilt self) -> BRepTools_Quilt

        A  Tool    to  glue faces  at  common    edges and
        reconstruct shells.

        The user designate pairs of common edges using the
        method Bind. One edge is designated as the edge to
        use  in place of the  other one (they are supposed
        to   be    geometrically confused,  but  this  not
        checked). They can be of opposite directions, this
        is specified by the orientations.

        The user can add  shapes with the Add method,  all
        the faces are  registred and  copies of faces  and
        edges are made to glue at the bound edges.

        The user can call the Shells  methods to compute a
        compound of shells from the current set of faces.

        If no  binding is made  this class can  be used to
        make shell from faces already sharing their edges.
        """
        this = _BRepTools.new_BRepTools_Quilt(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Bind(self, *args):
        """
        Bind(BRepTools_Quilt self, TopoDS_Edge Eold, TopoDS_Edge Enew)
        Bind(BRepTools_Quilt self, TopoDS_Vertex Vold, TopoDS_Vertex Vnew)

        Binds <VNew> to be a new vertex instead of <Vold>.

        The faces  of  the added  shape containing  <Vold>
        will be copied to substitute <Vold> by <Vnew>.

        :type Vold: OCC.wrapper.TopoDS.TopoDS_Vertex
        :type Vnew: OCC.wrapper.TopoDS.TopoDS_Vertex

        """
        return _BRepTools.BRepTools_Quilt_Bind(self, *args)


    def Add(self, *args):
        """
        Add(BRepTools_Quilt self, TopoDS_Shape S)

        Add   the faces of  <S>  to  the Quilt,  the faces
        containing bounded edges are copied.

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _BRepTools.BRepTools_Quilt_Add(self, *args)


    def IsCopied(self, *args):
        """
        IsCopied(BRepTools_Quilt self, TopoDS_Shape S) -> Standard_Boolean

        Returns   True if <S> has   been  copied (<S> is a
        vertex, an edge or a face)

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepTools.BRepTools_Quilt_IsCopied(self, *args)


    def Copy(self, *args):
        """
        Returns the shape  substitued to <S> in the Quilt.

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _BRepTools.BRepTools_Quilt_Copy(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Shells(self, *args):
        """
        Shells(BRepTools_Quilt self) -> TopoDS_Shape

        Returns a Compound of shells made from the current
        set of faces. The shells will be flagged as closed
        or not closed.

        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _BRepTools.BRepTools_Quilt_Shells(self, *args)

    __swig_destroy__ = _BRepTools.delete_BRepTools_Quilt
BRepTools_Quilt_swigregister = _BRepTools.BRepTools_Quilt_swigregister
BRepTools_Quilt_swigregister(BRepTools_Quilt)

class Handle_BRepTools_ReShape(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_BRepTools_ReShape self)

        Nullify the handle


        """
        return _BRepTools.Handle_BRepTools_ReShape_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_BRepTools_ReShape self) -> bool

        Check for being null

        :rtype: bool

        """
        return _BRepTools.Handle_BRepTools_ReShape_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_BRepTools_ReShape self, BRepTools_ReShape thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _BRepTools.Handle_BRepTools_ReShape_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_BRepTools_ReShape self, Handle_BRepTools_ReShape theHandle) -> Handle_BRepTools_ReShape
        assign(Handle_BRepTools_ReShape self, BRepTools_ReShape thePtr) -> Handle_BRepTools_ReShape
        assign(Handle_BRepTools_ReShape self, Handle_BRepTools_ReShape theHandle) -> Handle_BRepTools_ReShape

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _BRepTools.Handle_BRepTools_ReShape_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_BRepTools_ReShape self) -> BRepTools_ReShape

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _BRepTools.Handle_BRepTools_ReShape_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_BRepTools_ReShape self) -> BRepTools_ReShape

        Member access operator (note non-const)

        :rtype: T *

        """
        return _BRepTools.Handle_BRepTools_ReShape___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_BRepTools_ReShape self) -> BRepTools_ReShape

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _BRepTools.Handle_BRepTools_ReShape___ref__(self, *args)


    def __hash__(self):
        return _BRepTools.Handle_BRepTools_ReShape___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _BRepTools.Handle_BRepTools_ReShape___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _BRepTools.new_Handle_BRepTools_ReShape(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_BRepTools.Handle_BRepTools_ReShape_DownCast)
    __swig_destroy__ = _BRepTools.delete_Handle_BRepTools_ReShape

    def Clear(self, *args):
        """
        Clear(Handle_BRepTools_ReShape self)

        Clears all substitutions requests


        """
        return _BRepTools.Handle_BRepTools_ReShape_Clear(self, *args)


    def Remove(self, *args):
        """
        Remove(Handle_BRepTools_ReShape self, TopoDS_Shape shape)

        Sets a request to Remove a Shape whatever the orientation

        :type shape: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _BRepTools.Handle_BRepTools_ReShape_Remove(self, *args)


    def Replace(self, *args):
        """
        Replace(Handle_BRepTools_ReShape self, TopoDS_Shape shape, TopoDS_Shape newshape)

        Sets a request to Replace a Shape by a new one.

        :type shape: OCC.wrapper.TopoDS.TopoDS_Shape
        :type newshape: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _BRepTools.Handle_BRepTools_ReShape_Replace(self, *args)


    def IsRecorded(self, *args):
        """
        IsRecorded(Handle_BRepTools_ReShape self, TopoDS_Shape shape) -> Standard_Boolean

        Tells if a shape is recorded for Replace/Remove

        :type shape: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepTools.Handle_BRepTools_ReShape_IsRecorded(self, *args)


    def Value(self, *args):
        """
        Value(Handle_BRepTools_ReShape self, TopoDS_Shape shape) -> TopoDS_Shape

        Returns the new value for an individual shape
        If not recorded, returns the original shape itself
        If to be Removed, returns a Null Shape
        Else, returns the replacing item

        :type shape: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _BRepTools.Handle_BRepTools_ReShape_Value(self, *args)


    def Status(self, *args):
        """
        Status(Handle_BRepTools_ReShape self, TopoDS_Shape shape, TopoDS_Shape newsh, Standard_Boolean const last) -> Standard_Integer

        Returns a complete substitution status for a shape
        0  : not recorded,   <newsh> = original <shape>
        < 0: to be removed,  <newsh> is NULL
        > 0: to be replaced, <newsh> is a new item
        If <last> is False, returns status and new shape recorded in
        the map directly for the shape, if True and status > 0 then
        recursively searches for the last status and new shape.

        :type shape: OCC.wrapper.TopoDS.TopoDS_Shape
        :type newsh: OCC.wrapper.TopoDS.TopoDS_Shape
        :type last: bool
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepTools.Handle_BRepTools_ReShape_Status(self, *args)


    def Apply(self, *args):
        """
        Apply(Handle_BRepTools_ReShape self, TopoDS_Shape shape, TopAbs_ShapeEnum const until=TopAbs_SHAPE) -> TopoDS_Shape

        Applies the substitutions requests to a shape.

        <until> gives the level of type until which requests are taken
        into account. For subshapes of the type <until> no rebuild
        and futher exploring are done.

        NOTE: each subshape can be replaced by shape of the same type
        or by shape containing only shapes of that type (for
        example, TopoDS_Edge can be replaced by TopoDS_Edge,
        TopoDS_Wire or TopoDS_Compound containing TopoDS_Edges).
        If incompatible shape type is encountered, it is ignored
        and flag FAIL1 is set in Status.

        :type shape: OCC.wrapper.TopoDS.TopoDS_Shape
        :type until: OCC.wrapper.TopAbs.TopAbs_ShapeEnum
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _BRepTools.Handle_BRepTools_ReShape_Apply(self, *args)


    def ModeConsiderLocation(self, *args):
        """
        ModeConsiderLocation(Handle_BRepTools_ReShape self) -> Standard_Boolean &

        Returns (modifiable) the flag which defines whether Location of shape take into account
        during replacing shapes.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepTools.Handle_BRepTools_ReShape_ModeConsiderLocation(self, *args)


    def CopyVertex(self, *args):
        """
        CopyVertex(Handle_BRepTools_ReShape self, TopoDS_Vertex theV, Standard_Real const theTol=-1.0) -> TopoDS_Vertex
        CopyVertex(Handle_BRepTools_ReShape self, TopoDS_Vertex theV, gp_Pnt theNewPos, Standard_Real const aTol) -> TopoDS_Vertex

        :type theV: OCC.wrapper.TopoDS.TopoDS_Vertex
        :type theNewPos: OCC.wrapper.gp.gp_Pnt
        :type aTol: float
        :rtype: OCC.wrapper.TopoDS.TopoDS_Vertex

        """
        return _BRepTools.Handle_BRepTools_ReShape_CopyVertex(self, *args)


    def IsNewShape(self, *args):
        """
        IsNewShape(Handle_BRepTools_ReShape self, TopoDS_Shape theShape) -> Standard_Boolean

        :type theShape: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepTools.Handle_BRepTools_ReShape_IsNewShape(self, *args)


    def History(self, *args):
        """
        History(Handle_BRepTools_ReShape self) -> Handle_BRepTools_History

        Returns the history of the substituted shapes.

        :rtype: OCC.wrapper.BRepTools.Handle_BRepTools_History

        """
        return _BRepTools.Handle_BRepTools_ReShape_History(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_BRepTools_ReShape self) -> char const *

        :rtype: const char *

        """
        return _BRepTools.Handle_BRepTools_ReShape_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _BRepTools.Handle_BRepTools_ReShape_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _BRepTools.Handle_BRepTools_ReShape_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_BRepTools_ReShape self)

        Memory deallocator for transient classes


        """
        return _BRepTools.Handle_BRepTools_ReShape_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_BRepTools_ReShape self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_BRepTools_ReShape self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepTools.Handle_BRepTools_ReShape_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_BRepTools_ReShape self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_BRepTools_ReShape self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepTools.Handle_BRepTools_ReShape_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_BRepTools_ReShape self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _BRepTools.Handle_BRepTools_ReShape_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_BRepTools_ReShape self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepTools.Handle_BRepTools_ReShape_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_BRepTools_ReShape self)

        Increments the reference counter of this object


        """
        return _BRepTools.Handle_BRepTools_ReShape_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_BRepTools_ReShape self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepTools.Handle_BRepTools_ReShape_DecrementRefCounter(self, *args)

Handle_BRepTools_ReShape_swigregister = _BRepTools.Handle_BRepTools_ReShape_swigregister
Handle_BRepTools_ReShape_swigregister(Handle_BRepTools_ReShape)

def Handle_BRepTools_ReShape_DownCast(thing):
    return _BRepTools.Handle_BRepTools_ReShape_DownCast(thing)
Handle_BRepTools_ReShape_DownCast = _BRepTools.Handle_BRepTools_ReShape_DownCast


try:
	TColgp_SequenceOfPnt2d = TColgp.NCollection_Sequence_gp_Pnt2d
except AttributeError:
	pass # does not exist, probably ignored

class BRepTools_Modifier(object):
    """Performs geometric modifications on a shape."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BRepTools_Modifier self, Standard_Boolean theMutableInput) -> BRepTools_Modifier
        __init__(BRepTools_Modifier self, TopoDS_Shape S) -> BRepTools_Modifier
        __init__(BRepTools_Modifier self, TopoDS_Shape S, Handle_BRepTools_Modification M) -> BRepTools_Modifier

        Creates a modifier on  the shape <S>, and performs
        the modifications described by <M>.

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :type M: OCC.wrapper.BRepTools.Handle_BRepTools_Modification

        """
        this = _BRepTools.new_BRepTools_Modifier(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(BRepTools_Modifier self, TopoDS_Shape S)

        Initializes the modifier with the shape <S>.

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _BRepTools.BRepTools_Modifier_Init(self, *args)


    def Perform(self, *args):
        """
        Perform(BRepTools_Modifier self, Handle_BRepTools_Modification M, Handle_Message_ProgressIndicator aProgress=0)

        Performs the modifications described by <M>.

        :type M: OCC.wrapper.BRepTools.Handle_BRepTools_Modification
        :type aProgress: OCC.wrapper.Message.Handle_Message_ProgressIndicator

        """
        return _BRepTools.BRepTools_Modifier_Perform(self, *args)


    def IsDone(self, *args):
        """
        IsDone(BRepTools_Modifier self) -> Standard_Boolean

        Returns Standard_True if the modification has
        been computed successfully.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepTools.BRepTools_Modifier_IsDone(self, *args)


    def IsMutableInput(self, *args):
        """
        IsMutableInput(BRepTools_Modifier self) -> Standard_Boolean

        Returns the current mutable input state

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepTools.BRepTools_Modifier_IsMutableInput(self, *args)


    def SetMutableInput(self, *args):
        """
        SetMutableInput(BRepTools_Modifier self, Standard_Boolean theMutableInput)

        Sets the mutable input state
        If true then the input (original) shape can be modified 
        during modification process

        :type theMutableInput: bool

        """
        return _BRepTools.BRepTools_Modifier_SetMutableInput(self, *args)


    def ModifiedShape(self, *args):
        """
        Returns the modified shape corresponding to <S>.

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _BRepTools.BRepTools_Modifier_ModifiedShape(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _BRepTools.delete_BRepTools_Modifier
BRepTools_Modifier_swigregister = _BRepTools.BRepTools_Modifier_swigregister
BRepTools_Modifier_swigregister(BRepTools_Modifier)

class BRepTools_WireExplorer(object):
    """
    The WireExplorer is a tool to explore the edges of
    a wire in a connection order.

    i.e. each edge is connected to the previous one by
    its origin.
    If a wire is not closed returns only a segment of edges which
    length depends on started in exploration edge. 
    Algorithm suggests that wire is valid and has no any defects, which 
    can stop edge exploration. Such defects can be loops, wrong orientation of edges
    (two edges go in to shared vertex or go out from shared vertex), branching of edges, 
    the presens of edges with INTERNAL or EXTERNAL orientation. If wire has
    such kind of defects WireExplorer can return not all
    edges in a wire. it depends on type of defect and position of starting edge.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BRepTools_WireExplorer self) -> BRepTools_WireExplorer
        __init__(BRepTools_WireExplorer self, TopoDS_Wire W) -> BRepTools_WireExplorer
        __init__(BRepTools_WireExplorer self, TopoDS_Wire W, TopoDS_Face F) -> BRepTools_WireExplorer

        Initializes an exploration  of the wire <W>.
        F is used to select the edge connected to the
        previous in the parametric representation of <F>.

        :type W: OCC.wrapper.TopoDS.TopoDS_Wire
        :type F: OCC.wrapper.TopoDS.TopoDS_Face

        """
        this = _BRepTools.new_BRepTools_WireExplorer(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(BRepTools_WireExplorer self, TopoDS_Wire W)
        Init(BRepTools_WireExplorer self, TopoDS_Wire W, TopoDS_Face F)
        Init(BRepTools_WireExplorer self, TopoDS_Wire W, TopoDS_Face F, Standard_Real const UMin, Standard_Real const UMax, Standard_Real const VMin, Standard_Real const VMax)

        Initializes an exploration of the wire <W>.
        F is used to select the edge connected to the
        previous in the parametric representation of <F>.
        <UMIn>, <UMax>, <VMin>, <VMax> - the UV bounds of the face <F>.

        :type W: OCC.wrapper.TopoDS.TopoDS_Wire
        :type F: OCC.wrapper.TopoDS.TopoDS_Face
        :type UMin: float
        :type UMax: float
        :type VMin: float
        :type VMax: float

        """
        return _BRepTools.BRepTools_WireExplorer_Init(self, *args)


    def More(self, *args):
        """
        More(BRepTools_WireExplorer self) -> Standard_Boolean

        Returns True if there  is a current  edge.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepTools.BRepTools_WireExplorer_More(self, *args)


    def Next(self, *args):
        """
        Next(BRepTools_WireExplorer self)

        Proceeds to the next edge.


        """
        return _BRepTools.BRepTools_WireExplorer_Next(self, *args)


    def Current(self, *args):
        """
        Returns the current edge.

        :rtype: OCC.wrapper.TopoDS.TopoDS_Edge

        """
        res = _BRepTools.BRepTools_WireExplorer_Current(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Orientation(self, *args):
        """
        Orientation(BRepTools_WireExplorer self) -> TopAbs_Orientation

        Returns an Orientation for the current edge.

        :rtype: OCC.wrapper.TopAbs.TopAbs_Orientation

        """
        return _BRepTools.BRepTools_WireExplorer_Orientation(self, *args)


    def CurrentVertex(self, *args):
        """
        Returns the vertex connecting the current  edge to
        the previous one.

        :rtype: OCC.wrapper.TopoDS.TopoDS_Vertex

        """
        res = _BRepTools.BRepTools_WireExplorer_CurrentVertex(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Clear(self, *args):
        """
        Clear(BRepTools_WireExplorer self)

        Clears the content of the explorer.


        """
        return _BRepTools.BRepTools_WireExplorer_Clear(self, *args)

    __swig_destroy__ = _BRepTools.delete_BRepTools_WireExplorer
BRepTools_WireExplorer_swigregister = _BRepTools.BRepTools_WireExplorer_swigregister
BRepTools_WireExplorer_swigregister(BRepTools_WireExplorer)

class BRepTools_Substitution(object):
    """
    A tool to substitute subshapes by other shapes.

    The user use the method Substitute to define the
    modifications.
    A set of shapes is designated to replace a initial
    shape.

    The method Build reconstructs a new Shape with the
    modifications.The Shape and the new shape are
    registered.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BRepTools_Substitution self) -> BRepTools_Substitution

        A tool to substitute subshapes by other shapes.

        The user use the method Substitute to define the
        modifications.
        A set of shapes is designated to replace a initial
        shape.

        The method Build reconstructs a new Shape with the
        modifications.The Shape and the new shape are
        registered.
        """
        this = _BRepTools.new_BRepTools_Substitution(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Clear(self, *args):
        """
        Clear(BRepTools_Substitution self)

        Reset all the fields.


        """
        return _BRepTools.BRepTools_Substitution_Clear(self, *args)


    def Substitute(self, *args):
        """
        Substitute(BRepTools_Substitution self, TopoDS_Shape OldShape, NCollection_List_TopoDS_Shape NewShapes)

        <Oldshape> will be replaced by <NewShapes>.

        <NewShapes> can be empty , in this case <OldShape>
        will disparate from its ancestors.

        if an item of <NewShapes> is oriented FORWARD.
        it will be oriented as <OldShape> in its ancestors.
        else it will be reversed.

        :type OldShape: OCC.wrapper.TopoDS.TopoDS_Shape
        :type NewShapes: OCC.wrapper.TopTools.TopTools_ListOfShape

        """
        return _BRepTools.BRepTools_Substitution_Substitute(self, *args)


    def Build(self, *args):
        """
        Build(BRepTools_Substitution self, TopoDS_Shape S)

        Build NewShape from <S> if its subshapes has modified.

        The methods <IsCopied> and <Copy> allows you to keep
        the resul of <Build>

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _BRepTools.BRepTools_Substitution_Build(self, *args)


    def IsCopied(self, *args):
        """
        IsCopied(BRepTools_Substitution self, TopoDS_Shape S) -> Standard_Boolean

        Returns   True if <S> has   been  replaced .

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepTools.BRepTools_Substitution_IsCopied(self, *args)


    def Copy(self, *args):
        """
        Returns the set of shapes  substitued to <S> .

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.TopTools.TopTools_ListOfShape

        """
        res = _BRepTools.BRepTools_Substitution_Copy(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _BRepTools.delete_BRepTools_Substitution
BRepTools_Substitution_swigregister = _BRepTools.BRepTools_Substitution_swigregister
BRepTools_Substitution_swigregister(BRepTools_Substitution)

class Handle_BRepTools_GTrsfModification(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_BRepTools_GTrsfModification self)

        Nullify the handle


        """
        return _BRepTools.Handle_BRepTools_GTrsfModification_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_BRepTools_GTrsfModification self) -> bool

        Check for being null

        :rtype: bool

        """
        return _BRepTools.Handle_BRepTools_GTrsfModification_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_BRepTools_GTrsfModification self, BRepTools_GTrsfModification thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _BRepTools.Handle_BRepTools_GTrsfModification_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_BRepTools_GTrsfModification self, Handle_BRepTools_GTrsfModification theHandle) -> Handle_BRepTools_GTrsfModification
        assign(Handle_BRepTools_GTrsfModification self, BRepTools_GTrsfModification thePtr) -> Handle_BRepTools_GTrsfModification
        assign(Handle_BRepTools_GTrsfModification self, Handle_BRepTools_GTrsfModification theHandle) -> Handle_BRepTools_GTrsfModification

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _BRepTools.Handle_BRepTools_GTrsfModification_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_BRepTools_GTrsfModification self) -> BRepTools_GTrsfModification

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _BRepTools.Handle_BRepTools_GTrsfModification_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_BRepTools_GTrsfModification self) -> BRepTools_GTrsfModification

        Member access operator (note non-const)

        :rtype: T *

        """
        return _BRepTools.Handle_BRepTools_GTrsfModification___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_BRepTools_GTrsfModification self) -> BRepTools_GTrsfModification

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _BRepTools.Handle_BRepTools_GTrsfModification___ref__(self, *args)


    def __hash__(self):
        return _BRepTools.Handle_BRepTools_GTrsfModification___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _BRepTools.Handle_BRepTools_GTrsfModification___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _BRepTools.new_Handle_BRepTools_GTrsfModification(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_BRepTools.Handle_BRepTools_GTrsfModification_DownCast)
    __swig_destroy__ = _BRepTools.delete_Handle_BRepTools_GTrsfModification

    def GTrsf(self, *args):
        """
        GTrsf(Handle_BRepTools_GTrsfModification self) -> gp_GTrsf

        Gives an access on the GTrsf.

        :rtype: OCC.wrapper.gp.gp_GTrsf

        """
        return _BRepTools.Handle_BRepTools_GTrsfModification_GTrsf(self, *args)


    def NewSurface(self, *args):
        """
        NewSurface(Handle_BRepTools_GTrsfModification self, TopoDS_Face F, Handle_Geom_Surface S, TopLoc_Location L) -> Standard_Boolean

        Returns Standard_True  if  the face  <F> has  been
        modified.  In this  case, <S> is the new geometric
        support of  the  face, <L> the  new location,<Tol>
        the new  tolerance.<RevWires> has  to  be set   to
        Standard_True   when the modification reverses the
        normal of  the   surface.(the wires   have  to  be
        reversed).   <RevFace>   has   to   be   set    to
        Standard_True if  the orientation  of the modified
        face changes in the  shells which contain  it.  --
        Here, <RevFace>  will  return Standard_True if the
        -- gp_Trsf is negative.

        :type F: OCC.wrapper.TopoDS.TopoDS_Face
        :type S: OCC.wrapper.Geom.Handle_Geom_Surface
        :type L: OCC.wrapper.TopLoc.TopLoc_Location
        :type Tol: float
        :type RevWires: bool
        :type RevFace: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepTools.Handle_BRepTools_GTrsfModification_NewSurface(self, *args)


    def NewCurve(self, *args):
        """
        NewCurve(Handle_BRepTools_GTrsfModification self, TopoDS_Edge E, Handle_Geom_Curve C, TopLoc_Location L) -> Standard_Boolean

        Returns Standard_True  if  the edge  <E> has  been
        modified.  In this case,  <C> is the new geometric
        support of the  edge, <L> the  new location, <Tol>
        the         new    tolerance.   Otherwise, returns
        Standard_False,    and  <C>,  <L>,   <Tol> are not
        significant.

        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :type C: OCC.wrapper.Geom.Handle_Geom_Curve
        :type L: OCC.wrapper.TopLoc.TopLoc_Location
        :type Tol: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepTools.Handle_BRepTools_GTrsfModification_NewCurve(self, *args)


    def NewPoint(self, *args):
        """
        NewPoint(Handle_BRepTools_GTrsfModification self, TopoDS_Vertex V, gp_Pnt P) -> Standard_Boolean

        Returns  Standard_True if the  vertex <V> has been
        modified.  In this  case, <P> is the new geometric
        support of the vertex,   <Tol> the new  tolerance.
        Otherwise, returns Standard_False, and <P>,  <Tol>
        are not significant.

        :type V: OCC.wrapper.TopoDS.TopoDS_Vertex
        :type P: OCC.wrapper.gp.gp_Pnt
        :type Tol: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepTools.Handle_BRepTools_GTrsfModification_NewPoint(self, *args)


    def NewCurve2d(self, *args):
        """
        NewCurve2d(Handle_BRepTools_GTrsfModification self, TopoDS_Edge E, TopoDS_Face F, TopoDS_Edge NewE, TopoDS_Face NewF, Handle_Geom2d_Curve C) -> Standard_Boolean

        Returns Standard_True if  the edge  <E> has a  new
        curve on surface on the face <F>.In this case, <C>
        is the new geometric support of  the edge, <L> the
        new location, <Tol> the new tolerance.
        Otherwise, returns  Standard_False, and <C>,  <L>,
        <Tol> are not significant.

        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :type F: OCC.wrapper.TopoDS.TopoDS_Face
        :type NewE: OCC.wrapper.TopoDS.TopoDS_Edge
        :type NewF: OCC.wrapper.TopoDS.TopoDS_Face
        :type C: OCC.wrapper.Geom2d.Handle_Geom2d_Curve
        :type Tol: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepTools.Handle_BRepTools_GTrsfModification_NewCurve2d(self, *args)


    def NewParameter(self, *args):
        """
        NewParameter(Handle_BRepTools_GTrsfModification self, TopoDS_Vertex V, TopoDS_Edge E) -> Standard_Boolean

        Returns Standard_True if the Vertex  <V> has a new
        parameter on the  edge <E>. In  this case,  <P> is
        the parameter,    <Tol>  the     new    tolerance.
        Otherwise, returns Standard_False, and <P>,  <Tol>
        are not significant.

        :type V: OCC.wrapper.TopoDS.TopoDS_Vertex
        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :type P: float
        :type Tol: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepTools.Handle_BRepTools_GTrsfModification_NewParameter(self, *args)


    def Continuity(self, *args):
        """
        Continuity(Handle_BRepTools_GTrsfModification self, TopoDS_Edge E, TopoDS_Face F1, TopoDS_Face F2, TopoDS_Edge NewE, TopoDS_Face NewF1, TopoDS_Face NewF2) -> GeomAbs_Shape

        Returns the  continuity of  <NewE> between <NewF1>
        and <NewF2>.

        <NewE> is the new  edge created from <E>.  <NewF1>
        (resp. <NewF2>) is the new  face created from <F1>
        (resp. <F2>).

        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :type F1: OCC.wrapper.TopoDS.TopoDS_Face
        :type F2: OCC.wrapper.TopoDS.TopoDS_Face
        :type NewE: OCC.wrapper.TopoDS.TopoDS_Edge
        :type NewF1: OCC.wrapper.TopoDS.TopoDS_Face
        :type NewF2: OCC.wrapper.TopoDS.TopoDS_Face
        :rtype: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _BRepTools.Handle_BRepTools_GTrsfModification_Continuity(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_BRepTools_GTrsfModification self) -> char const *

        :rtype: const char *

        """
        return _BRepTools.Handle_BRepTools_GTrsfModification_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _BRepTools.Handle_BRepTools_GTrsfModification_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _BRepTools.Handle_BRepTools_GTrsfModification_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def NewTriangulation(self, *args):
        """
        NewTriangulation(Handle_BRepTools_GTrsfModification self, TopoDS_Face F, Handle_Poly_Triangulation T) -> Standard_Boolean

        Returns true if the face has been modified according to changed triangulation.
        If the face has been modified:
        - T is a new triangulation on the face

        :type F: OCC.wrapper.TopoDS.TopoDS_Face
        :type T: OCC.wrapper.Poly.Handle_Poly_Triangulation
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepTools.Handle_BRepTools_GTrsfModification_NewTriangulation(self, *args)


    def NewPolygon(self, *args):
        """
        NewPolygon(Handle_BRepTools_GTrsfModification self, TopoDS_Edge E, Handle_Poly_Polygon3D P) -> Standard_Boolean

        Returns true if the edge has been modified according to changed polygon.
        If the edge has been modified:
        - P is a new polygon

        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :type P: OCC.wrapper.Poly.Handle_Poly_Polygon3D
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepTools.Handle_BRepTools_GTrsfModification_NewPolygon(self, *args)


    def NewPolygonOnTriangulation(self, *args):
        """
        NewPolygonOnTriangulation(Handle_BRepTools_GTrsfModification self, TopoDS_Edge E, TopoDS_Face F, Handle_Poly_PolygonOnTriangulation P) -> Standard_Boolean

        Returns true if the edge has been modified according to changed polygon on triangulation.
        If the edge has been modified:
        - P is a new polygon on triangulation

        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :type F: OCC.wrapper.TopoDS.TopoDS_Face
        :type P: OCC.wrapper.Poly.Handle_Poly_PolygonOnTriangulation
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepTools.Handle_BRepTools_GTrsfModification_NewPolygonOnTriangulation(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_BRepTools_GTrsfModification self)

        Memory deallocator for transient classes


        """
        return _BRepTools.Handle_BRepTools_GTrsfModification_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_BRepTools_GTrsfModification self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_BRepTools_GTrsfModification self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepTools.Handle_BRepTools_GTrsfModification_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_BRepTools_GTrsfModification self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_BRepTools_GTrsfModification self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepTools.Handle_BRepTools_GTrsfModification_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_BRepTools_GTrsfModification self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _BRepTools.Handle_BRepTools_GTrsfModification_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_BRepTools_GTrsfModification self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepTools.Handle_BRepTools_GTrsfModification_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_BRepTools_GTrsfModification self)

        Increments the reference counter of this object


        """
        return _BRepTools.Handle_BRepTools_GTrsfModification_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_BRepTools_GTrsfModification self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepTools.Handle_BRepTools_GTrsfModification_DecrementRefCounter(self, *args)

Handle_BRepTools_GTrsfModification_swigregister = _BRepTools.Handle_BRepTools_GTrsfModification_swigregister
Handle_BRepTools_GTrsfModification_swigregister(Handle_BRepTools_GTrsfModification)

def Handle_BRepTools_GTrsfModification_DownCast(thing):
    return _BRepTools.Handle_BRepTools_GTrsfModification_DownCast(thing)
Handle_BRepTools_GTrsfModification_DownCast = _BRepTools.Handle_BRepTools_GTrsfModification_DownCast

class BRepTools_ShapeSet(TopTools.TopTools_ShapeSet):
    """
    Contains a Shape and all  its subshapes, locations
    and geometries.

    The topology is inherited from TopTools.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BRepTools_ShapeSet self, Standard_Boolean const isWithTriangles) -> BRepTools_ShapeSet
        __init__(BRepTools_ShapeSet self, BRep_Builder B, Standard_Boolean const isWithTriangles) -> BRepTools_ShapeSet

        Builds an empty ShapeSet.
        Parameter <isWithTriangles> is added for XML Persistence

        :type B: OCC.wrapper.BRep.BRep_Builder
        :type isWithTriangles: bool

        """
        this = _BRepTools.new_BRepTools_ShapeSet(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Clear(self, *args):
        """
        Clear(BRepTools_ShapeSet self)

        Clears the content of the set.


        """
        return _BRepTools.BRepTools_ShapeSet_Clear(self, *args)


    def AddGeometry(self, *args):
        """
        AddGeometry(BRepTools_ShapeSet self, TopoDS_Shape S)

        Stores the goemetry of <S>.

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _BRepTools.BRepTools_ShapeSet_AddGeometry(self, *args)


    def DumpGeometry(self, *args):
        """
        DumpGeometry(BRepTools_ShapeSet self, Standard_OStream & OS)
        DumpGeometry(BRepTools_ShapeSet self, TopoDS_Shape S, Standard_OStream & OS)

        Dumps the geometry of <S> on the stream <OS>.

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :type OS: OCC.wrapper.Standard.Standard_OStream

        """
        return _BRepTools.BRepTools_ShapeSet_DumpGeometry(self, *args)


    def WriteGeometry(self, *args):
        """
        WriteGeometry(BRepTools_ShapeSet self, Standard_OStream & OS)
        WriteGeometry(BRepTools_ShapeSet self, TopoDS_Shape S, Standard_OStream & OS)

        Writes the geometry of <S>  on the stream <OS> in a
        format that can be read back by Read.

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :type OS: OCC.wrapper.Standard.Standard_OStream

        """
        return _BRepTools.BRepTools_ShapeSet_WriteGeometry(self, *args)


    def ReadGeometry(self, *args):
        """
        ReadGeometry(BRepTools_ShapeSet self, Standard_IStream & IS)
        ReadGeometry(BRepTools_ShapeSet self, TopAbs_ShapeEnum const T, Standard_IStream & IS, TopoDS_Shape S)

        Reads the geometry of a shape of type <T> from the
        stream <IS> and returns it in <S>.

        :type T: OCC.wrapper.TopAbs.TopAbs_ShapeEnum
        :type IS: OCC.wrapper.Standard.Standard_IStream
        :type S: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _BRepTools.BRepTools_ShapeSet_ReadGeometry(self, *args)


    def AddShapes(self, *args):
        """
        AddShapes(BRepTools_ShapeSet self, TopoDS_Shape S1, TopoDS_Shape S2)

        Inserts  the shape <S2> in  the  shape <S1>.  This
        method must be   redefined  to  use   the  correct
        builder.

        :type S1: OCC.wrapper.TopoDS.TopoDS_Shape
        :type S2: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _BRepTools.BRepTools_ShapeSet_AddShapes(self, *args)


    def Check(self, *args):
        """
        Check(BRepTools_ShapeSet self, TopAbs_ShapeEnum const T, TopoDS_Shape S)

        :type T: OCC.wrapper.TopAbs.TopAbs_ShapeEnum
        :type S: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _BRepTools.BRepTools_ShapeSet_Check(self, *args)


    def ReadPolygon3D(self, *args):
        """
        ReadPolygon3D(BRepTools_ShapeSet self, Standard_IStream & IS)

        Reads the 3d polygons  of me
        from the  stream  <IS>.

        :type IS: OCC.wrapper.Standard.Standard_IStream

        """
        return _BRepTools.BRepTools_ShapeSet_ReadPolygon3D(self, *args)


    def WritePolygon3D(self, *args):
        """
        WritePolygon3D(BRepTools_ShapeSet self, Standard_OStream & OS, Standard_Boolean const Compact)

        Writes the 3d polygons
        on the stream <OS> in a format that can
        be read back by Read.

        :type OS: OCC.wrapper.Standard.Standard_OStream
        :type Compact: bool

        """
        return _BRepTools.BRepTools_ShapeSet_WritePolygon3D(self, *args)


    def DumpPolygon3D(self, *args):
        """
        DumpPolygon3D(BRepTools_ShapeSet self, Standard_OStream & OS)

        Dumps the 3d polygons
        on the stream <OS>.

        :type OS: OCC.wrapper.Standard.Standard_OStream

        """
        return _BRepTools.BRepTools_ShapeSet_DumpPolygon3D(self, *args)


    def ReadTriangulation(self, *args):
        """
        ReadTriangulation(BRepTools_ShapeSet self, Standard_IStream & IS)

        Reads the triangulation of me
        from the  stream  <IS>.

        :type IS: OCC.wrapper.Standard.Standard_IStream

        """
        return _BRepTools.BRepTools_ShapeSet_ReadTriangulation(self, *args)


    def WriteTriangulation(self, *args):
        """
        WriteTriangulation(BRepTools_ShapeSet self, Standard_OStream & OS, Standard_Boolean const Compact)

        Writes the triangulation
        on the stream <OS> in a format that can
        be read back by Read.

        :type OS: OCC.wrapper.Standard.Standard_OStream
        :type Compact: bool

        """
        return _BRepTools.BRepTools_ShapeSet_WriteTriangulation(self, *args)


    def DumpTriangulation(self, *args):
        """
        DumpTriangulation(BRepTools_ShapeSet self, Standard_OStream & OS)

        Dumps the triangulation
        on the stream <OS>.

        :type OS: OCC.wrapper.Standard.Standard_OStream

        """
        return _BRepTools.BRepTools_ShapeSet_DumpTriangulation(self, *args)


    def ReadPolygonOnTriangulation(self, *args):
        """
        ReadPolygonOnTriangulation(BRepTools_ShapeSet self, Standard_IStream & IS)

        Reads the polygons on triangulation of me
        from the  stream  <IS>.

        :type IS: OCC.wrapper.Standard.Standard_IStream

        """
        return _BRepTools.BRepTools_ShapeSet_ReadPolygonOnTriangulation(self, *args)


    def WritePolygonOnTriangulation(self, *args):
        """
        WritePolygonOnTriangulation(BRepTools_ShapeSet self, Standard_OStream & OS, Standard_Boolean const Compact)

        Writes the polygons on triangulation
        on the stream <OS> in a format that can
        be read back by Read.

        :type OS: OCC.wrapper.Standard.Standard_OStream
        :type Compact: bool

        """
        return _BRepTools.BRepTools_ShapeSet_WritePolygonOnTriangulation(self, *args)


    def DumpPolygonOnTriangulation(self, *args):
        """
        DumpPolygonOnTriangulation(BRepTools_ShapeSet self, Standard_OStream & OS)

        Dumps the polygons on triangulation
        on the stream <OS>.

        :type OS: OCC.wrapper.Standard.Standard_OStream

        """
        return _BRepTools.BRepTools_ShapeSet_DumpPolygonOnTriangulation(self, *args)

    __swig_destroy__ = _BRepTools.delete_BRepTools_ShapeSet
BRepTools_ShapeSet_swigregister = _BRepTools.BRepTools_ShapeSet_swigregister
BRepTools_ShapeSet_swigregister(BRepTools_ShapeSet)

class NCollection_DataMap_TopoDS_Shape_TColgp_SequenceOfPnt2d_TopTools_ShapeMapHasher(NCollection.NCollection_BaseMap):
    """
    Purpose:     The DataMap is a Map to store keys with associated
    Items. See Map  from NCollection for  a discussion
    about the number of buckets.

    The DataMap can be seen as an extended array where
    the Keys  are the   indices.  For this reason  the
    operator () is defined on DataMap to fetch an Item
    from a Key. So the following syntax can be used :

    anItem = aMap(aKey);
    aMap(aKey) = anItem;

    This analogy has its  limit.   aMap(aKey) = anItem
    can  be done only  if aKey was previously bound to
    an item in the map.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_DataMap_TopoDS_Shape_TColgp_SequenceOfPnt2d_TopTools_ShapeMapHasher self) -> NCollection_DataMap< TopoDS_Shape,TColgp_SequenceOfPnt2d,TopTools_ShapeMapHasher >::iterator

        Returns an iterator pointing to the first element in the map.

        :rtype: iterator

        """
        return _BRepTools.NCollection_DataMap_TopoDS_Shape_TColgp_SequenceOfPnt2d_TopTools_ShapeMapHasher_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_DataMap_TopoDS_Shape_TColgp_SequenceOfPnt2d_TopTools_ShapeMapHasher self) -> NCollection_DataMap< TopoDS_Shape,TColgp_SequenceOfPnt2d,TopTools_ShapeMapHasher >::iterator

        Returns an iterator referring to the past-the-end element in the map.

        :rtype: iterator

        """
        return _BRepTools.NCollection_DataMap_TopoDS_Shape_TColgp_SequenceOfPnt2d_TopTools_ShapeMapHasher_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_DataMap_TopoDS_Shape_TColgp_SequenceOfPnt2d_TopTools_ShapeMapHasher self) -> NCollection_DataMap< TopoDS_Shape,TColgp_SequenceOfPnt2d,TopTools_ShapeMapHasher >::const_iterator

        Returns a const iterator pointing to the first element in the map.

        :rtype: const_iterator

        """
        return _BRepTools.NCollection_DataMap_TopoDS_Shape_TColgp_SequenceOfPnt2d_TopTools_ShapeMapHasher_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_DataMap_TopoDS_Shape_TColgp_SequenceOfPnt2d_TopTools_ShapeMapHasher self) -> NCollection_DataMap< TopoDS_Shape,TColgp_SequenceOfPnt2d,TopTools_ShapeMapHasher >::const_iterator

        Returns a const iterator referring to the past-the-end element in the map.

        :rtype: const_iterator

        """
        return _BRepTools.NCollection_DataMap_TopoDS_Shape_TColgp_SequenceOfPnt2d_TopTools_ShapeMapHasher_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     The DataMap is a Map to store keys with associated
        Items. See Map  from NCollection for  a discussion
        about the number of buckets.

        The DataMap can be seen as an extended array where
        the Keys  are the   indices.  For this reason  the
        operator () is defined on DataMap to fetch an Item
        from a Key. So the following syntax can be used :

        anItem = aMap(aKey);
        aMap(aKey) = anItem;

        This analogy has its  limit.   aMap(aKey) = anItem
        can  be done only  if aKey was previously bound to
        an item in the map.
        """
        this = _BRepTools.new_NCollection_DataMap_TopoDS_Shape_TColgp_SequenceOfPnt2d_TopTools_ShapeMapHasher(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Exchange(self, *args):
        """
        Exchange(NCollection_DataMap_TopoDS_Shape_TColgp_SequenceOfPnt2d_TopTools_ShapeMapHasher self, NCollection_DataMap_TopoDS_Shape_TColgp_SequenceOfPnt2d_TopTools_ShapeMapHasher theOther)

        Exchange the content of two maps without re-allocations.
        Notice that allocators will be swapped as well!

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _BRepTools.NCollection_DataMap_TopoDS_Shape_TColgp_SequenceOfPnt2d_TopTools_ShapeMapHasher_Exchange(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_DataMap_TopoDS_Shape_TColgp_SequenceOfPnt2d_TopTools_ShapeMapHasher self, NCollection_DataMap_TopoDS_Shape_TColgp_SequenceOfPnt2d_TopTools_ShapeMapHasher theOther) -> NCollection_DataMap_TopoDS_Shape_TColgp_SequenceOfPnt2d_TopTools_ShapeMapHasher

        Assignment.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _BRepTools.NCollection_DataMap_TopoDS_Shape_TColgp_SequenceOfPnt2d_TopTools_ShapeMapHasher_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_DataMap_TopoDS_Shape_TColgp_SequenceOfPnt2d_TopTools_ShapeMapHasher self, NCollection_DataMap_TopoDS_Shape_TColgp_SequenceOfPnt2d_TopTools_ShapeMapHasher theOther) -> NCollection_DataMap_TopoDS_Shape_TColgp_SequenceOfPnt2d_TopTools_ShapeMapHasher

        Assignment operator

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _BRepTools.NCollection_DataMap_TopoDS_Shape_TColgp_SequenceOfPnt2d_TopTools_ShapeMapHasher_assign(self, *args)


    def ReSize(self, *args):
        """
        ReSize(NCollection_DataMap_TopoDS_Shape_TColgp_SequenceOfPnt2d_TopTools_ShapeMapHasher self, Standard_Integer const N)

        ReSize

        :type N: int

        """
        return _BRepTools.NCollection_DataMap_TopoDS_Shape_TColgp_SequenceOfPnt2d_TopTools_ShapeMapHasher_ReSize(self, *args)


    def Bind(self, *args):
        """
        Bind(NCollection_DataMap_TopoDS_Shape_TColgp_SequenceOfPnt2d_TopTools_ShapeMapHasher self, TopoDS_Shape theKey, NCollection_Sequence_gp_Pnt2d theItem) -> Standard_Boolean

        Bind binds Item to Key in map.
        @param theKey  key to add/update
        @param theItem new item; overrides value previously bound to the key, if any
        @return Standard_True if Key was not bound already

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepTools.NCollection_DataMap_TopoDS_Shape_TColgp_SequenceOfPnt2d_TopTools_ShapeMapHasher_Bind(self, *args)


    def Bound(self, *args):
        """
        Bound(NCollection_DataMap_TopoDS_Shape_TColgp_SequenceOfPnt2d_TopTools_ShapeMapHasher self, TopoDS_Shape theKey, NCollection_Sequence_gp_Pnt2d theItem) -> NCollection_Sequence_gp_Pnt2d

        Bound binds Item to Key in map. Returns modifiable Item 

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: TheItemType *

        """
        return _BRepTools.NCollection_DataMap_TopoDS_Shape_TColgp_SequenceOfPnt2d_TopTools_ShapeMapHasher_Bound(self, *args)


    def IsBound(self, *args):
        """
        IsBound(NCollection_DataMap_TopoDS_Shape_TColgp_SequenceOfPnt2d_TopTools_ShapeMapHasher self, TopoDS_Shape theKey) -> Standard_Boolean

        IsBound

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepTools.NCollection_DataMap_TopoDS_Shape_TColgp_SequenceOfPnt2d_TopTools_ShapeMapHasher_IsBound(self, *args)


    def UnBind(self, *args):
        """
        UnBind(NCollection_DataMap_TopoDS_Shape_TColgp_SequenceOfPnt2d_TopTools_ShapeMapHasher self, TopoDS_Shape theKey) -> Standard_Boolean

        UnBind removes Item Key pair from map

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepTools.NCollection_DataMap_TopoDS_Shape_TColgp_SequenceOfPnt2d_TopTools_ShapeMapHasher_UnBind(self, *args)


    def Seek(self, *args):
        """
        Seek(NCollection_DataMap_TopoDS_Shape_TColgp_SequenceOfPnt2d_TopTools_ShapeMapHasher self, TopoDS_Shape theKey) -> NCollection_Sequence_gp_Pnt2d

        Seek returns pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: const TheItemType *

        """
        return _BRepTools.NCollection_DataMap_TopoDS_Shape_TColgp_SequenceOfPnt2d_TopTools_ShapeMapHasher_Seek(self, *args)


    def Find(self, *args):
        """
        Find returns the Item for Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _BRepTools.NCollection_DataMap_TopoDS_Shape_TColgp_SequenceOfPnt2d_TopTools_ShapeMapHasher_Find(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeSeek(self, *args):
        """
        ChangeSeek(NCollection_DataMap_TopoDS_Shape_TColgp_SequenceOfPnt2d_TopTools_ShapeMapHasher self, TopoDS_Shape theKey) -> NCollection_Sequence_gp_Pnt2d

        ChangeSeek returns modifiable pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: TheItemType *

        """
        return _BRepTools.NCollection_DataMap_TopoDS_Shape_TColgp_SequenceOfPnt2d_TopTools_ShapeMapHasher_ChangeSeek(self, *args)


    def ChangeFind(self, *args):
        """
        ChangeFind(NCollection_DataMap_TopoDS_Shape_TColgp_SequenceOfPnt2d_TopTools_ShapeMapHasher self, TopoDS_Shape theKey) -> NCollection_Sequence_gp_Pnt2d

        ChangeFind returns mofifiable Item by Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: TheItemType &

        """
        return _BRepTools.NCollection_DataMap_TopoDS_Shape_TColgp_SequenceOfPnt2d_TopTools_ShapeMapHasher_ChangeFind(self, *args)


    def __call__(self, *args):
        """
        operator ()

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _BRepTools.NCollection_DataMap_TopoDS_Shape_TColgp_SequenceOfPnt2d_TopTools_ShapeMapHasher___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Clear(self, *args):
        """
        Clear(NCollection_DataMap_TopoDS_Shape_TColgp_SequenceOfPnt2d_TopTools_ShapeMapHasher self, Standard_Boolean const doReleaseMemory)
        Clear(NCollection_DataMap_TopoDS_Shape_TColgp_SequenceOfPnt2d_TopTools_ShapeMapHasher self, Handle_NCollection_BaseAllocator theAllocator)

        Clear data and reset allocator

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _BRepTools.NCollection_DataMap_TopoDS_Shape_TColgp_SequenceOfPnt2d_TopTools_ShapeMapHasher_Clear(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_DataMap_TopoDS_Shape_TColgp_SequenceOfPnt2d_TopTools_ShapeMapHasher self) -> Standard_Integer

        Size

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepTools.NCollection_DataMap_TopoDS_Shape_TColgp_SequenceOfPnt2d_TopTools_ShapeMapHasher_Size(self, *args)


    def __iter__(self):
        return _BRepTools.NCollection_DataMap_TopoDS_Shape_TColgp_SequenceOfPnt2d_TopTools_ShapeMapHasher___iter__(self)
    __swig_destroy__ = _BRepTools.delete_NCollection_DataMap_TopoDS_Shape_TColgp_SequenceOfPnt2d_TopTools_ShapeMapHasher
NCollection_DataMap_TopoDS_Shape_TColgp_SequenceOfPnt2d_TopTools_ShapeMapHasher_swigregister = _BRepTools.NCollection_DataMap_TopoDS_Shape_TColgp_SequenceOfPnt2d_TopTools_ShapeMapHasher_swigregister
NCollection_DataMap_TopoDS_Shape_TColgp_SequenceOfPnt2d_TopTools_ShapeMapHasher_swigregister(NCollection_DataMap_TopoDS_Shape_TColgp_SequenceOfPnt2d_TopTools_ShapeMapHasher)

class NCollection_DataMap_TopoDS_Shape_TColgp_SequenceOfPnt2d_TopTools_ShapeMapHasher_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _BRepTools.new_NCollection_DataMap_TopoDS_Shape_TColgp_SequenceOfPnt2d_TopTools_ShapeMapHasher_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _BRepTools.delete_NCollection_DataMap_TopoDS_Shape_TColgp_SequenceOfPnt2d_TopTools_ShapeMapHasher_IteratorHelper

    def __next__(self):
        return _BRepTools.NCollection_DataMap_TopoDS_Shape_TColgp_SequenceOfPnt2d_TopTools_ShapeMapHasher_IteratorHelper___next__(self)
NCollection_DataMap_TopoDS_Shape_TColgp_SequenceOfPnt2d_TopTools_ShapeMapHasher_IteratorHelper_swigregister = _BRepTools.NCollection_DataMap_TopoDS_Shape_TColgp_SequenceOfPnt2d_TopTools_ShapeMapHasher_IteratorHelper_swigregister
NCollection_DataMap_TopoDS_Shape_TColgp_SequenceOfPnt2d_TopTools_ShapeMapHasher_IteratorHelper_swigregister(NCollection_DataMap_TopoDS_Shape_TColgp_SequenceOfPnt2d_TopTools_ShapeMapHasher_IteratorHelper)


try:
	BRepTools_MapOfVertexPnt2d = NCollection_DataMap_TopoDS_Shape_TColgp_SequenceOfPnt2d_TopTools_ShapeMapHasher
except NameError:
	pass # does not exist, probably ignored




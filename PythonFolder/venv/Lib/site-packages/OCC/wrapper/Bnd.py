# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_Bnd')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_Bnd')
    _Bnd = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_Bnd', [dirname(__file__)])
        except ImportError:
            import _Bnd
            return _Bnd
        try:
            _mod = imp.load_module('_Bnd', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _Bnd = swig_import_helper()
    del swig_import_helper
else:
    import _Bnd
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


class SwigPyIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _Bnd.delete_SwigPyIterator

    def value(self):
        return _Bnd.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _Bnd.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _Bnd.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _Bnd.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _Bnd.SwigPyIterator_equal(self, x)

    def copy(self):
        return _Bnd.SwigPyIterator_copy(self)

    def next(self):
        return _Bnd.SwigPyIterator_next(self)

    def __next__(self):
        return _Bnd.SwigPyIterator___next__(self)

    def previous(self):
        return _Bnd.SwigPyIterator_previous(self)

    def advance(self, n):
        return _Bnd.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _Bnd.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _Bnd.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _Bnd.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _Bnd.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _Bnd.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _Bnd.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self
SwigPyIterator_swigregister = _Bnd.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

class NCollection_CellFilter_InspectorXYZ(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _Bnd.NCollection_CellFilter_InspectorXYZ_Dimension
    Coord = staticmethod(_Bnd.NCollection_CellFilter_InspectorXYZ_Coord)

    def Shift(self, thePnt, theTol):
        return _Bnd.NCollection_CellFilter_InspectorXYZ_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _Bnd.new_NCollection_CellFilter_InspectorXYZ()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _Bnd.delete_NCollection_CellFilter_InspectorXYZ
NCollection_CellFilter_InspectorXYZ_swigregister = _Bnd.NCollection_CellFilter_InspectorXYZ_swigregister
NCollection_CellFilter_InspectorXYZ_swigregister(NCollection_CellFilter_InspectorXYZ)

def NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt):
    return _Bnd.NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt)
NCollection_CellFilter_InspectorXYZ_Coord = _Bnd.NCollection_CellFilter_InspectorXYZ_Coord

class NCollection_CellFilter_InspectorXY(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _Bnd.NCollection_CellFilter_InspectorXY_Dimension
    Coord = staticmethod(_Bnd.NCollection_CellFilter_InspectorXY_Coord)

    def Shift(self, thePnt, theTol):
        return _Bnd.NCollection_CellFilter_InspectorXY_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _Bnd.new_NCollection_CellFilter_InspectorXY()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _Bnd.delete_NCollection_CellFilter_InspectorXY
NCollection_CellFilter_InspectorXY_swigregister = _Bnd.NCollection_CellFilter_InspectorXY_swigregister
NCollection_CellFilter_InspectorXY_swigregister(NCollection_CellFilter_InspectorXY)

def NCollection_CellFilter_InspectorXY_Coord(i, thePnt):
    return _Bnd.NCollection_CellFilter_InspectorXY_Coord(i, thePnt)
NCollection_CellFilter_InspectorXY_Coord = _Bnd.NCollection_CellFilter_InspectorXY_Coord


def ptr_to_number(item):
    return _Bnd.ptr_to_number(item)
ptr_to_number = _Bnd.ptr_to_number

def HashCode(*args):
    return _Bnd.HashCode(*args)
HashCode = _Bnd.HashCode

def ptr_equal(a, b):
    return _Bnd.ptr_equal(a, b)
ptr_equal = _Bnd.ptr_equal
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import NCollection
else:
    import NCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Standard
else:
    import Standard
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import gp
else:
    import gp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColStd
else:
    import TColStd
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TCollection
else:
    import TCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColgp
else:
    import TColgp
del _swig_python_version_info
class Bnd_Box(object):
    """
    Describes a bounding box in 3D space.
    A bounding box is parallel to the axes of the coordinates
    system. If it is finite, it is defined by the three intervals:
    -   [ Xmin,Xmax ],
    -   [ Ymin,Ymax ],
    -   [ Zmin,Zmax ].
    A bounding box may be infinite (i.e. open) in one or more
    directions. It is said to be:
    -   OpenXmin if it is infinite on the negative side of the   "X Direction";
    -   OpenXmax if it is infinite on the positive side of the "X Direction";
    -   OpenYmin if it is infinite on the negative side of the   "Y Direction";
    -   OpenYmax if it is infinite on the positive side of the "Y Direction";
    -   OpenZmin if it is infinite on the negative side of the   "Z Direction";
    -   OpenZmax if it is infinite on the positive side of the "Z Direction";
    -   WholeSpace if it is infinite in all six directions. In this
    case, any point of the space is inside the box;
    -   Void if it is empty. In this case, there is no point included in the box.
    A bounding box is defined by:
    -   six bounds (Xmin, Xmax, Ymin, Ymax, Zmin and
    Zmax) which limit the bounding box if it is finite,
    -   eight flags (OpenXmin, OpenXmax, OpenYmin,
    OpenYmax, OpenZmin, OpenZmax,
    WholeSpace and Void) which describe the
    bounding box if it is infinite or empty, and
    -   a gap, which is included on both sides in any direction
    when consulting the finite bounds of the box.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Bnd_Box self) -> Bnd_Box

        Creates an empty Box.
        The constructed box is qualified Void. Its gap is null.


        """
        this = _Bnd.new_Bnd_Box(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def SetWhole(self, *args):
        """
        SetWhole(Bnd_Box self)

        Sets this bounding box so that it  covers the whole of 3D space.
        It is infinitely  long in all directions.


        """
        return _Bnd.Bnd_Box_SetWhole(self, *args)


    def SetVoid(self, *args):
        """
        SetVoid(Bnd_Box self)

        Sets this bounding box so that it is empty. All points are outside a void box.


        """
        return _Bnd.Bnd_Box_SetVoid(self, *args)


    def Set(self, *args):
        """
        Set(Bnd_Box self, gp_Pnt P)
        Set(Bnd_Box self, gp_Pnt P, gp_Dir D)

        Sets this bounding box so that it bounds
        the half-line defined by point P and direction D, i.e. all
        points M defined by M=P+u*D, where u is greater than
        or equal to 0, are inside the bounding volume. This
        involves first setting this box to be void and then adding   the half-line.

        :type P: OCC.wrapper.gp.gp_Pnt
        :type D: OCC.wrapper.gp.gp_Dir

        """
        return _Bnd.Bnd_Box_Set(self, *args)


    def Update(self, *args):
        """
        Update(Bnd_Box self, Standard_Real const aXmin, Standard_Real const aYmin, Standard_Real const aZmin, Standard_Real const aXmax, Standard_Real const aYmax, Standard_Real const aZmax)
        Update(Bnd_Box self, Standard_Real const X, Standard_Real const Y, Standard_Real const Z)

        Adds a point of coordinates (X,Y,Z) to this bounding box.

        :type X: float
        :type Y: float
        :type Z: float

        """
        return _Bnd.Bnd_Box_Update(self, *args)


    def GetGap(self, *args):
        """
        GetGap(Bnd_Box self) -> Standard_Real

        Returns the gap of this bounding box.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Bnd.Bnd_Box_GetGap(self, *args)


    def SetGap(self, *args):
        """
        SetGap(Bnd_Box self, Standard_Real const Tol)

        Set the gap of this bounding box to abs(Tol).

        :type Tol: float

        """
        return _Bnd.Bnd_Box_SetGap(self, *args)


    def Enlarge(self, *args):
        """
        Enlarge(Bnd_Box self, Standard_Real const Tol)

        Enlarges the      box    with    a   tolerance   value.
        (minvalues-Abs(<tol>) and maxvalues+Abs(<tol>))
        This means that the minimum values of its X, Y and Z
        intervals of definition, when they are finite, are reduced by
        the absolute value of Tol, while the maximum values are
        increased by the same amount.

        :type Tol: float

        """
        return _Bnd.Bnd_Box_Enlarge(self, *args)


    def Get(self, *args):
        """
        Get(Bnd_Box self)

        Returns the bounds of this bounding box. The gap is included.
        If this bounding box is infinite (i.e. "open"), returned values
        may be equal to +/- Precision::Infinite().
        Standard_ConstructionError exception will be thrown if the box is void.
        if IsVoid()

        :type theXmin: float
        :type theYmin: float
        :type theZmin: float
        :type theXmax: float
        :type theYmax: float
        :type theZmax: float

        """
        return _Bnd.Bnd_Box_Get(self, *args)


    def CornerMin(self, *args):
        """
        CornerMin(Bnd_Box self) -> gp_Pnt

        Returns the lower corner of this bounding box. The gap is included.
        If this bounding box is infinite (i.e. "open"), returned values
        may be equal to +/- Precision::Infinite().
        Standard_ConstructionError exception will be thrown if the box is void.
        if IsVoid()

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _Bnd.Bnd_Box_CornerMin(self, *args)


    def CornerMax(self, *args):
        """
        CornerMax(Bnd_Box self) -> gp_Pnt

        Returns the upper corner of this bounding box. The gap is included.
        If this bounding box is infinite (i.e. "open"), returned values
        may be equal to +/- Precision::Infinite().
        Standard_ConstructionError exception will be thrown if the box is void.
        if IsVoid()

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _Bnd.Bnd_Box_CornerMax(self, *args)


    def OpenXmin(self, *args):
        """
        OpenXmin(Bnd_Box self)

        The   Box will be   infinitely   long  in the Xmin
        direction.


        """
        return _Bnd.Bnd_Box_OpenXmin(self, *args)


    def OpenXmax(self, *args):
        """
        OpenXmax(Bnd_Box self)

        The   Box will be   infinitely   long  in the Xmax
        direction.


        """
        return _Bnd.Bnd_Box_OpenXmax(self, *args)


    def OpenYmin(self, *args):
        """
        OpenYmin(Bnd_Box self)

        The   Box will be   infinitely   long  in the Ymin
        direction.


        """
        return _Bnd.Bnd_Box_OpenYmin(self, *args)


    def OpenYmax(self, *args):
        """
        OpenYmax(Bnd_Box self)

        The   Box will be   infinitely   long  in the Ymax
        direction.


        """
        return _Bnd.Bnd_Box_OpenYmax(self, *args)


    def OpenZmin(self, *args):
        """
        OpenZmin(Bnd_Box self)

        The   Box will be   infinitely   long  in the Zmin
        direction.


        """
        return _Bnd.Bnd_Box_OpenZmin(self, *args)


    def OpenZmax(self, *args):
        """
        OpenZmax(Bnd_Box self)

        The   Box will be   infinitely   long  in the Zmax
        direction.


        """
        return _Bnd.Bnd_Box_OpenZmax(self, *args)


    def IsOpenXmin(self, *args):
        """
        IsOpenXmin(Bnd_Box self) -> Standard_Boolean

        Returns true if this bounding box is open in the  Xmin direction.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Bnd.Bnd_Box_IsOpenXmin(self, *args)


    def IsOpenXmax(self, *args):
        """
        IsOpenXmax(Bnd_Box self) -> Standard_Boolean

        Returns true if this bounding box is open in the  Xmax direction.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Bnd.Bnd_Box_IsOpenXmax(self, *args)


    def IsOpenYmin(self, *args):
        """
        IsOpenYmin(Bnd_Box self) -> Standard_Boolean

        Returns true if this bounding box is open in the  Ymix direction.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Bnd.Bnd_Box_IsOpenYmin(self, *args)


    def IsOpenYmax(self, *args):
        """
        IsOpenYmax(Bnd_Box self) -> Standard_Boolean

        Returns true if this bounding box is open in the  Ymax direction.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Bnd.Bnd_Box_IsOpenYmax(self, *args)


    def IsOpenZmin(self, *args):
        """
        IsOpenZmin(Bnd_Box self) -> Standard_Boolean

        Returns true if this bounding box is open in the  Zmin direction.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Bnd.Bnd_Box_IsOpenZmin(self, *args)


    def IsOpenZmax(self, *args):
        """
        IsOpenZmax(Bnd_Box self) -> Standard_Boolean

        Returns true if this bounding box is open in the  Zmax  direction.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Bnd.Bnd_Box_IsOpenZmax(self, *args)


    def IsWhole(self, *args):
        """
        IsWhole(Bnd_Box self) -> Standard_Boolean

        Returns true if this bounding box is infinite in all 6 directions (WholeSpace flag).

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Bnd.Bnd_Box_IsWhole(self, *args)


    def IsVoid(self, *args):
        """
        IsVoid(Bnd_Box self) -> Standard_Boolean

        Returns true if this bounding box is empty (Void flag).

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Bnd.Bnd_Box_IsVoid(self, *args)


    def IsXThin(self, *args):
        """
        IsXThin(Bnd_Box self, Standard_Real const tol) -> Standard_Boolean

        true if xmax-xmin < tol.

        :type tol: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Bnd.Bnd_Box_IsXThin(self, *args)


    def IsYThin(self, *args):
        """
        IsYThin(Bnd_Box self, Standard_Real const tol) -> Standard_Boolean

        true if ymax-ymin < tol.

        :type tol: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Bnd.Bnd_Box_IsYThin(self, *args)


    def IsZThin(self, *args):
        """
        IsZThin(Bnd_Box self, Standard_Real const tol) -> Standard_Boolean

        true if zmax-zmin < tol.

        :type tol: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Bnd.Bnd_Box_IsZThin(self, *args)


    def IsThin(self, *args):
        """
        IsThin(Bnd_Box self, Standard_Real const tol) -> Standard_Boolean

        Returns true if IsXThin, IsYThin and IsZThin are all true,
        i.e. if the box is thin in all three dimensions.

        :type tol: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Bnd.Bnd_Box_IsThin(self, *args)


    def Transformed(self, *args):
        """
        Transformed(Bnd_Box self, gp_Trsf T) -> Bnd_Box

        Returns a bounding box which is the result of applying the
        transformation T to this bounding box.
        Warning
        Applying a geometric transformation (for example, a
        rotation) to a bounding box generally increases its
        dimensions. This is not optimal for algorithms which use it.

        :type T: OCC.wrapper.gp.gp_Trsf
        :rtype: OCC.wrapper.Bnd.Bnd_Box

        """
        return _Bnd.Bnd_Box_Transformed(self, *args)


    def Add(self, *args):
        """
        Add(Bnd_Box self, Bnd_Box Other)
        Add(Bnd_Box self, gp_Pnt P)
        Add(Bnd_Box self, gp_Pnt P, gp_Dir D)
        Add(Bnd_Box self, gp_Dir D)

        Extends the Box  in the given Direction, i.e. adds
        an  half-line. The   box  may become   infinite in
        1,2 or 3 directions.

        :type D: OCC.wrapper.gp.gp_Dir

        """
        return _Bnd.Bnd_Box_Add(self, *args)


    def IsOut(self, *args):
        """
        IsOut(Bnd_Box self, gp_Pnt P) -> Standard_Boolean
        IsOut(Bnd_Box self, gp_Lin L) -> Standard_Boolean
        IsOut(Bnd_Box self, gp_Pln P) -> Standard_Boolean
        IsOut(Bnd_Box self, Bnd_Box Other) -> Standard_Boolean
        IsOut(Bnd_Box self, Bnd_Box Other, gp_Trsf T) -> Standard_Boolean
        IsOut(Bnd_Box self, gp_Trsf T1, Bnd_Box Other, gp_Trsf T2) -> Standard_Boolean
        IsOut(Bnd_Box self, gp_Pnt P1, gp_Pnt P2, gp_Dir D) -> Standard_Boolean

        Returns False  if the flat band lying between two parallel
        lines represented by their reference points <P1>, <P2> and
        direction <D> intersects the box.

        :type P1: OCC.wrapper.gp.gp_Pnt
        :type P2: OCC.wrapper.gp.gp_Pnt
        :type D: OCC.wrapper.gp.gp_Dir
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Bnd.Bnd_Box_IsOut(self, *args)


    def Distance(self, *args):
        """
        Distance(Bnd_Box self, Bnd_Box Other) -> Standard_Real

        Computes the minimum distance between two boxes.

        :type Other: OCC.wrapper.Bnd.Bnd_Box
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Bnd.Bnd_Box_Distance(self, *args)


    def Dump(self, *args):
        """Dump(Bnd_Box self)"""
        return _Bnd.Bnd_Box_Dump(self, *args)


    def SquareExtent(self, *args):
        """
        SquareExtent(Bnd_Box self) -> Standard_Real

        Computes the squared diagonal of me.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Bnd.Bnd_Box_SquareExtent(self, *args)

    __swig_destroy__ = _Bnd.delete_Bnd_Box
Bnd_Box_swigregister = _Bnd.Bnd_Box_swigregister
Bnd_Box_swigregister(Bnd_Box)

class Bnd_Sphere(object):
    """
    This class represents a bounding sphere of a geometric entity
    (triangle, segment of line or whatever else).
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Bnd_Sphere self) -> Bnd_Sphere
        __init__(Bnd_Sphere self, gp_XYZ theCntr, Standard_Real const theRad, Standard_Integer const theU, Standard_Integer const theV) -> Bnd_Sphere

        Constructor of a definite sphere

        :type theCntr: OCC.wrapper.gp.gp_XYZ
        :type theRad: float
        :type theU: int
        :type theV: int

        """
        this = _Bnd.new_Bnd_Sphere(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def U(self, *args):
        """
        U(Bnd_Sphere self) -> Standard_Integer

        Returns the U parameter on shape

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Bnd.Bnd_Sphere_U(self, *args)


    def V(self, *args):
        """
        V(Bnd_Sphere self) -> Standard_Integer

        Returns the V parameter on shape

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Bnd.Bnd_Sphere_V(self, *args)


    def IsValid(self, *args):
        """
        IsValid(Bnd_Sphere self) -> Standard_Boolean

        Returns validity status, indicating that this
        sphere corresponds to a real entity

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Bnd.Bnd_Sphere_IsValid(self, *args)


    def SetValid(self, *args):
        """
        SetValid(Bnd_Sphere self, Standard_Boolean const isValid)

        :type isValid: bool

        """
        return _Bnd.Bnd_Sphere_SetValid(self, *args)


    def Center(self, *args):
        """
        Returns center of sphere object

        :rtype: OCC.wrapper.gp.gp_XYZ

        """
        res = _Bnd.Bnd_Sphere_Center(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Radius(self, *args):
        """
        Radius(Bnd_Sphere self) -> Standard_Real

        Returns the radius value

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Bnd.Bnd_Sphere_Radius(self, *args)


    def Distances(self, *args):
        """
        Distances(Bnd_Sphere self, gp_XYZ theXYZ)

        Calculate and return minimal and maximal distance to sphere.
        NOTE: This function is tightly optimized; any modifications
        may affect performance!

        :type theXYZ: OCC.wrapper.gp.gp_XYZ
        :type theMin: float
        :type theMax: float

        """
        return _Bnd.Bnd_Sphere_Distances(self, *args)


    def SquareDistances(self, *args):
        """
        SquareDistances(Bnd_Sphere self, gp_XYZ theXYZ)

        Calculate and return minimal and maximal distance to sphere.
        NOTE: This function is tightly optimized; any modifications
        may affect performance!

        :type theXYZ: OCC.wrapper.gp.gp_XYZ
        :type theMin: float
        :type theMax: float

        """
        return _Bnd.Bnd_Sphere_SquareDistances(self, *args)


    def Project(self, *args):
        """
        Project(Bnd_Sphere self, gp_XYZ theNode, gp_XYZ theProjNode) -> Standard_Boolean

        Projects a point on entity.
        Returns true if success

        :type theNode: OCC.wrapper.gp.gp_XYZ
        :type theProjNode: OCC.wrapper.gp.gp_XYZ
        :type theDist: float
        :type theInside: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Bnd.Bnd_Sphere_Project(self, *args)


    def Distance(self, *args):
        """
        Distance(Bnd_Sphere self, gp_XYZ theNode) -> Standard_Real

        :type theNode: OCC.wrapper.gp.gp_XYZ
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Bnd.Bnd_Sphere_Distance(self, *args)


    def SquareDistance(self, *args):
        """
        SquareDistance(Bnd_Sphere self, gp_XYZ theNode) -> Standard_Real

        :type theNode: OCC.wrapper.gp.gp_XYZ
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Bnd.Bnd_Sphere_SquareDistance(self, *args)


    def Add(self, *args):
        """
        Add(Bnd_Sphere self, Bnd_Sphere theOther)

        :type theOther: OCC.wrapper.Bnd.Bnd_Sphere

        """
        return _Bnd.Bnd_Sphere_Add(self, *args)


    def IsOut(self, *args):
        """
        IsOut(Bnd_Sphere self, Bnd_Sphere theOther) -> Standard_Boolean
        IsOut(Bnd_Sphere self, gp_XYZ thePnt) -> Standard_Boolean

        :type thePnt: OCC.wrapper.gp.gp_XYZ
        :type theMaxDist: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Bnd.Bnd_Sphere_IsOut(self, *args)


    def SquareExtent(self, *args):
        """
        SquareExtent(Bnd_Sphere self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Bnd.Bnd_Sphere_SquareExtent(self, *args)

    __swig_destroy__ = _Bnd.delete_Bnd_Sphere
Bnd_Sphere_swigregister = _Bnd.Bnd_Sphere_swigregister
Bnd_Sphere_swigregister(Bnd_Sphere)

class Bnd_HArray1OfBox(Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Bnd_HArray1OfBox
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Bnd_HArray1OfBox(self) 
            return h


    def __init__(self, *args):
        """
        __init__(Bnd_HArray1OfBox self, Standard_Integer const theLower, Standard_Integer const theUpper) -> Bnd_HArray1OfBox
        __init__(Bnd_HArray1OfBox self, Standard_Integer const theLower, Standard_Integer const theUpper, Bnd_Box theValue) -> Bnd_HArray1OfBox
        __init__(Bnd_HArray1OfBox self, NCollection_Array1_Bnd_Box theOther) -> Bnd_HArray1OfBox

        :type theOther: OCC.wrapper.Bnd.Bnd_Array1OfBox

        """
        this = _Bnd.new_Bnd_HArray1OfBox(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Array1(self, *args):
        """
        :rtype: OCC.wrapper.Bnd.Bnd_Array1OfBox

        """
        res = _Bnd.Bnd_HArray1OfBox_Array1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeArray1(self, *args):
        """
        ChangeArray1(Bnd_HArray1OfBox self) -> NCollection_Array1_Bnd_Box

        :rtype: OCC.wrapper.Bnd.Bnd_Array1OfBox

        """
        return _Bnd.Bnd_HArray1OfBox_ChangeArray1(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Bnd.Bnd_HArray1OfBox_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Bnd.Bnd_HArray1OfBox_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Bnd.Bnd_HArray1OfBox_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Bnd.delete_Bnd_HArray1OfBox
Bnd_HArray1OfBox_swigregister = _Bnd.Bnd_HArray1OfBox_swigregister
Bnd_HArray1OfBox_swigregister(Bnd_HArray1OfBox)

def Bnd_HArray1OfBox_get_type_name(*args):
    """
    Bnd_HArray1OfBox_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Bnd.Bnd_HArray1OfBox_get_type_name(*args)

def Bnd_HArray1OfBox_get_type_descriptor(*args):
    """
    Bnd_HArray1OfBox_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Bnd.Bnd_HArray1OfBox_get_type_descriptor(*args)

class Bnd_HArray1OfBox2d(Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Bnd_HArray1OfBox2d
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Bnd_HArray1OfBox2d(self) 
            return h


    def __init__(self, *args):
        """
        __init__(Bnd_HArray1OfBox2d self, Standard_Integer const theLower, Standard_Integer const theUpper) -> Bnd_HArray1OfBox2d
        __init__(Bnd_HArray1OfBox2d self, Standard_Integer const theLower, Standard_Integer const theUpper, Bnd_Box2d theValue) -> Bnd_HArray1OfBox2d
        __init__(Bnd_HArray1OfBox2d self, NCollection_Array1_Bnd_Box2d theOther) -> Bnd_HArray1OfBox2d

        :type theOther: OCC.wrapper.Bnd.Bnd_Array1OfBox2d

        """
        this = _Bnd.new_Bnd_HArray1OfBox2d(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Array1(self, *args):
        """
        :rtype: OCC.wrapper.Bnd.Bnd_Array1OfBox2d

        """
        res = _Bnd.Bnd_HArray1OfBox2d_Array1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeArray1(self, *args):
        """
        ChangeArray1(Bnd_HArray1OfBox2d self) -> NCollection_Array1_Bnd_Box2d

        :rtype: OCC.wrapper.Bnd.Bnd_Array1OfBox2d

        """
        return _Bnd.Bnd_HArray1OfBox2d_ChangeArray1(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Bnd.Bnd_HArray1OfBox2d_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Bnd.Bnd_HArray1OfBox2d_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Bnd.Bnd_HArray1OfBox2d_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Bnd.delete_Bnd_HArray1OfBox2d
Bnd_HArray1OfBox2d_swigregister = _Bnd.Bnd_HArray1OfBox2d_swigregister
Bnd_HArray1OfBox2d_swigregister(Bnd_HArray1OfBox2d)

def Bnd_HArray1OfBox2d_get_type_name(*args):
    """
    Bnd_HArray1OfBox2d_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Bnd.Bnd_HArray1OfBox2d_get_type_name(*args)

def Bnd_HArray1OfBox2d_get_type_descriptor(*args):
    """
    Bnd_HArray1OfBox2d_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Bnd.Bnd_HArray1OfBox2d_get_type_descriptor(*args)

class NCollection_Array1_Bnd_Sphere(object):
    """
    Purpose:     The class Array1 represents unidimensional arrays 
    of fixed size known at run time. 
    The range of the index is user defined.
    An array1 can be constructed with a "C array".
    This functionality is useful to call methods expecting
    an Array1. It allows to carry the bounds inside the arrays.

    Examples:    Item tab[100]; //  An example with a C array
    Array1OfItem ttab (tab[0],1,100);

    Array1OfItem tttab (ttab(10),10,20); // a slice of ttab

    If you want to reindex an array from 1 to Length do :

    Array1 tab1(tab(tab.Lower()),1,tab.Length());

    Warning:     Programs client of such a class must be independant
    of the range of the first element. Then, a C++ for
    loop must be written like this

    for (i = A.Lower(); i <= A.Upper(); i++)

    Changes:     In  comparison  to  TCollection  the  flag  isAllocated  was
    renamed into myDeletable (alike in  the Array2).  For naming
    compatibility the method IsAllocated remained in class along
    with IsDeletable.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Array1_Bnd_Sphere self) -> NCollection_Array1< Bnd_Sphere >::iterator

        Returns an iterator pointing to the first element in the array.

        :rtype: iterator

        """
        return _Bnd.NCollection_Array1_Bnd_Sphere_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Array1_Bnd_Sphere self) -> NCollection_Array1< Bnd_Sphere >::iterator

        Returns an iterator referring to the past-the-end element in the array.

        :rtype: iterator

        """
        return _Bnd.NCollection_Array1_Bnd_Sphere_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Array1_Bnd_Sphere self) -> NCollection_Array1< Bnd_Sphere >::const_iterator

        Returns a const iterator pointing to the first element in the array.

        :rtype: const_iterator

        """
        return _Bnd.NCollection_Array1_Bnd_Sphere_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Array1_Bnd_Sphere self) -> NCollection_Array1< Bnd_Sphere >::const_iterator

        Returns a const iterator referring to the past-the-end element in the array.

        :rtype: const_iterator

        """
        return _Bnd.NCollection_Array1_Bnd_Sphere_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     The class Array1 represents unidimensional arrays 
        of fixed size known at run time. 
        The range of the index is user defined.
        An array1 can be constructed with a "C array".
        This functionality is useful to call methods expecting
        an Array1. It allows to carry the bounds inside the arrays.

        Examples:    Item tab[100]; //  An example with a C array
        Array1OfItem ttab (tab[0],1,100);

        Array1OfItem tttab (ttab(10),10,20); // a slice of ttab

        If you want to reindex an array from 1 to Length do :

        Array1 tab1(tab(tab.Lower()),1,tab.Length());

        Warning:     Programs client of such a class must be independant
        of the range of the first element. Then, a C++ for
        loop must be written like this

        for (i = A.Lower(); i <= A.Upper(); i++)

        Changes:     In  comparison  to  TCollection  the  flag  isAllocated  was
        renamed into myDeletable (alike in  the Array2).  For naming
        compatibility the method IsAllocated remained in class along
        with IsDeletable.
        """
        this = _Bnd.new_NCollection_Array1_Bnd_Sphere(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(NCollection_Array1_Bnd_Sphere self, Bnd_Sphere theValue)

        Initialise the items with theValue

        :type theValue: const TheItemType &

        """
        return _Bnd.NCollection_Array1_Bnd_Sphere_Init(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_Array1_Bnd_Sphere self) -> Standard_Integer

        Size query

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Bnd.NCollection_Array1_Bnd_Sphere_Size(self, *args)


    def Length(self, *args):
        """
        Length(NCollection_Array1_Bnd_Sphere self) -> Standard_Integer

        Length query (the same)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Bnd.NCollection_Array1_Bnd_Sphere_Length(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Array1_Bnd_Sphere self) -> Standard_Boolean

        Return TRUE if array has zero length.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Bnd.NCollection_Array1_Bnd_Sphere_IsEmpty(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Array1_Bnd_Sphere self) -> Standard_Integer

        Lower bound

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Bnd.NCollection_Array1_Bnd_Sphere_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Array1_Bnd_Sphere self) -> Standard_Integer

        Upper bound

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Bnd.NCollection_Array1_Bnd_Sphere_Upper(self, *args)


    def IsDeletable(self, *args):
        """
        IsDeletable(NCollection_Array1_Bnd_Sphere self) -> Standard_Boolean

        myDeletable flag

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Bnd.NCollection_Array1_Bnd_Sphere_IsDeletable(self, *args)


    def IsAllocated(self, *args):
        """
        IsAllocated(NCollection_Array1_Bnd_Sphere self) -> Standard_Boolean

        IsAllocated flag - for naming compatibility

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Bnd.NCollection_Array1_Bnd_Sphere_IsAllocated(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Array1_Bnd_Sphere self, NCollection_Array1_Bnd_Sphere theOther) -> NCollection_Array1_Bnd_Sphere

        Copies data of theOther array to this.
        This array should be pre-allocated and have the same length as theOther;
        otherwise exception Standard_DimensionMismatch is thrown.

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _Bnd.NCollection_Array1_Bnd_Sphere_Assign(self, *args)


    def Move(self, *args):
        """
        Move(NCollection_Array1_Bnd_Sphere self, NCollection_Array1_Bnd_Sphere theOther) -> NCollection_Array1_Bnd_Sphere

        Move assignment.
        This array will borrow all the data from theOther.
        The moved object will keep pointer to the memory buffer and
        range, but it will not free the buffer on destruction.

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _Bnd.NCollection_Array1_Bnd_Sphere_Move(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Array1_Bnd_Sphere self, NCollection_Array1_Bnd_Sphere theOther) -> NCollection_Array1_Bnd_Sphere
        assign(NCollection_Array1_Bnd_Sphere self, NCollection_Array1_Bnd_Sphere theOther) -> NCollection_Array1_Bnd_Sphere

        Move assignment operator; @sa Move()

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1<TheItemType> &&
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _Bnd.NCollection_Array1_Bnd_Sphere_assign(self, *args)


    def First(self, *args):
        """
        @return first element

        :rtype: const TheItemType &

        """
        res = _Bnd.NCollection_Array1_Bnd_Sphere_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Array1_Bnd_Sphere self) -> Bnd_Sphere

        @return first element

        :rtype: TheItemType &

        """
        return _Bnd.NCollection_Array1_Bnd_Sphere_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        @return last element

        :rtype: const TheItemType &

        """
        res = _Bnd.NCollection_Array1_Bnd_Sphere_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Array1_Bnd_Sphere self) -> Bnd_Sphere

        @return last element

        :rtype: TheItemType &

        """
        return _Bnd.NCollection_Array1_Bnd_Sphere_ChangeLast(self, *args)


    def Value(self, *args):
        """
        Constant value access

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _Bnd.NCollection_Array1_Bnd_Sphere_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Array1_Bnd_Sphere self, Standard_Integer const theIndex) -> Bnd_Sphere

        Variable value access

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _Bnd.NCollection_Array1_Bnd_Sphere_ChangeValue(self, *args)


    def __call__(self, *args):
        """
        operator() - alias to Value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _Bnd.NCollection_Array1_Bnd_Sphere___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __getitem__(self, *args):
        """
        operator[] - alias to Value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _Bnd.NCollection_Array1_Bnd_Sphere_at(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetValue(self, *args):
        """
        SetValue(NCollection_Array1_Bnd_Sphere self, Standard_Integer const theIndex, Bnd_Sphere theItem)

        Set value 

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _Bnd.NCollection_Array1_Bnd_Sphere_SetValue(self, *args)


    def Resize(self, *args):
        """
        Resize(NCollection_Array1_Bnd_Sphere self, Standard_Integer const theLower, Standard_Integer const theUpper, Standard_Boolean const theToCopyData)

        Resizes the array to specified bounds.
        No re-allocation will be done if length of array does not change,
        but existing values will not be discarded if theToCopyData set to FALSE.
        @param theLower new lower bound of array
        @param theUpper new upper bound of array
        @param theToCopyData flag to copy existing data into new array

        :type theLower: int
        :type theUpper: int
        :type theToCopyData: bool

        """
        return _Bnd.NCollection_Array1_Bnd_Sphere_Resize(self, *args)

    __swig_destroy__ = _Bnd.delete_NCollection_Array1_Bnd_Sphere
NCollection_Array1_Bnd_Sphere_swigregister = _Bnd.NCollection_Array1_Bnd_Sphere_swigregister
NCollection_Array1_Bnd_Sphere_swigregister(NCollection_Array1_Bnd_Sphere)


try:
	Bnd_Array1OfSphere = NCollection_Array1_Bnd_Sphere
except NameError:
	pass # does not exist, probably ignored

class Bnd_B2d(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Bnd_B2d self) -> Bnd_B2d
        __init__(Bnd_B2d self, gp_XY theCenter, gp_XY theHSize) -> Bnd_B2d

        Constructor.

        :type theCenter: OCC.wrapper.gp.gp_XY
        :type theHSize: OCC.wrapper.gp.gp_XY

        """
        this = _Bnd.new_Bnd_B2d(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def IsVoid(self, *args):
        """
        IsVoid(Bnd_B2d self) -> Standard_Boolean

        Returns True if the box is void (non-initialized).

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Bnd.Bnd_B2d_IsVoid(self, *args)


    def Clear(self, *args):
        """
        Clear(Bnd_B2d self)

        Reset the box data.


        """
        return _Bnd.Bnd_B2d_Clear(self, *args)


    def Add(self, *args):
        """
        Add(Bnd_B2d self, gp_XY thePnt)
        Add(Bnd_B2d self, gp_Pnt2d thePnt)
        Add(Bnd_B2d self, Bnd_B2d theBox)

        Update the box by another box.

        :type theBox: OCC.wrapper.Bnd.Bnd_B2d

        """
        return _Bnd.Bnd_B2d_Add(self, *args)


    def CornerMin(self, *args):
        """
        CornerMin(Bnd_B2d self) -> gp_XY

        Query a box corner: (Center - HSize). You must make sure that
        the box is NOT VOID (see IsVoid()), otherwise the method returns
        irrelevant result.

        :rtype: OCC.wrapper.gp.gp_XY

        """
        return _Bnd.Bnd_B2d_CornerMin(self, *args)


    def CornerMax(self, *args):
        """
        CornerMax(Bnd_B2d self) -> gp_XY

        Query a box corner: (Center + HSize). You must make sure that
        the box is NOT VOID (see IsVoid()), otherwise the method returns
        irrelevant result.

        :rtype: OCC.wrapper.gp.gp_XY

        """
        return _Bnd.Bnd_B2d_CornerMax(self, *args)


    def SquareExtent(self, *args):
        """
        SquareExtent(Bnd_B2d self) -> Standard_Real

        Query the square diagonal. If the box is VOID (see method IsVoid())
        then a very big real value is returned.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Bnd.Bnd_B2d_SquareExtent(self, *args)


    def Enlarge(self, *args):
        """
        Enlarge(Bnd_B2d self, Standard_Real const theDiff)

        Extend the Box by the absolute value of theDiff.

        :type theDiff: float

        """
        return _Bnd.Bnd_B2d_Enlarge(self, *args)


    def Limit(self, *args):
        """
        Limit(Bnd_B2d self, Bnd_B2d theOtherBox) -> Standard_Boolean

        Limit the Box by the internals of theOtherBox.
        Returns True if the limitation takes place, otherwise False
        indicating that the boxes do not intersect.

        :type theOtherBox: OCC.wrapper.Bnd.Bnd_B2d
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Bnd.Bnd_B2d_Limit(self, *args)


    def Transformed(self, *args):
        """
        Transformed(Bnd_B2d self, gp_Trsf2d theTrsf) -> Bnd_B2d

        Transform the bounding box with the given transformation.
        The resulting box will be larger if theTrsf contains rotation.

        :type theTrsf: OCC.wrapper.gp.gp_Trsf2d
        :rtype: OCC.wrapper.Bnd.Bnd_B2d

        """
        return _Bnd.Bnd_B2d_Transformed(self, *args)


    def IsOut(self, *args):
        """
        IsOut(Bnd_B2d self, gp_XY thePnt) -> Standard_Boolean
        IsOut(Bnd_B2d self, gp_XY theCenter, Standard_Real const theRadius, Standard_Boolean const isCircleHollow) -> Standard_Boolean
        IsOut(Bnd_B2d self, Bnd_B2d theOtherBox) -> Standard_Boolean
        IsOut(Bnd_B2d self, Bnd_B2d theOtherBox, gp_Trsf2d theTrsf) -> Standard_Boolean
        IsOut(Bnd_B2d self, gp_Ax2d theLine) -> Standard_Boolean
        IsOut(Bnd_B2d self, gp_XY theP0, gp_XY theP1) -> Standard_Boolean

        Check the Segment defined by the couple of input points
        for the intersection with the current box.
        Returns True if there is no intersection.

        :type theP0: OCC.wrapper.gp.gp_XY
        :type theP1: OCC.wrapper.gp.gp_XY
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Bnd.Bnd_B2d_IsOut(self, *args)


    def IsIn(self, *args):
        """
        IsIn(Bnd_B2d self, Bnd_B2d theBox) -> Standard_Boolean
        IsIn(Bnd_B2d self, Bnd_B2d theBox, gp_Trsf2d theTrsf) -> Standard_Boolean

        Check that the box 'this' is inside the given box 'theBox'
        transformed by 'theTrsf'. Returns True if 'this' box is fully
        inside the transformed 'theBox'.

        :type theBox: OCC.wrapper.Bnd.Bnd_B2d
        :type theTrsf: OCC.wrapper.gp.gp_Trsf2d
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Bnd.Bnd_B2d_IsIn(self, *args)


    def SetCenter(self, *args):
        """
        SetCenter(Bnd_B2d self, gp_XY theCenter)

        Set the Center coordinates

        :type theCenter: OCC.wrapper.gp.gp_XY

        """
        return _Bnd.Bnd_B2d_SetCenter(self, *args)


    def SetHSize(self, *args):
        """
        SetHSize(Bnd_B2d self, gp_XY theHSize)

        Set the HSize (half-diagonal) coordinates.
        All components of theHSize must be non-negative.

        :type theHSize: OCC.wrapper.gp.gp_XY

        """
        return _Bnd.Bnd_B2d_SetHSize(self, *args)

    __swig_destroy__ = _Bnd.delete_Bnd_B2d
Bnd_B2d_swigregister = _Bnd.Bnd_B2d_swigregister
Bnd_B2d_swigregister(Bnd_B2d)

class Bnd_B2f(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Bnd_B2f self) -> Bnd_B2f
        __init__(Bnd_B2f self, gp_XY theCenter, gp_XY theHSize) -> Bnd_B2f

        Constructor.

        :type theCenter: OCC.wrapper.gp.gp_XY
        :type theHSize: OCC.wrapper.gp.gp_XY

        """
        this = _Bnd.new_Bnd_B2f(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def IsVoid(self, *args):
        """
        IsVoid(Bnd_B2f self) -> Standard_Boolean

        Returns True if the box is void (non-initialized).

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Bnd.Bnd_B2f_IsVoid(self, *args)


    def Clear(self, *args):
        """
        Clear(Bnd_B2f self)

        Reset the box data.


        """
        return _Bnd.Bnd_B2f_Clear(self, *args)


    def Add(self, *args):
        """
        Add(Bnd_B2f self, gp_XY thePnt)
        Add(Bnd_B2f self, gp_Pnt2d thePnt)
        Add(Bnd_B2f self, Bnd_B2f theBox)

        Update the box by another box.

        :type theBox: OCC.wrapper.Bnd.Bnd_B2f

        """
        return _Bnd.Bnd_B2f_Add(self, *args)


    def CornerMin(self, *args):
        """
        CornerMin(Bnd_B2f self) -> gp_XY

        Query a box corner: (Center - HSize). You must make sure that
        the box is NOT VOID (see IsVoid()), otherwise the method returns
        irrelevant result.

        :rtype: OCC.wrapper.gp.gp_XY

        """
        return _Bnd.Bnd_B2f_CornerMin(self, *args)


    def CornerMax(self, *args):
        """
        CornerMax(Bnd_B2f self) -> gp_XY

        Query a box corner: (Center + HSize). You must make sure that
        the box is NOT VOID (see IsVoid()), otherwise the method returns
        irrelevant result.

        :rtype: OCC.wrapper.gp.gp_XY

        """
        return _Bnd.Bnd_B2f_CornerMax(self, *args)


    def SquareExtent(self, *args):
        """
        SquareExtent(Bnd_B2f self) -> Standard_Real

        Query the square diagonal. If the box is VOID (see method IsVoid())
        then a very big real value is returned.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Bnd.Bnd_B2f_SquareExtent(self, *args)


    def Enlarge(self, *args):
        """
        Enlarge(Bnd_B2f self, Standard_Real const theDiff)

        Extend the Box by the absolute value of theDiff.

        :type theDiff: float

        """
        return _Bnd.Bnd_B2f_Enlarge(self, *args)


    def Limit(self, *args):
        """
        Limit(Bnd_B2f self, Bnd_B2f theOtherBox) -> Standard_Boolean

        Limit the Box by the internals of theOtherBox.
        Returns True if the limitation takes place, otherwise False
        indicating that the boxes do not intersect.

        :type theOtherBox: OCC.wrapper.Bnd.Bnd_B2f
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Bnd.Bnd_B2f_Limit(self, *args)


    def Transformed(self, *args):
        """
        Transformed(Bnd_B2f self, gp_Trsf2d theTrsf) -> Bnd_B2f

        Transform the bounding box with the given transformation.
        The resulting box will be larger if theTrsf contains rotation.

        :type theTrsf: OCC.wrapper.gp.gp_Trsf2d
        :rtype: OCC.wrapper.Bnd.Bnd_B2f

        """
        return _Bnd.Bnd_B2f_Transformed(self, *args)


    def IsOut(self, *args):
        """
        IsOut(Bnd_B2f self, gp_XY thePnt) -> Standard_Boolean
        IsOut(Bnd_B2f self, gp_XY theCenter, Standard_Real const theRadius, Standard_Boolean const isCircleHollow) -> Standard_Boolean
        IsOut(Bnd_B2f self, Bnd_B2f theOtherBox) -> Standard_Boolean
        IsOut(Bnd_B2f self, Bnd_B2f theOtherBox, gp_Trsf2d theTrsf) -> Standard_Boolean
        IsOut(Bnd_B2f self, gp_Ax2d theLine) -> Standard_Boolean
        IsOut(Bnd_B2f self, gp_XY theP0, gp_XY theP1) -> Standard_Boolean

        Check the Segment defined by the couple of input points
        for the intersection with the current box.
        Returns True if there is no intersection.

        :type theP0: OCC.wrapper.gp.gp_XY
        :type theP1: OCC.wrapper.gp.gp_XY
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Bnd.Bnd_B2f_IsOut(self, *args)


    def IsIn(self, *args):
        """
        IsIn(Bnd_B2f self, Bnd_B2f theBox) -> Standard_Boolean
        IsIn(Bnd_B2f self, Bnd_B2f theBox, gp_Trsf2d theTrsf) -> Standard_Boolean

        Check that the box 'this' is inside the given box 'theBox'
        transformed by 'theTrsf'. Returns True if 'this' box is fully
        inside the transformed 'theBox'.

        :type theBox: OCC.wrapper.Bnd.Bnd_B2f
        :type theTrsf: OCC.wrapper.gp.gp_Trsf2d
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Bnd.Bnd_B2f_IsIn(self, *args)


    def SetCenter(self, *args):
        """
        SetCenter(Bnd_B2f self, gp_XY theCenter)

        Set the Center coordinates

        :type theCenter: OCC.wrapper.gp.gp_XY

        """
        return _Bnd.Bnd_B2f_SetCenter(self, *args)


    def SetHSize(self, *args):
        """
        SetHSize(Bnd_B2f self, gp_XY theHSize)

        Set the HSize (half-diagonal) coordinates.
        All components of theHSize must be non-negative.

        :type theHSize: OCC.wrapper.gp.gp_XY

        """
        return _Bnd.Bnd_B2f_SetHSize(self, *args)

    __swig_destroy__ = _Bnd.delete_Bnd_B2f
Bnd_B2f_swigregister = _Bnd.Bnd_B2f_swigregister
Bnd_B2f_swigregister(Bnd_B2f)

class Bnd_Box2d(object):
    """
    Describes a bounding box in 2D space.
    A bounding box is parallel to the axes of the coordinates
    system. If it is finite, it is defined by the two intervals:
    -   [ Xmin,Xmax ], and
    -   [ Ymin,Ymax ].
    A bounding box may be infinite (i.e. open) in one or more
    directions. It is said to be:
    -   OpenXmin if it is infinite on the negative side of the   "X Direction";
    -   OpenXmax if it is infinite on the positive side of the   "X Direction";
    -   OpenYmin if it is infinite on the negative side of the   "Y Direction";
    -   OpenYmax if it is infinite on the positive side of the   "Y Direction";
    -   WholeSpace if it is infinite in all four directions. In
    this case, any point of the space is inside the box;
    -   Void if it is empty. In this case, there is no point included in the box.
    A bounding box is defined by four bounds (Xmin, Xmax, Ymin and Ymax) which
    limit the bounding box if it is finite, six flags (OpenXmin, OpenXmax, OpenYmin,
    OpenYmax, WholeSpace and Void) which describe the bounding box if it is infinite or empty, and
    -   a gap, which is included on both sides in any direction when consulting the finite bounds of the box.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Bnd_Box2d self) -> Bnd_Box2d

        Creates an empty 2D bounding box.
        The constructed box is qualified Void. Its gap is null.


        """
        this = _Bnd.new_Bnd_Box2d(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def SetWhole(self, *args):
        """
        SetWhole(Bnd_Box2d self)

        Sets this bounding box so that it covers the whole 2D
        space, i.e. it is infinite in all directions.


        """
        return _Bnd.Bnd_Box2d_SetWhole(self, *args)


    def SetVoid(self, *args):
        """
        SetVoid(Bnd_Box2d self)

        Sets this 2D bounding box so that it is empty. All points are outside a void box.


        """
        return _Bnd.Bnd_Box2d_SetVoid(self, *args)


    def Set(self, *args):
        """
        Set(Bnd_Box2d self, gp_Pnt2d thePnt)
        Set(Bnd_Box2d self, gp_Pnt2d thePnt, gp_Dir2d theDir)

        Sets this 2D bounding box so that it bounds
        the half-line defined by point P and direction D, i.e. all
        points M defined by M=P+u*D, where u is greater than
        or equal to 0, are inside the bounding area. This involves
        first setting this 2D box to be void and then adding the   half-line.

        :type thePnt: OCC.wrapper.gp.gp_Pnt2d
        :type theDir: OCC.wrapper.gp.gp_Dir2d

        """
        return _Bnd.Bnd_Box2d_Set(self, *args)


    def Update(self, *args):
        """
        Update(Bnd_Box2d self, Standard_Real const aXmin, Standard_Real const aYmin, Standard_Real const aXmax, Standard_Real const aYmax)
        Update(Bnd_Box2d self, Standard_Real const X, Standard_Real const Y)

        Adds a point of coordinates (X,Y) to this bounding box.

        :type X: float
        :type Y: float

        """
        return _Bnd.Bnd_Box2d_Update(self, *args)


    def GetGap(self, *args):
        """
        GetGap(Bnd_Box2d self) -> Standard_Real

        Returns the gap of this 2D bounding box.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Bnd.Bnd_Box2d_GetGap(self, *args)


    def SetGap(self, *args):
        """
        SetGap(Bnd_Box2d self, Standard_Real const Tol)

        Set the gap of this 2D bounding box to abs(Tol).

        :type Tol: float

        """
        return _Bnd.Bnd_Box2d_SetGap(self, *args)


    def Enlarge(self, *args):
        """
        Enlarge(Bnd_Box2d self, Standard_Real const theTol)

        Enlarges     the  box  with    a  tolerance  value.
        This means that the minimum values of its X and Y
        intervals of definition, when they are finite, are reduced by
        the absolute value of Tol, while the maximum values are
        increased by the same amount.

        :type theTol: float

        """
        return _Bnd.Bnd_Box2d_Enlarge(self, *args)


    def Get(self, *args):
        """
        Get(Bnd_Box2d self)

        Returns the bounds of this 2D bounding box.
        The gap is included. If this bounding box is infinite (i.e. "open"), returned values
        may be equal to +/- Precision::Infinite().
        if IsVoid()

        :type aXmin: float
        :type aYmin: float
        :type aXmax: float
        :type aYmax: float

        """
        return _Bnd.Bnd_Box2d_Get(self, *args)


    def OpenXmin(self, *args):
        """
        OpenXmin(Bnd_Box2d self)

        The Box will be infinitely long in the Xmin direction.


        """
        return _Bnd.Bnd_Box2d_OpenXmin(self, *args)


    def OpenXmax(self, *args):
        """
        OpenXmax(Bnd_Box2d self)

        The Box will be infinitely long in the Xmax direction.


        """
        return _Bnd.Bnd_Box2d_OpenXmax(self, *args)


    def OpenYmin(self, *args):
        """
        OpenYmin(Bnd_Box2d self)

        The Box will be infinitely long in the Ymin direction.


        """
        return _Bnd.Bnd_Box2d_OpenYmin(self, *args)


    def OpenYmax(self, *args):
        """
        OpenYmax(Bnd_Box2d self)

        The Box will be infinitely long in the Ymax direction.


        """
        return _Bnd.Bnd_Box2d_OpenYmax(self, *args)


    def IsOpenXmin(self, *args):
        """
        IsOpenXmin(Bnd_Box2d self) -> Standard_Boolean

        Returns true if this bounding box is open in the Xmin direction.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Bnd.Bnd_Box2d_IsOpenXmin(self, *args)


    def IsOpenXmax(self, *args):
        """
        IsOpenXmax(Bnd_Box2d self) -> Standard_Boolean

        Returns true if this bounding box is open in the Xmax direction.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Bnd.Bnd_Box2d_IsOpenXmax(self, *args)


    def IsOpenYmin(self, *args):
        """
        IsOpenYmin(Bnd_Box2d self) -> Standard_Boolean

        Returns true if this bounding box is open in the Ymin direction.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Bnd.Bnd_Box2d_IsOpenYmin(self, *args)


    def IsOpenYmax(self, *args):
        """
        IsOpenYmax(Bnd_Box2d self) -> Standard_Boolean

        Returns true if this bounding box is open in the Ymax direction.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Bnd.Bnd_Box2d_IsOpenYmax(self, *args)


    def IsWhole(self, *args):
        """
        IsWhole(Bnd_Box2d self) -> Standard_Boolean

        Returns true if this bounding box is infinite in all 4
        directions (Whole Space flag).

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Bnd.Bnd_Box2d_IsWhole(self, *args)


    def IsVoid(self, *args):
        """
        IsVoid(Bnd_Box2d self) -> Standard_Boolean

        Returns true if this 2D bounding box is empty (Void flag).

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Bnd.Bnd_Box2d_IsVoid(self, *args)


    def Transformed(self, *args):
        """
        Transformed(Bnd_Box2d self, gp_Trsf2d T) -> Bnd_Box2d

        Returns a bounding box which is the result of applying the
        transformation T to this bounding box.
        Warning
        Applying a geometric transformation (for example, a
        rotation) to a bounding box generally increases its
        dimensions. This is not optimal for algorithms which use it.

        :type T: OCC.wrapper.gp.gp_Trsf2d
        :rtype: OCC.wrapper.Bnd.Bnd_Box2d

        """
        return _Bnd.Bnd_Box2d_Transformed(self, *args)


    def Add(self, *args):
        """
        Add(Bnd_Box2d self, Bnd_Box2d Other)
        Add(Bnd_Box2d self, gp_Pnt2d thePnt)
        Add(Bnd_Box2d self, gp_Pnt2d thePnt, gp_Dir2d theDir)
        Add(Bnd_Box2d self, gp_Dir2d D)

        Extends the Box  in the given Direction, i.e. adds
        a half-line. The box may become infinite in 1 or 2
        directions.

        :type D: OCC.wrapper.gp.gp_Dir2d

        """
        return _Bnd.Bnd_Box2d_Add(self, *args)


    def IsOut(self, *args):
        """
        IsOut(Bnd_Box2d self, gp_Pnt2d P) -> Standard_Boolean
        IsOut(Bnd_Box2d self, Bnd_Box2d Other) -> Standard_Boolean
        IsOut(Bnd_Box2d self, Bnd_Box2d theOther, gp_Trsf2d theTrsf) -> Standard_Boolean
        IsOut(Bnd_Box2d self, gp_Trsf2d T1, Bnd_Box2d Other, gp_Trsf2d T2) -> Standard_Boolean

        Compares  a transformed  bounding with  a    transformed
        bounding. The default implementation is  to make a copy
        of <me> and <Other>, to transform them and to test.

        :type T1: OCC.wrapper.gp.gp_Trsf2d
        :type Other: OCC.wrapper.Bnd.Bnd_Box2d
        :type T2: OCC.wrapper.gp.gp_Trsf2d
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Bnd.Bnd_Box2d_IsOut(self, *args)


    def Dump(self, *args):
        """Dump(Bnd_Box2d self)"""
        return _Bnd.Bnd_Box2d_Dump(self, *args)


    def SquareExtent(self, *args):
        """
        SquareExtent(Bnd_Box2d self) -> Standard_Real

        Computes the squared diagonal of me.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Bnd.Bnd_Box2d_SquareExtent(self, *args)

    __swig_destroy__ = _Bnd.delete_Bnd_Box2d
Bnd_Box2d_swigregister = _Bnd.Bnd_Box2d_swigregister
Bnd_Box2d_swigregister(Bnd_Box2d)

class NCollection_Sequence_Bnd_Box(NCollection.NCollection_BaseSequence):
    """
    Purpose:     Definition of a sequence of elements indexed by
    an Integer in range of 1..n
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Sequence_Bnd_Box self) -> NCollection_Sequence< Bnd_Box >::iterator

        Returns an iterator pointing to the first element in the sequence.

        :rtype: iterator

        """
        return _Bnd.NCollection_Sequence_Bnd_Box_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Sequence_Bnd_Box self) -> NCollection_Sequence< Bnd_Box >::iterator

        Returns an iterator referring to the past-the-end element in the sequence.

        :rtype: iterator

        """
        return _Bnd.NCollection_Sequence_Bnd_Box_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Sequence_Bnd_Box self) -> NCollection_Sequence< Bnd_Box >::const_iterator

        Returns a const iterator pointing to the first element in the sequence.

        :rtype: const_iterator

        """
        return _Bnd.NCollection_Sequence_Bnd_Box_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Sequence_Bnd_Box self) -> NCollection_Sequence< Bnd_Box >::const_iterator

        Returns a const iterator referring to the past-the-end element in the sequence.

        :rtype: const_iterator

        """
        return _Bnd.NCollection_Sequence_Bnd_Box_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     Definition of a sequence of elements indexed by
        an Integer in range of 1..n
        """
        this = _Bnd.new_NCollection_Sequence_Bnd_Box(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Size(self, *args):
        """
        Size(NCollection_Sequence_Bnd_Box self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Bnd.NCollection_Sequence_Bnd_Box_Size(self, *args)


    def Length(self, *args):
        """
        Length(NCollection_Sequence_Bnd_Box self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Bnd.NCollection_Sequence_Bnd_Box_Length(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Sequence_Bnd_Box self) -> Standard_Integer

        Method for consistency with other collections.
        @return Lower bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Bnd.NCollection_Sequence_Bnd_Box_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Sequence_Bnd_Box self) -> Standard_Integer

        Method for consistency with other collections.
        @return Upper bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Bnd.NCollection_Sequence_Bnd_Box_Upper(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Sequence_Bnd_Box self) -> Standard_Boolean

        Empty query

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Bnd.NCollection_Sequence_Bnd_Box_IsEmpty(self, *args)


    def Reverse(self, *args):
        """
        Reverse(NCollection_Sequence_Bnd_Box self)

        Reverse sequence


        """
        return _Bnd.NCollection_Sequence_Bnd_Box_Reverse(self, *args)


    def Exchange(self, *args):
        """
        Exchange(NCollection_Sequence_Bnd_Box self, Standard_Integer const I, Standard_Integer const J)

        Exchange two members

        :type I: int
        :type J: int

        """
        return _Bnd.NCollection_Sequence_Bnd_Box_Exchange(self, *args)


    def delNode(*args):
        """
        delNode(NCollection_SeqNode theNode, Handle_NCollection_BaseAllocator theAl)

        Static deleter to be passed to BaseSequence

        :type theNode: OCC.wrapper.NCollection.NCollection_SeqNode
        :type theAl: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _Bnd.NCollection_Sequence_Bnd_Box_delNode(*args)

    delNode = staticmethod(delNode)

    def Clear(self, *args):
        """
        Clear(NCollection_Sequence_Bnd_Box self, Handle_NCollection_BaseAllocator theAllocator=0)

        Clear the items out, take a new allocator if non null

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _Bnd.NCollection_Sequence_Bnd_Box_Clear(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Sequence_Bnd_Box self, NCollection_Sequence_Bnd_Box theOther) -> NCollection_Sequence_Bnd_Box

        Replace this sequence by the items of theOther.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_Sequence
        :rtype: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _Bnd.NCollection_Sequence_Bnd_Box_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Sequence_Bnd_Box self, NCollection_Sequence_Bnd_Box theOther) -> NCollection_Sequence_Bnd_Box

        Replacement operator

        :type theOther: OCC.wrapper.NCollection.NCollection_Sequence
        :rtype: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _Bnd.NCollection_Sequence_Bnd_Box_assign(self, *args)


    def Remove(self, *args):
        """
        Remove(NCollection_Sequence_Bnd_Box self, NCollection_Sequence< Bnd_Box >::Iterator & thePosition)
        Remove(NCollection_Sequence_Bnd_Box self, Standard_Integer const theIndex)
        Remove(NCollection_Sequence_Bnd_Box self, Standard_Integer const theFromIndex, Standard_Integer const theToIndex)

        Remove range of items

        :type theFromIndex: int
        :type theToIndex: int

        """
        return _Bnd.NCollection_Sequence_Bnd_Box_Remove(self, *args)


    def Append(self, *args):
        """
        Append(NCollection_Sequence_Bnd_Box self, Bnd_Box theItem)
        Append(NCollection_Sequence_Bnd_Box self, NCollection_Sequence_Bnd_Box theSeq)

        Append another sequence (making it empty)

        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _Bnd.NCollection_Sequence_Bnd_Box_Append(self, *args)


    def Prepend(self, *args):
        """
        Prepend(NCollection_Sequence_Bnd_Box self, Bnd_Box theItem)
        Prepend(NCollection_Sequence_Bnd_Box self, NCollection_Sequence_Bnd_Box theSeq)

        Prepend another sequence (making it empty)

        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _Bnd.NCollection_Sequence_Bnd_Box_Prepend(self, *args)


    def InsertBefore(self, *args):
        """
        InsertBefore(NCollection_Sequence_Bnd_Box self, Standard_Integer const theIndex, Bnd_Box theItem)
        InsertBefore(NCollection_Sequence_Bnd_Box self, Standard_Integer const theIndex, NCollection_Sequence_Bnd_Box theSeq)

        InsertBefore theIndex another sequence

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _Bnd.NCollection_Sequence_Bnd_Box_InsertBefore(self, *args)


    def InsertAfter(self, *args):
        """
        InsertAfter(NCollection_Sequence_Bnd_Box self, NCollection_Sequence< Bnd_Box >::Iterator & thePosition, Bnd_Box theItem)
        InsertAfter(NCollection_Sequence_Bnd_Box self, Standard_Integer const theIndex, NCollection_Sequence_Bnd_Box theSeq)
        InsertAfter(NCollection_Sequence_Bnd_Box self, Standard_Integer const theIndex, Bnd_Box theItem)

        InsertAfter theIndex another sequence

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _Bnd.NCollection_Sequence_Bnd_Box_InsertAfter(self, *args)


    def Split(self, *args):
        """
        Split(NCollection_Sequence_Bnd_Box self, Standard_Integer const theIndex, NCollection_Sequence_Bnd_Box theSeq)

        Split in two sequences

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _Bnd.NCollection_Sequence_Bnd_Box_Split(self, *args)


    def First(self, *args):
        """
        First item access

        :rtype: const TheItemType &

        """
        res = _Bnd.NCollection_Sequence_Bnd_Box_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Sequence_Bnd_Box self) -> Bnd_Box

        First item access

        :rtype: TheItemType &

        """
        return _Bnd.NCollection_Sequence_Bnd_Box_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        Last item access

        :rtype: const TheItemType &

        """
        res = _Bnd.NCollection_Sequence_Bnd_Box_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Sequence_Bnd_Box self) -> Bnd_Box

        Last item access

        :rtype: TheItemType &

        """
        return _Bnd.NCollection_Sequence_Bnd_Box_ChangeLast(self, *args)


    def Value(self, *args):
        """
        Constant item access by theIndex

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _Bnd.NCollection_Sequence_Bnd_Box_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Sequence_Bnd_Box self, Standard_Integer const theIndex) -> Bnd_Box

        Variable item access by theIndex

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _Bnd.NCollection_Sequence_Bnd_Box_ChangeValue(self, *args)


    def __call__(self, *args):
        """
        Constant operator()

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _Bnd.NCollection_Sequence_Bnd_Box___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetValue(self, *args):
        """
        SetValue(NCollection_Sequence_Bnd_Box self, Standard_Integer const theIndex, Bnd_Box theItem)

        Set item value by theIndex

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _Bnd.NCollection_Sequence_Bnd_Box_SetValue(self, *args)


    def __iter__(self):
        return _Bnd.NCollection_Sequence_Bnd_Box___iter__(self)
    __swig_destroy__ = _Bnd.delete_NCollection_Sequence_Bnd_Box
NCollection_Sequence_Bnd_Box_swigregister = _Bnd.NCollection_Sequence_Bnd_Box_swigregister
NCollection_Sequence_Bnd_Box_swigregister(NCollection_Sequence_Bnd_Box)

def NCollection_Sequence_Bnd_Box_delNode(*args):
    """
    NCollection_Sequence_Bnd_Box_delNode(NCollection_SeqNode theNode, Handle_NCollection_BaseAllocator theAl)

    Static deleter to be passed to BaseSequence

    :type theNode: OCC.wrapper.NCollection.NCollection_SeqNode
    :type theAl: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

    """
    return _Bnd.NCollection_Sequence_Bnd_Box_delNode(*args)

class NCollection_Sequence_Bnd_Box_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _Bnd.new_NCollection_Sequence_Bnd_Box_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _Bnd.delete_NCollection_Sequence_Bnd_Box_IteratorHelper

    def __next__(self):
        return _Bnd.NCollection_Sequence_Bnd_Box_IteratorHelper___next__(self)
NCollection_Sequence_Bnd_Box_IteratorHelper_swigregister = _Bnd.NCollection_Sequence_Bnd_Box_IteratorHelper_swigregister
NCollection_Sequence_Bnd_Box_IteratorHelper_swigregister(NCollection_Sequence_Bnd_Box_IteratorHelper)


try:
	Bnd_SeqOfBox = NCollection_Sequence_Bnd_Box
except NameError:
	pass # does not exist, probably ignored

class Bnd_BoundSortBox(object):
    """
    A tool to compare a bounding box or a plane with a set of
    bounding boxes. It sorts the set of bounding boxes to give
    the list of boxes which intersect the element being compared.
    The boxes being sorted generally bound a set of shapes,
    while the box being compared bounds a shape to be
    compared. The resulting list of intersecting boxes therefore
    gives the list of items which potentially intersect the shape to be compared.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Bnd_BoundSortBox self) -> Bnd_BoundSortBox

        Constructs an empty comparison algorithm for bounding boxes.
        The bounding boxes are then defined using the Initialize function.


        """
        this = _Bnd.new_Bnd_BoundSortBox(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Initialize(self, *args):
        """
        Initialize(Bnd_BoundSortBox self, Bnd_Box CompleteBox, Handle_Bnd_HArray1OfBox SetOfBox)
        Initialize(Bnd_BoundSortBox self, Handle_Bnd_HArray1OfBox SetOfBox)
        Initialize(Bnd_BoundSortBox self, Bnd_Box CompleteBox, Standard_Integer const nbComponents)

        Initializes this comparison algorithm, giving it only
        -   the maximum number nbComponents
        of the bounding boxes to be managed. Use the Add
        function to define the array of bounding boxes to be sorted by this algorithm.

        :type CompleteBox: OCC.wrapper.Bnd.Bnd_Box
        :type nbComponents: int

        """
        return _Bnd.Bnd_BoundSortBox_Initialize(self, *args)


    def Add(self, *args):
        """
        Add(Bnd_BoundSortBox self, Bnd_Box theBox, Standard_Integer const boxIndex)

        Adds the bounding box theBox at position boxIndex in
        the array of boxes to be sorted by this comparison algorithm.
        This function is used only in conjunction with the third
        syntax described in the synopsis of Initialize.

        Exceptions:

        - Standard_OutOfRange if boxIndex is not in the
        range [ 1,nbComponents ] where
        nbComponents is the maximum number of bounding
        boxes declared for this comparison algorithm at
        initialization.

        - Standard_MultiplyDefined if a box already exists at
        position boxIndex in the array of boxes to be sorted by
        this comparison algorithm.

        :type theBox: OCC.wrapper.Bnd.Bnd_Box
        :type boxIndex: int

        """
        return _Bnd.Bnd_BoundSortBox_Add(self, *args)


    def Compare(self, *args):
        """
        Compares the plane P
        with the set of bounding boxes to be sorted by this
        comparison algorithm, and returns the list of intersecting
        bounding boxes as a list of indexes on the array of
        bounding boxes used by this algorithm.

        :type P: OCC.wrapper.gp.gp_Pln
        :rtype: OCC.wrapper.TColStd.TColStd_ListOfInteger

        """
        res = _Bnd.Bnd_BoundSortBox_Compare(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Dump(self, *args):
        """Dump(Bnd_BoundSortBox self)"""
        return _Bnd.Bnd_BoundSortBox_Dump(self, *args)


    def Destroy(self, *args):
        """Destroy(Bnd_BoundSortBox self)"""
        return _Bnd.Bnd_BoundSortBox_Destroy(self, *args)

    __swig_destroy__ = _Bnd.delete_Bnd_BoundSortBox
Bnd_BoundSortBox_swigregister = _Bnd.Bnd_BoundSortBox_swigregister
Bnd_BoundSortBox_swigregister(Bnd_BoundSortBox)

class Handle_Bnd_HArray1OfBox(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Bnd_HArray1OfBox self)

        Nullify the handle


        """
        return _Bnd.Handle_Bnd_HArray1OfBox_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Bnd_HArray1OfBox self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Bnd.Handle_Bnd_HArray1OfBox_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Bnd_HArray1OfBox self, Bnd_HArray1OfBox thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Bnd.Handle_Bnd_HArray1OfBox_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Bnd_HArray1OfBox self, Handle_Bnd_HArray1OfBox theHandle) -> Handle_Bnd_HArray1OfBox
        assign(Handle_Bnd_HArray1OfBox self, Bnd_HArray1OfBox thePtr) -> Handle_Bnd_HArray1OfBox
        assign(Handle_Bnd_HArray1OfBox self, Handle_Bnd_HArray1OfBox theHandle) -> Handle_Bnd_HArray1OfBox

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Bnd.Handle_Bnd_HArray1OfBox_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Bnd_HArray1OfBox self) -> Bnd_HArray1OfBox

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Bnd.Handle_Bnd_HArray1OfBox_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Bnd_HArray1OfBox self) -> Bnd_HArray1OfBox

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Bnd.Handle_Bnd_HArray1OfBox___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Bnd_HArray1OfBox self) -> Bnd_HArray1OfBox

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Bnd.Handle_Bnd_HArray1OfBox___ref__(self, *args)


    def __hash__(self):
        return _Bnd.Handle_Bnd_HArray1OfBox___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Bnd.Handle_Bnd_HArray1OfBox___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Bnd.new_Handle_Bnd_HArray1OfBox(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Bnd.Handle_Bnd_HArray1OfBox_DownCast)
    __swig_destroy__ = _Bnd.delete_Handle_Bnd_HArray1OfBox

    def Array1(self, *args):
        """
        :rtype: OCC.wrapper.Bnd.Bnd_Array1OfBox

        """
        res = _Bnd.Handle_Bnd_HArray1OfBox_Array1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeArray1(self, *args):
        """
        ChangeArray1(Handle_Bnd_HArray1OfBox self) -> NCollection_Array1_Bnd_Box

        :rtype: OCC.wrapper.Bnd.Bnd_Array1OfBox

        """
        return _Bnd.Handle_Bnd_HArray1OfBox_ChangeArray1(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Bnd_HArray1OfBox self) -> char const *

        :rtype: const char *

        """
        return _Bnd.Handle_Bnd_HArray1OfBox_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Bnd.Handle_Bnd_HArray1OfBox_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Bnd.Handle_Bnd_HArray1OfBox_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_Bnd_HArray1OfBox self)

        Memory deallocator for transient classes


        """
        return _Bnd.Handle_Bnd_HArray1OfBox_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Bnd_HArray1OfBox self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Bnd_HArray1OfBox self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Bnd.Handle_Bnd_HArray1OfBox_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Bnd_HArray1OfBox self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Bnd_HArray1OfBox self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Bnd.Handle_Bnd_HArray1OfBox_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Bnd_HArray1OfBox self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Bnd.Handle_Bnd_HArray1OfBox_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Bnd_HArray1OfBox self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Bnd.Handle_Bnd_HArray1OfBox_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Bnd_HArray1OfBox self)

        Increments the reference counter of this object


        """
        return _Bnd.Handle_Bnd_HArray1OfBox_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Bnd_HArray1OfBox self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Bnd.Handle_Bnd_HArray1OfBox_DecrementRefCounter(self, *args)

Handle_Bnd_HArray1OfBox_swigregister = _Bnd.Handle_Bnd_HArray1OfBox_swigregister
Handle_Bnd_HArray1OfBox_swigregister(Handle_Bnd_HArray1OfBox)

def Handle_Bnd_HArray1OfBox_DownCast(thing):
    return _Bnd.Handle_Bnd_HArray1OfBox_DownCast(thing)
Handle_Bnd_HArray1OfBox_DownCast = _Bnd.Handle_Bnd_HArray1OfBox_DownCast

class Handle_Bnd_HArray1OfBox2d(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Bnd_HArray1OfBox2d self)

        Nullify the handle


        """
        return _Bnd.Handle_Bnd_HArray1OfBox2d_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Bnd_HArray1OfBox2d self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Bnd.Handle_Bnd_HArray1OfBox2d_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Bnd_HArray1OfBox2d self, Bnd_HArray1OfBox2d thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Bnd.Handle_Bnd_HArray1OfBox2d_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Bnd_HArray1OfBox2d self, Handle_Bnd_HArray1OfBox2d theHandle) -> Handle_Bnd_HArray1OfBox2d
        assign(Handle_Bnd_HArray1OfBox2d self, Bnd_HArray1OfBox2d thePtr) -> Handle_Bnd_HArray1OfBox2d
        assign(Handle_Bnd_HArray1OfBox2d self, Handle_Bnd_HArray1OfBox2d theHandle) -> Handle_Bnd_HArray1OfBox2d

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Bnd.Handle_Bnd_HArray1OfBox2d_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Bnd_HArray1OfBox2d self) -> Bnd_HArray1OfBox2d

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Bnd.Handle_Bnd_HArray1OfBox2d_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Bnd_HArray1OfBox2d self) -> Bnd_HArray1OfBox2d

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Bnd.Handle_Bnd_HArray1OfBox2d___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Bnd_HArray1OfBox2d self) -> Bnd_HArray1OfBox2d

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Bnd.Handle_Bnd_HArray1OfBox2d___ref__(self, *args)


    def __hash__(self):
        return _Bnd.Handle_Bnd_HArray1OfBox2d___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Bnd.Handle_Bnd_HArray1OfBox2d___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Bnd.new_Handle_Bnd_HArray1OfBox2d(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Bnd.Handle_Bnd_HArray1OfBox2d_DownCast)
    __swig_destroy__ = _Bnd.delete_Handle_Bnd_HArray1OfBox2d

    def Array1(self, *args):
        """
        :rtype: OCC.wrapper.Bnd.Bnd_Array1OfBox2d

        """
        res = _Bnd.Handle_Bnd_HArray1OfBox2d_Array1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeArray1(self, *args):
        """
        ChangeArray1(Handle_Bnd_HArray1OfBox2d self) -> NCollection_Array1_Bnd_Box2d

        :rtype: OCC.wrapper.Bnd.Bnd_Array1OfBox2d

        """
        return _Bnd.Handle_Bnd_HArray1OfBox2d_ChangeArray1(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Bnd_HArray1OfBox2d self) -> char const *

        :rtype: const char *

        """
        return _Bnd.Handle_Bnd_HArray1OfBox2d_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Bnd.Handle_Bnd_HArray1OfBox2d_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Bnd.Handle_Bnd_HArray1OfBox2d_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_Bnd_HArray1OfBox2d self)

        Memory deallocator for transient classes


        """
        return _Bnd.Handle_Bnd_HArray1OfBox2d_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Bnd_HArray1OfBox2d self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Bnd_HArray1OfBox2d self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Bnd.Handle_Bnd_HArray1OfBox2d_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Bnd_HArray1OfBox2d self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Bnd_HArray1OfBox2d self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Bnd.Handle_Bnd_HArray1OfBox2d_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Bnd_HArray1OfBox2d self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Bnd.Handle_Bnd_HArray1OfBox2d_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Bnd_HArray1OfBox2d self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Bnd.Handle_Bnd_HArray1OfBox2d_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Bnd_HArray1OfBox2d self)

        Increments the reference counter of this object


        """
        return _Bnd.Handle_Bnd_HArray1OfBox2d_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Bnd_HArray1OfBox2d self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Bnd.Handle_Bnd_HArray1OfBox2d_DecrementRefCounter(self, *args)

Handle_Bnd_HArray1OfBox2d_swigregister = _Bnd.Handle_Bnd_HArray1OfBox2d_swigregister
Handle_Bnd_HArray1OfBox2d_swigregister(Handle_Bnd_HArray1OfBox2d)

def Handle_Bnd_HArray1OfBox2d_DownCast(thing):
    return _Bnd.Handle_Bnd_HArray1OfBox2d_DownCast(thing)
Handle_Bnd_HArray1OfBox2d_DownCast = _Bnd.Handle_Bnd_HArray1OfBox2d_DownCast

class Bnd_B3d(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Bnd_B3d self) -> Bnd_B3d
        __init__(Bnd_B3d self, gp_XYZ theCenter, gp_XYZ theHSize) -> Bnd_B3d

        Constructor.

        :type theCenter: OCC.wrapper.gp.gp_XYZ
        :type theHSize: OCC.wrapper.gp.gp_XYZ

        """
        this = _Bnd.new_Bnd_B3d(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def IsVoid(self, *args):
        """
        IsVoid(Bnd_B3d self) -> Standard_Boolean

        Returns True if the box is void (non-initialized).

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Bnd.Bnd_B3d_IsVoid(self, *args)


    def Clear(self, *args):
        """
        Clear(Bnd_B3d self)

        Reset the box data.


        """
        return _Bnd.Bnd_B3d_Clear(self, *args)


    def Add(self, *args):
        """
        Add(Bnd_B3d self, gp_XYZ thePnt)
        Add(Bnd_B3d self, gp_Pnt thePnt)
        Add(Bnd_B3d self, Bnd_B3d theBox)

        Update the box by another box.

        :type theBox: OCC.wrapper.Bnd.Bnd_B3d

        """
        return _Bnd.Bnd_B3d_Add(self, *args)


    def CornerMin(self, *args):
        """
        CornerMin(Bnd_B3d self) -> gp_XYZ

        Query the lower corner: (Center - HSize). You must make sure that
        the box is NOT VOID (see IsVoid()), otherwise the method returns
        irrelevant result.

        :rtype: OCC.wrapper.gp.gp_XYZ

        """
        return _Bnd.Bnd_B3d_CornerMin(self, *args)


    def CornerMax(self, *args):
        """
        CornerMax(Bnd_B3d self) -> gp_XYZ

        Query the upper corner: (Center + HSize). You must make sure that
        the box is NOT VOID (see IsVoid()), otherwise the method returns
        irrelevant result.

        :rtype: OCC.wrapper.gp.gp_XYZ

        """
        return _Bnd.Bnd_B3d_CornerMax(self, *args)


    def SquareExtent(self, *args):
        """
        SquareExtent(Bnd_B3d self) -> Standard_Real

        Query the square diagonal. If the box is VOID (see method IsVoid())
        then a very big real value is returned.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Bnd.Bnd_B3d_SquareExtent(self, *args)


    def Enlarge(self, *args):
        """
        Enlarge(Bnd_B3d self, Standard_Real const theDiff)

        Extend the Box by the absolute value of theDiff.

        :type theDiff: float

        """
        return _Bnd.Bnd_B3d_Enlarge(self, *args)


    def Limit(self, *args):
        """
        Limit(Bnd_B3d self, Bnd_B3d theOtherBox) -> Standard_Boolean

        Limit the Box by the internals of theOtherBox.
        Returns True if the limitation takes place, otherwise False
        indicating that the boxes do not intersect.

        :type theOtherBox: OCC.wrapper.Bnd.Bnd_B3d
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Bnd.Bnd_B3d_Limit(self, *args)


    def Transformed(self, *args):
        """
        Transformed(Bnd_B3d self, gp_Trsf theTrsf) -> Bnd_B3d

        Transform the bounding box with the given transformation.
        The resulting box will be larger if theTrsf contains rotation.

        :type theTrsf: OCC.wrapper.gp.gp_Trsf
        :rtype: OCC.wrapper.Bnd.Bnd_B3d

        """
        return _Bnd.Bnd_B3d_Transformed(self, *args)


    def IsOut(self, *args):
        """
        IsOut(Bnd_B3d self, gp_XYZ thePnt) -> Standard_Boolean
        IsOut(Bnd_B3d self, gp_XYZ theCenter, Standard_Real const theRadius, Standard_Boolean const isSphereHollow) -> Standard_Boolean
        IsOut(Bnd_B3d self, Bnd_B3d theOtherBox) -> Standard_Boolean
        IsOut(Bnd_B3d self, Bnd_B3d theOtherBox, gp_Trsf theTrsf) -> Standard_Boolean
        IsOut(Bnd_B3d self, gp_Ax1 theLine, Standard_Boolean const isRay, Standard_Real const theOverthickness=0.0) -> Standard_Boolean
        IsOut(Bnd_B3d self, gp_Ax3 thePlane) -> Standard_Boolean

        Check the given Plane for the intersection with the current box.
        Returns True if there is no intersection.

        :type thePlane: OCC.wrapper.gp.gp_Ax3
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Bnd.Bnd_B3d_IsOut(self, *args)


    def IsIn(self, *args):
        """
        IsIn(Bnd_B3d self, Bnd_B3d theBox) -> Standard_Boolean
        IsIn(Bnd_B3d self, Bnd_B3d theBox, gp_Trsf theTrsf) -> Standard_Boolean

        Check that the box 'this' is inside the given box 'theBox'
        transformed by 'theTrsf'. Returns True if 'this' box is fully
        inside the transformed 'theBox'.

        :type theBox: OCC.wrapper.Bnd.Bnd_B3d
        :type theTrsf: OCC.wrapper.gp.gp_Trsf
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Bnd.Bnd_B3d_IsIn(self, *args)


    def SetCenter(self, *args):
        """
        SetCenter(Bnd_B3d self, gp_XYZ theCenter)

        Set the Center coordinates

        :type theCenter: OCC.wrapper.gp.gp_XYZ

        """
        return _Bnd.Bnd_B3d_SetCenter(self, *args)


    def SetHSize(self, *args):
        """
        SetHSize(Bnd_B3d self, gp_XYZ theHSize)

        Set the HSize (half-diagonal) coordinates.
        All components of theHSize must be non-negative.

        :type theHSize: OCC.wrapper.gp.gp_XYZ

        """
        return _Bnd.Bnd_B3d_SetHSize(self, *args)

    __swig_destroy__ = _Bnd.delete_Bnd_B3d
Bnd_B3d_swigregister = _Bnd.Bnd_B3d_swigregister
Bnd_B3d_swigregister(Bnd_B3d)

class Bnd_B3f(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Bnd_B3f self) -> Bnd_B3f
        __init__(Bnd_B3f self, gp_XYZ theCenter, gp_XYZ theHSize) -> Bnd_B3f

        Constructor.

        :type theCenter: OCC.wrapper.gp.gp_XYZ
        :type theHSize: OCC.wrapper.gp.gp_XYZ

        """
        this = _Bnd.new_Bnd_B3f(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def IsVoid(self, *args):
        """
        IsVoid(Bnd_B3f self) -> Standard_Boolean

        Returns True if the box is void (non-initialized).

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Bnd.Bnd_B3f_IsVoid(self, *args)


    def Clear(self, *args):
        """
        Clear(Bnd_B3f self)

        Reset the box data.


        """
        return _Bnd.Bnd_B3f_Clear(self, *args)


    def Add(self, *args):
        """
        Add(Bnd_B3f self, gp_XYZ thePnt)
        Add(Bnd_B3f self, gp_Pnt thePnt)
        Add(Bnd_B3f self, Bnd_B3f theBox)

        Update the box by another box.

        :type theBox: OCC.wrapper.Bnd.Bnd_B3f

        """
        return _Bnd.Bnd_B3f_Add(self, *args)


    def CornerMin(self, *args):
        """
        CornerMin(Bnd_B3f self) -> gp_XYZ

        Query the lower corner: (Center - HSize). You must make sure that
        the box is NOT VOID (see IsVoid()), otherwise the method returns
        irrelevant result.

        :rtype: OCC.wrapper.gp.gp_XYZ

        """
        return _Bnd.Bnd_B3f_CornerMin(self, *args)


    def CornerMax(self, *args):
        """
        CornerMax(Bnd_B3f self) -> gp_XYZ

        Query the upper corner: (Center + HSize). You must make sure that
        the box is NOT VOID (see IsVoid()), otherwise the method returns
        irrelevant result.

        :rtype: OCC.wrapper.gp.gp_XYZ

        """
        return _Bnd.Bnd_B3f_CornerMax(self, *args)


    def SquareExtent(self, *args):
        """
        SquareExtent(Bnd_B3f self) -> Standard_Real

        Query the square diagonal. If the box is VOID (see method IsVoid())
        then a very big real value is returned.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Bnd.Bnd_B3f_SquareExtent(self, *args)


    def Enlarge(self, *args):
        """
        Enlarge(Bnd_B3f self, Standard_Real const theDiff)

        Extend the Box by the absolute value of theDiff.

        :type theDiff: float

        """
        return _Bnd.Bnd_B3f_Enlarge(self, *args)


    def Limit(self, *args):
        """
        Limit(Bnd_B3f self, Bnd_B3f theOtherBox) -> Standard_Boolean

        Limit the Box by the internals of theOtherBox.
        Returns True if the limitation takes place, otherwise False
        indicating that the boxes do not intersect.

        :type theOtherBox: OCC.wrapper.Bnd.Bnd_B3f
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Bnd.Bnd_B3f_Limit(self, *args)


    def Transformed(self, *args):
        """
        Transformed(Bnd_B3f self, gp_Trsf theTrsf) -> Bnd_B3f

        Transform the bounding box with the given transformation.
        The resulting box will be larger if theTrsf contains rotation.

        :type theTrsf: OCC.wrapper.gp.gp_Trsf
        :rtype: OCC.wrapper.Bnd.Bnd_B3f

        """
        return _Bnd.Bnd_B3f_Transformed(self, *args)


    def IsOut(self, *args):
        """
        IsOut(Bnd_B3f self, gp_XYZ thePnt) -> Standard_Boolean
        IsOut(Bnd_B3f self, gp_XYZ theCenter, Standard_Real const theRadius, Standard_Boolean const isSphereHollow) -> Standard_Boolean
        IsOut(Bnd_B3f self, Bnd_B3f theOtherBox) -> Standard_Boolean
        IsOut(Bnd_B3f self, Bnd_B3f theOtherBox, gp_Trsf theTrsf) -> Standard_Boolean
        IsOut(Bnd_B3f self, gp_Ax1 theLine, Standard_Boolean const isRay, Standard_Real const theOverthickness=0.0) -> Standard_Boolean
        IsOut(Bnd_B3f self, gp_Ax3 thePlane) -> Standard_Boolean

        Check the given Plane for the intersection with the current box.
        Returns True if there is no intersection.

        :type thePlane: OCC.wrapper.gp.gp_Ax3
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Bnd.Bnd_B3f_IsOut(self, *args)


    def IsIn(self, *args):
        """
        IsIn(Bnd_B3f self, Bnd_B3f theBox) -> Standard_Boolean
        IsIn(Bnd_B3f self, Bnd_B3f theBox, gp_Trsf theTrsf) -> Standard_Boolean

        Check that the box 'this' is inside the given box 'theBox'
        transformed by 'theTrsf'. Returns True if 'this' box is fully
        inside the transformed 'theBox'.

        :type theBox: OCC.wrapper.Bnd.Bnd_B3f
        :type theTrsf: OCC.wrapper.gp.gp_Trsf
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Bnd.Bnd_B3f_IsIn(self, *args)


    def SetCenter(self, *args):
        """
        SetCenter(Bnd_B3f self, gp_XYZ theCenter)

        Set the Center coordinates

        :type theCenter: OCC.wrapper.gp.gp_XYZ

        """
        return _Bnd.Bnd_B3f_SetCenter(self, *args)


    def SetHSize(self, *args):
        """
        SetHSize(Bnd_B3f self, gp_XYZ theHSize)

        Set the HSize (half-diagonal) coordinates.
        All components of theHSize must be non-negative.

        :type theHSize: OCC.wrapper.gp.gp_XYZ

        """
        return _Bnd.Bnd_B3f_SetHSize(self, *args)

    __swig_destroy__ = _Bnd.delete_Bnd_B3f
Bnd_B3f_swigregister = _Bnd.Bnd_B3f_swigregister
Bnd_B3f_swigregister(Bnd_B3f)

class Bnd_HArray1OfSphere(NCollection_Array1_Bnd_Sphere, Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Bnd_HArray1OfSphere
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Bnd_HArray1OfSphere(self) 
            return h


    def __init__(self, *args):
        """
        __init__(Bnd_HArray1OfSphere self, Standard_Integer const theLower, Standard_Integer const theUpper) -> Bnd_HArray1OfSphere
        __init__(Bnd_HArray1OfSphere self, Standard_Integer const theLower, Standard_Integer const theUpper, Bnd_Sphere theValue) -> Bnd_HArray1OfSphere
        __init__(Bnd_HArray1OfSphere self, NCollection_Array1_Bnd_Sphere theOther) -> Bnd_HArray1OfSphere

        :type theOther: OCC.wrapper.Bnd.Bnd_Array1OfSphere

        """
        this = _Bnd.new_Bnd_HArray1OfSphere(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Array1(self, *args):
        """
        :rtype: OCC.wrapper.Bnd.Bnd_Array1OfSphere

        """
        res = _Bnd.Bnd_HArray1OfSphere_Array1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeArray1(self, *args):
        """
        ChangeArray1(Bnd_HArray1OfSphere self) -> NCollection_Array1_Bnd_Sphere

        :rtype: OCC.wrapper.Bnd.Bnd_Array1OfSphere

        """
        return _Bnd.Bnd_HArray1OfSphere_ChangeArray1(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Bnd.Bnd_HArray1OfSphere_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Bnd.Bnd_HArray1OfSphere_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Bnd.Bnd_HArray1OfSphere_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Bnd.delete_Bnd_HArray1OfSphere
Bnd_HArray1OfSphere_swigregister = _Bnd.Bnd_HArray1OfSphere_swigregister
Bnd_HArray1OfSphere_swigregister(Bnd_HArray1OfSphere)

def Bnd_HArray1OfSphere_get_type_name(*args):
    """
    Bnd_HArray1OfSphere_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Bnd.Bnd_HArray1OfSphere_get_type_name(*args)

def Bnd_HArray1OfSphere_get_type_descriptor(*args):
    """
    Bnd_HArray1OfSphere_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Bnd.Bnd_HArray1OfSphere_get_type_descriptor(*args)

class Bnd_OBB(object):
    """
    The class describes the Oriented Bounding Box (OBB),
    much tighter enclosing volume for the shape than the
    Axis Aligned Bounding Box (AABB).
    The OBB is defined by a center of the box, the axes and the halves
    of its three dimensions.
    The OBB can be used more effectively than AABB as a rejection mechanism
    for non-interfering objects.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Bnd_OBB self) -> Bnd_OBB
        __init__(Bnd_OBB self, gp_Pnt theCenter, gp_Dir theXDirection, gp_Dir theYDirection, gp_Dir theZDirection, Standard_Real const theHXSize, Standard_Real const theHYSize, Standard_Real const theHZSize) -> Bnd_OBB
        __init__(Bnd_OBB self, Bnd_Box theBox) -> Bnd_OBB

        Constructor to create OBB from AABB.

        :type theBox: OCC.wrapper.Bnd.Bnd_Box

        """
        this = _Bnd.new_Bnd_OBB(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def ReBuild(self, *args):
        """
        ReBuild(Bnd_OBB self, NCollection_Array1_gp_Pnt theListOfPoints, NCollection_Array1_Standard_Real theListOfTolerances=None)

        Created new OBB covering every point in theListOfPoints.
        Tolerance of every such point is set by *theListOfTolerances array.
        If this array is not void (not null-pointer) then the resulted Bnd_OBB
        will be enlarged using tolerances of points lying on the box surface.

        :type theListOfPoints: OCC.wrapper.TColgp.TColgp_Array1OfPnt
        :type theListOfTolerances: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        return _Bnd.Bnd_OBB_ReBuild(self, *args)


    def SetCenter(self, *args):
        """
        SetCenter(Bnd_OBB self, gp_Pnt theCenter)

        Sets the center of OBB

        :type theCenter: OCC.wrapper.gp.gp_Pnt

        """
        return _Bnd.Bnd_OBB_SetCenter(self, *args)


    def SetXComponent(self, *args):
        """
        SetXComponent(Bnd_OBB self, gp_Dir theXDirection, Standard_Real const theHXSize)

        Sets the X component of OBB - direction and size

        :type theXDirection: OCC.wrapper.gp.gp_Dir
        :type theHXSize: float

        """
        return _Bnd.Bnd_OBB_SetXComponent(self, *args)


    def SetYComponent(self, *args):
        """
        SetYComponent(Bnd_OBB self, gp_Dir theYDirection, Standard_Real const theHYSize)

        Sets the Y component of OBB - direction and size

        :type theYDirection: OCC.wrapper.gp.gp_Dir
        :type theHYSize: float

        """
        return _Bnd.Bnd_OBB_SetYComponent(self, *args)


    def SetZComponent(self, *args):
        """
        SetZComponent(Bnd_OBB self, gp_Dir theZDirection, Standard_Real const theHZSize)

        Sets the Z component of OBB - direction and size

        :type theZDirection: OCC.wrapper.gp.gp_Dir
        :type theHZSize: float

        """
        return _Bnd.Bnd_OBB_SetZComponent(self, *args)


    def Center(self, *args):
        """
        Returns the center of OBB

        :rtype: OCC.wrapper.gp.gp_XYZ

        """
        res = _Bnd.Bnd_OBB_Center(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def XDirection(self, *args):
        """
        Returns the X Direction of OBB

        :rtype: OCC.wrapper.gp.gp_XYZ

        """
        res = _Bnd.Bnd_OBB_XDirection(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def YDirection(self, *args):
        """
        Returns the Y Direction of OBB

        :rtype: OCC.wrapper.gp.gp_XYZ

        """
        res = _Bnd.Bnd_OBB_YDirection(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ZDirection(self, *args):
        """
        Returns the Z Direction of OBB

        :rtype: OCC.wrapper.gp.gp_XYZ

        """
        res = _Bnd.Bnd_OBB_ZDirection(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def XHSize(self, *args):
        """
        XHSize(Bnd_OBB self) -> Standard_Real

        Returns the X Dimension of OBB

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Bnd.Bnd_OBB_XHSize(self, *args)


    def YHSize(self, *args):
        """
        YHSize(Bnd_OBB self) -> Standard_Real

        Returns the Y Dimension of OBB

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Bnd.Bnd_OBB_YHSize(self, *args)


    def ZHSize(self, *args):
        """
        ZHSize(Bnd_OBB self) -> Standard_Real

        Returns the Z Dimension of OBB

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Bnd.Bnd_OBB_ZHSize(self, *args)


    def IsVoid(self, *args):
        """
        IsVoid(Bnd_OBB self) -> Standard_Boolean

        Checks if the box is empty.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Bnd.Bnd_OBB_IsVoid(self, *args)


    def SetVoid(self, *args):
        """
        SetVoid(Bnd_OBB self)

        Clears this box


        """
        return _Bnd.Bnd_OBB_SetVoid(self, *args)


    def SetAABox(self, *args):
        """
        SetAABox(Bnd_OBB self, Standard_Boolean const & theFlag)

        Sets the flag for axes aligned box

        :type theFlag: bool

        """
        return _Bnd.Bnd_OBB_SetAABox(self, *args)


    def IsAABox(self, *args):
        """
        IsAABox(Bnd_OBB self) -> Standard_Boolean

        Returns TRUE if the box is axes aligned

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Bnd.Bnd_OBB_IsAABox(self, *args)


    def Enlarge(self, *args):
        """
        Enlarge(Bnd_OBB self, Standard_Real const theGapAdd)

        Enlarges the box with the given value

        :type theGapAdd: float

        """
        return _Bnd.Bnd_OBB_Enlarge(self, *args)


    def GetVertex(self, *args):
        """
        GetVertex(Bnd_OBB self, gp_Pnt theP) -> Standard_Boolean

        Returns the array of vertices in <this>.
        The local coordinate of the vertex depending on the
        index of the array are follow:
        Index == 0: (-XHSize(), -YHSize(), -ZHSize())
        Index == 1: ( XHSize(), -YHSize(), -ZHSize())
        Index == 2: (-XHSize(),  YHSize(), -ZHSize())
        Index == 3: ( XHSize(),  YHSize(), -ZHSize())
        Index == 4: (-XHSize(), -YHSize(),  ZHSize())
        Index == 5: ( XHSize(), -YHSize(),  ZHSize())
        Index == 6: (-XHSize(),  YHSize(),  ZHSize())
        Index == 7: ( XHSize(),  YHSize(),  ZHSize()).

        :type theP: OCC.wrapper.gp.gp_Pnt [8]
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Bnd.Bnd_OBB_GetVertex(self, *args)


    def SquareExtent(self, *args):
        """
        SquareExtent(Bnd_OBB self) -> Standard_Real

        Returns square diagonal of this box

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Bnd.Bnd_OBB_SquareExtent(self, *args)


    def IsOut(self, *args):
        """
        IsOut(Bnd_OBB self, Bnd_OBB theOther) -> Standard_Boolean
        IsOut(Bnd_OBB self, gp_Pnt theP) -> Standard_Boolean

        Check if the point is inside of <this>.

        :type theP: OCC.wrapper.gp.gp_Pnt
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Bnd.Bnd_OBB_IsOut(self, *args)


    def IsCompletelyInside(self, *args):
        """
        IsCompletelyInside(Bnd_OBB self, Bnd_OBB theOther) -> Standard_Boolean

        Check if the theOther is completely inside *this.

        :type theOther: OCC.wrapper.Bnd.Bnd_OBB
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Bnd.Bnd_OBB_IsCompletelyInside(self, *args)


    def Add(self, *args):
        """
        Add(Bnd_OBB self, Bnd_OBB theOther)
        Add(Bnd_OBB self, gp_Pnt theP)

        Rebuilds this in order to include all previous objects
        (which it was created from) and theP.

        :type theP: OCC.wrapper.gp.gp_Pnt

        """
        return _Bnd.Bnd_OBB_Add(self, *args)

    __swig_destroy__ = _Bnd.delete_Bnd_OBB
Bnd_OBB_swigregister = _Bnd.Bnd_OBB_swigregister
Bnd_OBB_swigregister(Bnd_OBB)

class NCollection_Array1_Bnd_Box(object):
    """
    Purpose:     The class Array1 represents unidimensional arrays 
    of fixed size known at run time. 
    The range of the index is user defined.
    An array1 can be constructed with a "C array".
    This functionality is useful to call methods expecting
    an Array1. It allows to carry the bounds inside the arrays.

    Examples:    Item tab[100]; //  An example with a C array
    Array1OfItem ttab (tab[0],1,100);

    Array1OfItem tttab (ttab(10),10,20); // a slice of ttab

    If you want to reindex an array from 1 to Length do :

    Array1 tab1(tab(tab.Lower()),1,tab.Length());

    Warning:     Programs client of such a class must be independant
    of the range of the first element. Then, a C++ for
    loop must be written like this

    for (i = A.Lower(); i <= A.Upper(); i++)

    Changes:     In  comparison  to  TCollection  the  flag  isAllocated  was
    renamed into myDeletable (alike in  the Array2).  For naming
    compatibility the method IsAllocated remained in class along
    with IsDeletable.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Array1_Bnd_Box self) -> NCollection_Array1< Bnd_Box >::iterator

        Returns an iterator pointing to the first element in the array.

        :rtype: iterator

        """
        return _Bnd.NCollection_Array1_Bnd_Box_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Array1_Bnd_Box self) -> NCollection_Array1< Bnd_Box >::iterator

        Returns an iterator referring to the past-the-end element in the array.

        :rtype: iterator

        """
        return _Bnd.NCollection_Array1_Bnd_Box_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Array1_Bnd_Box self) -> NCollection_Array1< Bnd_Box >::const_iterator

        Returns a const iterator pointing to the first element in the array.

        :rtype: const_iterator

        """
        return _Bnd.NCollection_Array1_Bnd_Box_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Array1_Bnd_Box self) -> NCollection_Array1< Bnd_Box >::const_iterator

        Returns a const iterator referring to the past-the-end element in the array.

        :rtype: const_iterator

        """
        return _Bnd.NCollection_Array1_Bnd_Box_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     The class Array1 represents unidimensional arrays 
        of fixed size known at run time. 
        The range of the index is user defined.
        An array1 can be constructed with a "C array".
        This functionality is useful to call methods expecting
        an Array1. It allows to carry the bounds inside the arrays.

        Examples:    Item tab[100]; //  An example with a C array
        Array1OfItem ttab (tab[0],1,100);

        Array1OfItem tttab (ttab(10),10,20); // a slice of ttab

        If you want to reindex an array from 1 to Length do :

        Array1 tab1(tab(tab.Lower()),1,tab.Length());

        Warning:     Programs client of such a class must be independant
        of the range of the first element. Then, a C++ for
        loop must be written like this

        for (i = A.Lower(); i <= A.Upper(); i++)

        Changes:     In  comparison  to  TCollection  the  flag  isAllocated  was
        renamed into myDeletable (alike in  the Array2).  For naming
        compatibility the method IsAllocated remained in class along
        with IsDeletable.
        """
        this = _Bnd.new_NCollection_Array1_Bnd_Box(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(NCollection_Array1_Bnd_Box self, Bnd_Box theValue)

        Initialise the items with theValue

        :type theValue: const TheItemType &

        """
        return _Bnd.NCollection_Array1_Bnd_Box_Init(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_Array1_Bnd_Box self) -> Standard_Integer

        Size query

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Bnd.NCollection_Array1_Bnd_Box_Size(self, *args)


    def Length(self, *args):
        """
        Length(NCollection_Array1_Bnd_Box self) -> Standard_Integer

        Length query (the same)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Bnd.NCollection_Array1_Bnd_Box_Length(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Array1_Bnd_Box self) -> Standard_Boolean

        Return TRUE if array has zero length.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Bnd.NCollection_Array1_Bnd_Box_IsEmpty(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Array1_Bnd_Box self) -> Standard_Integer

        Lower bound

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Bnd.NCollection_Array1_Bnd_Box_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Array1_Bnd_Box self) -> Standard_Integer

        Upper bound

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Bnd.NCollection_Array1_Bnd_Box_Upper(self, *args)


    def IsDeletable(self, *args):
        """
        IsDeletable(NCollection_Array1_Bnd_Box self) -> Standard_Boolean

        myDeletable flag

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Bnd.NCollection_Array1_Bnd_Box_IsDeletable(self, *args)


    def IsAllocated(self, *args):
        """
        IsAllocated(NCollection_Array1_Bnd_Box self) -> Standard_Boolean

        IsAllocated flag - for naming compatibility

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Bnd.NCollection_Array1_Bnd_Box_IsAllocated(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Array1_Bnd_Box self, NCollection_Array1_Bnd_Box theOther) -> NCollection_Array1_Bnd_Box

        Copies data of theOther array to this.
        This array should be pre-allocated and have the same length as theOther;
        otherwise exception Standard_DimensionMismatch is thrown.

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _Bnd.NCollection_Array1_Bnd_Box_Assign(self, *args)


    def Move(self, *args):
        """
        Move(NCollection_Array1_Bnd_Box self, NCollection_Array1_Bnd_Box theOther) -> NCollection_Array1_Bnd_Box

        Move assignment.
        This array will borrow all the data from theOther.
        The moved object will keep pointer to the memory buffer and
        range, but it will not free the buffer on destruction.

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _Bnd.NCollection_Array1_Bnd_Box_Move(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Array1_Bnd_Box self, NCollection_Array1_Bnd_Box theOther) -> NCollection_Array1_Bnd_Box
        assign(NCollection_Array1_Bnd_Box self, NCollection_Array1_Bnd_Box theOther) -> NCollection_Array1_Bnd_Box

        Move assignment operator; @sa Move()

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1<TheItemType> &&
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _Bnd.NCollection_Array1_Bnd_Box_assign(self, *args)


    def First(self, *args):
        """
        @return first element

        :rtype: const TheItemType &

        """
        res = _Bnd.NCollection_Array1_Bnd_Box_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Array1_Bnd_Box self) -> Bnd_Box

        @return first element

        :rtype: TheItemType &

        """
        return _Bnd.NCollection_Array1_Bnd_Box_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        @return last element

        :rtype: const TheItemType &

        """
        res = _Bnd.NCollection_Array1_Bnd_Box_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Array1_Bnd_Box self) -> Bnd_Box

        @return last element

        :rtype: TheItemType &

        """
        return _Bnd.NCollection_Array1_Bnd_Box_ChangeLast(self, *args)


    def Value(self, *args):
        """
        Constant value access

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _Bnd.NCollection_Array1_Bnd_Box_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Array1_Bnd_Box self, Standard_Integer const theIndex) -> Bnd_Box

        Variable value access

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _Bnd.NCollection_Array1_Bnd_Box_ChangeValue(self, *args)


    def __call__(self, *args):
        """
        operator() - alias to Value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _Bnd.NCollection_Array1_Bnd_Box___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __getitem__(self, *args):
        """
        operator[] - alias to Value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _Bnd.NCollection_Array1_Bnd_Box_at(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetValue(self, *args):
        """
        SetValue(NCollection_Array1_Bnd_Box self, Standard_Integer const theIndex, Bnd_Box theItem)

        Set value 

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _Bnd.NCollection_Array1_Bnd_Box_SetValue(self, *args)


    def Resize(self, *args):
        """
        Resize(NCollection_Array1_Bnd_Box self, Standard_Integer const theLower, Standard_Integer const theUpper, Standard_Boolean const theToCopyData)

        Resizes the array to specified bounds.
        No re-allocation will be done if length of array does not change,
        but existing values will not be discarded if theToCopyData set to FALSE.
        @param theLower new lower bound of array
        @param theUpper new upper bound of array
        @param theToCopyData flag to copy existing data into new array

        :type theLower: int
        :type theUpper: int
        :type theToCopyData: bool

        """
        return _Bnd.NCollection_Array1_Bnd_Box_Resize(self, *args)

    __swig_destroy__ = _Bnd.delete_NCollection_Array1_Bnd_Box
NCollection_Array1_Bnd_Box_swigregister = _Bnd.NCollection_Array1_Bnd_Box_swigregister
NCollection_Array1_Bnd_Box_swigregister(NCollection_Array1_Bnd_Box)


try:
	Bnd_Array1OfBox = NCollection_Array1_Bnd_Box
except NameError:
	pass # does not exist, probably ignored

class Bnd_BoundSortBox2d(object):
    """
    A tool to compare a 2D bounding box with a set of 2D
    bounding boxes. It sorts the set of bounding boxes to give
    the list of boxes which intersect the element being compared.
    The boxes being sorted generally bound a set of shapes,
    while the box being compared bounds a shape to be
    compared. The resulting list of intersecting boxes therefore
    gives the list of items which potentially intersect the shape to be compared.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Bnd_BoundSortBox2d self) -> Bnd_BoundSortBox2d

        Constructs an empty comparison algorithm for 2D bounding boxes.
        The bounding boxes are then defined using the Initialize function.


        """
        this = _Bnd.new_Bnd_BoundSortBox2d(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Initialize(self, *args):
        """
        Initialize(Bnd_BoundSortBox2d self, Bnd_Box2d CompleteBox, Handle_Bnd_HArray1OfBox2d SetOfBox)
        Initialize(Bnd_BoundSortBox2d self, Handle_Bnd_HArray1OfBox2d SetOfBox)
        Initialize(Bnd_BoundSortBox2d self, Bnd_Box2d CompleteBox, Standard_Integer const nbComponents)

        Initializes this comparison algorithm, giving it only
        -   the maximum number nbComponents, and
        -   the global bounding box CompleteBox,
        of the 2D bounding boxes to be managed. Use the Add
        function to define the array of bounding boxes to be sorted by this algorithm.

        :type CompleteBox: OCC.wrapper.Bnd.Bnd_Box2d
        :type nbComponents: int

        """
        return _Bnd.Bnd_BoundSortBox2d_Initialize(self, *args)


    def Add(self, *args):
        """
        Add(Bnd_BoundSortBox2d self, Bnd_Box2d theBox, Standard_Integer const boxIndex)

        Adds the 2D bounding box theBox at position boxIndex in
        the array of boxes to be sorted by this comparison algorithm.
        This function is used only in conjunction with the third
        syntax described in the synopsis of Initialize.
        Exceptions
        -   Standard_OutOfRange if boxIndex is not in the
        range [ 1,nbComponents ] where
        nbComponents is the maximum number of bounding
        boxes declared for this comparison algorithm at
        initialization.
        -   Standard_MultiplyDefined if a box still exists at
        position boxIndex in the array of boxes to be sorted by
        this comparison algorithm.

        :type theBox: OCC.wrapper.Bnd.Bnd_Box2d
        :type boxIndex: int

        """
        return _Bnd.Bnd_BoundSortBox2d_Add(self, *args)


    def Compare(self, *args):
        """
        Compares the 2D bounding box theBox with the set of
        bounding boxes to be sorted by this comparison algorithm,
        and returns the list of intersecting bounding boxes as a list
        of indexes on the array of bounding boxes used by this algorithm.

        :type theBox: OCC.wrapper.Bnd.Bnd_Box2d
        :rtype: OCC.wrapper.TColStd.TColStd_ListOfInteger

        """
        res = _Bnd.Bnd_BoundSortBox2d_Compare(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Dump(self, *args):
        """Dump(Bnd_BoundSortBox2d self)"""
        return _Bnd.Bnd_BoundSortBox2d_Dump(self, *args)

    __swig_destroy__ = _Bnd.delete_Bnd_BoundSortBox2d
Bnd_BoundSortBox2d_swigregister = _Bnd.Bnd_BoundSortBox2d_swigregister
Bnd_BoundSortBox2d_swigregister(Bnd_BoundSortBox2d)

class Bnd_Range(object):
    """
    This class describes a range in 1D space restricted
    by two real values.
    A range can be void indicating there is no point included in the range.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Bnd_Range self) -> Bnd_Range
        __init__(Bnd_Range self, Standard_Real const theMin, Standard_Real const theMax) -> Bnd_Range

        Constructor. Never creates VOID range.

        :type theMin: float
        :type theMax: float

        """
        this = _Bnd.new_Bnd_Range(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Common(self, *args):
        """
        Common(Bnd_Range self, Bnd_Range theOther)

        Replaces <this> with common-part of <this> and theOther

        :type theOther: OCC.wrapper.Bnd.Bnd_Range

        """
        return _Bnd.Bnd_Range_Common(self, *args)


    def Union(self, *args):
        """
        Union(Bnd_Range self, Bnd_Range theOther) -> Standard_Boolean

        Joins *this and theOther to one interval.
        Replaces *this to the result.
        Returns false if the operation cannot be done (e.g.
        input arguments are empty or separated).
        @sa use method ::Add() to merge two ranges unconditionally

        :type theOther: OCC.wrapper.Bnd.Bnd_Range
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Bnd.Bnd_Range_Union(self, *args)


    def Split(self, *args):
        """
        Split(Bnd_Range self, Standard_Real const theVal, NCollection_List< Bnd_Range > & theList, Standard_Real const thePeriod=0.0)

        Splits <this> to several sub-ranges by theVal value
        (e.g. range [3, 15] will be split by theVal==5 to the two
        ranges: [3, 5] and [5, 15]). New ranges will be pushed to
        theList (theList must be initialized correctly before
        calling this method).
        If thePeriod != 0.0 then at least one boundary of
        new ranges (if <*this> intersects theVal+k*thePeriod) will be equal to
        theVal+thePeriod*k, where k is an integer number (k = 0, +/-1, +/-2, ...).
        (let thePeriod in above example be 4 ==> we will obtain
        four ranges: [3, 5], [5, 9], [9, 13] and [13, 15].

        :type theVal: float
        :type theList: OCC.wrapper.Bnd.NCollection_List_Bnd_Range
        :type thePeriod: float

        """
        return _Bnd.Bnd_Range_Split(self, *args)


    def IsIntersected(self, *args):
        """
        IsIntersected(Bnd_Range self, Standard_Real const theVal, Standard_Real const thePeriod=0.0) -> Standard_Integer

        Checks if <this> intersects values like
        theVal+k*thePeriod, where k is an integer number (k = 0, +/-1, +/-2, ...).
        Returns:
        0 - if <this> does not intersect the theVal+k*thePeriod.
        1 - if <this> intersects theVal+k*thePeriod.
        2 - if myFirst or/and myLast are equal to theVal+k*thePeriod.

        ATTENTION!!!
        If (myFirst == myLast) then this function will return only either 0 or 2.

        :type theVal: float
        :type thePeriod: float
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Bnd.Bnd_Range_IsIntersected(self, *args)


    def Add(self, *args):
        """
        Add(Bnd_Range self, Standard_Real const theParameter)
        Add(Bnd_Range self, Bnd_Range theRange)

        Extends this range to include both ranges.
        @sa use method ::Union() to check if two ranges overlap method merging

        :type theRange: OCC.wrapper.Bnd.Bnd_Range

        """
        return _Bnd.Bnd_Range_Add(self, *args)


    def GetMin(self, *args):
        """
        GetMin(Bnd_Range self) -> Standard_Boolean

        Obtain MIN boundary of <this>.
        If <this> is VOID the method returns false.

        :type thePar: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Bnd.Bnd_Range_GetMin(self, *args)


    def GetMax(self, *args):
        """
        GetMax(Bnd_Range self) -> Standard_Boolean

        Obtain MAX boundary of <this>.
        If <this> is VOID the method returns false.

        :type thePar: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Bnd.Bnd_Range_GetMax(self, *args)


    def GetBounds(self, *args):
        """
        GetBounds(Bnd_Range self) -> Standard_Boolean

        Obtain first and last boundary of <this>.
        If <this> is VOID the method returns false.

        :type theFirstPar: float
        :type theLastPar: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Bnd.Bnd_Range_GetBounds(self, *args)


    def Delta(self, *args):
        """
        Delta(Bnd_Range self) -> Standard_Real

        Returns range value (MAX-MIN). Returns negative value for VOID range.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Bnd.Bnd_Range_Delta(self, *args)


    def IsVoid(self, *args):
        """
        IsVoid(Bnd_Range self) -> Standard_Boolean

        Is <this> initialized.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Bnd.Bnd_Range_IsVoid(self, *args)


    def SetVoid(self, *args):
        """
        SetVoid(Bnd_Range self)

        Initializes <this> by default parameters. Makes <this> VOID.


        """
        return _Bnd.Bnd_Range_SetVoid(self, *args)


    def Enlarge(self, *args):
        """
        Enlarge(Bnd_Range self, Standard_Real const theDelta)

        Extends this to the given value (in both side)

        :type theDelta: float

        """
        return _Bnd.Bnd_Range_Enlarge(self, *args)


    def Shifted(self, *args):
        """
        Shifted(Bnd_Range self, Standard_Real const theVal) -> Bnd_Range

        Returns the copy of <*this> shifted by theVal

        :type theVal: float
        :rtype: OCC.wrapper.Bnd.Bnd_Range

        """
        return _Bnd.Bnd_Range_Shifted(self, *args)


    def Shift(self, *args):
        """
        Shift(Bnd_Range self, Standard_Real const theVal)

        Shifts <*this> by theVal

        :type theVal: float

        """
        return _Bnd.Bnd_Range_Shift(self, *args)


    def IsOut(self, *args):
        """
        IsOut(Bnd_Range self, Standard_Real theValue) -> Standard_Boolean
        IsOut(Bnd_Range self, Bnd_Range theRange) -> Standard_Boolean

        Returns True if the given range is out of this range.

        :type theRange: OCC.wrapper.Bnd.Bnd_Range
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Bnd.Bnd_Range_IsOut(self, *args)


    def __eq__(self, *args):
        """
        __eq__(Bnd_Range self, Bnd_Range theOther) -> Standard_Boolean

        Returns TRUE if theOther is equal to <*this>

        :type theOther: OCC.wrapper.Bnd.Bnd_Range
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Bnd.Bnd_Range___eq__(self, *args)

    __swig_destroy__ = _Bnd.delete_Bnd_Range
Bnd_Range_swigregister = _Bnd.Bnd_Range_swigregister
Bnd_Range_swigregister(Bnd_Range)

class NCollection_Array1_Bnd_Box2d(object):
    """
    Purpose:     The class Array1 represents unidimensional arrays 
    of fixed size known at run time. 
    The range of the index is user defined.
    An array1 can be constructed with a "C array".
    This functionality is useful to call methods expecting
    an Array1. It allows to carry the bounds inside the arrays.

    Examples:    Item tab[100]; //  An example with a C array
    Array1OfItem ttab (tab[0],1,100);

    Array1OfItem tttab (ttab(10),10,20); // a slice of ttab

    If you want to reindex an array from 1 to Length do :

    Array1 tab1(tab(tab.Lower()),1,tab.Length());

    Warning:     Programs client of such a class must be independant
    of the range of the first element. Then, a C++ for
    loop must be written like this

    for (i = A.Lower(); i <= A.Upper(); i++)

    Changes:     In  comparison  to  TCollection  the  flag  isAllocated  was
    renamed into myDeletable (alike in  the Array2).  For naming
    compatibility the method IsAllocated remained in class along
    with IsDeletable.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Array1_Bnd_Box2d self) -> NCollection_Array1< Bnd_Box2d >::iterator

        Returns an iterator pointing to the first element in the array.

        :rtype: iterator

        """
        return _Bnd.NCollection_Array1_Bnd_Box2d_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Array1_Bnd_Box2d self) -> NCollection_Array1< Bnd_Box2d >::iterator

        Returns an iterator referring to the past-the-end element in the array.

        :rtype: iterator

        """
        return _Bnd.NCollection_Array1_Bnd_Box2d_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Array1_Bnd_Box2d self) -> NCollection_Array1< Bnd_Box2d >::const_iterator

        Returns a const iterator pointing to the first element in the array.

        :rtype: const_iterator

        """
        return _Bnd.NCollection_Array1_Bnd_Box2d_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Array1_Bnd_Box2d self) -> NCollection_Array1< Bnd_Box2d >::const_iterator

        Returns a const iterator referring to the past-the-end element in the array.

        :rtype: const_iterator

        """
        return _Bnd.NCollection_Array1_Bnd_Box2d_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     The class Array1 represents unidimensional arrays 
        of fixed size known at run time. 
        The range of the index is user defined.
        An array1 can be constructed with a "C array".
        This functionality is useful to call methods expecting
        an Array1. It allows to carry the bounds inside the arrays.

        Examples:    Item tab[100]; //  An example with a C array
        Array1OfItem ttab (tab[0],1,100);

        Array1OfItem tttab (ttab(10),10,20); // a slice of ttab

        If you want to reindex an array from 1 to Length do :

        Array1 tab1(tab(tab.Lower()),1,tab.Length());

        Warning:     Programs client of such a class must be independant
        of the range of the first element. Then, a C++ for
        loop must be written like this

        for (i = A.Lower(); i <= A.Upper(); i++)

        Changes:     In  comparison  to  TCollection  the  flag  isAllocated  was
        renamed into myDeletable (alike in  the Array2).  For naming
        compatibility the method IsAllocated remained in class along
        with IsDeletable.
        """
        this = _Bnd.new_NCollection_Array1_Bnd_Box2d(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(NCollection_Array1_Bnd_Box2d self, Bnd_Box2d theValue)

        Initialise the items with theValue

        :type theValue: const TheItemType &

        """
        return _Bnd.NCollection_Array1_Bnd_Box2d_Init(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_Array1_Bnd_Box2d self) -> Standard_Integer

        Size query

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Bnd.NCollection_Array1_Bnd_Box2d_Size(self, *args)


    def Length(self, *args):
        """
        Length(NCollection_Array1_Bnd_Box2d self) -> Standard_Integer

        Length query (the same)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Bnd.NCollection_Array1_Bnd_Box2d_Length(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Array1_Bnd_Box2d self) -> Standard_Boolean

        Return TRUE if array has zero length.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Bnd.NCollection_Array1_Bnd_Box2d_IsEmpty(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Array1_Bnd_Box2d self) -> Standard_Integer

        Lower bound

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Bnd.NCollection_Array1_Bnd_Box2d_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Array1_Bnd_Box2d self) -> Standard_Integer

        Upper bound

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Bnd.NCollection_Array1_Bnd_Box2d_Upper(self, *args)


    def IsDeletable(self, *args):
        """
        IsDeletable(NCollection_Array1_Bnd_Box2d self) -> Standard_Boolean

        myDeletable flag

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Bnd.NCollection_Array1_Bnd_Box2d_IsDeletable(self, *args)


    def IsAllocated(self, *args):
        """
        IsAllocated(NCollection_Array1_Bnd_Box2d self) -> Standard_Boolean

        IsAllocated flag - for naming compatibility

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Bnd.NCollection_Array1_Bnd_Box2d_IsAllocated(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Array1_Bnd_Box2d self, NCollection_Array1_Bnd_Box2d theOther) -> NCollection_Array1_Bnd_Box2d

        Copies data of theOther array to this.
        This array should be pre-allocated and have the same length as theOther;
        otherwise exception Standard_DimensionMismatch is thrown.

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _Bnd.NCollection_Array1_Bnd_Box2d_Assign(self, *args)


    def Move(self, *args):
        """
        Move(NCollection_Array1_Bnd_Box2d self, NCollection_Array1_Bnd_Box2d theOther) -> NCollection_Array1_Bnd_Box2d

        Move assignment.
        This array will borrow all the data from theOther.
        The moved object will keep pointer to the memory buffer and
        range, but it will not free the buffer on destruction.

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _Bnd.NCollection_Array1_Bnd_Box2d_Move(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Array1_Bnd_Box2d self, NCollection_Array1_Bnd_Box2d theOther) -> NCollection_Array1_Bnd_Box2d
        assign(NCollection_Array1_Bnd_Box2d self, NCollection_Array1_Bnd_Box2d theOther) -> NCollection_Array1_Bnd_Box2d

        Move assignment operator; @sa Move()

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1<TheItemType> &&
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _Bnd.NCollection_Array1_Bnd_Box2d_assign(self, *args)


    def First(self, *args):
        """
        @return first element

        :rtype: const TheItemType &

        """
        res = _Bnd.NCollection_Array1_Bnd_Box2d_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Array1_Bnd_Box2d self) -> Bnd_Box2d

        @return first element

        :rtype: TheItemType &

        """
        return _Bnd.NCollection_Array1_Bnd_Box2d_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        @return last element

        :rtype: const TheItemType &

        """
        res = _Bnd.NCollection_Array1_Bnd_Box2d_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Array1_Bnd_Box2d self) -> Bnd_Box2d

        @return last element

        :rtype: TheItemType &

        """
        return _Bnd.NCollection_Array1_Bnd_Box2d_ChangeLast(self, *args)


    def Value(self, *args):
        """
        Constant value access

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _Bnd.NCollection_Array1_Bnd_Box2d_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Array1_Bnd_Box2d self, Standard_Integer const theIndex) -> Bnd_Box2d

        Variable value access

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _Bnd.NCollection_Array1_Bnd_Box2d_ChangeValue(self, *args)


    def __call__(self, *args):
        """
        operator() - alias to Value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _Bnd.NCollection_Array1_Bnd_Box2d___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __getitem__(self, *args):
        """
        operator[] - alias to Value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _Bnd.NCollection_Array1_Bnd_Box2d_at(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetValue(self, *args):
        """
        SetValue(NCollection_Array1_Bnd_Box2d self, Standard_Integer const theIndex, Bnd_Box2d theItem)

        Set value 

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _Bnd.NCollection_Array1_Bnd_Box2d_SetValue(self, *args)


    def Resize(self, *args):
        """
        Resize(NCollection_Array1_Bnd_Box2d self, Standard_Integer const theLower, Standard_Integer const theUpper, Standard_Boolean const theToCopyData)

        Resizes the array to specified bounds.
        No re-allocation will be done if length of array does not change,
        but existing values will not be discarded if theToCopyData set to FALSE.
        @param theLower new lower bound of array
        @param theUpper new upper bound of array
        @param theToCopyData flag to copy existing data into new array

        :type theLower: int
        :type theUpper: int
        :type theToCopyData: bool

        """
        return _Bnd.NCollection_Array1_Bnd_Box2d_Resize(self, *args)

    __swig_destroy__ = _Bnd.delete_NCollection_Array1_Bnd_Box2d
NCollection_Array1_Bnd_Box2d_swigregister = _Bnd.NCollection_Array1_Bnd_Box2d_swigregister
NCollection_Array1_Bnd_Box2d_swigregister(NCollection_Array1_Bnd_Box2d)


try:
	Bnd_Array1OfBox2d = NCollection_Array1_Bnd_Box2d
except NameError:
	pass # does not exist, probably ignored

class Handle_Bnd_HArray1OfSphere(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Bnd_HArray1OfSphere self)

        Nullify the handle


        """
        return _Bnd.Handle_Bnd_HArray1OfSphere_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Bnd_HArray1OfSphere self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Bnd.Handle_Bnd_HArray1OfSphere_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Bnd_HArray1OfSphere self, Bnd_HArray1OfSphere thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Bnd.Handle_Bnd_HArray1OfSphere_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Bnd_HArray1OfSphere self, Handle_Bnd_HArray1OfSphere theHandle) -> Handle_Bnd_HArray1OfSphere
        assign(Handle_Bnd_HArray1OfSphere self, Bnd_HArray1OfSphere thePtr) -> Handle_Bnd_HArray1OfSphere
        assign(Handle_Bnd_HArray1OfSphere self, Handle_Bnd_HArray1OfSphere theHandle) -> Handle_Bnd_HArray1OfSphere

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Bnd.Handle_Bnd_HArray1OfSphere_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Bnd_HArray1OfSphere self) -> Bnd_HArray1OfSphere

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Bnd.Handle_Bnd_HArray1OfSphere_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Bnd_HArray1OfSphere self) -> Bnd_HArray1OfSphere

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Bnd.Handle_Bnd_HArray1OfSphere___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Bnd_HArray1OfSphere self) -> Bnd_HArray1OfSphere

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Bnd.Handle_Bnd_HArray1OfSphere___ref__(self, *args)


    def __hash__(self):
        return _Bnd.Handle_Bnd_HArray1OfSphere___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Bnd.Handle_Bnd_HArray1OfSphere___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Bnd.new_Handle_Bnd_HArray1OfSphere(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Bnd.Handle_Bnd_HArray1OfSphere_DownCast)
    __swig_destroy__ = _Bnd.delete_Handle_Bnd_HArray1OfSphere

    def Array1(self, *args):
        """
        :rtype: OCC.wrapper.Bnd.Bnd_Array1OfSphere

        """
        res = _Bnd.Handle_Bnd_HArray1OfSphere_Array1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeArray1(self, *args):
        """
        ChangeArray1(Handle_Bnd_HArray1OfSphere self) -> NCollection_Array1_Bnd_Sphere

        :rtype: OCC.wrapper.Bnd.Bnd_Array1OfSphere

        """
        return _Bnd.Handle_Bnd_HArray1OfSphere_ChangeArray1(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Bnd_HArray1OfSphere self) -> char const *

        :rtype: const char *

        """
        return _Bnd.Handle_Bnd_HArray1OfSphere_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Bnd.Handle_Bnd_HArray1OfSphere_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Bnd.Handle_Bnd_HArray1OfSphere_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def begin(self, *args):
        """
        begin(Handle_Bnd_HArray1OfSphere self) -> NCollection_Array1< Bnd_Sphere >::iterator

        Returns an iterator pointing to the first element in the array.

        :rtype: iterator

        """
        return _Bnd.Handle_Bnd_HArray1OfSphere_begin(self, *args)


    def end(self, *args):
        """
        end(Handle_Bnd_HArray1OfSphere self) -> NCollection_Array1< Bnd_Sphere >::iterator

        Returns an iterator referring to the past-the-end element in the array.

        :rtype: iterator

        """
        return _Bnd.Handle_Bnd_HArray1OfSphere_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(Handle_Bnd_HArray1OfSphere self) -> NCollection_Array1< Bnd_Sphere >::const_iterator

        Returns a const iterator pointing to the first element in the array.

        :rtype: const_iterator

        """
        return _Bnd.Handle_Bnd_HArray1OfSphere_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(Handle_Bnd_HArray1OfSphere self) -> NCollection_Array1< Bnd_Sphere >::const_iterator

        Returns a const iterator referring to the past-the-end element in the array.

        :rtype: const_iterator

        """
        return _Bnd.Handle_Bnd_HArray1OfSphere_cend(self, *args)


    def Init(self, *args):
        """
        Init(Handle_Bnd_HArray1OfSphere self, Bnd_Sphere theValue)

        Initialise the items with theValue

        :type theValue: const TheItemType &

        """
        return _Bnd.Handle_Bnd_HArray1OfSphere_Init(self, *args)


    def Size(self, *args):
        """
        Size(Handle_Bnd_HArray1OfSphere self) -> Standard_Integer

        Size query

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Bnd.Handle_Bnd_HArray1OfSphere_Size(self, *args)


    def Length(self, *args):
        """
        Length(Handle_Bnd_HArray1OfSphere self) -> Standard_Integer

        Length query (the same)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Bnd.Handle_Bnd_HArray1OfSphere_Length(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(Handle_Bnd_HArray1OfSphere self) -> Standard_Boolean

        Return TRUE if array has zero length.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Bnd.Handle_Bnd_HArray1OfSphere_IsEmpty(self, *args)


    def Lower(self, *args):
        """
        Lower(Handle_Bnd_HArray1OfSphere self) -> Standard_Integer

        Lower bound

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Bnd.Handle_Bnd_HArray1OfSphere_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(Handle_Bnd_HArray1OfSphere self) -> Standard_Integer

        Upper bound

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Bnd.Handle_Bnd_HArray1OfSphere_Upper(self, *args)


    def IsDeletable(self, *args):
        """
        IsDeletable(Handle_Bnd_HArray1OfSphere self) -> Standard_Boolean

        myDeletable flag

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Bnd.Handle_Bnd_HArray1OfSphere_IsDeletable(self, *args)


    def IsAllocated(self, *args):
        """
        IsAllocated(Handle_Bnd_HArray1OfSphere self) -> Standard_Boolean

        IsAllocated flag - for naming compatibility

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Bnd.Handle_Bnd_HArray1OfSphere_IsAllocated(self, *args)


    def Assign(self, *args):
        """
        Assign(Handle_Bnd_HArray1OfSphere self, NCollection_Array1_Bnd_Sphere theOther) -> NCollection_Array1_Bnd_Sphere

        Copies data of theOther array to this.
        This array should be pre-allocated and have the same length as theOther;
        otherwise exception Standard_DimensionMismatch is thrown.

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _Bnd.Handle_Bnd_HArray1OfSphere_Assign(self, *args)


    def Move(self, *args):
        """
        Move(Handle_Bnd_HArray1OfSphere self, NCollection_Array1_Bnd_Sphere theOther) -> NCollection_Array1_Bnd_Sphere

        Move assignment.
        This array will borrow all the data from theOther.
        The moved object will keep pointer to the memory buffer and
        range, but it will not free the buffer on destruction.

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _Bnd.Handle_Bnd_HArray1OfSphere_Move(self, *args)


    def First(self, *args):
        """
        @return first element

        :rtype: const TheItemType &

        """
        res = _Bnd.Handle_Bnd_HArray1OfSphere_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(Handle_Bnd_HArray1OfSphere self) -> Bnd_Sphere

        @return first element

        :rtype: TheItemType &

        """
        return _Bnd.Handle_Bnd_HArray1OfSphere_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        @return last element

        :rtype: const TheItemType &

        """
        res = _Bnd.Handle_Bnd_HArray1OfSphere_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(Handle_Bnd_HArray1OfSphere self) -> Bnd_Sphere

        @return last element

        :rtype: TheItemType &

        """
        return _Bnd.Handle_Bnd_HArray1OfSphere_ChangeLast(self, *args)


    def Value(self, *args):
        """
        Constant value access

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _Bnd.Handle_Bnd_HArray1OfSphere_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __call__(self, *args):
        """
        operator() - alias to Value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _Bnd.Handle_Bnd_HArray1OfSphere___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __getitem__(self, *args):
        """
        operator[] - alias to Value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _Bnd.Handle_Bnd_HArray1OfSphere_at(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(Handle_Bnd_HArray1OfSphere self, Standard_Integer const theIndex) -> Bnd_Sphere

        Variable value access

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _Bnd.Handle_Bnd_HArray1OfSphere_ChangeValue(self, *args)


    def SetValue(self, *args):
        """
        SetValue(Handle_Bnd_HArray1OfSphere self, Standard_Integer const theIndex, Bnd_Sphere theItem)

        Set value 

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _Bnd.Handle_Bnd_HArray1OfSphere_SetValue(self, *args)


    def Resize(self, *args):
        """
        Resize(Handle_Bnd_HArray1OfSphere self, Standard_Integer const theLower, Standard_Integer const theUpper, Standard_Boolean const theToCopyData)

        Resizes the array to specified bounds.
        No re-allocation will be done if length of array does not change,
        but existing values will not be discarded if theToCopyData set to FALSE.
        @param theLower new lower bound of array
        @param theUpper new upper bound of array
        @param theToCopyData flag to copy existing data into new array

        :type theLower: int
        :type theUpper: int
        :type theToCopyData: bool

        """
        return _Bnd.Handle_Bnd_HArray1OfSphere_Resize(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_Bnd_HArray1OfSphere self)

        Memory deallocator for transient classes


        """
        return _Bnd.Handle_Bnd_HArray1OfSphere_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Bnd_HArray1OfSphere self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Bnd_HArray1OfSphere self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Bnd.Handle_Bnd_HArray1OfSphere_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Bnd_HArray1OfSphere self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Bnd_HArray1OfSphere self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Bnd.Handle_Bnd_HArray1OfSphere_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Bnd_HArray1OfSphere self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Bnd.Handle_Bnd_HArray1OfSphere_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Bnd_HArray1OfSphere self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Bnd.Handle_Bnd_HArray1OfSphere_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Bnd_HArray1OfSphere self)

        Increments the reference counter of this object


        """
        return _Bnd.Handle_Bnd_HArray1OfSphere_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Bnd_HArray1OfSphere self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Bnd.Handle_Bnd_HArray1OfSphere_DecrementRefCounter(self, *args)

Handle_Bnd_HArray1OfSphere_swigregister = _Bnd.Handle_Bnd_HArray1OfSphere_swigregister
Handle_Bnd_HArray1OfSphere_swigregister(Handle_Bnd_HArray1OfSphere)

def Handle_Bnd_HArray1OfSphere_DownCast(thing):
    return _Bnd.Handle_Bnd_HArray1OfSphere_DownCast(thing)
Handle_Bnd_HArray1OfSphere_DownCast = _Bnd.Handle_Bnd_HArray1OfSphere_DownCast




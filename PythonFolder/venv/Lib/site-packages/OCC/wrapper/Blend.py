# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_Blend')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_Blend')
    _Blend = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_Blend', [dirname(__file__)])
        except ImportError:
            import _Blend
            return _Blend
        try:
            _mod = imp.load_module('_Blend', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _Blend = swig_import_helper()
    del swig_import_helper
else:
    import _Blend
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


class SwigPyIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _Blend.delete_SwigPyIterator

    def value(self):
        return _Blend.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _Blend.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _Blend.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _Blend.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _Blend.SwigPyIterator_equal(self, x)

    def copy(self):
        return _Blend.SwigPyIterator_copy(self)

    def next(self):
        return _Blend.SwigPyIterator_next(self)

    def __next__(self):
        return _Blend.SwigPyIterator___next__(self)

    def previous(self):
        return _Blend.SwigPyIterator_previous(self)

    def advance(self, n):
        return _Blend.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _Blend.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _Blend.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _Blend.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _Blend.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _Blend.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _Blend.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self
SwigPyIterator_swigregister = _Blend.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

class NCollection_CellFilter_InspectorXYZ(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _Blend.NCollection_CellFilter_InspectorXYZ_Dimension
    Coord = staticmethod(_Blend.NCollection_CellFilter_InspectorXYZ_Coord)

    def Shift(self, thePnt, theTol):
        return _Blend.NCollection_CellFilter_InspectorXYZ_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _Blend.new_NCollection_CellFilter_InspectorXYZ()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _Blend.delete_NCollection_CellFilter_InspectorXYZ
NCollection_CellFilter_InspectorXYZ_swigregister = _Blend.NCollection_CellFilter_InspectorXYZ_swigregister
NCollection_CellFilter_InspectorXYZ_swigregister(NCollection_CellFilter_InspectorXYZ)

def NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt):
    return _Blend.NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt)
NCollection_CellFilter_InspectorXYZ_Coord = _Blend.NCollection_CellFilter_InspectorXYZ_Coord

class NCollection_CellFilter_InspectorXY(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _Blend.NCollection_CellFilter_InspectorXY_Dimension
    Coord = staticmethod(_Blend.NCollection_CellFilter_InspectorXY_Coord)

    def Shift(self, thePnt, theTol):
        return _Blend.NCollection_CellFilter_InspectorXY_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _Blend.new_NCollection_CellFilter_InspectorXY()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _Blend.delete_NCollection_CellFilter_InspectorXY
NCollection_CellFilter_InspectorXY_swigregister = _Blend.NCollection_CellFilter_InspectorXY_swigregister
NCollection_CellFilter_InspectorXY_swigregister(NCollection_CellFilter_InspectorXY)

def NCollection_CellFilter_InspectorXY_Coord(i, thePnt):
    return _Blend.NCollection_CellFilter_InspectorXY_Coord(i, thePnt)
NCollection_CellFilter_InspectorXY_Coord = _Blend.NCollection_CellFilter_InspectorXY_Coord


def ptr_to_number(item):
    return _Blend.ptr_to_number(item)
ptr_to_number = _Blend.ptr_to_number

def HashCode(*args):
    return _Blend.HashCode(*args)
HashCode = _Blend.HashCode

def ptr_equal(a, b):
    return _Blend.ptr_equal(a, b)
ptr_equal = _Blend.ptr_equal
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import NCollection
else:
    import NCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Standard
else:
    import Standard
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import GeomAbs
else:
    import GeomAbs
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColStd
else:
    import TColStd
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TCollection
else:
    import TCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import gp
else:
    import gp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColgp
else:
    import TColgp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Adaptor2d
else:
    import Adaptor2d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Geom2d
else:
    import Geom2d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import math
else:
    import math
del _swig_python_version_info
Blend_NoDecroch = _Blend.Blend_NoDecroch
Blend_DecrochRst1 = _Blend.Blend_DecrochRst1
Blend_DecrochRst2 = _Blend.Blend_DecrochRst2
Blend_DecrochBoth = _Blend.Blend_DecrochBoth
Blend_StepTooLarge = _Blend.Blend_StepTooLarge
Blend_StepTooSmall = _Blend.Blend_StepTooSmall
Blend_Backward = _Blend.Blend_Backward
Blend_SamePoints = _Blend.Blend_SamePoints
Blend_OnRst1 = _Blend.Blend_OnRst1
Blend_OnRst2 = _Blend.Blend_OnRst2
Blend_OnRst12 = _Blend.Blend_OnRst12
Blend_OK = _Blend.Blend_OK
class Blend_AppFunction(math.math_FunctionSetWithDerivatives):
    """
    Deferred class for a function used to compute a blending
    surface between two surfaces, using a guide line.
    The vector <X> used in Value, Values and Derivatives methods
    has to be the vector of the parametric coordinates U1,V1,
    U2,V2, of the extremities of a section on the first and
    second surface.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def NbVariables(self, *args):
        """
        NbVariables(Blend_AppFunction self) -> Standard_Integer

        returns the number of variables of the function.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Blend.Blend_AppFunction_NbVariables(self, *args)


    def NbEquations(self, *args):
        """
        NbEquations(Blend_AppFunction self) -> Standard_Integer

        returns the number of equations of the function.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Blend.Blend_AppFunction_NbEquations(self, *args)


    def Value(self, *args):
        """
        Value(Blend_AppFunction self, math_Vector X, math_Vector F) -> Standard_Boolean

        computes the values <F> of the Functions for the
        variable <X>.
        Returns True if the computation was done successfully,
        False otherwise.

        :type X: OCC.wrapper.math.math_Vector
        :type F: OCC.wrapper.math.math_Vector
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Blend.Blend_AppFunction_Value(self, *args)


    def Derivatives(self, *args):
        """
        Derivatives(Blend_AppFunction self, math_Vector X, math_Matrix D) -> Standard_Boolean

        returns the values <D> of the derivatives for the
        variable <X>.
        Returns True if the computation was done successfully,
        False otherwise.

        :type X: OCC.wrapper.math.math_Vector
        :type D: OCC.wrapper.math.math_Matrix
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Blend.Blend_AppFunction_Derivatives(self, *args)


    def Values(self, *args):
        """
        Values(Blend_AppFunction self, math_Vector X, math_Vector F, math_Matrix D) -> Standard_Boolean

        returns the values <F> of the functions and the derivatives
        <D> for the variable <X>.
        Returns True if the computation was done successfully,
        False otherwise.

        :type X: OCC.wrapper.math.math_Vector
        :type F: OCC.wrapper.math.math_Vector
        :type D: OCC.wrapper.math.math_Matrix
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Blend.Blend_AppFunction_Values(self, *args)


    def Set(self, *args):
        """
        Set(Blend_AppFunction self, Standard_Real const Param)
        Set(Blend_AppFunction self, Standard_Real const First, Standard_Real const Last)

        Sets the bounds of the parametric interval on
        the guide line.
        This determines the derivatives in these values if the
        function is not Cn.

        :type First: float
        :type Last: float

        """
        return _Blend.Blend_AppFunction_Set(self, *args)


    def GetBounds(self, *args):
        """
        GetBounds(Blend_AppFunction self, math_Vector InfBound, math_Vector SupBound)

        Returns in the vector InfBound the lowest values allowed
        for each of the 4 variables.
        Returns in the vector SupBound the greatest values allowed
        for each of the 4 variables.

        :type InfBound: OCC.wrapper.math.math_Vector
        :type SupBound: OCC.wrapper.math.math_Vector

        """
        return _Blend.Blend_AppFunction_GetBounds(self, *args)


    def IsSolution(self, *args):
        """
        IsSolution(Blend_AppFunction self, math_Vector Sol, Standard_Real const Tol) -> Standard_Boolean

        Returns Standard_True if Sol is a zero of the function.
        Tol is the tolerance used in 3d space.
        The computation is made at the current value of
        the parameter on the guide line.

        :type Sol: OCC.wrapper.math.math_Vector
        :type Tol: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Blend.Blend_AppFunction_IsSolution(self, *args)


    def GetMinimalDistance(self, *args):
        """
        GetMinimalDistance(Blend_AppFunction self) -> Standard_Real

        Returns   the    minimal  Distance  beetween   two
        extremitys of calculed sections.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Blend.Blend_AppFunction_GetMinimalDistance(self, *args)


    def Pnt1(self, *args):
        """
        Returns the point on the first support.

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        res = _Blend.Blend_AppFunction_Pnt1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Pnt2(self, *args):
        """
        Returns the point on the first support.

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        res = _Blend.Blend_AppFunction_Pnt2(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def IsRational(self, *args):
        """
        IsRational(Blend_AppFunction self) -> Standard_Boolean

        Returns  if the section is rationnal

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Blend.Blend_AppFunction_IsRational(self, *args)


    def GetSectionSize(self, *args):
        """
        GetSectionSize(Blend_AppFunction self) -> Standard_Real

        Returns the length of the maximum section

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Blend.Blend_AppFunction_GetSectionSize(self, *args)


    def GetMinimalWeight(self, *args):
        """
        GetMinimalWeight(Blend_AppFunction self, NCollection_Array1_Standard_Real Weigths)

        Compute the minimal value of weight for each poles
        of all sections.

        :type Weigths: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        return _Blend.Blend_AppFunction_GetMinimalWeight(self, *args)


    def NbIntervals(self, *args):
        """
        NbIntervals(Blend_AppFunction self, GeomAbs_Shape const S) -> Standard_Integer

        Returns  the number  of  intervals for  continuity
        <S>. May be one if Continuity(me) >= <S>

        :type S: OCC.wrapper.GeomAbs.GeomAbs_Shape
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Blend.Blend_AppFunction_NbIntervals(self, *args)


    def Intervals(self, *args):
        """
        Intervals(Blend_AppFunction self, NCollection_Array1_Standard_Real T, GeomAbs_Shape const S)

        Stores in <T> the  parameters bounding the intervals
        of continuity <S>.

        The array must provide  enough room to  accomodate
        for the parameters. i.e. T.Length() > NbIntervals()
        raises
        OutOfRange from Standard

        :type T: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type S: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _Blend.Blend_AppFunction_Intervals(self, *args)


    def GetShape(self, *args):
        """
        GetShape(Blend_AppFunction self)

        :type NbPoles: int
        :type NbKnots: int
        :type Degree: int
        :type NbPoles2d: int

        """
        return _Blend.Blend_AppFunction_GetShape(self, *args)


    def GetTolerance(self, *args):
        """
        GetTolerance(Blend_AppFunction self, math_Vector Tolerance, Standard_Real const Tol)
        GetTolerance(Blend_AppFunction self, Standard_Real const BoundTol, Standard_Real const SurfTol, Standard_Real const AngleTol, math_Vector Tol3d, math_Vector Tol1D)

        Returns the tolerance to reach in approximation
        to respecte
        BoundTol error at the Boundary
        AngleTol tangent error at the Boundary
        SurfTol error inside the surface.

        :type BoundTol: float
        :type SurfTol: float
        :type AngleTol: float
        :type Tol3d: OCC.wrapper.math.math_Vector
        :type Tol1D: OCC.wrapper.math.math_Vector

        """
        return _Blend.Blend_AppFunction_GetTolerance(self, *args)


    def Knots(self, *args):
        """
        Knots(Blend_AppFunction self, NCollection_Array1_Standard_Real TKnots)

        :type TKnots: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        return _Blend.Blend_AppFunction_Knots(self, *args)


    def Mults(self, *args):
        """
        Mults(Blend_AppFunction self, NCollection_Array1_Standard_Integer TMults)

        :type TMults: OCC.wrapper.TColStd.TColStd_Array1OfInteger

        """
        return _Blend.Blend_AppFunction_Mults(self, *args)


    def Section(self, *args):
        """
        Section(Blend_AppFunction self, Blend_Point P, NCollection_Array1_gp_Pnt Poles, NCollection_Array1_gp_Vec DPoles, NCollection_Array1_gp_Pnt2d Poles2d, NCollection_Array1_gp_Vec2d DPoles2d, NCollection_Array1_Standard_Real Weigths, NCollection_Array1_Standard_Real DWeigths) -> Standard_Boolean
        Section(Blend_AppFunction self, Blend_Point P, NCollection_Array1_gp_Pnt Poles, NCollection_Array1_gp_Pnt2d Poles2d, NCollection_Array1_Standard_Real Weigths)
        Section(Blend_AppFunction self, Blend_Point P, NCollection_Array1_gp_Pnt Poles, NCollection_Array1_gp_Vec DPoles, NCollection_Array1_gp_Vec D2Poles, NCollection_Array1_gp_Pnt2d Poles2d, NCollection_Array1_gp_Vec2d DPoles2d, NCollection_Array1_gp_Vec2d D2Poles2d, NCollection_Array1_Standard_Real Weigths, NCollection_Array1_Standard_Real DWeigths, NCollection_Array1_Standard_Real D2Weigths) -> Standard_Boolean

        Used for the first and last section
        The method returns Standard_True if the derivatives
        are computed, otherwise it returns Standard_False.

        :type P: OCC.wrapper.Blend.Blend_Point
        :type Poles: OCC.wrapper.TColgp.TColgp_Array1OfPnt
        :type DPoles: OCC.wrapper.TColgp.TColgp_Array1OfVec
        :type D2Poles: OCC.wrapper.TColgp.TColgp_Array1OfVec
        :type Poles2d: OCC.wrapper.TColgp.TColgp_Array1OfPnt2d
        :type DPoles2d: OCC.wrapper.TColgp.TColgp_Array1OfVec2d
        :type D2Poles2d: OCC.wrapper.TColgp.TColgp_Array1OfVec2d
        :type Weigths: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type DWeigths: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type D2Weigths: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Blend.Blend_AppFunction_Section(self, *args)


    def Resolution(self, *args):
        """
        Resolution(Blend_AppFunction self, Standard_Integer const IC2d, Standard_Real const Tol)

        :type IC2d: int
        :type Tol: float
        :type TolU: float
        :type TolV: float

        """
        return _Blend.Blend_AppFunction_Resolution(self, *args)


    def Parameter(self, *args):
        """
        Parameter(Blend_AppFunction self, Blend_Point P) -> Standard_Real

        Returns  the parameter  of  the point  P. Used  to
        impose the parameters in the approximation.

        :type P: OCC.wrapper.Blend.Blend_Point
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Blend.Blend_AppFunction_Parameter(self, *args)

    __swig_destroy__ = _Blend.delete_Blend_AppFunction
Blend_AppFunction_swigregister = _Blend.Blend_AppFunction_swigregister
Blend_AppFunction_swigregister(Blend_AppFunction)

class Blend_SurfPointFuncInv(math.math_FunctionSetWithDerivatives):
    """
    Deferred   class  for a  function  used  to compute  a
    blending surface between a  surface and a curve, using
    a  guide  line.   This   function is  used  to find  a
    solution on a done point of the curve.

    The vector <X>  used in Value, Values and  Derivatives
    methods  has  to   be the  vector   of the  parametric
    coordinates w, U,  V where w is  the parameter  on the
    guide line, U,V   are the parametric coordinates of  a
    point on the partner surface.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def NbVariables(self, *args):
        """
        NbVariables(Blend_SurfPointFuncInv self) -> Standard_Integer

        Returns 3.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Blend.Blend_SurfPointFuncInv_NbVariables(self, *args)


    def NbEquations(self, *args):
        """
        NbEquations(Blend_SurfPointFuncInv self) -> Standard_Integer

        returns the number of equations of the function.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Blend.Blend_SurfPointFuncInv_NbEquations(self, *args)


    def Value(self, *args):
        """
        Value(Blend_SurfPointFuncInv self, math_Vector X, math_Vector F) -> Standard_Boolean

        computes the values <F> of the Functions for the
        variable <X>.
        Returns True if the computation was done successfully,
        False otherwise.

        :type X: OCC.wrapper.math.math_Vector
        :type F: OCC.wrapper.math.math_Vector
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Blend.Blend_SurfPointFuncInv_Value(self, *args)


    def Derivatives(self, *args):
        """
        Derivatives(Blend_SurfPointFuncInv self, math_Vector X, math_Matrix D) -> Standard_Boolean

        returns the values <D> of the derivatives for the
        variable <X>.
        Returns True if the computation was done successfully,
        False otherwise.

        :type X: OCC.wrapper.math.math_Vector
        :type D: OCC.wrapper.math.math_Matrix
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Blend.Blend_SurfPointFuncInv_Derivatives(self, *args)


    def Values(self, *args):
        """
        Values(Blend_SurfPointFuncInv self, math_Vector X, math_Vector F, math_Matrix D) -> Standard_Boolean

        returns the values <F> of the functions and the derivatives
        <D> for the variable <X>.
        Returns True if the computation was done successfully,
        False otherwise.

        :type X: OCC.wrapper.math.math_Vector
        :type F: OCC.wrapper.math.math_Vector
        :type D: OCC.wrapper.math.math_Matrix
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Blend.Blend_SurfPointFuncInv_Values(self, *args)


    def Set(self, *args):
        """
        Set(Blend_SurfPointFuncInv self, gp_Pnt P)

        Set the Point on which a solution has to be found.

        :type P: OCC.wrapper.gp.gp_Pnt

        """
        return _Blend.Blend_SurfPointFuncInv_Set(self, *args)


    def GetTolerance(self, *args):
        """
        GetTolerance(Blend_SurfPointFuncInv self, math_Vector Tolerance, Standard_Real const Tol)

        Returns in the vector Tolerance the parametric tolerance
        for each of the 3 variables;
        Tol is the tolerance used in 3d space.

        :type Tolerance: OCC.wrapper.math.math_Vector
        :type Tol: float

        """
        return _Blend.Blend_SurfPointFuncInv_GetTolerance(self, *args)


    def GetBounds(self, *args):
        """
        GetBounds(Blend_SurfPointFuncInv self, math_Vector InfBound, math_Vector SupBound)

        Returns in the vector InfBound the lowest values allowed
        for each of the 3 variables.
        Returns in the vector SupBound the greatest values allowed
        for each of the 3 variables.

        :type InfBound: OCC.wrapper.math.math_Vector
        :type SupBound: OCC.wrapper.math.math_Vector

        """
        return _Blend.Blend_SurfPointFuncInv_GetBounds(self, *args)


    def IsSolution(self, *args):
        """
        IsSolution(Blend_SurfPointFuncInv self, math_Vector Sol, Standard_Real const Tol) -> Standard_Boolean

        Returns Standard_True if Sol is a zero of the function.
        Tol is the tolerance used in 3d space.

        :type Sol: OCC.wrapper.math.math_Vector
        :type Tol: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Blend.Blend_SurfPointFuncInv_IsSolution(self, *args)

    __swig_destroy__ = _Blend.delete_Blend_SurfPointFuncInv
Blend_SurfPointFuncInv_swigregister = _Blend.Blend_SurfPointFuncInv_swigregister
Blend_SurfPointFuncInv_swigregister(Blend_SurfPointFuncInv)

class Blend_SurfCurvFuncInv(math.math_FunctionSetWithDerivatives):
    """
    Deferred   class  for a  function  used  to compute  a
    blending surface between a  surface and a curve, using
    a  guide  line.   This   function is  used  to find  a
    solution on a done restriction of the surface.

    The vector  <X> used in  Value, Values and Derivatives
    methods  has   to  be the   vector  of  the parametric
    coordinates  wguide, wcurv, wrst  where  wguide is the
    parameter on the guide line, wcurv is the parameter on
    the curve, wrst is the parameter on the restriction on
    the surface.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def NbVariables(self, *args):
        """
        NbVariables(Blend_SurfCurvFuncInv self) -> Standard_Integer

        Returns 3.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Blend.Blend_SurfCurvFuncInv_NbVariables(self, *args)


    def NbEquations(self, *args):
        """
        NbEquations(Blend_SurfCurvFuncInv self) -> Standard_Integer

        returns the number of equations of the function.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Blend.Blend_SurfCurvFuncInv_NbEquations(self, *args)


    def Value(self, *args):
        """
        Value(Blend_SurfCurvFuncInv self, math_Vector X, math_Vector F) -> Standard_Boolean

        computes the values <F> of the Functions for the
        variable <X>.
        Returns True if the computation was done successfully,
        False otherwise.

        :type X: OCC.wrapper.math.math_Vector
        :type F: OCC.wrapper.math.math_Vector
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Blend.Blend_SurfCurvFuncInv_Value(self, *args)


    def Derivatives(self, *args):
        """
        Derivatives(Blend_SurfCurvFuncInv self, math_Vector X, math_Matrix D) -> Standard_Boolean

        returns the values <D> of the derivatives for the
        variable <X>.
        Returns True if the computation was done successfully,
        False otherwise.

        :type X: OCC.wrapper.math.math_Vector
        :type D: OCC.wrapper.math.math_Matrix
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Blend.Blend_SurfCurvFuncInv_Derivatives(self, *args)


    def Values(self, *args):
        """
        Values(Blend_SurfCurvFuncInv self, math_Vector X, math_Vector F, math_Matrix D) -> Standard_Boolean

        returns the values <F> of the functions and the derivatives
        <D> for the variable <X>.
        Returns True if the computation was done successfully,
        False otherwise.

        :type X: OCC.wrapper.math.math_Vector
        :type F: OCC.wrapper.math.math_Vector
        :type D: OCC.wrapper.math.math_Matrix
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Blend.Blend_SurfCurvFuncInv_Values(self, *args)


    def Set(self, *args):
        """
        Set(Blend_SurfCurvFuncInv self, Handle_Adaptor2d_HCurve2d Rst)

        Set the Point on which a solution has to be found.

        :type Rst: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d

        """
        return _Blend.Blend_SurfCurvFuncInv_Set(self, *args)


    def GetTolerance(self, *args):
        """
        GetTolerance(Blend_SurfCurvFuncInv self, math_Vector Tolerance, Standard_Real const Tol)

        Returns in the vector Tolerance the parametric tolerance
        for each of the 3 variables;
        Tol is the tolerance used in 3d space.

        :type Tolerance: OCC.wrapper.math.math_Vector
        :type Tol: float

        """
        return _Blend.Blend_SurfCurvFuncInv_GetTolerance(self, *args)


    def GetBounds(self, *args):
        """
        GetBounds(Blend_SurfCurvFuncInv self, math_Vector InfBound, math_Vector SupBound)

        Returns in the vector InfBound the lowest values allowed
        for each of the 3 variables.
        Returns in the vector SupBound the greatest values allowed
        for each of the 3 variables.

        :type InfBound: OCC.wrapper.math.math_Vector
        :type SupBound: OCC.wrapper.math.math_Vector

        """
        return _Blend.Blend_SurfCurvFuncInv_GetBounds(self, *args)


    def IsSolution(self, *args):
        """
        IsSolution(Blend_SurfCurvFuncInv self, math_Vector Sol, Standard_Real const Tol) -> Standard_Boolean

        Returns Standard_True if Sol is a zero of the function.
        Tol is the tolerance used in 3d space.

        :type Sol: OCC.wrapper.math.math_Vector
        :type Tol: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Blend.Blend_SurfCurvFuncInv_IsSolution(self, *args)

    __swig_destroy__ = _Blend.delete_Blend_SurfCurvFuncInv
Blend_SurfCurvFuncInv_swigregister = _Blend.Blend_SurfCurvFuncInv_swigregister
Blend_SurfCurvFuncInv_swigregister(Blend_SurfCurvFuncInv)

class Blend_Point(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Blend_Point self) -> Blend_Point
        __init__(Blend_Point self, gp_Pnt Pt1, gp_Pnt Pt2, Standard_Real const Param, Standard_Real const U1, Standard_Real const V1, Standard_Real const U2, Standard_Real const V2, gp_Vec Tg1, gp_Vec Tg2, gp_Vec2d Tg12d, gp_Vec2d Tg22d) -> Blend_Point
        __init__(Blend_Point self, gp_Pnt Pt1, gp_Pnt Pt2, Standard_Real const Param, Standard_Real const U1, Standard_Real const V1, Standard_Real const U2, Standard_Real const V2) -> Blend_Point
        __init__(Blend_Point self, gp_Pnt Pts, gp_Pnt Ptc, Standard_Real const Param, Standard_Real const U, Standard_Real const V, Standard_Real const W, gp_Vec Tgs, gp_Vec Tgc, gp_Vec2d Tg2d) -> Blend_Point
        __init__(Blend_Point self, gp_Pnt Pts, gp_Pnt Ptc, Standard_Real const Param, Standard_Real const U, Standard_Real const V, Standard_Real const W) -> Blend_Point
        __init__(Blend_Point self, gp_Pnt Pt1, gp_Pnt Pt2, Standard_Real const Param, Standard_Real const U1, Standard_Real const V1, Standard_Real const U2, Standard_Real const V2, Standard_Real const PC, gp_Vec Tg1, gp_Vec Tg2, gp_Vec2d Tg12d, gp_Vec2d Tg22d) -> Blend_Point
        __init__(Blend_Point self, gp_Pnt Pt1, gp_Pnt Pt2, Standard_Real const Param, Standard_Real const U1, Standard_Real const V1, Standard_Real const U2, Standard_Real const V2, Standard_Real const PC) -> Blend_Point
        __init__(Blend_Point self, gp_Pnt Pt1, gp_Pnt Pt2, Standard_Real const Param, Standard_Real const U1, Standard_Real const V1, Standard_Real const U2, Standard_Real const V2, Standard_Real const PC1, Standard_Real const PC2, gp_Vec Tg1, gp_Vec Tg2, gp_Vec2d Tg12d, gp_Vec2d Tg22d) -> Blend_Point
        __init__(Blend_Point self, gp_Pnt Pt1, gp_Pnt Pt2, Standard_Real const Param, Standard_Real const U1, Standard_Real const V1, Standard_Real const U2, Standard_Real const V2, Standard_Real const PC1, Standard_Real const PC2) -> Blend_Point

        Creates a point on two curves on surfaces, with tangents.

        :type Pt1: OCC.wrapper.gp.gp_Pnt
        :type Pt2: OCC.wrapper.gp.gp_Pnt
        :type Param: float
        :type U1: float
        :type V1: float
        :type U2: float
        :type V2: float
        :type PC1: float
        :type PC2: float

        """
        this = _Blend.new_Blend_Point(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def SetValue(self, *args):
        """
        SetValue(Blend_Point self, gp_Pnt Pt1, gp_Pnt Pt2, Standard_Real const Param, Standard_Real const U1, Standard_Real const V1, Standard_Real const U2, Standard_Real const V2, gp_Vec Tg1, gp_Vec Tg2, gp_Vec2d Tg12d, gp_Vec2d Tg22d)
        SetValue(Blend_Point self, gp_Pnt Pt1, gp_Pnt Pt2, Standard_Real const Param, Standard_Real const U1, Standard_Real const V1, Standard_Real const U2, Standard_Real const V2)
        SetValue(Blend_Point self, gp_Pnt Pts, gp_Pnt Ptc, Standard_Real const Param, Standard_Real const U, Standard_Real const V, Standard_Real const W, gp_Vec Tgs, gp_Vec Tgc, gp_Vec2d Tg2d)
        SetValue(Blend_Point self, gp_Pnt Pts, gp_Pnt Ptc, Standard_Real const Param, Standard_Real const U, Standard_Real const V, Standard_Real const W)
        SetValue(Blend_Point self, gp_Pnt Pt1, gp_Pnt Pt2, Standard_Real const Param, Standard_Real const U1, Standard_Real const V1, Standard_Real const U2, Standard_Real const V2, Standard_Real const PC, gp_Vec Tg1, gp_Vec Tg2, gp_Vec2d Tg12d, gp_Vec2d Tg22d)
        SetValue(Blend_Point self, gp_Pnt Pt1, gp_Pnt Pt2, Standard_Real const Param, Standard_Real const U1, Standard_Real const V1, Standard_Real const U2, Standard_Real const V2, Standard_Real const PC)
        SetValue(Blend_Point self, gp_Pnt Pt1, gp_Pnt Pt2, Standard_Real const Param, Standard_Real const U1, Standard_Real const V1, Standard_Real const U2, Standard_Real const V2, Standard_Real const PC1, Standard_Real const PC2, gp_Vec Tg1, gp_Vec Tg2, gp_Vec2d Tg12d, gp_Vec2d Tg22d)
        SetValue(Blend_Point self, gp_Pnt Pt1, gp_Pnt Pt2, Standard_Real const Param, Standard_Real const U1, Standard_Real const V1, Standard_Real const U2, Standard_Real const V2, Standard_Real const PC1, Standard_Real const PC2)
        SetValue(Blend_Point self, gp_Pnt Pt1, gp_Pnt Pt2, Standard_Real const Param, Standard_Real const PC1, Standard_Real const PC2)

        Creates a point on two curves.

        :type Pt1: OCC.wrapper.gp.gp_Pnt
        :type Pt2: OCC.wrapper.gp.gp_Pnt
        :type Param: float
        :type PC1: float
        :type PC2: float

        """
        return _Blend.Blend_Point_SetValue(self, *args)


    def SetParameter(self, *args):
        """
        SetParameter(Blend_Point self, Standard_Real const Param)

        Changes parameter on existing point

        :type Param: float

        """
        return _Blend.Blend_Point_SetParameter(self, *args)


    def Parameter(self, *args):
        """
        Parameter(Blend_Point self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Blend.Blend_Point_Parameter(self, *args)


    def IsTangencyPoint(self, *args):
        """
        IsTangencyPoint(Blend_Point self) -> Standard_Boolean

        Returns Standard_True if it was not possible to compute
        the tangent vectors at PointOnS1 and/or PointOnS2.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Blend.Blend_Point_IsTangencyPoint(self, *args)


    def PointOnS1(self, *args):
        """
        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        res = _Blend.Blend_Point_PointOnS1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def PointOnS2(self, *args):
        """
        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        res = _Blend.Blend_Point_PointOnS2(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ParametersOnS1(self, *args):
        """
        ParametersOnS1(Blend_Point self)

        :type U: float
        :type V: float

        """
        return _Blend.Blend_Point_ParametersOnS1(self, *args)


    def ParametersOnS2(self, *args):
        """
        ParametersOnS2(Blend_Point self)

        :type U: float
        :type V: float

        """
        return _Blend.Blend_Point_ParametersOnS2(self, *args)


    def TangentOnS1(self, *args):
        """
        :rtype: OCC.wrapper.gp.gp_Vec

        """
        res = _Blend.Blend_Point_TangentOnS1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def TangentOnS2(self, *args):
        """
        :rtype: OCC.wrapper.gp.gp_Vec

        """
        res = _Blend.Blend_Point_TangentOnS2(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Tangent2dOnS1(self, *args):
        """
        Tangent2dOnS1(Blend_Point self) -> gp_Vec2d

        :rtype: OCC.wrapper.gp.gp_Vec2d

        """
        return _Blend.Blend_Point_Tangent2dOnS1(self, *args)


    def Tangent2dOnS2(self, *args):
        """
        Tangent2dOnS2(Blend_Point self) -> gp_Vec2d

        :rtype: OCC.wrapper.gp.gp_Vec2d

        """
        return _Blend.Blend_Point_Tangent2dOnS2(self, *args)


    def PointOnS(self, *args):
        """
        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        res = _Blend.Blend_Point_PointOnS(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def PointOnC(self, *args):
        """
        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        res = _Blend.Blend_Point_PointOnC(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ParametersOnS(self, *args):
        """
        ParametersOnS(Blend_Point self)

        :type U: float
        :type V: float

        """
        return _Blend.Blend_Point_ParametersOnS(self, *args)


    def ParameterOnC(self, *args):
        """
        ParameterOnC(Blend_Point self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Blend.Blend_Point_ParameterOnC(self, *args)


    def TangentOnS(self, *args):
        """
        :rtype: OCC.wrapper.gp.gp_Vec

        """
        res = _Blend.Blend_Point_TangentOnS(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def TangentOnC(self, *args):
        """
        :rtype: OCC.wrapper.gp.gp_Vec

        """
        res = _Blend.Blend_Point_TangentOnC(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Tangent2d(self, *args):
        """
        Tangent2d(Blend_Point self) -> gp_Vec2d

        :rtype: OCC.wrapper.gp.gp_Vec2d

        """
        return _Blend.Blend_Point_Tangent2d(self, *args)


    def PointOnC1(self, *args):
        """
        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        res = _Blend.Blend_Point_PointOnC1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def PointOnC2(self, *args):
        """
        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        res = _Blend.Blend_Point_PointOnC2(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ParameterOnC1(self, *args):
        """
        ParameterOnC1(Blend_Point self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Blend.Blend_Point_ParameterOnC1(self, *args)


    def ParameterOnC2(self, *args):
        """
        ParameterOnC2(Blend_Point self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Blend.Blend_Point_ParameterOnC2(self, *args)


    def TangentOnC1(self, *args):
        """
        :rtype: OCC.wrapper.gp.gp_Vec

        """
        res = _Blend.Blend_Point_TangentOnC1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def TangentOnC2(self, *args):
        """
        :rtype: OCC.wrapper.gp.gp_Vec

        """
        res = _Blend.Blend_Point_TangentOnC2(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Blend.delete_Blend_Point
Blend_Point_swigregister = _Blend.Blend_Point_swigregister
Blend_Point_swigregister(Blend_Point)

class Blend_CSFunction(Blend_AppFunction):
    """
    Deferred class for a function used to compute a blending
    surface between a surface and a curve, using a guide line.
    The vector <X> used in Value, Values and Derivatives methods
    may be the vector of the parametric coordinates U,V,
    W of the extremities of a section on the surface  and
    the curve.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def NbVariables(self, *args):
        """
        NbVariables(Blend_CSFunction self) -> Standard_Integer

        Returns 3 (default value). Can be redefined.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Blend.Blend_CSFunction_NbVariables(self, *args)


    def NbEquations(self, *args):
        """
        NbEquations(Blend_CSFunction self) -> Standard_Integer

        returns the number of equations of the function.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Blend.Blend_CSFunction_NbEquations(self, *args)


    def Value(self, *args):
        """
        Value(Blend_CSFunction self, math_Vector X, math_Vector F) -> Standard_Boolean

        computes the values <F> of the Functions for the
        variable <X>.
        Returns True if the computation was done successfully,
        False otherwise.

        :type X: OCC.wrapper.math.math_Vector
        :type F: OCC.wrapper.math.math_Vector
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Blend.Blend_CSFunction_Value(self, *args)


    def Derivatives(self, *args):
        """
        Derivatives(Blend_CSFunction self, math_Vector X, math_Matrix D) -> Standard_Boolean

        returns the values <D> of the derivatives for the
        variable <X>.
        Returns True if the computation was done successfully,
        False otherwise.

        :type X: OCC.wrapper.math.math_Vector
        :type D: OCC.wrapper.math.math_Matrix
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Blend.Blend_CSFunction_Derivatives(self, *args)


    def Values(self, *args):
        """
        Values(Blend_CSFunction self, math_Vector X, math_Vector F, math_Matrix D) -> Standard_Boolean

        returns the values <F> of the functions and the derivatives
        <D> for the variable <X>.
        Returns True if the computation was done successfully,
        False otherwise.

        :type X: OCC.wrapper.math.math_Vector
        :type F: OCC.wrapper.math.math_Vector
        :type D: OCC.wrapper.math.math_Matrix
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Blend.Blend_CSFunction_Values(self, *args)


    def Set(self, *args):
        """
        Set(Blend_CSFunction self, Standard_Real const Param)
        Set(Blend_CSFunction self, Standard_Real const First, Standard_Real const Last)

        Sets the bounds of the parametric interval on
        the guide line.
        This determines the derivatives in these values if the
        function is not Cn.

        :type First: float
        :type Last: float

        """
        return _Blend.Blend_CSFunction_Set(self, *args)


    def GetBounds(self, *args):
        """
        GetBounds(Blend_CSFunction self, math_Vector InfBound, math_Vector SupBound)

        Returns in the vector InfBound the lowest values allowed
        for each of the 3 variables.
        Returns in the vector SupBound the greatest values allowed
        for each of the 3 variables.

        :type InfBound: OCC.wrapper.math.math_Vector
        :type SupBound: OCC.wrapper.math.math_Vector

        """
        return _Blend.Blend_CSFunction_GetBounds(self, *args)


    def IsSolution(self, *args):
        """
        IsSolution(Blend_CSFunction self, math_Vector Sol, Standard_Real const Tol) -> Standard_Boolean

        Returns Standard_True if Sol is a zero of the function.
        Tol is the tolerance used in 3d space.
        The computation is made at the current value of
        the parameter on the guide line.

        :type Sol: OCC.wrapper.math.math_Vector
        :type Tol: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Blend.Blend_CSFunction_IsSolution(self, *args)


    def GetMinimalDistance(self, *args):
        """
        GetMinimalDistance(Blend_CSFunction self) -> Standard_Real

        Returns   the    minimal  Distance  beetween   two
        extremitys of calculed sections.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Blend.Blend_CSFunction_GetMinimalDistance(self, *args)


    def Pnt1(self, *args):
        """
        Returns the point on the first support.

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        res = _Blend.Blend_CSFunction_Pnt1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Pnt2(self, *args):
        """
        Returns the point on the seconde support.

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        res = _Blend.Blend_CSFunction_Pnt2(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def PointOnS(self, *args):
        """
        Returns the point on the surface.

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        res = _Blend.Blend_CSFunction_PointOnS(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def PointOnC(self, *args):
        """
        Returns the point on the curve.

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        res = _Blend.Blend_CSFunction_PointOnC(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Pnt2d(self, *args):
        """
        Returns U,V coordinates of the point on the surface.

        :rtype: OCC.wrapper.gp.gp_Pnt2d

        """
        res = _Blend.Blend_CSFunction_Pnt2d(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ParameterOnC(self, *args):
        """
        ParameterOnC(Blend_CSFunction self) -> Standard_Real

        Returns parameter of the point on the curve.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Blend.Blend_CSFunction_ParameterOnC(self, *args)


    def IsTangencyPoint(self, *args):
        """
        IsTangencyPoint(Blend_CSFunction self) -> Standard_Boolean

        Returns True when it is not possible to compute
        the tangent vectors at PointOnS and/or PointOnC.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Blend.Blend_CSFunction_IsTangencyPoint(self, *args)


    def TangentOnS(self, *args):
        """
        Returns the tangent vector at PointOnS, in 3d space.

        :rtype: OCC.wrapper.gp.gp_Vec

        """
        res = _Blend.Blend_CSFunction_TangentOnS(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Tangent2d(self, *args):
        """
        Returns the tangent vector at PointOnS, in the
        parametric space of the first surface.

        :rtype: OCC.wrapper.gp.gp_Vec2d

        """
        res = _Blend.Blend_CSFunction_Tangent2d(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def TangentOnC(self, *args):
        """
        Returns the tangent vector at PointOnC, in 3d space.

        :rtype: OCC.wrapper.gp.gp_Vec

        """
        res = _Blend.Blend_CSFunction_TangentOnC(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Tangent(self, *args):
        """
        Tangent(Blend_CSFunction self, Standard_Real const U, Standard_Real const V, gp_Vec TgS, gp_Vec NormS)

        Returns the tangent vector at the section,
        at the beginning and the end of the section, and
        returns the normal (of the surfaces) at
        these points.

        :type U: float
        :type V: float
        :type TgS: OCC.wrapper.gp.gp_Vec
        :type NormS: OCC.wrapper.gp.gp_Vec

        """
        return _Blend.Blend_CSFunction_Tangent(self, *args)


    def GetShape(self, *args):
        """
        GetShape(Blend_CSFunction self)

        :type NbPoles: int
        :type NbKnots: int
        :type Degree: int
        :type NbPoles2d: int

        """
        return _Blend.Blend_CSFunction_GetShape(self, *args)


    def GetTolerance(self, *args):
        """
        GetTolerance(Blend_CSFunction self, math_Vector Tolerance, Standard_Real const Tol)
        GetTolerance(Blend_CSFunction self, Standard_Real const BoundTol, Standard_Real const SurfTol, Standard_Real const AngleTol, math_Vector Tol3d, math_Vector Tol1D)

        Returns the tolerance to reach in approximation
        to respecte
        BoundTol error at the Boundary
        AngleTol tangent error at the Boundary
        SurfTol error inside the surface.

        :type BoundTol: float
        :type SurfTol: float
        :type AngleTol: float
        :type Tol3d: OCC.wrapper.math.math_Vector
        :type Tol1D: OCC.wrapper.math.math_Vector

        """
        return _Blend.Blend_CSFunction_GetTolerance(self, *args)


    def Knots(self, *args):
        """
        Knots(Blend_CSFunction self, NCollection_Array1_Standard_Real TKnots)

        :type TKnots: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        return _Blend.Blend_CSFunction_Knots(self, *args)


    def Mults(self, *args):
        """
        Mults(Blend_CSFunction self, NCollection_Array1_Standard_Integer TMults)

        :type TMults: OCC.wrapper.TColStd.TColStd_Array1OfInteger

        """
        return _Blend.Blend_CSFunction_Mults(self, *args)


    def Section(self, *args):
        """
        Section(Blend_CSFunction self, Blend_Point P, NCollection_Array1_gp_Pnt Poles, NCollection_Array1_gp_Vec DPoles, NCollection_Array1_gp_Pnt2d Poles2d, NCollection_Array1_gp_Vec2d DPoles2d, NCollection_Array1_Standard_Real Weigths, NCollection_Array1_Standard_Real DWeigths) -> Standard_Boolean
        Section(Blend_CSFunction self, Blend_Point P, NCollection_Array1_gp_Pnt Poles, NCollection_Array1_gp_Pnt2d Poles2d, NCollection_Array1_Standard_Real Weigths)
        Section(Blend_CSFunction self, Blend_Point P, NCollection_Array1_gp_Pnt Poles, NCollection_Array1_gp_Vec DPoles, NCollection_Array1_gp_Vec D2Poles, NCollection_Array1_gp_Pnt2d Poles2d, NCollection_Array1_gp_Vec2d DPoles2d, NCollection_Array1_gp_Vec2d D2Poles2d, NCollection_Array1_Standard_Real Weigths, NCollection_Array1_Standard_Real DWeigths, NCollection_Array1_Standard_Real D2Weigths) -> Standard_Boolean

        Used for the first and last section
        The method returns Standard_True if the derivatives
        are computed, otherwise it returns Standard_False.

        :type P: OCC.wrapper.Blend.Blend_Point
        :type Poles: OCC.wrapper.TColgp.TColgp_Array1OfPnt
        :type DPoles: OCC.wrapper.TColgp.TColgp_Array1OfVec
        :type D2Poles: OCC.wrapper.TColgp.TColgp_Array1OfVec
        :type Poles2d: OCC.wrapper.TColgp.TColgp_Array1OfPnt2d
        :type DPoles2d: OCC.wrapper.TColgp.TColgp_Array1OfVec2d
        :type D2Poles2d: OCC.wrapper.TColgp.TColgp_Array1OfVec2d
        :type Weigths: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type DWeigths: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type D2Weigths: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Blend.Blend_CSFunction_Section(self, *args)

    __swig_destroy__ = _Blend.delete_Blend_CSFunction
Blend_CSFunction_swigregister = _Blend.Blend_CSFunction_swigregister
Blend_CSFunction_swigregister(Blend_CSFunction)

class Blend_CurvPointFuncInv(math.math_FunctionSetWithDerivatives):
    """
    Deferred   class  for a  function  used  to compute  a
    blending surface between a  surface and a curve, using
    a  guide  line.   This   function is  used  to find  a
    solution on a done point of the curve.
    The vector <X>  used in Value, Values and  Derivatives
    methods  has  to   be the  vector   of the  parametric
    coordinates w, U,  V where w is  the parameter  on the
    guide line, U,V   are the parametric coordinates of  a
    point on the partner surface.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def NbVariables(self, *args):
        """
        NbVariables(Blend_CurvPointFuncInv self) -> Standard_Integer

        Returns 3.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Blend.Blend_CurvPointFuncInv_NbVariables(self, *args)


    def NbEquations(self, *args):
        """
        NbEquations(Blend_CurvPointFuncInv self) -> Standard_Integer

        returns the number of equations of the function.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Blend.Blend_CurvPointFuncInv_NbEquations(self, *args)


    def Value(self, *args):
        """
        Value(Blend_CurvPointFuncInv self, math_Vector X, math_Vector F) -> Standard_Boolean

        computes the values <F> of the Functions for the
        variable <X>.
        Returns True if the computation was done successfully,
        False otherwise.

        :type X: OCC.wrapper.math.math_Vector
        :type F: OCC.wrapper.math.math_Vector
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Blend.Blend_CurvPointFuncInv_Value(self, *args)


    def Derivatives(self, *args):
        """
        Derivatives(Blend_CurvPointFuncInv self, math_Vector X, math_Matrix D) -> Standard_Boolean

        returns the values <D> of the derivatives for the
        variable <X>.
        Returns True if the computation was done successfully,
        False otherwise.

        :type X: OCC.wrapper.math.math_Vector
        :type D: OCC.wrapper.math.math_Matrix
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Blend.Blend_CurvPointFuncInv_Derivatives(self, *args)


    def Values(self, *args):
        """
        Values(Blend_CurvPointFuncInv self, math_Vector X, math_Vector F, math_Matrix D) -> Standard_Boolean

        returns the values <F> of the functions and the derivatives
        <D> for the variable <X>.
        Returns True if the computation was done successfully,
        False otherwise.

        :type X: OCC.wrapper.math.math_Vector
        :type F: OCC.wrapper.math.math_Vector
        :type D: OCC.wrapper.math.math_Matrix
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Blend.Blend_CurvPointFuncInv_Values(self, *args)


    def Set(self, *args):
        """
        Set(Blend_CurvPointFuncInv self, gp_Pnt P)

        Set the Point on which a solution has to be found.

        :type P: OCC.wrapper.gp.gp_Pnt

        """
        return _Blend.Blend_CurvPointFuncInv_Set(self, *args)


    def GetTolerance(self, *args):
        """
        GetTolerance(Blend_CurvPointFuncInv self, math_Vector Tolerance, Standard_Real const Tol)

        Returns in the vector Tolerance the parametric tolerance
        for each of the 3 variables;
        Tol is the tolerance used in 3d space.

        :type Tolerance: OCC.wrapper.math.math_Vector
        :type Tol: float

        """
        return _Blend.Blend_CurvPointFuncInv_GetTolerance(self, *args)


    def GetBounds(self, *args):
        """
        GetBounds(Blend_CurvPointFuncInv self, math_Vector InfBound, math_Vector SupBound)

        Returns in the vector InfBound the lowest values allowed
        for each of the 3 variables.
        Returns in the vector SupBound the greatest values allowed
        for each of the 3 variables.

        :type InfBound: OCC.wrapper.math.math_Vector
        :type SupBound: OCC.wrapper.math.math_Vector

        """
        return _Blend.Blend_CurvPointFuncInv_GetBounds(self, *args)


    def IsSolution(self, *args):
        """
        IsSolution(Blend_CurvPointFuncInv self, math_Vector Sol, Standard_Real const Tol) -> Standard_Boolean

        Returns Standard_True if Sol is a zero of the function.
        Tol is the tolerance used in 3d space.

        :type Sol: OCC.wrapper.math.math_Vector
        :type Tol: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Blend.Blend_CurvPointFuncInv_IsSolution(self, *args)

    __swig_destroy__ = _Blend.delete_Blend_CurvPointFuncInv
Blend_CurvPointFuncInv_swigregister = _Blend.Blend_CurvPointFuncInv_swigregister
Blend_CurvPointFuncInv_swigregister(Blend_CurvPointFuncInv)

class Blend_FuncInv(math.math_FunctionSetWithDerivatives):
    """
    Deferred class for a function used to compute a blending
    surface between two surfaces, using a guide line.
    This function is used to find a solution on a restriction
    of one of the surface.
    The vector <X> used in Value, Values and Derivatives methods
    has to be the vector of the parametric coordinates t,w,U,V
    where t is the parameter on the curve on surface,
    w is the parameter on the guide line,
    U,V are the parametric coordinates of a point on the
    partner surface.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def NbVariables(self, *args):
        """
        NbVariables(Blend_FuncInv self) -> Standard_Integer

        Returns 4.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Blend.Blend_FuncInv_NbVariables(self, *args)


    def NbEquations(self, *args):
        """
        NbEquations(Blend_FuncInv self) -> Standard_Integer

        returns the number of equations of the function.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Blend.Blend_FuncInv_NbEquations(self, *args)


    def Value(self, *args):
        """
        Value(Blend_FuncInv self, math_Vector X, math_Vector F) -> Standard_Boolean

        computes the values <F> of the Functions for the
        variable <X>.
        Returns True if the computation was done successfully,
        False otherwise.

        :type X: OCC.wrapper.math.math_Vector
        :type F: OCC.wrapper.math.math_Vector
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Blend.Blend_FuncInv_Value(self, *args)


    def Derivatives(self, *args):
        """
        Derivatives(Blend_FuncInv self, math_Vector X, math_Matrix D) -> Standard_Boolean

        returns the values <D> of the derivatives for the
        variable <X>.
        Returns True if the computation was done successfully,
        False otherwise.

        :type X: OCC.wrapper.math.math_Vector
        :type D: OCC.wrapper.math.math_Matrix
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Blend.Blend_FuncInv_Derivatives(self, *args)


    def Values(self, *args):
        """
        Values(Blend_FuncInv self, math_Vector X, math_Vector F, math_Matrix D) -> Standard_Boolean

        returns the values <F> of the functions and the derivatives
        <D> for the variable <X>.
        Returns True if the computation was done successfully,
        False otherwise.

        :type X: OCC.wrapper.math.math_Vector
        :type F: OCC.wrapper.math.math_Vector
        :type D: OCC.wrapper.math.math_Matrix
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Blend.Blend_FuncInv_Values(self, *args)


    def Set(self, *args):
        """
        Set(Blend_FuncInv self, Standard_Boolean const OnFirst, Handle_Adaptor2d_HCurve2d COnSurf)

        Sets the CurveOnSurface on which a solution has
        to be found. If <OnFirst> is set to Standard_True,
        the curve will be on the first surface, otherwise the
        curve is on the second one.

        :type OnFirst: bool
        :type COnSurf: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d

        """
        return _Blend.Blend_FuncInv_Set(self, *args)


    def GetTolerance(self, *args):
        """
        GetTolerance(Blend_FuncInv self, math_Vector Tolerance, Standard_Real const Tol)

        Returns in the vector Tolerance the parametric tolerance
        for each of the 4 variables;
        Tol is the tolerance used in 3d space.

        :type Tolerance: OCC.wrapper.math.math_Vector
        :type Tol: float

        """
        return _Blend.Blend_FuncInv_GetTolerance(self, *args)


    def GetBounds(self, *args):
        """
        GetBounds(Blend_FuncInv self, math_Vector InfBound, math_Vector SupBound)

        Returns in the vector InfBound the lowest values allowed
        for each of the 4 variables.
        Returns in the vector SupBound the greatest values allowed
        for each of the 4 variables.

        :type InfBound: OCC.wrapper.math.math_Vector
        :type SupBound: OCC.wrapper.math.math_Vector

        """
        return _Blend.Blend_FuncInv_GetBounds(self, *args)


    def IsSolution(self, *args):
        """
        IsSolution(Blend_FuncInv self, math_Vector Sol, Standard_Real const Tol) -> Standard_Boolean

        Returns Standard_True if Sol is a zero of the function.
        Tol is the tolerance used in 3d space.

        :type Sol: OCC.wrapper.math.math_Vector
        :type Tol: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Blend.Blend_FuncInv_IsSolution(self, *args)

    __swig_destroy__ = _Blend.delete_Blend_FuncInv
Blend_FuncInv_swigregister = _Blend.Blend_FuncInv_swigregister
Blend_FuncInv_swigregister(Blend_FuncInv)

class Blend_Function(Blend_AppFunction):
    """
    Deferred class for a function used to compute a blending
    surface between two surfaces, using a guide line.
    The vector <X> used in Value, Values and Derivatives methods
    has to be the vector of the parametric coordinates U1,V1,
    U2,V2, of the extremities of a section on the first and
    second surface.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def NbVariables(self, *args):
        """
        NbVariables(Blend_Function self) -> Standard_Integer

        Returns 4.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Blend.Blend_Function_NbVariables(self, *args)


    def NbEquations(self, *args):
        """
        NbEquations(Blend_Function self) -> Standard_Integer

        returns the number of equations of the function.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Blend.Blend_Function_NbEquations(self, *args)


    def Value(self, *args):
        """
        Value(Blend_Function self, math_Vector X, math_Vector F) -> Standard_Boolean

        computes the values <F> of the Functions for the
        variable <X>.
        Returns True if the computation was done successfully,
        False otherwise.

        :type X: OCC.wrapper.math.math_Vector
        :type F: OCC.wrapper.math.math_Vector
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Blend.Blend_Function_Value(self, *args)


    def Derivatives(self, *args):
        """
        Derivatives(Blend_Function self, math_Vector X, math_Matrix D) -> Standard_Boolean

        returns the values <D> of the derivatives for the
        variable <X>.
        Returns True if the computation was done successfully,
        False otherwise.

        :type X: OCC.wrapper.math.math_Vector
        :type D: OCC.wrapper.math.math_Matrix
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Blend.Blend_Function_Derivatives(self, *args)


    def Values(self, *args):
        """
        Values(Blend_Function self, math_Vector X, math_Vector F, math_Matrix D) -> Standard_Boolean

        returns the values <F> of the functions and the derivatives
        <D> for the variable <X>.
        Returns True if the computation was done successfully,
        False otherwise.

        :type X: OCC.wrapper.math.math_Vector
        :type F: OCC.wrapper.math.math_Vector
        :type D: OCC.wrapper.math.math_Matrix
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Blend.Blend_Function_Values(self, *args)


    def Set(self, *args):
        """
        Set(Blend_Function self, Standard_Real const Param)
        Set(Blend_Function self, Standard_Real const First, Standard_Real const Last)

        Sets the bounds of the parametric interval on
        the guide line.
        This determines the derivatives in these values if the
        function is not Cn.

        :type First: float
        :type Last: float

        """
        return _Blend.Blend_Function_Set(self, *args)


    def GetBounds(self, *args):
        """
        GetBounds(Blend_Function self, math_Vector InfBound, math_Vector SupBound)

        Returns in the vector InfBound the lowest values allowed
        for each of the 4 variables.
        Returns in the vector SupBound the greatest values allowed
        for each of the 4 variables.

        :type InfBound: OCC.wrapper.math.math_Vector
        :type SupBound: OCC.wrapper.math.math_Vector

        """
        return _Blend.Blend_Function_GetBounds(self, *args)


    def IsSolution(self, *args):
        """
        IsSolution(Blend_Function self, math_Vector Sol, Standard_Real const Tol) -> Standard_Boolean

        Returns Standard_True if Sol is a zero of the function.
        Tol is the tolerance used in 3d space.
        The computation is made at the current value of
        the parameter on the guide line.

        :type Sol: OCC.wrapper.math.math_Vector
        :type Tol: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Blend.Blend_Function_IsSolution(self, *args)


    def Pnt1(self, *args):
        """
        Returns the point on the first support.

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        res = _Blend.Blend_Function_Pnt1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Pnt2(self, *args):
        """
        Returns the point on the seconde support.

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        res = _Blend.Blend_Function_Pnt2(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def PointOnS1(self, *args):
        """
        Returns the point on the first surface, at parameter
        Sol(1),Sol(2) (Sol is the vector used in the call of
        IsSolution.

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        res = _Blend.Blend_Function_PointOnS1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def PointOnS2(self, *args):
        """
        Returns the point on the second surface, at parameter
        Sol(3),Sol(4) (Sol is the vector used in the call of
        IsSolution.

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        res = _Blend.Blend_Function_PointOnS2(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def IsTangencyPoint(self, *args):
        """
        IsTangencyPoint(Blend_Function self) -> Standard_Boolean

        Returns True when it is not possible to compute
        the tangent vectors at PointOnS1 and/or PointOnS2.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Blend.Blend_Function_IsTangencyPoint(self, *args)


    def TangentOnS1(self, *args):
        """
        Returns the tangent vector at PointOnS1, in 3d space.

        :rtype: OCC.wrapper.gp.gp_Vec

        """
        res = _Blend.Blend_Function_TangentOnS1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Tangent2dOnS1(self, *args):
        """
        Returns the tangent vector at PointOnS1, in the
        parametric space of the first surface.

        :rtype: OCC.wrapper.gp.gp_Vec2d

        """
        res = _Blend.Blend_Function_Tangent2dOnS1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def TangentOnS2(self, *args):
        """
        Returns the tangent vector at PointOnS2, in 3d space.

        :rtype: OCC.wrapper.gp.gp_Vec

        """
        res = _Blend.Blend_Function_TangentOnS2(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Tangent2dOnS2(self, *args):
        """
        Returns the tangent vector at PointOnS2, in the
        parametric space of the second surface.

        :rtype: OCC.wrapper.gp.gp_Vec2d

        """
        res = _Blend.Blend_Function_Tangent2dOnS2(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Tangent(self, *args):
        """
        Tangent(Blend_Function self, Standard_Real const U1, Standard_Real const V1, Standard_Real const U2, Standard_Real const V2, gp_Vec TgFirst, gp_Vec TgLast, gp_Vec NormFirst, gp_Vec NormLast)

        Returns the tangent vector at the section,
        at the beginning and the end of the section, and
        returns the normal (of the surfaces) at
        these points.

        :type U1: float
        :type V1: float
        :type U2: float
        :type V2: float
        :type TgFirst: OCC.wrapper.gp.gp_Vec
        :type TgLast: OCC.wrapper.gp.gp_Vec
        :type NormFirst: OCC.wrapper.gp.gp_Vec
        :type NormLast: OCC.wrapper.gp.gp_Vec

        """
        return _Blend.Blend_Function_Tangent(self, *args)


    def TwistOnS1(self, *args):
        """
        TwistOnS1(Blend_Function self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Blend.Blend_Function_TwistOnS1(self, *args)


    def TwistOnS2(self, *args):
        """
        TwistOnS2(Blend_Function self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Blend.Blend_Function_TwistOnS2(self, *args)


    def GetShape(self, *args):
        """
        GetShape(Blend_Function self)

        :type NbPoles: int
        :type NbKnots: int
        :type Degree: int
        :type NbPoles2d: int

        """
        return _Blend.Blend_Function_GetShape(self, *args)


    def GetTolerance(self, *args):
        """
        GetTolerance(Blend_Function self, math_Vector Tolerance, Standard_Real const Tol)
        GetTolerance(Blend_Function self, Standard_Real const BoundTol, Standard_Real const SurfTol, Standard_Real const AngleTol, math_Vector Tol3d, math_Vector Tol1D)

        Returns the tolerance to reach in approximation
        to respecte
        BoundTol error at the Boundary
        AngleTol tangent error at the Boundary
        SurfTol error inside the surface.

        :type BoundTol: float
        :type SurfTol: float
        :type AngleTol: float
        :type Tol3d: OCC.wrapper.math.math_Vector
        :type Tol1D: OCC.wrapper.math.math_Vector

        """
        return _Blend.Blend_Function_GetTolerance(self, *args)


    def Knots(self, *args):
        """
        Knots(Blend_Function self, NCollection_Array1_Standard_Real TKnots)

        :type TKnots: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        return _Blend.Blend_Function_Knots(self, *args)


    def Mults(self, *args):
        """
        Mults(Blend_Function self, NCollection_Array1_Standard_Integer TMults)

        :type TMults: OCC.wrapper.TColStd.TColStd_Array1OfInteger

        """
        return _Blend.Blend_Function_Mults(self, *args)


    def Section(self, *args):
        """
        Section(Blend_Function self, Blend_Point P, NCollection_Array1_gp_Pnt Poles, NCollection_Array1_gp_Vec DPoles, NCollection_Array1_gp_Pnt2d Poles2d, NCollection_Array1_gp_Vec2d DPoles2d, NCollection_Array1_Standard_Real Weigths, NCollection_Array1_Standard_Real DWeigths) -> Standard_Boolean
        Section(Blend_Function self, Blend_Point P, NCollection_Array1_gp_Pnt Poles, NCollection_Array1_gp_Pnt2d Poles2d, NCollection_Array1_Standard_Real Weigths)
        Section(Blend_Function self, Blend_Point P, NCollection_Array1_gp_Pnt Poles, NCollection_Array1_gp_Vec DPoles, NCollection_Array1_gp_Vec D2Poles, NCollection_Array1_gp_Pnt2d Poles2d, NCollection_Array1_gp_Vec2d DPoles2d, NCollection_Array1_gp_Vec2d D2Poles2d, NCollection_Array1_Standard_Real Weigths, NCollection_Array1_Standard_Real DWeigths, NCollection_Array1_Standard_Real D2Weigths) -> Standard_Boolean

        Used for the first and last section
        The method returns Standard_True if the derivatives
        are computed, otherwise it returns Standard_False

        :type P: OCC.wrapper.Blend.Blend_Point
        :type Poles: OCC.wrapper.TColgp.TColgp_Array1OfPnt
        :type DPoles: OCC.wrapper.TColgp.TColgp_Array1OfVec
        :type D2Poles: OCC.wrapper.TColgp.TColgp_Array1OfVec
        :type Poles2d: OCC.wrapper.TColgp.TColgp_Array1OfPnt2d
        :type DPoles2d: OCC.wrapper.TColgp.TColgp_Array1OfVec2d
        :type D2Poles2d: OCC.wrapper.TColgp.TColgp_Array1OfVec2d
        :type Weigths: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type DWeigths: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type D2Weigths: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Blend.Blend_Function_Section(self, *args)

    __swig_destroy__ = _Blend.delete_Blend_Function
Blend_Function_swigregister = _Blend.Blend_Function_swigregister
Blend_Function_swigregister(Blend_Function)

class Blend_RstRstFunction(Blend_AppFunction):
    """
    Deferred class for a function used to compute a blending
    surface between a surface and a pcurve on an other Surface,
    using a guide line.
    The vector <X> used in Value, Values and Derivatives methods
    may be the vector of the parametric coordinates U,V,
    W of the extremities of a section on the surface  and
    the curve.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def NbVariables(self, *args):
        """
        NbVariables(Blend_RstRstFunction self) -> Standard_Integer

        Returns 2 (default value). Can be redefined.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Blend.Blend_RstRstFunction_NbVariables(self, *args)


    def NbEquations(self, *args):
        """
        NbEquations(Blend_RstRstFunction self) -> Standard_Integer

        returns the number of equations of the function.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Blend.Blend_RstRstFunction_NbEquations(self, *args)


    def Value(self, *args):
        """
        Value(Blend_RstRstFunction self, math_Vector X, math_Vector F) -> Standard_Boolean

        computes the values <F> of the Functions for the
        variable <X>.
        Returns True if the computation was done successfully,
        False otherwise.

        :type X: OCC.wrapper.math.math_Vector
        :type F: OCC.wrapper.math.math_Vector
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Blend.Blend_RstRstFunction_Value(self, *args)


    def Derivatives(self, *args):
        """
        Derivatives(Blend_RstRstFunction self, math_Vector X, math_Matrix D) -> Standard_Boolean

        returns the values <D> of the derivatives for the
        variable <X>.
        Returns True if the computation was done successfully,
        False otherwise.

        :type X: OCC.wrapper.math.math_Vector
        :type D: OCC.wrapper.math.math_Matrix
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Blend.Blend_RstRstFunction_Derivatives(self, *args)


    def Values(self, *args):
        """
        Values(Blend_RstRstFunction self, math_Vector X, math_Vector F, math_Matrix D) -> Standard_Boolean

        returns the values <F> of the functions and the derivatives
        <D> for the variable <X>.
        Returns True if the computation was done successfully,
        False otherwise.

        :type X: OCC.wrapper.math.math_Vector
        :type F: OCC.wrapper.math.math_Vector
        :type D: OCC.wrapper.math.math_Matrix
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Blend.Blend_RstRstFunction_Values(self, *args)


    def Set(self, *args):
        """
        Set(Blend_RstRstFunction self, Standard_Real const Param)
        Set(Blend_RstRstFunction self, Standard_Real const First, Standard_Real const Last)

        Sets the bounds of the parametric interval on
        the guide line.
        This determines the derivatives in these values if the
        function is not Cn.

        :type First: float
        :type Last: float

        """
        return _Blend.Blend_RstRstFunction_Set(self, *args)


    def GetBounds(self, *args):
        """
        GetBounds(Blend_RstRstFunction self, math_Vector InfBound, math_Vector SupBound)

        Returns in the vector InfBound the lowest values allowed
        for each variables.
        Returns in the vector SupBound the greatest values allowed
        for each of the 3 variables.

        :type InfBound: OCC.wrapper.math.math_Vector
        :type SupBound: OCC.wrapper.math.math_Vector

        """
        return _Blend.Blend_RstRstFunction_GetBounds(self, *args)


    def IsSolution(self, *args):
        """
        IsSolution(Blend_RstRstFunction self, math_Vector Sol, Standard_Real const Tol) -> Standard_Boolean

        Returns Standard_True if Sol is a zero of the function.
        Tol is the tolerance used in 3d space.
        The computation is made at the current value of
        the parameter on the guide line.

        :type Sol: OCC.wrapper.math.math_Vector
        :type Tol: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Blend.Blend_RstRstFunction_IsSolution(self, *args)


    def GetMinimalDistance(self, *args):
        """
        GetMinimalDistance(Blend_RstRstFunction self) -> Standard_Real

        Returns   the    minimal  Distance  beetween   two
        extremitys of calculed sections.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Blend.Blend_RstRstFunction_GetMinimalDistance(self, *args)


    def Pnt1(self, *args):
        """
        Returns the point on the first support.

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        res = _Blend.Blend_RstRstFunction_Pnt1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Pnt2(self, *args):
        """
        Returns the point on the seconde support.

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        res = _Blend.Blend_RstRstFunction_Pnt2(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def PointOnRst1(self, *args):
        """
        Returns the point on the surface.

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        res = _Blend.Blend_RstRstFunction_PointOnRst1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def PointOnRst2(self, *args):
        """
        Returns the point on the curve.

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        res = _Blend.Blend_RstRstFunction_PointOnRst2(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Pnt2dOnRst1(self, *args):
        """
        Returns U,V coordinates of the point on the surface.

        :rtype: OCC.wrapper.gp.gp_Pnt2d

        """
        res = _Blend.Blend_RstRstFunction_Pnt2dOnRst1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Pnt2dOnRst2(self, *args):
        """
        Returns  U,V coordinates of the point  on the curve on
        surface.

        :rtype: OCC.wrapper.gp.gp_Pnt2d

        """
        res = _Blend.Blend_RstRstFunction_Pnt2dOnRst2(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ParameterOnRst1(self, *args):
        """
        ParameterOnRst1(Blend_RstRstFunction self) -> Standard_Real

        Returns parameter of the point on the curve.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Blend.Blend_RstRstFunction_ParameterOnRst1(self, *args)


    def ParameterOnRst2(self, *args):
        """
        ParameterOnRst2(Blend_RstRstFunction self) -> Standard_Real

        Returns parameter of the point on the curve.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Blend.Blend_RstRstFunction_ParameterOnRst2(self, *args)


    def IsTangencyPoint(self, *args):
        """
        IsTangencyPoint(Blend_RstRstFunction self) -> Standard_Boolean

        Returns True when it is not possible to compute
        the tangent vectors at PointOnS and/or PointOnRst.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Blend.Blend_RstRstFunction_IsTangencyPoint(self, *args)


    def TangentOnRst1(self, *args):
        """
        Returns the tangent vector at PointOnS, in 3d space.

        :rtype: OCC.wrapper.gp.gp_Vec

        """
        res = _Blend.Blend_RstRstFunction_TangentOnRst1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Tangent2dOnRst1(self, *args):
        """
        Returns the tangent vector at PointOnS, in the
        parametric space of the first surface.

        :rtype: OCC.wrapper.gp.gp_Vec2d

        """
        res = _Blend.Blend_RstRstFunction_Tangent2dOnRst1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def TangentOnRst2(self, *args):
        """
        Returns the tangent vector at PointOnC, in 3d space.

        :rtype: OCC.wrapper.gp.gp_Vec

        """
        res = _Blend.Blend_RstRstFunction_TangentOnRst2(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Tangent2dOnRst2(self, *args):
        """
        Returns the tangent vector at PointOnRst, in the
        parametric space of the second surface.

        :rtype: OCC.wrapper.gp.gp_Vec2d

        """
        res = _Blend.Blend_RstRstFunction_Tangent2dOnRst2(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Decroch(self, *args):
        """
        Decroch(Blend_RstRstFunction self, math_Vector Sol, gp_Vec NRst1, gp_Vec TgRst1, gp_Vec NRst2, gp_Vec TgRst2) -> Blend_DecrochStatus

        Enables to implement a  criterion  of  decrochage
        specific to the function.
        Warning: Can  be  called  without  previous  call  of issolution
        but  the  values  calculated can  be  senseless.

        :type Sol: OCC.wrapper.math.math_Vector
        :type NRst1: OCC.wrapper.gp.gp_Vec
        :type TgRst1: OCC.wrapper.gp.gp_Vec
        :type NRst2: OCC.wrapper.gp.gp_Vec
        :type TgRst2: OCC.wrapper.gp.gp_Vec
        :rtype: OCC.wrapper.Blend.Blend_DecrochStatus

        """
        return _Blend.Blend_RstRstFunction_Decroch(self, *args)


    def IsRational(self, *args):
        """
        IsRational(Blend_RstRstFunction self) -> Standard_Boolean

        Returns  if the section is rationnal

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Blend.Blend_RstRstFunction_IsRational(self, *args)


    def GetSectionSize(self, *args):
        """
        GetSectionSize(Blend_RstRstFunction self) -> Standard_Real

        Returns the length of the maximum section

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Blend.Blend_RstRstFunction_GetSectionSize(self, *args)


    def GetMinimalWeight(self, *args):
        """
        GetMinimalWeight(Blend_RstRstFunction self, NCollection_Array1_Standard_Real Weigths)

        Compute the minimal value of weight for each poles
        of all sections.

        :type Weigths: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        return _Blend.Blend_RstRstFunction_GetMinimalWeight(self, *args)


    def NbIntervals(self, *args):
        """
        NbIntervals(Blend_RstRstFunction self, GeomAbs_Shape const S) -> Standard_Integer

        Returns  the number  of  intervals for  continuity
        <S>. May be one if Continuity(me) >= <S>

        :type S: OCC.wrapper.GeomAbs.GeomAbs_Shape
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Blend.Blend_RstRstFunction_NbIntervals(self, *args)


    def Intervals(self, *args):
        """
        Intervals(Blend_RstRstFunction self, NCollection_Array1_Standard_Real T, GeomAbs_Shape const S)

        Stores in <T> the  parameters bounding the intervals
        of continuity <S>.

        The array must provide  enough room to  accomodate
        for the parameters. i.e. T.Length() > NbIntervals()

        :type T: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type S: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _Blend.Blend_RstRstFunction_Intervals(self, *args)


    def GetShape(self, *args):
        """
        GetShape(Blend_RstRstFunction self)

        :type NbPoles: int
        :type NbKnots: int
        :type Degree: int
        :type NbPoles2d: int

        """
        return _Blend.Blend_RstRstFunction_GetShape(self, *args)


    def GetTolerance(self, *args):
        """
        GetTolerance(Blend_RstRstFunction self, math_Vector Tolerance, Standard_Real const Tol)
        GetTolerance(Blend_RstRstFunction self, Standard_Real const BoundTol, Standard_Real const SurfTol, Standard_Real const AngleTol, math_Vector Tol3d, math_Vector Tol1D)

        Returns the tolerance to reach in approximation
        to respecte
        BoundTol error at the Boundary
        AngleTol tangent error at the Boundary
        SurfTol error inside the surface.

        :type BoundTol: float
        :type SurfTol: float
        :type AngleTol: float
        :type Tol3d: OCC.wrapper.math.math_Vector
        :type Tol1D: OCC.wrapper.math.math_Vector

        """
        return _Blend.Blend_RstRstFunction_GetTolerance(self, *args)


    def Knots(self, *args):
        """
        Knots(Blend_RstRstFunction self, NCollection_Array1_Standard_Real TKnots)

        :type TKnots: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        return _Blend.Blend_RstRstFunction_Knots(self, *args)


    def Mults(self, *args):
        """
        Mults(Blend_RstRstFunction self, NCollection_Array1_Standard_Integer TMults)

        :type TMults: OCC.wrapper.TColStd.TColStd_Array1OfInteger

        """
        return _Blend.Blend_RstRstFunction_Mults(self, *args)


    def Section(self, *args):
        """
        Section(Blend_RstRstFunction self, Blend_Point P, NCollection_Array1_gp_Pnt Poles, NCollection_Array1_gp_Pnt2d Poles2d, NCollection_Array1_Standard_Real Weigths)
        Section(Blend_RstRstFunction self, Blend_Point P, NCollection_Array1_gp_Pnt Poles, NCollection_Array1_gp_Vec DPoles, NCollection_Array1_gp_Pnt2d Poles2d, NCollection_Array1_gp_Vec2d DPoles2d, NCollection_Array1_Standard_Real Weigths, NCollection_Array1_Standard_Real DWeigths) -> Standard_Boolean
        Section(Blend_RstRstFunction self, Blend_Point P, NCollection_Array1_gp_Pnt Poles, NCollection_Array1_gp_Vec DPoles, NCollection_Array1_gp_Vec D2Poles, NCollection_Array1_gp_Pnt2d Poles2d, NCollection_Array1_gp_Vec2d DPoles2d, NCollection_Array1_gp_Vec2d D2Poles2d, NCollection_Array1_Standard_Real Weigths, NCollection_Array1_Standard_Real DWeigths, NCollection_Array1_Standard_Real D2Weigths) -> Standard_Boolean

        Used for the first and last section
        The method returns Standard_True if the derivatives
        are computed, otherwise it returns Standard_False.

        :type P: OCC.wrapper.Blend.Blend_Point
        :type Poles: OCC.wrapper.TColgp.TColgp_Array1OfPnt
        :type DPoles: OCC.wrapper.TColgp.TColgp_Array1OfVec
        :type D2Poles: OCC.wrapper.TColgp.TColgp_Array1OfVec
        :type Poles2d: OCC.wrapper.TColgp.TColgp_Array1OfPnt2d
        :type DPoles2d: OCC.wrapper.TColgp.TColgp_Array1OfVec2d
        :type D2Poles2d: OCC.wrapper.TColgp.TColgp_Array1OfVec2d
        :type Weigths: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type DWeigths: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type D2Weigths: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Blend.Blend_RstRstFunction_Section(self, *args)

    __swig_destroy__ = _Blend.delete_Blend_RstRstFunction
Blend_RstRstFunction_swigregister = _Blend.Blend_RstRstFunction_swigregister
Blend_RstRstFunction_swigregister(Blend_RstRstFunction)

class NCollection_Sequence_Blend_Point(NCollection.NCollection_BaseSequence):
    """
    Purpose:     Definition of a sequence of elements indexed by
    an Integer in range of 1..n
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Sequence_Blend_Point self) -> NCollection_Sequence< Blend_Point >::iterator

        Returns an iterator pointing to the first element in the sequence.

        :rtype: iterator

        """
        return _Blend.NCollection_Sequence_Blend_Point_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Sequence_Blend_Point self) -> NCollection_Sequence< Blend_Point >::iterator

        Returns an iterator referring to the past-the-end element in the sequence.

        :rtype: iterator

        """
        return _Blend.NCollection_Sequence_Blend_Point_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Sequence_Blend_Point self) -> NCollection_Sequence< Blend_Point >::const_iterator

        Returns a const iterator pointing to the first element in the sequence.

        :rtype: const_iterator

        """
        return _Blend.NCollection_Sequence_Blend_Point_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Sequence_Blend_Point self) -> NCollection_Sequence< Blend_Point >::const_iterator

        Returns a const iterator referring to the past-the-end element in the sequence.

        :rtype: const_iterator

        """
        return _Blend.NCollection_Sequence_Blend_Point_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     Definition of a sequence of elements indexed by
        an Integer in range of 1..n
        """
        this = _Blend.new_NCollection_Sequence_Blend_Point(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Size(self, *args):
        """
        Size(NCollection_Sequence_Blend_Point self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Blend.NCollection_Sequence_Blend_Point_Size(self, *args)


    def Length(self, *args):
        """
        Length(NCollection_Sequence_Blend_Point self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Blend.NCollection_Sequence_Blend_Point_Length(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Sequence_Blend_Point self) -> Standard_Integer

        Method for consistency with other collections.
        @return Lower bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Blend.NCollection_Sequence_Blend_Point_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Sequence_Blend_Point self) -> Standard_Integer

        Method for consistency with other collections.
        @return Upper bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Blend.NCollection_Sequence_Blend_Point_Upper(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Sequence_Blend_Point self) -> Standard_Boolean

        Empty query

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Blend.NCollection_Sequence_Blend_Point_IsEmpty(self, *args)


    def Reverse(self, *args):
        """
        Reverse(NCollection_Sequence_Blend_Point self)

        Reverse sequence


        """
        return _Blend.NCollection_Sequence_Blend_Point_Reverse(self, *args)


    def Exchange(self, *args):
        """
        Exchange(NCollection_Sequence_Blend_Point self, Standard_Integer const I, Standard_Integer const J)

        Exchange two members

        :type I: int
        :type J: int

        """
        return _Blend.NCollection_Sequence_Blend_Point_Exchange(self, *args)


    def delNode(*args):
        """
        delNode(NCollection_SeqNode theNode, Handle_NCollection_BaseAllocator theAl)

        Static deleter to be passed to BaseSequence

        :type theNode: OCC.wrapper.NCollection.NCollection_SeqNode
        :type theAl: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _Blend.NCollection_Sequence_Blend_Point_delNode(*args)

    delNode = staticmethod(delNode)

    def Clear(self, *args):
        """
        Clear(NCollection_Sequence_Blend_Point self, Handle_NCollection_BaseAllocator theAllocator=0)

        Clear the items out, take a new allocator if non null

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _Blend.NCollection_Sequence_Blend_Point_Clear(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Sequence_Blend_Point self, NCollection_Sequence_Blend_Point theOther) -> NCollection_Sequence_Blend_Point

        Replace this sequence by the items of theOther.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_Sequence
        :rtype: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _Blend.NCollection_Sequence_Blend_Point_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Sequence_Blend_Point self, NCollection_Sequence_Blend_Point theOther) -> NCollection_Sequence_Blend_Point

        Replacement operator

        :type theOther: OCC.wrapper.NCollection.NCollection_Sequence
        :rtype: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _Blend.NCollection_Sequence_Blend_Point_assign(self, *args)


    def Remove(self, *args):
        """
        Remove(NCollection_Sequence_Blend_Point self, NCollection_Sequence< Blend_Point >::Iterator & thePosition)
        Remove(NCollection_Sequence_Blend_Point self, Standard_Integer const theIndex)
        Remove(NCollection_Sequence_Blend_Point self, Standard_Integer const theFromIndex, Standard_Integer const theToIndex)

        Remove range of items

        :type theFromIndex: int
        :type theToIndex: int

        """
        return _Blend.NCollection_Sequence_Blend_Point_Remove(self, *args)


    def Append(self, *args):
        """
        Append(NCollection_Sequence_Blend_Point self, Blend_Point theItem)
        Append(NCollection_Sequence_Blend_Point self, NCollection_Sequence_Blend_Point theSeq)

        Append another sequence (making it empty)

        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _Blend.NCollection_Sequence_Blend_Point_Append(self, *args)


    def Prepend(self, *args):
        """
        Prepend(NCollection_Sequence_Blend_Point self, Blend_Point theItem)
        Prepend(NCollection_Sequence_Blend_Point self, NCollection_Sequence_Blend_Point theSeq)

        Prepend another sequence (making it empty)

        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _Blend.NCollection_Sequence_Blend_Point_Prepend(self, *args)


    def InsertBefore(self, *args):
        """
        InsertBefore(NCollection_Sequence_Blend_Point self, Standard_Integer const theIndex, Blend_Point theItem)
        InsertBefore(NCollection_Sequence_Blend_Point self, Standard_Integer const theIndex, NCollection_Sequence_Blend_Point theSeq)

        InsertBefore theIndex another sequence

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _Blend.NCollection_Sequence_Blend_Point_InsertBefore(self, *args)


    def InsertAfter(self, *args):
        """
        InsertAfter(NCollection_Sequence_Blend_Point self, NCollection_Sequence< Blend_Point >::Iterator & thePosition, Blend_Point theItem)
        InsertAfter(NCollection_Sequence_Blend_Point self, Standard_Integer const theIndex, NCollection_Sequence_Blend_Point theSeq)
        InsertAfter(NCollection_Sequence_Blend_Point self, Standard_Integer const theIndex, Blend_Point theItem)

        InsertAfter theIndex another sequence

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _Blend.NCollection_Sequence_Blend_Point_InsertAfter(self, *args)


    def Split(self, *args):
        """
        Split(NCollection_Sequence_Blend_Point self, Standard_Integer const theIndex, NCollection_Sequence_Blend_Point theSeq)

        Split in two sequences

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _Blend.NCollection_Sequence_Blend_Point_Split(self, *args)


    def First(self, *args):
        """
        First item access

        :rtype: const TheItemType &

        """
        res = _Blend.NCollection_Sequence_Blend_Point_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Sequence_Blend_Point self) -> Blend_Point

        First item access

        :rtype: TheItemType &

        """
        return _Blend.NCollection_Sequence_Blend_Point_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        Last item access

        :rtype: const TheItemType &

        """
        res = _Blend.NCollection_Sequence_Blend_Point_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Sequence_Blend_Point self) -> Blend_Point

        Last item access

        :rtype: TheItemType &

        """
        return _Blend.NCollection_Sequence_Blend_Point_ChangeLast(self, *args)


    def Value(self, *args):
        """
        Constant item access by theIndex

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _Blend.NCollection_Sequence_Blend_Point_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Sequence_Blend_Point self, Standard_Integer const theIndex) -> Blend_Point

        Variable item access by theIndex

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _Blend.NCollection_Sequence_Blend_Point_ChangeValue(self, *args)


    def __call__(self, *args):
        """
        Constant operator()

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _Blend.NCollection_Sequence_Blend_Point___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetValue(self, *args):
        """
        SetValue(NCollection_Sequence_Blend_Point self, Standard_Integer const theIndex, Blend_Point theItem)

        Set item value by theIndex

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _Blend.NCollection_Sequence_Blend_Point_SetValue(self, *args)


    def __iter__(self):
        return _Blend.NCollection_Sequence_Blend_Point___iter__(self)
    __swig_destroy__ = _Blend.delete_NCollection_Sequence_Blend_Point
NCollection_Sequence_Blend_Point_swigregister = _Blend.NCollection_Sequence_Blend_Point_swigregister
NCollection_Sequence_Blend_Point_swigregister(NCollection_Sequence_Blend_Point)

def NCollection_Sequence_Blend_Point_delNode(*args):
    """
    NCollection_Sequence_Blend_Point_delNode(NCollection_SeqNode theNode, Handle_NCollection_BaseAllocator theAl)

    Static deleter to be passed to BaseSequence

    :type theNode: OCC.wrapper.NCollection.NCollection_SeqNode
    :type theAl: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

    """
    return _Blend.NCollection_Sequence_Blend_Point_delNode(*args)

class NCollection_Sequence_Blend_Point_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _Blend.new_NCollection_Sequence_Blend_Point_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _Blend.delete_NCollection_Sequence_Blend_Point_IteratorHelper

    def __next__(self):
        return _Blend.NCollection_Sequence_Blend_Point_IteratorHelper___next__(self)
NCollection_Sequence_Blend_Point_IteratorHelper_swigregister = _Blend.NCollection_Sequence_Blend_Point_IteratorHelper_swigregister
NCollection_Sequence_Blend_Point_IteratorHelper_swigregister(NCollection_Sequence_Blend_Point_IteratorHelper)


try:
	Blend_SequenceOfPoint = NCollection_Sequence_Blend_Point
except NameError:
	pass # does not exist, probably ignored

class Blend_SurfRstFunction(Blend_AppFunction):
    """
    Deferred class for a function used to compute a blending
    surface between a surface and a pcurve on an other Surface,
    using a guide line.
    The vector <X> used in Value, Values and Derivatives methods
    may be the vector of the parametric coordinates U,V,
    W of the extremities of a section on the surface  and
    the curve.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def NbVariables(self, *args):
        """
        NbVariables(Blend_SurfRstFunction self) -> Standard_Integer

        Returns 3 (default value). Can be redefined.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Blend.Blend_SurfRstFunction_NbVariables(self, *args)


    def NbEquations(self, *args):
        """
        NbEquations(Blend_SurfRstFunction self) -> Standard_Integer

        returns the number of equations of the function.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Blend.Blend_SurfRstFunction_NbEquations(self, *args)


    def Value(self, *args):
        """
        Value(Blend_SurfRstFunction self, math_Vector X, math_Vector F) -> Standard_Boolean

        computes the values <F> of the Functions for the
        variable <X>.
        Returns True if the computation was done successfully,
        False otherwise.

        :type X: OCC.wrapper.math.math_Vector
        :type F: OCC.wrapper.math.math_Vector
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Blend.Blend_SurfRstFunction_Value(self, *args)


    def Derivatives(self, *args):
        """
        Derivatives(Blend_SurfRstFunction self, math_Vector X, math_Matrix D) -> Standard_Boolean

        returns the values <D> of the derivatives for the
        variable <X>.
        Returns True if the computation was done successfully,
        False otherwise.

        :type X: OCC.wrapper.math.math_Vector
        :type D: OCC.wrapper.math.math_Matrix
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Blend.Blend_SurfRstFunction_Derivatives(self, *args)


    def Values(self, *args):
        """
        Values(Blend_SurfRstFunction self, math_Vector X, math_Vector F, math_Matrix D) -> Standard_Boolean

        returns the values <F> of the functions and the derivatives
        <D> for the variable <X>.
        Returns True if the computation was done successfully,
        False otherwise.

        :type X: OCC.wrapper.math.math_Vector
        :type F: OCC.wrapper.math.math_Vector
        :type D: OCC.wrapper.math.math_Matrix
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Blend.Blend_SurfRstFunction_Values(self, *args)


    def Set(self, *args):
        """
        Set(Blend_SurfRstFunction self, Standard_Real const Param)
        Set(Blend_SurfRstFunction self, Standard_Real const First, Standard_Real const Last)

        Sets the bounds of the parametric interval on
        the guide line.
        This determines the derivatives in these values if the
        function is not Cn.

        :type First: float
        :type Last: float

        """
        return _Blend.Blend_SurfRstFunction_Set(self, *args)


    def GetBounds(self, *args):
        """
        GetBounds(Blend_SurfRstFunction self, math_Vector InfBound, math_Vector SupBound)

        Returns in the vector InfBound the lowest values allowed
        for each variables.
        Returns in the vector SupBound the greatest values allowed
        for each of the 3 variables.

        :type InfBound: OCC.wrapper.math.math_Vector
        :type SupBound: OCC.wrapper.math.math_Vector

        """
        return _Blend.Blend_SurfRstFunction_GetBounds(self, *args)


    def IsSolution(self, *args):
        """
        IsSolution(Blend_SurfRstFunction self, math_Vector Sol, Standard_Real const Tol) -> Standard_Boolean

        Returns Standard_True if Sol is a zero of the function.
        Tol is the tolerance used in 3d space.
        The computation is made at the current value of
        the parameter on the guide line.

        :type Sol: OCC.wrapper.math.math_Vector
        :type Tol: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Blend.Blend_SurfRstFunction_IsSolution(self, *args)


    def GetMinimalDistance(self, *args):
        """
        GetMinimalDistance(Blend_SurfRstFunction self) -> Standard_Real

        Returns   the    minimal  Distance  beetween   two
        extremitys of calculed sections.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Blend.Blend_SurfRstFunction_GetMinimalDistance(self, *args)


    def Pnt1(self, *args):
        """
        Returns the point on the first support.

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        res = _Blend.Blend_SurfRstFunction_Pnt1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Pnt2(self, *args):
        """
        Returns the point on the seconde support.

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        res = _Blend.Blend_SurfRstFunction_Pnt2(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def PointOnS(self, *args):
        """
        Returns the point on the surface.

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        res = _Blend.Blend_SurfRstFunction_PointOnS(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def PointOnRst(self, *args):
        """
        Returns the point on the curve.

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        res = _Blend.Blend_SurfRstFunction_PointOnRst(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Pnt2dOnS(self, *args):
        """
        Returns U,V coordinates of the point on the surface.

        :rtype: OCC.wrapper.gp.gp_Pnt2d

        """
        res = _Blend.Blend_SurfRstFunction_Pnt2dOnS(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Pnt2dOnRst(self, *args):
        """
        Returns  U,V coordinates of the point  on the curve on
        surface.

        :rtype: OCC.wrapper.gp.gp_Pnt2d

        """
        res = _Blend.Blend_SurfRstFunction_Pnt2dOnRst(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ParameterOnRst(self, *args):
        """
        ParameterOnRst(Blend_SurfRstFunction self) -> Standard_Real

        Returns parameter of the point on the curve.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Blend.Blend_SurfRstFunction_ParameterOnRst(self, *args)


    def IsTangencyPoint(self, *args):
        """
        IsTangencyPoint(Blend_SurfRstFunction self) -> Standard_Boolean

        Returns True when it is not possible to compute
        the tangent vectors at PointOnS and/or PointOnRst.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Blend.Blend_SurfRstFunction_IsTangencyPoint(self, *args)


    def TangentOnS(self, *args):
        """
        Returns the tangent vector at PointOnS, in 3d space.

        :rtype: OCC.wrapper.gp.gp_Vec

        """
        res = _Blend.Blend_SurfRstFunction_TangentOnS(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Tangent2dOnS(self, *args):
        """
        Returns the tangent vector at PointOnS, in the
        parametric space of the first surface.

        :rtype: OCC.wrapper.gp.gp_Vec2d

        """
        res = _Blend.Blend_SurfRstFunction_Tangent2dOnS(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def TangentOnRst(self, *args):
        """
        Returns the tangent vector at PointOnC, in 3d space.

        :rtype: OCC.wrapper.gp.gp_Vec

        """
        res = _Blend.Blend_SurfRstFunction_TangentOnRst(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Tangent2dOnRst(self, *args):
        """
        Returns the tangent vector at PointOnRst, in the
        parametric space of the second surface.

        :rtype: OCC.wrapper.gp.gp_Vec2d

        """
        res = _Blend.Blend_SurfRstFunction_Tangent2dOnRst(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Decroch(self, *args):
        """
        Decroch(Blend_SurfRstFunction self, math_Vector Sol, gp_Vec NS, gp_Vec TgS) -> Standard_Boolean

        Enables implementation  of a criterion of decrochage
        specific to  the function.

        :type Sol: OCC.wrapper.math.math_Vector
        :type NS: OCC.wrapper.gp.gp_Vec
        :type TgS: OCC.wrapper.gp.gp_Vec
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Blend.Blend_SurfRstFunction_Decroch(self, *args)


    def IsRational(self, *args):
        """
        IsRational(Blend_SurfRstFunction self) -> Standard_Boolean

        Returns  if the section is rationnal

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Blend.Blend_SurfRstFunction_IsRational(self, *args)


    def GetSectionSize(self, *args):
        """
        GetSectionSize(Blend_SurfRstFunction self) -> Standard_Real

        Returns the length of the maximum section

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Blend.Blend_SurfRstFunction_GetSectionSize(self, *args)


    def GetMinimalWeight(self, *args):
        """
        GetMinimalWeight(Blend_SurfRstFunction self, NCollection_Array1_Standard_Real Weigths)

        Compute the minimal value of weight for each poles
        of all sections.

        :type Weigths: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        return _Blend.Blend_SurfRstFunction_GetMinimalWeight(self, *args)


    def NbIntervals(self, *args):
        """
        NbIntervals(Blend_SurfRstFunction self, GeomAbs_Shape const S) -> Standard_Integer

        Returns  the number  of  intervals for  continuity
        <S>. May be one if Continuity(me) >= <S>

        :type S: OCC.wrapper.GeomAbs.GeomAbs_Shape
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Blend.Blend_SurfRstFunction_NbIntervals(self, *args)


    def Intervals(self, *args):
        """
        Intervals(Blend_SurfRstFunction self, NCollection_Array1_Standard_Real T, GeomAbs_Shape const S)

        Stores in <T> the  parameters bounding the intervals
        of continuity <S>.

        The array must provide  enough room to  accomodate
        for the parameters. i.e. T.Length() > NbIntervals()

        :type T: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type S: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _Blend.Blend_SurfRstFunction_Intervals(self, *args)


    def GetShape(self, *args):
        """
        GetShape(Blend_SurfRstFunction self)

        :type NbPoles: int
        :type NbKnots: int
        :type Degree: int
        :type NbPoles2d: int

        """
        return _Blend.Blend_SurfRstFunction_GetShape(self, *args)


    def GetTolerance(self, *args):
        """
        GetTolerance(Blend_SurfRstFunction self, math_Vector Tolerance, Standard_Real const Tol)
        GetTolerance(Blend_SurfRstFunction self, Standard_Real const BoundTol, Standard_Real const SurfTol, Standard_Real const AngleTol, math_Vector Tol3d, math_Vector Tol1D)

        Returns the tolerance to reach in approximation
        to respecte
        BoundTol error at the Boundary
        AngleTol tangent error at the Boundary
        SurfTol error inside the surface.

        :type BoundTol: float
        :type SurfTol: float
        :type AngleTol: float
        :type Tol3d: OCC.wrapper.math.math_Vector
        :type Tol1D: OCC.wrapper.math.math_Vector

        """
        return _Blend.Blend_SurfRstFunction_GetTolerance(self, *args)


    def Knots(self, *args):
        """
        Knots(Blend_SurfRstFunction self, NCollection_Array1_Standard_Real TKnots)

        :type TKnots: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        return _Blend.Blend_SurfRstFunction_Knots(self, *args)


    def Mults(self, *args):
        """
        Mults(Blend_SurfRstFunction self, NCollection_Array1_Standard_Integer TMults)

        :type TMults: OCC.wrapper.TColStd.TColStd_Array1OfInteger

        """
        return _Blend.Blend_SurfRstFunction_Mults(self, *args)


    def Section(self, *args):
        """
        Section(Blend_SurfRstFunction self, Blend_Point P, NCollection_Array1_gp_Pnt Poles, NCollection_Array1_gp_Vec DPoles, NCollection_Array1_gp_Pnt2d Poles2d, NCollection_Array1_gp_Vec2d DPoles2d, NCollection_Array1_Standard_Real Weigths, NCollection_Array1_Standard_Real DWeigths) -> Standard_Boolean
        Section(Blend_SurfRstFunction self, Blend_Point P, NCollection_Array1_gp_Pnt Poles, NCollection_Array1_gp_Vec DPoles, NCollection_Array1_gp_Vec D2Poles, NCollection_Array1_gp_Pnt2d Poles2d, NCollection_Array1_gp_Vec2d DPoles2d, NCollection_Array1_gp_Vec2d D2Poles2d, NCollection_Array1_Standard_Real Weigths, NCollection_Array1_Standard_Real DWeigths, NCollection_Array1_Standard_Real D2Weigths) -> Standard_Boolean
        Section(Blend_SurfRstFunction self, Blend_Point P, NCollection_Array1_gp_Pnt Poles, NCollection_Array1_gp_Pnt2d Poles2d, NCollection_Array1_Standard_Real Weigths)

        :type P: OCC.wrapper.Blend.Blend_Point
        :type Poles: OCC.wrapper.TColgp.TColgp_Array1OfPnt
        :type Poles2d: OCC.wrapper.TColgp.TColgp_Array1OfPnt2d
        :type Weigths: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        return _Blend.Blend_SurfRstFunction_Section(self, *args)

    __swig_destroy__ = _Blend.delete_Blend_SurfRstFunction
Blend_SurfRstFunction_swigregister = _Blend.Blend_SurfRstFunction_swigregister
Blend_SurfRstFunction_swigregister(Blend_SurfRstFunction)




# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_StepSelect')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_StepSelect')
    _StepSelect = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_StepSelect', [dirname(__file__)])
        except ImportError:
            import _StepSelect
            return _StepSelect
        try:
            _mod = imp.load_module('_StepSelect', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _StepSelect = swig_import_helper()
    del swig_import_helper
else:
    import _StepSelect
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


class SwigPyIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _StepSelect.delete_SwigPyIterator

    def value(self):
        return _StepSelect.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _StepSelect.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _StepSelect.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _StepSelect.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _StepSelect.SwigPyIterator_equal(self, x)

    def copy(self):
        return _StepSelect.SwigPyIterator_copy(self)

    def next(self):
        return _StepSelect.SwigPyIterator_next(self)

    def __next__(self):
        return _StepSelect.SwigPyIterator___next__(self)

    def previous(self):
        return _StepSelect.SwigPyIterator_previous(self)

    def advance(self, n):
        return _StepSelect.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _StepSelect.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _StepSelect.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _StepSelect.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _StepSelect.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _StepSelect.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _StepSelect.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self
SwigPyIterator_swigregister = _StepSelect.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

class NCollection_CellFilter_InspectorXYZ(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _StepSelect.NCollection_CellFilter_InspectorXYZ_Dimension
    Coord = staticmethod(_StepSelect.NCollection_CellFilter_InspectorXYZ_Coord)

    def Shift(self, thePnt, theTol):
        return _StepSelect.NCollection_CellFilter_InspectorXYZ_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _StepSelect.new_NCollection_CellFilter_InspectorXYZ()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _StepSelect.delete_NCollection_CellFilter_InspectorXYZ
NCollection_CellFilter_InspectorXYZ_swigregister = _StepSelect.NCollection_CellFilter_InspectorXYZ_swigregister
NCollection_CellFilter_InspectorXYZ_swigregister(NCollection_CellFilter_InspectorXYZ)

def NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt):
    return _StepSelect.NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt)
NCollection_CellFilter_InspectorXYZ_Coord = _StepSelect.NCollection_CellFilter_InspectorXYZ_Coord

class NCollection_CellFilter_InspectorXY(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _StepSelect.NCollection_CellFilter_InspectorXY_Dimension
    Coord = staticmethod(_StepSelect.NCollection_CellFilter_InspectorXY_Coord)

    def Shift(self, thePnt, theTol):
        return _StepSelect.NCollection_CellFilter_InspectorXY_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _StepSelect.new_NCollection_CellFilter_InspectorXY()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _StepSelect.delete_NCollection_CellFilter_InspectorXY
NCollection_CellFilter_InspectorXY_swigregister = _StepSelect.NCollection_CellFilter_InspectorXY_swigregister
NCollection_CellFilter_InspectorXY_swigregister(NCollection_CellFilter_InspectorXY)

def NCollection_CellFilter_InspectorXY_Coord(i, thePnt):
    return _StepSelect.NCollection_CellFilter_InspectorXY_Coord(i, thePnt)
NCollection_CellFilter_InspectorXY_Coord = _StepSelect.NCollection_CellFilter_InspectorXY_Coord


def ptr_to_number(item):
    return _StepSelect.ptr_to_number(item)
ptr_to_number = _StepSelect.ptr_to_number

def HashCode(*args):
    return _StepSelect.HashCode(*args)
HashCode = _StepSelect.HashCode

def ptr_equal(a, b):
    return _StepSelect.ptr_equal(a, b)
ptr_equal = _StepSelect.ptr_equal
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import StepData
else:
    import StepData
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import NCollection
else:
    import NCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Standard
else:
    import Standard
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColStd
else:
    import TColStd
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TCollection
else:
    import TCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Interface
else:
    import Interface
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import MoniTool
else:
    import MoniTool
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopoDS
else:
    import TopoDS
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopAbs
else:
    import TopAbs
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Message
else:
    import Message
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopLoc
else:
    import TopLoc
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import gp
else:
    import gp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import OSD
else:
    import OSD
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Quantity
else:
    import Quantity
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopTools
else:
    import TopTools
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Bnd
else:
    import Bnd
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColgp
else:
    import TColgp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import IFSelect
else:
    import IFSelect
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import IFGraph
else:
    import IFGraph
del _swig_python_version_info
class StepSelect_FileModifier(IFSelect.IFSelect_GeneralModifier):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepSelect_FileModifier
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepSelect_FileModifier(self) 
            return h


    def Perform(self, *args):
        """
        Perform(StepSelect_FileModifier self, IFSelect_ContextWrite ctx, StepData_StepWriter writer)

        Perform the action specific to each class of File Modifier
        <ctx> is the ContextWrite, which brings : the model, the
        protocol, the file name, plus the object AppliedModifiers
        (not used here) and the CheckList
        Remark that the model has to be casted for specific access

        <writer> is the Writer and is specific to each norm, on which
        to act

        :type ctx: OCC.wrapper.IFSelect.IFSelect_ContextWrite
        :type writer: OCC.wrapper.StepData.StepData_StepWriter

        """
        return _StepSelect.StepSelect_FileModifier_Perform(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepSelect.StepSelect_FileModifier_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepSelect.StepSelect_FileModifier_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepSelect.StepSelect_FileModifier_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepSelect.delete_StepSelect_FileModifier
StepSelect_FileModifier_swigregister = _StepSelect.StepSelect_FileModifier_swigregister
StepSelect_FileModifier_swigregister(StepSelect_FileModifier)

def StepSelect_FileModifier_get_type_name(*args):
    """
    StepSelect_FileModifier_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepSelect.StepSelect_FileModifier_get_type_name(*args)

def StepSelect_FileModifier_get_type_descriptor(*args):
    """
    StepSelect_FileModifier_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepSelect.StepSelect_FileModifier_get_type_descriptor(*args)

class StepSelect_WorkLibrary(IFSelect.IFSelect_WorkLibrary):
    """
    Performs Read and Write a STEP File with a STEP Model
    Following the protocols, Copy may be implemented or not
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepSelect_WorkLibrary
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepSelect_WorkLibrary(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepSelect_WorkLibrary self, Standard_Boolean const copymode) -> StepSelect_WorkLibrary

        Creates a STEP WorkLibrary
        <copymode> precises whether Copy is implemented or not

        :type copymode: bool

        """
        this = _StepSelect.new_StepSelect_WorkLibrary(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def SetDumpLabel(self, *args):
        """
        SetDumpLabel(StepSelect_WorkLibrary self, Standard_Integer const mode)

        Selects a mode to dump entities
        0 (D) : prints numbers, then displays table number/label
        1 : prints labels, then displays table label/number
        2 : prints labels onky

        :type mode: int

        """
        return _StepSelect.StepSelect_WorkLibrary_SetDumpLabel(self, *args)


    def ReadFile(self, *args):
        """
        ReadFile(StepSelect_WorkLibrary self, Standard_CString const name, Handle_Interface_InterfaceModel model, Handle_Interface_Protocol protocol) -> Standard_Integer

        Reads a STEP File and returns a STEP Model (into <mod>),
        or lets <mod> "Null" in case of Error
        Returns 0 if OK, 1 if Read Error, -1 if File not opened

        :type name: OCC.wrapper.Standard.Standard_CString
        :type model: OCC.wrapper.Interface.Handle_Interface_InterfaceModel
        :type protocol: OCC.wrapper.Interface.Handle_Interface_Protocol
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepSelect.StepSelect_WorkLibrary_ReadFile(self, *args)


    def WriteFile(self, *args):
        """
        WriteFile(StepSelect_WorkLibrary self, IFSelect_ContextWrite ctx) -> Standard_Boolean

        Writes a File from a STEP Model
        Returns False (and writes no file) if <ctx> does not bring a
        STEP Model

        :type ctx: OCC.wrapper.IFSelect.IFSelect_ContextWrite
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepSelect.StepSelect_WorkLibrary_WriteFile(self, *args)


    def CopyModel(self, *args):
        """
        CopyModel(StepSelect_WorkLibrary self, Handle_Interface_InterfaceModel original, Handle_Interface_InterfaceModel newmodel, Interface_EntityIterator list, Interface_CopyTool TC) -> Standard_Boolean

        Performs the copy of entities from an original model to a new
        one. Works according <copymode> :
        if True, standard copy is run
        else nothing is done and returned value is False

        :type original: OCC.wrapper.Interface.Handle_Interface_InterfaceModel
        :type newmodel: OCC.wrapper.Interface.Handle_Interface_InterfaceModel
        :type list: OCC.wrapper.Interface.Interface_EntityIterator
        :type TC: OCC.wrapper.Interface.Interface_CopyTool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepSelect.StepSelect_WorkLibrary_CopyModel(self, *args)


    def DumpEntity(self, *args):
        """
        DumpEntity(StepSelect_WorkLibrary self, Handle_Interface_InterfaceModel model, Handle_Interface_Protocol protocol, Handle_Standard_Transient entity, Handle_Message_Messenger S, Standard_Integer const level)

        Dumps an entity under STEP form, i.e. as a part of a Step file
        Works with a StepDumper.
        Level 0 just displays type; level 1 displays the entity itself
        and level 2 displays the entity plus its shared ones (one
        sub-level : immediately shared entities)

        :type model: OCC.wrapper.Interface.Handle_Interface_InterfaceModel
        :type protocol: OCC.wrapper.Interface.Handle_Interface_Protocol
        :type entity: OCC.wrapper.Standard.Handle_Standard_Transient
        :type S: OCC.wrapper.Message.Handle_Message_Messenger
        :type level: int

        """
        return _StepSelect.StepSelect_WorkLibrary_DumpEntity(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepSelect.StepSelect_WorkLibrary_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepSelect.StepSelect_WorkLibrary_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepSelect.StepSelect_WorkLibrary_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepSelect.delete_StepSelect_WorkLibrary
StepSelect_WorkLibrary_swigregister = _StepSelect.StepSelect_WorkLibrary_swigregister
StepSelect_WorkLibrary_swigregister(StepSelect_WorkLibrary)

def StepSelect_WorkLibrary_get_type_name(*args):
    """
    StepSelect_WorkLibrary_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepSelect.StepSelect_WorkLibrary_get_type_name(*args)

def StepSelect_WorkLibrary_get_type_descriptor(*args):
    """
    StepSelect_WorkLibrary_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepSelect.StepSelect_WorkLibrary_get_type_descriptor(*args)

class StepSelect_ModelModifier(IFSelect.IFSelect_Modifier):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepSelect_ModelModifier
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepSelect_ModelModifier(self) 
            return h


    def Perform(self, *args):
        """
        Perform(StepSelect_ModelModifier self, IFSelect_ContextModif ctx, Handle_Interface_InterfaceModel target, Handle_Interface_Protocol protocol, Interface_CopyTool TC)

        The inherited Perform does the required cast (and refuses to
        go further if cast has failed) then calls the instantiated
        Performing

        :type ctx: OCC.wrapper.IFSelect.IFSelect_ContextModif
        :type target: OCC.wrapper.Interface.Handle_Interface_InterfaceModel
        :type protocol: OCC.wrapper.Interface.Handle_Interface_Protocol
        :type TC: OCC.wrapper.Interface.Interface_CopyTool

        """
        return _StepSelect.StepSelect_ModelModifier_Perform(self, *args)


    def PerformProtocol(self, *args):
        """
        PerformProtocol(StepSelect_ModelModifier self, IFSelect_ContextModif ctx, Handle_StepData_StepModel target, Handle_StepData_Protocol proto, Interface_CopyTool TC)

        Specific Perform with Protocol. It is defined to let the
        Protocol unused and to call Performing without Protocol
        (most current case). It can be redefined if specific action
        requires Protocol.

        :type ctx: OCC.wrapper.IFSelect.IFSelect_ContextModif
        :type target: OCC.wrapper.StepData.Handle_StepData_StepModel
        :type proto: OCC.wrapper.StepData.Handle_StepData_Protocol
        :type TC: OCC.wrapper.Interface.Interface_CopyTool

        """
        return _StepSelect.StepSelect_ModelModifier_PerformProtocol(self, *args)


    def Performing(self, *args):
        """
        Performing(StepSelect_ModelModifier self, IFSelect_ContextModif ctx, Handle_StepData_StepModel target, Interface_CopyTool TC)

        Specific Perform, without Protocol. If Performing with
        Protocol is redefined, Performing without Protocol must
        though be defined to do nothing (not called, but demanded
        by the linker)

        :type ctx: OCC.wrapper.IFSelect.IFSelect_ContextModif
        :type target: OCC.wrapper.StepData.Handle_StepData_StepModel
        :type TC: OCC.wrapper.Interface.Interface_CopyTool

        """
        return _StepSelect.StepSelect_ModelModifier_Performing(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepSelect.StepSelect_ModelModifier_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepSelect.StepSelect_ModelModifier_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepSelect.StepSelect_ModelModifier_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepSelect.delete_StepSelect_ModelModifier
StepSelect_ModelModifier_swigregister = _StepSelect.StepSelect_ModelModifier_swigregister
StepSelect_ModelModifier_swigregister(StepSelect_ModelModifier)

def StepSelect_ModelModifier_get_type_name(*args):
    """
    StepSelect_ModelModifier_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepSelect.StepSelect_ModelModifier_get_type_name(*args)

def StepSelect_ModelModifier_get_type_descriptor(*args):
    """
    StepSelect_ModelModifier_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepSelect.StepSelect_ModelModifier_get_type_descriptor(*args)

class StepSelect_StepType(IFSelect.IFSelect_Signature):
    """
    StepType is a Signature specific to Step definitions : it
    considers the type as defined in STEP Schemas, the same which
    is used in files.
    For a Complex Type, if its definition is known, StepType
    produces the list of basic types, separated by commas, the
    whole between brackets : "(TYPE1,TYPE2..)".
    If its precise definition is not known (simply it is known as
    Complex, it can be recognised, but the list is produced at
    Write time only), StepType produces : "(..COMPLEX TYPE..)" 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepSelect_StepType
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepSelect_StepType(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepSelect_StepType self) -> StepSelect_StepType

        Creates a Signature for Step Type. Protocol is undefined here,
        hence no Signature may yet be produced. The StepType signature
        requires a Protocol before working


        """
        this = _StepSelect.new_StepSelect_StepType(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def SetProtocol(self, *args):
        """
        SetProtocol(StepSelect_StepType self, Handle_Interface_Protocol proto)

        Sets the StepType signature to work with a Protocol : this
        initialises the library

        :type proto: OCC.wrapper.Interface.Handle_Interface_Protocol

        """
        return _StepSelect.StepSelect_StepType_SetProtocol(self, *args)


    def Value(self, *args):
        """
        Value(StepSelect_StepType self, Handle_Standard_Transient ent, Handle_Interface_InterfaceModel model) -> Standard_CString

        Returns the Step Type defined from the Protocol (see above).
        If <ent> is not recognised, produces "..NOT FROM SCHEMA <name>.."

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type model: OCC.wrapper.Interface.Handle_Interface_InterfaceModel
        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _StepSelect.StepSelect_StepType_Value(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepSelect.StepSelect_StepType_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepSelect.StepSelect_StepType_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepSelect.StepSelect_StepType_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepSelect.delete_StepSelect_StepType
StepSelect_StepType_swigregister = _StepSelect.StepSelect_StepType_swigregister
StepSelect_StepType_swigregister(StepSelect_StepType)

def StepSelect_StepType_get_type_name(*args):
    """
    StepSelect_StepType_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepSelect.StepSelect_StepType_get_type_name(*args)

def StepSelect_StepType_get_type_descriptor(*args):
    """
    StepSelect_StepType_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepSelect.StepSelect_StepType_get_type_descriptor(*args)

class StepSelect_FloatFormat(StepSelect_FileModifier):
    """
    This class gives control out format for floatting values :
    ZeroSuppress or no, Main Format, Format in Range (for values
    around 1.), as StepWriter allows to manage it.
    Formats are given under C-printf form
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepSelect_FloatFormat
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepSelect_FloatFormat(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepSelect_FloatFormat self) -> StepSelect_FloatFormat

        Creates a new FloatFormat, with standard options :
        ZeroSuppress, Main Format = %E,
        Format between 0.001 and 1000. = %f


        """
        this = _StepSelect.new_StepSelect_FloatFormat(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def SetDefault(self, *args):
        """
        SetDefault(StepSelect_FloatFormat self, Standard_Integer const digits=0)

        Sets FloatFormat to default value (see Create) but if <digits>
        is given positive, it commands Formats (main and range) to
        ensure <digits> significant digits to be displayed

        :type digits: int

        """
        return _StepSelect.StepSelect_FloatFormat_SetDefault(self, *args)


    def SetZeroSuppress(self, *args):
        """
        SetZeroSuppress(StepSelect_FloatFormat self, Standard_Boolean const mode)

        Sets ZeroSuppress mode to a new value

        :type mode: bool

        """
        return _StepSelect.StepSelect_FloatFormat_SetZeroSuppress(self, *args)


    def SetFormat(self, *args):
        """
        SetFormat(StepSelect_FloatFormat self, Standard_CString const format)

        Sets Main Format to a new value
        Remark : SetFormat, SetZeroSuppress and SetFormatForRange are
        independant

        :type format: OCC.wrapper.Standard.Standard_CString

        """
        return _StepSelect.StepSelect_FloatFormat_SetFormat(self, *args)


    def SetFormatForRange(self, *args):
        """
        SetFormatForRange(StepSelect_FloatFormat self, Standard_CString const format, Standard_Real const Rmin=0.1, Standard_Real const Rmax=1000.0)

        Sets Format for Range to a new value with its range of
        application.
        To cancel it, give format as "" (empty string)
        Remark that if the condition (0. < Rmin < Rmax)  is not
        verified, this secondary format will be ignored.
        Moreover, this secondary format is intended to be used in a
        range around 1.

        :type format: OCC.wrapper.Standard.Standard_CString
        :type Rmin: float
        :type Rmax: float

        """
        return _StepSelect.StepSelect_FloatFormat_SetFormatForRange(self, *args)


    def Format(self, *args):
        """
        Format(StepSelect_FloatFormat self, TCollection_AsciiString mainform, TCollection_AsciiString forminrange)

        Returns all recorded parameters :
        zerosup  : ZeroSuppress status
        mainform : Main Format (which applies out of the range, or
        for every real if no range is set)
        hasrange : True if a FormatInRange is set, False else
        (following parameters do not apply if it is False)
        forminrange : Secondary Format (it applies inside the range)
        rangemin, rangemax : the range in which the secondary format
        applies

        :type zerosup: bool
        :type mainform: OCC.wrapper.TCollection.TCollection_AsciiString
        :type hasrange: bool
        :type forminrange: OCC.wrapper.TCollection.TCollection_AsciiString
        :type rangemin: float
        :type rangemax: float

        """
        return _StepSelect.StepSelect_FloatFormat_Format(self, *args)


    def Perform(self, *args):
        """
        Perform(StepSelect_FloatFormat self, IFSelect_ContextWrite ctx, StepData_StepWriter writer)

        Sets the Floatting Formats of StepWriter to the recorded
        parameters

        :type ctx: OCC.wrapper.IFSelect.IFSelect_ContextWrite
        :type writer: OCC.wrapper.StepData.StepData_StepWriter

        """
        return _StepSelect.StepSelect_FloatFormat_Perform(self, *args)


    def Label(self, *args):
        """
        Label(StepSelect_FloatFormat self) -> TCollection_AsciiString

        Returns specific Label : for instance,
        "Float Format [ZeroSuppress] %E [, in range R1-R2 %f]"

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _StepSelect.StepSelect_FloatFormat_Label(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepSelect.StepSelect_FloatFormat_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepSelect.StepSelect_FloatFormat_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepSelect.StepSelect_FloatFormat_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepSelect.delete_StepSelect_FloatFormat
StepSelect_FloatFormat_swigregister = _StepSelect.StepSelect_FloatFormat_swigregister
StepSelect_FloatFormat_swigregister(StepSelect_FloatFormat)

def StepSelect_FloatFormat_get_type_name(*args):
    """
    StepSelect_FloatFormat_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepSelect.StepSelect_FloatFormat_get_type_name(*args)

def StepSelect_FloatFormat_get_type_descriptor(*args):
    """
    StepSelect_FloatFormat_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepSelect.StepSelect_FloatFormat_get_type_descriptor(*args)

class Handle_StepSelect_WorkLibrary(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepSelect_WorkLibrary self)

        Nullify the handle


        """
        return _StepSelect.Handle_StepSelect_WorkLibrary_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepSelect_WorkLibrary self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepSelect.Handle_StepSelect_WorkLibrary_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepSelect_WorkLibrary self, StepSelect_WorkLibrary thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepSelect.Handle_StepSelect_WorkLibrary_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepSelect_WorkLibrary self, Handle_StepSelect_WorkLibrary theHandle) -> Handle_StepSelect_WorkLibrary
        assign(Handle_StepSelect_WorkLibrary self, StepSelect_WorkLibrary thePtr) -> Handle_StepSelect_WorkLibrary
        assign(Handle_StepSelect_WorkLibrary self, Handle_StepSelect_WorkLibrary theHandle) -> Handle_StepSelect_WorkLibrary

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepSelect.Handle_StepSelect_WorkLibrary_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepSelect_WorkLibrary self) -> StepSelect_WorkLibrary

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepSelect.Handle_StepSelect_WorkLibrary_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepSelect_WorkLibrary self) -> StepSelect_WorkLibrary

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepSelect.Handle_StepSelect_WorkLibrary___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepSelect_WorkLibrary self) -> StepSelect_WorkLibrary

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepSelect.Handle_StepSelect_WorkLibrary___ref__(self, *args)


    def __hash__(self):
        return _StepSelect.Handle_StepSelect_WorkLibrary___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepSelect.Handle_StepSelect_WorkLibrary___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepSelect.new_Handle_StepSelect_WorkLibrary(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepSelect.Handle_StepSelect_WorkLibrary_DownCast)
    __swig_destroy__ = _StepSelect.delete_Handle_StepSelect_WorkLibrary

    def SetDumpLabel(self, *args):
        """
        SetDumpLabel(Handle_StepSelect_WorkLibrary self, Standard_Integer const mode)

        Selects a mode to dump entities
        0 (D) : prints numbers, then displays table number/label
        1 : prints labels, then displays table label/number
        2 : prints labels onky

        :type mode: int

        """
        return _StepSelect.Handle_StepSelect_WorkLibrary_SetDumpLabel(self, *args)


    def ReadFile(self, *args):
        """
        ReadFile(Handle_StepSelect_WorkLibrary self, Standard_CString const name, Handle_Interface_InterfaceModel model, Handle_Interface_Protocol protocol) -> Standard_Integer

        Reads a STEP File and returns a STEP Model (into <mod>),
        or lets <mod> "Null" in case of Error
        Returns 0 if OK, 1 if Read Error, -1 if File not opened

        :type name: OCC.wrapper.Standard.Standard_CString
        :type model: OCC.wrapper.Interface.Handle_Interface_InterfaceModel
        :type protocol: OCC.wrapper.Interface.Handle_Interface_Protocol
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepSelect.Handle_StepSelect_WorkLibrary_ReadFile(self, *args)


    def WriteFile(self, *args):
        """
        WriteFile(Handle_StepSelect_WorkLibrary self, IFSelect_ContextWrite ctx) -> Standard_Boolean

        Writes a File from a STEP Model
        Returns False (and writes no file) if <ctx> does not bring a
        STEP Model

        :type ctx: OCC.wrapper.IFSelect.IFSelect_ContextWrite
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepSelect.Handle_StepSelect_WorkLibrary_WriteFile(self, *args)


    def CopyModel(self, *args):
        """
        CopyModel(Handle_StepSelect_WorkLibrary self, Handle_Interface_InterfaceModel original, Handle_Interface_InterfaceModel newmodel, Interface_EntityIterator list, Interface_CopyTool TC) -> Standard_Boolean

        Performs the copy of entities from an original model to a new
        one. Works according <copymode> :
        if True, standard copy is run
        else nothing is done and returned value is False

        :type original: OCC.wrapper.Interface.Handle_Interface_InterfaceModel
        :type newmodel: OCC.wrapper.Interface.Handle_Interface_InterfaceModel
        :type list: OCC.wrapper.Interface.Interface_EntityIterator
        :type TC: OCC.wrapper.Interface.Interface_CopyTool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepSelect.Handle_StepSelect_WorkLibrary_CopyModel(self, *args)


    def DumpEntity(self, *args):
        """
        DumpEntity(Handle_StepSelect_WorkLibrary self, Handle_Interface_InterfaceModel model, Handle_Interface_Protocol protocol, Handle_Standard_Transient entity, Handle_Message_Messenger S, Standard_Integer const level)

        Dumps an entity under STEP form, i.e. as a part of a Step file
        Works with a StepDumper.
        Level 0 just displays type; level 1 displays the entity itself
        and level 2 displays the entity plus its shared ones (one
        sub-level : immediately shared entities)

        :type model: OCC.wrapper.Interface.Handle_Interface_InterfaceModel
        :type protocol: OCC.wrapper.Interface.Handle_Interface_Protocol
        :type entity: OCC.wrapper.Standard.Handle_Standard_Transient
        :type S: OCC.wrapper.Message.Handle_Message_Messenger
        :type level: int

        """
        return _StepSelect.Handle_StepSelect_WorkLibrary_DumpEntity(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepSelect_WorkLibrary self) -> char const *

        :rtype: const char *

        """
        return _StepSelect.Handle_StepSelect_WorkLibrary_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepSelect.Handle_StepSelect_WorkLibrary_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepSelect.Handle_StepSelect_WorkLibrary_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetDumpLevels(self, *args):
        """
        SetDumpLevels(Handle_StepSelect_WorkLibrary self, Standard_Integer const arg2, Standard_Integer const max)

        Records a default level and a maximum value for level
        level for DumpEntity can go between 0 and <max>
        default value will be <def>

        :type def: int
        :type max: int

        """
        return _StepSelect.Handle_StepSelect_WorkLibrary_SetDumpLevels(self, *args)


    def DumpLevels(self, *args):
        """
        DumpLevels(Handle_StepSelect_WorkLibrary self)

        Returns the recorded default and maximum dump levels
        If none was recorded, max is returned negative, def as zero

        :type def: int
        :type max: int

        """
        return _StepSelect.Handle_StepSelect_WorkLibrary_DumpLevels(self, *args)


    def SetDumpHelp(self, *args):
        """
        SetDumpHelp(Handle_StepSelect_WorkLibrary self, Standard_Integer const level, Standard_CString const help)

        Records a short line of help for a level (0 - max)

        :type level: int
        :type help: OCC.wrapper.Standard.Standard_CString

        """
        return _StepSelect.Handle_StepSelect_WorkLibrary_SetDumpHelp(self, *args)


    def DumpHelp(self, *args):
        """
        DumpHelp(Handle_StepSelect_WorkLibrary self, Standard_Integer const level) -> Standard_CString

        Returns the help line recorded for <level>, or an empty string

        :type level: int
        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _StepSelect.Handle_StepSelect_WorkLibrary_DumpHelp(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepSelect_WorkLibrary self)

        Memory deallocator for transient classes


        """
        return _StepSelect.Handle_StepSelect_WorkLibrary_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepSelect_WorkLibrary self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepSelect_WorkLibrary self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepSelect.Handle_StepSelect_WorkLibrary_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepSelect_WorkLibrary self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepSelect_WorkLibrary self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepSelect.Handle_StepSelect_WorkLibrary_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepSelect_WorkLibrary self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepSelect.Handle_StepSelect_WorkLibrary_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepSelect_WorkLibrary self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepSelect.Handle_StepSelect_WorkLibrary_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepSelect_WorkLibrary self)

        Increments the reference counter of this object


        """
        return _StepSelect.Handle_StepSelect_WorkLibrary_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepSelect_WorkLibrary self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepSelect.Handle_StepSelect_WorkLibrary_DecrementRefCounter(self, *args)

Handle_StepSelect_WorkLibrary_swigregister = _StepSelect.Handle_StepSelect_WorkLibrary_swigregister
Handle_StepSelect_WorkLibrary_swigregister(Handle_StepSelect_WorkLibrary)

def Handle_StepSelect_WorkLibrary_DownCast(thing):
    return _StepSelect.Handle_StepSelect_WorkLibrary_DownCast(thing)
Handle_StepSelect_WorkLibrary_DownCast = _StepSelect.Handle_StepSelect_WorkLibrary_DownCast

class StepSelect_Activator(IFSelect.IFSelect_Activator):
    """
    Performs Actions specific to StepSelect, i.e. creation of
    Step Selections and Counters, plus dumping specific to Step
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepSelect_Activator
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepSelect_Activator(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepSelect_Activator self) -> StepSelect_Activator

        Performs Actions specific to StepSelect, i.e. creation of
        Step Selections and Counters, plus dumping specific to Step
        """
        this = _StepSelect.new_StepSelect_Activator(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Do(self, *args):
        """
        Do(StepSelect_Activator self, Standard_Integer const number, Handle_IFSelect_SessionPilot pilot) -> IFSelect_ReturnStatus

        Executes a Command Line for StepSelect

        :type number: int
        :type pilot: OCC.wrapper.IFSelect.Handle_IFSelect_SessionPilot
        :rtype: OCC.wrapper.IFSelect.IFSelect_ReturnStatus

        """
        return _StepSelect.StepSelect_Activator_Do(self, *args)


    def Help(self, *args):
        """
        Help(StepSelect_Activator self, Standard_Integer const number) -> Standard_CString

        Sends a short help message for StepSelect commands

        :type number: int
        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _StepSelect.StepSelect_Activator_Help(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepSelect.StepSelect_Activator_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepSelect.StepSelect_Activator_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepSelect.StepSelect_Activator_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepSelect.delete_StepSelect_Activator
StepSelect_Activator_swigregister = _StepSelect.StepSelect_Activator_swigregister
StepSelect_Activator_swigregister(StepSelect_Activator)

def StepSelect_Activator_get_type_name(*args):
    """
    StepSelect_Activator_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepSelect.StepSelect_Activator_get_type_name(*args)

def StepSelect_Activator_get_type_descriptor(*args):
    """
    StepSelect_Activator_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepSelect.StepSelect_Activator_get_type_descriptor(*args)

class Handle_StepSelect_ModelModifier(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepSelect_ModelModifier self)

        Nullify the handle


        """
        return _StepSelect.Handle_StepSelect_ModelModifier_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepSelect_ModelModifier self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepSelect.Handle_StepSelect_ModelModifier_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepSelect_ModelModifier self, StepSelect_ModelModifier thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepSelect.Handle_StepSelect_ModelModifier_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepSelect_ModelModifier self, Handle_StepSelect_ModelModifier theHandle) -> Handle_StepSelect_ModelModifier
        assign(Handle_StepSelect_ModelModifier self, StepSelect_ModelModifier thePtr) -> Handle_StepSelect_ModelModifier
        assign(Handle_StepSelect_ModelModifier self, Handle_StepSelect_ModelModifier theHandle) -> Handle_StepSelect_ModelModifier

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepSelect.Handle_StepSelect_ModelModifier_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepSelect_ModelModifier self) -> StepSelect_ModelModifier

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepSelect.Handle_StepSelect_ModelModifier_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepSelect_ModelModifier self) -> StepSelect_ModelModifier

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepSelect.Handle_StepSelect_ModelModifier___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepSelect_ModelModifier self) -> StepSelect_ModelModifier

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepSelect.Handle_StepSelect_ModelModifier___ref__(self, *args)


    def __hash__(self):
        return _StepSelect.Handle_StepSelect_ModelModifier___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepSelect.Handle_StepSelect_ModelModifier___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepSelect.new_Handle_StepSelect_ModelModifier(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepSelect.Handle_StepSelect_ModelModifier_DownCast)
    __swig_destroy__ = _StepSelect.delete_Handle_StepSelect_ModelModifier

    def Perform(self, *args):
        """
        Perform(Handle_StepSelect_ModelModifier self, IFSelect_ContextModif ctx, Handle_Interface_InterfaceModel target, Handle_Interface_Protocol protocol, Interface_CopyTool TC)

        The inherited Perform does the required cast (and refuses to
        go further if cast has failed) then calls the instantiated
        Performing

        :type ctx: OCC.wrapper.IFSelect.IFSelect_ContextModif
        :type target: OCC.wrapper.Interface.Handle_Interface_InterfaceModel
        :type protocol: OCC.wrapper.Interface.Handle_Interface_Protocol
        :type TC: OCC.wrapper.Interface.Interface_CopyTool

        """
        return _StepSelect.Handle_StepSelect_ModelModifier_Perform(self, *args)


    def PerformProtocol(self, *args):
        """
        PerformProtocol(Handle_StepSelect_ModelModifier self, IFSelect_ContextModif ctx, Handle_StepData_StepModel target, Handle_StepData_Protocol proto, Interface_CopyTool TC)

        Specific Perform with Protocol. It is defined to let the
        Protocol unused and to call Performing without Protocol
        (most current case). It can be redefined if specific action
        requires Protocol.

        :type ctx: OCC.wrapper.IFSelect.IFSelect_ContextModif
        :type target: OCC.wrapper.StepData.Handle_StepData_StepModel
        :type proto: OCC.wrapper.StepData.Handle_StepData_Protocol
        :type TC: OCC.wrapper.Interface.Interface_CopyTool

        """
        return _StepSelect.Handle_StepSelect_ModelModifier_PerformProtocol(self, *args)


    def Performing(self, *args):
        """
        Performing(Handle_StepSelect_ModelModifier self, IFSelect_ContextModif ctx, Handle_StepData_StepModel target, Interface_CopyTool TC)

        Specific Perform, without Protocol. If Performing with
        Protocol is redefined, Performing without Protocol must
        though be defined to do nothing (not called, but demanded
        by the linker)

        :type ctx: OCC.wrapper.IFSelect.IFSelect_ContextModif
        :type target: OCC.wrapper.StepData.Handle_StepData_StepModel
        :type TC: OCC.wrapper.Interface.Interface_CopyTool

        """
        return _StepSelect.Handle_StepSelect_ModelModifier_Performing(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepSelect_ModelModifier self) -> char const *

        :rtype: const char *

        """
        return _StepSelect.Handle_StepSelect_ModelModifier_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepSelect.Handle_StepSelect_ModelModifier_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepSelect.Handle_StepSelect_ModelModifier_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def MayChangeGraph(self, *args):
        """
        MayChangeGraph(Handle_StepSelect_ModelModifier self) -> Standard_Boolean

        Returns True if this modifier may change the graph of
        dependences (aknowledged at creation time)

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepSelect.Handle_StepSelect_ModelModifier_MayChangeGraph(self, *args)


    def SetDispatch(self, *args):
        """
        SetDispatch(Handle_StepSelect_ModelModifier self, Handle_IFSelect_Dispatch disp)

        Attaches to a Dispatch. If <disp> is Null, Resets it
        (to apply the Modifier on every Dispatch)

        :type disp: OCC.wrapper.IFSelect.Handle_IFSelect_Dispatch

        """
        return _StepSelect.Handle_StepSelect_ModelModifier_SetDispatch(self, *args)


    def Dispatch(self, *args):
        """
        Dispatch(Handle_StepSelect_ModelModifier self) -> Handle_IFSelect_Dispatch

        Returns the Dispatch to be matched, Null if not set

        :rtype: OCC.wrapper.IFSelect.Handle_IFSelect_Dispatch

        """
        return _StepSelect.Handle_StepSelect_ModelModifier_Dispatch(self, *args)


    def Applies(self, *args):
        """
        Applies(Handle_StepSelect_ModelModifier self, Handle_IFSelect_Dispatch disp) -> Standard_Boolean

        Returns True if a Model obtained from the Dispatch <disp>
        is to be treated (apart from the Selection criterium)
        If Dispatch(me) is Null, returns True. Else, checks <disp>

        :type disp: OCC.wrapper.IFSelect.Handle_IFSelect_Dispatch
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepSelect.Handle_StepSelect_ModelModifier_Applies(self, *args)


    def SetSelection(self, *args):
        """
        SetSelection(Handle_StepSelect_ModelModifier self, Handle_IFSelect_Selection sel)

        Sets a Selection : a Model is treated if it contains one or
        more Entities designated by the Selection

        :type sel: OCC.wrapper.IFSelect.Handle_IFSelect_Selection

        """
        return _StepSelect.Handle_StepSelect_ModelModifier_SetSelection(self, *args)


    def ResetSelection(self, *args):
        """
        ResetSelection(Handle_StepSelect_ModelModifier self)

        Resets the Selection : this criterium is not longer active


        """
        return _StepSelect.Handle_StepSelect_ModelModifier_ResetSelection(self, *args)


    def HasSelection(self, *args):
        """
        HasSelection(Handle_StepSelect_ModelModifier self) -> Standard_Boolean

        Returns True if a Selection is set as an additionnal criterium

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepSelect.Handle_StepSelect_ModelModifier_HasSelection(self, *args)


    def Selection(self, *args):
        """
        Selection(Handle_StepSelect_ModelModifier self) -> Handle_IFSelect_Selection

        Returns the Selection, or a Null Handle if not set

        :rtype: OCC.wrapper.IFSelect.Handle_IFSelect_Selection

        """
        return _StepSelect.Handle_StepSelect_ModelModifier_Selection(self, *args)


    def Label(self, *args):
        """
        Label(Handle_StepSelect_ModelModifier self) -> TCollection_AsciiString

        Returns a short text which defines the operation performed

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _StepSelect.Handle_StepSelect_ModelModifier_Label(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepSelect_ModelModifier self)

        Memory deallocator for transient classes


        """
        return _StepSelect.Handle_StepSelect_ModelModifier_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepSelect_ModelModifier self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepSelect_ModelModifier self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepSelect.Handle_StepSelect_ModelModifier_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepSelect_ModelModifier self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepSelect_ModelModifier self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepSelect.Handle_StepSelect_ModelModifier_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepSelect_ModelModifier self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepSelect.Handle_StepSelect_ModelModifier_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepSelect_ModelModifier self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepSelect.Handle_StepSelect_ModelModifier_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepSelect_ModelModifier self)

        Increments the reference counter of this object


        """
        return _StepSelect.Handle_StepSelect_ModelModifier_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepSelect_ModelModifier self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepSelect.Handle_StepSelect_ModelModifier_DecrementRefCounter(self, *args)

Handle_StepSelect_ModelModifier_swigregister = _StepSelect.Handle_StepSelect_ModelModifier_swigregister
Handle_StepSelect_ModelModifier_swigregister(Handle_StepSelect_ModelModifier)

def Handle_StepSelect_ModelModifier_DownCast(thing):
    return _StepSelect.Handle_StepSelect_ModelModifier_DownCast(thing)
Handle_StepSelect_ModelModifier_DownCast = _StepSelect.Handle_StepSelect_ModelModifier_DownCast

class Handle_StepSelect_FloatFormat(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepSelect_FloatFormat self)

        Nullify the handle


        """
        return _StepSelect.Handle_StepSelect_FloatFormat_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepSelect_FloatFormat self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepSelect.Handle_StepSelect_FloatFormat_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepSelect_FloatFormat self, StepSelect_FloatFormat thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepSelect.Handle_StepSelect_FloatFormat_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepSelect_FloatFormat self, Handle_StepSelect_FloatFormat theHandle) -> Handle_StepSelect_FloatFormat
        assign(Handle_StepSelect_FloatFormat self, StepSelect_FloatFormat thePtr) -> Handle_StepSelect_FloatFormat
        assign(Handle_StepSelect_FloatFormat self, Handle_StepSelect_FloatFormat theHandle) -> Handle_StepSelect_FloatFormat

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepSelect.Handle_StepSelect_FloatFormat_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepSelect_FloatFormat self) -> StepSelect_FloatFormat

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepSelect.Handle_StepSelect_FloatFormat_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepSelect_FloatFormat self) -> StepSelect_FloatFormat

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepSelect.Handle_StepSelect_FloatFormat___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepSelect_FloatFormat self) -> StepSelect_FloatFormat

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepSelect.Handle_StepSelect_FloatFormat___ref__(self, *args)


    def __hash__(self):
        return _StepSelect.Handle_StepSelect_FloatFormat___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepSelect.Handle_StepSelect_FloatFormat___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepSelect.new_Handle_StepSelect_FloatFormat(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepSelect.Handle_StepSelect_FloatFormat_DownCast)
    __swig_destroy__ = _StepSelect.delete_Handle_StepSelect_FloatFormat

    def SetDefault(self, *args):
        """
        SetDefault(Handle_StepSelect_FloatFormat self, Standard_Integer const digits=0)

        Sets FloatFormat to default value (see Create) but if <digits>
        is given positive, it commands Formats (main and range) to
        ensure <digits> significant digits to be displayed

        :type digits: int

        """
        return _StepSelect.Handle_StepSelect_FloatFormat_SetDefault(self, *args)


    def SetZeroSuppress(self, *args):
        """
        SetZeroSuppress(Handle_StepSelect_FloatFormat self, Standard_Boolean const mode)

        Sets ZeroSuppress mode to a new value

        :type mode: bool

        """
        return _StepSelect.Handle_StepSelect_FloatFormat_SetZeroSuppress(self, *args)


    def SetFormat(self, *args):
        """
        SetFormat(Handle_StepSelect_FloatFormat self, Standard_CString const format)

        Sets Main Format to a new value
        Remark : SetFormat, SetZeroSuppress and SetFormatForRange are
        independant

        :type format: OCC.wrapper.Standard.Standard_CString

        """
        return _StepSelect.Handle_StepSelect_FloatFormat_SetFormat(self, *args)


    def SetFormatForRange(self, *args):
        """
        SetFormatForRange(Handle_StepSelect_FloatFormat self, Standard_CString const format, Standard_Real const Rmin=0.1, Standard_Real const Rmax=1000.0)

        Sets Format for Range to a new value with its range of
        application.
        To cancel it, give format as "" (empty string)
        Remark that if the condition (0. < Rmin < Rmax)  is not
        verified, this secondary format will be ignored.
        Moreover, this secondary format is intended to be used in a
        range around 1.

        :type format: OCC.wrapper.Standard.Standard_CString
        :type Rmin: float
        :type Rmax: float

        """
        return _StepSelect.Handle_StepSelect_FloatFormat_SetFormatForRange(self, *args)


    def Format(self, *args):
        """
        Format(Handle_StepSelect_FloatFormat self, TCollection_AsciiString mainform, TCollection_AsciiString forminrange)

        Returns all recorded parameters :
        zerosup  : ZeroSuppress status
        mainform : Main Format (which applies out of the range, or
        for every real if no range is set)
        hasrange : True if a FormatInRange is set, False else
        (following parameters do not apply if it is False)
        forminrange : Secondary Format (it applies inside the range)
        rangemin, rangemax : the range in which the secondary format
        applies

        :type zerosup: bool
        :type mainform: OCC.wrapper.TCollection.TCollection_AsciiString
        :type hasrange: bool
        :type forminrange: OCC.wrapper.TCollection.TCollection_AsciiString
        :type rangemin: float
        :type rangemax: float

        """
        return _StepSelect.Handle_StepSelect_FloatFormat_Format(self, *args)


    def Perform(self, *args):
        """
        Perform(Handle_StepSelect_FloatFormat self, IFSelect_ContextWrite ctx, StepData_StepWriter writer)

        Sets the Floatting Formats of StepWriter to the recorded
        parameters

        :type ctx: OCC.wrapper.IFSelect.IFSelect_ContextWrite
        :type writer: OCC.wrapper.StepData.StepData_StepWriter

        """
        return _StepSelect.Handle_StepSelect_FloatFormat_Perform(self, *args)


    def Label(self, *args):
        """
        Label(Handle_StepSelect_FloatFormat self) -> TCollection_AsciiString

        Returns specific Label : for instance,
        "Float Format [ZeroSuppress] %E [, in range R1-R2 %f]"

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _StepSelect.Handle_StepSelect_FloatFormat_Label(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepSelect_FloatFormat self) -> char const *

        :rtype: const char *

        """
        return _StepSelect.Handle_StepSelect_FloatFormat_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepSelect.Handle_StepSelect_FloatFormat_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepSelect.Handle_StepSelect_FloatFormat_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def MayChangeGraph(self, *args):
        """
        MayChangeGraph(Handle_StepSelect_FloatFormat self) -> Standard_Boolean

        Returns True if this modifier may change the graph of
        dependences (aknowledged at creation time)

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepSelect.Handle_StepSelect_FloatFormat_MayChangeGraph(self, *args)


    def SetDispatch(self, *args):
        """
        SetDispatch(Handle_StepSelect_FloatFormat self, Handle_IFSelect_Dispatch disp)

        Attaches to a Dispatch. If <disp> is Null, Resets it
        (to apply the Modifier on every Dispatch)

        :type disp: OCC.wrapper.IFSelect.Handle_IFSelect_Dispatch

        """
        return _StepSelect.Handle_StepSelect_FloatFormat_SetDispatch(self, *args)


    def Dispatch(self, *args):
        """
        Dispatch(Handle_StepSelect_FloatFormat self) -> Handle_IFSelect_Dispatch

        Returns the Dispatch to be matched, Null if not set

        :rtype: OCC.wrapper.IFSelect.Handle_IFSelect_Dispatch

        """
        return _StepSelect.Handle_StepSelect_FloatFormat_Dispatch(self, *args)


    def Applies(self, *args):
        """
        Applies(Handle_StepSelect_FloatFormat self, Handle_IFSelect_Dispatch disp) -> Standard_Boolean

        Returns True if a Model obtained from the Dispatch <disp>
        is to be treated (apart from the Selection criterium)
        If Dispatch(me) is Null, returns True. Else, checks <disp>

        :type disp: OCC.wrapper.IFSelect.Handle_IFSelect_Dispatch
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepSelect.Handle_StepSelect_FloatFormat_Applies(self, *args)


    def SetSelection(self, *args):
        """
        SetSelection(Handle_StepSelect_FloatFormat self, Handle_IFSelect_Selection sel)

        Sets a Selection : a Model is treated if it contains one or
        more Entities designated by the Selection

        :type sel: OCC.wrapper.IFSelect.Handle_IFSelect_Selection

        """
        return _StepSelect.Handle_StepSelect_FloatFormat_SetSelection(self, *args)


    def ResetSelection(self, *args):
        """
        ResetSelection(Handle_StepSelect_FloatFormat self)

        Resets the Selection : this criterium is not longer active


        """
        return _StepSelect.Handle_StepSelect_FloatFormat_ResetSelection(self, *args)


    def HasSelection(self, *args):
        """
        HasSelection(Handle_StepSelect_FloatFormat self) -> Standard_Boolean

        Returns True if a Selection is set as an additionnal criterium

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepSelect.Handle_StepSelect_FloatFormat_HasSelection(self, *args)


    def Selection(self, *args):
        """
        Selection(Handle_StepSelect_FloatFormat self) -> Handle_IFSelect_Selection

        Returns the Selection, or a Null Handle if not set

        :rtype: OCC.wrapper.IFSelect.Handle_IFSelect_Selection

        """
        return _StepSelect.Handle_StepSelect_FloatFormat_Selection(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepSelect_FloatFormat self)

        Memory deallocator for transient classes


        """
        return _StepSelect.Handle_StepSelect_FloatFormat_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepSelect_FloatFormat self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepSelect_FloatFormat self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepSelect.Handle_StepSelect_FloatFormat_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepSelect_FloatFormat self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepSelect_FloatFormat self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepSelect.Handle_StepSelect_FloatFormat_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepSelect_FloatFormat self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepSelect.Handle_StepSelect_FloatFormat_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepSelect_FloatFormat self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepSelect.Handle_StepSelect_FloatFormat_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepSelect_FloatFormat self)

        Increments the reference counter of this object


        """
        return _StepSelect.Handle_StepSelect_FloatFormat_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepSelect_FloatFormat self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepSelect.Handle_StepSelect_FloatFormat_DecrementRefCounter(self, *args)

Handle_StepSelect_FloatFormat_swigregister = _StepSelect.Handle_StepSelect_FloatFormat_swigregister
Handle_StepSelect_FloatFormat_swigregister(Handle_StepSelect_FloatFormat)

def Handle_StepSelect_FloatFormat_DownCast(thing):
    return _StepSelect.Handle_StepSelect_FloatFormat_DownCast(thing)
Handle_StepSelect_FloatFormat_DownCast = _StepSelect.Handle_StepSelect_FloatFormat_DownCast

class Handle_StepSelect_Activator(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepSelect_Activator self)

        Nullify the handle


        """
        return _StepSelect.Handle_StepSelect_Activator_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepSelect_Activator self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepSelect.Handle_StepSelect_Activator_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepSelect_Activator self, StepSelect_Activator thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepSelect.Handle_StepSelect_Activator_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepSelect_Activator self, Handle_StepSelect_Activator theHandle) -> Handle_StepSelect_Activator
        assign(Handle_StepSelect_Activator self, StepSelect_Activator thePtr) -> Handle_StepSelect_Activator
        assign(Handle_StepSelect_Activator self, Handle_StepSelect_Activator theHandle) -> Handle_StepSelect_Activator

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepSelect.Handle_StepSelect_Activator_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepSelect_Activator self) -> StepSelect_Activator

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepSelect.Handle_StepSelect_Activator_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepSelect_Activator self) -> StepSelect_Activator

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepSelect.Handle_StepSelect_Activator___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepSelect_Activator self) -> StepSelect_Activator

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepSelect.Handle_StepSelect_Activator___ref__(self, *args)


    def __hash__(self):
        return _StepSelect.Handle_StepSelect_Activator___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepSelect.Handle_StepSelect_Activator___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepSelect.new_Handle_StepSelect_Activator(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepSelect.Handle_StepSelect_Activator_DownCast)
    __swig_destroy__ = _StepSelect.delete_Handle_StepSelect_Activator

    def Do(self, *args):
        """
        Do(Handle_StepSelect_Activator self, Standard_Integer const number, Handle_IFSelect_SessionPilot pilot) -> IFSelect_ReturnStatus

        Executes a Command Line for StepSelect

        :type number: int
        :type pilot: OCC.wrapper.IFSelect.Handle_IFSelect_SessionPilot
        :rtype: OCC.wrapper.IFSelect.IFSelect_ReturnStatus

        """
        return _StepSelect.Handle_StepSelect_Activator_Do(self, *args)


    def Help(self, *args):
        """
        Help(Handle_StepSelect_Activator self, Standard_Integer const number) -> Standard_CString

        Sends a short help message for StepSelect commands

        :type number: int
        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _StepSelect.Handle_StepSelect_Activator_Help(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepSelect_Activator self) -> char const *

        :rtype: const char *

        """
        return _StepSelect.Handle_StepSelect_Activator_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepSelect.Handle_StepSelect_Activator_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepSelect.Handle_StepSelect_Activator_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Adding(self, *args):
        """
        Adding(Handle_StepSelect_Activator self, Handle_IFSelect_Activator actor, Standard_Integer const number, Standard_CString const command, Standard_Integer const mode)

        Records, in a Dictionary available for all the Activators,
        the command title an Activator can process, attached with
        its number, proper for this Activator
        <mode> allows to distinguish various execution modes
        0: default mode; 1 : for xset

        :type actor: OCC.wrapper.IFSelect.Handle_IFSelect_Activator
        :type number: int
        :type command: OCC.wrapper.Standard.Standard_CString
        :type mode: int

        """
        return _StepSelect.Handle_StepSelect_Activator_Adding(self, *args)


    def Add(self, *args):
        """
        Add(Handle_StepSelect_Activator self, Standard_Integer const number, Standard_CString const command)

        Allows a self-definition by an Activator of the Commands it
        processes, call the class method Adding (mode 0)

        :type number: int
        :type command: OCC.wrapper.Standard.Standard_CString

        """
        return _StepSelect.Handle_StepSelect_Activator_Add(self, *args)


    def AddSet(self, *args):
        """
        AddSet(Handle_StepSelect_Activator self, Standard_Integer const number, Standard_CString const command)

        Same as Add but specifies that this command is candidate for
        xset (creation of items, xset : named items; mode 1)

        :type number: int
        :type command: OCC.wrapper.Standard.Standard_CString

        """
        return _StepSelect.Handle_StepSelect_Activator_AddSet(self, *args)


    def Remove(self, *args):
        """
        Remove(Handle_StepSelect_Activator self, Standard_CString const command)

        Removes a Command, if it is recorded (else, does nothing)

        :type command: OCC.wrapper.Standard.Standard_CString

        """
        return _StepSelect.Handle_StepSelect_Activator_Remove(self, *args)


    def Select(self, *args):
        """
        Select(Handle_StepSelect_Activator self, Standard_CString const command, Handle_IFSelect_Activator actor) -> Standard_Boolean

        Selects, for a Command given by its title, an actor with its
        command number. Returns True if found, False else

        :type command: OCC.wrapper.Standard.Standard_CString
        :type number: int
        :type actor: OCC.wrapper.IFSelect.Handle_IFSelect_Activator
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepSelect.Handle_StepSelect_Activator_Select(self, *args)


    def Mode(self, *args):
        """
        Mode(Handle_StepSelect_Activator self, Standard_CString const command) -> Standard_Integer

        Returns mode recorded for a command. -1 if not found

        :type command: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepSelect.Handle_StepSelect_Activator_Mode(self, *args)


    def Commands(self, *args):
        """
        Commands(Handle_StepSelect_Activator self, Standard_Integer const mode=-1, Standard_CString const command) -> Handle_TColStd_HSequenceOfAsciiString

        Returns, for a root of command title, the list of possible
        commands.
        <mode> : -1 (D) for all commands if <commands> is empty
        -1 + command : about a Group , >= 0 see Adding
        By default, it returns the whole list of known commands.

        :type mode: int
        :type command: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfAsciiString

        """
        return _StepSelect.Handle_StepSelect_Activator_Commands(self, *args)


    def Group(self, *args):
        """
        Group(Handle_StepSelect_Activator self) -> Standard_CString

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _StepSelect.Handle_StepSelect_Activator_Group(self, *args)


    def File(self, *args):
        """
        File(Handle_StepSelect_Activator self) -> Standard_CString

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _StepSelect.Handle_StepSelect_Activator_File(self, *args)


    def SetForGroup(self, *args):
        """
        SetForGroup(Handle_StepSelect_Activator self, Standard_CString const group, Standard_CString const file)

        Group and SetGroup define a "Group of commands" which
        correspond to an Activator. Default is "XSTEP"
        Also a file may be attached

        :type group: OCC.wrapper.Standard.Standard_CString
        :type file: OCC.wrapper.Standard.Standard_CString

        """
        return _StepSelect.Handle_StepSelect_Activator_SetForGroup(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepSelect_Activator self)

        Memory deallocator for transient classes


        """
        return _StepSelect.Handle_StepSelect_Activator_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepSelect_Activator self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepSelect_Activator self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepSelect.Handle_StepSelect_Activator_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepSelect_Activator self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepSelect_Activator self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepSelect.Handle_StepSelect_Activator_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepSelect_Activator self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepSelect.Handle_StepSelect_Activator_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepSelect_Activator self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepSelect.Handle_StepSelect_Activator_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepSelect_Activator self)

        Increments the reference counter of this object


        """
        return _StepSelect.Handle_StepSelect_Activator_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepSelect_Activator self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepSelect.Handle_StepSelect_Activator_DecrementRefCounter(self, *args)

Handle_StepSelect_Activator_swigregister = _StepSelect.Handle_StepSelect_Activator_swigregister
Handle_StepSelect_Activator_swigregister(Handle_StepSelect_Activator)

def Handle_StepSelect_Activator_DownCast(thing):
    return _StepSelect.Handle_StepSelect_Activator_DownCast(thing)
Handle_StepSelect_Activator_DownCast = _StepSelect.Handle_StepSelect_Activator_DownCast

class Handle_StepSelect_StepType(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepSelect_StepType self)

        Nullify the handle


        """
        return _StepSelect.Handle_StepSelect_StepType_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepSelect_StepType self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepSelect.Handle_StepSelect_StepType_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepSelect_StepType self, StepSelect_StepType thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepSelect.Handle_StepSelect_StepType_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepSelect_StepType self, Handle_StepSelect_StepType theHandle) -> Handle_StepSelect_StepType
        assign(Handle_StepSelect_StepType self, StepSelect_StepType thePtr) -> Handle_StepSelect_StepType
        assign(Handle_StepSelect_StepType self, Handle_StepSelect_StepType theHandle) -> Handle_StepSelect_StepType

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepSelect.Handle_StepSelect_StepType_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepSelect_StepType self) -> StepSelect_StepType

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepSelect.Handle_StepSelect_StepType_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepSelect_StepType self) -> StepSelect_StepType

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepSelect.Handle_StepSelect_StepType___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepSelect_StepType self) -> StepSelect_StepType

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepSelect.Handle_StepSelect_StepType___ref__(self, *args)


    def __hash__(self):
        return _StepSelect.Handle_StepSelect_StepType___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepSelect.Handle_StepSelect_StepType___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepSelect.new_Handle_StepSelect_StepType(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepSelect.Handle_StepSelect_StepType_DownCast)
    __swig_destroy__ = _StepSelect.delete_Handle_StepSelect_StepType

    def SetProtocol(self, *args):
        """
        SetProtocol(Handle_StepSelect_StepType self, Handle_Interface_Protocol proto)

        Sets the StepType signature to work with a Protocol : this
        initialises the library

        :type proto: OCC.wrapper.Interface.Handle_Interface_Protocol

        """
        return _StepSelect.Handle_StepSelect_StepType_SetProtocol(self, *args)


    def Value(self, *args):
        """
        Value(Handle_StepSelect_StepType self, Handle_Standard_Transient ent, Handle_Interface_InterfaceModel model) -> Standard_CString

        Returns the Step Type defined from the Protocol (see above).
        If <ent> is not recognised, produces "..NOT FROM SCHEMA <name>.."

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type model: OCC.wrapper.Interface.Handle_Interface_InterfaceModel
        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _StepSelect.Handle_StepSelect_StepType_Value(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepSelect_StepType self) -> char const *

        :rtype: const char *

        """
        return _StepSelect.Handle_StepSelect_StepType_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepSelect.Handle_StepSelect_StepType_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepSelect.Handle_StepSelect_StepType_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetIntCase(self, *args):
        """
        SetIntCase(Handle_StepSelect_StepType self, Standard_Boolean const hasmin, Standard_Integer const valmin, Standard_Boolean const hasmax, Standard_Integer const valmax)

        Sets the information data to tell "integer cases" with
        possible min and max values
        To be called when creating

        :type hasmin: bool
        :type valmin: int
        :type hasmax: bool
        :type valmax: int

        """
        return _StepSelect.Handle_StepSelect_StepType_SetIntCase(self, *args)


    def IsIntCase(self, *args):
        """
        IsIntCase(Handle_StepSelect_StepType self) -> Standard_Boolean

        Tells if this Signature gives integer values
        and returns values from SetIntCase if True

        :type hasmin: bool
        :type valmin: int
        :type hasmax: bool
        :type valmax: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepSelect.Handle_StepSelect_StepType_IsIntCase(self, *args)


    def AddCase(self, *args):
        """
        AddCase(Handle_StepSelect_StepType self, Standard_CString const acase)

        Adds a possible case
        To be called when creating, IF the list of possible cases for
        Value is known when starting
        For instance, for CDL types, rather do not fill this,
        but for a specific enumeration (such as a status), can be used

        :type acase: OCC.wrapper.Standard.Standard_CString

        """
        return _StepSelect.Handle_StepSelect_StepType_AddCase(self, *args)


    def CaseList(self, *args):
        """
        CaseList(Handle_StepSelect_StepType self) -> Handle_TColStd_HSequenceOfAsciiString

        Returns the predefined list of possible cases, filled by AddCase
        Null Handle if no predefined list (hence, to be counted)
        Useful to filter on  really possible vase, for instance, or
        for a help

        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfAsciiString

        """
        return _StepSelect.Handle_StepSelect_StepType_CaseList(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepSelect_StepType self) -> Standard_CString

        Returns an identification of the Signature (a word), given at
        initialization time
        Returns the Signature for a Transient object. It is specific
        of each sub-class of Signature. For a Null Handle, it should
        provide ""
        It can work with the model which contains the entity

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _StepSelect.Handle_StepSelect_StepType_Name(self, *args)


    def Label(self, *args):
        """
        Label(Handle_StepSelect_StepType self) -> TCollection_AsciiString

        The label of a Signature uses its name as follow :
        "Signature : <name>"

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _StepSelect.Handle_StepSelect_StepType_Label(self, *args)


    def Matches(self, *args):
        """
        Matches(Handle_StepSelect_StepType self, Handle_Standard_Transient ent, Handle_Interface_InterfaceModel model, TCollection_AsciiString text, Standard_Boolean const exact) -> Standard_Boolean

        Tells if the value for <ent> in <model> matches a text, with
        a criterium <exact>.
        The default definition calls MatchValue
        Can be redefined

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type model: OCC.wrapper.Interface.Handle_Interface_InterfaceModel
        :type text: OCC.wrapper.TCollection.TCollection_AsciiString
        :type exact: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepSelect.Handle_StepSelect_StepType_Matches(self, *args)


    def MatchValue(self, *args):
        """
        MatchValue(Handle_StepSelect_StepType self, Standard_CString const val, TCollection_AsciiString text, Standard_Boolean const exact) -> Standard_Boolean

        Default procedure to tell if a value <val> matches a text
        with a criterium <exact>. <exact> = True requires equality,
        else only contained (no reg-exp)

        :type val: OCC.wrapper.Standard.Standard_CString
        :type text: OCC.wrapper.TCollection.TCollection_AsciiString
        :type exact: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepSelect.Handle_StepSelect_StepType_MatchValue(self, *args)


    def IntValue(self, *args):
        """
        IntValue(Handle_StepSelect_StepType self, Standard_Integer const val) -> Standard_CString

        This procedure converts an Integer to a CString
        It is a convenient way when the value of a signature has the
        form of a simple integer value
        The value is to be used immediately (one buffer only, no copy)

        :type val: int
        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _StepSelect.Handle_StepSelect_StepType_IntValue(self, *args)


    def Text(self, *args):
        """
        Text(Handle_StepSelect_StepType self, Handle_Standard_Transient ent, Handle_Standard_Transient context) -> TCollection_AsciiString

        Returns an identification of the Signature (a word), given at
        initialization time
        Specialised to consider context as an InterfaceModel

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type context: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _StepSelect.Handle_StepSelect_StepType_Text(self, *args)


    def ClassName(self, *args):
        """
        ClassName(Handle_StepSelect_StepType self, Standard_CString const typnam) -> Standard_CString

        From a CDL Type Name, returns the Class part (package dropped)
        WARNING : buffered, to be immediately copied or printed

        :type typnam: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _StepSelect.Handle_StepSelect_StepType_ClassName(self, *args)


    def TextAlone(self, *args):
        """
        TextAlone(Handle_StepSelect_StepType self, Handle_Standard_Transient ent) -> TCollection_AsciiString

        Gives a text as a signature for a transient object alone, i.e.
        without defined context.
        By default, calls Text with undefined context (Null Handle) and
        if empty, then returns DynamicType

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _StepSelect.Handle_StepSelect_StepType_TextAlone(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepSelect_StepType self)

        Memory deallocator for transient classes


        """
        return _StepSelect.Handle_StepSelect_StepType_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepSelect_StepType self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepSelect_StepType self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepSelect.Handle_StepSelect_StepType_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepSelect_StepType self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepSelect_StepType self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepSelect.Handle_StepSelect_StepType_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepSelect_StepType self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepSelect.Handle_StepSelect_StepType_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepSelect_StepType self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepSelect.Handle_StepSelect_StepType_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepSelect_StepType self)

        Increments the reference counter of this object


        """
        return _StepSelect.Handle_StepSelect_StepType_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepSelect_StepType self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepSelect.Handle_StepSelect_StepType_DecrementRefCounter(self, *args)

Handle_StepSelect_StepType_swigregister = _StepSelect.Handle_StepSelect_StepType_swigregister
Handle_StepSelect_StepType_swigregister(Handle_StepSelect_StepType)

def Handle_StepSelect_StepType_DownCast(thing):
    return _StepSelect.Handle_StepSelect_StepType_DownCast(thing)
Handle_StepSelect_StepType_DownCast = _StepSelect.Handle_StepSelect_StepType_DownCast

class Handle_StepSelect_FileModifier(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepSelect_FileModifier self)

        Nullify the handle


        """
        return _StepSelect.Handle_StepSelect_FileModifier_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepSelect_FileModifier self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepSelect.Handle_StepSelect_FileModifier_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepSelect_FileModifier self, StepSelect_FileModifier thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepSelect.Handle_StepSelect_FileModifier_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepSelect_FileModifier self, Handle_StepSelect_FileModifier theHandle) -> Handle_StepSelect_FileModifier
        assign(Handle_StepSelect_FileModifier self, StepSelect_FileModifier thePtr) -> Handle_StepSelect_FileModifier
        assign(Handle_StepSelect_FileModifier self, Handle_StepSelect_FileModifier theHandle) -> Handle_StepSelect_FileModifier

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepSelect.Handle_StepSelect_FileModifier_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepSelect_FileModifier self) -> StepSelect_FileModifier

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepSelect.Handle_StepSelect_FileModifier_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepSelect_FileModifier self) -> StepSelect_FileModifier

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepSelect.Handle_StepSelect_FileModifier___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepSelect_FileModifier self) -> StepSelect_FileModifier

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepSelect.Handle_StepSelect_FileModifier___ref__(self, *args)


    def __hash__(self):
        return _StepSelect.Handle_StepSelect_FileModifier___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepSelect.Handle_StepSelect_FileModifier___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepSelect.new_Handle_StepSelect_FileModifier(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepSelect.Handle_StepSelect_FileModifier_DownCast)
    __swig_destroy__ = _StepSelect.delete_Handle_StepSelect_FileModifier

    def Perform(self, *args):
        """
        Perform(Handle_StepSelect_FileModifier self, IFSelect_ContextWrite ctx, StepData_StepWriter writer)

        Perform the action specific to each class of File Modifier
        <ctx> is the ContextWrite, which brings : the model, the
        protocol, the file name, plus the object AppliedModifiers
        (not used here) and the CheckList
        Remark that the model has to be casted for specific access

        <writer> is the Writer and is specific to each norm, on which
        to act

        :type ctx: OCC.wrapper.IFSelect.IFSelect_ContextWrite
        :type writer: OCC.wrapper.StepData.StepData_StepWriter

        """
        return _StepSelect.Handle_StepSelect_FileModifier_Perform(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepSelect_FileModifier self) -> char const *

        :rtype: const char *

        """
        return _StepSelect.Handle_StepSelect_FileModifier_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepSelect.Handle_StepSelect_FileModifier_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepSelect.Handle_StepSelect_FileModifier_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def MayChangeGraph(self, *args):
        """
        MayChangeGraph(Handle_StepSelect_FileModifier self) -> Standard_Boolean

        Returns True if this modifier may change the graph of
        dependences (aknowledged at creation time)

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepSelect.Handle_StepSelect_FileModifier_MayChangeGraph(self, *args)


    def SetDispatch(self, *args):
        """
        SetDispatch(Handle_StepSelect_FileModifier self, Handle_IFSelect_Dispatch disp)

        Attaches to a Dispatch. If <disp> is Null, Resets it
        (to apply the Modifier on every Dispatch)

        :type disp: OCC.wrapper.IFSelect.Handle_IFSelect_Dispatch

        """
        return _StepSelect.Handle_StepSelect_FileModifier_SetDispatch(self, *args)


    def Dispatch(self, *args):
        """
        Dispatch(Handle_StepSelect_FileModifier self) -> Handle_IFSelect_Dispatch

        Returns the Dispatch to be matched, Null if not set

        :rtype: OCC.wrapper.IFSelect.Handle_IFSelect_Dispatch

        """
        return _StepSelect.Handle_StepSelect_FileModifier_Dispatch(self, *args)


    def Applies(self, *args):
        """
        Applies(Handle_StepSelect_FileModifier self, Handle_IFSelect_Dispatch disp) -> Standard_Boolean

        Returns True if a Model obtained from the Dispatch <disp>
        is to be treated (apart from the Selection criterium)
        If Dispatch(me) is Null, returns True. Else, checks <disp>

        :type disp: OCC.wrapper.IFSelect.Handle_IFSelect_Dispatch
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepSelect.Handle_StepSelect_FileModifier_Applies(self, *args)


    def SetSelection(self, *args):
        """
        SetSelection(Handle_StepSelect_FileModifier self, Handle_IFSelect_Selection sel)

        Sets a Selection : a Model is treated if it contains one or
        more Entities designated by the Selection

        :type sel: OCC.wrapper.IFSelect.Handle_IFSelect_Selection

        """
        return _StepSelect.Handle_StepSelect_FileModifier_SetSelection(self, *args)


    def ResetSelection(self, *args):
        """
        ResetSelection(Handle_StepSelect_FileModifier self)

        Resets the Selection : this criterium is not longer active


        """
        return _StepSelect.Handle_StepSelect_FileModifier_ResetSelection(self, *args)


    def HasSelection(self, *args):
        """
        HasSelection(Handle_StepSelect_FileModifier self) -> Standard_Boolean

        Returns True if a Selection is set as an additionnal criterium

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepSelect.Handle_StepSelect_FileModifier_HasSelection(self, *args)


    def Selection(self, *args):
        """
        Selection(Handle_StepSelect_FileModifier self) -> Handle_IFSelect_Selection

        Returns the Selection, or a Null Handle if not set

        :rtype: OCC.wrapper.IFSelect.Handle_IFSelect_Selection

        """
        return _StepSelect.Handle_StepSelect_FileModifier_Selection(self, *args)


    def Label(self, *args):
        """
        Label(Handle_StepSelect_FileModifier self) -> TCollection_AsciiString

        Returns a short text which defines the operation performed

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _StepSelect.Handle_StepSelect_FileModifier_Label(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepSelect_FileModifier self)

        Memory deallocator for transient classes


        """
        return _StepSelect.Handle_StepSelect_FileModifier_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepSelect_FileModifier self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepSelect_FileModifier self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepSelect.Handle_StepSelect_FileModifier_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepSelect_FileModifier self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepSelect_FileModifier self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepSelect.Handle_StepSelect_FileModifier_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepSelect_FileModifier self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepSelect.Handle_StepSelect_FileModifier_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepSelect_FileModifier self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepSelect.Handle_StepSelect_FileModifier_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepSelect_FileModifier self)

        Increments the reference counter of this object


        """
        return _StepSelect.Handle_StepSelect_FileModifier_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepSelect_FileModifier self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepSelect.Handle_StepSelect_FileModifier_DecrementRefCounter(self, *args)

Handle_StepSelect_FileModifier_swigregister = _StepSelect.Handle_StepSelect_FileModifier_swigregister
Handle_StepSelect_FileModifier_swigregister(Handle_StepSelect_FileModifier)

def Handle_StepSelect_FileModifier_DownCast(thing):
    return _StepSelect.Handle_StepSelect_FileModifier_DownCast(thing)
Handle_StepSelect_FileModifier_DownCast = _StepSelect.Handle_StepSelect_FileModifier_DownCast




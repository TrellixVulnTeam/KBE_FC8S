# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_LocOpe')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_LocOpe')
    _LocOpe = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_LocOpe', [dirname(__file__)])
        except ImportError:
            import _LocOpe
            return _LocOpe
        try:
            _mod = imp.load_module('_LocOpe', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _LocOpe = swig_import_helper()
    del swig_import_helper
else:
    import _LocOpe
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


class SwigPyIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _LocOpe.delete_SwigPyIterator

    def value(self):
        return _LocOpe.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _LocOpe.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _LocOpe.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _LocOpe.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _LocOpe.SwigPyIterator_equal(self, x)

    def copy(self):
        return _LocOpe.SwigPyIterator_copy(self)

    def next(self):
        return _LocOpe.SwigPyIterator_next(self)

    def __next__(self):
        return _LocOpe.SwigPyIterator___next__(self)

    def previous(self):
        return _LocOpe.SwigPyIterator_previous(self)

    def advance(self, n):
        return _LocOpe.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _LocOpe.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _LocOpe.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _LocOpe.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _LocOpe.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _LocOpe.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _LocOpe.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self
SwigPyIterator_swigregister = _LocOpe.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

class NCollection_CellFilter_InspectorXYZ(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _LocOpe.NCollection_CellFilter_InspectorXYZ_Dimension
    Coord = staticmethod(_LocOpe.NCollection_CellFilter_InspectorXYZ_Coord)

    def Shift(self, thePnt, theTol):
        return _LocOpe.NCollection_CellFilter_InspectorXYZ_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _LocOpe.new_NCollection_CellFilter_InspectorXYZ()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _LocOpe.delete_NCollection_CellFilter_InspectorXYZ
NCollection_CellFilter_InspectorXYZ_swigregister = _LocOpe.NCollection_CellFilter_InspectorXYZ_swigregister
NCollection_CellFilter_InspectorXYZ_swigregister(NCollection_CellFilter_InspectorXYZ)

def NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt):
    return _LocOpe.NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt)
NCollection_CellFilter_InspectorXYZ_Coord = _LocOpe.NCollection_CellFilter_InspectorXYZ_Coord

class NCollection_CellFilter_InspectorXY(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _LocOpe.NCollection_CellFilter_InspectorXY_Dimension
    Coord = staticmethod(_LocOpe.NCollection_CellFilter_InspectorXY_Coord)

    def Shift(self, thePnt, theTol):
        return _LocOpe.NCollection_CellFilter_InspectorXY_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _LocOpe.new_NCollection_CellFilter_InspectorXY()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _LocOpe.delete_NCollection_CellFilter_InspectorXY
NCollection_CellFilter_InspectorXY_swigregister = _LocOpe.NCollection_CellFilter_InspectorXY_swigregister
NCollection_CellFilter_InspectorXY_swigregister(NCollection_CellFilter_InspectorXY)

def NCollection_CellFilter_InspectorXY_Coord(i, thePnt):
    return _LocOpe.NCollection_CellFilter_InspectorXY_Coord(i, thePnt)
NCollection_CellFilter_InspectorXY_Coord = _LocOpe.NCollection_CellFilter_InspectorXY_Coord


def ptr_to_number(item):
    return _LocOpe.ptr_to_number(item)
ptr_to_number = _LocOpe.ptr_to_number

def HashCode(*args):
    return _LocOpe.HashCode(*args)
HashCode = _LocOpe.HashCode

def ptr_equal(a, b):
    return _LocOpe.ptr_equal(a, b)
ptr_equal = _LocOpe.ptr_equal
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import NCollection
else:
    import NCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Standard
else:
    import Standard
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import gp
else:
    import gp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColStd
else:
    import TColStd
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TCollection
else:
    import TCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColgp
else:
    import TColgp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopAbs
else:
    import TopAbs
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Geom
else:
    import Geom
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import GeomAbs
else:
    import GeomAbs
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColGeom
else:
    import TColGeom
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopoDS
else:
    import TopoDS
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Message
else:
    import Message
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopLoc
else:
    import TopLoc
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopTools
else:
    import TopTools
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Bnd
else:
    import Bnd
del _swig_python_version_info
LocOpe_FUSE = _LocOpe.LocOpe_FUSE
LocOpe_CUT = _LocOpe.LocOpe_CUT
LocOpe_INVALID = _LocOpe.LocOpe_INVALID
class LocOpe_GeneratedShape(Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_LocOpe_GeneratedShape
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_LocOpe_GeneratedShape(self) 
            return h


    def GeneratingEdges(self, *args):
        """
        :rtype: OCC.wrapper.TopTools.TopTools_ListOfShape

        """
        res = _LocOpe.LocOpe_GeneratedShape_GeneratingEdges(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Generated(self, *args):
        """
        Generated(LocOpe_GeneratedShape self, TopoDS_Vertex V) -> TopoDS_Edge
        Generated(LocOpe_GeneratedShape self, TopoDS_Edge E) -> TopoDS_Face

        Returns the face created by the edge <E>. If none,
        must return a null shape.

        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :rtype: OCC.wrapper.TopoDS.TopoDS_Face

        """
        return _LocOpe.LocOpe_GeneratedShape_Generated(self, *args)


    def OrientedFaces(self, *args):
        """
        Returns  the  list of correctly oriented generated
        faces.

        :rtype: OCC.wrapper.TopTools.TopTools_ListOfShape

        """
        res = _LocOpe.LocOpe_GeneratedShape_OrientedFaces(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _LocOpe.LocOpe_GeneratedShape_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _LocOpe.LocOpe_GeneratedShape_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _LocOpe.LocOpe_GeneratedShape_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _LocOpe.delete_LocOpe_GeneratedShape
LocOpe_GeneratedShape_swigregister = _LocOpe.LocOpe_GeneratedShape_swigregister
LocOpe_GeneratedShape_swigregister(LocOpe_GeneratedShape)

def LocOpe_GeneratedShape_get_type_name(*args):
    """
    LocOpe_GeneratedShape_get_type_name() -> char const *

    :rtype: const char *

    """
    return _LocOpe.LocOpe_GeneratedShape_get_type_name(*args)

def LocOpe_GeneratedShape_get_type_descriptor(*args):
    """
    LocOpe_GeneratedShape_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _LocOpe.LocOpe_GeneratedShape_get_type_descriptor(*args)

class LocOpe_WiresOnShape(Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_LocOpe_WiresOnShape
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_LocOpe_WiresOnShape(self) 
            return h


    def __init__(self, *args):
        """
        __init__(LocOpe_WiresOnShape self, TopoDS_Shape S) -> LocOpe_WiresOnShape

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        this = _LocOpe.new_LocOpe_WiresOnShape(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(LocOpe_WiresOnShape self, TopoDS_Shape S)

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _LocOpe.LocOpe_WiresOnShape_Init(self, *args)


    def Add(self, *args):
        """
        Add(LocOpe_WiresOnShape self, NCollection_Sequence_TopoDS_Shape theEdges) -> Standard_Boolean

        Add splitting edges or wires for whole initial shape
        withot additional specification edge->face, edge->edge
        This method puts edge on the corresponding faces from initial shape

        :type theEdges: OCC.wrapper.TopTools.TopTools_SequenceOfShape
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _LocOpe.LocOpe_WiresOnShape_Add(self, *args)


    def SetCheckInterior(self, *args):
        """
        SetCheckInterior(LocOpe_WiresOnShape self, Standard_Boolean const ToCheckInterior)

        Set the flag of check internal intersections
        default value is True (to check)

        :type ToCheckInterior: bool

        """
        return _LocOpe.LocOpe_WiresOnShape_SetCheckInterior(self, *args)


    def Bind(self, *args):
        """
        Bind(LocOpe_WiresOnShape self, TopoDS_Wire W, TopoDS_Face F)
        Bind(LocOpe_WiresOnShape self, TopoDS_Compound Comp, TopoDS_Face F)
        Bind(LocOpe_WiresOnShape self, TopoDS_Edge E, TopoDS_Face F)
        Bind(LocOpe_WiresOnShape self, TopoDS_Edge EfromW, TopoDS_Edge EonFace)

        :type EfromW: OCC.wrapper.TopoDS.TopoDS_Edge
        :type EonFace: OCC.wrapper.TopoDS.TopoDS_Edge

        """
        return _LocOpe.LocOpe_WiresOnShape_Bind(self, *args)


    def BindAll(self, *args):
        """BindAll(LocOpe_WiresOnShape self)"""
        return _LocOpe.LocOpe_WiresOnShape_BindAll(self, *args)


    def IsDone(self, *args):
        """
        IsDone(LocOpe_WiresOnShape self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _LocOpe.LocOpe_WiresOnShape_IsDone(self, *args)


    def InitEdgeIterator(self, *args):
        """InitEdgeIterator(LocOpe_WiresOnShape self)"""
        return _LocOpe.LocOpe_WiresOnShape_InitEdgeIterator(self, *args)


    def MoreEdge(self, *args):
        """
        MoreEdge(LocOpe_WiresOnShape self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _LocOpe.LocOpe_WiresOnShape_MoreEdge(self, *args)


    def Edge(self, *args):
        """
        Edge(LocOpe_WiresOnShape self) -> TopoDS_Edge

        :rtype: OCC.wrapper.TopoDS.TopoDS_Edge

        """
        return _LocOpe.LocOpe_WiresOnShape_Edge(self, *args)


    def OnFace(self, *args):
        """
        OnFace(LocOpe_WiresOnShape self) -> TopoDS_Face

        Returns the face of the shape on which the current
        edge is projected.

        :rtype: OCC.wrapper.TopoDS.TopoDS_Face

        """
        return _LocOpe.LocOpe_WiresOnShape_OnFace(self, *args)


    def NextEdge(self, *args):
        """NextEdge(LocOpe_WiresOnShape self)"""
        return _LocOpe.LocOpe_WiresOnShape_NextEdge(self, *args)


    def OnVertex(self, *args):
        """
        OnVertex(LocOpe_WiresOnShape self, TopoDS_Vertex Vwire, TopoDS_Vertex Vshape) -> Standard_Boolean

        :type Vwire: OCC.wrapper.TopoDS.TopoDS_Vertex
        :type Vshape: OCC.wrapper.TopoDS.TopoDS_Vertex
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _LocOpe.LocOpe_WiresOnShape_OnVertex(self, *args)


    def OnEdge(self, *args):
        """
        OnEdge(LocOpe_WiresOnShape self, TopoDS_Edge E) -> Standard_Boolean
        OnEdge(LocOpe_WiresOnShape self, TopoDS_Vertex V, TopoDS_Edge E) -> Standard_Boolean
        OnEdge(LocOpe_WiresOnShape self, TopoDS_Vertex V, TopoDS_Edge EdgeFrom, TopoDS_Edge E) -> Standard_Boolean

        If the vertex <V> lies on  an edge of the original
        shape,  returns     <Standard_True> and   sets the
        concerned edge in  <E>,  and the parameter on  the
        edge in <P>.
        Else returns <Standard_False>.

        :type V: OCC.wrapper.TopoDS.TopoDS_Vertex
        :type EdgeFrom: OCC.wrapper.TopoDS.TopoDS_Edge
        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :type P: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _LocOpe.LocOpe_WiresOnShape_OnEdge(self, *args)


    def IsFaceWithSection(self, *args):
        """
        IsFaceWithSection(LocOpe_WiresOnShape self, TopoDS_Shape aFace) -> Standard_Boolean

        tells is the face to be split by section or not

        :type aFace: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _LocOpe.LocOpe_WiresOnShape_IsFaceWithSection(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _LocOpe.LocOpe_WiresOnShape_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _LocOpe.LocOpe_WiresOnShape_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _LocOpe.LocOpe_WiresOnShape_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _LocOpe.delete_LocOpe_WiresOnShape
LocOpe_WiresOnShape_swigregister = _LocOpe.LocOpe_WiresOnShape_swigregister
LocOpe_WiresOnShape_swigregister(LocOpe_WiresOnShape)

def LocOpe_WiresOnShape_get_type_name(*args):
    """
    LocOpe_WiresOnShape_get_type_name() -> char const *

    :rtype: const char *

    """
    return _LocOpe.LocOpe_WiresOnShape_get_type_name(*args)

def LocOpe_WiresOnShape_get_type_descriptor(*args):
    """
    LocOpe_WiresOnShape_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _LocOpe.LocOpe_WiresOnShape_get_type_descriptor(*args)

class LocOpe_GluedShape(LocOpe_GeneratedShape):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_LocOpe_GluedShape
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_LocOpe_GluedShape(self) 
            return h


    def __init__(self, *args):
        """
        __init__(LocOpe_GluedShape self) -> LocOpe_GluedShape
        __init__(LocOpe_GluedShape self, TopoDS_Shape S) -> LocOpe_GluedShape

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        this = _LocOpe.new_LocOpe_GluedShape(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(LocOpe_GluedShape self, TopoDS_Shape S)

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _LocOpe.LocOpe_GluedShape_Init(self, *args)


    def GlueOnFace(self, *args):
        """
        GlueOnFace(LocOpe_GluedShape self, TopoDS_Face F)

        :type F: OCC.wrapper.TopoDS.TopoDS_Face

        """
        return _LocOpe.LocOpe_GluedShape_GlueOnFace(self, *args)


    def GeneratingEdges(self, *args):
        """
        :rtype: OCC.wrapper.TopTools.TopTools_ListOfShape

        """
        res = _LocOpe.LocOpe_GluedShape_GeneratingEdges(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Generated(self, *args):
        """
        Generated(LocOpe_GluedShape self, TopoDS_Vertex V) -> TopoDS_Edge
        Generated(LocOpe_GluedShape self, TopoDS_Edge E) -> TopoDS_Face

        Returns the face created by the edge <E>. If none,
        must return a null shape.

        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :rtype: OCC.wrapper.TopoDS.TopoDS_Face

        """
        return _LocOpe.LocOpe_GluedShape_Generated(self, *args)


    def OrientedFaces(self, *args):
        """
        Returns  the  list of correctly oriented generated
        faces.

        :rtype: OCC.wrapper.TopTools.TopTools_ListOfShape

        """
        res = _LocOpe.LocOpe_GluedShape_OrientedFaces(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _LocOpe.LocOpe_GluedShape_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _LocOpe.LocOpe_GluedShape_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _LocOpe.LocOpe_GluedShape_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _LocOpe.delete_LocOpe_GluedShape
LocOpe_GluedShape_swigregister = _LocOpe.LocOpe_GluedShape_swigregister
LocOpe_GluedShape_swigregister(LocOpe_GluedShape)

def LocOpe_GluedShape_get_type_name(*args):
    """
    LocOpe_GluedShape_get_type_name() -> char const *

    :rtype: const char *

    """
    return _LocOpe.LocOpe_GluedShape_get_type_name(*args)

def LocOpe_GluedShape_get_type_descriptor(*args):
    """
    LocOpe_GluedShape_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _LocOpe.LocOpe_GluedShape_get_type_descriptor(*args)

class LocOpe_Revol(object):
    """
    Defines a prism (using Prism from BRepSweep)
    with modifications provided for the Prism feature.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(LocOpe_Revol self) -> LocOpe_Revol

        Defines a prism (using Prism from BRepSweep)
        with modifications provided for the Prism feature.
        """
        this = _LocOpe.new_LocOpe_Revol(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Perform(self, *args):
        """
        Perform(LocOpe_Revol self, TopoDS_Shape Base, gp_Ax1 Axis, Standard_Real const Angle, Standard_Real const angledec)
        Perform(LocOpe_Revol self, TopoDS_Shape Base, gp_Ax1 Axis, Standard_Real const Angle)

        :type Base: OCC.wrapper.TopoDS.TopoDS_Shape
        :type Axis: OCC.wrapper.gp.gp_Ax1
        :type Angle: float

        """
        return _LocOpe.LocOpe_Revol_Perform(self, *args)


    def FirstShape(self, *args):
        """
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _LocOpe.LocOpe_Revol_FirstShape(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def LastShape(self, *args):
        """
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _LocOpe.LocOpe_Revol_LastShape(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Shape(self, *args):
        """
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _LocOpe.LocOpe_Revol_Shape(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Shapes(self, *args):
        """
        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.TopTools.TopTools_ListOfShape

        """
        res = _LocOpe.LocOpe_Revol_Shapes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Curves(self, *args):
        """
        Curves(LocOpe_Revol self, NCollection_Sequence_Handle_Geom_Curve SCurves)

        :type SCurves: OCC.wrapper.TColGeom.TColGeom_SequenceOfCurve

        """
        return _LocOpe.LocOpe_Revol_Curves(self, *args)


    def BarycCurve(self, *args):
        """
        BarycCurve(LocOpe_Revol self) -> Handle_Geom_Curve

        :rtype: OCC.wrapper.Geom.Handle_Geom_Curve

        """
        return _LocOpe.LocOpe_Revol_BarycCurve(self, *args)

    __swig_destroy__ = _LocOpe.delete_LocOpe_Revol
LocOpe_Revol_swigregister = _LocOpe.LocOpe_Revol_swigregister
LocOpe_Revol_swigregister(LocOpe_Revol)

class LocOpe_RevolutionForm(object):
    """
    Defines a revolution form (using Revol from BRepSweep)
    with modifications provided for the RevolutionForm feature.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(LocOpe_RevolutionForm self) -> LocOpe_RevolutionForm

        Defines a revolution form (using Revol from BRepSweep)
        with modifications provided for the RevolutionForm feature.
        """
        this = _LocOpe.new_LocOpe_RevolutionForm(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Perform(self, *args):
        """
        Perform(LocOpe_RevolutionForm self, TopoDS_Shape Base, gp_Ax1 Axe, Standard_Real const Angle)

        :type Base: OCC.wrapper.TopoDS.TopoDS_Shape
        :type Axe: OCC.wrapper.gp.gp_Ax1
        :type Angle: float

        """
        return _LocOpe.LocOpe_RevolutionForm_Perform(self, *args)


    def FirstShape(self, *args):
        """
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _LocOpe.LocOpe_RevolutionForm_FirstShape(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def LastShape(self, *args):
        """
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _LocOpe.LocOpe_RevolutionForm_LastShape(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Shape(self, *args):
        """
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _LocOpe.LocOpe_RevolutionForm_Shape(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Shapes(self, *args):
        """
        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.TopTools.TopTools_ListOfShape

        """
        res = _LocOpe.LocOpe_RevolutionForm_Shapes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _LocOpe.delete_LocOpe_RevolutionForm
LocOpe_RevolutionForm_swigregister = _LocOpe.LocOpe_RevolutionForm_swigregister
LocOpe_RevolutionForm_swigregister(LocOpe_RevolutionForm)

class LocOpe_PntFace(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(LocOpe_PntFace self) -> LocOpe_PntFace
        __init__(LocOpe_PntFace self, gp_Pnt P, TopoDS_Face F, TopAbs_Orientation const Or, Standard_Real const Param, Standard_Real const UPar, Standard_Real const VPar) -> LocOpe_PntFace

        :type P: OCC.wrapper.gp.gp_Pnt
        :type F: OCC.wrapper.TopoDS.TopoDS_Face
        :type Or: OCC.wrapper.TopAbs.TopAbs_Orientation
        :type Param: float
        :type UPar: float
        :type VPar: float

        """
        this = _LocOpe.new_LocOpe_PntFace(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Pnt(self, *args):
        """
        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        res = _LocOpe.LocOpe_PntFace_Pnt(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Face(self, *args):
        """
        :rtype: OCC.wrapper.TopoDS.TopoDS_Face

        """
        res = _LocOpe.LocOpe_PntFace_Face(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Orientation(self, *args):
        """
        Orientation(LocOpe_PntFace self) -> TopAbs_Orientation

        :rtype: OCC.wrapper.TopAbs.TopAbs_Orientation

        """
        return _LocOpe.LocOpe_PntFace_Orientation(self, *args)


    def ChangeOrientation(self, *args):
        """
        ChangeOrientation(LocOpe_PntFace self) -> TopAbs_Orientation &

        :rtype: OCC.wrapper.TopAbs.TopAbs_Orientation

        """
        return _LocOpe.LocOpe_PntFace_ChangeOrientation(self, *args)


    def Parameter(self, *args):
        """
        Parameter(LocOpe_PntFace self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _LocOpe.LocOpe_PntFace_Parameter(self, *args)


    def UParameter(self, *args):
        """
        UParameter(LocOpe_PntFace self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _LocOpe.LocOpe_PntFace_UParameter(self, *args)


    def VParameter(self, *args):
        """
        VParameter(LocOpe_PntFace self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _LocOpe.LocOpe_PntFace_VParameter(self, *args)

    __swig_destroy__ = _LocOpe.delete_LocOpe_PntFace
LocOpe_PntFace_swigregister = _LocOpe.LocOpe_PntFace_swigregister
LocOpe_PntFace_swigregister(LocOpe_PntFace)

class LocOpe_DPrism(object):
    """
    Defines a  pipe  (near from   Pipe from BRepFill),
    with modifications provided for the Pipe feature.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(LocOpe_DPrism self, TopoDS_Face Spine, Standard_Real const Height1, Standard_Real const Height2, Standard_Real const Angle) -> LocOpe_DPrism
        __init__(LocOpe_DPrism self, TopoDS_Face Spine, Standard_Real const Height, Standard_Real const Angle) -> LocOpe_DPrism

        :type Spine: OCC.wrapper.TopoDS.TopoDS_Face
        :type Height: float
        :type Angle: float

        """
        this = _LocOpe.new_LocOpe_DPrism(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def IsDone(self, *args):
        """
        IsDone(LocOpe_DPrism self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _LocOpe.LocOpe_DPrism_IsDone(self, *args)


    def Spine(self, *args):
        """
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _LocOpe.LocOpe_DPrism_Spine(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Profile(self, *args):
        """
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _LocOpe.LocOpe_DPrism_Profile(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def FirstShape(self, *args):
        """
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _LocOpe.LocOpe_DPrism_FirstShape(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def LastShape(self, *args):
        """
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _LocOpe.LocOpe_DPrism_LastShape(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Shape(self, *args):
        """
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _LocOpe.LocOpe_DPrism_Shape(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Shapes(self, *args):
        """
        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.TopTools.TopTools_ListOfShape

        """
        res = _LocOpe.LocOpe_DPrism_Shapes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Curves(self, *args):
        """
        Curves(LocOpe_DPrism self, NCollection_Sequence_Handle_Geom_Curve SCurves)

        :type SCurves: OCC.wrapper.TColGeom.TColGeom_SequenceOfCurve

        """
        return _LocOpe.LocOpe_DPrism_Curves(self, *args)


    def BarycCurve(self, *args):
        """
        BarycCurve(LocOpe_DPrism self) -> Handle_Geom_Curve

        :rtype: OCC.wrapper.Geom.Handle_Geom_Curve

        """
        return _LocOpe.LocOpe_DPrism_BarycCurve(self, *args)

    __swig_destroy__ = _LocOpe.delete_LocOpe_DPrism
LocOpe_DPrism_swigregister = _LocOpe.LocOpe_DPrism_swigregister
LocOpe_DPrism_swigregister(LocOpe_DPrism)

class NCollection_Sequence_gp_Circ(NCollection.NCollection_BaseSequence):
    """
    Purpose:     Definition of a sequence of elements indexed by
    an Integer in range of 1..n
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Sequence_gp_Circ self) -> NCollection_Sequence< gp_Circ >::iterator

        Returns an iterator pointing to the first element in the sequence.

        :rtype: iterator

        """
        return _LocOpe.NCollection_Sequence_gp_Circ_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Sequence_gp_Circ self) -> NCollection_Sequence< gp_Circ >::iterator

        Returns an iterator referring to the past-the-end element in the sequence.

        :rtype: iterator

        """
        return _LocOpe.NCollection_Sequence_gp_Circ_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Sequence_gp_Circ self) -> NCollection_Sequence< gp_Circ >::const_iterator

        Returns a const iterator pointing to the first element in the sequence.

        :rtype: const_iterator

        """
        return _LocOpe.NCollection_Sequence_gp_Circ_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Sequence_gp_Circ self) -> NCollection_Sequence< gp_Circ >::const_iterator

        Returns a const iterator referring to the past-the-end element in the sequence.

        :rtype: const_iterator

        """
        return _LocOpe.NCollection_Sequence_gp_Circ_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     Definition of a sequence of elements indexed by
        an Integer in range of 1..n
        """
        this = _LocOpe.new_NCollection_Sequence_gp_Circ(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Size(self, *args):
        """
        Size(NCollection_Sequence_gp_Circ self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _LocOpe.NCollection_Sequence_gp_Circ_Size(self, *args)


    def Length(self, *args):
        """
        Length(NCollection_Sequence_gp_Circ self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _LocOpe.NCollection_Sequence_gp_Circ_Length(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Sequence_gp_Circ self) -> Standard_Integer

        Method for consistency with other collections.
        @return Lower bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _LocOpe.NCollection_Sequence_gp_Circ_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Sequence_gp_Circ self) -> Standard_Integer

        Method for consistency with other collections.
        @return Upper bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _LocOpe.NCollection_Sequence_gp_Circ_Upper(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Sequence_gp_Circ self) -> Standard_Boolean

        Empty query

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _LocOpe.NCollection_Sequence_gp_Circ_IsEmpty(self, *args)


    def Reverse(self, *args):
        """
        Reverse(NCollection_Sequence_gp_Circ self)

        Reverse sequence


        """
        return _LocOpe.NCollection_Sequence_gp_Circ_Reverse(self, *args)


    def Exchange(self, *args):
        """
        Exchange(NCollection_Sequence_gp_Circ self, Standard_Integer const I, Standard_Integer const J)

        Exchange two members

        :type I: int
        :type J: int

        """
        return _LocOpe.NCollection_Sequence_gp_Circ_Exchange(self, *args)


    def delNode(*args):
        """
        delNode(NCollection_SeqNode theNode, Handle_NCollection_BaseAllocator theAl)

        Static deleter to be passed to BaseSequence

        :type theNode: OCC.wrapper.NCollection.NCollection_SeqNode
        :type theAl: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _LocOpe.NCollection_Sequence_gp_Circ_delNode(*args)

    delNode = staticmethod(delNode)

    def Clear(self, *args):
        """
        Clear(NCollection_Sequence_gp_Circ self, Handle_NCollection_BaseAllocator theAllocator=0)

        Clear the items out, take a new allocator if non null

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _LocOpe.NCollection_Sequence_gp_Circ_Clear(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Sequence_gp_Circ self, NCollection_Sequence_gp_Circ theOther) -> NCollection_Sequence_gp_Circ

        Replace this sequence by the items of theOther.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_Sequence
        :rtype: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _LocOpe.NCollection_Sequence_gp_Circ_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Sequence_gp_Circ self, NCollection_Sequence_gp_Circ theOther) -> NCollection_Sequence_gp_Circ

        Replacement operator

        :type theOther: OCC.wrapper.NCollection.NCollection_Sequence
        :rtype: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _LocOpe.NCollection_Sequence_gp_Circ_assign(self, *args)


    def Remove(self, *args):
        """
        Remove(NCollection_Sequence_gp_Circ self, NCollection_Sequence< gp_Circ >::Iterator & thePosition)
        Remove(NCollection_Sequence_gp_Circ self, Standard_Integer const theIndex)
        Remove(NCollection_Sequence_gp_Circ self, Standard_Integer const theFromIndex, Standard_Integer const theToIndex)

        Remove range of items

        :type theFromIndex: int
        :type theToIndex: int

        """
        return _LocOpe.NCollection_Sequence_gp_Circ_Remove(self, *args)


    def Append(self, *args):
        """
        Append(NCollection_Sequence_gp_Circ self, gp_Circ theItem)
        Append(NCollection_Sequence_gp_Circ self, NCollection_Sequence_gp_Circ theSeq)

        Append another sequence (making it empty)

        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _LocOpe.NCollection_Sequence_gp_Circ_Append(self, *args)


    def Prepend(self, *args):
        """
        Prepend(NCollection_Sequence_gp_Circ self, gp_Circ theItem)
        Prepend(NCollection_Sequence_gp_Circ self, NCollection_Sequence_gp_Circ theSeq)

        Prepend another sequence (making it empty)

        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _LocOpe.NCollection_Sequence_gp_Circ_Prepend(self, *args)


    def InsertBefore(self, *args):
        """
        InsertBefore(NCollection_Sequence_gp_Circ self, Standard_Integer const theIndex, gp_Circ theItem)
        InsertBefore(NCollection_Sequence_gp_Circ self, Standard_Integer const theIndex, NCollection_Sequence_gp_Circ theSeq)

        InsertBefore theIndex another sequence

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _LocOpe.NCollection_Sequence_gp_Circ_InsertBefore(self, *args)


    def InsertAfter(self, *args):
        """
        InsertAfter(NCollection_Sequence_gp_Circ self, NCollection_Sequence< gp_Circ >::Iterator & thePosition, gp_Circ theItem)
        InsertAfter(NCollection_Sequence_gp_Circ self, Standard_Integer const theIndex, NCollection_Sequence_gp_Circ theSeq)
        InsertAfter(NCollection_Sequence_gp_Circ self, Standard_Integer const theIndex, gp_Circ theItem)

        InsertAfter theIndex another sequence

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _LocOpe.NCollection_Sequence_gp_Circ_InsertAfter(self, *args)


    def Split(self, *args):
        """
        Split(NCollection_Sequence_gp_Circ self, Standard_Integer const theIndex, NCollection_Sequence_gp_Circ theSeq)

        Split in two sequences

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _LocOpe.NCollection_Sequence_gp_Circ_Split(self, *args)


    def First(self, *args):
        """
        First item access

        :rtype: const TheItemType &

        """
        res = _LocOpe.NCollection_Sequence_gp_Circ_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Sequence_gp_Circ self) -> gp_Circ

        First item access

        :rtype: TheItemType &

        """
        return _LocOpe.NCollection_Sequence_gp_Circ_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        Last item access

        :rtype: const TheItemType &

        """
        res = _LocOpe.NCollection_Sequence_gp_Circ_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Sequence_gp_Circ self) -> gp_Circ

        Last item access

        :rtype: TheItemType &

        """
        return _LocOpe.NCollection_Sequence_gp_Circ_ChangeLast(self, *args)


    def Value(self, *args):
        """
        Constant item access by theIndex

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _LocOpe.NCollection_Sequence_gp_Circ_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Sequence_gp_Circ self, Standard_Integer const theIndex) -> gp_Circ

        Variable item access by theIndex

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _LocOpe.NCollection_Sequence_gp_Circ_ChangeValue(self, *args)


    def __call__(self, *args):
        """
        Constant operator()

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _LocOpe.NCollection_Sequence_gp_Circ___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetValue(self, *args):
        """
        SetValue(NCollection_Sequence_gp_Circ self, Standard_Integer const theIndex, gp_Circ theItem)

        Set item value by theIndex

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _LocOpe.NCollection_Sequence_gp_Circ_SetValue(self, *args)


    def __iter__(self):
        return _LocOpe.NCollection_Sequence_gp_Circ___iter__(self)
    __swig_destroy__ = _LocOpe.delete_NCollection_Sequence_gp_Circ
NCollection_Sequence_gp_Circ_swigregister = _LocOpe.NCollection_Sequence_gp_Circ_swigregister
NCollection_Sequence_gp_Circ_swigregister(NCollection_Sequence_gp_Circ)

def NCollection_Sequence_gp_Circ_delNode(*args):
    """
    NCollection_Sequence_gp_Circ_delNode(NCollection_SeqNode theNode, Handle_NCollection_BaseAllocator theAl)

    Static deleter to be passed to BaseSequence

    :type theNode: OCC.wrapper.NCollection.NCollection_SeqNode
    :type theAl: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

    """
    return _LocOpe.NCollection_Sequence_gp_Circ_delNode(*args)

class NCollection_Sequence_gp_Circ_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _LocOpe.new_NCollection_Sequence_gp_Circ_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _LocOpe.delete_NCollection_Sequence_gp_Circ_IteratorHelper

    def __next__(self):
        return _LocOpe.NCollection_Sequence_gp_Circ_IteratorHelper___next__(self)
NCollection_Sequence_gp_Circ_IteratorHelper_swigregister = _LocOpe.NCollection_Sequence_gp_Circ_IteratorHelper_swigregister
NCollection_Sequence_gp_Circ_IteratorHelper_swigregister(NCollection_Sequence_gp_Circ_IteratorHelper)


try:
	LocOpe_SequenceOfCirc = NCollection_Sequence_gp_Circ
except NameError:
	pass # does not exist, probably ignored

class Handle_LocOpe_WiresOnShape(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_LocOpe_WiresOnShape self)

        Nullify the handle


        """
        return _LocOpe.Handle_LocOpe_WiresOnShape_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_LocOpe_WiresOnShape self) -> bool

        Check for being null

        :rtype: bool

        """
        return _LocOpe.Handle_LocOpe_WiresOnShape_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_LocOpe_WiresOnShape self, LocOpe_WiresOnShape thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _LocOpe.Handle_LocOpe_WiresOnShape_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_LocOpe_WiresOnShape self, Handle_LocOpe_WiresOnShape theHandle) -> Handle_LocOpe_WiresOnShape
        assign(Handle_LocOpe_WiresOnShape self, LocOpe_WiresOnShape thePtr) -> Handle_LocOpe_WiresOnShape
        assign(Handle_LocOpe_WiresOnShape self, Handle_LocOpe_WiresOnShape theHandle) -> Handle_LocOpe_WiresOnShape

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _LocOpe.Handle_LocOpe_WiresOnShape_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_LocOpe_WiresOnShape self) -> LocOpe_WiresOnShape

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _LocOpe.Handle_LocOpe_WiresOnShape_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_LocOpe_WiresOnShape self) -> LocOpe_WiresOnShape

        Member access operator (note non-const)

        :rtype: T *

        """
        return _LocOpe.Handle_LocOpe_WiresOnShape___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_LocOpe_WiresOnShape self) -> LocOpe_WiresOnShape

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _LocOpe.Handle_LocOpe_WiresOnShape___ref__(self, *args)


    def __hash__(self):
        return _LocOpe.Handle_LocOpe_WiresOnShape___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _LocOpe.Handle_LocOpe_WiresOnShape___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _LocOpe.new_Handle_LocOpe_WiresOnShape(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_LocOpe.Handle_LocOpe_WiresOnShape_DownCast)
    __swig_destroy__ = _LocOpe.delete_Handle_LocOpe_WiresOnShape

    def Init(self, *args):
        """
        Init(Handle_LocOpe_WiresOnShape self, TopoDS_Shape S)

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _LocOpe.Handle_LocOpe_WiresOnShape_Init(self, *args)


    def Add(self, *args):
        """
        Add(Handle_LocOpe_WiresOnShape self, NCollection_Sequence_TopoDS_Shape theEdges) -> Standard_Boolean

        Add splitting edges or wires for whole initial shape
        withot additional specification edge->face, edge->edge
        This method puts edge on the corresponding faces from initial shape

        :type theEdges: OCC.wrapper.TopTools.TopTools_SequenceOfShape
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _LocOpe.Handle_LocOpe_WiresOnShape_Add(self, *args)


    def SetCheckInterior(self, *args):
        """
        SetCheckInterior(Handle_LocOpe_WiresOnShape self, Standard_Boolean const ToCheckInterior)

        Set the flag of check internal intersections
        default value is True (to check)

        :type ToCheckInterior: bool

        """
        return _LocOpe.Handle_LocOpe_WiresOnShape_SetCheckInterior(self, *args)


    def Bind(self, *args):
        """
        Bind(Handle_LocOpe_WiresOnShape self, TopoDS_Wire W, TopoDS_Face F)
        Bind(Handle_LocOpe_WiresOnShape self, TopoDS_Compound Comp, TopoDS_Face F)
        Bind(Handle_LocOpe_WiresOnShape self, TopoDS_Edge E, TopoDS_Face F)
        Bind(Handle_LocOpe_WiresOnShape self, TopoDS_Edge EfromW, TopoDS_Edge EonFace)

        :type EfromW: OCC.wrapper.TopoDS.TopoDS_Edge
        :type EonFace: OCC.wrapper.TopoDS.TopoDS_Edge

        """
        return _LocOpe.Handle_LocOpe_WiresOnShape_Bind(self, *args)


    def BindAll(self, *args):
        """BindAll(Handle_LocOpe_WiresOnShape self)"""
        return _LocOpe.Handle_LocOpe_WiresOnShape_BindAll(self, *args)


    def IsDone(self, *args):
        """
        IsDone(Handle_LocOpe_WiresOnShape self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _LocOpe.Handle_LocOpe_WiresOnShape_IsDone(self, *args)


    def InitEdgeIterator(self, *args):
        """InitEdgeIterator(Handle_LocOpe_WiresOnShape self)"""
        return _LocOpe.Handle_LocOpe_WiresOnShape_InitEdgeIterator(self, *args)


    def MoreEdge(self, *args):
        """
        MoreEdge(Handle_LocOpe_WiresOnShape self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _LocOpe.Handle_LocOpe_WiresOnShape_MoreEdge(self, *args)


    def Edge(self, *args):
        """
        Edge(Handle_LocOpe_WiresOnShape self) -> TopoDS_Edge

        :rtype: OCC.wrapper.TopoDS.TopoDS_Edge

        """
        return _LocOpe.Handle_LocOpe_WiresOnShape_Edge(self, *args)


    def OnFace(self, *args):
        """
        OnFace(Handle_LocOpe_WiresOnShape self) -> TopoDS_Face

        Returns the face of the shape on which the current
        edge is projected.

        :rtype: OCC.wrapper.TopoDS.TopoDS_Face

        """
        return _LocOpe.Handle_LocOpe_WiresOnShape_OnFace(self, *args)


    def OnEdge(self, *args):
        """
        OnEdge(Handle_LocOpe_WiresOnShape self, TopoDS_Edge E) -> Standard_Boolean
        OnEdge(Handle_LocOpe_WiresOnShape self, TopoDS_Vertex V, TopoDS_Edge E) -> Standard_Boolean
        OnEdge(Handle_LocOpe_WiresOnShape self, TopoDS_Vertex V, TopoDS_Edge EdgeFrom, TopoDS_Edge E) -> Standard_Boolean

        If the vertex <V> lies on  an edge of the original
        shape,  returns     <Standard_True> and   sets the
        concerned edge in  <E>,  and the parameter on  the
        edge in <P>.
        Else returns <Standard_False>.

        :type V: OCC.wrapper.TopoDS.TopoDS_Vertex
        :type EdgeFrom: OCC.wrapper.TopoDS.TopoDS_Edge
        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :type P: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _LocOpe.Handle_LocOpe_WiresOnShape_OnEdge(self, *args)


    def NextEdge(self, *args):
        """NextEdge(Handle_LocOpe_WiresOnShape self)"""
        return _LocOpe.Handle_LocOpe_WiresOnShape_NextEdge(self, *args)


    def OnVertex(self, *args):
        """
        OnVertex(Handle_LocOpe_WiresOnShape self, TopoDS_Vertex Vwire, TopoDS_Vertex Vshape) -> Standard_Boolean

        :type Vwire: OCC.wrapper.TopoDS.TopoDS_Vertex
        :type Vshape: OCC.wrapper.TopoDS.TopoDS_Vertex
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _LocOpe.Handle_LocOpe_WiresOnShape_OnVertex(self, *args)


    def IsFaceWithSection(self, *args):
        """
        IsFaceWithSection(Handle_LocOpe_WiresOnShape self, TopoDS_Shape aFace) -> Standard_Boolean

        tells is the face to be split by section or not

        :type aFace: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _LocOpe.Handle_LocOpe_WiresOnShape_IsFaceWithSection(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_LocOpe_WiresOnShape self) -> char const *

        :rtype: const char *

        """
        return _LocOpe.Handle_LocOpe_WiresOnShape_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _LocOpe.Handle_LocOpe_WiresOnShape_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _LocOpe.Handle_LocOpe_WiresOnShape_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_LocOpe_WiresOnShape self)

        Memory deallocator for transient classes


        """
        return _LocOpe.Handle_LocOpe_WiresOnShape_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_LocOpe_WiresOnShape self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_LocOpe_WiresOnShape self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _LocOpe.Handle_LocOpe_WiresOnShape_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_LocOpe_WiresOnShape self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_LocOpe_WiresOnShape self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _LocOpe.Handle_LocOpe_WiresOnShape_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_LocOpe_WiresOnShape self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _LocOpe.Handle_LocOpe_WiresOnShape_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_LocOpe_WiresOnShape self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _LocOpe.Handle_LocOpe_WiresOnShape_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_LocOpe_WiresOnShape self)

        Increments the reference counter of this object


        """
        return _LocOpe.Handle_LocOpe_WiresOnShape_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_LocOpe_WiresOnShape self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _LocOpe.Handle_LocOpe_WiresOnShape_DecrementRefCounter(self, *args)

Handle_LocOpe_WiresOnShape_swigregister = _LocOpe.Handle_LocOpe_WiresOnShape_swigregister
Handle_LocOpe_WiresOnShape_swigregister(Handle_LocOpe_WiresOnShape)

def Handle_LocOpe_WiresOnShape_DownCast(thing):
    return _LocOpe.Handle_LocOpe_WiresOnShape_DownCast(thing)
Handle_LocOpe_WiresOnShape_DownCast = _LocOpe.Handle_LocOpe_WiresOnShape_DownCast

class LocOpe_LinearForm(object):
    """
    Defines a linear form (using Prism from BRepSweep)
    with modifications provided for the LinearForm feature.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(LocOpe_LinearForm self) -> LocOpe_LinearForm
        __init__(LocOpe_LinearForm self, TopoDS_Shape Base, gp_Vec V, gp_Pnt Pnt1, gp_Pnt Pnt2) -> LocOpe_LinearForm
        __init__(LocOpe_LinearForm self, TopoDS_Shape Base, gp_Vec V, gp_Vec Vectra, gp_Pnt Pnt1, gp_Pnt Pnt2) -> LocOpe_LinearForm

        :type Base: OCC.wrapper.TopoDS.TopoDS_Shape
        :type V: OCC.wrapper.gp.gp_Vec
        :type Vectra: OCC.wrapper.gp.gp_Vec
        :type Pnt1: OCC.wrapper.gp.gp_Pnt
        :type Pnt2: OCC.wrapper.gp.gp_Pnt

        """
        this = _LocOpe.new_LocOpe_LinearForm(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Perform(self, *args):
        """
        Perform(LocOpe_LinearForm self, TopoDS_Shape Base, gp_Vec V, gp_Pnt Pnt1, gp_Pnt Pnt2)
        Perform(LocOpe_LinearForm self, TopoDS_Shape Base, gp_Vec V, gp_Vec Vectra, gp_Pnt Pnt1, gp_Pnt Pnt2)

        :type Base: OCC.wrapper.TopoDS.TopoDS_Shape
        :type V: OCC.wrapper.gp.gp_Vec
        :type Vectra: OCC.wrapper.gp.gp_Vec
        :type Pnt1: OCC.wrapper.gp.gp_Pnt
        :type Pnt2: OCC.wrapper.gp.gp_Pnt

        """
        return _LocOpe.LocOpe_LinearForm_Perform(self, *args)


    def FirstShape(self, *args):
        """
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _LocOpe.LocOpe_LinearForm_FirstShape(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def LastShape(self, *args):
        """
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _LocOpe.LocOpe_LinearForm_LastShape(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Shape(self, *args):
        """
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _LocOpe.LocOpe_LinearForm_Shape(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Shapes(self, *args):
        """
        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.TopTools.TopTools_ListOfShape

        """
        res = _LocOpe.LocOpe_LinearForm_Shapes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _LocOpe.delete_LocOpe_LinearForm
LocOpe_LinearForm_swigregister = _LocOpe.LocOpe_LinearForm_swigregister
LocOpe_LinearForm_swigregister(LocOpe_LinearForm)

class LocOpe_FindEdgesInFace(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(LocOpe_FindEdgesInFace self) -> LocOpe_FindEdgesInFace
        __init__(LocOpe_FindEdgesInFace self, TopoDS_Shape S, TopoDS_Face F) -> LocOpe_FindEdgesInFace

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :type F: OCC.wrapper.TopoDS.TopoDS_Face

        """
        this = _LocOpe.new_LocOpe_FindEdgesInFace(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Set(self, *args):
        """
        Set(LocOpe_FindEdgesInFace self, TopoDS_Shape S, TopoDS_Face F)

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :type F: OCC.wrapper.TopoDS.TopoDS_Face

        """
        return _LocOpe.LocOpe_FindEdgesInFace_Set(self, *args)


    def Init(self, *args):
        """Init(LocOpe_FindEdgesInFace self)"""
        return _LocOpe.LocOpe_FindEdgesInFace_Init(self, *args)


    def More(self, *args):
        """
        More(LocOpe_FindEdgesInFace self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _LocOpe.LocOpe_FindEdgesInFace_More(self, *args)


    def Edge(self, *args):
        """
        :rtype: OCC.wrapper.TopoDS.TopoDS_Edge

        """
        res = _LocOpe.LocOpe_FindEdgesInFace_Edge(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Next(self, *args):
        """Next(LocOpe_FindEdgesInFace self)"""
        return _LocOpe.LocOpe_FindEdgesInFace_Next(self, *args)

    __swig_destroy__ = _LocOpe.delete_LocOpe_FindEdgesInFace
LocOpe_FindEdgesInFace_swigregister = _LocOpe.LocOpe_FindEdgesInFace_swigregister
LocOpe_FindEdgesInFace_swigregister(LocOpe_FindEdgesInFace)

class Handle_LocOpe_GluedShape(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_LocOpe_GluedShape self)

        Nullify the handle


        """
        return _LocOpe.Handle_LocOpe_GluedShape_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_LocOpe_GluedShape self) -> bool

        Check for being null

        :rtype: bool

        """
        return _LocOpe.Handle_LocOpe_GluedShape_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_LocOpe_GluedShape self, LocOpe_GluedShape thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _LocOpe.Handle_LocOpe_GluedShape_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_LocOpe_GluedShape self, Handle_LocOpe_GluedShape theHandle) -> Handle_LocOpe_GluedShape
        assign(Handle_LocOpe_GluedShape self, LocOpe_GluedShape thePtr) -> Handle_LocOpe_GluedShape
        assign(Handle_LocOpe_GluedShape self, Handle_LocOpe_GluedShape theHandle) -> Handle_LocOpe_GluedShape

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _LocOpe.Handle_LocOpe_GluedShape_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_LocOpe_GluedShape self) -> LocOpe_GluedShape

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _LocOpe.Handle_LocOpe_GluedShape_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_LocOpe_GluedShape self) -> LocOpe_GluedShape

        Member access operator (note non-const)

        :rtype: T *

        """
        return _LocOpe.Handle_LocOpe_GluedShape___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_LocOpe_GluedShape self) -> LocOpe_GluedShape

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _LocOpe.Handle_LocOpe_GluedShape___ref__(self, *args)


    def __hash__(self):
        return _LocOpe.Handle_LocOpe_GluedShape___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _LocOpe.Handle_LocOpe_GluedShape___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _LocOpe.new_Handle_LocOpe_GluedShape(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_LocOpe.Handle_LocOpe_GluedShape_DownCast)
    __swig_destroy__ = _LocOpe.delete_Handle_LocOpe_GluedShape

    def Init(self, *args):
        """
        Init(Handle_LocOpe_GluedShape self, TopoDS_Shape S)

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _LocOpe.Handle_LocOpe_GluedShape_Init(self, *args)


    def GlueOnFace(self, *args):
        """
        GlueOnFace(Handle_LocOpe_GluedShape self, TopoDS_Face F)

        :type F: OCC.wrapper.TopoDS.TopoDS_Face

        """
        return _LocOpe.Handle_LocOpe_GluedShape_GlueOnFace(self, *args)


    def GeneratingEdges(self, *args):
        """
        :rtype: OCC.wrapper.TopTools.TopTools_ListOfShape

        """
        res = _LocOpe.Handle_LocOpe_GluedShape_GeneratingEdges(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Generated(self, *args):
        """
        Generated(Handle_LocOpe_GluedShape self, TopoDS_Vertex V) -> TopoDS_Edge
        Generated(Handle_LocOpe_GluedShape self, TopoDS_Edge E) -> TopoDS_Face

        Returns the face created by the edge <E>. If none,
        must return a null shape.

        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :rtype: OCC.wrapper.TopoDS.TopoDS_Face

        """
        return _LocOpe.Handle_LocOpe_GluedShape_Generated(self, *args)


    def OrientedFaces(self, *args):
        """
        Returns  the  list of correctly oriented generated
        faces.

        :rtype: OCC.wrapper.TopTools.TopTools_ListOfShape

        """
        res = _LocOpe.Handle_LocOpe_GluedShape_OrientedFaces(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def get_type_name(self, *args):
        """
        get_type_name(Handle_LocOpe_GluedShape self) -> char const *

        :rtype: const char *

        """
        return _LocOpe.Handle_LocOpe_GluedShape_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _LocOpe.Handle_LocOpe_GluedShape_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _LocOpe.Handle_LocOpe_GluedShape_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_LocOpe_GluedShape self)

        Memory deallocator for transient classes


        """
        return _LocOpe.Handle_LocOpe_GluedShape_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_LocOpe_GluedShape self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_LocOpe_GluedShape self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _LocOpe.Handle_LocOpe_GluedShape_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_LocOpe_GluedShape self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_LocOpe_GluedShape self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _LocOpe.Handle_LocOpe_GluedShape_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_LocOpe_GluedShape self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _LocOpe.Handle_LocOpe_GluedShape_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_LocOpe_GluedShape self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _LocOpe.Handle_LocOpe_GluedShape_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_LocOpe_GluedShape self)

        Increments the reference counter of this object


        """
        return _LocOpe.Handle_LocOpe_GluedShape_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_LocOpe_GluedShape self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _LocOpe.Handle_LocOpe_GluedShape_DecrementRefCounter(self, *args)

Handle_LocOpe_GluedShape_swigregister = _LocOpe.Handle_LocOpe_GluedShape_swigregister
Handle_LocOpe_GluedShape_swigregister(Handle_LocOpe_GluedShape)

def Handle_LocOpe_GluedShape_DownCast(thing):
    return _LocOpe.Handle_LocOpe_GluedShape_DownCast(thing)
Handle_LocOpe_GluedShape_DownCast = _LocOpe.Handle_LocOpe_GluedShape_DownCast

class LocOpe_(object):
    """
    Provides  tools to implement local     topological
    operations on a shape.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Closed(*args):
        """
        Closed(TopoDS_Wire W, TopoDS_Face OnF) -> Standard_Boolean
        Closed(TopoDS_Edge E, TopoDS_Face OnF) -> Standard_Boolean

        Returns Standard_True  when the edge <E> is closed
        on the face <OnF>.

        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :type OnF: OCC.wrapper.TopoDS.TopoDS_Face
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _LocOpe.LocOpe__Closed(*args)

    Closed = staticmethod(Closed)

    def TgtFaces(*args):
        """
        TgtFaces(TopoDS_Edge E, TopoDS_Face F1, TopoDS_Face F2) -> Standard_Boolean

        Returns Standard_True  when the faces are tangent

        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :type F1: OCC.wrapper.TopoDS.TopoDS_Face
        :type F2: OCC.wrapper.TopoDS.TopoDS_Face
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _LocOpe.LocOpe__TgtFaces(*args)

    TgtFaces = staticmethod(TgtFaces)

    def SampleEdges(*args):
        """
        SampleEdges(TopoDS_Shape S, NCollection_Sequence_gp_Pnt Pt)

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :type Pt: OCC.wrapper.TColgp.TColgp_SequenceOfPnt

        """
        return _LocOpe.LocOpe__SampleEdges(*args)

    SampleEdges = staticmethod(SampleEdges)

    def __init__(self):
        """
        Provides  tools to implement local     topological
        operations on a shape.
        """
        this = _LocOpe.new_LocOpe_()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _LocOpe.delete_LocOpe_
LocOpe__swigregister = _LocOpe.LocOpe__swigregister
LocOpe__swigregister(LocOpe_)

def LocOpe__Closed(*args):
    """
    Closed(TopoDS_Wire W, TopoDS_Face OnF) -> Standard_Boolean
    LocOpe__Closed(TopoDS_Edge E, TopoDS_Face OnF) -> Standard_Boolean

    Returns Standard_True  when the edge <E> is closed
    on the face <OnF>.

    :type E: OCC.wrapper.TopoDS.TopoDS_Edge
    :type OnF: OCC.wrapper.TopoDS.TopoDS_Face
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _LocOpe.LocOpe__Closed(*args)

def LocOpe__TgtFaces(*args):
    """
    LocOpe__TgtFaces(TopoDS_Edge E, TopoDS_Face F1, TopoDS_Face F2) -> Standard_Boolean

    Returns Standard_True  when the faces are tangent

    :type E: OCC.wrapper.TopoDS.TopoDS_Edge
    :type F1: OCC.wrapper.TopoDS.TopoDS_Face
    :type F2: OCC.wrapper.TopoDS.TopoDS_Face
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _LocOpe.LocOpe__TgtFaces(*args)

def LocOpe__SampleEdges(*args):
    """
    LocOpe__SampleEdges(TopoDS_Shape S, NCollection_Sequence_gp_Pnt Pt)

    :type S: OCC.wrapper.TopoDS.TopoDS_Shape
    :type Pt: OCC.wrapper.TColgp.TColgp_SequenceOfPnt

    """
    return _LocOpe.LocOpe__SampleEdges(*args)

class NCollection_Sequence_LocOpe_PntFace(NCollection.NCollection_BaseSequence):
    """
    Purpose:     Definition of a sequence of elements indexed by
    an Integer in range of 1..n
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Sequence_LocOpe_PntFace self) -> NCollection_Sequence< LocOpe_PntFace >::iterator

        Returns an iterator pointing to the first element in the sequence.

        :rtype: iterator

        """
        return _LocOpe.NCollection_Sequence_LocOpe_PntFace_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Sequence_LocOpe_PntFace self) -> NCollection_Sequence< LocOpe_PntFace >::iterator

        Returns an iterator referring to the past-the-end element in the sequence.

        :rtype: iterator

        """
        return _LocOpe.NCollection_Sequence_LocOpe_PntFace_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Sequence_LocOpe_PntFace self) -> NCollection_Sequence< LocOpe_PntFace >::const_iterator

        Returns a const iterator pointing to the first element in the sequence.

        :rtype: const_iterator

        """
        return _LocOpe.NCollection_Sequence_LocOpe_PntFace_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Sequence_LocOpe_PntFace self) -> NCollection_Sequence< LocOpe_PntFace >::const_iterator

        Returns a const iterator referring to the past-the-end element in the sequence.

        :rtype: const_iterator

        """
        return _LocOpe.NCollection_Sequence_LocOpe_PntFace_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     Definition of a sequence of elements indexed by
        an Integer in range of 1..n
        """
        this = _LocOpe.new_NCollection_Sequence_LocOpe_PntFace(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Size(self, *args):
        """
        Size(NCollection_Sequence_LocOpe_PntFace self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _LocOpe.NCollection_Sequence_LocOpe_PntFace_Size(self, *args)


    def Length(self, *args):
        """
        Length(NCollection_Sequence_LocOpe_PntFace self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _LocOpe.NCollection_Sequence_LocOpe_PntFace_Length(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Sequence_LocOpe_PntFace self) -> Standard_Integer

        Method for consistency with other collections.
        @return Lower bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _LocOpe.NCollection_Sequence_LocOpe_PntFace_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Sequence_LocOpe_PntFace self) -> Standard_Integer

        Method for consistency with other collections.
        @return Upper bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _LocOpe.NCollection_Sequence_LocOpe_PntFace_Upper(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Sequence_LocOpe_PntFace self) -> Standard_Boolean

        Empty query

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _LocOpe.NCollection_Sequence_LocOpe_PntFace_IsEmpty(self, *args)


    def Reverse(self, *args):
        """
        Reverse(NCollection_Sequence_LocOpe_PntFace self)

        Reverse sequence


        """
        return _LocOpe.NCollection_Sequence_LocOpe_PntFace_Reverse(self, *args)


    def Exchange(self, *args):
        """
        Exchange(NCollection_Sequence_LocOpe_PntFace self, Standard_Integer const I, Standard_Integer const J)

        Exchange two members

        :type I: int
        :type J: int

        """
        return _LocOpe.NCollection_Sequence_LocOpe_PntFace_Exchange(self, *args)


    def delNode(*args):
        """
        delNode(NCollection_SeqNode theNode, Handle_NCollection_BaseAllocator theAl)

        Static deleter to be passed to BaseSequence

        :type theNode: OCC.wrapper.NCollection.NCollection_SeqNode
        :type theAl: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _LocOpe.NCollection_Sequence_LocOpe_PntFace_delNode(*args)

    delNode = staticmethod(delNode)

    def Clear(self, *args):
        """
        Clear(NCollection_Sequence_LocOpe_PntFace self, Handle_NCollection_BaseAllocator theAllocator=0)

        Clear the items out, take a new allocator if non null

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _LocOpe.NCollection_Sequence_LocOpe_PntFace_Clear(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Sequence_LocOpe_PntFace self, NCollection_Sequence_LocOpe_PntFace theOther) -> NCollection_Sequence_LocOpe_PntFace

        Replace this sequence by the items of theOther.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_Sequence
        :rtype: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _LocOpe.NCollection_Sequence_LocOpe_PntFace_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Sequence_LocOpe_PntFace self, NCollection_Sequence_LocOpe_PntFace theOther) -> NCollection_Sequence_LocOpe_PntFace

        Replacement operator

        :type theOther: OCC.wrapper.NCollection.NCollection_Sequence
        :rtype: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _LocOpe.NCollection_Sequence_LocOpe_PntFace_assign(self, *args)


    def Remove(self, *args):
        """
        Remove(NCollection_Sequence_LocOpe_PntFace self, NCollection_Sequence< LocOpe_PntFace >::Iterator & thePosition)
        Remove(NCollection_Sequence_LocOpe_PntFace self, Standard_Integer const theIndex)
        Remove(NCollection_Sequence_LocOpe_PntFace self, Standard_Integer const theFromIndex, Standard_Integer const theToIndex)

        Remove range of items

        :type theFromIndex: int
        :type theToIndex: int

        """
        return _LocOpe.NCollection_Sequence_LocOpe_PntFace_Remove(self, *args)


    def Append(self, *args):
        """
        Append(NCollection_Sequence_LocOpe_PntFace self, LocOpe_PntFace theItem)
        Append(NCollection_Sequence_LocOpe_PntFace self, NCollection_Sequence_LocOpe_PntFace theSeq)

        Append another sequence (making it empty)

        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _LocOpe.NCollection_Sequence_LocOpe_PntFace_Append(self, *args)


    def Prepend(self, *args):
        """
        Prepend(NCollection_Sequence_LocOpe_PntFace self, LocOpe_PntFace theItem)
        Prepend(NCollection_Sequence_LocOpe_PntFace self, NCollection_Sequence_LocOpe_PntFace theSeq)

        Prepend another sequence (making it empty)

        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _LocOpe.NCollection_Sequence_LocOpe_PntFace_Prepend(self, *args)


    def InsertBefore(self, *args):
        """
        InsertBefore(NCollection_Sequence_LocOpe_PntFace self, Standard_Integer const theIndex, LocOpe_PntFace theItem)
        InsertBefore(NCollection_Sequence_LocOpe_PntFace self, Standard_Integer const theIndex, NCollection_Sequence_LocOpe_PntFace theSeq)

        InsertBefore theIndex another sequence

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _LocOpe.NCollection_Sequence_LocOpe_PntFace_InsertBefore(self, *args)


    def InsertAfter(self, *args):
        """
        InsertAfter(NCollection_Sequence_LocOpe_PntFace self, NCollection_Sequence< LocOpe_PntFace >::Iterator & thePosition, LocOpe_PntFace theItem)
        InsertAfter(NCollection_Sequence_LocOpe_PntFace self, Standard_Integer const theIndex, NCollection_Sequence_LocOpe_PntFace theSeq)
        InsertAfter(NCollection_Sequence_LocOpe_PntFace self, Standard_Integer const theIndex, LocOpe_PntFace theItem)

        InsertAfter theIndex another sequence

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _LocOpe.NCollection_Sequence_LocOpe_PntFace_InsertAfter(self, *args)


    def Split(self, *args):
        """
        Split(NCollection_Sequence_LocOpe_PntFace self, Standard_Integer const theIndex, NCollection_Sequence_LocOpe_PntFace theSeq)

        Split in two sequences

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _LocOpe.NCollection_Sequence_LocOpe_PntFace_Split(self, *args)


    def First(self, *args):
        """
        First item access

        :rtype: const TheItemType &

        """
        res = _LocOpe.NCollection_Sequence_LocOpe_PntFace_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Sequence_LocOpe_PntFace self) -> LocOpe_PntFace

        First item access

        :rtype: TheItemType &

        """
        return _LocOpe.NCollection_Sequence_LocOpe_PntFace_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        Last item access

        :rtype: const TheItemType &

        """
        res = _LocOpe.NCollection_Sequence_LocOpe_PntFace_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Sequence_LocOpe_PntFace self) -> LocOpe_PntFace

        Last item access

        :rtype: TheItemType &

        """
        return _LocOpe.NCollection_Sequence_LocOpe_PntFace_ChangeLast(self, *args)


    def Value(self, *args):
        """
        Constant item access by theIndex

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _LocOpe.NCollection_Sequence_LocOpe_PntFace_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Sequence_LocOpe_PntFace self, Standard_Integer const theIndex) -> LocOpe_PntFace

        Variable item access by theIndex

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _LocOpe.NCollection_Sequence_LocOpe_PntFace_ChangeValue(self, *args)


    def __call__(self, *args):
        """
        Constant operator()

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _LocOpe.NCollection_Sequence_LocOpe_PntFace___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetValue(self, *args):
        """
        SetValue(NCollection_Sequence_LocOpe_PntFace self, Standard_Integer const theIndex, LocOpe_PntFace theItem)

        Set item value by theIndex

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _LocOpe.NCollection_Sequence_LocOpe_PntFace_SetValue(self, *args)


    def __iter__(self):
        return _LocOpe.NCollection_Sequence_LocOpe_PntFace___iter__(self)
    __swig_destroy__ = _LocOpe.delete_NCollection_Sequence_LocOpe_PntFace
NCollection_Sequence_LocOpe_PntFace_swigregister = _LocOpe.NCollection_Sequence_LocOpe_PntFace_swigregister
NCollection_Sequence_LocOpe_PntFace_swigregister(NCollection_Sequence_LocOpe_PntFace)

def NCollection_Sequence_LocOpe_PntFace_delNode(*args):
    """
    NCollection_Sequence_LocOpe_PntFace_delNode(NCollection_SeqNode theNode, Handle_NCollection_BaseAllocator theAl)

    Static deleter to be passed to BaseSequence

    :type theNode: OCC.wrapper.NCollection.NCollection_SeqNode
    :type theAl: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

    """
    return _LocOpe.NCollection_Sequence_LocOpe_PntFace_delNode(*args)

class NCollection_Sequence_LocOpe_PntFace_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _LocOpe.new_NCollection_Sequence_LocOpe_PntFace_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _LocOpe.delete_NCollection_Sequence_LocOpe_PntFace_IteratorHelper

    def __next__(self):
        return _LocOpe.NCollection_Sequence_LocOpe_PntFace_IteratorHelper___next__(self)
NCollection_Sequence_LocOpe_PntFace_IteratorHelper_swigregister = _LocOpe.NCollection_Sequence_LocOpe_PntFace_IteratorHelper_swigregister
NCollection_Sequence_LocOpe_PntFace_IteratorHelper_swigregister(NCollection_Sequence_LocOpe_PntFace_IteratorHelper)


try:
	LocOpe_SequenceOfPntFace = NCollection_Sequence_LocOpe_PntFace
except NameError:
	pass # does not exist, probably ignored

class NCollection_Sequence_gp_Lin(NCollection.NCollection_BaseSequence):
    """
    Purpose:     Definition of a sequence of elements indexed by
    an Integer in range of 1..n
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Sequence_gp_Lin self) -> NCollection_Sequence< gp_Lin >::iterator

        Returns an iterator pointing to the first element in the sequence.

        :rtype: iterator

        """
        return _LocOpe.NCollection_Sequence_gp_Lin_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Sequence_gp_Lin self) -> NCollection_Sequence< gp_Lin >::iterator

        Returns an iterator referring to the past-the-end element in the sequence.

        :rtype: iterator

        """
        return _LocOpe.NCollection_Sequence_gp_Lin_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Sequence_gp_Lin self) -> NCollection_Sequence< gp_Lin >::const_iterator

        Returns a const iterator pointing to the first element in the sequence.

        :rtype: const_iterator

        """
        return _LocOpe.NCollection_Sequence_gp_Lin_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Sequence_gp_Lin self) -> NCollection_Sequence< gp_Lin >::const_iterator

        Returns a const iterator referring to the past-the-end element in the sequence.

        :rtype: const_iterator

        """
        return _LocOpe.NCollection_Sequence_gp_Lin_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     Definition of a sequence of elements indexed by
        an Integer in range of 1..n
        """
        this = _LocOpe.new_NCollection_Sequence_gp_Lin(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Size(self, *args):
        """
        Size(NCollection_Sequence_gp_Lin self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _LocOpe.NCollection_Sequence_gp_Lin_Size(self, *args)


    def Length(self, *args):
        """
        Length(NCollection_Sequence_gp_Lin self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _LocOpe.NCollection_Sequence_gp_Lin_Length(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Sequence_gp_Lin self) -> Standard_Integer

        Method for consistency with other collections.
        @return Lower bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _LocOpe.NCollection_Sequence_gp_Lin_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Sequence_gp_Lin self) -> Standard_Integer

        Method for consistency with other collections.
        @return Upper bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _LocOpe.NCollection_Sequence_gp_Lin_Upper(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Sequence_gp_Lin self) -> Standard_Boolean

        Empty query

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _LocOpe.NCollection_Sequence_gp_Lin_IsEmpty(self, *args)


    def Reverse(self, *args):
        """
        Reverse(NCollection_Sequence_gp_Lin self)

        Reverse sequence


        """
        return _LocOpe.NCollection_Sequence_gp_Lin_Reverse(self, *args)


    def Exchange(self, *args):
        """
        Exchange(NCollection_Sequence_gp_Lin self, Standard_Integer const I, Standard_Integer const J)

        Exchange two members

        :type I: int
        :type J: int

        """
        return _LocOpe.NCollection_Sequence_gp_Lin_Exchange(self, *args)


    def delNode(*args):
        """
        delNode(NCollection_SeqNode theNode, Handle_NCollection_BaseAllocator theAl)

        Static deleter to be passed to BaseSequence

        :type theNode: OCC.wrapper.NCollection.NCollection_SeqNode
        :type theAl: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _LocOpe.NCollection_Sequence_gp_Lin_delNode(*args)

    delNode = staticmethod(delNode)

    def Clear(self, *args):
        """
        Clear(NCollection_Sequence_gp_Lin self, Handle_NCollection_BaseAllocator theAllocator=0)

        Clear the items out, take a new allocator if non null

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _LocOpe.NCollection_Sequence_gp_Lin_Clear(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Sequence_gp_Lin self, NCollection_Sequence_gp_Lin theOther) -> NCollection_Sequence_gp_Lin

        Replace this sequence by the items of theOther.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_Sequence
        :rtype: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _LocOpe.NCollection_Sequence_gp_Lin_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Sequence_gp_Lin self, NCollection_Sequence_gp_Lin theOther) -> NCollection_Sequence_gp_Lin

        Replacement operator

        :type theOther: OCC.wrapper.NCollection.NCollection_Sequence
        :rtype: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _LocOpe.NCollection_Sequence_gp_Lin_assign(self, *args)


    def Remove(self, *args):
        """
        Remove(NCollection_Sequence_gp_Lin self, NCollection_Sequence< gp_Lin >::Iterator & thePosition)
        Remove(NCollection_Sequence_gp_Lin self, Standard_Integer const theIndex)
        Remove(NCollection_Sequence_gp_Lin self, Standard_Integer const theFromIndex, Standard_Integer const theToIndex)

        Remove range of items

        :type theFromIndex: int
        :type theToIndex: int

        """
        return _LocOpe.NCollection_Sequence_gp_Lin_Remove(self, *args)


    def Append(self, *args):
        """
        Append(NCollection_Sequence_gp_Lin self, gp_Lin theItem)
        Append(NCollection_Sequence_gp_Lin self, NCollection_Sequence_gp_Lin theSeq)

        Append another sequence (making it empty)

        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _LocOpe.NCollection_Sequence_gp_Lin_Append(self, *args)


    def Prepend(self, *args):
        """
        Prepend(NCollection_Sequence_gp_Lin self, gp_Lin theItem)
        Prepend(NCollection_Sequence_gp_Lin self, NCollection_Sequence_gp_Lin theSeq)

        Prepend another sequence (making it empty)

        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _LocOpe.NCollection_Sequence_gp_Lin_Prepend(self, *args)


    def InsertBefore(self, *args):
        """
        InsertBefore(NCollection_Sequence_gp_Lin self, Standard_Integer const theIndex, gp_Lin theItem)
        InsertBefore(NCollection_Sequence_gp_Lin self, Standard_Integer const theIndex, NCollection_Sequence_gp_Lin theSeq)

        InsertBefore theIndex another sequence

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _LocOpe.NCollection_Sequence_gp_Lin_InsertBefore(self, *args)


    def InsertAfter(self, *args):
        """
        InsertAfter(NCollection_Sequence_gp_Lin self, NCollection_Sequence< gp_Lin >::Iterator & thePosition, gp_Lin theItem)
        InsertAfter(NCollection_Sequence_gp_Lin self, Standard_Integer const theIndex, NCollection_Sequence_gp_Lin theSeq)
        InsertAfter(NCollection_Sequence_gp_Lin self, Standard_Integer const theIndex, gp_Lin theItem)

        InsertAfter theIndex another sequence

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _LocOpe.NCollection_Sequence_gp_Lin_InsertAfter(self, *args)


    def Split(self, *args):
        """
        Split(NCollection_Sequence_gp_Lin self, Standard_Integer const theIndex, NCollection_Sequence_gp_Lin theSeq)

        Split in two sequences

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _LocOpe.NCollection_Sequence_gp_Lin_Split(self, *args)


    def First(self, *args):
        """
        First item access

        :rtype: const TheItemType &

        """
        res = _LocOpe.NCollection_Sequence_gp_Lin_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Sequence_gp_Lin self) -> gp_Lin

        First item access

        :rtype: TheItemType &

        """
        return _LocOpe.NCollection_Sequence_gp_Lin_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        Last item access

        :rtype: const TheItemType &

        """
        res = _LocOpe.NCollection_Sequence_gp_Lin_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Sequence_gp_Lin self) -> gp_Lin

        Last item access

        :rtype: TheItemType &

        """
        return _LocOpe.NCollection_Sequence_gp_Lin_ChangeLast(self, *args)


    def Value(self, *args):
        """
        Constant item access by theIndex

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _LocOpe.NCollection_Sequence_gp_Lin_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Sequence_gp_Lin self, Standard_Integer const theIndex) -> gp_Lin

        Variable item access by theIndex

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _LocOpe.NCollection_Sequence_gp_Lin_ChangeValue(self, *args)


    def __call__(self, *args):
        """
        Constant operator()

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _LocOpe.NCollection_Sequence_gp_Lin___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetValue(self, *args):
        """
        SetValue(NCollection_Sequence_gp_Lin self, Standard_Integer const theIndex, gp_Lin theItem)

        Set item value by theIndex

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _LocOpe.NCollection_Sequence_gp_Lin_SetValue(self, *args)


    def __iter__(self):
        return _LocOpe.NCollection_Sequence_gp_Lin___iter__(self)
    __swig_destroy__ = _LocOpe.delete_NCollection_Sequence_gp_Lin
NCollection_Sequence_gp_Lin_swigregister = _LocOpe.NCollection_Sequence_gp_Lin_swigregister
NCollection_Sequence_gp_Lin_swigregister(NCollection_Sequence_gp_Lin)

def NCollection_Sequence_gp_Lin_delNode(*args):
    """
    NCollection_Sequence_gp_Lin_delNode(NCollection_SeqNode theNode, Handle_NCollection_BaseAllocator theAl)

    Static deleter to be passed to BaseSequence

    :type theNode: OCC.wrapper.NCollection.NCollection_SeqNode
    :type theAl: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

    """
    return _LocOpe.NCollection_Sequence_gp_Lin_delNode(*args)

class NCollection_Sequence_gp_Lin_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _LocOpe.new_NCollection_Sequence_gp_Lin_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _LocOpe.delete_NCollection_Sequence_gp_Lin_IteratorHelper

    def __next__(self):
        return _LocOpe.NCollection_Sequence_gp_Lin_IteratorHelper___next__(self)
NCollection_Sequence_gp_Lin_IteratorHelper_swigregister = _LocOpe.NCollection_Sequence_gp_Lin_IteratorHelper_swigregister
NCollection_Sequence_gp_Lin_IteratorHelper_swigregister(NCollection_Sequence_gp_Lin_IteratorHelper)


try:
	LocOpe_SequenceOfLin = NCollection_Sequence_gp_Lin
except NameError:
	pass # does not exist, probably ignored

class LocOpe_CSIntersector(object):
    """
    This class provides the intersection between a set
    of axis or a circle and the faces of a shape.  The
    intersection  points  are   sorted  in  increasing
    parameter along each axis or circle.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(LocOpe_CSIntersector self) -> LocOpe_CSIntersector
        __init__(LocOpe_CSIntersector self, TopoDS_Shape S) -> LocOpe_CSIntersector

        Creates  and performs the intersection     betwwen
        <Ax1> and <S>.

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        this = _LocOpe.new_LocOpe_CSIntersector(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(LocOpe_CSIntersector self, TopoDS_Shape S)

        Performs the intersection between <Ax1 and <S>.

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _LocOpe.LocOpe_CSIntersector_Init(self, *args)


    def Perform(self, *args):
        """
        Perform(LocOpe_CSIntersector self, NCollection_Sequence_gp_Lin Slin)
        Perform(LocOpe_CSIntersector self, NCollection_Sequence_gp_Circ Scir)
        Perform(LocOpe_CSIntersector self, NCollection_Sequence_Handle_Geom_Curve Scur)

        :type Scur: OCC.wrapper.TColGeom.TColGeom_SequenceOfCurve

        """
        return _LocOpe.LocOpe_CSIntersector_Perform(self, *args)


    def IsDone(self, *args):
        """
        IsDone(LocOpe_CSIntersector self) -> Standard_Boolean

        Returns <Standard_True>  if the  intersection  has
        been done.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _LocOpe.LocOpe_CSIntersector_IsDone(self, *args)


    def NbPoints(self, *args):
        """
        NbPoints(LocOpe_CSIntersector self, Standard_Integer const I) -> Standard_Integer

        Returns  the number of   intersection point on the
        element of range <I>.

        :type I: int
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _LocOpe.LocOpe_CSIntersector_NbPoints(self, *args)


    def Point(self, *args):
        """
        Returns the intersection point of range <Index> on
        element of range   <I>. The points   are sorted in
        increasing order of parameter along the axis.

        :type I: int
        :type Index: int
        :rtype: OCC.wrapper.LocOpe.LocOpe_PntFace

        """
        res = _LocOpe.LocOpe_CSIntersector_Point(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def LocalizeAfter(self, *args):
        """
        LocalizeAfter(LocOpe_CSIntersector self, Standard_Integer const I, Standard_Real const From, Standard_Real const Tol) -> Standard_Boolean
        LocalizeAfter(LocOpe_CSIntersector self, Standard_Integer const I, Standard_Integer const FromInd, Standard_Real const Tol) -> Standard_Boolean

        On the  element of  range <I>, searches  the first
        intersection      point  located after the   index
        <FromInd> ( >=  FromInd + 1), wich  orientation is
        not    TopAbs_EXTERNAL.      If    found,  returns
        <Standard_True>.  <Or> contains the orientation of
        the  point, <IndFrom>  and <IndTo> represents  the
        interval of index in  the sequence of intersection
        point corresponding   to the  point.  (IndFrom  <=
        IndTo). <Tol> is used to determine if 2 parameters
        are equal.

        Otherwise, returns <Standard_False>.

        :type I: int
        :type FromInd: int
        :type Tol: float
        :type Or: OCC.wrapper.TopAbs.TopAbs_Orientation
        :type IndFrom: int
        :type IndTo: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _LocOpe.LocOpe_CSIntersector_LocalizeAfter(self, *args)


    def LocalizeBefore(self, *args):
        """
        LocalizeBefore(LocOpe_CSIntersector self, Standard_Integer const I, Standard_Real const From, Standard_Real const Tol) -> Standard_Boolean
        LocalizeBefore(LocOpe_CSIntersector self, Standard_Integer const I, Standard_Integer const FromInd, Standard_Real const Tol) -> Standard_Boolean

        On  the element of  range  <I>, searches the first
        intersection  point    located  before  the  index
        <FromInd>  (  <= FromInd -1),  wich orientation is
        not   TopAbs_EXTERNAL.  If    found,       returns
        <Standard_True>.  <Or> contains the orientation of
        the  point, <IndFrom>  and  <IndTo> represents the
        interval of  index in the sequence of intersection
        point  corresponding to   the  point  (IndFrom  <=
        IndTo). <Tol> is used to determine if 2 parameters
        are equal.

        Otherwise, returns <Standard_False>.

        :type I: int
        :type FromInd: int
        :type Tol: float
        :type Or: OCC.wrapper.TopAbs.TopAbs_Orientation
        :type IndFrom: int
        :type IndTo: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _LocOpe.LocOpe_CSIntersector_LocalizeBefore(self, *args)


    def Destroy(self, *args):
        """Destroy(LocOpe_CSIntersector self)"""
        return _LocOpe.LocOpe_CSIntersector_Destroy(self, *args)

    __swig_destroy__ = _LocOpe.delete_LocOpe_CSIntersector
LocOpe_CSIntersector_swigregister = _LocOpe.LocOpe_CSIntersector_swigregister
LocOpe_CSIntersector_swigregister(LocOpe_CSIntersector)

class LocOpe_CurveShapeIntersector(object):
    """
    This  class  provides  the intersection between an
    axis  or  a circle and  the  faces of a shape. The
    intersection   points  are   sorted in  increasing
    parameter along the axis.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(LocOpe_CurveShapeIntersector self) -> LocOpe_CurveShapeIntersector
        __init__(LocOpe_CurveShapeIntersector self, gp_Ax1 Axis, TopoDS_Shape S) -> LocOpe_CurveShapeIntersector
        __init__(LocOpe_CurveShapeIntersector self, gp_Circ C, TopoDS_Shape S) -> LocOpe_CurveShapeIntersector

        Creates  and performs yte intersection     betwwen
        <C> and <S>.

        :type C: OCC.wrapper.gp.gp_Circ
        :type S: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        this = _LocOpe.new_LocOpe_CurveShapeIntersector(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(LocOpe_CurveShapeIntersector self, gp_Ax1 Axis, TopoDS_Shape S)
        Init(LocOpe_CurveShapeIntersector self, gp_Circ C, TopoDS_Shape S)

        Performs the intersection between <Ax1 and <S>.

        :type C: OCC.wrapper.gp.gp_Circ
        :type S: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _LocOpe.LocOpe_CurveShapeIntersector_Init(self, *args)


    def IsDone(self, *args):
        """
        IsDone(LocOpe_CurveShapeIntersector self) -> Standard_Boolean

        Returns <Standard_True>  if the  intersection  has
        been done.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _LocOpe.LocOpe_CurveShapeIntersector_IsDone(self, *args)


    def NbPoints(self, *args):
        """
        NbPoints(LocOpe_CurveShapeIntersector self) -> Standard_Integer

        Returns the number of intersection point.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _LocOpe.LocOpe_CurveShapeIntersector_NbPoints(self, *args)


    def Point(self, *args):
        """
        Returns the intersection  point  of range <Index>.
        The points  are   sorted in increasing  order   of
        parameter along the axis.

        :type Index: int
        :rtype: OCC.wrapper.LocOpe.LocOpe_PntFace

        """
        res = _LocOpe.LocOpe_CurveShapeIntersector_Point(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def LocalizeAfter(self, *args):
        """
        LocalizeAfter(LocOpe_CurveShapeIntersector self, Standard_Real const From) -> Standard_Boolean
        LocalizeAfter(LocOpe_CurveShapeIntersector self, Standard_Integer const FromInd) -> Standard_Boolean

        Searches  the first intersection point     located
        after the index <FromInd>  ( >= FromInd + 1), wich
        orientation   is   not TopAbs_EXTERNAL.   If found,
        returns   <Standard_True>.   <Or>  contains    the
        orientation of the  point, <IndFrom>  and  <IndTo>
        represents the interval  of index in  the sequence
        of  intersection  point     corresponding to   the
        point. (IndFrom <= IndTo).

        Otherwise, returns <Standard_False>.

        :type FromInd: int
        :type Or: OCC.wrapper.TopAbs.TopAbs_Orientation
        :type IndFrom: int
        :type IndTo: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _LocOpe.LocOpe_CurveShapeIntersector_LocalizeAfter(self, *args)


    def LocalizeBefore(self, *args):
        """
        LocalizeBefore(LocOpe_CurveShapeIntersector self, Standard_Real const From) -> Standard_Boolean
        LocalizeBefore(LocOpe_CurveShapeIntersector self, Standard_Integer const FromInd) -> Standard_Boolean

        Searches the  first  intersection   point  located
        before the index <FromInd>  ( <= FromInd -1), wich
        orientation is   not TopAbs_EXTERNAL.   If   found,
        returns   <Standard_True>.  <Or>  contains     the
        orientation  of the  point,  <IndFrom> and <IndTo>
        represents the interval  of index  in the sequence
        of  intersection  point corresponding to the point
        (IndFrom <= IndTo).

        Otherwise, returns <Standard_False>.

        :type FromInd: int
        :type Or: OCC.wrapper.TopAbs.TopAbs_Orientation
        :type IndFrom: int
        :type IndTo: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _LocOpe.LocOpe_CurveShapeIntersector_LocalizeBefore(self, *args)

    __swig_destroy__ = _LocOpe.delete_LocOpe_CurveShapeIntersector
LocOpe_CurveShapeIntersector_swigregister = _LocOpe.LocOpe_CurveShapeIntersector_swigregister
LocOpe_CurveShapeIntersector_swigregister(LocOpe_CurveShapeIntersector)

class LocOpe_SplitShape(object):
    """
    Provides a tool to cut  :
    - edges with a vertices,
    - faces with wires,
    and  rebuilds  the shape containing the edges and
    the faces.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(LocOpe_SplitShape self) -> LocOpe_SplitShape
        __init__(LocOpe_SplitShape self, TopoDS_Shape S) -> LocOpe_SplitShape

        Creates the process  with the shape <S>.

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        this = _LocOpe.new_LocOpe_SplitShape(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(LocOpe_SplitShape self, TopoDS_Shape S)

        Initializes the process on the shape <S>.

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _LocOpe.LocOpe_SplitShape_Init(self, *args)


    def CanSplit(self, *args):
        """
        CanSplit(LocOpe_SplitShape self, TopoDS_Edge E) -> Standard_Boolean

        Tests if it is possible to split the edge <E>.

        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _LocOpe.LocOpe_SplitShape_CanSplit(self, *args)


    def Add(self, *args):
        """
        Add(LocOpe_SplitShape self, TopoDS_Vertex V, Standard_Real const P, TopoDS_Edge E)
        Add(LocOpe_SplitShape self, TopoDS_Wire W, TopoDS_Face F) -> Standard_Boolean
        Add(LocOpe_SplitShape self, NCollection_List_TopoDS_Shape Lwires, TopoDS_Face F) -> Standard_Boolean

        Adds the list of wires <Lwires> on the face <F>.

        :type Lwires: OCC.wrapper.TopTools.TopTools_ListOfShape
        :type F: OCC.wrapper.TopoDS.TopoDS_Face
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _LocOpe.LocOpe_SplitShape_Add(self, *args)


    def Shape(self, *args):
        """
        Returns the "original" shape.

        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _LocOpe.LocOpe_SplitShape_Shape(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DescendantShapes(self, *args):
        """
        Returns the list of descendant shapes of <S>.

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.TopTools.TopTools_ListOfShape

        """
        res = _LocOpe.LocOpe_SplitShape_DescendantShapes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def LeftOf(self, *args):
        """
        Returns the "left" part defined by the wire <W> on
        the face <F>.   The  returned list of shape  is in
        fact  a list of faces. The  face <F> is considered
        with its topological  orientation  in the original
        shape.  <W> is considered with its orientation.

        :type W: OCC.wrapper.TopoDS.TopoDS_Wire
        :type F: OCC.wrapper.TopoDS.TopoDS_Face
        :rtype: OCC.wrapper.TopTools.TopTools_ListOfShape

        """
        res = _LocOpe.LocOpe_SplitShape_LeftOf(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _LocOpe.delete_LocOpe_SplitShape
LocOpe_SplitShape_swigregister = _LocOpe.LocOpe_SplitShape_swigregister
LocOpe_SplitShape_swigregister(LocOpe_SplitShape)

class LocOpe_Pipe(object):
    """
    Defines a  pipe  (near from   Pipe from BRepFill),
    with modifications provided for the Pipe feature.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(LocOpe_Pipe self, TopoDS_Wire Spine, TopoDS_Shape Profile) -> LocOpe_Pipe

        :type Spine: OCC.wrapper.TopoDS.TopoDS_Wire
        :type Profile: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        this = _LocOpe.new_LocOpe_Pipe(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Spine(self, *args):
        """
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _LocOpe.LocOpe_Pipe_Spine(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Profile(self, *args):
        """
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _LocOpe.LocOpe_Pipe_Profile(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def FirstShape(self, *args):
        """
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _LocOpe.LocOpe_Pipe_FirstShape(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def LastShape(self, *args):
        """
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _LocOpe.LocOpe_Pipe_LastShape(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Shape(self, *args):
        """
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _LocOpe.LocOpe_Pipe_Shape(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Shapes(self, *args):
        """
        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.TopTools.TopTools_ListOfShape

        """
        res = _LocOpe.LocOpe_Pipe_Shapes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Curves(self, *args):
        """
        :type Spt: OCC.wrapper.TColgp.TColgp_SequenceOfPnt
        :rtype: OCC.wrapper.TColGeom.TColGeom_SequenceOfCurve

        """
        res = _LocOpe.LocOpe_Pipe_Curves(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def BarycCurve(self, *args):
        """
        BarycCurve(LocOpe_Pipe self) -> Handle_Geom_Curve

        :rtype: OCC.wrapper.Geom.Handle_Geom_Curve

        """
        return _LocOpe.LocOpe_Pipe_BarycCurve(self, *args)

    __swig_destroy__ = _LocOpe.delete_LocOpe_Pipe
LocOpe_Pipe_swigregister = _LocOpe.LocOpe_Pipe_swigregister
LocOpe_Pipe_swigregister(LocOpe_Pipe)

class LocOpe_BuildWires(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(LocOpe_BuildWires self) -> LocOpe_BuildWires
        __init__(LocOpe_BuildWires self, NCollection_List_TopoDS_Shape Ledges, Handle_LocOpe_WiresOnShape PW) -> LocOpe_BuildWires

        :type Ledges: OCC.wrapper.TopTools.TopTools_ListOfShape
        :type PW: OCC.wrapper.LocOpe.Handle_LocOpe_WiresOnShape

        """
        this = _LocOpe.new_LocOpe_BuildWires(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Perform(self, *args):
        """
        Perform(LocOpe_BuildWires self, NCollection_List_TopoDS_Shape Ledges, Handle_LocOpe_WiresOnShape PW)

        :type Ledges: OCC.wrapper.TopTools.TopTools_ListOfShape
        :type PW: OCC.wrapper.LocOpe.Handle_LocOpe_WiresOnShape

        """
        return _LocOpe.LocOpe_BuildWires_Perform(self, *args)


    def IsDone(self, *args):
        """
        IsDone(LocOpe_BuildWires self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _LocOpe.LocOpe_BuildWires_IsDone(self, *args)


    def Result(self, *args):
        """
        :rtype: OCC.wrapper.TopTools.TopTools_ListOfShape

        """
        res = _LocOpe.LocOpe_BuildWires_Result(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _LocOpe.delete_LocOpe_BuildWires
LocOpe_BuildWires_swigregister = _LocOpe.LocOpe_BuildWires_swigregister
LocOpe_BuildWires_swigregister(LocOpe_BuildWires)

class LocOpe_Generator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(LocOpe_Generator self) -> LocOpe_Generator
        __init__(LocOpe_Generator self, TopoDS_Shape S) -> LocOpe_Generator

        Creates the algorithm on the shape <S>.

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        this = _LocOpe.new_LocOpe_Generator(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(LocOpe_Generator self, TopoDS_Shape S)

        Initializes the algorithm on the shape <S>.

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _LocOpe.LocOpe_Generator_Init(self, *args)


    def Perform(self, *args):
        """
        Perform(LocOpe_Generator self, Handle_LocOpe_GeneratedShape G)

        :type G: OCC.wrapper.LocOpe.Handle_LocOpe_GeneratedShape

        """
        return _LocOpe.LocOpe_Generator_Perform(self, *args)


    def IsDone(self, *args):
        """
        IsDone(LocOpe_Generator self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _LocOpe.LocOpe_Generator_IsDone(self, *args)


    def ResultingShape(self, *args):
        """
        Returns the new shape

        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _LocOpe.LocOpe_Generator_ResultingShape(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Shape(self, *args):
        """
        Returns the initial shape

        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _LocOpe.LocOpe_Generator_Shape(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DescendantFace(self, *args):
        """
        Returns  the  descendant  face  of <F>.    <F> may
        belong to the original shape or to the "generated"
        shape.  The returned    face may be   a null shape
        (when <F> disappears).

        :type F: OCC.wrapper.TopoDS.TopoDS_Face
        :rtype: OCC.wrapper.TopTools.TopTools_ListOfShape

        """
        res = _LocOpe.LocOpe_Generator_DescendantFace(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _LocOpe.delete_LocOpe_Generator
LocOpe_Generator_swigregister = _LocOpe.LocOpe_Generator_swigregister
LocOpe_Generator_swigregister(LocOpe_Generator)

class LocOpe_BuildShape(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(LocOpe_BuildShape self) -> LocOpe_BuildShape
        __init__(LocOpe_BuildShape self, NCollection_List_TopoDS_Shape L) -> LocOpe_BuildShape

        Builds shape(s) from  the list <L>.  Uses only the
        faces of <L>.

        :type L: OCC.wrapper.TopTools.TopTools_ListOfShape

        """
        this = _LocOpe.new_LocOpe_BuildShape(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Perform(self, *args):
        """
        Perform(LocOpe_BuildShape self, NCollection_List_TopoDS_Shape L)

        Builds shape(s) from  the list <L>.  Uses only the
        faces of <L>.

        :type L: OCC.wrapper.TopTools.TopTools_ListOfShape

        """
        return _LocOpe.LocOpe_BuildShape_Perform(self, *args)


    def Shape(self, *args):
        """
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _LocOpe.LocOpe_BuildShape_Shape(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _LocOpe.delete_LocOpe_BuildShape
LocOpe_BuildShape_swigregister = _LocOpe.LocOpe_BuildShape_swigregister
LocOpe_BuildShape_swigregister(LocOpe_BuildShape)

class LocOpe_Prism(object):
    """
    Defines a prism (using Prism from BRepSweep)
    with modifications provided for the Prism feature.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(LocOpe_Prism self) -> LocOpe_Prism
        __init__(LocOpe_Prism self, TopoDS_Shape Base, gp_Vec V) -> LocOpe_Prism
        __init__(LocOpe_Prism self, TopoDS_Shape Base, gp_Vec V, gp_Vec Vectra) -> LocOpe_Prism

        :type Base: OCC.wrapper.TopoDS.TopoDS_Shape
        :type V: OCC.wrapper.gp.gp_Vec
        :type Vectra: OCC.wrapper.gp.gp_Vec

        """
        this = _LocOpe.new_LocOpe_Prism(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Perform(self, *args):
        """
        Perform(LocOpe_Prism self, TopoDS_Shape Base, gp_Vec V)
        Perform(LocOpe_Prism self, TopoDS_Shape Base, gp_Vec V, gp_Vec Vtra)

        :type Base: OCC.wrapper.TopoDS.TopoDS_Shape
        :type V: OCC.wrapper.gp.gp_Vec
        :type Vtra: OCC.wrapper.gp.gp_Vec

        """
        return _LocOpe.LocOpe_Prism_Perform(self, *args)


    def FirstShape(self, *args):
        """
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _LocOpe.LocOpe_Prism_FirstShape(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def LastShape(self, *args):
        """
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _LocOpe.LocOpe_Prism_LastShape(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Shape(self, *args):
        """
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _LocOpe.LocOpe_Prism_Shape(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Shapes(self, *args):
        """
        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.TopTools.TopTools_ListOfShape

        """
        res = _LocOpe.LocOpe_Prism_Shapes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Curves(self, *args):
        """
        Curves(LocOpe_Prism self, NCollection_Sequence_Handle_Geom_Curve SCurves)

        :type SCurves: OCC.wrapper.TColGeom.TColGeom_SequenceOfCurve

        """
        return _LocOpe.LocOpe_Prism_Curves(self, *args)


    def BarycCurve(self, *args):
        """
        BarycCurve(LocOpe_Prism self) -> Handle_Geom_Curve

        :rtype: OCC.wrapper.Geom.Handle_Geom_Curve

        """
        return _LocOpe.LocOpe_Prism_BarycCurve(self, *args)

    __swig_destroy__ = _LocOpe.delete_LocOpe_Prism
LocOpe_Prism_swigregister = _LocOpe.LocOpe_Prism_swigregister
LocOpe_Prism_swigregister(LocOpe_Prism)

class Handle_LocOpe_GeneratedShape(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_LocOpe_GeneratedShape self)

        Nullify the handle


        """
        return _LocOpe.Handle_LocOpe_GeneratedShape_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_LocOpe_GeneratedShape self) -> bool

        Check for being null

        :rtype: bool

        """
        return _LocOpe.Handle_LocOpe_GeneratedShape_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_LocOpe_GeneratedShape self, LocOpe_GeneratedShape thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _LocOpe.Handle_LocOpe_GeneratedShape_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_LocOpe_GeneratedShape self, Handle_LocOpe_GeneratedShape theHandle) -> Handle_LocOpe_GeneratedShape
        assign(Handle_LocOpe_GeneratedShape self, LocOpe_GeneratedShape thePtr) -> Handle_LocOpe_GeneratedShape
        assign(Handle_LocOpe_GeneratedShape self, Handle_LocOpe_GeneratedShape theHandle) -> Handle_LocOpe_GeneratedShape

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _LocOpe.Handle_LocOpe_GeneratedShape_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_LocOpe_GeneratedShape self) -> LocOpe_GeneratedShape

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _LocOpe.Handle_LocOpe_GeneratedShape_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_LocOpe_GeneratedShape self) -> LocOpe_GeneratedShape

        Member access operator (note non-const)

        :rtype: T *

        """
        return _LocOpe.Handle_LocOpe_GeneratedShape___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_LocOpe_GeneratedShape self) -> LocOpe_GeneratedShape

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _LocOpe.Handle_LocOpe_GeneratedShape___ref__(self, *args)


    def __hash__(self):
        return _LocOpe.Handle_LocOpe_GeneratedShape___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _LocOpe.Handle_LocOpe_GeneratedShape___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _LocOpe.new_Handle_LocOpe_GeneratedShape(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_LocOpe.Handle_LocOpe_GeneratedShape_DownCast)
    __swig_destroy__ = _LocOpe.delete_Handle_LocOpe_GeneratedShape

    def GeneratingEdges(self, *args):
        """
        :rtype: OCC.wrapper.TopTools.TopTools_ListOfShape

        """
        res = _LocOpe.Handle_LocOpe_GeneratedShape_GeneratingEdges(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Generated(self, *args):
        """
        Generated(Handle_LocOpe_GeneratedShape self, TopoDS_Vertex V) -> TopoDS_Edge
        Generated(Handle_LocOpe_GeneratedShape self, TopoDS_Edge E) -> TopoDS_Face

        Returns the face created by the edge <E>. If none,
        must return a null shape.

        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :rtype: OCC.wrapper.TopoDS.TopoDS_Face

        """
        return _LocOpe.Handle_LocOpe_GeneratedShape_Generated(self, *args)


    def OrientedFaces(self, *args):
        """
        Returns  the  list of correctly oriented generated
        faces.

        :rtype: OCC.wrapper.TopTools.TopTools_ListOfShape

        """
        res = _LocOpe.Handle_LocOpe_GeneratedShape_OrientedFaces(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def get_type_name(self, *args):
        """
        get_type_name(Handle_LocOpe_GeneratedShape self) -> char const *

        :rtype: const char *

        """
        return _LocOpe.Handle_LocOpe_GeneratedShape_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _LocOpe.Handle_LocOpe_GeneratedShape_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _LocOpe.Handle_LocOpe_GeneratedShape_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_LocOpe_GeneratedShape self)

        Memory deallocator for transient classes


        """
        return _LocOpe.Handle_LocOpe_GeneratedShape_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_LocOpe_GeneratedShape self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_LocOpe_GeneratedShape self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _LocOpe.Handle_LocOpe_GeneratedShape_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_LocOpe_GeneratedShape self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_LocOpe_GeneratedShape self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _LocOpe.Handle_LocOpe_GeneratedShape_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_LocOpe_GeneratedShape self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _LocOpe.Handle_LocOpe_GeneratedShape_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_LocOpe_GeneratedShape self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _LocOpe.Handle_LocOpe_GeneratedShape_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_LocOpe_GeneratedShape self)

        Increments the reference counter of this object


        """
        return _LocOpe.Handle_LocOpe_GeneratedShape_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_LocOpe_GeneratedShape self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _LocOpe.Handle_LocOpe_GeneratedShape_DecrementRefCounter(self, *args)

Handle_LocOpe_GeneratedShape_swigregister = _LocOpe.Handle_LocOpe_GeneratedShape_swigregister
Handle_LocOpe_GeneratedShape_swigregister(Handle_LocOpe_GeneratedShape)

def Handle_LocOpe_GeneratedShape_DownCast(thing):
    return _LocOpe.Handle_LocOpe_GeneratedShape_DownCast(thing)
Handle_LocOpe_GeneratedShape_DownCast = _LocOpe.Handle_LocOpe_GeneratedShape_DownCast

class NCollection_DataMap_TopoDS_Shape_gp_Pnt_TopTools_ShapeMapHasher(NCollection.NCollection_BaseMap):
    """
    Purpose:     The DataMap is a Map to store keys with associated
    Items. See Map  from NCollection for  a discussion
    about the number of buckets.

    The DataMap can be seen as an extended array where
    the Keys  are the   indices.  For this reason  the
    operator () is defined on DataMap to fetch an Item
    from a Key. So the following syntax can be used :

    anItem = aMap(aKey);
    aMap(aKey) = anItem;

    This analogy has its  limit.   aMap(aKey) = anItem
    can  be done only  if aKey was previously bound to
    an item in the map.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_DataMap_TopoDS_Shape_gp_Pnt_TopTools_ShapeMapHasher self) -> NCollection_DataMap< TopoDS_Shape,gp_Pnt,TopTools_ShapeMapHasher >::iterator

        Returns an iterator pointing to the first element in the map.

        :rtype: iterator

        """
        return _LocOpe.NCollection_DataMap_TopoDS_Shape_gp_Pnt_TopTools_ShapeMapHasher_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_DataMap_TopoDS_Shape_gp_Pnt_TopTools_ShapeMapHasher self) -> NCollection_DataMap< TopoDS_Shape,gp_Pnt,TopTools_ShapeMapHasher >::iterator

        Returns an iterator referring to the past-the-end element in the map.

        :rtype: iterator

        """
        return _LocOpe.NCollection_DataMap_TopoDS_Shape_gp_Pnt_TopTools_ShapeMapHasher_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_DataMap_TopoDS_Shape_gp_Pnt_TopTools_ShapeMapHasher self) -> NCollection_DataMap< TopoDS_Shape,gp_Pnt,TopTools_ShapeMapHasher >::const_iterator

        Returns a const iterator pointing to the first element in the map.

        :rtype: const_iterator

        """
        return _LocOpe.NCollection_DataMap_TopoDS_Shape_gp_Pnt_TopTools_ShapeMapHasher_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_DataMap_TopoDS_Shape_gp_Pnt_TopTools_ShapeMapHasher self) -> NCollection_DataMap< TopoDS_Shape,gp_Pnt,TopTools_ShapeMapHasher >::const_iterator

        Returns a const iterator referring to the past-the-end element in the map.

        :rtype: const_iterator

        """
        return _LocOpe.NCollection_DataMap_TopoDS_Shape_gp_Pnt_TopTools_ShapeMapHasher_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     The DataMap is a Map to store keys with associated
        Items. See Map  from NCollection for  a discussion
        about the number of buckets.

        The DataMap can be seen as an extended array where
        the Keys  are the   indices.  For this reason  the
        operator () is defined on DataMap to fetch an Item
        from a Key. So the following syntax can be used :

        anItem = aMap(aKey);
        aMap(aKey) = anItem;

        This analogy has its  limit.   aMap(aKey) = anItem
        can  be done only  if aKey was previously bound to
        an item in the map.
        """
        this = _LocOpe.new_NCollection_DataMap_TopoDS_Shape_gp_Pnt_TopTools_ShapeMapHasher(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Exchange(self, *args):
        """
        Exchange(NCollection_DataMap_TopoDS_Shape_gp_Pnt_TopTools_ShapeMapHasher self, NCollection_DataMap_TopoDS_Shape_gp_Pnt_TopTools_ShapeMapHasher theOther)

        Exchange the content of two maps without re-allocations.
        Notice that allocators will be swapped as well!

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _LocOpe.NCollection_DataMap_TopoDS_Shape_gp_Pnt_TopTools_ShapeMapHasher_Exchange(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_DataMap_TopoDS_Shape_gp_Pnt_TopTools_ShapeMapHasher self, NCollection_DataMap_TopoDS_Shape_gp_Pnt_TopTools_ShapeMapHasher theOther) -> NCollection_DataMap_TopoDS_Shape_gp_Pnt_TopTools_ShapeMapHasher

        Assignment.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _LocOpe.NCollection_DataMap_TopoDS_Shape_gp_Pnt_TopTools_ShapeMapHasher_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_DataMap_TopoDS_Shape_gp_Pnt_TopTools_ShapeMapHasher self, NCollection_DataMap_TopoDS_Shape_gp_Pnt_TopTools_ShapeMapHasher theOther) -> NCollection_DataMap_TopoDS_Shape_gp_Pnt_TopTools_ShapeMapHasher

        Assignment operator

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _LocOpe.NCollection_DataMap_TopoDS_Shape_gp_Pnt_TopTools_ShapeMapHasher_assign(self, *args)


    def ReSize(self, *args):
        """
        ReSize(NCollection_DataMap_TopoDS_Shape_gp_Pnt_TopTools_ShapeMapHasher self, Standard_Integer const N)

        ReSize

        :type N: int

        """
        return _LocOpe.NCollection_DataMap_TopoDS_Shape_gp_Pnt_TopTools_ShapeMapHasher_ReSize(self, *args)


    def Bind(self, *args):
        """
        Bind(NCollection_DataMap_TopoDS_Shape_gp_Pnt_TopTools_ShapeMapHasher self, TopoDS_Shape theKey, gp_Pnt theItem) -> Standard_Boolean

        Bind binds Item to Key in map.
        @param theKey  key to add/update
        @param theItem new item; overrides value previously bound to the key, if any
        @return Standard_True if Key was not bound already

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _LocOpe.NCollection_DataMap_TopoDS_Shape_gp_Pnt_TopTools_ShapeMapHasher_Bind(self, *args)


    def Bound(self, *args):
        """
        Bound(NCollection_DataMap_TopoDS_Shape_gp_Pnt_TopTools_ShapeMapHasher self, TopoDS_Shape theKey, gp_Pnt theItem) -> gp_Pnt

        Bound binds Item to Key in map. Returns modifiable Item 

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: TheItemType *

        """
        return _LocOpe.NCollection_DataMap_TopoDS_Shape_gp_Pnt_TopTools_ShapeMapHasher_Bound(self, *args)


    def IsBound(self, *args):
        """
        IsBound(NCollection_DataMap_TopoDS_Shape_gp_Pnt_TopTools_ShapeMapHasher self, TopoDS_Shape theKey) -> Standard_Boolean

        IsBound

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _LocOpe.NCollection_DataMap_TopoDS_Shape_gp_Pnt_TopTools_ShapeMapHasher_IsBound(self, *args)


    def UnBind(self, *args):
        """
        UnBind(NCollection_DataMap_TopoDS_Shape_gp_Pnt_TopTools_ShapeMapHasher self, TopoDS_Shape theKey) -> Standard_Boolean

        UnBind removes Item Key pair from map

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _LocOpe.NCollection_DataMap_TopoDS_Shape_gp_Pnt_TopTools_ShapeMapHasher_UnBind(self, *args)


    def Seek(self, *args):
        """
        Seek(NCollection_DataMap_TopoDS_Shape_gp_Pnt_TopTools_ShapeMapHasher self, TopoDS_Shape theKey) -> gp_Pnt

        Seek returns pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: const TheItemType *

        """
        return _LocOpe.NCollection_DataMap_TopoDS_Shape_gp_Pnt_TopTools_ShapeMapHasher_Seek(self, *args)


    def Find(self, *args):
        """
        Find returns the Item for Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _LocOpe.NCollection_DataMap_TopoDS_Shape_gp_Pnt_TopTools_ShapeMapHasher_Find(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeSeek(self, *args):
        """
        ChangeSeek(NCollection_DataMap_TopoDS_Shape_gp_Pnt_TopTools_ShapeMapHasher self, TopoDS_Shape theKey) -> gp_Pnt

        ChangeSeek returns modifiable pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: TheItemType *

        """
        return _LocOpe.NCollection_DataMap_TopoDS_Shape_gp_Pnt_TopTools_ShapeMapHasher_ChangeSeek(self, *args)


    def ChangeFind(self, *args):
        """
        ChangeFind(NCollection_DataMap_TopoDS_Shape_gp_Pnt_TopTools_ShapeMapHasher self, TopoDS_Shape theKey) -> gp_Pnt

        ChangeFind returns mofifiable Item by Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: TheItemType &

        """
        return _LocOpe.NCollection_DataMap_TopoDS_Shape_gp_Pnt_TopTools_ShapeMapHasher_ChangeFind(self, *args)


    def __call__(self, *args):
        """
        operator ()

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _LocOpe.NCollection_DataMap_TopoDS_Shape_gp_Pnt_TopTools_ShapeMapHasher___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Clear(self, *args):
        """
        Clear(NCollection_DataMap_TopoDS_Shape_gp_Pnt_TopTools_ShapeMapHasher self, Standard_Boolean const doReleaseMemory)
        Clear(NCollection_DataMap_TopoDS_Shape_gp_Pnt_TopTools_ShapeMapHasher self, Handle_NCollection_BaseAllocator theAllocator)

        Clear data and reset allocator

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _LocOpe.NCollection_DataMap_TopoDS_Shape_gp_Pnt_TopTools_ShapeMapHasher_Clear(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_DataMap_TopoDS_Shape_gp_Pnt_TopTools_ShapeMapHasher self) -> Standard_Integer

        Size

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _LocOpe.NCollection_DataMap_TopoDS_Shape_gp_Pnt_TopTools_ShapeMapHasher_Size(self, *args)


    def __iter__(self):
        return _LocOpe.NCollection_DataMap_TopoDS_Shape_gp_Pnt_TopTools_ShapeMapHasher___iter__(self)
    __swig_destroy__ = _LocOpe.delete_NCollection_DataMap_TopoDS_Shape_gp_Pnt_TopTools_ShapeMapHasher
NCollection_DataMap_TopoDS_Shape_gp_Pnt_TopTools_ShapeMapHasher_swigregister = _LocOpe.NCollection_DataMap_TopoDS_Shape_gp_Pnt_TopTools_ShapeMapHasher_swigregister
NCollection_DataMap_TopoDS_Shape_gp_Pnt_TopTools_ShapeMapHasher_swigregister(NCollection_DataMap_TopoDS_Shape_gp_Pnt_TopTools_ShapeMapHasher)

class NCollection_DataMap_TopoDS_Shape_gp_Pnt_TopTools_ShapeMapHasher_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _LocOpe.new_NCollection_DataMap_TopoDS_Shape_gp_Pnt_TopTools_ShapeMapHasher_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _LocOpe.delete_NCollection_DataMap_TopoDS_Shape_gp_Pnt_TopTools_ShapeMapHasher_IteratorHelper

    def __next__(self):
        return _LocOpe.NCollection_DataMap_TopoDS_Shape_gp_Pnt_TopTools_ShapeMapHasher_IteratorHelper___next__(self)
NCollection_DataMap_TopoDS_Shape_gp_Pnt_TopTools_ShapeMapHasher_IteratorHelper_swigregister = _LocOpe.NCollection_DataMap_TopoDS_Shape_gp_Pnt_TopTools_ShapeMapHasher_IteratorHelper_swigregister
NCollection_DataMap_TopoDS_Shape_gp_Pnt_TopTools_ShapeMapHasher_IteratorHelper_swigregister(NCollection_DataMap_TopoDS_Shape_gp_Pnt_TopTools_ShapeMapHasher_IteratorHelper)


try:
	LocOpe_DataMapOfShapePnt = NCollection_DataMap_TopoDS_Shape_gp_Pnt_TopTools_ShapeMapHasher
except NameError:
	pass # does not exist, probably ignored

class LocOpe_SplitDrafts(object):
    """
    This  class  provides  a    tool to   realize  the
    following operations on a shape :
    - split a face of the shape with a wire,
    - put draft angle on both side of the wire.
    For each side, the draft angle may be different.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(LocOpe_SplitDrafts self) -> LocOpe_SplitDrafts
        __init__(LocOpe_SplitDrafts self, TopoDS_Shape S) -> LocOpe_SplitDrafts

        Creates the algoritm on the shape <S>.

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        this = _LocOpe.new_LocOpe_SplitDrafts(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(LocOpe_SplitDrafts self, TopoDS_Shape S)

        Initializes the algoritm with the shape <S>.

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _LocOpe.LocOpe_SplitDrafts_Init(self, *args)


    def Perform(self, *args):
        """
        Perform(LocOpe_SplitDrafts self, TopoDS_Face F, TopoDS_Wire W, gp_Dir Extractg, gp_Pln NPlg, Standard_Real const Angleg, gp_Dir Extractd, gp_Pln NPld, Standard_Real const Angled, Standard_Boolean const ModifyLeft, Standard_Boolean const ModifyRight)
        Perform(LocOpe_SplitDrafts self, TopoDS_Face F, TopoDS_Wire W, gp_Dir Extract, gp_Pln NPl, Standard_Real const Angle)

        Splits the face <F> of the former given shape with
        the  wire <W>.  The wire is  assumed to lie on the
        face.  Puts a draft angle  on the left part of the
        wire.   The draft    angle is   measured  with the
        direction  <Extract>.   <Npl> defines the  neutral
        plane (points belonging  to the neutral plane  are
        not modified). <Angle> is  the value of  the draft
        angle.

        :type F: OCC.wrapper.TopoDS.TopoDS_Face
        :type W: OCC.wrapper.TopoDS.TopoDS_Wire
        :type Extract: OCC.wrapper.gp.gp_Dir
        :type NPl: OCC.wrapper.gp.gp_Pln
        :type Angle: float

        """
        return _LocOpe.LocOpe_SplitDrafts_Perform(self, *args)


    def IsDone(self, *args):
        """
        IsDone(LocOpe_SplitDrafts self) -> Standard_Boolean

        Returns <Standard_True>  if the  modification  has
        been succesfully performed.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _LocOpe.LocOpe_SplitDrafts_IsDone(self, *args)


    def OriginalShape(self, *args):
        """
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _LocOpe.LocOpe_SplitDrafts_OriginalShape(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Shape(self, *args):
        """
        Returns the modified shape.

        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _LocOpe.LocOpe_SplitDrafts_Shape(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ShapesFromShape(self, *args):
        """
        Manages the descendant shapes.

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.TopTools.TopTools_ListOfShape

        """
        res = _LocOpe.LocOpe_SplitDrafts_ShapesFromShape(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _LocOpe.delete_LocOpe_SplitDrafts
LocOpe_SplitDrafts_swigregister = _LocOpe.LocOpe_SplitDrafts_swigregister
LocOpe_SplitDrafts_swigregister(LocOpe_SplitDrafts)

class LocOpe_Spliter(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(LocOpe_Spliter self) -> LocOpe_Spliter
        __init__(LocOpe_Spliter self, TopoDS_Shape S) -> LocOpe_Spliter

        Creates the algorithm on the shape <S>.

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        this = _LocOpe.new_LocOpe_Spliter(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(LocOpe_Spliter self, TopoDS_Shape S)

        Initializes the algorithm on the shape <S>.

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _LocOpe.LocOpe_Spliter_Init(self, *args)


    def Perform(self, *args):
        """
        Perform(LocOpe_Spliter self, Handle_LocOpe_WiresOnShape PW)

        :type PW: OCC.wrapper.LocOpe.Handle_LocOpe_WiresOnShape

        """
        return _LocOpe.LocOpe_Spliter_Perform(self, *args)


    def IsDone(self, *args):
        """
        IsDone(LocOpe_Spliter self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _LocOpe.LocOpe_Spliter_IsDone(self, *args)


    def ResultingShape(self, *args):
        """
        Returns the new shape

        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _LocOpe.LocOpe_Spliter_ResultingShape(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Shape(self, *args):
        """
        Returns the initial shape

        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _LocOpe.LocOpe_Spliter_Shape(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DirectLeft(self, *args):
        """
        Returns  the faces   which  are the  left of   the
        projected wires and which are

        :rtype: OCC.wrapper.TopTools.TopTools_ListOfShape

        """
        res = _LocOpe.LocOpe_Spliter_DirectLeft(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Left(self, *args):
        """
        Returns the faces of the "left" part on the shape.
        (It  is build   from  DirectLeft,  with  the faces
        connected to this set, and so on...).

        :rtype: OCC.wrapper.TopTools.TopTools_ListOfShape

        """
        res = _LocOpe.LocOpe_Spliter_Left(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DescendantShapes(self, *args):
        """
        Returns the list of descendant shapes of <S>.

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.TopTools.TopTools_ListOfShape

        """
        res = _LocOpe.LocOpe_Spliter_DescendantShapes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _LocOpe.delete_LocOpe_Spliter
LocOpe_Spliter_swigregister = _LocOpe.LocOpe_Spliter_swigregister
LocOpe_Spliter_swigregister(LocOpe_Spliter)

class LocOpe_Gluer(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(LocOpe_Gluer self) -> LocOpe_Gluer
        __init__(LocOpe_Gluer self, TopoDS_Shape Sbase, TopoDS_Shape Snew) -> LocOpe_Gluer

        :type Sbase: OCC.wrapper.TopoDS.TopoDS_Shape
        :type Snew: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        this = _LocOpe.new_LocOpe_Gluer(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(LocOpe_Gluer self, TopoDS_Shape Sbase, TopoDS_Shape Snew)

        :type Sbase: OCC.wrapper.TopoDS.TopoDS_Shape
        :type Snew: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _LocOpe.LocOpe_Gluer_Init(self, *args)


    def Bind(self, *args):
        """
        Bind(LocOpe_Gluer self, TopoDS_Face Fnew, TopoDS_Face Fbase)
        Bind(LocOpe_Gluer self, TopoDS_Edge Enew, TopoDS_Edge Ebase)

        :type Enew: OCC.wrapper.TopoDS.TopoDS_Edge
        :type Ebase: OCC.wrapper.TopoDS.TopoDS_Edge

        """
        return _LocOpe.LocOpe_Gluer_Bind(self, *args)


    def OpeType(self, *args):
        """
        OpeType(LocOpe_Gluer self) -> LocOpe_Operation

        :rtype: OCC.wrapper.LocOpe.LocOpe_Operation

        """
        return _LocOpe.LocOpe_Gluer_OpeType(self, *args)


    def Perform(self, *args):
        """Perform(LocOpe_Gluer self)"""
        return _LocOpe.LocOpe_Gluer_Perform(self, *args)


    def IsDone(self, *args):
        """
        IsDone(LocOpe_Gluer self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _LocOpe.LocOpe_Gluer_IsDone(self, *args)


    def ResultingShape(self, *args):
        """
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _LocOpe.LocOpe_Gluer_ResultingShape(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DescendantFaces(self, *args):
        """
        :type F: OCC.wrapper.TopoDS.TopoDS_Face
        :rtype: OCC.wrapper.TopTools.TopTools_ListOfShape

        """
        res = _LocOpe.LocOpe_Gluer_DescendantFaces(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def BasisShape(self, *args):
        """
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _LocOpe.LocOpe_Gluer_BasisShape(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def GluedShape(self, *args):
        """
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _LocOpe.LocOpe_Gluer_GluedShape(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Edges(self, *args):
        """
        :rtype: OCC.wrapper.TopTools.TopTools_ListOfShape

        """
        res = _LocOpe.LocOpe_Gluer_Edges(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def TgtEdges(self, *args):
        """
        :rtype: OCC.wrapper.TopTools.TopTools_ListOfShape

        """
        res = _LocOpe.LocOpe_Gluer_TgtEdges(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _LocOpe.delete_LocOpe_Gluer
LocOpe_Gluer_swigregister = _LocOpe.LocOpe_Gluer_swigregister
LocOpe_Gluer_swigregister(LocOpe_Gluer)

class LocOpe_FindEdges(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(LocOpe_FindEdges self) -> LocOpe_FindEdges
        __init__(LocOpe_FindEdges self, TopoDS_Shape FFrom, TopoDS_Shape FTo) -> LocOpe_FindEdges

        :type FFrom: OCC.wrapper.TopoDS.TopoDS_Shape
        :type FTo: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        this = _LocOpe.new_LocOpe_FindEdges(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Set(self, *args):
        """
        Set(LocOpe_FindEdges self, TopoDS_Shape FFrom, TopoDS_Shape FTo)

        :type FFrom: OCC.wrapper.TopoDS.TopoDS_Shape
        :type FTo: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _LocOpe.LocOpe_FindEdges_Set(self, *args)


    def InitIterator(self, *args):
        """InitIterator(LocOpe_FindEdges self)"""
        return _LocOpe.LocOpe_FindEdges_InitIterator(self, *args)


    def More(self, *args):
        """
        More(LocOpe_FindEdges self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _LocOpe.LocOpe_FindEdges_More(self, *args)


    def EdgeFrom(self, *args):
        """
        :rtype: OCC.wrapper.TopoDS.TopoDS_Edge

        """
        res = _LocOpe.LocOpe_FindEdges_EdgeFrom(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def EdgeTo(self, *args):
        """
        :rtype: OCC.wrapper.TopoDS.TopoDS_Edge

        """
        res = _LocOpe.LocOpe_FindEdges_EdgeTo(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Next(self, *args):
        """Next(LocOpe_FindEdges self)"""
        return _LocOpe.LocOpe_FindEdges_Next(self, *args)

    __swig_destroy__ = _LocOpe.delete_LocOpe_FindEdges
LocOpe_FindEdges_swigregister = _LocOpe.LocOpe_FindEdges_swigregister
LocOpe_FindEdges_swigregister(LocOpe_FindEdges)




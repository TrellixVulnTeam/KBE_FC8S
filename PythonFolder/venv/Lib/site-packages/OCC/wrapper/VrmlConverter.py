# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_VrmlConverter')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_VrmlConverter')
    _VrmlConverter = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_VrmlConverter', [dirname(__file__)])
        except ImportError:
            import _VrmlConverter
            return _VrmlConverter
        try:
            _mod = imp.load_module('_VrmlConverter', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _VrmlConverter = swig_import_helper()
    del swig_import_helper
else:
    import _VrmlConverter
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


class SwigPyIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _VrmlConverter.delete_SwigPyIterator

    def value(self):
        return _VrmlConverter.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _VrmlConverter.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _VrmlConverter.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _VrmlConverter.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _VrmlConverter.SwigPyIterator_equal(self, x)

    def copy(self):
        return _VrmlConverter.SwigPyIterator_copy(self)

    def next(self):
        return _VrmlConverter.SwigPyIterator_next(self)

    def __next__(self):
        return _VrmlConverter.SwigPyIterator___next__(self)

    def previous(self):
        return _VrmlConverter.SwigPyIterator_previous(self)

    def advance(self, n):
        return _VrmlConverter.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _VrmlConverter.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _VrmlConverter.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _VrmlConverter.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _VrmlConverter.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _VrmlConverter.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _VrmlConverter.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self
SwigPyIterator_swigregister = _VrmlConverter.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

class NCollection_CellFilter_InspectorXYZ(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _VrmlConverter.NCollection_CellFilter_InspectorXYZ_Dimension
    Coord = staticmethod(_VrmlConverter.NCollection_CellFilter_InspectorXYZ_Coord)

    def Shift(self, thePnt, theTol):
        return _VrmlConverter.NCollection_CellFilter_InspectorXYZ_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _VrmlConverter.new_NCollection_CellFilter_InspectorXYZ()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _VrmlConverter.delete_NCollection_CellFilter_InspectorXYZ
NCollection_CellFilter_InspectorXYZ_swigregister = _VrmlConverter.NCollection_CellFilter_InspectorXYZ_swigregister
NCollection_CellFilter_InspectorXYZ_swigregister(NCollection_CellFilter_InspectorXYZ)

def NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt):
    return _VrmlConverter.NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt)
NCollection_CellFilter_InspectorXYZ_Coord = _VrmlConverter.NCollection_CellFilter_InspectorXYZ_Coord

class NCollection_CellFilter_InspectorXY(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _VrmlConverter.NCollection_CellFilter_InspectorXY_Dimension
    Coord = staticmethod(_VrmlConverter.NCollection_CellFilter_InspectorXY_Coord)

    def Shift(self, thePnt, theTol):
        return _VrmlConverter.NCollection_CellFilter_InspectorXY_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _VrmlConverter.new_NCollection_CellFilter_InspectorXY()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _VrmlConverter.delete_NCollection_CellFilter_InspectorXY
NCollection_CellFilter_InspectorXY_swigregister = _VrmlConverter.NCollection_CellFilter_InspectorXY_swigregister
NCollection_CellFilter_InspectorXY_swigregister(NCollection_CellFilter_InspectorXY)

def NCollection_CellFilter_InspectorXY_Coord(i, thePnt):
    return _VrmlConverter.NCollection_CellFilter_InspectorXY_Coord(i, thePnt)
NCollection_CellFilter_InspectorXY_Coord = _VrmlConverter.NCollection_CellFilter_InspectorXY_Coord


def ptr_to_number(item):
    return _VrmlConverter.ptr_to_number(item)
ptr_to_number = _VrmlConverter.ptr_to_number

def HashCode(*args):
    return _VrmlConverter.HashCode(*args)
HashCode = _VrmlConverter.HashCode

def ptr_equal(a, b):
    return _VrmlConverter.ptr_equal(a, b)
ptr_equal = _VrmlConverter.ptr_equal
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopoDS
else:
    import TopoDS
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import NCollection
else:
    import NCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Standard
else:
    import Standard
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopAbs
else:
    import TopAbs
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Message
else:
    import Message
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColStd
else:
    import TColStd
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TCollection
else:
    import TCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopLoc
else:
    import TopLoc
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import gp
else:
    import gp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import HLRAlgo
else:
    import HLRAlgo
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColgp
else:
    import TColgp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Poly
else:
    import Poly
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TShort
else:
    import TShort
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Aspect
else:
    import Aspect
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Quantity
else:
    import Quantity
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Adaptor3d
else:
    import Adaptor3d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import GeomAbs
else:
    import GeomAbs
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Adaptor2d
else:
    import Adaptor2d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Geom2d
else:
    import Geom2d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Geom
else:
    import Geom
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import math
else:
    import math
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import BRepAdaptor
else:
    import BRepAdaptor
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Geom2dAdaptor
else:
    import Geom2dAdaptor
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import GeomAdaptor
else:
    import GeomAdaptor
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopTools
else:
    import TopTools
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Bnd
else:
    import Bnd
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Vrml
else:
    import Vrml
del _swig_python_version_info
VrmlConverter_NoCamera = _VrmlConverter.VrmlConverter_NoCamera
VrmlConverter_PerspectiveCamera = _VrmlConverter.VrmlConverter_PerspectiveCamera
VrmlConverter_OrthographicCamera = _VrmlConverter.VrmlConverter_OrthographicCamera
VrmlConverter_NoLight = _VrmlConverter.VrmlConverter_NoLight
VrmlConverter_DirectionLight = _VrmlConverter.VrmlConverter_DirectionLight
VrmlConverter_PointLight = _VrmlConverter.VrmlConverter_PointLight
VrmlConverter_SpotLight = _VrmlConverter.VrmlConverter_SpotLight
class VrmlConverter_LineAspect(Standard.Standard_Transient):
    """
    qualifies the aspect properties for
    the VRML conversation of a Curve and  a  DeflectionCurve .
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_VrmlConverter_LineAspect
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_VrmlConverter_LineAspect(self) 
            return h


    def __init__(self, *args):
        """
        __init__(VrmlConverter_LineAspect self) -> VrmlConverter_LineAspect
        __init__(VrmlConverter_LineAspect self, Handle_Vrml_Material aMaterial, Standard_Boolean const OnOff) -> VrmlConverter_LineAspect

        :type aMaterial: OCC.wrapper.Vrml.Handle_Vrml_Material
        :type OnOff: bool

        """
        this = _VrmlConverter.new_VrmlConverter_LineAspect(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def SetMaterial(self, *args):
        """
        SetMaterial(VrmlConverter_LineAspect self, Handle_Vrml_Material aMaterial)

        :type aMaterial: OCC.wrapper.Vrml.Handle_Vrml_Material

        """
        return _VrmlConverter.VrmlConverter_LineAspect_SetMaterial(self, *args)


    def Material(self, *args):
        """
        Material(VrmlConverter_LineAspect self) -> Handle_Vrml_Material

        :rtype: OCC.wrapper.Vrml.Handle_Vrml_Material

        """
        return _VrmlConverter.VrmlConverter_LineAspect_Material(self, *args)


    def SetHasMaterial(self, *args):
        """
        SetHasMaterial(VrmlConverter_LineAspect self, Standard_Boolean const OnOff)

        defines the necessary of writing  own  Material from Vrml into  output  OStream.
        By default False  -  the material is not writing into OStream,
        True  -  the material is writing.

        :type OnOff: bool

        """
        return _VrmlConverter.VrmlConverter_LineAspect_SetHasMaterial(self, *args)


    def HasMaterial(self, *args):
        """
        HasMaterial(VrmlConverter_LineAspect self) -> Standard_Boolean

        returns True if the  materials is  writing into OStream.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _VrmlConverter.VrmlConverter_LineAspect_HasMaterial(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _VrmlConverter.VrmlConverter_LineAspect_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _VrmlConverter.VrmlConverter_LineAspect_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _VrmlConverter.VrmlConverter_LineAspect_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _VrmlConverter.delete_VrmlConverter_LineAspect
VrmlConverter_LineAspect_swigregister = _VrmlConverter.VrmlConverter_LineAspect_swigregister
VrmlConverter_LineAspect_swigregister(VrmlConverter_LineAspect)

def VrmlConverter_LineAspect_get_type_name(*args):
    """
    VrmlConverter_LineAspect_get_type_name() -> char const *

    :rtype: const char *

    """
    return _VrmlConverter.VrmlConverter_LineAspect_get_type_name(*args)

def VrmlConverter_LineAspect_get_type_descriptor(*args):
    """
    VrmlConverter_LineAspect_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _VrmlConverter.VrmlConverter_LineAspect_get_type_descriptor(*args)

class VrmlConverter_ShadingAspect(Standard.Standard_Transient):
    """
    qualifies the aspect properties for
    the VRML conversation of ShadedShape .
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_VrmlConverter_ShadingAspect
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_VrmlConverter_ShadingAspect(self) 
            return h


    def __init__(self, *args):
        """
        __init__(VrmlConverter_ShadingAspect self) -> VrmlConverter_ShadingAspect

        create a default ShadingAspect.


        """
        this = _VrmlConverter.new_VrmlConverter_ShadingAspect(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def SetFrontMaterial(self, *args):
        """
        SetFrontMaterial(VrmlConverter_ShadingAspect self, Handle_Vrml_Material aMaterial)

        :type aMaterial: OCC.wrapper.Vrml.Handle_Vrml_Material

        """
        return _VrmlConverter.VrmlConverter_ShadingAspect_SetFrontMaterial(self, *args)


    def FrontMaterial(self, *args):
        """
        FrontMaterial(VrmlConverter_ShadingAspect self) -> Handle_Vrml_Material

        :rtype: OCC.wrapper.Vrml.Handle_Vrml_Material

        """
        return _VrmlConverter.VrmlConverter_ShadingAspect_FrontMaterial(self, *args)


    def SetShapeHints(self, *args):
        """
        SetShapeHints(VrmlConverter_ShadingAspect self, Vrml_ShapeHints aShapeHints)

        :type aShapeHints: OCC.wrapper.Vrml.Vrml_ShapeHints

        """
        return _VrmlConverter.VrmlConverter_ShadingAspect_SetShapeHints(self, *args)


    def ShapeHints(self, *args):
        """
        ShapeHints(VrmlConverter_ShadingAspect self) -> Vrml_ShapeHints

        :rtype: OCC.wrapper.Vrml.Vrml_ShapeHints

        """
        return _VrmlConverter.VrmlConverter_ShadingAspect_ShapeHints(self, *args)


    def SetHasNormals(self, *args):
        """
        SetHasNormals(VrmlConverter_ShadingAspect self, Standard_Boolean const OnOff)

        defines necessary of  a  calculation  of  normals for  ShadedShape  to  more
        accurately  display  curved  surfaces,  pacticularly  when  smoooth  or  phong
        shading  is  used  in  VRML  viewer.
        By default False  -  the normals are not calculated,
        True  -  the normals are calculated.
        Warning: If  normals  are  calculated  the  resulting  VRML  file  will
        be  substantially  lager.

        :type OnOff: bool

        """
        return _VrmlConverter.VrmlConverter_ShadingAspect_SetHasNormals(self, *args)


    def HasNormals(self, *args):
        """
        HasNormals(VrmlConverter_ShadingAspect self) -> Standard_Boolean

        returns True if the normals are calculating

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _VrmlConverter.VrmlConverter_ShadingAspect_HasNormals(self, *args)


    def SetHasMaterial(self, *args):
        """
        SetHasMaterial(VrmlConverter_ShadingAspect self, Standard_Boolean const OnOff)

        defines necessary of writing  Material from Vrml into  output  OStream.
        By default False  -  the material is not writing into OStream,
        True  -  the material is writing.

        :type OnOff: bool

        """
        return _VrmlConverter.VrmlConverter_ShadingAspect_SetHasMaterial(self, *args)


    def HasMaterial(self, *args):
        """
        HasMaterial(VrmlConverter_ShadingAspect self) -> Standard_Boolean

        returns True if the  materials is  writing into OStream.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _VrmlConverter.VrmlConverter_ShadingAspect_HasMaterial(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _VrmlConverter.VrmlConverter_ShadingAspect_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _VrmlConverter.VrmlConverter_ShadingAspect_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _VrmlConverter.VrmlConverter_ShadingAspect_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _VrmlConverter.delete_VrmlConverter_ShadingAspect
VrmlConverter_ShadingAspect_swigregister = _VrmlConverter.VrmlConverter_ShadingAspect_swigregister
VrmlConverter_ShadingAspect_swigregister(VrmlConverter_ShadingAspect)

def VrmlConverter_ShadingAspect_get_type_name(*args):
    """
    VrmlConverter_ShadingAspect_get_type_name() -> char const *

    :rtype: const char *

    """
    return _VrmlConverter.VrmlConverter_ShadingAspect_get_type_name(*args)

def VrmlConverter_ShadingAspect_get_type_descriptor(*args):
    """
    VrmlConverter_ShadingAspect_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _VrmlConverter.VrmlConverter_ShadingAspect_get_type_descriptor(*args)

class VrmlConverter_Projector(Standard.Standard_Transient):
    """
    defines projector  and calculates properties of cameras and lights from Vrml
    ( OrthograpicCamera, PerspectiveCamera, DirectionalLight, PointLight, SpotLight
    and  MatrixTransform  )  to display all scene  shapes  with  arbitrary locations
    for requested the Projection Vector,  High Point Direction and the Focus
    and adds them ( method Add ) to anOSream.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_VrmlConverter_Projector
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_VrmlConverter_Projector(self) 
            return h


    def __init__(self, *args):
        """
        __init__(VrmlConverter_Projector self, NCollection_Array1_TopoDS_Shape Shapes, Standard_Real const Focus, Standard_Real const DX, Standard_Real const DY, Standard_Real const DZ, Standard_Real const XUp, Standard_Real const YUp, Standard_Real const ZUp, VrmlConverter_TypeOfCamera const Camera=VrmlConverter_NoCamera, VrmlConverter_TypeOfLight const Light=VrmlConverter_NoLight) -> VrmlConverter_Projector

        :type Shapes: OCC.wrapper.TopTools.TopTools_Array1OfShape
        :type Focus: float
        :type DX: float
        :type DY: float
        :type DZ: float
        :type XUp: float
        :type YUp: float
        :type ZUp: float
        :type Camera: OCC.wrapper.VrmlConverter.VrmlConverter_TypeOfCamera
        :type Light: OCC.wrapper.VrmlConverter.VrmlConverter_TypeOfLight

        """
        this = _VrmlConverter.new_VrmlConverter_Projector(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def SetCamera(self, *args):
        """
        SetCamera(VrmlConverter_Projector self, VrmlConverter_TypeOfCamera const aCamera)

        :type aCamera: OCC.wrapper.VrmlConverter.VrmlConverter_TypeOfCamera

        """
        return _VrmlConverter.VrmlConverter_Projector_SetCamera(self, *args)


    def Camera(self, *args):
        """
        Camera(VrmlConverter_Projector self) -> VrmlConverter_TypeOfCamera

        :rtype: OCC.wrapper.VrmlConverter.VrmlConverter_TypeOfCamera

        """
        return _VrmlConverter.VrmlConverter_Projector_Camera(self, *args)


    def SetLight(self, *args):
        """
        SetLight(VrmlConverter_Projector self, VrmlConverter_TypeOfLight const aLight)

        :type aLight: OCC.wrapper.VrmlConverter.VrmlConverter_TypeOfLight

        """
        return _VrmlConverter.VrmlConverter_Projector_SetLight(self, *args)


    def Light(self, *args):
        """
        Light(VrmlConverter_Projector self) -> VrmlConverter_TypeOfLight

        :rtype: OCC.wrapper.VrmlConverter.VrmlConverter_TypeOfLight

        """
        return _VrmlConverter.VrmlConverter_Projector_Light(self, *args)


    def Add(self, *args):
        """
        Add(VrmlConverter_Projector self, Standard_OStream & anOStream)

        Adds  into anOStream  if  they  are  defined in  Create.
        PerspectiveCamera,
        OrthographicCamera,
        DirectionLight,
        PointLight,
        SpotLight
        with  MatrixTransform  from VrmlConverter;

        :type anOStream: OCC.wrapper.Standard.Standard_OStream

        """
        return _VrmlConverter.VrmlConverter_Projector_Add(self, *args)


    def Projector(self, *args):
        """
        Projector(VrmlConverter_Projector self) -> HLRAlgo_Projector

        :rtype: OCC.wrapper.HLRAlgo.HLRAlgo_Projector

        """
        return _VrmlConverter.VrmlConverter_Projector_Projector(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _VrmlConverter.VrmlConverter_Projector_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _VrmlConverter.VrmlConverter_Projector_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _VrmlConverter.VrmlConverter_Projector_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _VrmlConverter.delete_VrmlConverter_Projector
VrmlConverter_Projector_swigregister = _VrmlConverter.VrmlConverter_Projector_swigregister
VrmlConverter_Projector_swigregister(VrmlConverter_Projector)

def VrmlConverter_Projector_get_type_name(*args):
    """
    VrmlConverter_Projector_get_type_name() -> char const *

    :rtype: const char *

    """
    return _VrmlConverter.VrmlConverter_Projector_get_type_name(*args)

def VrmlConverter_Projector_get_type_descriptor(*args):
    """
    VrmlConverter_Projector_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _VrmlConverter.VrmlConverter_Projector_get_type_descriptor(*args)

class VrmlConverter_IsoAspect(VrmlConverter_LineAspect):
    """
    qualifies the aspect properties for
    the VRML conversation of iso curves .
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_VrmlConverter_IsoAspect
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_VrmlConverter_IsoAspect(self) 
            return h


    def __init__(self, *args):
        """
        __init__(VrmlConverter_IsoAspect self) -> VrmlConverter_IsoAspect
        __init__(VrmlConverter_IsoAspect self, Handle_Vrml_Material aMaterial, Standard_Boolean const OnOff, Standard_Integer const aNumber) -> VrmlConverter_IsoAspect

        :type aMaterial: OCC.wrapper.Vrml.Handle_Vrml_Material
        :type OnOff: bool
        :type aNumber: int

        """
        this = _VrmlConverter.new_VrmlConverter_IsoAspect(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def SetNumber(self, *args):
        """
        SetNumber(VrmlConverter_IsoAspect self, Standard_Integer const aNumber)

        :type aNumber: int

        """
        return _VrmlConverter.VrmlConverter_IsoAspect_SetNumber(self, *args)


    def Number(self, *args):
        """
        Number(VrmlConverter_IsoAspect self) -> Standard_Integer

        returns the number of U or V isoparametric curves drawn for a
        single face.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _VrmlConverter.VrmlConverter_IsoAspect_Number(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _VrmlConverter.VrmlConverter_IsoAspect_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _VrmlConverter.VrmlConverter_IsoAspect_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _VrmlConverter.VrmlConverter_IsoAspect_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _VrmlConverter.delete_VrmlConverter_IsoAspect
VrmlConverter_IsoAspect_swigregister = _VrmlConverter.VrmlConverter_IsoAspect_swigregister
VrmlConverter_IsoAspect_swigregister(VrmlConverter_IsoAspect)

def VrmlConverter_IsoAspect_get_type_name(*args):
    """
    VrmlConverter_IsoAspect_get_type_name() -> char const *

    :rtype: const char *

    """
    return _VrmlConverter.VrmlConverter_IsoAspect_get_type_name(*args)

def VrmlConverter_IsoAspect_get_type_descriptor(*args):
    """
    VrmlConverter_IsoAspect_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _VrmlConverter.VrmlConverter_IsoAspect_get_type_descriptor(*args)

class Handle_VrmlConverter_LineAspect(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_VrmlConverter_LineAspect self)

        Nullify the handle


        """
        return _VrmlConverter.Handle_VrmlConverter_LineAspect_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_VrmlConverter_LineAspect self) -> bool

        Check for being null

        :rtype: bool

        """
        return _VrmlConverter.Handle_VrmlConverter_LineAspect_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_VrmlConverter_LineAspect self, VrmlConverter_LineAspect thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _VrmlConverter.Handle_VrmlConverter_LineAspect_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_VrmlConverter_LineAspect self, Handle_VrmlConverter_LineAspect theHandle) -> Handle_VrmlConverter_LineAspect
        assign(Handle_VrmlConverter_LineAspect self, VrmlConverter_LineAspect thePtr) -> Handle_VrmlConverter_LineAspect
        assign(Handle_VrmlConverter_LineAspect self, Handle_VrmlConverter_LineAspect theHandle) -> Handle_VrmlConverter_LineAspect

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _VrmlConverter.Handle_VrmlConverter_LineAspect_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_VrmlConverter_LineAspect self) -> VrmlConverter_LineAspect

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _VrmlConverter.Handle_VrmlConverter_LineAspect_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_VrmlConverter_LineAspect self) -> VrmlConverter_LineAspect

        Member access operator (note non-const)

        :rtype: T *

        """
        return _VrmlConverter.Handle_VrmlConverter_LineAspect___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_VrmlConverter_LineAspect self) -> VrmlConverter_LineAspect

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _VrmlConverter.Handle_VrmlConverter_LineAspect___ref__(self, *args)


    def __hash__(self):
        return _VrmlConverter.Handle_VrmlConverter_LineAspect___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _VrmlConverter.Handle_VrmlConverter_LineAspect___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _VrmlConverter.new_Handle_VrmlConverter_LineAspect(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_VrmlConverter.Handle_VrmlConverter_LineAspect_DownCast)
    __swig_destroy__ = _VrmlConverter.delete_Handle_VrmlConverter_LineAspect

    def SetMaterial(self, *args):
        """
        SetMaterial(Handle_VrmlConverter_LineAspect self, Handle_Vrml_Material aMaterial)

        :type aMaterial: OCC.wrapper.Vrml.Handle_Vrml_Material

        """
        return _VrmlConverter.Handle_VrmlConverter_LineAspect_SetMaterial(self, *args)


    def Material(self, *args):
        """
        Material(Handle_VrmlConverter_LineAspect self) -> Handle_Vrml_Material

        :rtype: OCC.wrapper.Vrml.Handle_Vrml_Material

        """
        return _VrmlConverter.Handle_VrmlConverter_LineAspect_Material(self, *args)


    def SetHasMaterial(self, *args):
        """
        SetHasMaterial(Handle_VrmlConverter_LineAspect self, Standard_Boolean const OnOff)

        defines the necessary of writing  own  Material from Vrml into  output  OStream.
        By default False  -  the material is not writing into OStream,
        True  -  the material is writing.

        :type OnOff: bool

        """
        return _VrmlConverter.Handle_VrmlConverter_LineAspect_SetHasMaterial(self, *args)


    def HasMaterial(self, *args):
        """
        HasMaterial(Handle_VrmlConverter_LineAspect self) -> Standard_Boolean

        returns True if the  materials is  writing into OStream.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _VrmlConverter.Handle_VrmlConverter_LineAspect_HasMaterial(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_VrmlConverter_LineAspect self) -> char const *

        :rtype: const char *

        """
        return _VrmlConverter.Handle_VrmlConverter_LineAspect_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _VrmlConverter.Handle_VrmlConverter_LineAspect_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _VrmlConverter.Handle_VrmlConverter_LineAspect_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_VrmlConverter_LineAspect self)

        Memory deallocator for transient classes


        """
        return _VrmlConverter.Handle_VrmlConverter_LineAspect_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_VrmlConverter_LineAspect self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_VrmlConverter_LineAspect self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _VrmlConverter.Handle_VrmlConverter_LineAspect_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_VrmlConverter_LineAspect self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_VrmlConverter_LineAspect self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _VrmlConverter.Handle_VrmlConverter_LineAspect_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_VrmlConverter_LineAspect self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _VrmlConverter.Handle_VrmlConverter_LineAspect_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_VrmlConverter_LineAspect self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _VrmlConverter.Handle_VrmlConverter_LineAspect_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_VrmlConverter_LineAspect self)

        Increments the reference counter of this object


        """
        return _VrmlConverter.Handle_VrmlConverter_LineAspect_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_VrmlConverter_LineAspect self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _VrmlConverter.Handle_VrmlConverter_LineAspect_DecrementRefCounter(self, *args)

Handle_VrmlConverter_LineAspect_swigregister = _VrmlConverter.Handle_VrmlConverter_LineAspect_swigregister
Handle_VrmlConverter_LineAspect_swigregister(Handle_VrmlConverter_LineAspect)

def Handle_VrmlConverter_LineAspect_DownCast(thing):
    return _VrmlConverter.Handle_VrmlConverter_LineAspect_DownCast(thing)
Handle_VrmlConverter_LineAspect_DownCast = _VrmlConverter.Handle_VrmlConverter_LineAspect_DownCast

class VrmlConverter_WFShape(object):
    """
    WFShape - computes the wireframe presentation of
    compound set  of  faces,  edges  and vertices by
    displaying a given  number of U and/or V isoparametric
    curves converts this one into VRML objects and writes (adds)
    them into anOStream.
    All requested properties of the representation are
    specify in aDrawer.
    This kind of the presentation is converted into
    IndexedLineSet and PointSet  ( VRML ).
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Add(*args):
        """
        Add(Standard_OStream & anOStream, TopoDS_Shape aShape, Handle_VrmlConverter_Drawer aDrawer)

        :type anOStream: OCC.wrapper.Standard.Standard_OStream
        :type aShape: OCC.wrapper.TopoDS.TopoDS_Shape
        :type aDrawer: OCC.wrapper.VrmlConverter.Handle_VrmlConverter_Drawer

        """
        return _VrmlConverter.VrmlConverter_WFShape_Add(*args)

    Add = staticmethod(Add)

    def __init__(self):
        """
        WFShape - computes the wireframe presentation of
        compound set  of  faces,  edges  and vertices by
        displaying a given  number of U and/or V isoparametric
        curves converts this one into VRML objects and writes (adds)
        them into anOStream.
        All requested properties of the representation are
        specify in aDrawer.
        This kind of the presentation is converted into
        IndexedLineSet and PointSet  ( VRML ).
        """
        this = _VrmlConverter.new_VrmlConverter_WFShape()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _VrmlConverter.delete_VrmlConverter_WFShape
VrmlConverter_WFShape_swigregister = _VrmlConverter.VrmlConverter_WFShape_swigregister
VrmlConverter_WFShape_swigregister(VrmlConverter_WFShape)

def VrmlConverter_WFShape_Add(*args):
    """
    VrmlConverter_WFShape_Add(Standard_OStream & anOStream, TopoDS_Shape aShape, Handle_VrmlConverter_Drawer aDrawer)

    :type anOStream: OCC.wrapper.Standard.Standard_OStream
    :type aShape: OCC.wrapper.TopoDS.TopoDS_Shape
    :type aDrawer: OCC.wrapper.VrmlConverter.Handle_VrmlConverter_Drawer

    """
    return _VrmlConverter.VrmlConverter_WFShape_Add(*args)

class Handle_VrmlConverter_Projector(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_VrmlConverter_Projector self)

        Nullify the handle


        """
        return _VrmlConverter.Handle_VrmlConverter_Projector_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_VrmlConverter_Projector self) -> bool

        Check for being null

        :rtype: bool

        """
        return _VrmlConverter.Handle_VrmlConverter_Projector_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_VrmlConverter_Projector self, VrmlConverter_Projector thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _VrmlConverter.Handle_VrmlConverter_Projector_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_VrmlConverter_Projector self, Handle_VrmlConverter_Projector theHandle) -> Handle_VrmlConverter_Projector
        assign(Handle_VrmlConverter_Projector self, VrmlConverter_Projector thePtr) -> Handle_VrmlConverter_Projector
        assign(Handle_VrmlConverter_Projector self, Handle_VrmlConverter_Projector theHandle) -> Handle_VrmlConverter_Projector

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _VrmlConverter.Handle_VrmlConverter_Projector_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_VrmlConverter_Projector self) -> VrmlConverter_Projector

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _VrmlConverter.Handle_VrmlConverter_Projector_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_VrmlConverter_Projector self) -> VrmlConverter_Projector

        Member access operator (note non-const)

        :rtype: T *

        """
        return _VrmlConverter.Handle_VrmlConverter_Projector___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_VrmlConverter_Projector self) -> VrmlConverter_Projector

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _VrmlConverter.Handle_VrmlConverter_Projector___ref__(self, *args)


    def __hash__(self):
        return _VrmlConverter.Handle_VrmlConverter_Projector___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _VrmlConverter.Handle_VrmlConverter_Projector___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _VrmlConverter.new_Handle_VrmlConverter_Projector(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_VrmlConverter.Handle_VrmlConverter_Projector_DownCast)
    __swig_destroy__ = _VrmlConverter.delete_Handle_VrmlConverter_Projector

    def SetCamera(self, *args):
        """
        SetCamera(Handle_VrmlConverter_Projector self, VrmlConverter_TypeOfCamera const aCamera)

        :type aCamera: OCC.wrapper.VrmlConverter.VrmlConverter_TypeOfCamera

        """
        return _VrmlConverter.Handle_VrmlConverter_Projector_SetCamera(self, *args)


    def Camera(self, *args):
        """
        Camera(Handle_VrmlConverter_Projector self) -> VrmlConverter_TypeOfCamera

        :rtype: OCC.wrapper.VrmlConverter.VrmlConverter_TypeOfCamera

        """
        return _VrmlConverter.Handle_VrmlConverter_Projector_Camera(self, *args)


    def SetLight(self, *args):
        """
        SetLight(Handle_VrmlConverter_Projector self, VrmlConverter_TypeOfLight const aLight)

        :type aLight: OCC.wrapper.VrmlConverter.VrmlConverter_TypeOfLight

        """
        return _VrmlConverter.Handle_VrmlConverter_Projector_SetLight(self, *args)


    def Light(self, *args):
        """
        Light(Handle_VrmlConverter_Projector self) -> VrmlConverter_TypeOfLight

        :rtype: OCC.wrapper.VrmlConverter.VrmlConverter_TypeOfLight

        """
        return _VrmlConverter.Handle_VrmlConverter_Projector_Light(self, *args)


    def Add(self, *args):
        """
        Add(Handle_VrmlConverter_Projector self, Standard_OStream & anOStream)

        Adds  into anOStream  if  they  are  defined in  Create.
        PerspectiveCamera,
        OrthographicCamera,
        DirectionLight,
        PointLight,
        SpotLight
        with  MatrixTransform  from VrmlConverter;

        :type anOStream: OCC.wrapper.Standard.Standard_OStream

        """
        return _VrmlConverter.Handle_VrmlConverter_Projector_Add(self, *args)


    def Projector(self, *args):
        """
        Projector(Handle_VrmlConverter_Projector self) -> HLRAlgo_Projector

        :rtype: OCC.wrapper.HLRAlgo.HLRAlgo_Projector

        """
        return _VrmlConverter.Handle_VrmlConverter_Projector_Projector(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_VrmlConverter_Projector self) -> char const *

        :rtype: const char *

        """
        return _VrmlConverter.Handle_VrmlConverter_Projector_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _VrmlConverter.Handle_VrmlConverter_Projector_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _VrmlConverter.Handle_VrmlConverter_Projector_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_VrmlConverter_Projector self)

        Memory deallocator for transient classes


        """
        return _VrmlConverter.Handle_VrmlConverter_Projector_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_VrmlConverter_Projector self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_VrmlConverter_Projector self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _VrmlConverter.Handle_VrmlConverter_Projector_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_VrmlConverter_Projector self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_VrmlConverter_Projector self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _VrmlConverter.Handle_VrmlConverter_Projector_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_VrmlConverter_Projector self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _VrmlConverter.Handle_VrmlConverter_Projector_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_VrmlConverter_Projector self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _VrmlConverter.Handle_VrmlConverter_Projector_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_VrmlConverter_Projector self)

        Increments the reference counter of this object


        """
        return _VrmlConverter.Handle_VrmlConverter_Projector_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_VrmlConverter_Projector self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _VrmlConverter.Handle_VrmlConverter_Projector_DecrementRefCounter(self, *args)

Handle_VrmlConverter_Projector_swigregister = _VrmlConverter.Handle_VrmlConverter_Projector_swigregister
Handle_VrmlConverter_Projector_swigregister(Handle_VrmlConverter_Projector)

def Handle_VrmlConverter_Projector_DownCast(thing):
    return _VrmlConverter.Handle_VrmlConverter_Projector_DownCast(thing)
Handle_VrmlConverter_Projector_DownCast = _VrmlConverter.Handle_VrmlConverter_Projector_DownCast

class VrmlConverter_ShadedShape(object):
    """
    ShadedShape - computes  the  shading presentation of shapes
    by triangulation algorithms, converts this one into VRML objects
    and writes (adds) into anOStream.
    All requested properties of the representation including
    the maximal chordial deviation  are specify in aDrawer.
    This  kind  of  the  presentation  is  converted  into
    IndexedFaceSet ( VRML ).
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Add(*args):
        """
        Add(Standard_OStream & anOStream, TopoDS_Shape aShape, Handle_VrmlConverter_Drawer aDrawer)

        :type anOStream: OCC.wrapper.Standard.Standard_OStream
        :type aShape: OCC.wrapper.TopoDS.TopoDS_Shape
        :type aDrawer: OCC.wrapper.VrmlConverter.Handle_VrmlConverter_Drawer

        """
        return _VrmlConverter.VrmlConverter_ShadedShape_Add(*args)

    Add = staticmethod(Add)

    def ComputeNormal(*args):
        """
        ComputeNormal(TopoDS_Face aFace, Poly_Connect pc, NCollection_Array1_gp_Dir Nor)

        :type aFace: OCC.wrapper.TopoDS.TopoDS_Face
        :type pc: OCC.wrapper.Poly.Poly_Connect
        :type Nor: OCC.wrapper.TColgp.TColgp_Array1OfDir

        """
        return _VrmlConverter.VrmlConverter_ShadedShape_ComputeNormal(*args)

    ComputeNormal = staticmethod(ComputeNormal)

    def __init__(self):
        """
        ShadedShape - computes  the  shading presentation of shapes
        by triangulation algorithms, converts this one into VRML objects
        and writes (adds) into anOStream.
        All requested properties of the representation including
        the maximal chordial deviation  are specify in aDrawer.
        This  kind  of  the  presentation  is  converted  into
        IndexedFaceSet ( VRML ).
        """
        this = _VrmlConverter.new_VrmlConverter_ShadedShape()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _VrmlConverter.delete_VrmlConverter_ShadedShape
VrmlConverter_ShadedShape_swigregister = _VrmlConverter.VrmlConverter_ShadedShape_swigregister
VrmlConverter_ShadedShape_swigregister(VrmlConverter_ShadedShape)

def VrmlConverter_ShadedShape_Add(*args):
    """
    VrmlConverter_ShadedShape_Add(Standard_OStream & anOStream, TopoDS_Shape aShape, Handle_VrmlConverter_Drawer aDrawer)

    :type anOStream: OCC.wrapper.Standard.Standard_OStream
    :type aShape: OCC.wrapper.TopoDS.TopoDS_Shape
    :type aDrawer: OCC.wrapper.VrmlConverter.Handle_VrmlConverter_Drawer

    """
    return _VrmlConverter.VrmlConverter_ShadedShape_Add(*args)

def VrmlConverter_ShadedShape_ComputeNormal(*args):
    """
    VrmlConverter_ShadedShape_ComputeNormal(TopoDS_Face aFace, Poly_Connect pc, NCollection_Array1_gp_Dir Nor)

    :type aFace: OCC.wrapper.TopoDS.TopoDS_Face
    :type pc: OCC.wrapper.Poly.Poly_Connect
    :type Nor: OCC.wrapper.TColgp.TColgp_Array1OfDir

    """
    return _VrmlConverter.VrmlConverter_ShadedShape_ComputeNormal(*args)

class VrmlConverter_WFDeflectionRestrictedFace(object):
    """
    WFDeflectionRestrictedFace    -    computes    the
    wireframe   presentation   of  faces       with
    restrictions by  displaying  a given  number of  U
    and/or  V  isoparametric  curves,  converts his
    into VRML objects   and writes (adds) them  into
    anOStream.    All   requested properties  of the
    representation  are  specify in  aDrawer of Drawer
    class (Prs3d).    This kind  of the presentation
    is     converted       into   IndexedFaceSet   and
    IndexedLineSet ( VRML ).
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def AddUIso(*args):
        """
        AddUIso(Standard_OStream & anOStream, Handle_BRepAdaptor_HSurface aFace, Handle_VrmlConverter_Drawer aDrawer)

        :type anOStream: OCC.wrapper.Standard.Standard_OStream
        :type aFace: OCC.wrapper.BRepAdaptor.Handle_BRepAdaptor_HSurface
        :type aDrawer: OCC.wrapper.VrmlConverter.Handle_VrmlConverter_Drawer

        """
        return _VrmlConverter.VrmlConverter_WFDeflectionRestrictedFace_AddUIso(*args)

    AddUIso = staticmethod(AddUIso)

    def AddVIso(*args):
        """
        AddVIso(Standard_OStream & anOStream, Handle_BRepAdaptor_HSurface aFace, Handle_VrmlConverter_Drawer aDrawer)

        :type anOStream: OCC.wrapper.Standard.Standard_OStream
        :type aFace: OCC.wrapper.BRepAdaptor.Handle_BRepAdaptor_HSurface
        :type aDrawer: OCC.wrapper.VrmlConverter.Handle_VrmlConverter_Drawer

        """
        return _VrmlConverter.VrmlConverter_WFDeflectionRestrictedFace_AddVIso(*args)

    AddVIso = staticmethod(AddVIso)

    def Add(*args):
        """
        Add(Standard_OStream & anOStream, Handle_BRepAdaptor_HSurface aFace, Handle_VrmlConverter_Drawer aDrawer)
        Add(Standard_OStream & anOStream, Handle_BRepAdaptor_HSurface aFace, Standard_Boolean const DrawUIso, Standard_Boolean const DrawVIso, Standard_Real const Deflection, Standard_Integer const NBUiso, Standard_Integer const NBViso, Handle_VrmlConverter_Drawer aDrawer)

        :type anOStream: OCC.wrapper.Standard.Standard_OStream
        :type aFace: OCC.wrapper.BRepAdaptor.Handle_BRepAdaptor_HSurface
        :type DrawUIso: bool
        :type DrawVIso: bool
        :type Deflection: float
        :type NBUiso: int
        :type NBViso: int
        :type aDrawer: OCC.wrapper.VrmlConverter.Handle_VrmlConverter_Drawer

        """
        return _VrmlConverter.VrmlConverter_WFDeflectionRestrictedFace_Add(*args)

    Add = staticmethod(Add)

    def __init__(self):
        """
        WFDeflectionRestrictedFace    -    computes    the
        wireframe   presentation   of  faces       with
        restrictions by  displaying  a given  number of  U
        and/or  V  isoparametric  curves,  converts his
        into VRML objects   and writes (adds) them  into
        anOStream.    All   requested properties  of the
        representation  are  specify in  aDrawer of Drawer
        class (Prs3d).    This kind  of the presentation
        is     converted       into   IndexedFaceSet   and
        IndexedLineSet ( VRML ).
        """
        this = _VrmlConverter.new_VrmlConverter_WFDeflectionRestrictedFace()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _VrmlConverter.delete_VrmlConverter_WFDeflectionRestrictedFace
VrmlConverter_WFDeflectionRestrictedFace_swigregister = _VrmlConverter.VrmlConverter_WFDeflectionRestrictedFace_swigregister
VrmlConverter_WFDeflectionRestrictedFace_swigregister(VrmlConverter_WFDeflectionRestrictedFace)

def VrmlConverter_WFDeflectionRestrictedFace_AddUIso(*args):
    """
    VrmlConverter_WFDeflectionRestrictedFace_AddUIso(Standard_OStream & anOStream, Handle_BRepAdaptor_HSurface aFace, Handle_VrmlConverter_Drawer aDrawer)

    :type anOStream: OCC.wrapper.Standard.Standard_OStream
    :type aFace: OCC.wrapper.BRepAdaptor.Handle_BRepAdaptor_HSurface
    :type aDrawer: OCC.wrapper.VrmlConverter.Handle_VrmlConverter_Drawer

    """
    return _VrmlConverter.VrmlConverter_WFDeflectionRestrictedFace_AddUIso(*args)

def VrmlConverter_WFDeflectionRestrictedFace_AddVIso(*args):
    """
    VrmlConverter_WFDeflectionRestrictedFace_AddVIso(Standard_OStream & anOStream, Handle_BRepAdaptor_HSurface aFace, Handle_VrmlConverter_Drawer aDrawer)

    :type anOStream: OCC.wrapper.Standard.Standard_OStream
    :type aFace: OCC.wrapper.BRepAdaptor.Handle_BRepAdaptor_HSurface
    :type aDrawer: OCC.wrapper.VrmlConverter.Handle_VrmlConverter_Drawer

    """
    return _VrmlConverter.VrmlConverter_WFDeflectionRestrictedFace_AddVIso(*args)

def VrmlConverter_WFDeflectionRestrictedFace_Add(*args):
    """
    Add(Standard_OStream & anOStream, Handle_BRepAdaptor_HSurface aFace, Handle_VrmlConverter_Drawer aDrawer)
    VrmlConverter_WFDeflectionRestrictedFace_Add(Standard_OStream & anOStream, Handle_BRepAdaptor_HSurface aFace, Standard_Boolean const DrawUIso, Standard_Boolean const DrawVIso, Standard_Real const Deflection, Standard_Integer const NBUiso, Standard_Integer const NBViso, Handle_VrmlConverter_Drawer aDrawer)

    :type anOStream: OCC.wrapper.Standard.Standard_OStream
    :type aFace: OCC.wrapper.BRepAdaptor.Handle_BRepAdaptor_HSurface
    :type DrawUIso: bool
    :type DrawVIso: bool
    :type Deflection: float
    :type NBUiso: int
    :type NBViso: int
    :type aDrawer: OCC.wrapper.VrmlConverter.Handle_VrmlConverter_Drawer

    """
    return _VrmlConverter.VrmlConverter_WFDeflectionRestrictedFace_Add(*args)

class VrmlConverter_WFDeflectionShape(object):
    """
    WFDeflectionShape -   computes    the    wireframe
    presentation of compound set  of faces,  edges and
    vertices by displaying a  given number of U and/or
    V isoparametric  curves,   converts this  one into  VRML
    objects and writes (adds) them into anOStream.
    All requested properties of the representation are
    specify in aDrawer.
    This kind of the presentation  is  converted  into
    IndexedLineSet and PointSet ( VRML ).
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Add(*args):
        """
        Add(Standard_OStream & anOStream, TopoDS_Shape aShape, Handle_VrmlConverter_Drawer aDrawer)

        :type anOStream: OCC.wrapper.Standard.Standard_OStream
        :type aShape: OCC.wrapper.TopoDS.TopoDS_Shape
        :type aDrawer: OCC.wrapper.VrmlConverter.Handle_VrmlConverter_Drawer

        """
        return _VrmlConverter.VrmlConverter_WFDeflectionShape_Add(*args)

    Add = staticmethod(Add)

    def __init__(self):
        """
        WFDeflectionShape -   computes    the    wireframe
        presentation of compound set  of faces,  edges and
        vertices by displaying a  given number of U and/or
        V isoparametric  curves,   converts this  one into  VRML
        objects and writes (adds) them into anOStream.
        All requested properties of the representation are
        specify in aDrawer.
        This kind of the presentation  is  converted  into
        IndexedLineSet and PointSet ( VRML ).
        """
        this = _VrmlConverter.new_VrmlConverter_WFDeflectionShape()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _VrmlConverter.delete_VrmlConverter_WFDeflectionShape
VrmlConverter_WFDeflectionShape_swigregister = _VrmlConverter.VrmlConverter_WFDeflectionShape_swigregister
VrmlConverter_WFDeflectionShape_swigregister(VrmlConverter_WFDeflectionShape)

def VrmlConverter_WFDeflectionShape_Add(*args):
    """
    VrmlConverter_WFDeflectionShape_Add(Standard_OStream & anOStream, TopoDS_Shape aShape, Handle_VrmlConverter_Drawer aDrawer)

    :type anOStream: OCC.wrapper.Standard.Standard_OStream
    :type aShape: OCC.wrapper.TopoDS.TopoDS_Shape
    :type aDrawer: OCC.wrapper.VrmlConverter.Handle_VrmlConverter_Drawer

    """
    return _VrmlConverter.VrmlConverter_WFDeflectionShape_Add(*args)

class VrmlConverter_Drawer(Standard.Standard_Transient):
    """
    qualifies the aspect properties for
    the VRML conversation of a specific kind of object.
    This includes for example color, maximal chordial deviation, etc...
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_VrmlConverter_Drawer
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_VrmlConverter_Drawer(self) 
            return h


    def __init__(self, *args):
        """
        __init__(VrmlConverter_Drawer self) -> VrmlConverter_Drawer

        qualifies the aspect properties for
        the VRML conversation of a specific kind of object.
        This includes for example color, maximal chordial deviation, etc...
        """
        this = _VrmlConverter.new_VrmlConverter_Drawer(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def SetTypeOfDeflection(self, *args):
        """
        SetTypeOfDeflection(VrmlConverter_Drawer self, Aspect_TypeOfDeflection const aTypeOfDeflection)

        by default: TOD_Relative; however, except for the shapes,
        the drawing  will be made using the absolute deviation.

        :type aTypeOfDeflection: OCC.wrapper.Aspect.Aspect_TypeOfDeflection

        """
        return _VrmlConverter.VrmlConverter_Drawer_SetTypeOfDeflection(self, *args)


    def TypeOfDeflection(self, *args):
        """
        TypeOfDeflection(VrmlConverter_Drawer self) -> Aspect_TypeOfDeflection

        :rtype: OCC.wrapper.Aspect.Aspect_TypeOfDeflection

        """
        return _VrmlConverter.VrmlConverter_Drawer_TypeOfDeflection(self, *args)


    def SetMaximalChordialDeviation(self, *args):
        """
        SetMaximalChordialDeviation(VrmlConverter_Drawer self, Standard_Real const aChordialDeviation)

        Defines the maximal chordial deviation when drawing any curve;
        If this  value is  one  of  the  obvious  parameters  of  methods,
        current  value  from  Drawer won't be used.
        This value is used by:

        VrmlConverter_DeflectionCurve
        VrmlConverter_WFDeflectionRestrictedFace
        VrmlConverter_WFDeflectionShape

        :type aChordialDeviation: float

        """
        return _VrmlConverter.VrmlConverter_Drawer_SetMaximalChordialDeviation(self, *args)


    def MaximalChordialDeviation(self, *args):
        """
        MaximalChordialDeviation(VrmlConverter_Drawer self) -> Standard_Real

        returns the maximal chordial deviation.
        Default value: 0.1

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _VrmlConverter.VrmlConverter_Drawer_MaximalChordialDeviation(self, *args)


    def SetDeviationCoefficient(self, *args):
        """
        SetDeviationCoefficient(VrmlConverter_Drawer self, Standard_Real const aCoefficient)

        default 0.001

        :type aCoefficient: float

        """
        return _VrmlConverter.VrmlConverter_Drawer_SetDeviationCoefficient(self, *args)


    def DeviationCoefficient(self, *args):
        """
        DeviationCoefficient(VrmlConverter_Drawer self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _VrmlConverter.VrmlConverter_Drawer_DeviationCoefficient(self, *args)


    def SetDiscretisation(self, *args):
        """
        SetDiscretisation(VrmlConverter_Drawer self, Standard_Integer const d)

        default: 17 points.
        Defines the Discretisation  (myNbPoints) when drawing any curve;
        If this  value is  one  of  the  obvious  parameters  of  methods,
        current  value  from  Drawer won't be used.
        This value is used by:

        VrmlConverter_Curve
        VrmlConverter_WFRestrictedFace
        VrmlConverter_WFShape

        :type d: int

        """
        return _VrmlConverter.VrmlConverter_Drawer_SetDiscretisation(self, *args)


    def Discretisation(self, *args):
        """
        Discretisation(VrmlConverter_Drawer self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _VrmlConverter.VrmlConverter_Drawer_Discretisation(self, *args)


    def SetMaximalParameterValue(self, *args):
        """
        SetMaximalParameterValue(VrmlConverter_Drawer self, Standard_Real const Value)

        defines the maximum value allowed  for the first and last
        parameters of an infinite curve.
        Default value: 500.
        VrmlConverter_Curve
        VrmlConverter_WFRestrictedFace
        VrmlConverter_WFShape

        :type Value: float

        """
        return _VrmlConverter.VrmlConverter_Drawer_SetMaximalParameterValue(self, *args)


    def MaximalParameterValue(self, *args):
        """
        MaximalParameterValue(VrmlConverter_Drawer self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _VrmlConverter.VrmlConverter_Drawer_MaximalParameterValue(self, *args)


    def SetIsoOnPlane(self, *args):
        """
        SetIsoOnPlane(VrmlConverter_Drawer self, Standard_Boolean const OnOff)

        enables the drawing of isos on planes.
        By default there are no isos on planes.

        :type OnOff: bool

        """
        return _VrmlConverter.VrmlConverter_Drawer_SetIsoOnPlane(self, *args)


    def IsoOnPlane(self, *args):
        """
        IsoOnPlane(VrmlConverter_Drawer self) -> Standard_Boolean

        returns True if the drawing of isos on planes is enabled.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _VrmlConverter.VrmlConverter_Drawer_IsoOnPlane(self, *args)


    def UIsoAspect(self, *args):
        """
        UIsoAspect(VrmlConverter_Drawer self) -> Handle_VrmlConverter_IsoAspect

        Defines the attributes which are used when drawing an
        U isoparametric curve of a face. Defines the number
        of U isoparametric curves to be drawn for a single face.
        The default values are the same default values from Vrml package.

        These attributes are used by the following algorithms:
        VrmlConverter_WFRestrictedFace
        VrmlConverter_WFDeflectionRestrictedFace

        :rtype: OCC.wrapper.VrmlConverter.Handle_VrmlConverter_IsoAspect

        """
        return _VrmlConverter.VrmlConverter_Drawer_UIsoAspect(self, *args)


    def SetUIsoAspect(self, *args):
        """
        SetUIsoAspect(VrmlConverter_Drawer self, Handle_VrmlConverter_IsoAspect anAspect)

        :type anAspect: OCC.wrapper.VrmlConverter.Handle_VrmlConverter_IsoAspect

        """
        return _VrmlConverter.VrmlConverter_Drawer_SetUIsoAspect(self, *args)


    def VIsoAspect(self, *args):
        """
        VIsoAspect(VrmlConverter_Drawer self) -> Handle_VrmlConverter_IsoAspect

        Defines the attributes which are used when drawing an
        V isoparametric curve of a face. Defines the number
        of V isoparametric curves to be drawn for a single face.
        The default values are the same default values from Vrml package.

        These attributes are used by the following algorithms:
        VrmlConverter_WFRestrictedFace
        VrmlConverter_WFDeflectionRestrictedFace

        :rtype: OCC.wrapper.VrmlConverter.Handle_VrmlConverter_IsoAspect

        """
        return _VrmlConverter.VrmlConverter_Drawer_VIsoAspect(self, *args)


    def SetVIsoAspect(self, *args):
        """
        SetVIsoAspect(VrmlConverter_Drawer self, Handle_VrmlConverter_IsoAspect anAspect)

        :type anAspect: OCC.wrapper.VrmlConverter.Handle_VrmlConverter_IsoAspect

        """
        return _VrmlConverter.VrmlConverter_Drawer_SetVIsoAspect(self, *args)


    def FreeBoundaryAspect(self, *args):
        """
        FreeBoundaryAspect(VrmlConverter_Drawer self) -> Handle_VrmlConverter_LineAspect

        The default values are the same default values from Vrml package.
        These attributes are used by the following algorithms:
        VrmlConverter_WFShape
        VrmlConverter_WFDeflectionShape

        :rtype: OCC.wrapper.VrmlConverter.Handle_VrmlConverter_LineAspect

        """
        return _VrmlConverter.VrmlConverter_Drawer_FreeBoundaryAspect(self, *args)


    def SetFreeBoundaryAspect(self, *args):
        """
        SetFreeBoundaryAspect(VrmlConverter_Drawer self, Handle_VrmlConverter_LineAspect anAspect)

        :type anAspect: OCC.wrapper.VrmlConverter.Handle_VrmlConverter_LineAspect

        """
        return _VrmlConverter.VrmlConverter_Drawer_SetFreeBoundaryAspect(self, *args)


    def SetFreeBoundaryDraw(self, *args):
        """
        SetFreeBoundaryDraw(VrmlConverter_Drawer self, Standard_Boolean const OnOff)

        enables the drawing the free boundaries
        By default the free boundaries  are drawn.

        :type OnOff: bool

        """
        return _VrmlConverter.VrmlConverter_Drawer_SetFreeBoundaryDraw(self, *args)


    def FreeBoundaryDraw(self, *args):
        """
        FreeBoundaryDraw(VrmlConverter_Drawer self) -> Standard_Boolean

        returns True if the drawing of the free boundaries is enabled.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _VrmlConverter.VrmlConverter_Drawer_FreeBoundaryDraw(self, *args)


    def WireAspect(self, *args):
        """
        WireAspect(VrmlConverter_Drawer self) -> Handle_VrmlConverter_LineAspect

        The default values are the same default values from Vrml package.
        These attributes are used by the following algorithms:
        VrmlConverter_WFShape
        VrmlConverter_WFDeflectionShape

        :rtype: OCC.wrapper.VrmlConverter.Handle_VrmlConverter_LineAspect

        """
        return _VrmlConverter.VrmlConverter_Drawer_WireAspect(self, *args)


    def SetWireAspect(self, *args):
        """
        SetWireAspect(VrmlConverter_Drawer self, Handle_VrmlConverter_LineAspect anAspect)

        :type anAspect: OCC.wrapper.VrmlConverter.Handle_VrmlConverter_LineAspect

        """
        return _VrmlConverter.VrmlConverter_Drawer_SetWireAspect(self, *args)


    def SetWireDraw(self, *args):
        """
        SetWireDraw(VrmlConverter_Drawer self, Standard_Boolean const OnOff)

        enables the drawing the wire
        By default the wire  are drawn.

        :type OnOff: bool

        """
        return _VrmlConverter.VrmlConverter_Drawer_SetWireDraw(self, *args)


    def WireDraw(self, *args):
        """
        WireDraw(VrmlConverter_Drawer self) -> Standard_Boolean

        returns True if the drawing of the wire is enabled.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _VrmlConverter.VrmlConverter_Drawer_WireDraw(self, *args)


    def UnFreeBoundaryAspect(self, *args):
        """
        UnFreeBoundaryAspect(VrmlConverter_Drawer self) -> Handle_VrmlConverter_LineAspect

        The default values are the same default values from Vrml package.
        These attributes are used by the following algorithms:
        VrmlConverter_WFShape
        VrmlConverter_WFDeflectionShape

        :rtype: OCC.wrapper.VrmlConverter.Handle_VrmlConverter_LineAspect

        """
        return _VrmlConverter.VrmlConverter_Drawer_UnFreeBoundaryAspect(self, *args)


    def SetUnFreeBoundaryAspect(self, *args):
        """
        SetUnFreeBoundaryAspect(VrmlConverter_Drawer self, Handle_VrmlConverter_LineAspect anAspect)

        :type anAspect: OCC.wrapper.VrmlConverter.Handle_VrmlConverter_LineAspect

        """
        return _VrmlConverter.VrmlConverter_Drawer_SetUnFreeBoundaryAspect(self, *args)


    def SetUnFreeBoundaryDraw(self, *args):
        """
        SetUnFreeBoundaryDraw(VrmlConverter_Drawer self, Standard_Boolean const OnOff)

        enables the drawing the unfree boundaries
        By default the unfree boundaries  are drawn.

        :type OnOff: bool

        """
        return _VrmlConverter.VrmlConverter_Drawer_SetUnFreeBoundaryDraw(self, *args)


    def UnFreeBoundaryDraw(self, *args):
        """
        UnFreeBoundaryDraw(VrmlConverter_Drawer self) -> Standard_Boolean

        returns True if the drawing of the unfree boundaries is enabled.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _VrmlConverter.VrmlConverter_Drawer_UnFreeBoundaryDraw(self, *args)


    def LineAspect(self, *args):
        """
        LineAspect(VrmlConverter_Drawer self) -> Handle_VrmlConverter_LineAspect

        The default values are the same default values from Vrml package.

        :rtype: OCC.wrapper.VrmlConverter.Handle_VrmlConverter_LineAspect

        """
        return _VrmlConverter.VrmlConverter_Drawer_LineAspect(self, *args)


    def SetLineAspect(self, *args):
        """
        SetLineAspect(VrmlConverter_Drawer self, Handle_VrmlConverter_LineAspect anAspect)

        :type anAspect: OCC.wrapper.VrmlConverter.Handle_VrmlConverter_LineAspect

        """
        return _VrmlConverter.VrmlConverter_Drawer_SetLineAspect(self, *args)


    def PointAspect(self, *args):
        """
        PointAspect(VrmlConverter_Drawer self) -> Handle_VrmlConverter_PointAspect

        :rtype: OCC.wrapper.VrmlConverter.Handle_VrmlConverter_PointAspect

        """
        return _VrmlConverter.VrmlConverter_Drawer_PointAspect(self, *args)


    def SetPointAspect(self, *args):
        """
        SetPointAspect(VrmlConverter_Drawer self, Handle_VrmlConverter_PointAspect anAspect)

        :type anAspect: OCC.wrapper.VrmlConverter.Handle_VrmlConverter_PointAspect

        """
        return _VrmlConverter.VrmlConverter_Drawer_SetPointAspect(self, *args)


    def ShadingAspect(self, *args):
        """
        ShadingAspect(VrmlConverter_Drawer self) -> Handle_VrmlConverter_ShadingAspect

        The default values are the same default values from Vrml package.

        :rtype: OCC.wrapper.VrmlConverter.Handle_VrmlConverter_ShadingAspect

        """
        return _VrmlConverter.VrmlConverter_Drawer_ShadingAspect(self, *args)


    def SetShadingAspect(self, *args):
        """
        SetShadingAspect(VrmlConverter_Drawer self, Handle_VrmlConverter_ShadingAspect anAspect)

        :type anAspect: OCC.wrapper.VrmlConverter.Handle_VrmlConverter_ShadingAspect

        """
        return _VrmlConverter.VrmlConverter_Drawer_SetShadingAspect(self, *args)


    def DrawHiddenLine(self, *args):
        """
        DrawHiddenLine(VrmlConverter_Drawer self) -> Standard_Boolean

        returns Standard_True if the hidden lines are to be drawn.
        By default the hidden lines are not drawn.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _VrmlConverter.VrmlConverter_Drawer_DrawHiddenLine(self, *args)


    def EnableDrawHiddenLine(self, *args):
        """
        EnableDrawHiddenLine(VrmlConverter_Drawer self)

        sets DrawHiddenLine  =  Standard_True  -  the hidden lines are drawn.


        """
        return _VrmlConverter.VrmlConverter_Drawer_EnableDrawHiddenLine(self, *args)


    def DisableDrawHiddenLine(self, *args):
        """
        DisableDrawHiddenLine(VrmlConverter_Drawer self)

        sets DrawHiddenLine  =  Standard_False  -  the hidden lines are not drawn.


        """
        return _VrmlConverter.VrmlConverter_Drawer_DisableDrawHiddenLine(self, *args)


    def HiddenLineAspect(self, *args):
        """
        HiddenLineAspect(VrmlConverter_Drawer self) -> Handle_VrmlConverter_LineAspect

        returns LineAspect  for  the hidden lines.
        The default values are the same default values from Vrml package.

        :rtype: OCC.wrapper.VrmlConverter.Handle_VrmlConverter_LineAspect

        """
        return _VrmlConverter.VrmlConverter_Drawer_HiddenLineAspect(self, *args)


    def SetHiddenLineAspect(self, *args):
        """
        SetHiddenLineAspect(VrmlConverter_Drawer self, Handle_VrmlConverter_LineAspect anAspect)

        sets LineAspect  for  the hidden lines.

        :type anAspect: OCC.wrapper.VrmlConverter.Handle_VrmlConverter_LineAspect

        """
        return _VrmlConverter.VrmlConverter_Drawer_SetHiddenLineAspect(self, *args)


    def SeenLineAspect(self, *args):
        """
        SeenLineAspect(VrmlConverter_Drawer self) -> Handle_VrmlConverter_LineAspect

        returns LineAspect  for  the seen lines.
        The default values are the same default values from Vrml package.

        :rtype: OCC.wrapper.VrmlConverter.Handle_VrmlConverter_LineAspect

        """
        return _VrmlConverter.VrmlConverter_Drawer_SeenLineAspect(self, *args)


    def SetSeenLineAspect(self, *args):
        """
        SetSeenLineAspect(VrmlConverter_Drawer self, Handle_VrmlConverter_LineAspect anAspect)

        sets LineAspect  for  the seen lines.

        :type anAspect: OCC.wrapper.VrmlConverter.Handle_VrmlConverter_LineAspect

        """
        return _VrmlConverter.VrmlConverter_Drawer_SetSeenLineAspect(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _VrmlConverter.VrmlConverter_Drawer_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _VrmlConverter.VrmlConverter_Drawer_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _VrmlConverter.VrmlConverter_Drawer_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _VrmlConverter.delete_VrmlConverter_Drawer
VrmlConverter_Drawer_swigregister = _VrmlConverter.VrmlConverter_Drawer_swigregister
VrmlConverter_Drawer_swigregister(VrmlConverter_Drawer)

def VrmlConverter_Drawer_get_type_name(*args):
    """
    VrmlConverter_Drawer_get_type_name() -> char const *

    :rtype: const char *

    """
    return _VrmlConverter.VrmlConverter_Drawer_get_type_name(*args)

def VrmlConverter_Drawer_get_type_descriptor(*args):
    """
    VrmlConverter_Drawer_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _VrmlConverter.VrmlConverter_Drawer_get_type_descriptor(*args)

class Handle_VrmlConverter_Drawer(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_VrmlConverter_Drawer self)

        Nullify the handle


        """
        return _VrmlConverter.Handle_VrmlConverter_Drawer_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_VrmlConverter_Drawer self) -> bool

        Check for being null

        :rtype: bool

        """
        return _VrmlConverter.Handle_VrmlConverter_Drawer_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_VrmlConverter_Drawer self, VrmlConverter_Drawer thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _VrmlConverter.Handle_VrmlConverter_Drawer_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_VrmlConverter_Drawer self, Handle_VrmlConverter_Drawer theHandle) -> Handle_VrmlConverter_Drawer
        assign(Handle_VrmlConverter_Drawer self, VrmlConverter_Drawer thePtr) -> Handle_VrmlConverter_Drawer
        assign(Handle_VrmlConverter_Drawer self, Handle_VrmlConverter_Drawer theHandle) -> Handle_VrmlConverter_Drawer

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _VrmlConverter.Handle_VrmlConverter_Drawer_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_VrmlConverter_Drawer self) -> VrmlConverter_Drawer

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _VrmlConverter.Handle_VrmlConverter_Drawer_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_VrmlConverter_Drawer self) -> VrmlConverter_Drawer

        Member access operator (note non-const)

        :rtype: T *

        """
        return _VrmlConverter.Handle_VrmlConverter_Drawer___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_VrmlConverter_Drawer self) -> VrmlConverter_Drawer

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _VrmlConverter.Handle_VrmlConverter_Drawer___ref__(self, *args)


    def __hash__(self):
        return _VrmlConverter.Handle_VrmlConverter_Drawer___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _VrmlConverter.Handle_VrmlConverter_Drawer___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _VrmlConverter.new_Handle_VrmlConverter_Drawer(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_VrmlConverter.Handle_VrmlConverter_Drawer_DownCast)
    __swig_destroy__ = _VrmlConverter.delete_Handle_VrmlConverter_Drawer

    def SetTypeOfDeflection(self, *args):
        """
        SetTypeOfDeflection(Handle_VrmlConverter_Drawer self, Aspect_TypeOfDeflection const aTypeOfDeflection)

        by default: TOD_Relative; however, except for the shapes,
        the drawing  will be made using the absolute deviation.

        :type aTypeOfDeflection: OCC.wrapper.Aspect.Aspect_TypeOfDeflection

        """
        return _VrmlConverter.Handle_VrmlConverter_Drawer_SetTypeOfDeflection(self, *args)


    def TypeOfDeflection(self, *args):
        """
        TypeOfDeflection(Handle_VrmlConverter_Drawer self) -> Aspect_TypeOfDeflection

        :rtype: OCC.wrapper.Aspect.Aspect_TypeOfDeflection

        """
        return _VrmlConverter.Handle_VrmlConverter_Drawer_TypeOfDeflection(self, *args)


    def SetMaximalChordialDeviation(self, *args):
        """
        SetMaximalChordialDeviation(Handle_VrmlConverter_Drawer self, Standard_Real const aChordialDeviation)

        Defines the maximal chordial deviation when drawing any curve;
        If this  value is  one  of  the  obvious  parameters  of  methods,
        current  value  from  Drawer won't be used.
        This value is used by:

        VrmlConverter_DeflectionCurve
        VrmlConverter_WFDeflectionRestrictedFace
        VrmlConverter_WFDeflectionShape

        :type aChordialDeviation: float

        """
        return _VrmlConverter.Handle_VrmlConverter_Drawer_SetMaximalChordialDeviation(self, *args)


    def MaximalChordialDeviation(self, *args):
        """
        MaximalChordialDeviation(Handle_VrmlConverter_Drawer self) -> Standard_Real

        returns the maximal chordial deviation.
        Default value: 0.1

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _VrmlConverter.Handle_VrmlConverter_Drawer_MaximalChordialDeviation(self, *args)


    def SetDeviationCoefficient(self, *args):
        """
        SetDeviationCoefficient(Handle_VrmlConverter_Drawer self, Standard_Real const aCoefficient)

        default 0.001

        :type aCoefficient: float

        """
        return _VrmlConverter.Handle_VrmlConverter_Drawer_SetDeviationCoefficient(self, *args)


    def DeviationCoefficient(self, *args):
        """
        DeviationCoefficient(Handle_VrmlConverter_Drawer self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _VrmlConverter.Handle_VrmlConverter_Drawer_DeviationCoefficient(self, *args)


    def SetDiscretisation(self, *args):
        """
        SetDiscretisation(Handle_VrmlConverter_Drawer self, Standard_Integer const d)

        default: 17 points.
        Defines the Discretisation  (myNbPoints) when drawing any curve;
        If this  value is  one  of  the  obvious  parameters  of  methods,
        current  value  from  Drawer won't be used.
        This value is used by:

        VrmlConverter_Curve
        VrmlConverter_WFRestrictedFace
        VrmlConverter_WFShape

        :type d: int

        """
        return _VrmlConverter.Handle_VrmlConverter_Drawer_SetDiscretisation(self, *args)


    def Discretisation(self, *args):
        """
        Discretisation(Handle_VrmlConverter_Drawer self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _VrmlConverter.Handle_VrmlConverter_Drawer_Discretisation(self, *args)


    def SetMaximalParameterValue(self, *args):
        """
        SetMaximalParameterValue(Handle_VrmlConverter_Drawer self, Standard_Real const Value)

        defines the maximum value allowed  for the first and last
        parameters of an infinite curve.
        Default value: 500.
        VrmlConverter_Curve
        VrmlConverter_WFRestrictedFace
        VrmlConverter_WFShape

        :type Value: float

        """
        return _VrmlConverter.Handle_VrmlConverter_Drawer_SetMaximalParameterValue(self, *args)


    def MaximalParameterValue(self, *args):
        """
        MaximalParameterValue(Handle_VrmlConverter_Drawer self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _VrmlConverter.Handle_VrmlConverter_Drawer_MaximalParameterValue(self, *args)


    def SetIsoOnPlane(self, *args):
        """
        SetIsoOnPlane(Handle_VrmlConverter_Drawer self, Standard_Boolean const OnOff)

        enables the drawing of isos on planes.
        By default there are no isos on planes.

        :type OnOff: bool

        """
        return _VrmlConverter.Handle_VrmlConverter_Drawer_SetIsoOnPlane(self, *args)


    def IsoOnPlane(self, *args):
        """
        IsoOnPlane(Handle_VrmlConverter_Drawer self) -> Standard_Boolean

        returns True if the drawing of isos on planes is enabled.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _VrmlConverter.Handle_VrmlConverter_Drawer_IsoOnPlane(self, *args)


    def UIsoAspect(self, *args):
        """
        UIsoAspect(Handle_VrmlConverter_Drawer self) -> Handle_VrmlConverter_IsoAspect

        Defines the attributes which are used when drawing an
        U isoparametric curve of a face. Defines the number
        of U isoparametric curves to be drawn for a single face.
        The default values are the same default values from Vrml package.

        These attributes are used by the following algorithms:
        VrmlConverter_WFRestrictedFace
        VrmlConverter_WFDeflectionRestrictedFace

        :rtype: OCC.wrapper.VrmlConverter.Handle_VrmlConverter_IsoAspect

        """
        return _VrmlConverter.Handle_VrmlConverter_Drawer_UIsoAspect(self, *args)


    def SetUIsoAspect(self, *args):
        """
        SetUIsoAspect(Handle_VrmlConverter_Drawer self, Handle_VrmlConverter_IsoAspect anAspect)

        :type anAspect: OCC.wrapper.VrmlConverter.Handle_VrmlConverter_IsoAspect

        """
        return _VrmlConverter.Handle_VrmlConverter_Drawer_SetUIsoAspect(self, *args)


    def VIsoAspect(self, *args):
        """
        VIsoAspect(Handle_VrmlConverter_Drawer self) -> Handle_VrmlConverter_IsoAspect

        Defines the attributes which are used when drawing an
        V isoparametric curve of a face. Defines the number
        of V isoparametric curves to be drawn for a single face.
        The default values are the same default values from Vrml package.

        These attributes are used by the following algorithms:
        VrmlConverter_WFRestrictedFace
        VrmlConverter_WFDeflectionRestrictedFace

        :rtype: OCC.wrapper.VrmlConverter.Handle_VrmlConverter_IsoAspect

        """
        return _VrmlConverter.Handle_VrmlConverter_Drawer_VIsoAspect(self, *args)


    def SetVIsoAspect(self, *args):
        """
        SetVIsoAspect(Handle_VrmlConverter_Drawer self, Handle_VrmlConverter_IsoAspect anAspect)

        :type anAspect: OCC.wrapper.VrmlConverter.Handle_VrmlConverter_IsoAspect

        """
        return _VrmlConverter.Handle_VrmlConverter_Drawer_SetVIsoAspect(self, *args)


    def FreeBoundaryAspect(self, *args):
        """
        FreeBoundaryAspect(Handle_VrmlConverter_Drawer self) -> Handle_VrmlConverter_LineAspect

        The default values are the same default values from Vrml package.
        These attributes are used by the following algorithms:
        VrmlConverter_WFShape
        VrmlConverter_WFDeflectionShape

        :rtype: OCC.wrapper.VrmlConverter.Handle_VrmlConverter_LineAspect

        """
        return _VrmlConverter.Handle_VrmlConverter_Drawer_FreeBoundaryAspect(self, *args)


    def SetFreeBoundaryAspect(self, *args):
        """
        SetFreeBoundaryAspect(Handle_VrmlConverter_Drawer self, Handle_VrmlConverter_LineAspect anAspect)

        :type anAspect: OCC.wrapper.VrmlConverter.Handle_VrmlConverter_LineAspect

        """
        return _VrmlConverter.Handle_VrmlConverter_Drawer_SetFreeBoundaryAspect(self, *args)


    def SetFreeBoundaryDraw(self, *args):
        """
        SetFreeBoundaryDraw(Handle_VrmlConverter_Drawer self, Standard_Boolean const OnOff)

        enables the drawing the free boundaries
        By default the free boundaries  are drawn.

        :type OnOff: bool

        """
        return _VrmlConverter.Handle_VrmlConverter_Drawer_SetFreeBoundaryDraw(self, *args)


    def FreeBoundaryDraw(self, *args):
        """
        FreeBoundaryDraw(Handle_VrmlConverter_Drawer self) -> Standard_Boolean

        returns True if the drawing of the free boundaries is enabled.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _VrmlConverter.Handle_VrmlConverter_Drawer_FreeBoundaryDraw(self, *args)


    def WireAspect(self, *args):
        """
        WireAspect(Handle_VrmlConverter_Drawer self) -> Handle_VrmlConverter_LineAspect

        The default values are the same default values from Vrml package.
        These attributes are used by the following algorithms:
        VrmlConverter_WFShape
        VrmlConverter_WFDeflectionShape

        :rtype: OCC.wrapper.VrmlConverter.Handle_VrmlConverter_LineAspect

        """
        return _VrmlConverter.Handle_VrmlConverter_Drawer_WireAspect(self, *args)


    def SetWireAspect(self, *args):
        """
        SetWireAspect(Handle_VrmlConverter_Drawer self, Handle_VrmlConverter_LineAspect anAspect)

        :type anAspect: OCC.wrapper.VrmlConverter.Handle_VrmlConverter_LineAspect

        """
        return _VrmlConverter.Handle_VrmlConverter_Drawer_SetWireAspect(self, *args)


    def SetWireDraw(self, *args):
        """
        SetWireDraw(Handle_VrmlConverter_Drawer self, Standard_Boolean const OnOff)

        enables the drawing the wire
        By default the wire  are drawn.

        :type OnOff: bool

        """
        return _VrmlConverter.Handle_VrmlConverter_Drawer_SetWireDraw(self, *args)


    def WireDraw(self, *args):
        """
        WireDraw(Handle_VrmlConverter_Drawer self) -> Standard_Boolean

        returns True if the drawing of the wire is enabled.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _VrmlConverter.Handle_VrmlConverter_Drawer_WireDraw(self, *args)


    def UnFreeBoundaryAspect(self, *args):
        """
        UnFreeBoundaryAspect(Handle_VrmlConverter_Drawer self) -> Handle_VrmlConverter_LineAspect

        The default values are the same default values from Vrml package.
        These attributes are used by the following algorithms:
        VrmlConverter_WFShape
        VrmlConverter_WFDeflectionShape

        :rtype: OCC.wrapper.VrmlConverter.Handle_VrmlConverter_LineAspect

        """
        return _VrmlConverter.Handle_VrmlConverter_Drawer_UnFreeBoundaryAspect(self, *args)


    def SetUnFreeBoundaryAspect(self, *args):
        """
        SetUnFreeBoundaryAspect(Handle_VrmlConverter_Drawer self, Handle_VrmlConverter_LineAspect anAspect)

        :type anAspect: OCC.wrapper.VrmlConverter.Handle_VrmlConverter_LineAspect

        """
        return _VrmlConverter.Handle_VrmlConverter_Drawer_SetUnFreeBoundaryAspect(self, *args)


    def SetUnFreeBoundaryDraw(self, *args):
        """
        SetUnFreeBoundaryDraw(Handle_VrmlConverter_Drawer self, Standard_Boolean const OnOff)

        enables the drawing the unfree boundaries
        By default the unfree boundaries  are drawn.

        :type OnOff: bool

        """
        return _VrmlConverter.Handle_VrmlConverter_Drawer_SetUnFreeBoundaryDraw(self, *args)


    def UnFreeBoundaryDraw(self, *args):
        """
        UnFreeBoundaryDraw(Handle_VrmlConverter_Drawer self) -> Standard_Boolean

        returns True if the drawing of the unfree boundaries is enabled.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _VrmlConverter.Handle_VrmlConverter_Drawer_UnFreeBoundaryDraw(self, *args)


    def LineAspect(self, *args):
        """
        LineAspect(Handle_VrmlConverter_Drawer self) -> Handle_VrmlConverter_LineAspect

        The default values are the same default values from Vrml package.

        :rtype: OCC.wrapper.VrmlConverter.Handle_VrmlConverter_LineAspect

        """
        return _VrmlConverter.Handle_VrmlConverter_Drawer_LineAspect(self, *args)


    def SetLineAspect(self, *args):
        """
        SetLineAspect(Handle_VrmlConverter_Drawer self, Handle_VrmlConverter_LineAspect anAspect)

        :type anAspect: OCC.wrapper.VrmlConverter.Handle_VrmlConverter_LineAspect

        """
        return _VrmlConverter.Handle_VrmlConverter_Drawer_SetLineAspect(self, *args)


    def PointAspect(self, *args):
        """
        PointAspect(Handle_VrmlConverter_Drawer self) -> Handle_VrmlConverter_PointAspect

        :rtype: OCC.wrapper.VrmlConverter.Handle_VrmlConverter_PointAspect

        """
        return _VrmlConverter.Handle_VrmlConverter_Drawer_PointAspect(self, *args)


    def SetPointAspect(self, *args):
        """
        SetPointAspect(Handle_VrmlConverter_Drawer self, Handle_VrmlConverter_PointAspect anAspect)

        :type anAspect: OCC.wrapper.VrmlConverter.Handle_VrmlConverter_PointAspect

        """
        return _VrmlConverter.Handle_VrmlConverter_Drawer_SetPointAspect(self, *args)


    def ShadingAspect(self, *args):
        """
        ShadingAspect(Handle_VrmlConverter_Drawer self) -> Handle_VrmlConverter_ShadingAspect

        The default values are the same default values from Vrml package.

        :rtype: OCC.wrapper.VrmlConverter.Handle_VrmlConverter_ShadingAspect

        """
        return _VrmlConverter.Handle_VrmlConverter_Drawer_ShadingAspect(self, *args)


    def SetShadingAspect(self, *args):
        """
        SetShadingAspect(Handle_VrmlConverter_Drawer self, Handle_VrmlConverter_ShadingAspect anAspect)

        :type anAspect: OCC.wrapper.VrmlConverter.Handle_VrmlConverter_ShadingAspect

        """
        return _VrmlConverter.Handle_VrmlConverter_Drawer_SetShadingAspect(self, *args)


    def DrawHiddenLine(self, *args):
        """
        DrawHiddenLine(Handle_VrmlConverter_Drawer self) -> Standard_Boolean

        returns Standard_True if the hidden lines are to be drawn.
        By default the hidden lines are not drawn.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _VrmlConverter.Handle_VrmlConverter_Drawer_DrawHiddenLine(self, *args)


    def EnableDrawHiddenLine(self, *args):
        """
        EnableDrawHiddenLine(Handle_VrmlConverter_Drawer self)

        sets DrawHiddenLine  =  Standard_True  -  the hidden lines are drawn.


        """
        return _VrmlConverter.Handle_VrmlConverter_Drawer_EnableDrawHiddenLine(self, *args)


    def DisableDrawHiddenLine(self, *args):
        """
        DisableDrawHiddenLine(Handle_VrmlConverter_Drawer self)

        sets DrawHiddenLine  =  Standard_False  -  the hidden lines are not drawn.


        """
        return _VrmlConverter.Handle_VrmlConverter_Drawer_DisableDrawHiddenLine(self, *args)


    def HiddenLineAspect(self, *args):
        """
        HiddenLineAspect(Handle_VrmlConverter_Drawer self) -> Handle_VrmlConverter_LineAspect

        returns LineAspect  for  the hidden lines.
        The default values are the same default values from Vrml package.

        :rtype: OCC.wrapper.VrmlConverter.Handle_VrmlConverter_LineAspect

        """
        return _VrmlConverter.Handle_VrmlConverter_Drawer_HiddenLineAspect(self, *args)


    def SetHiddenLineAspect(self, *args):
        """
        SetHiddenLineAspect(Handle_VrmlConverter_Drawer self, Handle_VrmlConverter_LineAspect anAspect)

        sets LineAspect  for  the hidden lines.

        :type anAspect: OCC.wrapper.VrmlConverter.Handle_VrmlConverter_LineAspect

        """
        return _VrmlConverter.Handle_VrmlConverter_Drawer_SetHiddenLineAspect(self, *args)


    def SeenLineAspect(self, *args):
        """
        SeenLineAspect(Handle_VrmlConverter_Drawer self) -> Handle_VrmlConverter_LineAspect

        returns LineAspect  for  the seen lines.
        The default values are the same default values from Vrml package.

        :rtype: OCC.wrapper.VrmlConverter.Handle_VrmlConverter_LineAspect

        """
        return _VrmlConverter.Handle_VrmlConverter_Drawer_SeenLineAspect(self, *args)


    def SetSeenLineAspect(self, *args):
        """
        SetSeenLineAspect(Handle_VrmlConverter_Drawer self, Handle_VrmlConverter_LineAspect anAspect)

        sets LineAspect  for  the seen lines.

        :type anAspect: OCC.wrapper.VrmlConverter.Handle_VrmlConverter_LineAspect

        """
        return _VrmlConverter.Handle_VrmlConverter_Drawer_SetSeenLineAspect(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_VrmlConverter_Drawer self) -> char const *

        :rtype: const char *

        """
        return _VrmlConverter.Handle_VrmlConverter_Drawer_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _VrmlConverter.Handle_VrmlConverter_Drawer_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _VrmlConverter.Handle_VrmlConverter_Drawer_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_VrmlConverter_Drawer self)

        Memory deallocator for transient classes


        """
        return _VrmlConverter.Handle_VrmlConverter_Drawer_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_VrmlConverter_Drawer self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_VrmlConverter_Drawer self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _VrmlConverter.Handle_VrmlConverter_Drawer_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_VrmlConverter_Drawer self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_VrmlConverter_Drawer self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _VrmlConverter.Handle_VrmlConverter_Drawer_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_VrmlConverter_Drawer self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _VrmlConverter.Handle_VrmlConverter_Drawer_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_VrmlConverter_Drawer self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _VrmlConverter.Handle_VrmlConverter_Drawer_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_VrmlConverter_Drawer self)

        Increments the reference counter of this object


        """
        return _VrmlConverter.Handle_VrmlConverter_Drawer_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_VrmlConverter_Drawer self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _VrmlConverter.Handle_VrmlConverter_Drawer_DecrementRefCounter(self, *args)

Handle_VrmlConverter_Drawer_swigregister = _VrmlConverter.Handle_VrmlConverter_Drawer_swigregister
Handle_VrmlConverter_Drawer_swigregister(Handle_VrmlConverter_Drawer)

def Handle_VrmlConverter_Drawer_DownCast(thing):
    return _VrmlConverter.Handle_VrmlConverter_Drawer_DownCast(thing)
Handle_VrmlConverter_Drawer_DownCast = _VrmlConverter.Handle_VrmlConverter_Drawer_DownCast

class VrmlConverter_PointAspect(Standard.Standard_Transient):
    """
    qualifies the aspect properties for
    the VRML conversation of a Point Set.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_VrmlConverter_PointAspect
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_VrmlConverter_PointAspect(self) 
            return h


    def __init__(self, *args):
        """
        __init__(VrmlConverter_PointAspect self) -> VrmlConverter_PointAspect
        __init__(VrmlConverter_PointAspect self, Handle_Vrml_Material aMaterial, Standard_Boolean const OnOff) -> VrmlConverter_PointAspect

        :type aMaterial: OCC.wrapper.Vrml.Handle_Vrml_Material
        :type OnOff: bool

        """
        this = _VrmlConverter.new_VrmlConverter_PointAspect(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def SetMaterial(self, *args):
        """
        SetMaterial(VrmlConverter_PointAspect self, Handle_Vrml_Material aMaterial)

        :type aMaterial: OCC.wrapper.Vrml.Handle_Vrml_Material

        """
        return _VrmlConverter.VrmlConverter_PointAspect_SetMaterial(self, *args)


    def Material(self, *args):
        """
        Material(VrmlConverter_PointAspect self) -> Handle_Vrml_Material

        :rtype: OCC.wrapper.Vrml.Handle_Vrml_Material

        """
        return _VrmlConverter.VrmlConverter_PointAspect_Material(self, *args)


    def SetHasMaterial(self, *args):
        """
        SetHasMaterial(VrmlConverter_PointAspect self, Standard_Boolean const OnOff)

        defines the necessary of writing  own  Material from Vrml into  output  OStream.
        By default False  -  the material is not writing into OStream,
        True  -  the material is writing.

        :type OnOff: bool

        """
        return _VrmlConverter.VrmlConverter_PointAspect_SetHasMaterial(self, *args)


    def HasMaterial(self, *args):
        """
        HasMaterial(VrmlConverter_PointAspect self) -> Standard_Boolean

        returns True if the  materials is  writing into OStream.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _VrmlConverter.VrmlConverter_PointAspect_HasMaterial(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _VrmlConverter.VrmlConverter_PointAspect_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _VrmlConverter.VrmlConverter_PointAspect_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _VrmlConverter.VrmlConverter_PointAspect_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _VrmlConverter.delete_VrmlConverter_PointAspect
VrmlConverter_PointAspect_swigregister = _VrmlConverter.VrmlConverter_PointAspect_swigregister
VrmlConverter_PointAspect_swigregister(VrmlConverter_PointAspect)

def VrmlConverter_PointAspect_get_type_name(*args):
    """
    VrmlConverter_PointAspect_get_type_name() -> char const *

    :rtype: const char *

    """
    return _VrmlConverter.VrmlConverter_PointAspect_get_type_name(*args)

def VrmlConverter_PointAspect_get_type_descriptor(*args):
    """
    VrmlConverter_PointAspect_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _VrmlConverter.VrmlConverter_PointAspect_get_type_descriptor(*args)

class Handle_VrmlConverter_ShadingAspect(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_VrmlConverter_ShadingAspect self)

        Nullify the handle


        """
        return _VrmlConverter.Handle_VrmlConverter_ShadingAspect_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_VrmlConverter_ShadingAspect self) -> bool

        Check for being null

        :rtype: bool

        """
        return _VrmlConverter.Handle_VrmlConverter_ShadingAspect_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_VrmlConverter_ShadingAspect self, VrmlConverter_ShadingAspect thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _VrmlConverter.Handle_VrmlConverter_ShadingAspect_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_VrmlConverter_ShadingAspect self, Handle_VrmlConverter_ShadingAspect theHandle) -> Handle_VrmlConverter_ShadingAspect
        assign(Handle_VrmlConverter_ShadingAspect self, VrmlConverter_ShadingAspect thePtr) -> Handle_VrmlConverter_ShadingAspect
        assign(Handle_VrmlConverter_ShadingAspect self, Handle_VrmlConverter_ShadingAspect theHandle) -> Handle_VrmlConverter_ShadingAspect

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _VrmlConverter.Handle_VrmlConverter_ShadingAspect_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_VrmlConverter_ShadingAspect self) -> VrmlConverter_ShadingAspect

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _VrmlConverter.Handle_VrmlConverter_ShadingAspect_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_VrmlConverter_ShadingAspect self) -> VrmlConverter_ShadingAspect

        Member access operator (note non-const)

        :rtype: T *

        """
        return _VrmlConverter.Handle_VrmlConverter_ShadingAspect___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_VrmlConverter_ShadingAspect self) -> VrmlConverter_ShadingAspect

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _VrmlConverter.Handle_VrmlConverter_ShadingAspect___ref__(self, *args)


    def __hash__(self):
        return _VrmlConverter.Handle_VrmlConverter_ShadingAspect___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _VrmlConverter.Handle_VrmlConverter_ShadingAspect___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _VrmlConverter.new_Handle_VrmlConverter_ShadingAspect(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_VrmlConverter.Handle_VrmlConverter_ShadingAspect_DownCast)
    __swig_destroy__ = _VrmlConverter.delete_Handle_VrmlConverter_ShadingAspect

    def SetFrontMaterial(self, *args):
        """
        SetFrontMaterial(Handle_VrmlConverter_ShadingAspect self, Handle_Vrml_Material aMaterial)

        :type aMaterial: OCC.wrapper.Vrml.Handle_Vrml_Material

        """
        return _VrmlConverter.Handle_VrmlConverter_ShadingAspect_SetFrontMaterial(self, *args)


    def FrontMaterial(self, *args):
        """
        FrontMaterial(Handle_VrmlConverter_ShadingAspect self) -> Handle_Vrml_Material

        :rtype: OCC.wrapper.Vrml.Handle_Vrml_Material

        """
        return _VrmlConverter.Handle_VrmlConverter_ShadingAspect_FrontMaterial(self, *args)


    def SetShapeHints(self, *args):
        """
        SetShapeHints(Handle_VrmlConverter_ShadingAspect self, Vrml_ShapeHints aShapeHints)

        :type aShapeHints: OCC.wrapper.Vrml.Vrml_ShapeHints

        """
        return _VrmlConverter.Handle_VrmlConverter_ShadingAspect_SetShapeHints(self, *args)


    def ShapeHints(self, *args):
        """
        ShapeHints(Handle_VrmlConverter_ShadingAspect self) -> Vrml_ShapeHints

        :rtype: OCC.wrapper.Vrml.Vrml_ShapeHints

        """
        return _VrmlConverter.Handle_VrmlConverter_ShadingAspect_ShapeHints(self, *args)


    def SetHasNormals(self, *args):
        """
        SetHasNormals(Handle_VrmlConverter_ShadingAspect self, Standard_Boolean const OnOff)

        defines necessary of  a  calculation  of  normals for  ShadedShape  to  more
        accurately  display  curved  surfaces,  pacticularly  when  smoooth  or  phong
        shading  is  used  in  VRML  viewer.
        By default False  -  the normals are not calculated,
        True  -  the normals are calculated.
        Warning: If  normals  are  calculated  the  resulting  VRML  file  will
        be  substantially  lager.

        :type OnOff: bool

        """
        return _VrmlConverter.Handle_VrmlConverter_ShadingAspect_SetHasNormals(self, *args)


    def HasNormals(self, *args):
        """
        HasNormals(Handle_VrmlConverter_ShadingAspect self) -> Standard_Boolean

        returns True if the normals are calculating

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _VrmlConverter.Handle_VrmlConverter_ShadingAspect_HasNormals(self, *args)


    def SetHasMaterial(self, *args):
        """
        SetHasMaterial(Handle_VrmlConverter_ShadingAspect self, Standard_Boolean const OnOff)

        defines necessary of writing  Material from Vrml into  output  OStream.
        By default False  -  the material is not writing into OStream,
        True  -  the material is writing.

        :type OnOff: bool

        """
        return _VrmlConverter.Handle_VrmlConverter_ShadingAspect_SetHasMaterial(self, *args)


    def HasMaterial(self, *args):
        """
        HasMaterial(Handle_VrmlConverter_ShadingAspect self) -> Standard_Boolean

        returns True if the  materials is  writing into OStream.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _VrmlConverter.Handle_VrmlConverter_ShadingAspect_HasMaterial(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_VrmlConverter_ShadingAspect self) -> char const *

        :rtype: const char *

        """
        return _VrmlConverter.Handle_VrmlConverter_ShadingAspect_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _VrmlConverter.Handle_VrmlConverter_ShadingAspect_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _VrmlConverter.Handle_VrmlConverter_ShadingAspect_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_VrmlConverter_ShadingAspect self)

        Memory deallocator for transient classes


        """
        return _VrmlConverter.Handle_VrmlConverter_ShadingAspect_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_VrmlConverter_ShadingAspect self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_VrmlConverter_ShadingAspect self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _VrmlConverter.Handle_VrmlConverter_ShadingAspect_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_VrmlConverter_ShadingAspect self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_VrmlConverter_ShadingAspect self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _VrmlConverter.Handle_VrmlConverter_ShadingAspect_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_VrmlConverter_ShadingAspect self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _VrmlConverter.Handle_VrmlConverter_ShadingAspect_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_VrmlConverter_ShadingAspect self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _VrmlConverter.Handle_VrmlConverter_ShadingAspect_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_VrmlConverter_ShadingAspect self)

        Increments the reference counter of this object


        """
        return _VrmlConverter.Handle_VrmlConverter_ShadingAspect_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_VrmlConverter_ShadingAspect self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _VrmlConverter.Handle_VrmlConverter_ShadingAspect_DecrementRefCounter(self, *args)

Handle_VrmlConverter_ShadingAspect_swigregister = _VrmlConverter.Handle_VrmlConverter_ShadingAspect_swigregister
Handle_VrmlConverter_ShadingAspect_swigregister(Handle_VrmlConverter_ShadingAspect)

def Handle_VrmlConverter_ShadingAspect_DownCast(thing):
    return _VrmlConverter.Handle_VrmlConverter_ShadingAspect_DownCast(thing)
Handle_VrmlConverter_ShadingAspect_DownCast = _VrmlConverter.Handle_VrmlConverter_ShadingAspect_DownCast

class Handle_VrmlConverter_IsoAspect(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_VrmlConverter_IsoAspect self)

        Nullify the handle


        """
        return _VrmlConverter.Handle_VrmlConverter_IsoAspect_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_VrmlConverter_IsoAspect self) -> bool

        Check for being null

        :rtype: bool

        """
        return _VrmlConverter.Handle_VrmlConverter_IsoAspect_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_VrmlConverter_IsoAspect self, VrmlConverter_IsoAspect thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _VrmlConverter.Handle_VrmlConverter_IsoAspect_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_VrmlConverter_IsoAspect self, Handle_VrmlConverter_IsoAspect theHandle) -> Handle_VrmlConverter_IsoAspect
        assign(Handle_VrmlConverter_IsoAspect self, VrmlConverter_IsoAspect thePtr) -> Handle_VrmlConverter_IsoAspect
        assign(Handle_VrmlConverter_IsoAspect self, Handle_VrmlConverter_IsoAspect theHandle) -> Handle_VrmlConverter_IsoAspect

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _VrmlConverter.Handle_VrmlConverter_IsoAspect_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_VrmlConverter_IsoAspect self) -> VrmlConverter_IsoAspect

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _VrmlConverter.Handle_VrmlConverter_IsoAspect_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_VrmlConverter_IsoAspect self) -> VrmlConverter_IsoAspect

        Member access operator (note non-const)

        :rtype: T *

        """
        return _VrmlConverter.Handle_VrmlConverter_IsoAspect___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_VrmlConverter_IsoAspect self) -> VrmlConverter_IsoAspect

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _VrmlConverter.Handle_VrmlConverter_IsoAspect___ref__(self, *args)


    def __hash__(self):
        return _VrmlConverter.Handle_VrmlConverter_IsoAspect___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _VrmlConverter.Handle_VrmlConverter_IsoAspect___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _VrmlConverter.new_Handle_VrmlConverter_IsoAspect(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_VrmlConverter.Handle_VrmlConverter_IsoAspect_DownCast)
    __swig_destroy__ = _VrmlConverter.delete_Handle_VrmlConverter_IsoAspect

    def SetNumber(self, *args):
        """
        SetNumber(Handle_VrmlConverter_IsoAspect self, Standard_Integer const aNumber)

        :type aNumber: int

        """
        return _VrmlConverter.Handle_VrmlConverter_IsoAspect_SetNumber(self, *args)


    def Number(self, *args):
        """
        Number(Handle_VrmlConverter_IsoAspect self) -> Standard_Integer

        returns the number of U or V isoparametric curves drawn for a
        single face.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _VrmlConverter.Handle_VrmlConverter_IsoAspect_Number(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_VrmlConverter_IsoAspect self) -> char const *

        :rtype: const char *

        """
        return _VrmlConverter.Handle_VrmlConverter_IsoAspect_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _VrmlConverter.Handle_VrmlConverter_IsoAspect_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _VrmlConverter.Handle_VrmlConverter_IsoAspect_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetMaterial(self, *args):
        """
        SetMaterial(Handle_VrmlConverter_IsoAspect self, Handle_Vrml_Material aMaterial)

        :type aMaterial: OCC.wrapper.Vrml.Handle_Vrml_Material

        """
        return _VrmlConverter.Handle_VrmlConverter_IsoAspect_SetMaterial(self, *args)


    def Material(self, *args):
        """
        Material(Handle_VrmlConverter_IsoAspect self) -> Handle_Vrml_Material

        :rtype: OCC.wrapper.Vrml.Handle_Vrml_Material

        """
        return _VrmlConverter.Handle_VrmlConverter_IsoAspect_Material(self, *args)


    def SetHasMaterial(self, *args):
        """
        SetHasMaterial(Handle_VrmlConverter_IsoAspect self, Standard_Boolean const OnOff)

        defines the necessary of writing  own  Material from Vrml into  output  OStream.
        By default False  -  the material is not writing into OStream,
        True  -  the material is writing.

        :type OnOff: bool

        """
        return _VrmlConverter.Handle_VrmlConverter_IsoAspect_SetHasMaterial(self, *args)


    def HasMaterial(self, *args):
        """
        HasMaterial(Handle_VrmlConverter_IsoAspect self) -> Standard_Boolean

        returns True if the  materials is  writing into OStream.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _VrmlConverter.Handle_VrmlConverter_IsoAspect_HasMaterial(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_VrmlConverter_IsoAspect self)

        Memory deallocator for transient classes


        """
        return _VrmlConverter.Handle_VrmlConverter_IsoAspect_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_VrmlConverter_IsoAspect self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_VrmlConverter_IsoAspect self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _VrmlConverter.Handle_VrmlConverter_IsoAspect_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_VrmlConverter_IsoAspect self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_VrmlConverter_IsoAspect self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _VrmlConverter.Handle_VrmlConverter_IsoAspect_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_VrmlConverter_IsoAspect self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _VrmlConverter.Handle_VrmlConverter_IsoAspect_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_VrmlConverter_IsoAspect self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _VrmlConverter.Handle_VrmlConverter_IsoAspect_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_VrmlConverter_IsoAspect self)

        Increments the reference counter of this object


        """
        return _VrmlConverter.Handle_VrmlConverter_IsoAspect_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_VrmlConverter_IsoAspect self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _VrmlConverter.Handle_VrmlConverter_IsoAspect_DecrementRefCounter(self, *args)

Handle_VrmlConverter_IsoAspect_swigregister = _VrmlConverter.Handle_VrmlConverter_IsoAspect_swigregister
Handle_VrmlConverter_IsoAspect_swigregister(Handle_VrmlConverter_IsoAspect)

def Handle_VrmlConverter_IsoAspect_DownCast(thing):
    return _VrmlConverter.Handle_VrmlConverter_IsoAspect_DownCast(thing)
Handle_VrmlConverter_IsoAspect_DownCast = _VrmlConverter.Handle_VrmlConverter_IsoAspect_DownCast

class VrmlConverter_HLRShape(object):
    """
    HLRShape  -  computes the presentation  of objects
    with removal of their hidden  lines for a specific
    projector, converts them into VRML  objects  and
    writes (adds) them into anOStream.  All requested
    properties of  the representation  are  specify in
    aDrawer of Drawer class.  This kind  of the presentation
    is  converted  into  IndexedLineSet  and   if  they  are  defined
    in  Projector into :
    PerspectiveCamera,
    OrthographicCamera,
    DirectionLight,
    PointLight,
    SpotLight
    from  Vrml  package.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Add(*args):
        """
        Add(Standard_OStream & anOStream, TopoDS_Shape aShape, Handle_VrmlConverter_Drawer aDrawer, Handle_VrmlConverter_Projector aProjector)

        :type anOStream: OCC.wrapper.Standard.Standard_OStream
        :type aShape: OCC.wrapper.TopoDS.TopoDS_Shape
        :type aDrawer: OCC.wrapper.VrmlConverter.Handle_VrmlConverter_Drawer
        :type aProjector: OCC.wrapper.VrmlConverter.Handle_VrmlConverter_Projector

        """
        return _VrmlConverter.VrmlConverter_HLRShape_Add(*args)

    Add = staticmethod(Add)

    def __init__(self):
        """
        HLRShape  -  computes the presentation  of objects
        with removal of their hidden  lines for a specific
        projector, converts them into VRML  objects  and
        writes (adds) them into anOStream.  All requested
        properties of  the representation  are  specify in
        aDrawer of Drawer class.  This kind  of the presentation
        is  converted  into  IndexedLineSet  and   if  they  are  defined
        in  Projector into :
        PerspectiveCamera,
        OrthographicCamera,
        DirectionLight,
        PointLight,
        SpotLight
        from  Vrml  package.
        """
        this = _VrmlConverter.new_VrmlConverter_HLRShape()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _VrmlConverter.delete_VrmlConverter_HLRShape
VrmlConverter_HLRShape_swigregister = _VrmlConverter.VrmlConverter_HLRShape_swigregister
VrmlConverter_HLRShape_swigregister(VrmlConverter_HLRShape)

def VrmlConverter_HLRShape_Add(*args):
    """
    VrmlConverter_HLRShape_Add(Standard_OStream & anOStream, TopoDS_Shape aShape, Handle_VrmlConverter_Drawer aDrawer, Handle_VrmlConverter_Projector aProjector)

    :type anOStream: OCC.wrapper.Standard.Standard_OStream
    :type aShape: OCC.wrapper.TopoDS.TopoDS_Shape
    :type aDrawer: OCC.wrapper.VrmlConverter.Handle_VrmlConverter_Drawer
    :type aProjector: OCC.wrapper.VrmlConverter.Handle_VrmlConverter_Projector

    """
    return _VrmlConverter.VrmlConverter_HLRShape_Add(*args)

class VrmlConverter_DeflectionCurve(object):
    """
    DeflectionCurve    -  computes the presentation of
    objects to be seen as  curves,   converts this  one into
    VRML    objects    and    writes (adds)  into
    anOStream.     All  requested properties  of   the
    representation  are specify in  aDrawer.
    This  kind of the presentation
    is converted into IndexedLineSet ( VRML ).
    The computation will be made according to a maximal
    chordial deviation.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Add(*args):
        """
        Add(Standard_OStream & anOStream, Adaptor3d_Curve aCurve, Handle_VrmlConverter_Drawer aDrawer)
        Add(Standard_OStream & anOStream, Adaptor3d_Curve aCurve, Standard_Real const U1, Standard_Real const U2, Handle_VrmlConverter_Drawer aDrawer)
        Add(Standard_OStream & anOStream, Adaptor3d_Curve aCurve, Standard_Real const aDeflection, Standard_Real const aLimit)
        Add(Standard_OStream & anOStream, Adaptor3d_Curve aCurve, Standard_Real const aDeflection, Handle_VrmlConverter_Drawer aDrawer)
        Add(Standard_OStream & anOStream, Adaptor3d_Curve aCurve, Standard_Real const U1, Standard_Real const U2, Standard_Real const aDeflection)
        Add(Standard_OStream & anOStream, Adaptor3d_Curve aCurve, Handle_TColStd_HArray1OfReal aParams, Standard_Integer const aNbNodes, Handle_VrmlConverter_Drawer aDrawer)

        adds to the OStream the drawing of the curve aCurve with
        the array of parameters to retrieve points on curve.

        :type anOStream: OCC.wrapper.Standard.Standard_OStream
        :type aCurve: OCC.wrapper.Adaptor3d.Adaptor3d_Curve
        :type aParams: OCC.wrapper.TColStd.Handle_TColStd_HArray1OfReal
        :type aNbNodes: int
        :type aDrawer: OCC.wrapper.VrmlConverter.Handle_VrmlConverter_Drawer

        """
        return _VrmlConverter.VrmlConverter_DeflectionCurve_Add(*args)

    Add = staticmethod(Add)

    def __init__(self):
        """
        DeflectionCurve    -  computes the presentation of
        objects to be seen as  curves,   converts this  one into
        VRML    objects    and    writes (adds)  into
        anOStream.     All  requested properties  of   the
        representation  are specify in  aDrawer.
        This  kind of the presentation
        is converted into IndexedLineSet ( VRML ).
        The computation will be made according to a maximal
        chordial deviation.
        """
        this = _VrmlConverter.new_VrmlConverter_DeflectionCurve()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _VrmlConverter.delete_VrmlConverter_DeflectionCurve
VrmlConverter_DeflectionCurve_swigregister = _VrmlConverter.VrmlConverter_DeflectionCurve_swigregister
VrmlConverter_DeflectionCurve_swigregister(VrmlConverter_DeflectionCurve)

def VrmlConverter_DeflectionCurve_Add(*args):
    """
    Add(Standard_OStream & anOStream, Adaptor3d_Curve aCurve, Handle_VrmlConverter_Drawer aDrawer)
    Add(Standard_OStream & anOStream, Adaptor3d_Curve aCurve, Standard_Real const U1, Standard_Real const U2, Handle_VrmlConverter_Drawer aDrawer)
    Add(Standard_OStream & anOStream, Adaptor3d_Curve aCurve, Standard_Real const aDeflection, Standard_Real const aLimit)
    Add(Standard_OStream & anOStream, Adaptor3d_Curve aCurve, Standard_Real const aDeflection, Handle_VrmlConverter_Drawer aDrawer)
    Add(Standard_OStream & anOStream, Adaptor3d_Curve aCurve, Standard_Real const U1, Standard_Real const U2, Standard_Real const aDeflection)
    VrmlConverter_DeflectionCurve_Add(Standard_OStream & anOStream, Adaptor3d_Curve aCurve, Handle_TColStd_HArray1OfReal aParams, Standard_Integer const aNbNodes, Handle_VrmlConverter_Drawer aDrawer)

    adds to the OStream the drawing of the curve aCurve with
    the array of parameters to retrieve points on curve.

    :type anOStream: OCC.wrapper.Standard.Standard_OStream
    :type aCurve: OCC.wrapper.Adaptor3d.Adaptor3d_Curve
    :type aParams: OCC.wrapper.TColStd.Handle_TColStd_HArray1OfReal
    :type aNbNodes: int
    :type aDrawer: OCC.wrapper.VrmlConverter.Handle_VrmlConverter_Drawer

    """
    return _VrmlConverter.VrmlConverter_DeflectionCurve_Add(*args)

class VrmlConverter_Curve(object):
    """
    Curve - computes the presentation of objects to be
    seen  as curves  (the  computation  will  be  made
    with a constant  number  of  points),  converts this one
    into  VRML  objects  and  writes (adds) them  into
    anOStream.   All  requested   properties  of   the
    representation are specify  in aDrawer  of  Drawer
    class (VrmlConverter).
    This kind of the presentation is converted into
    IndexedLineSet ( VRML ).
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Add(*args):
        """
        Add(Adaptor3d_Curve aCurve, Handle_VrmlConverter_Drawer aDrawer, Standard_OStream & anOStream)
        Add(Adaptor3d_Curve aCurve, Standard_Real const U1, Standard_Real const U2, Handle_VrmlConverter_Drawer aDrawer, Standard_OStream & anOStream)
        Add(Adaptor3d_Curve aCurve, Standard_Real const U1, Standard_Real const U2, Standard_OStream & anOStream, Standard_Integer const aNbPoints)

        adds to the OStream the drawing of the curve aCurve.
        The aspect is the current aspect.
        The drawing will be limited between the points of parameter
        U1 and U2. aNbPoints defines  number of points on  one interval.

        :type aCurve: OCC.wrapper.Adaptor3d.Adaptor3d_Curve
        :type U1: float
        :type U2: float
        :type anOStream: OCC.wrapper.Standard.Standard_OStream
        :type aNbPoints: int

        """
        return _VrmlConverter.VrmlConverter_Curve_Add(*args)

    Add = staticmethod(Add)

    def __init__(self):
        """
        Curve - computes the presentation of objects to be
        seen  as curves  (the  computation  will  be  made
        with a constant  number  of  points),  converts this one
        into  VRML  objects  and  writes (adds) them  into
        anOStream.   All  requested   properties  of   the
        representation are specify  in aDrawer  of  Drawer
        class (VrmlConverter).
        This kind of the presentation is converted into
        IndexedLineSet ( VRML ).
        """
        this = _VrmlConverter.new_VrmlConverter_Curve()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _VrmlConverter.delete_VrmlConverter_Curve
VrmlConverter_Curve_swigregister = _VrmlConverter.VrmlConverter_Curve_swigregister
VrmlConverter_Curve_swigregister(VrmlConverter_Curve)

def VrmlConverter_Curve_Add(*args):
    """
    Add(Adaptor3d_Curve aCurve, Handle_VrmlConverter_Drawer aDrawer, Standard_OStream & anOStream)
    Add(Adaptor3d_Curve aCurve, Standard_Real const U1, Standard_Real const U2, Handle_VrmlConverter_Drawer aDrawer, Standard_OStream & anOStream)
    VrmlConverter_Curve_Add(Adaptor3d_Curve aCurve, Standard_Real const U1, Standard_Real const U2, Standard_OStream & anOStream, Standard_Integer const aNbPoints)

    adds to the OStream the drawing of the curve aCurve.
    The aspect is the current aspect.
    The drawing will be limited between the points of parameter
    U1 and U2. aNbPoints defines  number of points on  one interval.

    :type aCurve: OCC.wrapper.Adaptor3d.Adaptor3d_Curve
    :type U1: float
    :type U2: float
    :type anOStream: OCC.wrapper.Standard.Standard_OStream
    :type aNbPoints: int

    """
    return _VrmlConverter.VrmlConverter_Curve_Add(*args)

class VrmlConverter_WFRestrictedFace(object):
    """
    WFRestrictedFace -     computes     the  wireframe
    presentation  of faces  with   restrictions by
    displaying   a  given  number    of  U   and/or  V
    isoparametric  curves,  converts this  one into VRML
    objects  and writes  (adds)  into anOStream.
    All requested  properties  of the representation
    are specify in  aDrawer.
    This kind of the presentation is converted into
    IndexedLineSet ( VRML ).
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def AddUIso(*args):
        """
        AddUIso(Standard_OStream & anOStream, Handle_BRepAdaptor_HSurface aFace, Handle_VrmlConverter_Drawer aDrawer)

        :type anOStream: OCC.wrapper.Standard.Standard_OStream
        :type aFace: OCC.wrapper.BRepAdaptor.Handle_BRepAdaptor_HSurface
        :type aDrawer: OCC.wrapper.VrmlConverter.Handle_VrmlConverter_Drawer

        """
        return _VrmlConverter.VrmlConverter_WFRestrictedFace_AddUIso(*args)

    AddUIso = staticmethod(AddUIso)

    def AddVIso(*args):
        """
        AddVIso(Standard_OStream & anOStream, Handle_BRepAdaptor_HSurface aFace, Handle_VrmlConverter_Drawer aDrawer)

        :type anOStream: OCC.wrapper.Standard.Standard_OStream
        :type aFace: OCC.wrapper.BRepAdaptor.Handle_BRepAdaptor_HSurface
        :type aDrawer: OCC.wrapper.VrmlConverter.Handle_VrmlConverter_Drawer

        """
        return _VrmlConverter.VrmlConverter_WFRestrictedFace_AddVIso(*args)

    AddVIso = staticmethod(AddVIso)

    def Add(*args):
        """
        Add(Standard_OStream & anOStream, Handle_BRepAdaptor_HSurface aFace, Handle_VrmlConverter_Drawer aDrawer)
        Add(Standard_OStream & anOStream, Handle_BRepAdaptor_HSurface aFace, Standard_Boolean const DrawUIso, Standard_Boolean const DrawVIso, Standard_Integer const NBUiso, Standard_Integer const NBViso, Handle_VrmlConverter_Drawer aDrawer)

        :type anOStream: OCC.wrapper.Standard.Standard_OStream
        :type aFace: OCC.wrapper.BRepAdaptor.Handle_BRepAdaptor_HSurface
        :type DrawUIso: bool
        :type DrawVIso: bool
        :type NBUiso: int
        :type NBViso: int
        :type aDrawer: OCC.wrapper.VrmlConverter.Handle_VrmlConverter_Drawer

        """
        return _VrmlConverter.VrmlConverter_WFRestrictedFace_Add(*args)

    Add = staticmethod(Add)

    def __init__(self):
        """
        WFRestrictedFace -     computes     the  wireframe
        presentation  of faces  with   restrictions by
        displaying   a  given  number    of  U   and/or  V
        isoparametric  curves,  converts this  one into VRML
        objects  and writes  (adds)  into anOStream.
        All requested  properties  of the representation
        are specify in  aDrawer.
        This kind of the presentation is converted into
        IndexedLineSet ( VRML ).
        """
        this = _VrmlConverter.new_VrmlConverter_WFRestrictedFace()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _VrmlConverter.delete_VrmlConverter_WFRestrictedFace
VrmlConverter_WFRestrictedFace_swigregister = _VrmlConverter.VrmlConverter_WFRestrictedFace_swigregister
VrmlConverter_WFRestrictedFace_swigregister(VrmlConverter_WFRestrictedFace)

def VrmlConverter_WFRestrictedFace_AddUIso(*args):
    """
    VrmlConverter_WFRestrictedFace_AddUIso(Standard_OStream & anOStream, Handle_BRepAdaptor_HSurface aFace, Handle_VrmlConverter_Drawer aDrawer)

    :type anOStream: OCC.wrapper.Standard.Standard_OStream
    :type aFace: OCC.wrapper.BRepAdaptor.Handle_BRepAdaptor_HSurface
    :type aDrawer: OCC.wrapper.VrmlConverter.Handle_VrmlConverter_Drawer

    """
    return _VrmlConverter.VrmlConverter_WFRestrictedFace_AddUIso(*args)

def VrmlConverter_WFRestrictedFace_AddVIso(*args):
    """
    VrmlConverter_WFRestrictedFace_AddVIso(Standard_OStream & anOStream, Handle_BRepAdaptor_HSurface aFace, Handle_VrmlConverter_Drawer aDrawer)

    :type anOStream: OCC.wrapper.Standard.Standard_OStream
    :type aFace: OCC.wrapper.BRepAdaptor.Handle_BRepAdaptor_HSurface
    :type aDrawer: OCC.wrapper.VrmlConverter.Handle_VrmlConverter_Drawer

    """
    return _VrmlConverter.VrmlConverter_WFRestrictedFace_AddVIso(*args)

def VrmlConverter_WFRestrictedFace_Add(*args):
    """
    Add(Standard_OStream & anOStream, Handle_BRepAdaptor_HSurface aFace, Handle_VrmlConverter_Drawer aDrawer)
    VrmlConverter_WFRestrictedFace_Add(Standard_OStream & anOStream, Handle_BRepAdaptor_HSurface aFace, Standard_Boolean const DrawUIso, Standard_Boolean const DrawVIso, Standard_Integer const NBUiso, Standard_Integer const NBViso, Handle_VrmlConverter_Drawer aDrawer)

    :type anOStream: OCC.wrapper.Standard.Standard_OStream
    :type aFace: OCC.wrapper.BRepAdaptor.Handle_BRepAdaptor_HSurface
    :type DrawUIso: bool
    :type DrawVIso: bool
    :type NBUiso: int
    :type NBViso: int
    :type aDrawer: OCC.wrapper.VrmlConverter.Handle_VrmlConverter_Drawer

    """
    return _VrmlConverter.VrmlConverter_WFRestrictedFace_Add(*args)

class Handle_VrmlConverter_PointAspect(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_VrmlConverter_PointAspect self)

        Nullify the handle


        """
        return _VrmlConverter.Handle_VrmlConverter_PointAspect_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_VrmlConverter_PointAspect self) -> bool

        Check for being null

        :rtype: bool

        """
        return _VrmlConverter.Handle_VrmlConverter_PointAspect_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_VrmlConverter_PointAspect self, VrmlConverter_PointAspect thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _VrmlConverter.Handle_VrmlConverter_PointAspect_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_VrmlConverter_PointAspect self, Handle_VrmlConverter_PointAspect theHandle) -> Handle_VrmlConverter_PointAspect
        assign(Handle_VrmlConverter_PointAspect self, VrmlConverter_PointAspect thePtr) -> Handle_VrmlConverter_PointAspect
        assign(Handle_VrmlConverter_PointAspect self, Handle_VrmlConverter_PointAspect theHandle) -> Handle_VrmlConverter_PointAspect

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _VrmlConverter.Handle_VrmlConverter_PointAspect_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_VrmlConverter_PointAspect self) -> VrmlConverter_PointAspect

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _VrmlConverter.Handle_VrmlConverter_PointAspect_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_VrmlConverter_PointAspect self) -> VrmlConverter_PointAspect

        Member access operator (note non-const)

        :rtype: T *

        """
        return _VrmlConverter.Handle_VrmlConverter_PointAspect___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_VrmlConverter_PointAspect self) -> VrmlConverter_PointAspect

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _VrmlConverter.Handle_VrmlConverter_PointAspect___ref__(self, *args)


    def __hash__(self):
        return _VrmlConverter.Handle_VrmlConverter_PointAspect___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _VrmlConverter.Handle_VrmlConverter_PointAspect___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _VrmlConverter.new_Handle_VrmlConverter_PointAspect(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_VrmlConverter.Handle_VrmlConverter_PointAspect_DownCast)
    __swig_destroy__ = _VrmlConverter.delete_Handle_VrmlConverter_PointAspect

    def SetMaterial(self, *args):
        """
        SetMaterial(Handle_VrmlConverter_PointAspect self, Handle_Vrml_Material aMaterial)

        :type aMaterial: OCC.wrapper.Vrml.Handle_Vrml_Material

        """
        return _VrmlConverter.Handle_VrmlConverter_PointAspect_SetMaterial(self, *args)


    def Material(self, *args):
        """
        Material(Handle_VrmlConverter_PointAspect self) -> Handle_Vrml_Material

        :rtype: OCC.wrapper.Vrml.Handle_Vrml_Material

        """
        return _VrmlConverter.Handle_VrmlConverter_PointAspect_Material(self, *args)


    def SetHasMaterial(self, *args):
        """
        SetHasMaterial(Handle_VrmlConverter_PointAspect self, Standard_Boolean const OnOff)

        defines the necessary of writing  own  Material from Vrml into  output  OStream.
        By default False  -  the material is not writing into OStream,
        True  -  the material is writing.

        :type OnOff: bool

        """
        return _VrmlConverter.Handle_VrmlConverter_PointAspect_SetHasMaterial(self, *args)


    def HasMaterial(self, *args):
        """
        HasMaterial(Handle_VrmlConverter_PointAspect self) -> Standard_Boolean

        returns True if the  materials is  writing into OStream.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _VrmlConverter.Handle_VrmlConverter_PointAspect_HasMaterial(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_VrmlConverter_PointAspect self) -> char const *

        :rtype: const char *

        """
        return _VrmlConverter.Handle_VrmlConverter_PointAspect_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _VrmlConverter.Handle_VrmlConverter_PointAspect_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _VrmlConverter.Handle_VrmlConverter_PointAspect_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_VrmlConverter_PointAspect self)

        Memory deallocator for transient classes


        """
        return _VrmlConverter.Handle_VrmlConverter_PointAspect_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_VrmlConverter_PointAspect self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_VrmlConverter_PointAspect self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _VrmlConverter.Handle_VrmlConverter_PointAspect_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_VrmlConverter_PointAspect self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_VrmlConverter_PointAspect self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _VrmlConverter.Handle_VrmlConverter_PointAspect_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_VrmlConverter_PointAspect self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _VrmlConverter.Handle_VrmlConverter_PointAspect_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_VrmlConverter_PointAspect self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _VrmlConverter.Handle_VrmlConverter_PointAspect_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_VrmlConverter_PointAspect self)

        Increments the reference counter of this object


        """
        return _VrmlConverter.Handle_VrmlConverter_PointAspect_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_VrmlConverter_PointAspect self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _VrmlConverter.Handle_VrmlConverter_PointAspect_DecrementRefCounter(self, *args)

Handle_VrmlConverter_PointAspect_swigregister = _VrmlConverter.Handle_VrmlConverter_PointAspect_swigregister
Handle_VrmlConverter_PointAspect_swigregister(Handle_VrmlConverter_PointAspect)

def Handle_VrmlConverter_PointAspect_DownCast(thing):
    return _VrmlConverter.Handle_VrmlConverter_PointAspect_DownCast(thing)
Handle_VrmlConverter_PointAspect_DownCast = _VrmlConverter.Handle_VrmlConverter_PointAspect_DownCast




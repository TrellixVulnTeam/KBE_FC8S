# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_Message')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_Message')
    _Message = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_Message', [dirname(__file__)])
        except ImportError:
            import _Message
            return _Message
        try:
            _mod = imp.load_module('_Message', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _Message = swig_import_helper()
    del swig_import_helper
else:
    import _Message
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


class SwigPyIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _Message.delete_SwigPyIterator

    def value(self):
        return _Message.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _Message.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _Message.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _Message.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _Message.SwigPyIterator_equal(self, x)

    def copy(self):
        return _Message.SwigPyIterator_copy(self)

    def next(self):
        return _Message.SwigPyIterator_next(self)

    def __next__(self):
        return _Message.SwigPyIterator___next__(self)

    def previous(self):
        return _Message.SwigPyIterator_previous(self)

    def advance(self, n):
        return _Message.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _Message.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _Message.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _Message.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _Message.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _Message.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _Message.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self
SwigPyIterator_swigregister = _Message.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

class NCollection_CellFilter_InspectorXYZ(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _Message.NCollection_CellFilter_InspectorXYZ_Dimension
    Coord = staticmethod(_Message.NCollection_CellFilter_InspectorXYZ_Coord)

    def Shift(self, thePnt, theTol):
        return _Message.NCollection_CellFilter_InspectorXYZ_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _Message.new_NCollection_CellFilter_InspectorXYZ()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _Message.delete_NCollection_CellFilter_InspectorXYZ
NCollection_CellFilter_InspectorXYZ_swigregister = _Message.NCollection_CellFilter_InspectorXYZ_swigregister
NCollection_CellFilter_InspectorXYZ_swigregister(NCollection_CellFilter_InspectorXYZ)

def NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt):
    return _Message.NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt)
NCollection_CellFilter_InspectorXYZ_Coord = _Message.NCollection_CellFilter_InspectorXYZ_Coord

class NCollection_CellFilter_InspectorXY(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _Message.NCollection_CellFilter_InspectorXY_Dimension
    Coord = staticmethod(_Message.NCollection_CellFilter_InspectorXY_Coord)

    def Shift(self, thePnt, theTol):
        return _Message.NCollection_CellFilter_InspectorXY_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _Message.new_NCollection_CellFilter_InspectorXY()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _Message.delete_NCollection_CellFilter_InspectorXY
NCollection_CellFilter_InspectorXY_swigregister = _Message.NCollection_CellFilter_InspectorXY_swigregister
NCollection_CellFilter_InspectorXY_swigregister(NCollection_CellFilter_InspectorXY)

def NCollection_CellFilter_InspectorXY_Coord(i, thePnt):
    return _Message.NCollection_CellFilter_InspectorXY_Coord(i, thePnt)
NCollection_CellFilter_InspectorXY_Coord = _Message.NCollection_CellFilter_InspectorXY_Coord


def ptr_to_number(item):
    return _Message.ptr_to_number(item)
ptr_to_number = _Message.ptr_to_number

def HashCode(*args):
    return _Message.HashCode(*args)
HashCode = _Message.HashCode

def ptr_equal(a, b):
    return _Message.ptr_equal(a, b)
ptr_equal = _Message.ptr_equal
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColStd
else:
    import TColStd
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TCollection
else:
    import TCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Standard
else:
    import Standard
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import NCollection
else:
    import NCollection
del _swig_python_version_info
Message_DONE = _Message.Message_DONE
Message_WARN = _Message.Message_WARN
Message_ALARM = _Message.Message_ALARM
Message_FAIL = _Message.Message_FAIL
Message_None = _Message.Message_None
Message_Done1 = _Message.Message_Done1
Message_Done2 = _Message.Message_Done2
Message_Done3 = _Message.Message_Done3
Message_Done4 = _Message.Message_Done4
Message_Done5 = _Message.Message_Done5
Message_Done6 = _Message.Message_Done6
Message_Done7 = _Message.Message_Done7
Message_Done8 = _Message.Message_Done8
Message_Done9 = _Message.Message_Done9
Message_Done10 = _Message.Message_Done10
Message_Done11 = _Message.Message_Done11
Message_Done12 = _Message.Message_Done12
Message_Done13 = _Message.Message_Done13
Message_Done14 = _Message.Message_Done14
Message_Done15 = _Message.Message_Done15
Message_Done16 = _Message.Message_Done16
Message_Done17 = _Message.Message_Done17
Message_Done18 = _Message.Message_Done18
Message_Done19 = _Message.Message_Done19
Message_Done20 = _Message.Message_Done20
Message_Done21 = _Message.Message_Done21
Message_Done22 = _Message.Message_Done22
Message_Done23 = _Message.Message_Done23
Message_Done24 = _Message.Message_Done24
Message_Done25 = _Message.Message_Done25
Message_Done26 = _Message.Message_Done26
Message_Done27 = _Message.Message_Done27
Message_Done28 = _Message.Message_Done28
Message_Done29 = _Message.Message_Done29
Message_Done30 = _Message.Message_Done30
Message_Done31 = _Message.Message_Done31
Message_Done32 = _Message.Message_Done32
Message_Warn1 = _Message.Message_Warn1
Message_Warn2 = _Message.Message_Warn2
Message_Warn3 = _Message.Message_Warn3
Message_Warn4 = _Message.Message_Warn4
Message_Warn5 = _Message.Message_Warn5
Message_Warn6 = _Message.Message_Warn6
Message_Warn7 = _Message.Message_Warn7
Message_Warn8 = _Message.Message_Warn8
Message_Warn9 = _Message.Message_Warn9
Message_Warn10 = _Message.Message_Warn10
Message_Warn11 = _Message.Message_Warn11
Message_Warn12 = _Message.Message_Warn12
Message_Warn13 = _Message.Message_Warn13
Message_Warn14 = _Message.Message_Warn14
Message_Warn15 = _Message.Message_Warn15
Message_Warn16 = _Message.Message_Warn16
Message_Warn17 = _Message.Message_Warn17
Message_Warn18 = _Message.Message_Warn18
Message_Warn19 = _Message.Message_Warn19
Message_Warn20 = _Message.Message_Warn20
Message_Warn21 = _Message.Message_Warn21
Message_Warn22 = _Message.Message_Warn22
Message_Warn23 = _Message.Message_Warn23
Message_Warn24 = _Message.Message_Warn24
Message_Warn25 = _Message.Message_Warn25
Message_Warn26 = _Message.Message_Warn26
Message_Warn27 = _Message.Message_Warn27
Message_Warn28 = _Message.Message_Warn28
Message_Warn29 = _Message.Message_Warn29
Message_Warn30 = _Message.Message_Warn30
Message_Warn31 = _Message.Message_Warn31
Message_Warn32 = _Message.Message_Warn32
Message_Alarm1 = _Message.Message_Alarm1
Message_Alarm2 = _Message.Message_Alarm2
Message_Alarm3 = _Message.Message_Alarm3
Message_Alarm4 = _Message.Message_Alarm4
Message_Alarm5 = _Message.Message_Alarm5
Message_Alarm6 = _Message.Message_Alarm6
Message_Alarm7 = _Message.Message_Alarm7
Message_Alarm8 = _Message.Message_Alarm8
Message_Alarm9 = _Message.Message_Alarm9
Message_Alarm10 = _Message.Message_Alarm10
Message_Alarm11 = _Message.Message_Alarm11
Message_Alarm12 = _Message.Message_Alarm12
Message_Alarm13 = _Message.Message_Alarm13
Message_Alarm14 = _Message.Message_Alarm14
Message_Alarm15 = _Message.Message_Alarm15
Message_Alarm16 = _Message.Message_Alarm16
Message_Alarm17 = _Message.Message_Alarm17
Message_Alarm18 = _Message.Message_Alarm18
Message_Alarm19 = _Message.Message_Alarm19
Message_Alarm20 = _Message.Message_Alarm20
Message_Alarm21 = _Message.Message_Alarm21
Message_Alarm22 = _Message.Message_Alarm22
Message_Alarm23 = _Message.Message_Alarm23
Message_Alarm24 = _Message.Message_Alarm24
Message_Alarm25 = _Message.Message_Alarm25
Message_Alarm26 = _Message.Message_Alarm26
Message_Alarm27 = _Message.Message_Alarm27
Message_Alarm28 = _Message.Message_Alarm28
Message_Alarm29 = _Message.Message_Alarm29
Message_Alarm30 = _Message.Message_Alarm30
Message_Alarm31 = _Message.Message_Alarm31
Message_Alarm32 = _Message.Message_Alarm32
Message_Fail1 = _Message.Message_Fail1
Message_Fail2 = _Message.Message_Fail2
Message_Fail3 = _Message.Message_Fail3
Message_Fail4 = _Message.Message_Fail4
Message_Fail5 = _Message.Message_Fail5
Message_Fail6 = _Message.Message_Fail6
Message_Fail7 = _Message.Message_Fail7
Message_Fail8 = _Message.Message_Fail8
Message_Fail9 = _Message.Message_Fail9
Message_Fail10 = _Message.Message_Fail10
Message_Fail11 = _Message.Message_Fail11
Message_Fail12 = _Message.Message_Fail12
Message_Fail13 = _Message.Message_Fail13
Message_Fail14 = _Message.Message_Fail14
Message_Fail15 = _Message.Message_Fail15
Message_Fail16 = _Message.Message_Fail16
Message_Fail17 = _Message.Message_Fail17
Message_Fail18 = _Message.Message_Fail18
Message_Fail19 = _Message.Message_Fail19
Message_Fail20 = _Message.Message_Fail20
Message_Fail21 = _Message.Message_Fail21
Message_Fail22 = _Message.Message_Fail22
Message_Fail23 = _Message.Message_Fail23
Message_Fail24 = _Message.Message_Fail24
Message_Fail25 = _Message.Message_Fail25
Message_Fail26 = _Message.Message_Fail26
Message_Fail27 = _Message.Message_Fail27
Message_Fail28 = _Message.Message_Fail28
Message_Fail29 = _Message.Message_Fail29
Message_Fail30 = _Message.Message_Fail30
Message_Fail31 = _Message.Message_Fail31
Message_Fail32 = _Message.Message_Fail32
Message_Trace = _Message.Message_Trace
Message_Info = _Message.Message_Info
Message_Warning = _Message.Message_Warning
Message_Alarm = _Message.Message_Alarm
Message_Fail = _Message.Message_Fail
class Message_Printer(Standard.Standard_Transient):
    """
    Abstract interface class defining printer as output context for text messages

    The message, besides being text string, has associated gravity
    level, which can be used by printer to decide either to process a message or ignore it.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Message_Printer
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Message_Printer(self) 
            return h


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Message.Message_Printer_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Message.Message_Printer_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Message.Message_Printer_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def GetTraceLevel(self, *args):
        """
        GetTraceLevel(Message_Printer self) -> Message_Gravity

        Return trace level used for filtering messages;
        messages with lover gravity will be ignored.

        :rtype: OCC.wrapper.Message.Message_Gravity

        """
        return _Message.Message_Printer_GetTraceLevel(self, *args)


    def SetTraceLevel(self, *args):
        """
        SetTraceLevel(Message_Printer self, Message_Gravity const theTraceLevel)

        Set trace level used for filtering messages.
        By default, trace level is Message_Info, so that all messages are output

        :type theTraceLevel: OCC.wrapper.Message.Message_Gravity

        """
        return _Message.Message_Printer_SetTraceLevel(self, *args)


    def Send(self, *args):
        """
        Send(Message_Printer self, TCollection_ExtendedString theString, Message_Gravity const theGravity, Standard_Boolean const theToPutEol)
        Send(Message_Printer self, Standard_CString const theString, Message_Gravity const theGravity, Standard_Boolean const theToPutEol)
        Send(Message_Printer self, TCollection_AsciiString theString, Message_Gravity const theGravity, Standard_Boolean const theToPutEol)

        Send a string message with specified trace level.
        The parameter theToPutEol specified whether end-of-line should be added to the end of the message.
        Default implementation calls first method Send().

        :type theString: OCC.wrapper.TCollection.TCollection_AsciiString
        :type theGravity: OCC.wrapper.Message.Message_Gravity
        :type theToPutEol: bool

        """
        return _Message.Message_Printer_Send(self, *args)

    __swig_destroy__ = _Message.delete_Message_Printer
Message_Printer_swigregister = _Message.Message_Printer_swigregister
Message_Printer_swigregister(Message_Printer)

def Message_Printer_get_type_name(*args):
    """
    Message_Printer_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Message.Message_Printer_get_type_name(*args)

def Message_Printer_get_type_descriptor(*args):
    """
    Message_Printer_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Message.Message_Printer_get_type_descriptor(*args)

class Message_PrinterOStream(Message_Printer):
    """
    Implementation of a message printer associated with an ostream
    The ostream may be either externally defined one (e.g. cout),
    or file stream maintained internally (depending on constructor).
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Message_PrinterOStream
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Message_PrinterOStream(self) 
            return h


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Message.Message_PrinterOStream_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Message.Message_PrinterOStream_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Message.Message_PrinterOStream_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __init__(self, *args):
        """
        __init__(Message_PrinterOStream self, Message_Gravity const theTraceLevel=Message_Info) -> Message_PrinterOStream
        __init__(Message_PrinterOStream self, Standard_CString const theFileName, Standard_Boolean const theDoAppend, Message_Gravity const theTraceLevel=Message_Info) -> Message_PrinterOStream

        Create printer for output to a specified file.
        The option theDoAppend specifies whether file should be
        appended or rewritten.
        For specific file names (cout, cerr) standard streams are used

        :type theFileName: OCC.wrapper.Standard.Standard_CString
        :type theDoAppend: bool
        :type theTraceLevel: OCC.wrapper.Message.Message_Gravity

        """
        this = _Message.new_Message_PrinterOStream(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Close(self, *args):
        """
        Close(Message_PrinterOStream self)

        Flushes the output stream and destroys it if it has been
        specified externally with option doFree (or if it is internal
        file stream)


        """
        return _Message.Message_PrinterOStream_Close(self, *args)


    def GetUseUtf8(self, *args):
        """
        GetUseUtf8(Message_PrinterOStream self) -> Standard_Boolean

        Returns option to convert non-Ascii symbols to UTF8 encoding

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Message.Message_PrinterOStream_GetUseUtf8(self, *args)


    def SetUseUtf8(self, *args):
        """
        SetUseUtf8(Message_PrinterOStream self, Standard_Boolean const useUtf8)

        Sets option to convert non-Ascii symbols to UTF8 encoding

        :type useUtf8: bool

        """
        return _Message.Message_PrinterOStream_SetUseUtf8(self, *args)


    def GetStream(self, *args):
        """
        GetStream(Message_PrinterOStream self) -> Standard_OStream &

        Returns reference to the output stream

        :rtype: OCC.wrapper.Standard.Standard_OStream

        """
        return _Message.Message_PrinterOStream_GetStream(self, *args)


    def Send(self, *args):
        """
        Send(Message_PrinterOStream self, Standard_CString const theString, Message_Gravity const theGravity, Standard_Boolean const putEndl)
        Send(Message_PrinterOStream self, TCollection_AsciiString theString, Message_Gravity const theGravity, Standard_Boolean const putEndl)
        Send(Message_PrinterOStream self, TCollection_ExtendedString theString, Message_Gravity const theGravity, Standard_Boolean const putEndl)

        Puts a message to the current stream
        if its gravity is equal or greater
        to the trace level set by SetTraceLevel()
        Non-Ascii symbols are converted to UTF-8 if UseUtf8
        option is set, else replaced by symbols '?'

        :type theString: OCC.wrapper.TCollection.TCollection_ExtendedString
        :type theGravity: OCC.wrapper.Message.Message_Gravity
        :type putEndl: bool

        """
        return _Message.Message_PrinterOStream_Send(self, *args)

    __swig_destroy__ = _Message.delete_Message_PrinterOStream
Message_PrinterOStream_swigregister = _Message.Message_PrinterOStream_swigregister
Message_PrinterOStream_swigregister(Message_PrinterOStream)

def Message_PrinterOStream_get_type_name(*args):
    """
    Message_PrinterOStream_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Message.Message_PrinterOStream_get_type_name(*args)

def Message_PrinterOStream_get_type_descriptor(*args):
    """
    Message_PrinterOStream_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Message.Message_PrinterOStream_get_type_descriptor(*args)

class Message_Report(Standard.Standard_Transient):
    """
    Container for alert messages, sorted according to their gravity.

    For each gravity level, alerts are stored in simple list.
    If alert being added can be merged with another alert of the same
    type already in the list, it is merged and not added to the list.

    This class is intended to be used as follows:

    - In the process of execution, algorithm fills report by alert objects
    using methods AddAlert()

    - The result can be queried for presence of particular alert using 
    methods HasAlert()

    - The reports produced by nested or sequentially executed algorithms
    can be collected in one using method Merge()

    - The report can be shown to the user either as plain text with method 
    Dump() or in more advanced way, by iterating over lists returned by GetAlerts()

    - Report can be cleared by methods Clear() (usually after reporting)
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Message_Report
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Message_Report(self) 
            return h


    def __init__(self, *args):
        """
        __init__(Message_Report self) -> Message_Report

        Empty constructor


        """
        this = _Message.new_Message_Report(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def AddAlert(self, *args):
        """
        AddAlert(Message_Report self, Message_Gravity theGravity, Handle_Message_Alert theAlert)

        Add alert with specified gravity.
        This method is thread-safe, i.e. alerts can be added from parallel threads safely.

        :type theGravity: OCC.wrapper.Message.Message_Gravity
        :type theAlert: OCC.wrapper.Message.Handle_Message_Alert

        """
        return _Message.Message_Report_AddAlert(self, *args)


    def GetAlerts(self, *args):
        """
        Returns list of collected alerts with specified gravity

        :type theGravity: OCC.wrapper.Message.Message_Gravity
        :rtype: OCC.wrapper.Message.Message_ListOfAlert

        """
        res = _Message.Message_Report_GetAlerts(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def HasAlert(self, *args):
        """
        HasAlert(Message_Report self, Handle_Standard_Type theType) -> Standard_Boolean
        HasAlert(Message_Report self, Handle_Standard_Type theType, Message_Gravity theGravity) -> Standard_Boolean

        Returns true if specific type of alert is recorded with specified gravity

        :type theType: OCC.wrapper.Standard.Handle_Standard_Type
        :type theGravity: OCC.wrapper.Message.Message_Gravity
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Message.Message_Report_HasAlert(self, *args)


    def Clear(self, *args):
        """
        Clear(Message_Report self)
        Clear(Message_Report self, Message_Gravity theGravity)
        Clear(Message_Report self, Handle_Standard_Type theType)

        Clears collected alerts with specified type

        :type theType: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Message.Message_Report_Clear(self, *args)


    def Dump(self, *args):
        """
        Dump(Message_Report self, Standard_OStream & theOS)
        Dump(Message_Report self, Standard_OStream & theOS, Message_Gravity theGravity)

        Dumps collected alerts with specified gravity to stream

        :type theOS: OCC.wrapper.Standard.Standard_OStream
        :type theGravity: OCC.wrapper.Message.Message_Gravity

        """
        return _Message.Message_Report_Dump(self, *args)


    def SendMessages(self, *args):
        """
        SendMessages(Message_Report self, Handle_Message_Messenger theMessenger)
        SendMessages(Message_Report self, Handle_Message_Messenger theMessenger, Message_Gravity theGravity)

        Dumps collected alerts with specified gravity to messenger

        :type theMessenger: OCC.wrapper.Message.Handle_Message_Messenger
        :type theGravity: OCC.wrapper.Message.Message_Gravity

        """
        return _Message.Message_Report_SendMessages(self, *args)


    def Merge(self, *args):
        """
        Merge(Message_Report self, Handle_Message_Report theOther)
        Merge(Message_Report self, Handle_Message_Report theOther, Message_Gravity theGravity)

        Merges alerts with specified gravity from theOther report into this

        :type theOther: OCC.wrapper.Message.Handle_Message_Report
        :type theGravity: OCC.wrapper.Message.Message_Gravity

        """
        return _Message.Message_Report_Merge(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Message.Message_Report_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Message.Message_Report_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Message.Message_Report_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Message.delete_Message_Report
Message_Report_swigregister = _Message.Message_Report_swigregister
Message_Report_swigregister(Message_Report)

def Message_Report_get_type_name(*args):
    """
    Message_Report_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Message.Message_Report_get_type_name(*args)

def Message_Report_get_type_descriptor(*args):
    """
    Message_Report_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Message.Message_Report_get_type_descriptor(*args)

class Message_ProgressScale(object):
    """
    Internal data structure for scale in ProgressIndicator

    Basically it defines three things:
    - name that can be used for generating user messages
    - limits and characteristics of the current scale,
    along with derived coefficients to map it into basic scale [0-1]
    - methods for conversion of values from current scale
    to basic one and back

    NOTE: There is no special protection against bad input data
    like min > max etc. except cases when it can cause exception
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Message_ProgressScale self) -> Message_ProgressScale

        Creates scale ranged from 0 to 100 with step 1


        """
        this = _Message.new_Message_ProgressScale(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def SetName(self, *args):
        """
        SetName(Message_ProgressScale self, Standard_CString const theName)
        SetName(Message_ProgressScale self, Handle_TCollection_HAsciiString theName)

        Sets scale name

        :type theName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _Message.Message_ProgressScale_SetName(self, *args)


    def GetName(self, *args):
        """
        GetName(Message_ProgressScale self) -> Handle_TCollection_HAsciiString

        Gets scale name
        Name may be Null handle if not set

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _Message.Message_ProgressScale_GetName(self, *args)


    def SetMin(self, *args):
        """
        SetMin(Message_ProgressScale self, Standard_Real const theMin)

        Sets minimum value of scale

        :type theMin: float

        """
        return _Message.Message_ProgressScale_SetMin(self, *args)


    def GetMin(self, *args):
        """
        GetMin(Message_ProgressScale self) -> Standard_Real

        Gets minimum value of scale

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Message.Message_ProgressScale_GetMin(self, *args)


    def SetMax(self, *args):
        """
        SetMax(Message_ProgressScale self, Standard_Real const theMax)

        Sets minimum value of scale

        :type theMax: float

        """
        return _Message.Message_ProgressScale_SetMax(self, *args)


    def GetMax(self, *args):
        """
        GetMax(Message_ProgressScale self) -> Standard_Real

        Gets minimum value of scale

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Message.Message_ProgressScale_GetMax(self, *args)


    def SetRange(self, *args):
        """
        SetRange(Message_ProgressScale self, Standard_Real const min, Standard_Real const max)

        Set both min and max

        :type min: float
        :type max: float

        """
        return _Message.Message_ProgressScale_SetRange(self, *args)


    def SetStep(self, *args):
        """
        SetStep(Message_ProgressScale self, Standard_Real const theStep)

        Sets default step

        :type theStep: float

        """
        return _Message.Message_ProgressScale_SetStep(self, *args)


    def GetStep(self, *args):
        """
        GetStep(Message_ProgressScale self) -> Standard_Real

        Gets default step

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Message.Message_ProgressScale_GetStep(self, *args)


    def SetInfinite(self, *args):
        """
        SetInfinite(Message_ProgressScale self, Standard_Boolean const theInfinite)

        Sets flag for infinite scale

        :type theInfinite: bool

        """
        return _Message.Message_ProgressScale_SetInfinite(self, *args)


    def GetInfinite(self, *args):
        """
        GetInfinite(Message_ProgressScale self) -> Standard_Boolean

        Gets flag for infinite scale

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Message.Message_ProgressScale_GetInfinite(self, *args)


    def SetScale(self, *args):
        """
        SetScale(Message_ProgressScale self, Standard_Real const min, Standard_Real const max, Standard_Real const step, Standard_Boolean const theInfinite)

        Set all scale parameters

        :type min: float
        :type max: float
        :type step: float
        :type theInfinite: bool

        """
        return _Message.Message_ProgressScale_SetScale(self, *args)


    def SetSpan(self, *args):
        """
        SetSpan(Message_ProgressScale self, Standard_Real const first, Standard_Real const last)

        Defines span occupied by the scale on the basis scale

        :type first: float
        :type last: float

        """
        return _Message.Message_ProgressScale_SetSpan(self, *args)


    def GetFirst(self, *args):
        """
        GetFirst(Message_ProgressScale self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Message.Message_ProgressScale_GetFirst(self, *args)


    def GetLast(self, *args):
        """
        GetLast(Message_ProgressScale self) -> Standard_Real

        Return information on span occupied by the scale on the base scale

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Message.Message_ProgressScale_GetLast(self, *args)


    def LocalToBase(self, *args):
        """
        LocalToBase(Message_ProgressScale self, Standard_Real const val) -> Standard_Real

        :type val: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Message.Message_ProgressScale_LocalToBase(self, *args)


    def BaseToLocal(self, *args):
        """
        BaseToLocal(Message_ProgressScale self, Standard_Real const val) -> Standard_Real

        Convert value from this scale to base one and back

        :type val: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Message.Message_ProgressScale_BaseToLocal(self, *args)

    __swig_destroy__ = _Message.delete_Message_ProgressScale
Message_ProgressScale_swigregister = _Message.Message_ProgressScale_swigregister
Message_ProgressScale_swigregister(Message_ProgressScale)

class Message_ProgressIndicator(Standard.Standard_Transient):
    """
    Defines abstract interface from program to the "user".
    This includes progress indication and user break mechanisms.

    The process that uses the progress indicator interacts with it as
    with a scale whose range and step can be configured according to
    the nature of the process.
    The scale can be made "infinite", which means it will grow
    non-linearly, and end of scale will be approached asymptotically at
    infinite number of steps. In that case the range defines
    a number of steps corresponding to position at 1/2 of scale.
    The current position can be either set directly (in a range from
    current position to maximum scale value), or incremented step
    by step.

    Progress indication mechanism is adapted for convenient
    usage in hiererchical processes that require indication of
    progress at several levels of the process nesting.
    For that purpose, it is possible to create restricted sub-scope of
    indication by specifying part of a current scale to be
    used by the subprocess.
    When subprocess works with progress indicator in the restricted
    scope, it has the same interface to a scale, while actually it
    deals only with part of the whole scale.

    The recommended way to implement progress indication in the algorithm
    is to use class Message_ProgressSentry that provides iterator-like
    interface for incrementing progress and opening nested scopes.

    NOTE:
    Currently there is no support for concurrent progress
    indicator that could be useful in multithreaded applications.

    The user break is implemented as virtual function that should
    return True in case if break signal from the user is received.

    The derived class should take care of visualisation of the
    progress indicator (e.g. show total position at the graphical bar,
    print scopes in text mode, or else), and for implementation
    of user break mechanism (if necessary).
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Message_ProgressIndicator
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Message_ProgressIndicator(self) 
            return h


    def Reset(self, *args):
        """
        Reset(Message_ProgressIndicator self)

        Drops all scopes and sets scale from 0 to 100, step 1
        This scale has name "Step"


        """
        return _Message.Message_ProgressIndicator_Reset(self, *args)


    def SetName(self, *args):
        """
        SetName(Message_ProgressIndicator self, Standard_CString const name)
        SetName(Message_ProgressIndicator self, Handle_TCollection_HAsciiString name)

        Set (optional) name for scale

        :type name: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _Message.Message_ProgressIndicator_SetName(self, *args)


    def SetRange(self, *args):
        """
        SetRange(Message_ProgressIndicator self, Standard_Real const min, Standard_Real const max)

        Set range for current scale

        :type min: float
        :type max: float

        """
        return _Message.Message_ProgressIndicator_SetRange(self, *args)


    def SetStep(self, *args):
        """
        SetStep(Message_ProgressIndicator self, Standard_Real const step)

        Set step for current scale

        :type step: float

        """
        return _Message.Message_ProgressIndicator_SetStep(self, *args)


    def SetInfinite(self, *args):
        """
        SetInfinite(Message_ProgressIndicator self, Standard_Boolean const isInf)

        Set or drop infinite mode for the current scale

        :type isInf: bool

        """
        return _Message.Message_ProgressIndicator_SetInfinite(self, *args)


    def SetScale(self, *args):
        """
        SetScale(Message_ProgressIndicator self, Standard_CString const name, Standard_Real const min, Standard_Real const max, Standard_Real const step, Standard_Boolean const isInf)
        SetScale(Message_ProgressIndicator self, Standard_Real const min, Standard_Real const max, Standard_Real const step, Standard_Boolean const isInf)

        Set all parameters for current scale

        :type min: float
        :type max: float
        :type step: float
        :type isInf: bool

        """
        return _Message.Message_ProgressIndicator_SetScale(self, *args)


    def GetScale(self, *args):
        """
        GetScale(Message_ProgressIndicator self)

        Returns all parameters for current scale

        :type min: float
        :type max: float
        :type step: float
        :type isInf: bool

        """
        return _Message.Message_ProgressIndicator_GetScale(self, *args)


    def SetValue(self, *args):
        """
        SetValue(Message_ProgressIndicator self, Standard_Real const val)

        :type val: float

        """
        return _Message.Message_ProgressIndicator_SetValue(self, *args)


    def GetValue(self, *args):
        """
        GetValue(Message_ProgressIndicator self) -> Standard_Real

        Set and get progress value at current scale
        If the value to be set is more than currently set one, or out
        of range for the current scale, it is limited by that range

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Message.Message_ProgressIndicator_GetValue(self, *args)


    def Increment(self, *args):
        """
        Increment(Message_ProgressIndicator self)
        Increment(Message_ProgressIndicator self, Standard_Real const step)

        Increment the progress value by the default of specified step

        :type step: float

        """
        return _Message.Message_ProgressIndicator_Increment(self, *args)


    def NewScope(self, *args):
        """
        NewScope(Message_ProgressIndicator self, Standard_CString const name=None) -> Standard_Boolean
        NewScope(Message_ProgressIndicator self, Handle_TCollection_HAsciiString name) -> Standard_Boolean
        NewScope(Message_ProgressIndicator self, Standard_Real const span, Standard_CString const name=None) -> Standard_Boolean
        NewScope(Message_ProgressIndicator self, Standard_Real const span, Handle_TCollection_HAsciiString name) -> Standard_Boolean

        Creates new scope on a part of a current scale from current
        position with span either equal to default step, or specified
        The scale for the new scope will have specified name and
        ranged from 0 to 100 with step 1
        Returns False if something is wrong in arguments or in current
        position of progress indicator; scope is opened anyway

        :type span: float
        :type name: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Message.Message_ProgressIndicator_NewScope(self, *args)


    def EndScope(self, *args):
        """
        EndScope(Message_ProgressIndicator self) -> Standard_Boolean

        Close the current scope and thus return to previous scale
        Updates position to be at the end of the closing scope
        Returns False if no scope is opened

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Message.Message_ProgressIndicator_EndScope(self, *args)


    def NextScope(self, *args):
        """
        NextScope(Message_ProgressIndicator self, Standard_CString const name=None) -> Standard_Boolean
        NextScope(Message_ProgressIndicator self, Standard_Real const span, Standard_CString const name=None) -> Standard_Boolean

        Optimized version of { return EndScope() && NewScope(); }

        :type span: float
        :type name: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Message.Message_ProgressIndicator_NextScope(self, *args)


    def UserBreak(self, *args):
        """
        UserBreak(Message_ProgressIndicator self) -> Standard_Boolean

        Should return True if user has send a break signal.
        Default implementation returns False.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Message.Message_ProgressIndicator_UserBreak(self, *args)


    def Show(self, *args):
        """
        Show(Message_ProgressIndicator self, Standard_Boolean const force) -> Standard_Boolean

        Update presentation of the progress indicator
        Called when progress position is changed
        Flag force is intended for forcing update in case if it is
        optimized; all internal calls from ProgressIndicator are
        done with this flag equal to False

        :type force: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Message.Message_ProgressIndicator_Show(self, *args)


    def GetPosition(self, *args):
        """
        GetPosition(Message_ProgressIndicator self) -> Standard_Real

        Returns total progress position on the basic scale
        ranged from 0. to 1.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Message.Message_ProgressIndicator_GetPosition(self, *args)


    def GetNbScopes(self, *args):
        """
        GetNbScopes(Message_ProgressIndicator self) -> Standard_Integer

        Returns current number of opened scopes
        This number is always >=1 as top-level scale is always present

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Message.Message_ProgressIndicator_GetNbScopes(self, *args)


    def GetScope(self, *args):
        """
        Returns data for scale of index-th scope
        The first scope is current one, the last is the top-level one

        :type index: int
        :rtype: OCC.wrapper.Message.Message_ProgressScale

        """
        res = _Message.Message_ProgressIndicator_GetScope(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Message.Message_ProgressIndicator_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Message.Message_ProgressIndicator_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Message.Message_ProgressIndicator_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Message.delete_Message_ProgressIndicator
Message_ProgressIndicator_swigregister = _Message.Message_ProgressIndicator_swigregister
Message_ProgressIndicator_swigregister(Message_ProgressIndicator)

def Message_ProgressIndicator_get_type_name(*args):
    """
    Message_ProgressIndicator_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Message.Message_ProgressIndicator_get_type_name(*args)

def Message_ProgressIndicator_get_type_descriptor(*args):
    """
    Message_ProgressIndicator_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Message.Message_ProgressIndicator_get_type_descriptor(*args)

class Handle_Message_ProgressIndicator(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Message_ProgressIndicator self)

        Nullify the handle


        """
        return _Message.Handle_Message_ProgressIndicator_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Message_ProgressIndicator self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Message.Handle_Message_ProgressIndicator_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Message_ProgressIndicator self, Message_ProgressIndicator thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Message.Handle_Message_ProgressIndicator_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Message_ProgressIndicator self, Handle_Message_ProgressIndicator theHandle) -> Handle_Message_ProgressIndicator
        assign(Handle_Message_ProgressIndicator self, Message_ProgressIndicator thePtr) -> Handle_Message_ProgressIndicator
        assign(Handle_Message_ProgressIndicator self, Handle_Message_ProgressIndicator theHandle) -> Handle_Message_ProgressIndicator

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Message.Handle_Message_ProgressIndicator_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Message_ProgressIndicator self) -> Message_ProgressIndicator

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Message.Handle_Message_ProgressIndicator_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Message_ProgressIndicator self) -> Message_ProgressIndicator

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Message.Handle_Message_ProgressIndicator___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Message_ProgressIndicator self) -> Message_ProgressIndicator

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Message.Handle_Message_ProgressIndicator___ref__(self, *args)


    def __hash__(self):
        return _Message.Handle_Message_ProgressIndicator___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Message.Handle_Message_ProgressIndicator___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Message.new_Handle_Message_ProgressIndicator(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Message.Handle_Message_ProgressIndicator_DownCast)
    __swig_destroy__ = _Message.delete_Handle_Message_ProgressIndicator

    def Reset(self, *args):
        """
        Reset(Handle_Message_ProgressIndicator self)

        Drops all scopes and sets scale from 0 to 100, step 1
        This scale has name "Step"


        """
        return _Message.Handle_Message_ProgressIndicator_Reset(self, *args)


    def SetName(self, *args):
        """
        SetName(Handle_Message_ProgressIndicator self, Standard_CString const name)
        SetName(Handle_Message_ProgressIndicator self, Handle_TCollection_HAsciiString name)

        Set (optional) name for scale

        :type name: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _Message.Handle_Message_ProgressIndicator_SetName(self, *args)


    def SetRange(self, *args):
        """
        SetRange(Handle_Message_ProgressIndicator self, Standard_Real const min, Standard_Real const max)

        Set range for current scale

        :type min: float
        :type max: float

        """
        return _Message.Handle_Message_ProgressIndicator_SetRange(self, *args)


    def SetStep(self, *args):
        """
        SetStep(Handle_Message_ProgressIndicator self, Standard_Real const step)

        Set step for current scale

        :type step: float

        """
        return _Message.Handle_Message_ProgressIndicator_SetStep(self, *args)


    def SetInfinite(self, *args):
        """
        SetInfinite(Handle_Message_ProgressIndicator self, Standard_Boolean const isInf)

        Set or drop infinite mode for the current scale

        :type isInf: bool

        """
        return _Message.Handle_Message_ProgressIndicator_SetInfinite(self, *args)


    def SetScale(self, *args):
        """
        SetScale(Handle_Message_ProgressIndicator self, Standard_CString const name, Standard_Real const min, Standard_Real const max, Standard_Real const step, Standard_Boolean const isInf)
        SetScale(Handle_Message_ProgressIndicator self, Standard_Real const min, Standard_Real const max, Standard_Real const step, Standard_Boolean const isInf)

        Set all parameters for current scale

        :type min: float
        :type max: float
        :type step: float
        :type isInf: bool

        """
        return _Message.Handle_Message_ProgressIndicator_SetScale(self, *args)


    def GetScale(self, *args):
        """
        GetScale(Handle_Message_ProgressIndicator self)

        Returns all parameters for current scale

        :type min: float
        :type max: float
        :type step: float
        :type isInf: bool

        """
        return _Message.Handle_Message_ProgressIndicator_GetScale(self, *args)


    def SetValue(self, *args):
        """
        SetValue(Handle_Message_ProgressIndicator self, Standard_Real const val)

        :type val: float

        """
        return _Message.Handle_Message_ProgressIndicator_SetValue(self, *args)


    def GetValue(self, *args):
        """
        GetValue(Handle_Message_ProgressIndicator self) -> Standard_Real

        Set and get progress value at current scale
        If the value to be set is more than currently set one, or out
        of range for the current scale, it is limited by that range

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Message.Handle_Message_ProgressIndicator_GetValue(self, *args)


    def Increment(self, *args):
        """
        Increment(Handle_Message_ProgressIndicator self)
        Increment(Handle_Message_ProgressIndicator self, Standard_Real const step)

        Increment the progress value by the default of specified step

        :type step: float

        """
        return _Message.Handle_Message_ProgressIndicator_Increment(self, *args)


    def NewScope(self, *args):
        """
        NewScope(Handle_Message_ProgressIndicator self, Standard_CString const name=None) -> Standard_Boolean
        NewScope(Handle_Message_ProgressIndicator self, Handle_TCollection_HAsciiString name) -> Standard_Boolean
        NewScope(Handle_Message_ProgressIndicator self, Standard_Real const span, Standard_CString const name=None) -> Standard_Boolean
        NewScope(Handle_Message_ProgressIndicator self, Standard_Real const span, Handle_TCollection_HAsciiString name) -> Standard_Boolean

        Creates new scope on a part of a current scale from current
        position with span either equal to default step, or specified
        The scale for the new scope will have specified name and
        ranged from 0 to 100 with step 1
        Returns False if something is wrong in arguments or in current
        position of progress indicator; scope is opened anyway

        :type span: float
        :type name: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Message.Handle_Message_ProgressIndicator_NewScope(self, *args)


    def EndScope(self, *args):
        """
        EndScope(Handle_Message_ProgressIndicator self) -> Standard_Boolean

        Close the current scope and thus return to previous scale
        Updates position to be at the end of the closing scope
        Returns False if no scope is opened

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Message.Handle_Message_ProgressIndicator_EndScope(self, *args)


    def NextScope(self, *args):
        """
        NextScope(Handle_Message_ProgressIndicator self, Standard_CString const name=None) -> Standard_Boolean
        NextScope(Handle_Message_ProgressIndicator self, Standard_Real const span, Standard_CString const name=None) -> Standard_Boolean

        Optimized version of { return EndScope() && NewScope(); }

        :type span: float
        :type name: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Message.Handle_Message_ProgressIndicator_NextScope(self, *args)


    def UserBreak(self, *args):
        """
        UserBreak(Handle_Message_ProgressIndicator self) -> Standard_Boolean

        Should return True if user has send a break signal.
        Default implementation returns False.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Message.Handle_Message_ProgressIndicator_UserBreak(self, *args)


    def Show(self, *args):
        """
        Show(Handle_Message_ProgressIndicator self, Standard_Boolean const force) -> Standard_Boolean

        Update presentation of the progress indicator
        Called when progress position is changed
        Flag force is intended for forcing update in case if it is
        optimized; all internal calls from ProgressIndicator are
        done with this flag equal to False

        :type force: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Message.Handle_Message_ProgressIndicator_Show(self, *args)


    def GetPosition(self, *args):
        """
        GetPosition(Handle_Message_ProgressIndicator self) -> Standard_Real

        Returns total progress position on the basic scale
        ranged from 0. to 1.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Message.Handle_Message_ProgressIndicator_GetPosition(self, *args)


    def GetNbScopes(self, *args):
        """
        GetNbScopes(Handle_Message_ProgressIndicator self) -> Standard_Integer

        Returns current number of opened scopes
        This number is always >=1 as top-level scale is always present

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Message.Handle_Message_ProgressIndicator_GetNbScopes(self, *args)


    def GetScope(self, *args):
        """
        Returns data for scale of index-th scope
        The first scope is current one, the last is the top-level one

        :type index: int
        :rtype: OCC.wrapper.Message.Message_ProgressScale

        """
        res = _Message.Handle_Message_ProgressIndicator_GetScope(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def get_type_name(self, *args):
        """
        get_type_name(Handle_Message_ProgressIndicator self) -> char const *

        :rtype: const char *

        """
        return _Message.Handle_Message_ProgressIndicator_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Message.Handle_Message_ProgressIndicator_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Message.Handle_Message_ProgressIndicator_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_Message_ProgressIndicator self)

        Memory deallocator for transient classes


        """
        return _Message.Handle_Message_ProgressIndicator_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Message_ProgressIndicator self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Message_ProgressIndicator self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Message.Handle_Message_ProgressIndicator_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Message_ProgressIndicator self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Message_ProgressIndicator self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Message.Handle_Message_ProgressIndicator_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Message_ProgressIndicator self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Message.Handle_Message_ProgressIndicator_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Message_ProgressIndicator self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Message.Handle_Message_ProgressIndicator_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Message_ProgressIndicator self)

        Increments the reference counter of this object


        """
        return _Message.Handle_Message_ProgressIndicator_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Message_ProgressIndicator self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Message.Handle_Message_ProgressIndicator_DecrementRefCounter(self, *args)

Handle_Message_ProgressIndicator_swigregister = _Message.Handle_Message_ProgressIndicator_swigregister
Handle_Message_ProgressIndicator_swigregister(Handle_Message_ProgressIndicator)

def Handle_Message_ProgressIndicator_DownCast(thing):
    return _Message.Handle_Message_ProgressIndicator_DownCast(thing)
Handle_Message_ProgressIndicator_DownCast = _Message.Handle_Message_ProgressIndicator_DownCast

class Handle_Message_PrinterOStream(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Message_PrinterOStream self)

        Nullify the handle


        """
        return _Message.Handle_Message_PrinterOStream_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Message_PrinterOStream self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Message.Handle_Message_PrinterOStream_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Message_PrinterOStream self, Message_PrinterOStream thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Message.Handle_Message_PrinterOStream_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Message_PrinterOStream self, Handle_Message_PrinterOStream theHandle) -> Handle_Message_PrinterOStream
        assign(Handle_Message_PrinterOStream self, Message_PrinterOStream thePtr) -> Handle_Message_PrinterOStream
        assign(Handle_Message_PrinterOStream self, Handle_Message_PrinterOStream theHandle) -> Handle_Message_PrinterOStream

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Message.Handle_Message_PrinterOStream_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Message_PrinterOStream self) -> Message_PrinterOStream

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Message.Handle_Message_PrinterOStream_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Message_PrinterOStream self) -> Message_PrinterOStream

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Message.Handle_Message_PrinterOStream___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Message_PrinterOStream self) -> Message_PrinterOStream

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Message.Handle_Message_PrinterOStream___ref__(self, *args)


    def __hash__(self):
        return _Message.Handle_Message_PrinterOStream___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Message.Handle_Message_PrinterOStream___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Message.new_Handle_Message_PrinterOStream(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Message.Handle_Message_PrinterOStream_DownCast)
    __swig_destroy__ = _Message.delete_Handle_Message_PrinterOStream

    def get_type_name(self, *args):
        """
        get_type_name(Handle_Message_PrinterOStream self) -> char const *

        :rtype: const char *

        """
        return _Message.Handle_Message_PrinterOStream_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Message.Handle_Message_PrinterOStream_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Message.Handle_Message_PrinterOStream_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Close(self, *args):
        """
        Close(Handle_Message_PrinterOStream self)

        Flushes the output stream and destroys it if it has been
        specified externally with option doFree (or if it is internal
        file stream)


        """
        return _Message.Handle_Message_PrinterOStream_Close(self, *args)


    def GetUseUtf8(self, *args):
        """
        GetUseUtf8(Handle_Message_PrinterOStream self) -> Standard_Boolean

        Returns option to convert non-Ascii symbols to UTF8 encoding

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Message.Handle_Message_PrinterOStream_GetUseUtf8(self, *args)


    def SetUseUtf8(self, *args):
        """
        SetUseUtf8(Handle_Message_PrinterOStream self, Standard_Boolean const useUtf8)

        Sets option to convert non-Ascii symbols to UTF8 encoding

        :type useUtf8: bool

        """
        return _Message.Handle_Message_PrinterOStream_SetUseUtf8(self, *args)


    def GetStream(self, *args):
        """
        GetStream(Handle_Message_PrinterOStream self) -> Standard_OStream &

        Returns reference to the output stream

        :rtype: OCC.wrapper.Standard.Standard_OStream

        """
        return _Message.Handle_Message_PrinterOStream_GetStream(self, *args)


    def Send(self, *args):
        """
        Send(Handle_Message_PrinterOStream self, Standard_CString const theString, Message_Gravity const theGravity, Standard_Boolean const putEndl)
        Send(Handle_Message_PrinterOStream self, TCollection_AsciiString theString, Message_Gravity const theGravity, Standard_Boolean const putEndl)
        Send(Handle_Message_PrinterOStream self, TCollection_ExtendedString theString, Message_Gravity const theGravity, Standard_Boolean const putEndl)

        Puts a message to the current stream
        if its gravity is equal or greater
        to the trace level set by SetTraceLevel()
        Non-Ascii symbols are converted to UTF-8 if UseUtf8
        option is set, else replaced by symbols '?'

        :type theString: OCC.wrapper.TCollection.TCollection_ExtendedString
        :type theGravity: OCC.wrapper.Message.Message_Gravity
        :type putEndl: bool

        """
        return _Message.Handle_Message_PrinterOStream_Send(self, *args)


    def GetTraceLevel(self, *args):
        """
        GetTraceLevel(Handle_Message_PrinterOStream self) -> Message_Gravity

        Return trace level used for filtering messages;
        messages with lover gravity will be ignored.

        :rtype: OCC.wrapper.Message.Message_Gravity

        """
        return _Message.Handle_Message_PrinterOStream_GetTraceLevel(self, *args)


    def SetTraceLevel(self, *args):
        """
        SetTraceLevel(Handle_Message_PrinterOStream self, Message_Gravity const theTraceLevel)

        Set trace level used for filtering messages.
        By default, trace level is Message_Info, so that all messages are output

        :type theTraceLevel: OCC.wrapper.Message.Message_Gravity

        """
        return _Message.Handle_Message_PrinterOStream_SetTraceLevel(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_Message_PrinterOStream self)

        Memory deallocator for transient classes


        """
        return _Message.Handle_Message_PrinterOStream_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Message_PrinterOStream self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Message_PrinterOStream self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Message.Handle_Message_PrinterOStream_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Message_PrinterOStream self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Message_PrinterOStream self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Message.Handle_Message_PrinterOStream_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Message_PrinterOStream self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Message.Handle_Message_PrinterOStream_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Message_PrinterOStream self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Message.Handle_Message_PrinterOStream_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Message_PrinterOStream self)

        Increments the reference counter of this object


        """
        return _Message.Handle_Message_PrinterOStream_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Message_PrinterOStream self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Message.Handle_Message_PrinterOStream_DecrementRefCounter(self, *args)

Handle_Message_PrinterOStream_swigregister = _Message.Handle_Message_PrinterOStream_swigregister
Handle_Message_PrinterOStream_swigregister(Handle_Message_PrinterOStream)

def Handle_Message_PrinterOStream_DownCast(thing):
    return _Message.Handle_Message_PrinterOStream_DownCast(thing)
Handle_Message_PrinterOStream_DownCast = _Message.Handle_Message_PrinterOStream_DownCast

class Message_Msg(object):
    """
    This class provides a tool for constructing the parametrized message
    basing on resources loaded by Message_MsgFile tool.

    A Message is created from a keyword: this keyword identifies the
    message in a message file that should be previously loaded by call
    to Message_MsgFile::LoadFile().

    The text of the message can contain placeholders for the parameters
    which are to be filled by the proper values when the message
    is prepared. Most of the format specifiers used in C can be used,
    for instance, %s for string, %d for integer etc. In addition,
    specifier %f is supported for double numbers (for compatibility
    with previous versions).

    User fills the parameter fields in the text of the message by
    calling corresponding methods Arg() or operators .

    The resulting message, filled with all parameters, can be obtained
    by method Get(). If some parameters were not filled, the text
    UNKNOWN is placed instead.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Message_Msg self) -> Message_Msg
        __init__(Message_Msg self, Message_Msg theMsg) -> Message_Msg
        __init__(Message_Msg self, Standard_CString const theKey) -> Message_Msg
        __init__(Message_Msg self, TCollection_ExtendedString theKey) -> Message_Msg

        Create a message using a corresponding entry in Message_MsgFile

        :type theKey: OCC.wrapper.TCollection.TCollection_ExtendedString

        """
        this = _Message.new_Message_Msg(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Set(self, *args):
        """
        Set(Message_Msg self, Standard_CString const theMsg)
        Set(Message_Msg self, TCollection_ExtendedString theMsg)

        Set a message body text -- can be used as alternative to
        using messages from resource file

        :type theMsg: OCC.wrapper.TCollection.TCollection_ExtendedString

        """
        return _Message.Message_Msg_Set(self, *args)


    def Arg(self, *args):
        """
        Arg(Message_Msg self, Standard_CString const theString) -> Message_Msg
        Arg(Message_Msg self, TCollection_AsciiString theString) -> Message_Msg
        Arg(Message_Msg self, Handle_TCollection_HAsciiString theString) -> Message_Msg
        Arg(Message_Msg self, TCollection_ExtendedString theString) -> Message_Msg
        Arg(Message_Msg self, Handle_TCollection_HExtendedString theString) -> Message_Msg
        Arg(Message_Msg self, Standard_Integer const theInt) -> Message_Msg
        Arg(Message_Msg self, Standard_Real const theReal) -> Message_Msg

        Set a value for %..f, %..e, %..E, %..g or %..G conversion

        :type theReal: float
        :rtype: OCC.wrapper.Message.Message_Msg

        """
        return _Message.Message_Msg_Arg(self, *args)


    def __lshift__(self, *args):
        """
        __lshift__(Message_Msg self, Standard_CString const theString) -> Message_Msg
        __lshift__(Message_Msg self, TCollection_AsciiString theString) -> Message_Msg
        __lshift__(Message_Msg self, Handle_TCollection_HAsciiString theString) -> Message_Msg
        __lshift__(Message_Msg self, TCollection_ExtendedString theString) -> Message_Msg
        __lshift__(Message_Msg self, Handle_TCollection_HExtendedString theString) -> Message_Msg
        __lshift__(Message_Msg self, Standard_Integer const theInt) -> Message_Msg
        __lshift__(Message_Msg self, Standard_Real const theReal) -> Message_Msg

        :type theReal: float
        :rtype: OCC.wrapper.Message.Message_Msg

        """
        return _Message.Message_Msg___lshift__(self, *args)


    def Original(self, *args):
        """
        Returns the original message text

        :rtype: OCC.wrapper.TCollection.TCollection_ExtendedString

        """
        res = _Message.Message_Msg_Original(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Value(self, *args):
        """
        Returns current state of the message text with
        parameters to the moment

        :rtype: OCC.wrapper.TCollection.TCollection_ExtendedString

        """
        res = _Message.Message_Msg_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def IsEdited(self, *args):
        """
        IsEdited(Message_Msg self) -> Standard_Boolean

        Tells if Value differs from Original

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Message.Message_Msg_IsEdited(self, *args)


    def Get(self, *args):
        """
        Return the resulting message string with all parameters
        filled. If some parameters were not yet filled by calls
        to methods Arg (or <<), these parameters are filled by
        the word UNKNOWN

        :rtype: OCC.wrapper.TCollection.TCollection_ExtendedString

        """
        res = _Message.Message_Msg_Get(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Message.delete_Message_Msg
Message_Msg_swigregister = _Message.Message_Msg_swigregister
Message_Msg_swigregister(Message_Msg)

class Message_Messenger(Standard.Standard_Transient):
    """
    Messenger is API class providing general-purpose interface for
    libraries that may issue text messages without knowledge
    of how these messages will be further processed.

    The messenger contains a sequence of "printers" which can be
    customized by the application, and dispatches every received
    message to all the printers.

    For convenience, a number of operators << are defined with left
    argument being Handle(Message_Messenger); thus it can be used
    with syntax similar to C++ streams.
    Note that all these operators use trace level Warning.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Message_Messenger
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Message_Messenger(self) 
            return h


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Message.Message_Messenger_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Message.Message_Messenger_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Message.Message_Messenger_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __init__(self, *args):
        """
        __init__(Message_Messenger self) -> Message_Messenger
        __init__(Message_Messenger self, Handle_Message_Printer thePrinter) -> Message_Messenger

        Create messenger with single printer

        :type thePrinter: OCC.wrapper.Message.Handle_Message_Printer

        """
        this = _Message.new_Message_Messenger(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def RemovePrinter(self, *args):
        """
        RemovePrinter(Message_Messenger self, Handle_Message_Printer thePrinter) -> Standard_Boolean

        Removes specified printer from the messenger.
        Returns True if this printer has been found in the list
        and removed.

        :type thePrinter: OCC.wrapper.Message.Handle_Message_Printer
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Message.Message_Messenger_RemovePrinter(self, *args)


    def RemovePrinters(self, *args):
        """
        RemovePrinters(Message_Messenger self, Handle_Standard_Type theType) -> Standard_Integer

        Removes printers of specified type (including derived classes)
        from the messenger.
        Returns number of removed printers.

        :type theType: OCC.wrapper.Standard.Handle_Standard_Type
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Message.Message_Messenger_RemovePrinters(self, *args)


    def Printers(self, *args):
        """
        Returns current sequence of printers

        :rtype: OCC.wrapper.Message.Message_SequenceOfPrinters

        """
        res = _Message.Message_Messenger_Printers(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangePrinters(self, *args):
        """
        ChangePrinters(Message_Messenger self) -> NCollection_Sequence_Handle_Message_Printer

        Returns sequence of printers
        The sequence can be modified.

        :rtype: OCC.wrapper.Message.Message_SequenceOfPrinters

        """
        return _Message.Message_Messenger_ChangePrinters(self, *args)


    def Send(self, *args):
        """
        Send(Message_Messenger self, Standard_CString const theString, Message_Gravity const theGravity=Message_Warning, Standard_Boolean const putEndl)
        Send(Message_Messenger self, TCollection_AsciiString theString, Message_Gravity const theGravity=Message_Warning, Standard_Boolean const putEndl)
        Send(Message_Messenger self, TCollection_ExtendedString theString, Message_Gravity const theGravity=Message_Warning, Standard_Boolean const putEndl)

        See above

        :type theString: OCC.wrapper.TCollection.TCollection_ExtendedString
        :type theGravity: OCC.wrapper.Message.Message_Gravity
        :type putEndl: bool

        """
        return _Message.Message_Messenger_Send(self, *args)


    def AddPrinter(self, bla):
        return _Message.Message_Messenger_AddPrinter(self, bla)
    __swig_destroy__ = _Message.delete_Message_Messenger
Message_Messenger_swigregister = _Message.Message_Messenger_swigregister
Message_Messenger_swigregister(Message_Messenger)

def Message_Messenger_get_type_name(*args):
    """
    Message_Messenger_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Message.Message_Messenger_get_type_name(*args)

def Message_Messenger_get_type_descriptor(*args):
    """
    Message_Messenger_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Message.Message_Messenger_get_type_descriptor(*args)

class Message_Alert(Standard.Standard_Transient):
    """
    Base class of the hierarchy of classes describing various situations
    occurring during execution of some algorithm or procedure.

    Alert should provide unique text identifier that can be used to distinguish 
    particular type of alerts, e.g. to get text message string describing it. 
    See method GetMessageKey(); by default, dynamic type name is used.

    Alert can contain some data. To avoid duplication of data, new alert
    can be merged with another one of the same type. Method SupportsMerge() 
    should return true if merge is supported; method Merge() should do the
    merge if possible and return true in that case and false otherwise.

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Message_Alert
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Message_Alert(self) 
            return h


    def GetMessageKey(self, *args):
        """
        GetMessageKey(Message_Alert self) -> Standard_CString

        Return a C string to be used as a key for generating text user 
        messages describing this alert.
        The messages are generated with help of Message_Msg class, in
        Message_Report::Dump().
        Base implementation returns dynamic type name of the instance.

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _Message.Message_Alert_GetMessageKey(self, *args)


    def SupportsMerge(self, *args):
        """
        SupportsMerge(Message_Alert self) -> Standard_Boolean

        Return true if this type of alert can be merged with other
        of the same type to avoid duplication.
        Basis implementation returns true.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Message.Message_Alert_SupportsMerge(self, *args)


    def Merge(self, *args):
        """
        Merge(Message_Alert self, Handle_Message_Alert theTarget) -> Standard_Boolean

        If possible, merge data contained in this alert to theTarget.
        @return True if merged.
        Base implementation always returns true.

        :type theTarget: OCC.wrapper.Message.Handle_Message_Alert
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Message.Message_Alert_Merge(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Message.Message_Alert_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Message.Message_Alert_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Message.Message_Alert_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __init__(self):
        """
        Base class of the hierarchy of classes describing various situations
        occurring during execution of some algorithm or procedure.

        Alert should provide unique text identifier that can be used to distinguish 
        particular type of alerts, e.g. to get text message string describing it. 
        See method GetMessageKey(); by default, dynamic type name is used.

        Alert can contain some data. To avoid duplication of data, new alert
        can be merged with another one of the same type. Method SupportsMerge() 
        should return true if merge is supported; method Merge() should do the
        merge if possible and return true in that case and false otherwise.

        """
        this = _Message.new_Message_Alert()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle



    __swig_destroy__ = _Message.delete_Message_Alert
Message_Alert_swigregister = _Message.Message_Alert_swigregister
Message_Alert_swigregister(Message_Alert)

def Message_Alert_get_type_name(*args):
    """
    Message_Alert_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Message.Message_Alert_get_type_name(*args)

def Message_Alert_get_type_descriptor(*args):
    """
    Message_Alert_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Message.Message_Alert_get_type_descriptor(*args)

class Message_Algorithm(Standard.Standard_Transient):
    """
    Class Message_Algorithm is intended to be the base class for
    classes implementing algorithms or any operations that need
    to provide extended information on its execution to the
    caller / user.

    It provides generic mechanism for management of the execution
    status, collection and output of messages.

    The algorithm uses methods SetStatus() to set an execution status.
    It is possible to associate a status with a number or a string
    (second argument of SetStatus() methods) to indicate precisely
    the item (object, element etc.) in the input data which caused
    the problem.

    Each execution status generated by the algorithm has associated
    text message that should be defined in the resouce file loaded
    with call to Message_MsgFile::LoadFile().

    The messages corresponding to the statuses generated during the
    algorithm execution are output to Message_Messenger using
    methods SendMessages(). If status have associated numbers
    or strings, they are included in the message body in place of
    "%s" placeholder which should be present in the message text.

    The name of the message text in the resource file is constructed
    from name of the class and name of the status, separated by dot,
    for instance:

    .TObj_CheckModel.Alarm2
    Error: Some objects (%s) have references to dead object(s)

    If message for the status is not found with prefix of
    the current class type, the same message is searched for the base
    class(es) recursively.

    Message can be set explicitly for the status; in this case the
    above procedure is not used and supplied message is used as is.

    The messages are output to the messenger, stored in the field;
    though messenger can be changed, it is guaranteed to be non-null.
    By default, Message::DefaultMessenger() is used.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Message_Algorithm
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Message_Algorithm(self) 
            return h


    def __init__(self, *args):
        """
        __init__(Message_Algorithm self) -> Message_Algorithm

        Empty constructor


        """
        this = _Message.new_Message_Algorithm(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def SetStatus(self, *args):
        """
        SetStatus(Message_Algorithm self, Message_Status const & theStat)
        SetStatus(Message_Algorithm self, Message_Status const & theStat, Standard_Integer const theInt)
        SetStatus(Message_Algorithm self, Message_Status const & theStat, Standard_CString const theStr, Standard_Boolean const noRepetitions)
        SetStatus(Message_Algorithm self, Message_Status const & theStat, TCollection_AsciiString theStr, Standard_Boolean const noRepetitions)
        SetStatus(Message_Algorithm self, Message_Status const & theStat, Handle_TCollection_HAsciiString theStr, Standard_Boolean const noRepetitions)
        SetStatus(Message_Algorithm self, Message_Status const & theStat, TCollection_ExtendedString theStr, Standard_Boolean const noRepetitions)
        SetStatus(Message_Algorithm self, Message_Status const & theStat, Handle_TCollection_HExtendedString theStr, Standard_Boolean const noRepetitions)
        SetStatus(Message_Algorithm self, Message_Status const & theStat, Message_Msg theMsg)

        Sets status with preformatted message. This message will be
        used directly to report the status; automatic generation of
        status messages will be disabled for it.

        :type theStat: OCC.wrapper.Message.Message_Status
        :type theMsg: OCC.wrapper.Message.Message_Msg

        """
        return _Message.Message_Algorithm_SetStatus(self, *args)


    def GetStatus(self, *args):
        """
        Returns copy of exec status of algorithm

        :rtype: OCC.wrapper.Message.Message_ExecStatus

        """
        res = _Message.Message_Algorithm_GetStatus(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeStatus(self, *args):
        """
        ChangeStatus(Message_Algorithm self) -> Message_ExecStatus

        Returns exec status of algorithm

        :rtype: OCC.wrapper.Message.Message_ExecStatus

        """
        return _Message.Message_Algorithm_ChangeStatus(self, *args)


    def ClearStatus(self, *args):
        """
        ClearStatus(Message_Algorithm self)

        Clear exec status of algorithm


        """
        return _Message.Message_Algorithm_ClearStatus(self, *args)


    def SetMessenger(self, *args):
        """
        SetMessenger(Message_Algorithm self, Handle_Message_Messenger theMsgr)

        Sets messenger to algorithm

        :type theMsgr: OCC.wrapper.Message.Handle_Message_Messenger

        """
        return _Message.Message_Algorithm_SetMessenger(self, *args)


    def GetMessenger(self, *args):
        """
        GetMessenger(Message_Algorithm self) -> Handle_Message_Messenger

        Returns messenger of algorithm.
        The returned handle is always non-null and can
        be used for sending messages.

        :rtype: OCC.wrapper.Message.Handle_Message_Messenger

        """
        return _Message.Message_Algorithm_GetMessenger(self, *args)


    def SendStatusMessages(self, *args):
        """
        SendStatusMessages(Message_Algorithm self, Message_ExecStatus theFilter, Message_Gravity const theTraceLevel=Message_Warning, Standard_Integer const theMaxCount=20)

        Print messages for all status flags that have been set during
        algorithm execution, excluding statuses that are NOT set
        in theFilter.

        The messages are taken from resource file, names being
        constructed as {dynamic class type}.{status name},
        for instance, "Message_Algorithm.Fail5".
        If message is not found in resources for this class and all
        its base types, surrogate text is printed.

        For the statuses having number or string parameters,
        theMaxCount defines maximal number of numbers or strings to be
        included in the message

        Note that this method is virtual; this allows descendant
        classes to customize message output (e.g. by adding
        messages from other sub-algorithms)

        :type theFilter: OCC.wrapper.Message.Message_ExecStatus
        :type theTraceLevel: OCC.wrapper.Message.Message_Gravity
        :type theMaxCount: int

        """
        return _Message.Message_Algorithm_SendStatusMessages(self, *args)


    def SendMessages(self, *args):
        """
        SendMessages(Message_Algorithm self, Message_Gravity const theTraceLevel=Message_Warning, Standard_Integer const theMaxCount=20)

        Convenient variant of SendStatusMessages() with theFilter
        having defined all WARN, ALARM, and FAIL (but not DONE)
        status flags

        :type theTraceLevel: OCC.wrapper.Message.Message_Gravity
        :type theMaxCount: int

        """
        return _Message.Message_Algorithm_SendMessages(self, *args)


    def AddStatus(self, *args):
        """
        AddStatus(Message_Algorithm self, Handle_Message_Algorithm theOther)
        AddStatus(Message_Algorithm self, Message_ExecStatus theStatus, Handle_Message_Algorithm theOther)

        Add statuses to this algorithm from other algorithm, but
        only those items are moved that correspond to statuses
        set in theStatus

        :type theStatus: OCC.wrapper.Message.Message_ExecStatus
        :type theOther: OCC.wrapper.Message.Handle_Message_Algorithm

        """
        return _Message.Message_Algorithm_AddStatus(self, *args)


    def GetMessageNumbers(self, *args):
        """
        GetMessageNumbers(Message_Algorithm self, Message_Status const & theStatus) -> Handle_TColStd_HPackedMapOfInteger

        Return the numbers associated with the indicated status;
        Null handle if no such status or no numbers associated with it

        :type theStatus: OCC.wrapper.Message.Message_Status
        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HPackedMapOfInteger

        """
        return _Message.Message_Algorithm_GetMessageNumbers(self, *args)


    def GetMessageStrings(self, *args):
        """
        GetMessageStrings(Message_Algorithm self, Message_Status const & theStatus) -> Handle_TColStd_HSequenceOfHExtendedString

        Return the strings associated with the indicated status;
        Null handle if no such status or no strings associated with it

        :type theStatus: OCC.wrapper.Message.Message_Status
        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfHExtendedString

        """
        return _Message.Message_Algorithm_GetMessageStrings(self, *args)


    def PrepareReport(*args):
        """
        PrepareReport(Handle_TColStd_HPackedMapOfInteger theError, Standard_Integer const theMaxCount) -> TCollection_ExtendedString
        PrepareReport(NCollection_Sequence_Handle_TCollection_HExtendedString theReportSeq, Standard_Integer const theMaxCount) -> TCollection_ExtendedString

        Prepares a string containing a list of names contained
        in theReportSeq sequence, but not more than theMaxCount

        :type theReportSeq: OCC.wrapper.TColStd.TColStd_SequenceOfHExtendedString
        :type theMaxCount: int
        :rtype: OCC.wrapper.TCollection.TCollection_ExtendedString

        """
        return _Message.Message_Algorithm_PrepareReport(*args)

    PrepareReport = staticmethod(PrepareReport)

    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Message.Message_Algorithm_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Message.Message_Algorithm_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Message.Message_Algorithm_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Message.delete_Message_Algorithm
Message_Algorithm_swigregister = _Message.Message_Algorithm_swigregister
Message_Algorithm_swigregister(Message_Algorithm)

def Message_Algorithm_PrepareReport(*args):
    """
    PrepareReport(Handle_TColStd_HPackedMapOfInteger theError, Standard_Integer const theMaxCount) -> TCollection_ExtendedString
    Message_Algorithm_PrepareReport(NCollection_Sequence_Handle_TCollection_HExtendedString theReportSeq, Standard_Integer const theMaxCount) -> TCollection_ExtendedString

    Prepares a string containing a list of names contained
    in theReportSeq sequence, but not more than theMaxCount

    :type theReportSeq: OCC.wrapper.TColStd.TColStd_SequenceOfHExtendedString
    :type theMaxCount: int
    :rtype: OCC.wrapper.TCollection.TCollection_ExtendedString

    """
    return _Message.Message_Algorithm_PrepareReport(*args)

def Message_Algorithm_get_type_name(*args):
    """
    Message_Algorithm_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Message.Message_Algorithm_get_type_name(*args)

def Message_Algorithm_get_type_descriptor(*args):
    """
    Message_Algorithm_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Message.Message_Algorithm_get_type_descriptor(*args)

class Message_(object):
    """
    Defines
    - tools to work with messages
    - basic tools intended for progress indication
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def DefaultMessenger(*args):
        """
        DefaultMessenger() -> Handle_Message_Messenger

        Defines default messenger for OCCT applications.
        This is global static instance of the messenger.
        By default, it contains single printer directed to cout.
        It can be customized according to the application needs.

        :rtype: OCC.wrapper.Message.Handle_Message_Messenger

        """
        return _Message.Message__DefaultMessenger(*args)

    DefaultMessenger = staticmethod(DefaultMessenger)

    def FillTime(*args):
        """
        FillTime(Standard_Integer const Hour, Standard_Integer const Minute, Standard_Real const Second) -> TCollection_AsciiString

        Returns the string filled with values of hours, minutes and seconds.
        Example:
        1. (5, 12, 26.3345) returns "05h:12m:26.33s",
        2. (0,  6, 34.496 ) returns "06m:34.50s",
        3. (0,  0,  4.5   ) returns "4.50s"

        :type Hour: int
        :type Minute: int
        :type Second: float
        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _Message.Message__FillTime(*args)

    FillTime = staticmethod(FillTime)

    def __init__(self):
        """
        Defines
        - tools to work with messages
        - basic tools intended for progress indication
        """
        this = _Message.new_Message_()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _Message.delete_Message_
Message__swigregister = _Message.Message__swigregister
Message__swigregister(Message_)

def Message__DefaultMessenger(*args):
    """
    Message__DefaultMessenger() -> Handle_Message_Messenger

    Defines default messenger for OCCT applications.
    This is global static instance of the messenger.
    By default, it contains single printer directed to cout.
    It can be customized according to the application needs.

    :rtype: OCC.wrapper.Message.Handle_Message_Messenger

    """
    return _Message.Message__DefaultMessenger(*args)

def Message__FillTime(*args):
    """
    Message__FillTime(Standard_Integer const Hour, Standard_Integer const Minute, Standard_Real const Second) -> TCollection_AsciiString

    Returns the string filled with values of hours, minutes and seconds.
    Example:
    1. (5, 12, 26.3345) returns "05h:12m:26.33s",
    2. (0,  6, 34.496 ) returns "06m:34.50s",
    3. (0,  0,  4.5   ) returns "4.50s"

    :type Hour: int
    :type Minute: int
    :type Second: float
    :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

    """
    return _Message.Message__FillTime(*args)

class Handle_Message_Report(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Message_Report self)

        Nullify the handle


        """
        return _Message.Handle_Message_Report_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Message_Report self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Message.Handle_Message_Report_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Message_Report self, Message_Report thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Message.Handle_Message_Report_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Message_Report self, Handle_Message_Report theHandle) -> Handle_Message_Report
        assign(Handle_Message_Report self, Message_Report thePtr) -> Handle_Message_Report
        assign(Handle_Message_Report self, Handle_Message_Report theHandle) -> Handle_Message_Report

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Message.Handle_Message_Report_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Message_Report self) -> Message_Report

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Message.Handle_Message_Report_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Message_Report self) -> Message_Report

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Message.Handle_Message_Report___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Message_Report self) -> Message_Report

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Message.Handle_Message_Report___ref__(self, *args)


    def __hash__(self):
        return _Message.Handle_Message_Report___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Message.Handle_Message_Report___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Message.new_Handle_Message_Report(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Message.Handle_Message_Report_DownCast)
    __swig_destroy__ = _Message.delete_Handle_Message_Report

    def AddAlert(self, *args):
        """
        AddAlert(Handle_Message_Report self, Message_Gravity theGravity, Handle_Message_Alert theAlert)

        Add alert with specified gravity.
        This method is thread-safe, i.e. alerts can be added from parallel threads safely.

        :type theGravity: OCC.wrapper.Message.Message_Gravity
        :type theAlert: OCC.wrapper.Message.Handle_Message_Alert

        """
        return _Message.Handle_Message_Report_AddAlert(self, *args)


    def GetAlerts(self, *args):
        """
        Returns list of collected alerts with specified gravity

        :type theGravity: OCC.wrapper.Message.Message_Gravity
        :rtype: OCC.wrapper.Message.Message_ListOfAlert

        """
        res = _Message.Handle_Message_Report_GetAlerts(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def HasAlert(self, *args):
        """
        HasAlert(Handle_Message_Report self, Handle_Standard_Type theType) -> Standard_Boolean
        HasAlert(Handle_Message_Report self, Handle_Standard_Type theType, Message_Gravity theGravity) -> Standard_Boolean

        Returns true if specific type of alert is recorded with specified gravity

        :type theType: OCC.wrapper.Standard.Handle_Standard_Type
        :type theGravity: OCC.wrapper.Message.Message_Gravity
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Message.Handle_Message_Report_HasAlert(self, *args)


    def Clear(self, *args):
        """
        Clear(Handle_Message_Report self)
        Clear(Handle_Message_Report self, Message_Gravity theGravity)
        Clear(Handle_Message_Report self, Handle_Standard_Type theType)

        Clears collected alerts with specified type

        :type theType: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Message.Handle_Message_Report_Clear(self, *args)


    def Dump(self, *args):
        """
        Dump(Handle_Message_Report self, Standard_OStream & theOS)
        Dump(Handle_Message_Report self, Standard_OStream & theOS, Message_Gravity theGravity)

        Dumps collected alerts with specified gravity to stream

        :type theOS: OCC.wrapper.Standard.Standard_OStream
        :type theGravity: OCC.wrapper.Message.Message_Gravity

        """
        return _Message.Handle_Message_Report_Dump(self, *args)


    def SendMessages(self, *args):
        """
        SendMessages(Handle_Message_Report self, Handle_Message_Messenger theMessenger)
        SendMessages(Handle_Message_Report self, Handle_Message_Messenger theMessenger, Message_Gravity theGravity)

        Dumps collected alerts with specified gravity to messenger

        :type theMessenger: OCC.wrapper.Message.Handle_Message_Messenger
        :type theGravity: OCC.wrapper.Message.Message_Gravity

        """
        return _Message.Handle_Message_Report_SendMessages(self, *args)


    def Merge(self, *args):
        """
        Merge(Handle_Message_Report self, Handle_Message_Report theOther)
        Merge(Handle_Message_Report self, Handle_Message_Report theOther, Message_Gravity theGravity)

        Merges alerts with specified gravity from theOther report into this

        :type theOther: OCC.wrapper.Message.Handle_Message_Report
        :type theGravity: OCC.wrapper.Message.Message_Gravity

        """
        return _Message.Handle_Message_Report_Merge(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Message_Report self) -> char const *

        :rtype: const char *

        """
        return _Message.Handle_Message_Report_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Message.Handle_Message_Report_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Message.Handle_Message_Report_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_Message_Report self)

        Memory deallocator for transient classes


        """
        return _Message.Handle_Message_Report_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Message_Report self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Message_Report self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Message.Handle_Message_Report_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Message_Report self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Message_Report self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Message.Handle_Message_Report_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Message_Report self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Message.Handle_Message_Report_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Message_Report self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Message.Handle_Message_Report_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Message_Report self)

        Increments the reference counter of this object


        """
        return _Message.Handle_Message_Report_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Message_Report self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Message.Handle_Message_Report_DecrementRefCounter(self, *args)

Handle_Message_Report_swigregister = _Message.Handle_Message_Report_swigregister
Handle_Message_Report_swigregister(Handle_Message_Report)

def Handle_Message_Report_DownCast(thing):
    return _Message.Handle_Message_Report_DownCast(thing)
Handle_Message_Report_DownCast = _Message.Handle_Message_Report_DownCast

class NCollection_List_Message_Msg_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _Message.new_NCollection_List_Message_Msg_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _Message.delete_NCollection_List_Message_Msg_IteratorHelper

    def __next__(self):
        return _Message.NCollection_List_Message_Msg_IteratorHelper___next__(self)
NCollection_List_Message_Msg_IteratorHelper_swigregister = _Message.NCollection_List_Message_Msg_IteratorHelper_swigregister
NCollection_List_Message_Msg_IteratorHelper_swigregister(NCollection_List_Message_Msg_IteratorHelper)


try:
	Message_ListOfMsg = NCollection_List_Message_Msg
except NameError:
	pass # does not exist, probably ignored

class NCollection_List_Handle_Message_Alert(NCollection.NCollection_BaseList):
    """
    Purpose:      Simple list to link  items together keeping the first 
    and the last one.
    Inherits BaseList, adding the data item to each node.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_List_Handle_Message_Alert self) -> NCollection_List< opencascade::handle< Message_Alert > >::iterator

        Returns an iterator pointing to the first element in the list.

        :rtype: iterator

        """
        return _Message.NCollection_List_Handle_Message_Alert_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_List_Handle_Message_Alert self) -> NCollection_List< opencascade::handle< Message_Alert > >::iterator

        Returns an iterator referring to the past-the-end element in the list.

        :rtype: iterator

        """
        return _Message.NCollection_List_Handle_Message_Alert_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_List_Handle_Message_Alert self) -> NCollection_List< opencascade::handle< Message_Alert > >::const_iterator

        Returns a const iterator pointing to the first element in the list.

        :rtype: const_iterator

        """
        return _Message.NCollection_List_Handle_Message_Alert_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_List_Handle_Message_Alert self) -> NCollection_List< opencascade::handle< Message_Alert > >::const_iterator

        Returns a const iterator referring to the past-the-end element in the list.

        :rtype: const_iterator

        """
        return _Message.NCollection_List_Handle_Message_Alert_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:      Simple list to link  items together keeping the first 
        and the last one.
        Inherits BaseList, adding the data item to each node.
        """
        this = _Message.new_NCollection_List_Handle_Message_Alert(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Size(self, *args):
        """
        Size(NCollection_List_Handle_Message_Alert self) -> Standard_Integer

        Size - Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Message.NCollection_List_Handle_Message_Alert_Size(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_List_Handle_Message_Alert self, NCollection_List_Handle_Message_Alert theOther) -> NCollection_List_Handle_Message_Alert

        Replace this list by the items of another list (theOther parameter).
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_List
        :rtype: OCC.wrapper.NCollection.NCollection_List

        """
        return _Message.NCollection_List_Handle_Message_Alert_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_List_Handle_Message_Alert self, NCollection_List_Handle_Message_Alert theOther) -> NCollection_List_Handle_Message_Alert

        Replacement operator

        :type theOther: OCC.wrapper.NCollection.NCollection_List
        :rtype: OCC.wrapper.NCollection.NCollection_List

        """
        return _Message.NCollection_List_Handle_Message_Alert_assign(self, *args)


    def Clear(self, *args):
        """
        Clear(NCollection_List_Handle_Message_Alert self, Handle_NCollection_BaseAllocator theAllocator=0)

        Clear this list

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _Message.NCollection_List_Handle_Message_Alert_Clear(self, *args)


    def First(self, *args):
        """
        First item

        :rtype: const TheItemType &

        """
        res = _Message.NCollection_List_Handle_Message_Alert_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Last(self, *args):
        """
        Last item

        :rtype: const TheItemType &

        """
        res = _Message.NCollection_List_Handle_Message_Alert_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Append(self, *args):
        """
        Append(NCollection_List_Handle_Message_Alert self, Handle_Message_Alert theItem) -> Handle_Message_Alert
        Append(NCollection_List_Handle_Message_Alert self, Handle_Message_Alert theItem, NCollection_List< opencascade::handle< Message_Alert > >::Iterator & theIter)
        Append(NCollection_List_Handle_Message_Alert self, NCollection_List_Handle_Message_Alert theOther)

        Append another list at the end

        :type theOther: OCC.wrapper.NCollection.NCollection_List

        """
        return _Message.NCollection_List_Handle_Message_Alert_Append(self, *args)


    def Prepend(self, *args):
        """
        Prepend(NCollection_List_Handle_Message_Alert self, Handle_Message_Alert theItem) -> Handle_Message_Alert
        Prepend(NCollection_List_Handle_Message_Alert self, NCollection_List_Handle_Message_Alert theOther)

        Prepend another list at the beginning

        :type theOther: OCC.wrapper.NCollection.NCollection_List

        """
        return _Message.NCollection_List_Handle_Message_Alert_Prepend(self, *args)


    def RemoveFirst(self, *args):
        """
        RemoveFirst(NCollection_List_Handle_Message_Alert self)

        RemoveFirst item


        """
        return _Message.NCollection_List_Handle_Message_Alert_RemoveFirst(self, *args)


    def Remove(self, *args):
        """
        Remove(NCollection_List_Handle_Message_Alert self, NCollection_List< opencascade::handle< Message_Alert > >::Iterator & theIter)

        Remove item pointed by iterator theIter; 
        theIter is then set to the next item

        :type theIter: Iterator

        """
        return _Message.NCollection_List_Handle_Message_Alert_Remove(self, *args)


    def InsertBefore(self, *args):
        """
        InsertBefore(NCollection_List_Handle_Message_Alert self, Handle_Message_Alert theItem, NCollection_List< opencascade::handle< Message_Alert > >::Iterator & theIter) -> Handle_Message_Alert
        InsertBefore(NCollection_List_Handle_Message_Alert self, NCollection_List_Handle_Message_Alert theOther, NCollection_List< opencascade::handle< Message_Alert > >::Iterator & theIter)

        InsertBefore

        :type theOther: OCC.wrapper.NCollection.NCollection_List
        :type theIter: Iterator

        """
        return _Message.NCollection_List_Handle_Message_Alert_InsertBefore(self, *args)


    def InsertAfter(self, *args):
        """
        InsertAfter(NCollection_List_Handle_Message_Alert self, Handle_Message_Alert theItem, NCollection_List< opencascade::handle< Message_Alert > >::Iterator & theIter) -> Handle_Message_Alert
        InsertAfter(NCollection_List_Handle_Message_Alert self, NCollection_List_Handle_Message_Alert theOther, NCollection_List< opencascade::handle< Message_Alert > >::Iterator & theIter)

        InsertAfter

        :type theOther: OCC.wrapper.NCollection.NCollection_List
        :type theIter: Iterator

        """
        return _Message.NCollection_List_Handle_Message_Alert_InsertAfter(self, *args)


    def Reverse(self, *args):
        """
        Reverse(NCollection_List_Handle_Message_Alert self)

        Reverse the list


        """
        return _Message.NCollection_List_Handle_Message_Alert_Reverse(self, *args)


    def __iter__(self):
        return _Message.NCollection_List_Handle_Message_Alert___iter__(self)
    __swig_destroy__ = _Message.delete_NCollection_List_Handle_Message_Alert
NCollection_List_Handle_Message_Alert_swigregister = _Message.NCollection_List_Handle_Message_Alert_swigregister
NCollection_List_Handle_Message_Alert_swigregister(NCollection_List_Handle_Message_Alert)

class NCollection_List_Handle_Message_Alert_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _Message.new_NCollection_List_Handle_Message_Alert_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _Message.delete_NCollection_List_Handle_Message_Alert_IteratorHelper

    def __next__(self):
        return _Message.NCollection_List_Handle_Message_Alert_IteratorHelper___next__(self)
NCollection_List_Handle_Message_Alert_IteratorHelper_swigregister = _Message.NCollection_List_Handle_Message_Alert_IteratorHelper_swigregister
NCollection_List_Handle_Message_Alert_IteratorHelper_swigregister(NCollection_List_Handle_Message_Alert_IteratorHelper)


try:
	Message_ListOfAlert = NCollection_List_Handle_Message_Alert
except NameError:
	pass # does not exist, probably ignored

class NCollection_Sequence_Handle_Message_Printer(NCollection.NCollection_BaseSequence):
    """
    Purpose:     Definition of a sequence of elements indexed by
    an Integer in range of 1..n
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Sequence_Handle_Message_Printer self) -> NCollection_Sequence< opencascade::handle< Message_Printer > >::iterator

        Returns an iterator pointing to the first element in the sequence.

        :rtype: iterator

        """
        return _Message.NCollection_Sequence_Handle_Message_Printer_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Sequence_Handle_Message_Printer self) -> NCollection_Sequence< opencascade::handle< Message_Printer > >::iterator

        Returns an iterator referring to the past-the-end element in the sequence.

        :rtype: iterator

        """
        return _Message.NCollection_Sequence_Handle_Message_Printer_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Sequence_Handle_Message_Printer self) -> NCollection_Sequence< opencascade::handle< Message_Printer > >::const_iterator

        Returns a const iterator pointing to the first element in the sequence.

        :rtype: const_iterator

        """
        return _Message.NCollection_Sequence_Handle_Message_Printer_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Sequence_Handle_Message_Printer self) -> NCollection_Sequence< opencascade::handle< Message_Printer > >::const_iterator

        Returns a const iterator referring to the past-the-end element in the sequence.

        :rtype: const_iterator

        """
        return _Message.NCollection_Sequence_Handle_Message_Printer_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     Definition of a sequence of elements indexed by
        an Integer in range of 1..n
        """
        this = _Message.new_NCollection_Sequence_Handle_Message_Printer(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Size(self, *args):
        """
        Size(NCollection_Sequence_Handle_Message_Printer self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Message.NCollection_Sequence_Handle_Message_Printer_Size(self, *args)


    def Length(self, *args):
        """
        Length(NCollection_Sequence_Handle_Message_Printer self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Message.NCollection_Sequence_Handle_Message_Printer_Length(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Sequence_Handle_Message_Printer self) -> Standard_Integer

        Method for consistency with other collections.
        @return Lower bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Message.NCollection_Sequence_Handle_Message_Printer_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Sequence_Handle_Message_Printer self) -> Standard_Integer

        Method for consistency with other collections.
        @return Upper bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Message.NCollection_Sequence_Handle_Message_Printer_Upper(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Sequence_Handle_Message_Printer self) -> Standard_Boolean

        Empty query

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Message.NCollection_Sequence_Handle_Message_Printer_IsEmpty(self, *args)


    def Reverse(self, *args):
        """
        Reverse(NCollection_Sequence_Handle_Message_Printer self)

        Reverse sequence


        """
        return _Message.NCollection_Sequence_Handle_Message_Printer_Reverse(self, *args)


    def Exchange(self, *args):
        """
        Exchange(NCollection_Sequence_Handle_Message_Printer self, Standard_Integer const I, Standard_Integer const J)

        Exchange two members

        :type I: int
        :type J: int

        """
        return _Message.NCollection_Sequence_Handle_Message_Printer_Exchange(self, *args)


    def delNode(*args):
        """
        delNode(NCollection_SeqNode theNode, Handle_NCollection_BaseAllocator theAl)

        Static deleter to be passed to BaseSequence

        :type theNode: OCC.wrapper.NCollection.NCollection_SeqNode
        :type theAl: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _Message.NCollection_Sequence_Handle_Message_Printer_delNode(*args)

    delNode = staticmethod(delNode)

    def Clear(self, *args):
        """
        Clear(NCollection_Sequence_Handle_Message_Printer self, Handle_NCollection_BaseAllocator theAllocator=0)

        Clear the items out, take a new allocator if non null

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _Message.NCollection_Sequence_Handle_Message_Printer_Clear(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Sequence_Handle_Message_Printer self, NCollection_Sequence_Handle_Message_Printer theOther) -> NCollection_Sequence_Handle_Message_Printer

        Replace this sequence by the items of theOther.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_Sequence
        :rtype: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _Message.NCollection_Sequence_Handle_Message_Printer_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Sequence_Handle_Message_Printer self, NCollection_Sequence_Handle_Message_Printer theOther) -> NCollection_Sequence_Handle_Message_Printer

        Replacement operator

        :type theOther: OCC.wrapper.NCollection.NCollection_Sequence
        :rtype: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _Message.NCollection_Sequence_Handle_Message_Printer_assign(self, *args)


    def Remove(self, *args):
        """
        Remove(NCollection_Sequence_Handle_Message_Printer self, NCollection_Sequence< opencascade::handle< Message_Printer > >::Iterator & thePosition)
        Remove(NCollection_Sequence_Handle_Message_Printer self, Standard_Integer const theIndex)
        Remove(NCollection_Sequence_Handle_Message_Printer self, Standard_Integer const theFromIndex, Standard_Integer const theToIndex)

        Remove range of items

        :type theFromIndex: int
        :type theToIndex: int

        """
        return _Message.NCollection_Sequence_Handle_Message_Printer_Remove(self, *args)


    def Append(self, *args):
        """
        Append(NCollection_Sequence_Handle_Message_Printer self, Handle_Message_Printer theItem)
        Append(NCollection_Sequence_Handle_Message_Printer self, NCollection_Sequence_Handle_Message_Printer theSeq)

        Append another sequence (making it empty)

        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _Message.NCollection_Sequence_Handle_Message_Printer_Append(self, *args)


    def Prepend(self, *args):
        """
        Prepend(NCollection_Sequence_Handle_Message_Printer self, Handle_Message_Printer theItem)
        Prepend(NCollection_Sequence_Handle_Message_Printer self, NCollection_Sequence_Handle_Message_Printer theSeq)

        Prepend another sequence (making it empty)

        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _Message.NCollection_Sequence_Handle_Message_Printer_Prepend(self, *args)


    def InsertBefore(self, *args):
        """
        InsertBefore(NCollection_Sequence_Handle_Message_Printer self, Standard_Integer const theIndex, Handle_Message_Printer theItem)
        InsertBefore(NCollection_Sequence_Handle_Message_Printer self, Standard_Integer const theIndex, NCollection_Sequence_Handle_Message_Printer theSeq)

        InsertBefore theIndex another sequence

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _Message.NCollection_Sequence_Handle_Message_Printer_InsertBefore(self, *args)


    def InsertAfter(self, *args):
        """
        InsertAfter(NCollection_Sequence_Handle_Message_Printer self, NCollection_Sequence< opencascade::handle< Message_Printer > >::Iterator & thePosition, Handle_Message_Printer theItem)
        InsertAfter(NCollection_Sequence_Handle_Message_Printer self, Standard_Integer const theIndex, NCollection_Sequence_Handle_Message_Printer theSeq)
        InsertAfter(NCollection_Sequence_Handle_Message_Printer self, Standard_Integer const theIndex, Handle_Message_Printer theItem)

        InsertAfter theIndex another sequence

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _Message.NCollection_Sequence_Handle_Message_Printer_InsertAfter(self, *args)


    def Split(self, *args):
        """
        Split(NCollection_Sequence_Handle_Message_Printer self, Standard_Integer const theIndex, NCollection_Sequence_Handle_Message_Printer theSeq)

        Split in two sequences

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _Message.NCollection_Sequence_Handle_Message_Printer_Split(self, *args)


    def First(self, *args):
        """
        First item access

        :rtype: const TheItemType &

        """
        res = _Message.NCollection_Sequence_Handle_Message_Printer_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Sequence_Handle_Message_Printer self) -> Handle_Message_Printer

        First item access

        :rtype: TheItemType &

        """
        return _Message.NCollection_Sequence_Handle_Message_Printer_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        Last item access

        :rtype: const TheItemType &

        """
        res = _Message.NCollection_Sequence_Handle_Message_Printer_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Sequence_Handle_Message_Printer self) -> Handle_Message_Printer

        Last item access

        :rtype: TheItemType &

        """
        return _Message.NCollection_Sequence_Handle_Message_Printer_ChangeLast(self, *args)


    def Value(self, *args):
        """
        Constant item access by theIndex

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _Message.NCollection_Sequence_Handle_Message_Printer_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Sequence_Handle_Message_Printer self, Standard_Integer const theIndex) -> Handle_Message_Printer

        Variable item access by theIndex

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _Message.NCollection_Sequence_Handle_Message_Printer_ChangeValue(self, *args)


    def __call__(self, *args):
        """
        Constant operator()

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _Message.NCollection_Sequence_Handle_Message_Printer___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetValue(self, *args):
        """
        SetValue(NCollection_Sequence_Handle_Message_Printer self, Standard_Integer const theIndex, Handle_Message_Printer theItem)

        Set item value by theIndex

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _Message.NCollection_Sequence_Handle_Message_Printer_SetValue(self, *args)


    def __iter__(self):
        return _Message.NCollection_Sequence_Handle_Message_Printer___iter__(self)
    __swig_destroy__ = _Message.delete_NCollection_Sequence_Handle_Message_Printer
NCollection_Sequence_Handle_Message_Printer_swigregister = _Message.NCollection_Sequence_Handle_Message_Printer_swigregister
NCollection_Sequence_Handle_Message_Printer_swigregister(NCollection_Sequence_Handle_Message_Printer)

def NCollection_Sequence_Handle_Message_Printer_delNode(*args):
    """
    NCollection_Sequence_Handle_Message_Printer_delNode(NCollection_SeqNode theNode, Handle_NCollection_BaseAllocator theAl)

    Static deleter to be passed to BaseSequence

    :type theNode: OCC.wrapper.NCollection.NCollection_SeqNode
    :type theAl: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

    """
    return _Message.NCollection_Sequence_Handle_Message_Printer_delNode(*args)

class NCollection_Sequence_Handle_Message_Printer_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _Message.new_NCollection_Sequence_Handle_Message_Printer_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _Message.delete_NCollection_Sequence_Handle_Message_Printer_IteratorHelper

    def __next__(self):
        return _Message.NCollection_Sequence_Handle_Message_Printer_IteratorHelper___next__(self)
NCollection_Sequence_Handle_Message_Printer_IteratorHelper_swigregister = _Message.NCollection_Sequence_Handle_Message_Printer_IteratorHelper_swigregister
NCollection_Sequence_Handle_Message_Printer_IteratorHelper_swigregister(NCollection_Sequence_Handle_Message_Printer_IteratorHelper)


try:
	Message_SequenceOfPrinters = NCollection_Sequence_Handle_Message_Printer
except NameError:
	pass # does not exist, probably ignored

class NCollection_Sequence_Message_ProgressScale(NCollection.NCollection_BaseSequence):
    """
    Purpose:     Definition of a sequence of elements indexed by
    an Integer in range of 1..n
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Sequence_Message_ProgressScale self) -> NCollection_Sequence< Message_ProgressScale >::iterator

        Returns an iterator pointing to the first element in the sequence.

        :rtype: iterator

        """
        return _Message.NCollection_Sequence_Message_ProgressScale_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Sequence_Message_ProgressScale self) -> NCollection_Sequence< Message_ProgressScale >::iterator

        Returns an iterator referring to the past-the-end element in the sequence.

        :rtype: iterator

        """
        return _Message.NCollection_Sequence_Message_ProgressScale_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Sequence_Message_ProgressScale self) -> NCollection_Sequence< Message_ProgressScale >::const_iterator

        Returns a const iterator pointing to the first element in the sequence.

        :rtype: const_iterator

        """
        return _Message.NCollection_Sequence_Message_ProgressScale_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Sequence_Message_ProgressScale self) -> NCollection_Sequence< Message_ProgressScale >::const_iterator

        Returns a const iterator referring to the past-the-end element in the sequence.

        :rtype: const_iterator

        """
        return _Message.NCollection_Sequence_Message_ProgressScale_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     Definition of a sequence of elements indexed by
        an Integer in range of 1..n
        """
        this = _Message.new_NCollection_Sequence_Message_ProgressScale(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Size(self, *args):
        """
        Size(NCollection_Sequence_Message_ProgressScale self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Message.NCollection_Sequence_Message_ProgressScale_Size(self, *args)


    def Length(self, *args):
        """
        Length(NCollection_Sequence_Message_ProgressScale self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Message.NCollection_Sequence_Message_ProgressScale_Length(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Sequence_Message_ProgressScale self) -> Standard_Integer

        Method for consistency with other collections.
        @return Lower bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Message.NCollection_Sequence_Message_ProgressScale_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Sequence_Message_ProgressScale self) -> Standard_Integer

        Method for consistency with other collections.
        @return Upper bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Message.NCollection_Sequence_Message_ProgressScale_Upper(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Sequence_Message_ProgressScale self) -> Standard_Boolean

        Empty query

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Message.NCollection_Sequence_Message_ProgressScale_IsEmpty(self, *args)


    def Reverse(self, *args):
        """
        Reverse(NCollection_Sequence_Message_ProgressScale self)

        Reverse sequence


        """
        return _Message.NCollection_Sequence_Message_ProgressScale_Reverse(self, *args)


    def Exchange(self, *args):
        """
        Exchange(NCollection_Sequence_Message_ProgressScale self, Standard_Integer const I, Standard_Integer const J)

        Exchange two members

        :type I: int
        :type J: int

        """
        return _Message.NCollection_Sequence_Message_ProgressScale_Exchange(self, *args)


    def delNode(*args):
        """
        delNode(NCollection_SeqNode theNode, Handle_NCollection_BaseAllocator theAl)

        Static deleter to be passed to BaseSequence

        :type theNode: OCC.wrapper.NCollection.NCollection_SeqNode
        :type theAl: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _Message.NCollection_Sequence_Message_ProgressScale_delNode(*args)

    delNode = staticmethod(delNode)

    def Clear(self, *args):
        """
        Clear(NCollection_Sequence_Message_ProgressScale self, Handle_NCollection_BaseAllocator theAllocator=0)

        Clear the items out, take a new allocator if non null

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _Message.NCollection_Sequence_Message_ProgressScale_Clear(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Sequence_Message_ProgressScale self, NCollection_Sequence_Message_ProgressScale theOther) -> NCollection_Sequence_Message_ProgressScale

        Replace this sequence by the items of theOther.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_Sequence
        :rtype: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _Message.NCollection_Sequence_Message_ProgressScale_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Sequence_Message_ProgressScale self, NCollection_Sequence_Message_ProgressScale theOther) -> NCollection_Sequence_Message_ProgressScale

        Replacement operator

        :type theOther: OCC.wrapper.NCollection.NCollection_Sequence
        :rtype: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _Message.NCollection_Sequence_Message_ProgressScale_assign(self, *args)


    def Remove(self, *args):
        """
        Remove(NCollection_Sequence_Message_ProgressScale self, NCollection_Sequence< Message_ProgressScale >::Iterator & thePosition)
        Remove(NCollection_Sequence_Message_ProgressScale self, Standard_Integer const theIndex)
        Remove(NCollection_Sequence_Message_ProgressScale self, Standard_Integer const theFromIndex, Standard_Integer const theToIndex)

        Remove range of items

        :type theFromIndex: int
        :type theToIndex: int

        """
        return _Message.NCollection_Sequence_Message_ProgressScale_Remove(self, *args)


    def Append(self, *args):
        """
        Append(NCollection_Sequence_Message_ProgressScale self, Message_ProgressScale theItem)
        Append(NCollection_Sequence_Message_ProgressScale self, NCollection_Sequence_Message_ProgressScale theSeq)

        Append another sequence (making it empty)

        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _Message.NCollection_Sequence_Message_ProgressScale_Append(self, *args)


    def Prepend(self, *args):
        """
        Prepend(NCollection_Sequence_Message_ProgressScale self, Message_ProgressScale theItem)
        Prepend(NCollection_Sequence_Message_ProgressScale self, NCollection_Sequence_Message_ProgressScale theSeq)

        Prepend another sequence (making it empty)

        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _Message.NCollection_Sequence_Message_ProgressScale_Prepend(self, *args)


    def InsertBefore(self, *args):
        """
        InsertBefore(NCollection_Sequence_Message_ProgressScale self, Standard_Integer const theIndex, Message_ProgressScale theItem)
        InsertBefore(NCollection_Sequence_Message_ProgressScale self, Standard_Integer const theIndex, NCollection_Sequence_Message_ProgressScale theSeq)

        InsertBefore theIndex another sequence

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _Message.NCollection_Sequence_Message_ProgressScale_InsertBefore(self, *args)


    def InsertAfter(self, *args):
        """
        InsertAfter(NCollection_Sequence_Message_ProgressScale self, NCollection_Sequence< Message_ProgressScale >::Iterator & thePosition, Message_ProgressScale theItem)
        InsertAfter(NCollection_Sequence_Message_ProgressScale self, Standard_Integer const theIndex, NCollection_Sequence_Message_ProgressScale theSeq)
        InsertAfter(NCollection_Sequence_Message_ProgressScale self, Standard_Integer const theIndex, Message_ProgressScale theItem)

        InsertAfter theIndex another sequence

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _Message.NCollection_Sequence_Message_ProgressScale_InsertAfter(self, *args)


    def Split(self, *args):
        """
        Split(NCollection_Sequence_Message_ProgressScale self, Standard_Integer const theIndex, NCollection_Sequence_Message_ProgressScale theSeq)

        Split in two sequences

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _Message.NCollection_Sequence_Message_ProgressScale_Split(self, *args)


    def First(self, *args):
        """
        First item access

        :rtype: const TheItemType &

        """
        res = _Message.NCollection_Sequence_Message_ProgressScale_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Sequence_Message_ProgressScale self) -> Message_ProgressScale

        First item access

        :rtype: TheItemType &

        """
        return _Message.NCollection_Sequence_Message_ProgressScale_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        Last item access

        :rtype: const TheItemType &

        """
        res = _Message.NCollection_Sequence_Message_ProgressScale_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Sequence_Message_ProgressScale self) -> Message_ProgressScale

        Last item access

        :rtype: TheItemType &

        """
        return _Message.NCollection_Sequence_Message_ProgressScale_ChangeLast(self, *args)


    def Value(self, *args):
        """
        Constant item access by theIndex

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _Message.NCollection_Sequence_Message_ProgressScale_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Sequence_Message_ProgressScale self, Standard_Integer const theIndex) -> Message_ProgressScale

        Variable item access by theIndex

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _Message.NCollection_Sequence_Message_ProgressScale_ChangeValue(self, *args)


    def __call__(self, *args):
        """
        Constant operator()

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _Message.NCollection_Sequence_Message_ProgressScale___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetValue(self, *args):
        """
        SetValue(NCollection_Sequence_Message_ProgressScale self, Standard_Integer const theIndex, Message_ProgressScale theItem)

        Set item value by theIndex

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _Message.NCollection_Sequence_Message_ProgressScale_SetValue(self, *args)


    def __iter__(self):
        return _Message.NCollection_Sequence_Message_ProgressScale___iter__(self)
    __swig_destroy__ = _Message.delete_NCollection_Sequence_Message_ProgressScale
NCollection_Sequence_Message_ProgressScale_swigregister = _Message.NCollection_Sequence_Message_ProgressScale_swigregister
NCollection_Sequence_Message_ProgressScale_swigregister(NCollection_Sequence_Message_ProgressScale)

def NCollection_Sequence_Message_ProgressScale_delNode(*args):
    """
    NCollection_Sequence_Message_ProgressScale_delNode(NCollection_SeqNode theNode, Handle_NCollection_BaseAllocator theAl)

    Static deleter to be passed to BaseSequence

    :type theNode: OCC.wrapper.NCollection.NCollection_SeqNode
    :type theAl: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

    """
    return _Message.NCollection_Sequence_Message_ProgressScale_delNode(*args)

class NCollection_Sequence_Message_ProgressScale_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _Message.new_NCollection_Sequence_Message_ProgressScale_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _Message.delete_NCollection_Sequence_Message_ProgressScale_IteratorHelper

    def __next__(self):
        return _Message.NCollection_Sequence_Message_ProgressScale_IteratorHelper___next__(self)
NCollection_Sequence_Message_ProgressScale_IteratorHelper_swigregister = _Message.NCollection_Sequence_Message_ProgressScale_IteratorHelper_swigregister
NCollection_Sequence_Message_ProgressScale_IteratorHelper_swigregister(NCollection_Sequence_Message_ProgressScale_IteratorHelper)


try:
	Message_SequenceOfProgressScale = NCollection_Sequence_Message_ProgressScale
except NameError:
	pass # does not exist, probably ignored

class Message_ProgressSentry(object):
    """
    This class is a tool allowing to manage opening/closing
    scopes in the ProgressIndicator in convenient and safe way.

    Its main features are:
    - Set all parameters for the current scale on the given
    ProgressIndicator and open a new scope at one line
    - Iterator-like interface to opening next scopes and
    check for user break
    - Automatic scope closing in destructor
    - Safe for NULL ProgressIndicator (just does nothing)

    Example of usage in nested process:

    @code{.cpp}
    Handle(Draw_ProgressIndicator) aProgress = ...;

    // Outer cycle
    Message_ProgressSentry anOuter (aProgress, "Outer", 0, nbOuter, 1);
    for (int i = 0; i < nbOuter && anOuter.More(); i++, anOuter.Next())
    {
    // Inner cycle
    Message_ProgressSentry anInner (aProgress, "Inner", 0, nbInner, 1);
    for (int j = 0; j < nbInner && anInner.More(); j++, anInner.Next())
    {
    // Cycle body
    }
    }
    @endcode
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Message_ProgressSentry self, Handle_Message_ProgressIndicator PI, Standard_CString const name, Standard_Real const min, Standard_Real const max, Standard_Real const step, Standard_Boolean const isInf, Standard_Real const newScopeSpan=0.0) -> Message_ProgressSentry
        __init__(Message_ProgressSentry self, Handle_Message_ProgressIndicator PI, Handle_TCollection_HAsciiString name, Standard_Real const min, Standard_Real const max, Standard_Real const step, Standard_Boolean const isInf, Standard_Real const newScopeSpan=0.0) -> Message_ProgressSentry

        Creates an instance of ProgressSentry attaching it to
        the specified ProgressIndicator, selects parameters of
        the current scale, and opens a new scope with specified
        span (equal to step by default)

        :type PI: OCC.wrapper.Message.Handle_Message_ProgressIndicator
        :type name: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type min: float
        :type max: float
        :type step: float
        :type isInf: bool
        :type newScopeSpan: float

        """
        this = _Message.new_Message_ProgressSentry(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Relieve(self, *args):
        """
        Relieve(Message_ProgressSentry self)

        Moves progress indicator to the end of the current scale
        and relieves sentry from its duty. Methods other than Show()
        will do nothing after this one is called.


        """
        return _Message.Message_ProgressSentry_Relieve(self, *args)


    def Next(self, *args):
        """
        Next(Message_ProgressSentry self, Standard_CString const name=None)
        Next(Message_ProgressSentry self, Standard_Real const span, Standard_CString const name=None)
        Next(Message_ProgressSentry self, Standard_Real const span, Handle_TCollection_HAsciiString name)

        Closes current scope and opens next one
        with either specified or default span

        :type span: float
        :type name: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _Message.Message_ProgressSentry_Next(self, *args)


    def More(self, *args):
        """
        More(Message_ProgressSentry self) -> Standard_Boolean

        Returns False if ProgressIndicator signals UserBreak

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Message.Message_ProgressSentry_More(self, *args)


    def Show(self, *args):
        """
        Show(Message_ProgressSentry self)

        Forces update of progress indicator display


        """
        return _Message.Message_ProgressSentry_Show(self, *args)

    __swig_destroy__ = _Message.delete_Message_ProgressSentry
Message_ProgressSentry_swigregister = _Message.Message_ProgressSentry_swigregister
Message_ProgressSentry_swigregister(Message_ProgressSentry)

class Handle_Message_Algorithm(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Message_Algorithm self)

        Nullify the handle


        """
        return _Message.Handle_Message_Algorithm_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Message_Algorithm self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Message.Handle_Message_Algorithm_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Message_Algorithm self, Message_Algorithm thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Message.Handle_Message_Algorithm_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Message_Algorithm self, Handle_Message_Algorithm theHandle) -> Handle_Message_Algorithm
        assign(Handle_Message_Algorithm self, Message_Algorithm thePtr) -> Handle_Message_Algorithm
        assign(Handle_Message_Algorithm self, Handle_Message_Algorithm theHandle) -> Handle_Message_Algorithm

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Message.Handle_Message_Algorithm_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Message_Algorithm self) -> Message_Algorithm

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Message.Handle_Message_Algorithm_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Message_Algorithm self) -> Message_Algorithm

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Message.Handle_Message_Algorithm___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Message_Algorithm self) -> Message_Algorithm

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Message.Handle_Message_Algorithm___ref__(self, *args)


    def __hash__(self):
        return _Message.Handle_Message_Algorithm___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Message.Handle_Message_Algorithm___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Message.new_Handle_Message_Algorithm(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Message.Handle_Message_Algorithm_DownCast)
    __swig_destroy__ = _Message.delete_Handle_Message_Algorithm

    def SetStatus(self, *args):
        """
        SetStatus(Handle_Message_Algorithm self, Message_Status const & theStat)
        SetStatus(Handle_Message_Algorithm self, Message_Status const & theStat, Standard_Integer const theInt)
        SetStatus(Handle_Message_Algorithm self, Message_Status const & theStat, Standard_CString const theStr, Standard_Boolean const noRepetitions)
        SetStatus(Handle_Message_Algorithm self, Message_Status const & theStat, TCollection_AsciiString theStr, Standard_Boolean const noRepetitions)
        SetStatus(Handle_Message_Algorithm self, Message_Status const & theStat, Handle_TCollection_HAsciiString theStr, Standard_Boolean const noRepetitions)
        SetStatus(Handle_Message_Algorithm self, Message_Status const & theStat, TCollection_ExtendedString theStr, Standard_Boolean const noRepetitions)
        SetStatus(Handle_Message_Algorithm self, Message_Status const & theStat, Handle_TCollection_HExtendedString theStr, Standard_Boolean const noRepetitions)
        SetStatus(Handle_Message_Algorithm self, Message_Status const & theStat, Message_Msg theMsg)

        Sets status with preformatted message. This message will be
        used directly to report the status; automatic generation of
        status messages will be disabled for it.

        :type theStat: OCC.wrapper.Message.Message_Status
        :type theMsg: OCC.wrapper.Message.Message_Msg

        """
        return _Message.Handle_Message_Algorithm_SetStatus(self, *args)


    def GetStatus(self, *args):
        """
        Returns copy of exec status of algorithm

        :rtype: OCC.wrapper.Message.Message_ExecStatus

        """
        res = _Message.Handle_Message_Algorithm_GetStatus(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeStatus(self, *args):
        """
        ChangeStatus(Handle_Message_Algorithm self) -> Message_ExecStatus

        Returns exec status of algorithm

        :rtype: OCC.wrapper.Message.Message_ExecStatus

        """
        return _Message.Handle_Message_Algorithm_ChangeStatus(self, *args)


    def ClearStatus(self, *args):
        """
        ClearStatus(Handle_Message_Algorithm self)

        Clear exec status of algorithm


        """
        return _Message.Handle_Message_Algorithm_ClearStatus(self, *args)


    def SetMessenger(self, *args):
        """
        SetMessenger(Handle_Message_Algorithm self, Handle_Message_Messenger theMsgr)

        Sets messenger to algorithm

        :type theMsgr: OCC.wrapper.Message.Handle_Message_Messenger

        """
        return _Message.Handle_Message_Algorithm_SetMessenger(self, *args)


    def GetMessenger(self, *args):
        """
        GetMessenger(Handle_Message_Algorithm self) -> Handle_Message_Messenger

        Returns messenger of algorithm.
        The returned handle is always non-null and can
        be used for sending messages.

        :rtype: OCC.wrapper.Message.Handle_Message_Messenger

        """
        return _Message.Handle_Message_Algorithm_GetMessenger(self, *args)


    def SendStatusMessages(self, *args):
        """
        SendStatusMessages(Handle_Message_Algorithm self, Message_ExecStatus theFilter, Message_Gravity const theTraceLevel=Message_Warning, Standard_Integer const theMaxCount=20)

        Print messages for all status flags that have been set during
        algorithm execution, excluding statuses that are NOT set
        in theFilter.

        The messages are taken from resource file, names being
        constructed as {dynamic class type}.{status name},
        for instance, "Message_Algorithm.Fail5".
        If message is not found in resources for this class and all
        its base types, surrogate text is printed.

        For the statuses having number or string parameters,
        theMaxCount defines maximal number of numbers or strings to be
        included in the message

        Note that this method is virtual; this allows descendant
        classes to customize message output (e.g. by adding
        messages from other sub-algorithms)

        :type theFilter: OCC.wrapper.Message.Message_ExecStatus
        :type theTraceLevel: OCC.wrapper.Message.Message_Gravity
        :type theMaxCount: int

        """
        return _Message.Handle_Message_Algorithm_SendStatusMessages(self, *args)


    def SendMessages(self, *args):
        """
        SendMessages(Handle_Message_Algorithm self, Message_Gravity const theTraceLevel=Message_Warning, Standard_Integer const theMaxCount=20)

        Convenient variant of SendStatusMessages() with theFilter
        having defined all WARN, ALARM, and FAIL (but not DONE)
        status flags

        :type theTraceLevel: OCC.wrapper.Message.Message_Gravity
        :type theMaxCount: int

        """
        return _Message.Handle_Message_Algorithm_SendMessages(self, *args)


    def AddStatus(self, *args):
        """
        AddStatus(Handle_Message_Algorithm self, Handle_Message_Algorithm theOther)
        AddStatus(Handle_Message_Algorithm self, Message_ExecStatus theStatus, Handle_Message_Algorithm theOther)

        Add statuses to this algorithm from other algorithm, but
        only those items are moved that correspond to statuses
        set in theStatus

        :type theStatus: OCC.wrapper.Message.Message_ExecStatus
        :type theOther: OCC.wrapper.Message.Handle_Message_Algorithm

        """
        return _Message.Handle_Message_Algorithm_AddStatus(self, *args)


    def GetMessageNumbers(self, *args):
        """
        GetMessageNumbers(Handle_Message_Algorithm self, Message_Status const & theStatus) -> Handle_TColStd_HPackedMapOfInteger

        Return the numbers associated with the indicated status;
        Null handle if no such status or no numbers associated with it

        :type theStatus: OCC.wrapper.Message.Message_Status
        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HPackedMapOfInteger

        """
        return _Message.Handle_Message_Algorithm_GetMessageNumbers(self, *args)


    def GetMessageStrings(self, *args):
        """
        GetMessageStrings(Handle_Message_Algorithm self, Message_Status const & theStatus) -> Handle_TColStd_HSequenceOfHExtendedString

        Return the strings associated with the indicated status;
        Null handle if no such status or no strings associated with it

        :type theStatus: OCC.wrapper.Message.Message_Status
        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfHExtendedString

        """
        return _Message.Handle_Message_Algorithm_GetMessageStrings(self, *args)


    def PrepareReport(self, *args):
        """
        PrepareReport(Handle_Message_Algorithm self, Handle_TColStd_HPackedMapOfInteger theError, Standard_Integer const theMaxCount) -> TCollection_ExtendedString
        PrepareReport(Handle_Message_Algorithm self, NCollection_Sequence_Handle_TCollection_HExtendedString theReportSeq, Standard_Integer const theMaxCount) -> TCollection_ExtendedString

        Prepares a string containing a list of names contained
        in theReportSeq sequence, but not more than theMaxCount

        :type theReportSeq: OCC.wrapper.TColStd.TColStd_SequenceOfHExtendedString
        :type theMaxCount: int
        :rtype: OCC.wrapper.TCollection.TCollection_ExtendedString

        """
        return _Message.Handle_Message_Algorithm_PrepareReport(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Message_Algorithm self) -> char const *

        :rtype: const char *

        """
        return _Message.Handle_Message_Algorithm_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Message.Handle_Message_Algorithm_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Message.Handle_Message_Algorithm_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_Message_Algorithm self)

        Memory deallocator for transient classes


        """
        return _Message.Handle_Message_Algorithm_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Message_Algorithm self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Message_Algorithm self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Message.Handle_Message_Algorithm_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Message_Algorithm self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Message_Algorithm self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Message.Handle_Message_Algorithm_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Message_Algorithm self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Message.Handle_Message_Algorithm_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Message_Algorithm self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Message.Handle_Message_Algorithm_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Message_Algorithm self)

        Increments the reference counter of this object


        """
        return _Message.Handle_Message_Algorithm_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Message_Algorithm self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Message.Handle_Message_Algorithm_DecrementRefCounter(self, *args)

Handle_Message_Algorithm_swigregister = _Message.Handle_Message_Algorithm_swigregister
Handle_Message_Algorithm_swigregister(Handle_Message_Algorithm)

def Handle_Message_Algorithm_DownCast(thing):
    return _Message.Handle_Message_Algorithm_DownCast(thing)
Handle_Message_Algorithm_DownCast = _Message.Handle_Message_Algorithm_DownCast

class NCollection_Handle_Message_ArrayOfMsg(Standard.Handle_Standard_Transient):
    """
    Purpose: This template class is used to define Handle adaptor
    for allocated dynamically objects of arbitrary type.

    The advantage is that this handle will automatically destroy 
    the object when last referred Handle is destroyed (i.e. it is a 
    typical smart pointer), and that it can be handled as 
    Handle(Standard_Transient) in OCCT components.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        Purpose: This template class is used to define Handle adaptor
        for allocated dynamically objects of arbitrary type.

        The advantage is that this handle will automatically destroy 
        the object when last referred Handle is destroyed (i.e. it is a 
        typical smart pointer), and that it can be handled as 
        Handle(Standard_Transient) in OCCT components.
        """
        this = _Message.new_NCollection_Handle_Message_ArrayOfMsg(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def get(self, *args):
        """
        get(NCollection_Handle_Message_ArrayOfMsg self) -> NCollection_Array1_NCollection_Handle_Message_Msg
        get(NCollection_Handle_Message_ArrayOfMsg self) -> NCollection_Array1_NCollection_Handle_Message_Msg

        Cast handle to contained type

        :rtype: const T *

        """
        return _Message.NCollection_Handle_Message_ArrayOfMsg_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(NCollection_Handle_Message_ArrayOfMsg self) -> NCollection_Array1_NCollection_Handle_Message_Msg
        __deref__(NCollection_Handle_Message_ArrayOfMsg self) -> NCollection_Array1_NCollection_Handle_Message_Msg

        Cast handle to contained type

        :rtype: const T *

        """
        return _Message.NCollection_Handle_Message_ArrayOfMsg___deref__(self, *args)


    def __ref__(self, *args):
        """
        Cast handle to contained type

        :rtype: const T &

        """
        res = _Message.NCollection_Handle_Message_ArrayOfMsg___ref__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DownCast(*args):
        """
        DownCast(Handle_Standard_Transient theOther) -> NCollection_Handle_Message_ArrayOfMsg

        Downcast arbitrary Handle to the argument type if contained
        object is Handle for this type; returns null otherwise

        :type theOther: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.NCollection.NCollection_Handle_T

        """
        return _Message.NCollection_Handle_Message_ArrayOfMsg_DownCast(*args)

    DownCast = staticmethod(DownCast)
    __swig_destroy__ = _Message.delete_NCollection_Handle_Message_ArrayOfMsg

    def begin(self, *args):
        """
        begin(NCollection_Handle_Message_ArrayOfMsg self) -> NCollection_Array1< NCollection_Handle< Message_Msg > >::iterator

        Returns an iterator pointing to the first element in the array.

        :rtype: iterator

        """
        return _Message.NCollection_Handle_Message_ArrayOfMsg_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Handle_Message_ArrayOfMsg self) -> NCollection_Array1< NCollection_Handle< Message_Msg > >::iterator

        Returns an iterator referring to the past-the-end element in the array.

        :rtype: iterator

        """
        return _Message.NCollection_Handle_Message_ArrayOfMsg_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Handle_Message_ArrayOfMsg self) -> NCollection_Array1< NCollection_Handle< Message_Msg > >::const_iterator

        Returns a const iterator pointing to the first element in the array.

        :rtype: const_iterator

        """
        return _Message.NCollection_Handle_Message_ArrayOfMsg_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Handle_Message_ArrayOfMsg self) -> NCollection_Array1< NCollection_Handle< Message_Msg > >::const_iterator

        Returns a const iterator referring to the past-the-end element in the array.

        :rtype: const_iterator

        """
        return _Message.NCollection_Handle_Message_ArrayOfMsg_cend(self, *args)


    def Init(self, *args):
        """
        Init(NCollection_Handle_Message_ArrayOfMsg self, NCollection_Handle_Message_Msg theValue)

        Initialise the items with theValue

        :type theValue: const TheItemType &

        """
        return _Message.NCollection_Handle_Message_ArrayOfMsg_Init(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_Handle_Message_ArrayOfMsg self) -> Standard_Integer

        Size query

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Message.NCollection_Handle_Message_ArrayOfMsg_Size(self, *args)


    def Length(self, *args):
        """
        Length(NCollection_Handle_Message_ArrayOfMsg self) -> Standard_Integer

        Length query (the same)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Message.NCollection_Handle_Message_ArrayOfMsg_Length(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Handle_Message_ArrayOfMsg self) -> Standard_Boolean

        Return TRUE if array has zero length.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Message.NCollection_Handle_Message_ArrayOfMsg_IsEmpty(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Handle_Message_ArrayOfMsg self) -> Standard_Integer

        Lower bound

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Message.NCollection_Handle_Message_ArrayOfMsg_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Handle_Message_ArrayOfMsg self) -> Standard_Integer

        Upper bound

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Message.NCollection_Handle_Message_ArrayOfMsg_Upper(self, *args)


    def IsDeletable(self, *args):
        """
        IsDeletable(NCollection_Handle_Message_ArrayOfMsg self) -> Standard_Boolean

        myDeletable flag

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Message.NCollection_Handle_Message_ArrayOfMsg_IsDeletable(self, *args)


    def IsAllocated(self, *args):
        """
        IsAllocated(NCollection_Handle_Message_ArrayOfMsg self) -> Standard_Boolean

        IsAllocated flag - for naming compatibility

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Message.NCollection_Handle_Message_ArrayOfMsg_IsAllocated(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Handle_Message_ArrayOfMsg self, NCollection_Array1_NCollection_Handle_Message_Msg theOther) -> NCollection_Array1_NCollection_Handle_Message_Msg

        Copies data of theOther array to this.
        This array should be pre-allocated and have the same length as theOther;
        otherwise exception Standard_DimensionMismatch is thrown.

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _Message.NCollection_Handle_Message_ArrayOfMsg_Assign(self, *args)


    def Move(self, *args):
        """
        Move(NCollection_Handle_Message_ArrayOfMsg self, NCollection_Array1_NCollection_Handle_Message_Msg theOther) -> NCollection_Array1_NCollection_Handle_Message_Msg

        Move assignment.
        This array will borrow all the data from theOther.
        The moved object will keep pointer to the memory buffer and
        range, but it will not free the buffer on destruction.

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _Message.NCollection_Handle_Message_ArrayOfMsg_Move(self, *args)


    def First(self, *args):
        """
        @return first element

        :rtype: const TheItemType &

        """
        res = _Message.NCollection_Handle_Message_ArrayOfMsg_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Handle_Message_ArrayOfMsg self) -> NCollection_Handle_Message_Msg

        @return first element

        :rtype: TheItemType &

        """
        return _Message.NCollection_Handle_Message_ArrayOfMsg_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        @return last element

        :rtype: const TheItemType &

        """
        res = _Message.NCollection_Handle_Message_ArrayOfMsg_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Handle_Message_ArrayOfMsg self) -> NCollection_Handle_Message_Msg

        @return last element

        :rtype: TheItemType &

        """
        return _Message.NCollection_Handle_Message_ArrayOfMsg_ChangeLast(self, *args)


    def Value(self, *args):
        """
        Constant value access

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _Message.NCollection_Handle_Message_ArrayOfMsg_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __call__(self, *args):
        """
        operator() - alias to Value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _Message.NCollection_Handle_Message_ArrayOfMsg___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __getitem__(self, *args):
        """
        operator[] - alias to Value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _Message.NCollection_Handle_Message_ArrayOfMsg_at(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Handle_Message_ArrayOfMsg self, Standard_Integer const theIndex) -> NCollection_Handle_Message_Msg

        Variable value access

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _Message.NCollection_Handle_Message_ArrayOfMsg_ChangeValue(self, *args)


    def SetValue(self, *args):
        """
        SetValue(NCollection_Handle_Message_ArrayOfMsg self, Standard_Integer const theIndex, NCollection_Handle_Message_Msg theItem)

        Set value 

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _Message.NCollection_Handle_Message_ArrayOfMsg_SetValue(self, *args)


    def Resize(self, *args):
        """
        Resize(NCollection_Handle_Message_ArrayOfMsg self, Standard_Integer const theLower, Standard_Integer const theUpper, Standard_Boolean const theToCopyData)

        Resizes the array to specified bounds.
        No re-allocation will be done if length of array does not change,
        but existing values will not be discarded if theToCopyData set to FALSE.
        @param theLower new lower bound of array
        @param theUpper new upper bound of array
        @param theToCopyData flag to copy existing data into new array

        :type theLower: int
        :type theUpper: int
        :type theToCopyData: bool

        """
        return _Message.NCollection_Handle_Message_ArrayOfMsg_Resize(self, *args)

NCollection_Handle_Message_ArrayOfMsg_swigregister = _Message.NCollection_Handle_Message_ArrayOfMsg_swigregister
NCollection_Handle_Message_ArrayOfMsg_swigregister(NCollection_Handle_Message_ArrayOfMsg)

def NCollection_Handle_Message_ArrayOfMsg_DownCast(*args):
    """
    NCollection_Handle_Message_ArrayOfMsg_DownCast(Handle_Standard_Transient theOther) -> NCollection_Handle_Message_ArrayOfMsg

    Downcast arbitrary Handle to the argument type if contained
    object is Handle for this type; returns null otherwise

    :type theOther: OCC.wrapper.Standard.Handle_Standard_Transient
    :rtype: OCC.wrapper.NCollection.NCollection_Handle_T

    """
    return _Message.NCollection_Handle_Message_ArrayOfMsg_DownCast(*args)


try:
	Message_HArrayOfMsg = NCollection_Handle_Message_ArrayOfMsg
except NameError:
	pass # does not exist, probably ignored

class Handle_Message_Alert(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Message_Alert self)

        Nullify the handle


        """
        return _Message.Handle_Message_Alert_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Message_Alert self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Message.Handle_Message_Alert_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Message_Alert self, Message_Alert thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Message.Handle_Message_Alert_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Message_Alert self, Handle_Message_Alert theHandle) -> Handle_Message_Alert
        assign(Handle_Message_Alert self, Message_Alert thePtr) -> Handle_Message_Alert
        assign(Handle_Message_Alert self, Handle_Message_Alert theHandle) -> Handle_Message_Alert

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Message.Handle_Message_Alert_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Message_Alert self) -> Message_Alert

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Message.Handle_Message_Alert_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Message_Alert self) -> Message_Alert

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Message.Handle_Message_Alert___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Message_Alert self) -> Message_Alert

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Message.Handle_Message_Alert___ref__(self, *args)


    def __hash__(self):
        return _Message.Handle_Message_Alert___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Message.Handle_Message_Alert___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Message.new_Handle_Message_Alert(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Message.Handle_Message_Alert_DownCast)
    __swig_destroy__ = _Message.delete_Handle_Message_Alert

    def GetMessageKey(self, *args):
        """
        GetMessageKey(Handle_Message_Alert self) -> Standard_CString

        Return a C string to be used as a key for generating text user 
        messages describing this alert.
        The messages are generated with help of Message_Msg class, in
        Message_Report::Dump().
        Base implementation returns dynamic type name of the instance.

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _Message.Handle_Message_Alert_GetMessageKey(self, *args)


    def SupportsMerge(self, *args):
        """
        SupportsMerge(Handle_Message_Alert self) -> Standard_Boolean

        Return true if this type of alert can be merged with other
        of the same type to avoid duplication.
        Basis implementation returns true.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Message.Handle_Message_Alert_SupportsMerge(self, *args)


    def Merge(self, *args):
        """
        Merge(Handle_Message_Alert self, Handle_Message_Alert theTarget) -> Standard_Boolean

        If possible, merge data contained in this alert to theTarget.
        @return True if merged.
        Base implementation always returns true.

        :type theTarget: OCC.wrapper.Message.Handle_Message_Alert
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Message.Handle_Message_Alert_Merge(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Message_Alert self) -> char const *

        :rtype: const char *

        """
        return _Message.Handle_Message_Alert_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Message.Handle_Message_Alert_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Message.Handle_Message_Alert_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_Message_Alert self)

        Memory deallocator for transient classes


        """
        return _Message.Handle_Message_Alert_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Message_Alert self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Message_Alert self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Message.Handle_Message_Alert_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Message_Alert self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Message_Alert self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Message.Handle_Message_Alert_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Message_Alert self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Message.Handle_Message_Alert_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Message_Alert self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Message.Handle_Message_Alert_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Message_Alert self)

        Increments the reference counter of this object


        """
        return _Message.Handle_Message_Alert_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Message_Alert self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Message.Handle_Message_Alert_DecrementRefCounter(self, *args)

Handle_Message_Alert_swigregister = _Message.Handle_Message_Alert_swigregister
Handle_Message_Alert_swigregister(Handle_Message_Alert)

def Handle_Message_Alert_DownCast(thing):
    return _Message.Handle_Message_Alert_DownCast(thing)
Handle_Message_Alert_DownCast = _Message.Handle_Message_Alert_DownCast

class NCollection_Array1_NCollection_Handle_Message_Msg(object):
    """
    Purpose:     The class Array1 represents unidimensional arrays 
    of fixed size known at run time. 
    The range of the index is user defined.
    An array1 can be constructed with a "C array".
    This functionality is useful to call methods expecting
    an Array1. It allows to carry the bounds inside the arrays.

    Examples:    Item tab[100]; //  An example with a C array
    Array1OfItem ttab (tab[0],1,100);

    Array1OfItem tttab (ttab(10),10,20); // a slice of ttab

    If you want to reindex an array from 1 to Length do :

    Array1 tab1(tab(tab.Lower()),1,tab.Length());

    Warning:     Programs client of such a class must be independant
    of the range of the first element. Then, a C++ for
    loop must be written like this

    for (i = A.Lower(); i <= A.Upper(); i++)

    Changes:     In  comparison  to  TCollection  the  flag  isAllocated  was
    renamed into myDeletable (alike in  the Array2).  For naming
    compatibility the method IsAllocated remained in class along
    with IsDeletable.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Array1_NCollection_Handle_Message_Msg self) -> NCollection_Array1< NCollection_Handle< Message_Msg > >::iterator

        Returns an iterator pointing to the first element in the array.

        :rtype: iterator

        """
        return _Message.NCollection_Array1_NCollection_Handle_Message_Msg_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Array1_NCollection_Handle_Message_Msg self) -> NCollection_Array1< NCollection_Handle< Message_Msg > >::iterator

        Returns an iterator referring to the past-the-end element in the array.

        :rtype: iterator

        """
        return _Message.NCollection_Array1_NCollection_Handle_Message_Msg_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Array1_NCollection_Handle_Message_Msg self) -> NCollection_Array1< NCollection_Handle< Message_Msg > >::const_iterator

        Returns a const iterator pointing to the first element in the array.

        :rtype: const_iterator

        """
        return _Message.NCollection_Array1_NCollection_Handle_Message_Msg_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Array1_NCollection_Handle_Message_Msg self) -> NCollection_Array1< NCollection_Handle< Message_Msg > >::const_iterator

        Returns a const iterator referring to the past-the-end element in the array.

        :rtype: const_iterator

        """
        return _Message.NCollection_Array1_NCollection_Handle_Message_Msg_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     The class Array1 represents unidimensional arrays 
        of fixed size known at run time. 
        The range of the index is user defined.
        An array1 can be constructed with a "C array".
        This functionality is useful to call methods expecting
        an Array1. It allows to carry the bounds inside the arrays.

        Examples:    Item tab[100]; //  An example with a C array
        Array1OfItem ttab (tab[0],1,100);

        Array1OfItem tttab (ttab(10),10,20); // a slice of ttab

        If you want to reindex an array from 1 to Length do :

        Array1 tab1(tab(tab.Lower()),1,tab.Length());

        Warning:     Programs client of such a class must be independant
        of the range of the first element. Then, a C++ for
        loop must be written like this

        for (i = A.Lower(); i <= A.Upper(); i++)

        Changes:     In  comparison  to  TCollection  the  flag  isAllocated  was
        renamed into myDeletable (alike in  the Array2).  For naming
        compatibility the method IsAllocated remained in class along
        with IsDeletable.
        """
        this = _Message.new_NCollection_Array1_NCollection_Handle_Message_Msg(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(NCollection_Array1_NCollection_Handle_Message_Msg self, NCollection_Handle_Message_Msg theValue)

        Initialise the items with theValue

        :type theValue: const TheItemType &

        """
        return _Message.NCollection_Array1_NCollection_Handle_Message_Msg_Init(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_Array1_NCollection_Handle_Message_Msg self) -> Standard_Integer

        Size query

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Message.NCollection_Array1_NCollection_Handle_Message_Msg_Size(self, *args)


    def Length(self, *args):
        """
        Length(NCollection_Array1_NCollection_Handle_Message_Msg self) -> Standard_Integer

        Length query (the same)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Message.NCollection_Array1_NCollection_Handle_Message_Msg_Length(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Array1_NCollection_Handle_Message_Msg self) -> Standard_Boolean

        Return TRUE if array has zero length.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Message.NCollection_Array1_NCollection_Handle_Message_Msg_IsEmpty(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Array1_NCollection_Handle_Message_Msg self) -> Standard_Integer

        Lower bound

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Message.NCollection_Array1_NCollection_Handle_Message_Msg_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Array1_NCollection_Handle_Message_Msg self) -> Standard_Integer

        Upper bound

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Message.NCollection_Array1_NCollection_Handle_Message_Msg_Upper(self, *args)


    def IsDeletable(self, *args):
        """
        IsDeletable(NCollection_Array1_NCollection_Handle_Message_Msg self) -> Standard_Boolean

        myDeletable flag

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Message.NCollection_Array1_NCollection_Handle_Message_Msg_IsDeletable(self, *args)


    def IsAllocated(self, *args):
        """
        IsAllocated(NCollection_Array1_NCollection_Handle_Message_Msg self) -> Standard_Boolean

        IsAllocated flag - for naming compatibility

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Message.NCollection_Array1_NCollection_Handle_Message_Msg_IsAllocated(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Array1_NCollection_Handle_Message_Msg self, NCollection_Array1_NCollection_Handle_Message_Msg theOther) -> NCollection_Array1_NCollection_Handle_Message_Msg

        Copies data of theOther array to this.
        This array should be pre-allocated and have the same length as theOther;
        otherwise exception Standard_DimensionMismatch is thrown.

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _Message.NCollection_Array1_NCollection_Handle_Message_Msg_Assign(self, *args)


    def Move(self, *args):
        """
        Move(NCollection_Array1_NCollection_Handle_Message_Msg self, NCollection_Array1_NCollection_Handle_Message_Msg theOther) -> NCollection_Array1_NCollection_Handle_Message_Msg

        Move assignment.
        This array will borrow all the data from theOther.
        The moved object will keep pointer to the memory buffer and
        range, but it will not free the buffer on destruction.

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _Message.NCollection_Array1_NCollection_Handle_Message_Msg_Move(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Array1_NCollection_Handle_Message_Msg self, NCollection_Array1_NCollection_Handle_Message_Msg theOther) -> NCollection_Array1_NCollection_Handle_Message_Msg
        assign(NCollection_Array1_NCollection_Handle_Message_Msg self, NCollection_Array1_NCollection_Handle_Message_Msg theOther) -> NCollection_Array1_NCollection_Handle_Message_Msg

        Move assignment operator; @sa Move()

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1<TheItemType> &&
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _Message.NCollection_Array1_NCollection_Handle_Message_Msg_assign(self, *args)


    def First(self, *args):
        """
        @return first element

        :rtype: const TheItemType &

        """
        res = _Message.NCollection_Array1_NCollection_Handle_Message_Msg_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Array1_NCollection_Handle_Message_Msg self) -> NCollection_Handle_Message_Msg

        @return first element

        :rtype: TheItemType &

        """
        return _Message.NCollection_Array1_NCollection_Handle_Message_Msg_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        @return last element

        :rtype: const TheItemType &

        """
        res = _Message.NCollection_Array1_NCollection_Handle_Message_Msg_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Array1_NCollection_Handle_Message_Msg self) -> NCollection_Handle_Message_Msg

        @return last element

        :rtype: TheItemType &

        """
        return _Message.NCollection_Array1_NCollection_Handle_Message_Msg_ChangeLast(self, *args)


    def Value(self, *args):
        """
        Constant value access

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _Message.NCollection_Array1_NCollection_Handle_Message_Msg_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Array1_NCollection_Handle_Message_Msg self, Standard_Integer const theIndex) -> NCollection_Handle_Message_Msg

        Variable value access

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _Message.NCollection_Array1_NCollection_Handle_Message_Msg_ChangeValue(self, *args)


    def __call__(self, *args):
        """
        operator() - alias to Value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _Message.NCollection_Array1_NCollection_Handle_Message_Msg___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __getitem__(self, *args):
        """
        operator[] - alias to Value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _Message.NCollection_Array1_NCollection_Handle_Message_Msg_at(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetValue(self, *args):
        """
        SetValue(NCollection_Array1_NCollection_Handle_Message_Msg self, Standard_Integer const theIndex, NCollection_Handle_Message_Msg theItem)

        Set value 

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _Message.NCollection_Array1_NCollection_Handle_Message_Msg_SetValue(self, *args)


    def Resize(self, *args):
        """
        Resize(NCollection_Array1_NCollection_Handle_Message_Msg self, Standard_Integer const theLower, Standard_Integer const theUpper, Standard_Boolean const theToCopyData)

        Resizes the array to specified bounds.
        No re-allocation will be done if length of array does not change,
        but existing values will not be discarded if theToCopyData set to FALSE.
        @param theLower new lower bound of array
        @param theUpper new upper bound of array
        @param theToCopyData flag to copy existing data into new array

        :type theLower: int
        :type theUpper: int
        :type theToCopyData: bool

        """
        return _Message.NCollection_Array1_NCollection_Handle_Message_Msg_Resize(self, *args)

    __swig_destroy__ = _Message.delete_NCollection_Array1_NCollection_Handle_Message_Msg
NCollection_Array1_NCollection_Handle_Message_Msg_swigregister = _Message.NCollection_Array1_NCollection_Handle_Message_Msg_swigregister
NCollection_Array1_NCollection_Handle_Message_Msg_swigregister(NCollection_Array1_NCollection_Handle_Message_Msg)


try:
	Message_ArrayOfMsg = NCollection_Array1_NCollection_Handle_Message_Msg
except NameError:
	pass # does not exist, probably ignored

class Handle_Message_Messenger(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Message_Messenger self)

        Nullify the handle


        """
        return _Message.Handle_Message_Messenger_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Message_Messenger self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Message.Handle_Message_Messenger_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Message_Messenger self, Message_Messenger thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Message.Handle_Message_Messenger_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Message_Messenger self, Handle_Message_Messenger theHandle) -> Handle_Message_Messenger
        assign(Handle_Message_Messenger self, Message_Messenger thePtr) -> Handle_Message_Messenger
        assign(Handle_Message_Messenger self, Handle_Message_Messenger theHandle) -> Handle_Message_Messenger

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Message.Handle_Message_Messenger_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Message_Messenger self) -> Message_Messenger

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Message.Handle_Message_Messenger_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Message_Messenger self) -> Message_Messenger

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Message.Handle_Message_Messenger___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Message_Messenger self) -> Message_Messenger

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Message.Handle_Message_Messenger___ref__(self, *args)


    def __hash__(self):
        return _Message.Handle_Message_Messenger___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Message.Handle_Message_Messenger___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Message.new_Handle_Message_Messenger(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Message.Handle_Message_Messenger_DownCast)
    __swig_destroy__ = _Message.delete_Handle_Message_Messenger

    def get_type_name(self, *args):
        """
        get_type_name(Handle_Message_Messenger self) -> char const *

        :rtype: const char *

        """
        return _Message.Handle_Message_Messenger_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Message.Handle_Message_Messenger_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Message.Handle_Message_Messenger_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def RemovePrinter(self, *args):
        """
        RemovePrinter(Handle_Message_Messenger self, Handle_Message_Printer thePrinter) -> Standard_Boolean

        Removes specified printer from the messenger.
        Returns True if this printer has been found in the list
        and removed.

        :type thePrinter: OCC.wrapper.Message.Handle_Message_Printer
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Message.Handle_Message_Messenger_RemovePrinter(self, *args)


    def RemovePrinters(self, *args):
        """
        RemovePrinters(Handle_Message_Messenger self, Handle_Standard_Type theType) -> Standard_Integer

        Removes printers of specified type (including derived classes)
        from the messenger.
        Returns number of removed printers.

        :type theType: OCC.wrapper.Standard.Handle_Standard_Type
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Message.Handle_Message_Messenger_RemovePrinters(self, *args)


    def Printers(self, *args):
        """
        Returns current sequence of printers

        :rtype: OCC.wrapper.Message.Message_SequenceOfPrinters

        """
        res = _Message.Handle_Message_Messenger_Printers(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangePrinters(self, *args):
        """
        ChangePrinters(Handle_Message_Messenger self) -> NCollection_Sequence_Handle_Message_Printer

        Returns sequence of printers
        The sequence can be modified.

        :rtype: OCC.wrapper.Message.Message_SequenceOfPrinters

        """
        return _Message.Handle_Message_Messenger_ChangePrinters(self, *args)


    def Send(self, *args):
        """
        Send(Handle_Message_Messenger self, Standard_CString const theString, Message_Gravity const theGravity=Message_Warning, Standard_Boolean const putEndl)
        Send(Handle_Message_Messenger self, TCollection_AsciiString theString, Message_Gravity const theGravity=Message_Warning, Standard_Boolean const putEndl)
        Send(Handle_Message_Messenger self, TCollection_ExtendedString theString, Message_Gravity const theGravity=Message_Warning, Standard_Boolean const putEndl)

        See above

        :type theString: OCC.wrapper.TCollection.TCollection_ExtendedString
        :type theGravity: OCC.wrapper.Message.Message_Gravity
        :type putEndl: bool

        """
        return _Message.Handle_Message_Messenger_Send(self, *args)


    def AddPrinter(self, bla):
        return _Message.Handle_Message_Messenger_AddPrinter(self, bla)

    def Delete(self, *args):
        """
        Delete(Handle_Message_Messenger self)

        Memory deallocator for transient classes


        """
        return _Message.Handle_Message_Messenger_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Message_Messenger self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Message_Messenger self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Message.Handle_Message_Messenger_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Message_Messenger self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Message_Messenger self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Message.Handle_Message_Messenger_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Message_Messenger self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Message.Handle_Message_Messenger_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Message_Messenger self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Message.Handle_Message_Messenger_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Message_Messenger self)

        Increments the reference counter of this object


        """
        return _Message.Handle_Message_Messenger_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Message_Messenger self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Message.Handle_Message_Messenger_DecrementRefCounter(self, *args)

Handle_Message_Messenger_swigregister = _Message.Handle_Message_Messenger_swigregister
Handle_Message_Messenger_swigregister(Handle_Message_Messenger)

def Handle_Message_Messenger_DownCast(thing):
    return _Message.Handle_Message_Messenger_DownCast(thing)
Handle_Message_Messenger_DownCast = _Message.Handle_Message_Messenger_DownCast

class Message_ExecStatus(object):
    """
    Tiny class for extended handling of error / execution
    status of algorithm in universal way.

    It is in fact a set of integers represented as a collection of bit flags
    for each of four types of status; each status flag has its own symbolic 
    name and can be set/tested individually.

    The flags are grouped in semantic groups: 
    - No flags means nothing done
    - Done flags correspond to some operation succesffuly completed
    - Warning flags correspond to warning messages on some 
    potentially wrong situation, not harming algorithm execution
    - Alarm flags correspond to more severe warnings about incorrect
    user data, while not breaking algorithm execution
    - Fail flags correspond to cases when algorithm failed to complete
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    FirstStatus = _Message.Message_ExecStatus_FirstStatus
    StatusesPerType = _Message.Message_ExecStatus_StatusesPerType
    NbStatuses = _Message.Message_ExecStatus_NbStatuses
    LastStatus = _Message.Message_ExecStatus_LastStatus

    def __init__(self, *args):
        """
        __init__(Message_ExecStatus self) -> Message_ExecStatus
        __init__(Message_ExecStatus self, Message_Status status) -> Message_ExecStatus

        Initialise the execution status

        :type status: OCC.wrapper.Message.Message_Status

        """
        this = _Message.new_Message_ExecStatus(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Set(self, *args):
        """
        Set(Message_ExecStatus self, Message_Status status)

        Sets a status flag

        :type status: OCC.wrapper.Message.Message_Status

        """
        return _Message.Message_ExecStatus_Set(self, *args)


    def IsSet(self, *args):
        """
        IsSet(Message_ExecStatus self, Message_Status status) -> Standard_Boolean

        Check status for being set

        :type status: OCC.wrapper.Message.Message_Status
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Message.Message_ExecStatus_IsSet(self, *args)


    def IsDone(self, *args):
        """
        IsDone(Message_ExecStatus self) -> Standard_Boolean

        Check if at least one status of each type is set

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Message.Message_ExecStatus_IsDone(self, *args)


    def IsFail(self, *args):
        """
        IsFail(Message_ExecStatus self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Message.Message_ExecStatus_IsFail(self, *args)


    def IsWarn(self, *args):
        """
        IsWarn(Message_ExecStatus self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Message.Message_ExecStatus_IsWarn(self, *args)


    def IsAlarm(self, *args):
        """
        IsAlarm(Message_ExecStatus self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Message.Message_ExecStatus_IsAlarm(self, *args)


    def SetAllDone(self, *args):
        """
        SetAllDone(Message_ExecStatus self)

        Set all statuses of each type


        """
        return _Message.Message_ExecStatus_SetAllDone(self, *args)


    def SetAllWarn(self, *args):
        """SetAllWarn(Message_ExecStatus self)"""
        return _Message.Message_ExecStatus_SetAllWarn(self, *args)


    def SetAllAlarm(self, *args):
        """SetAllAlarm(Message_ExecStatus self)"""
        return _Message.Message_ExecStatus_SetAllAlarm(self, *args)


    def SetAllFail(self, *args):
        """SetAllFail(Message_ExecStatus self)"""
        return _Message.Message_ExecStatus_SetAllFail(self, *args)


    def ClearAllDone(self, *args):
        """
        ClearAllDone(Message_ExecStatus self)

        Clear all statuses of each type 


        """
        return _Message.Message_ExecStatus_ClearAllDone(self, *args)


    def ClearAllWarn(self, *args):
        """ClearAllWarn(Message_ExecStatus self)"""
        return _Message.Message_ExecStatus_ClearAllWarn(self, *args)


    def ClearAllAlarm(self, *args):
        """ClearAllAlarm(Message_ExecStatus self)"""
        return _Message.Message_ExecStatus_ClearAllAlarm(self, *args)


    def ClearAllFail(self, *args):
        """ClearAllFail(Message_ExecStatus self)"""
        return _Message.Message_ExecStatus_ClearAllFail(self, *args)


    def Clear(self, *args):
        """
        Clear(Message_ExecStatus self, Message_Status status)
        Clear(Message_ExecStatus self)

        Clear all statuses


        """
        return _Message.Message_ExecStatus_Clear(self, *args)


    def Add(self, *args):
        """
        Add(Message_ExecStatus self, Message_ExecStatus theOther)

        Add statuses to me from theOther execution status

        :type theOther: OCC.wrapper.Message.Message_ExecStatus

        """
        return _Message.Message_ExecStatus_Add(self, *args)


    def __ior__(self, *args):
        """
        __ior__(Message_ExecStatus self, Message_ExecStatus theOther) -> Message_ExecStatus

        :type theOther: OCC.wrapper.Message.Message_ExecStatus
        :rtype: OCC.wrapper.Message.Message_ExecStatus

        """
        return _Message.Message_ExecStatus___ior__(self, *args)


    def And(self, *args):
        """
        And(Message_ExecStatus self, Message_ExecStatus theOther)

        Leave only the statuses common with theOther

        :type theOther: OCC.wrapper.Message.Message_ExecStatus

        """
        return _Message.Message_ExecStatus_And(self, *args)


    def __iand__(self, *args):
        """
        __iand__(Message_ExecStatus self, Message_ExecStatus theOther) -> Message_ExecStatus

        :type theOther: OCC.wrapper.Message.Message_ExecStatus
        :rtype: OCC.wrapper.Message.Message_ExecStatus

        """
        return _Message.Message_ExecStatus___iand__(self, *args)


    def StatusIndex(*args):
        """
        StatusIndex(Message_Status status) -> Standard_Integer

        Returns index of status in whole range [FirstStatus, LastStatus]

        :type status: OCC.wrapper.Message.Message_Status
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Message.Message_ExecStatus_StatusIndex(*args)

    StatusIndex = staticmethod(StatusIndex)

    def LocalStatusIndex(*args):
        """
        LocalStatusIndex(Message_Status status) -> Standard_Integer

        Returns index of status inside type of status (Done or Warn or, etc) 
        in range [1, StatusesPerType]

        :type status: OCC.wrapper.Message.Message_Status
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Message.Message_ExecStatus_LocalStatusIndex(*args)

    LocalStatusIndex = staticmethod(LocalStatusIndex)

    def TypeOfStatus(*args):
        """
        TypeOfStatus(Message_Status status) -> Message_StatusType

        Returns status type (DONE, WARN, ALARM, or FAIL) 

        :type status: OCC.wrapper.Message.Message_Status
        :rtype: OCC.wrapper.Message.Message_StatusType

        """
        return _Message.Message_ExecStatus_TypeOfStatus(*args)

    TypeOfStatus = staticmethod(TypeOfStatus)

    def StatusByIndex(*args):
        """
        StatusByIndex(Standard_Integer const theIndex) -> Message_Status

        Returns status with index theIndex in whole range [FirstStatus, LastStatus]

        :type theIndex: int
        :rtype: OCC.wrapper.Message.Message_Status

        """
        return _Message.Message_ExecStatus_StatusByIndex(*args)

    StatusByIndex = staticmethod(StatusByIndex)
    __swig_destroy__ = _Message.delete_Message_ExecStatus
Message_ExecStatus_swigregister = _Message.Message_ExecStatus_swigregister
Message_ExecStatus_swigregister(Message_ExecStatus)

def Message_ExecStatus_StatusIndex(*args):
    """
    Message_ExecStatus_StatusIndex(Message_Status status) -> Standard_Integer

    Returns index of status in whole range [FirstStatus, LastStatus]

    :type status: OCC.wrapper.Message.Message_Status
    :rtype: OCC.wrapper.Standard.Standard_Integer

    """
    return _Message.Message_ExecStatus_StatusIndex(*args)

def Message_ExecStatus_LocalStatusIndex(*args):
    """
    Message_ExecStatus_LocalStatusIndex(Message_Status status) -> Standard_Integer

    Returns index of status inside type of status (Done or Warn or, etc) 
    in range [1, StatusesPerType]

    :type status: OCC.wrapper.Message.Message_Status
    :rtype: OCC.wrapper.Standard.Standard_Integer

    """
    return _Message.Message_ExecStatus_LocalStatusIndex(*args)

def Message_ExecStatus_TypeOfStatus(*args):
    """
    Message_ExecStatus_TypeOfStatus(Message_Status status) -> Message_StatusType

    Returns status type (DONE, WARN, ALARM, or FAIL) 

    :type status: OCC.wrapper.Message.Message_Status
    :rtype: OCC.wrapper.Message.Message_StatusType

    """
    return _Message.Message_ExecStatus_TypeOfStatus(*args)

def Message_ExecStatus_StatusByIndex(*args):
    """
    Message_ExecStatus_StatusByIndex(Standard_Integer const theIndex) -> Message_Status

    Returns status with index theIndex in whole range [FirstStatus, LastStatus]

    :type theIndex: int
    :rtype: OCC.wrapper.Message.Message_Status

    """
    return _Message.Message_ExecStatus_StatusByIndex(*args)

class Message_MsgFile(object):
    """
    A tool providing facility to load definitions of message strings from
    resource file(s).

    The message file is an ASCII file which defines a set of messages.
    Each message is identified by its keyword (string).

    All lines in the file starting with the exclamation sign
    (perhaps preceeding by spaces and/or tabs) are ignored as comments.

    Each line in the file starting with the dot character "."
    (perhaps preceeding by spaces and/or tabs) defines the keyword.
    The keyword is a string starting from the next symbol after dot
    and ending at the symbol preceeding ending newline character "
    ".

    All the lines in the file after the keyword and before next
    keyword (and which are not comments) define the message for that
    keyword. If the message consists of several lines, the message
    string will contain newline symbols "
    " between parts (but not
    at the end).

    The experimental support of Unicode message files is provided.
    These are distinguished by two bytes FF.FE or FE.FF at the beginning.

    The loaded messages are stored in static data map; all methods of that
    class are also static.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Load(*args):
        """
        Load(Standard_CString const theDirName, Standard_CString const theFileName) -> Standard_Boolean

        Load message file <theFileName> from directory <theDirName>
        or its sub-directory

        :type theDirName: OCC.wrapper.Standard.Standard_CString
        :type theFileName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Message.Message_MsgFile_Load(*args)

    Load = staticmethod(Load)

    def LoadFile(*args):
        """
        LoadFile(Standard_CString const theFName) -> Standard_Boolean

        Load the messages from the given file, additive to any previously
        loaded messages. Messages with same keywords, if already present,
        are replaced with the new ones.

        :type theFName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Message.Message_MsgFile_LoadFile(*args)

    LoadFile = staticmethod(LoadFile)

    def LoadFromEnv(*args):
        """
        LoadFromEnv(Standard_CString const theEnvName, Standard_CString const theFileName, Standard_CString const theLangExt) -> Standard_Boolean

        Loads the messages from the file with name (without extension) given by environment variable.
        Extension of the file name is given separately. If its not defined, it is taken:
        - by default from environment CSF_LANGUAGE,
        - if not defined either, as "us".
        @name theEnvName  environment variable name
        @name theFileName file name without language suffix
        @name theLangExt  language file name extension
        @return TRUE on success

        :type theEnvName: OCC.wrapper.Standard.Standard_CString
        :type theFileName: OCC.wrapper.Standard.Standard_CString
        :type theLangExt: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Message.Message_MsgFile_LoadFromEnv(*args)

    LoadFromEnv = staticmethod(LoadFromEnv)

    def LoadFromString(*args):
        """
        LoadFromString(Standard_CString const theContent, Standard_Integer const theLength=-1) -> Standard_Boolean

        Loads the messages from the given text buffer.
        @param theContent string containing the messages
        @param theLength  length of the buffer;
        when -1 specified - theContent will be considered as NULL-terminated string

        :type theContent: OCC.wrapper.Standard.Standard_CString
        :type theLength: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Message.Message_MsgFile_LoadFromString(*args)

    LoadFromString = staticmethod(LoadFromString)

    def AddMsg(*args):
        """
        AddMsg(TCollection_AsciiString key, TCollection_ExtendedString text) -> Standard_Boolean

        Adds new message to the map. Parameter <key> gives
        the key of the message, <text> defines the message itself.
        If there already was defined the message identified by the
        same keyword, it is replaced with the new one.

        :type key: OCC.wrapper.TCollection.TCollection_AsciiString
        :type text: OCC.wrapper.TCollection.TCollection_ExtendedString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Message.Message_MsgFile_AddMsg(*args)

    AddMsg = staticmethod(AddMsg)

    def HasMsg(*args):
        """
        HasMsg(TCollection_AsciiString key) -> Standard_Boolean

        Returns True if message with specified keyword is registered

        :type key: OCC.wrapper.TCollection.TCollection_AsciiString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Message.Message_MsgFile_HasMsg(*args)

    HasMsg = staticmethod(HasMsg)

    def Msg(*args):
        """
        Msg(Standard_CString const key) -> TCollection_ExtendedString
        Msg(TCollection_AsciiString key) -> TCollection_ExtendedString

        Gives the text for the message identified by the keyword <key>
        If there are no messages with such keyword defined,
        the error message is returned.
        In that case reference to static string is returned, it can
        be chenged with next call(s) to Msg().
        Note: The error message is constructed like 'Unknown message: <key>', and can
        itself be customized by defining message with key Message_Msg_BadKeyword.

        :type key: OCC.wrapper.TCollection.TCollection_AsciiString
        :rtype: OCC.wrapper.TCollection.TCollection_ExtendedString

        """
        return _Message.Message_MsgFile_Msg(*args)

    Msg = staticmethod(Msg)

    def __init__(self):
        """
        A tool providing facility to load definitions of message strings from
        resource file(s).

        The message file is an ASCII file which defines a set of messages.
        Each message is identified by its keyword (string).

        All lines in the file starting with the exclamation sign
        (perhaps preceeding by spaces and/or tabs) are ignored as comments.

        Each line in the file starting with the dot character "."
        (perhaps preceeding by spaces and/or tabs) defines the keyword.
        The keyword is a string starting from the next symbol after dot
        and ending at the symbol preceeding ending newline character "
        ".

        All the lines in the file after the keyword and before next
        keyword (and which are not comments) define the message for that
        keyword. If the message consists of several lines, the message
        string will contain newline symbols "
        " between parts (but not
        at the end).

        The experimental support of Unicode message files is provided.
        These are distinguished by two bytes FF.FE or FE.FF at the beginning.

        The loaded messages are stored in static data map; all methods of that
        class are also static.
        """
        this = _Message.new_Message_MsgFile()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _Message.delete_Message_MsgFile
Message_MsgFile_swigregister = _Message.Message_MsgFile_swigregister
Message_MsgFile_swigregister(Message_MsgFile)

def Message_MsgFile_Load(*args):
    """
    Message_MsgFile_Load(Standard_CString const theDirName, Standard_CString const theFileName) -> Standard_Boolean

    Load message file <theFileName> from directory <theDirName>
    or its sub-directory

    :type theDirName: OCC.wrapper.Standard.Standard_CString
    :type theFileName: OCC.wrapper.Standard.Standard_CString
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _Message.Message_MsgFile_Load(*args)

def Message_MsgFile_LoadFile(*args):
    """
    Message_MsgFile_LoadFile(Standard_CString const theFName) -> Standard_Boolean

    Load the messages from the given file, additive to any previously
    loaded messages. Messages with same keywords, if already present,
    are replaced with the new ones.

    :type theFName: OCC.wrapper.Standard.Standard_CString
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _Message.Message_MsgFile_LoadFile(*args)

def Message_MsgFile_LoadFromEnv(*args):
    """
    Message_MsgFile_LoadFromEnv(Standard_CString const theEnvName, Standard_CString const theFileName, Standard_CString const theLangExt) -> Standard_Boolean

    Loads the messages from the file with name (without extension) given by environment variable.
    Extension of the file name is given separately. If its not defined, it is taken:
    - by default from environment CSF_LANGUAGE,
    - if not defined either, as "us".
    @name theEnvName  environment variable name
    @name theFileName file name without language suffix
    @name theLangExt  language file name extension
    @return TRUE on success

    :type theEnvName: OCC.wrapper.Standard.Standard_CString
    :type theFileName: OCC.wrapper.Standard.Standard_CString
    :type theLangExt: OCC.wrapper.Standard.Standard_CString
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _Message.Message_MsgFile_LoadFromEnv(*args)

def Message_MsgFile_LoadFromString(*args):
    """
    Message_MsgFile_LoadFromString(Standard_CString const theContent, Standard_Integer const theLength=-1) -> Standard_Boolean

    Loads the messages from the given text buffer.
    @param theContent string containing the messages
    @param theLength  length of the buffer;
    when -1 specified - theContent will be considered as NULL-terminated string

    :type theContent: OCC.wrapper.Standard.Standard_CString
    :type theLength: int
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _Message.Message_MsgFile_LoadFromString(*args)

def Message_MsgFile_AddMsg(*args):
    """
    Message_MsgFile_AddMsg(TCollection_AsciiString key, TCollection_ExtendedString text) -> Standard_Boolean

    Adds new message to the map. Parameter <key> gives
    the key of the message, <text> defines the message itself.
    If there already was defined the message identified by the
    same keyword, it is replaced with the new one.

    :type key: OCC.wrapper.TCollection.TCollection_AsciiString
    :type text: OCC.wrapper.TCollection.TCollection_ExtendedString
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _Message.Message_MsgFile_AddMsg(*args)

def Message_MsgFile_HasMsg(*args):
    """
    Message_MsgFile_HasMsg(TCollection_AsciiString key) -> Standard_Boolean

    Returns True if message with specified keyword is registered

    :type key: OCC.wrapper.TCollection.TCollection_AsciiString
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _Message.Message_MsgFile_HasMsg(*args)

def Message_MsgFile_Msg(*args):
    """
    Msg(Standard_CString const key) -> TCollection_ExtendedString
    Message_MsgFile_Msg(TCollection_AsciiString key) -> TCollection_ExtendedString

    Gives the text for the message identified by the keyword <key>
    If there are no messages with such keyword defined,
    the error message is returned.
    In that case reference to static string is returned, it can
    be chenged with next call(s) to Msg().
    Note: The error message is constructed like 'Unknown message: <key>', and can
    itself be customized by defining message with key Message_Msg_BadKeyword.

    :type key: OCC.wrapper.TCollection.TCollection_AsciiString
    :rtype: OCC.wrapper.TCollection.TCollection_ExtendedString

    """
    return _Message.Message_MsgFile_Msg(*args)

class NCollection_Handle_Message_Msg(Standard.Handle_Standard_Transient):
    """
    Purpose: This template class is used to define Handle adaptor
    for allocated dynamically objects of arbitrary type.

    The advantage is that this handle will automatically destroy 
    the object when last referred Handle is destroyed (i.e. it is a 
    typical smart pointer), and that it can be handled as 
    Handle(Standard_Transient) in OCCT components.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        Purpose: This template class is used to define Handle adaptor
        for allocated dynamically objects of arbitrary type.

        The advantage is that this handle will automatically destroy 
        the object when last referred Handle is destroyed (i.e. it is a 
        typical smart pointer), and that it can be handled as 
        Handle(Standard_Transient) in OCCT components.
        """
        this = _Message.new_NCollection_Handle_Message_Msg(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def get(self, *args):
        """
        get(NCollection_Handle_Message_Msg self) -> Message_Msg
        get(NCollection_Handle_Message_Msg self) -> Message_Msg

        Cast handle to contained type

        :rtype: const T *

        """
        return _Message.NCollection_Handle_Message_Msg_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(NCollection_Handle_Message_Msg self) -> Message_Msg
        __deref__(NCollection_Handle_Message_Msg self) -> Message_Msg

        Cast handle to contained type

        :rtype: const T *

        """
        return _Message.NCollection_Handle_Message_Msg___deref__(self, *args)


    def __ref__(self, *args):
        """
        Cast handle to contained type

        :rtype: const T &

        """
        res = _Message.NCollection_Handle_Message_Msg___ref__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DownCast(*args):
        """
        DownCast(Handle_Standard_Transient theOther) -> NCollection_Handle_Message_Msg

        Downcast arbitrary Handle to the argument type if contained
        object is Handle for this type; returns null otherwise

        :type theOther: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.NCollection.NCollection_Handle_T

        """
        return _Message.NCollection_Handle_Message_Msg_DownCast(*args)

    DownCast = staticmethod(DownCast)
    __swig_destroy__ = _Message.delete_NCollection_Handle_Message_Msg

    def Set(self, *args):
        """
        Set(NCollection_Handle_Message_Msg self, Standard_CString const theMsg)
        Set(NCollection_Handle_Message_Msg self, TCollection_ExtendedString theMsg)

        Set a message body text -- can be used as alternative to
        using messages from resource file

        :type theMsg: OCC.wrapper.TCollection.TCollection_ExtendedString

        """
        return _Message.NCollection_Handle_Message_Msg_Set(self, *args)


    def Arg(self, *args):
        """
        Arg(NCollection_Handle_Message_Msg self, Standard_CString const theString) -> Message_Msg
        Arg(NCollection_Handle_Message_Msg self, TCollection_AsciiString theString) -> Message_Msg
        Arg(NCollection_Handle_Message_Msg self, Handle_TCollection_HAsciiString theString) -> Message_Msg
        Arg(NCollection_Handle_Message_Msg self, TCollection_ExtendedString theString) -> Message_Msg
        Arg(NCollection_Handle_Message_Msg self, Handle_TCollection_HExtendedString theString) -> Message_Msg
        Arg(NCollection_Handle_Message_Msg self, Standard_Integer const theInt) -> Message_Msg
        Arg(NCollection_Handle_Message_Msg self, Standard_Real const theReal) -> Message_Msg

        Set a value for %..f, %..e, %..E, %..g or %..G conversion

        :type theReal: float
        :rtype: OCC.wrapper.Message.Message_Msg

        """
        return _Message.NCollection_Handle_Message_Msg_Arg(self, *args)


    def __lshift__(self, *args):
        """
        __lshift__(NCollection_Handle_Message_Msg self, Standard_CString const theString) -> Message_Msg
        __lshift__(NCollection_Handle_Message_Msg self, TCollection_AsciiString theString) -> Message_Msg
        __lshift__(NCollection_Handle_Message_Msg self, Handle_TCollection_HAsciiString theString) -> Message_Msg
        __lshift__(NCollection_Handle_Message_Msg self, TCollection_ExtendedString theString) -> Message_Msg
        __lshift__(NCollection_Handle_Message_Msg self, Handle_TCollection_HExtendedString theString) -> Message_Msg
        __lshift__(NCollection_Handle_Message_Msg self, Standard_Integer const theInt) -> Message_Msg
        __lshift__(NCollection_Handle_Message_Msg self, Standard_Real const theReal) -> Message_Msg

        :type theReal: float
        :rtype: OCC.wrapper.Message.Message_Msg

        """
        return _Message.NCollection_Handle_Message_Msg___lshift__(self, *args)


    def Original(self, *args):
        """
        Returns the original message text

        :rtype: OCC.wrapper.TCollection.TCollection_ExtendedString

        """
        res = _Message.NCollection_Handle_Message_Msg_Original(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Value(self, *args):
        """
        Returns current state of the message text with
        parameters to the moment

        :rtype: OCC.wrapper.TCollection.TCollection_ExtendedString

        """
        res = _Message.NCollection_Handle_Message_Msg_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def IsEdited(self, *args):
        """
        IsEdited(NCollection_Handle_Message_Msg self) -> Standard_Boolean

        Tells if Value differs from Original

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Message.NCollection_Handle_Message_Msg_IsEdited(self, *args)


    def Get(self, *args):
        """
        Return the resulting message string with all parameters
        filled. If some parameters were not yet filled by calls
        to methods Arg (or <<), these parameters are filled by
        the word UNKNOWN

        :rtype: OCC.wrapper.TCollection.TCollection_ExtendedString

        """
        res = _Message.NCollection_Handle_Message_Msg_Get(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


NCollection_Handle_Message_Msg_swigregister = _Message.NCollection_Handle_Message_Msg_swigregister
NCollection_Handle_Message_Msg_swigregister(NCollection_Handle_Message_Msg)

def NCollection_Handle_Message_Msg_DownCast(*args):
    """
    NCollection_Handle_Message_Msg_DownCast(Handle_Standard_Transient theOther) -> NCollection_Handle_Message_Msg

    Downcast arbitrary Handle to the argument type if contained
    object is Handle for this type; returns null otherwise

    :type theOther: OCC.wrapper.Standard.Handle_Standard_Transient
    :rtype: OCC.wrapper.NCollection.NCollection_Handle_T

    """
    return _Message.NCollection_Handle_Message_Msg_DownCast(*args)

class Handle_Message_Printer(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Message_Printer self)

        Nullify the handle


        """
        return _Message.Handle_Message_Printer_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Message_Printer self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Message.Handle_Message_Printer_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Message_Printer self, Message_Printer thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Message.Handle_Message_Printer_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Message_Printer self, Handle_Message_Printer theHandle) -> Handle_Message_Printer
        assign(Handle_Message_Printer self, Message_Printer thePtr) -> Handle_Message_Printer
        assign(Handle_Message_Printer self, Handle_Message_Printer theHandle) -> Handle_Message_Printer

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Message.Handle_Message_Printer_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Message_Printer self) -> Message_Printer

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Message.Handle_Message_Printer_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Message_Printer self) -> Message_Printer

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Message.Handle_Message_Printer___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Message_Printer self) -> Message_Printer

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Message.Handle_Message_Printer___ref__(self, *args)


    def __hash__(self):
        return _Message.Handle_Message_Printer___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Message.Handle_Message_Printer___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Message.new_Handle_Message_Printer(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Message.Handle_Message_Printer_DownCast)
    __swig_destroy__ = _Message.delete_Handle_Message_Printer

    def get_type_name(self, *args):
        """
        get_type_name(Handle_Message_Printer self) -> char const *

        :rtype: const char *

        """
        return _Message.Handle_Message_Printer_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Message.Handle_Message_Printer_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Message.Handle_Message_Printer_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def GetTraceLevel(self, *args):
        """
        GetTraceLevel(Handle_Message_Printer self) -> Message_Gravity

        Return trace level used for filtering messages;
        messages with lover gravity will be ignored.

        :rtype: OCC.wrapper.Message.Message_Gravity

        """
        return _Message.Handle_Message_Printer_GetTraceLevel(self, *args)


    def SetTraceLevel(self, *args):
        """
        SetTraceLevel(Handle_Message_Printer self, Message_Gravity const theTraceLevel)

        Set trace level used for filtering messages.
        By default, trace level is Message_Info, so that all messages are output

        :type theTraceLevel: OCC.wrapper.Message.Message_Gravity

        """
        return _Message.Handle_Message_Printer_SetTraceLevel(self, *args)


    def Send(self, *args):
        """
        Send(Handle_Message_Printer self, TCollection_ExtendedString theString, Message_Gravity const theGravity, Standard_Boolean const theToPutEol)
        Send(Handle_Message_Printer self, Standard_CString const theString, Message_Gravity const theGravity, Standard_Boolean const theToPutEol)
        Send(Handle_Message_Printer self, TCollection_AsciiString theString, Message_Gravity const theGravity, Standard_Boolean const theToPutEol)

        Send a string message with specified trace level.
        The parameter theToPutEol specified whether end-of-line should be added to the end of the message.
        Default implementation calls first method Send().

        :type theString: OCC.wrapper.TCollection.TCollection_AsciiString
        :type theGravity: OCC.wrapper.Message.Message_Gravity
        :type theToPutEol: bool

        """
        return _Message.Handle_Message_Printer_Send(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_Message_Printer self)

        Memory deallocator for transient classes


        """
        return _Message.Handle_Message_Printer_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Message_Printer self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Message_Printer self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Message.Handle_Message_Printer_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Message_Printer self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Message_Printer self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Message.Handle_Message_Printer_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Message_Printer self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Message.Handle_Message_Printer_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Message_Printer self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Message.Handle_Message_Printer_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Message_Printer self)

        Increments the reference counter of this object


        """
        return _Message.Handle_Message_Printer_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Message_Printer self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Message.Handle_Message_Printer_DecrementRefCounter(self, *args)

Handle_Message_Printer_swigregister = _Message.Handle_Message_Printer_swigregister
Handle_Message_Printer_swigregister(Handle_Message_Printer)

def Handle_Message_Printer_DownCast(thing):
    return _Message.Handle_Message_Printer_DownCast(thing)
Handle_Message_Printer_DownCast = _Message.Handle_Message_Printer_DownCast




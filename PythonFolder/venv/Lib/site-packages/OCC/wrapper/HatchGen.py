# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_HatchGen')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_HatchGen')
    _HatchGen = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_HatchGen', [dirname(__file__)])
        except ImportError:
            import _HatchGen
            return _HatchGen
        try:
            _mod = imp.load_module('_HatchGen', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _HatchGen = swig_import_helper()
    del swig_import_helper
else:
    import _HatchGen
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


class SwigPyIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _HatchGen.delete_SwigPyIterator

    def value(self):
        return _HatchGen.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _HatchGen.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _HatchGen.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _HatchGen.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _HatchGen.SwigPyIterator_equal(self, x)

    def copy(self):
        return _HatchGen.SwigPyIterator_copy(self)

    def next(self):
        return _HatchGen.SwigPyIterator_next(self)

    def __next__(self):
        return _HatchGen.SwigPyIterator___next__(self)

    def previous(self):
        return _HatchGen.SwigPyIterator_previous(self)

    def advance(self, n):
        return _HatchGen.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _HatchGen.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _HatchGen.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _HatchGen.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _HatchGen.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _HatchGen.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _HatchGen.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self
SwigPyIterator_swigregister = _HatchGen.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

class NCollection_CellFilter_InspectorXYZ(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _HatchGen.NCollection_CellFilter_InspectorXYZ_Dimension
    Coord = staticmethod(_HatchGen.NCollection_CellFilter_InspectorXYZ_Coord)

    def Shift(self, thePnt, theTol):
        return _HatchGen.NCollection_CellFilter_InspectorXYZ_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _HatchGen.new_NCollection_CellFilter_InspectorXYZ()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _HatchGen.delete_NCollection_CellFilter_InspectorXYZ
NCollection_CellFilter_InspectorXYZ_swigregister = _HatchGen.NCollection_CellFilter_InspectorXYZ_swigregister
NCollection_CellFilter_InspectorXYZ_swigregister(NCollection_CellFilter_InspectorXYZ)

def NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt):
    return _HatchGen.NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt)
NCollection_CellFilter_InspectorXYZ_Coord = _HatchGen.NCollection_CellFilter_InspectorXYZ_Coord

class NCollection_CellFilter_InspectorXY(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _HatchGen.NCollection_CellFilter_InspectorXY_Dimension
    Coord = staticmethod(_HatchGen.NCollection_CellFilter_InspectorXY_Coord)

    def Shift(self, thePnt, theTol):
        return _HatchGen.NCollection_CellFilter_InspectorXY_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _HatchGen.new_NCollection_CellFilter_InspectorXY()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _HatchGen.delete_NCollection_CellFilter_InspectorXY
NCollection_CellFilter_InspectorXY_swigregister = _HatchGen.NCollection_CellFilter_InspectorXY_swigregister
NCollection_CellFilter_InspectorXY_swigregister(NCollection_CellFilter_InspectorXY)

def NCollection_CellFilter_InspectorXY_Coord(i, thePnt):
    return _HatchGen.NCollection_CellFilter_InspectorXY_Coord(i, thePnt)
NCollection_CellFilter_InspectorXY_Coord = _HatchGen.NCollection_CellFilter_InspectorXY_Coord


def ptr_to_number(item):
    return _HatchGen.ptr_to_number(item)
ptr_to_number = _HatchGen.ptr_to_number

def HashCode(*args):
    return _HatchGen.HashCode(*args)
HashCode = _HatchGen.HashCode

def ptr_equal(a, b):
    return _HatchGen.ptr_equal(a, b)
ptr_equal = _HatchGen.ptr_equal
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopAbs
else:
    import TopAbs
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Standard
else:
    import Standard
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import IntRes2d
else:
    import IntRes2d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import NCollection
else:
    import NCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import gp
else:
    import gp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColStd
else:
    import TColStd
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TCollection
else:
    import TCollection
del _swig_python_version_info
HatchGen_TRUE = _HatchGen.HatchGen_TRUE
HatchGen_TOUCH = _HatchGen.HatchGen_TOUCH
HatchGen_TANGENT = _HatchGen.HatchGen_TANGENT
HatchGen_UNDETERMINED = _HatchGen.HatchGen_UNDETERMINED
HatchGen_NoProblem = _HatchGen.HatchGen_NoProblem
HatchGen_TrimFailure = _HatchGen.HatchGen_TrimFailure
HatchGen_TransitionFailure = _HatchGen.HatchGen_TransitionFailure
HatchGen_IncoherentParity = _HatchGen.HatchGen_IncoherentParity
HatchGen_IncompatibleStates = _HatchGen.HatchGen_IncompatibleStates
class HatchGen_Domain(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(HatchGen_Domain self) -> HatchGen_Domain
        __init__(HatchGen_Domain self, HatchGen_PointOnHatching P1, HatchGen_PointOnHatching P2) -> HatchGen_Domain
        __init__(HatchGen_Domain self, HatchGen_PointOnHatching P, Standard_Boolean const First) -> HatchGen_Domain

        Creates a semi-infinite domain for the curve associated
        to a hatching. The `First' flag means that the given
        point is the first one.

        :type P: OCC.wrapper.HatchGen.HatchGen_PointOnHatching
        :type First: bool

        """
        this = _HatchGen.new_HatchGen_Domain(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def SetPoints(self, *args):
        """
        SetPoints(HatchGen_Domain self, HatchGen_PointOnHatching P1, HatchGen_PointOnHatching P2)
        SetPoints(HatchGen_Domain self)

        Sets the first and the second points of the domain
        as the infinite.


        """
        return _HatchGen.HatchGen_Domain_SetPoints(self, *args)


    def SetFirstPoint(self, *args):
        """
        SetFirstPoint(HatchGen_Domain self, HatchGen_PointOnHatching P)
        SetFirstPoint(HatchGen_Domain self)

        Sets the first point of the domain at the
        infinite.


        """
        return _HatchGen.HatchGen_Domain_SetFirstPoint(self, *args)


    def SetSecondPoint(self, *args):
        """
        SetSecondPoint(HatchGen_Domain self, HatchGen_PointOnHatching P)
        SetSecondPoint(HatchGen_Domain self)

        Sets the second point of the domain at the
        infinite.


        """
        return _HatchGen.HatchGen_Domain_SetSecondPoint(self, *args)


    def HasFirstPoint(self, *args):
        """
        HasFirstPoint(HatchGen_Domain self) -> Standard_Boolean

        Returns True if the domain has a first point.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _HatchGen.HatchGen_Domain_HasFirstPoint(self, *args)


    def FirstPoint(self, *args):
        """
        Returns the first point of the domain.
        The exception DomainError is raised if
        HasFirstPoint returns False.

        :rtype: OCC.wrapper.HatchGen.HatchGen_PointOnHatching

        """
        res = _HatchGen.HatchGen_Domain_FirstPoint(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def HasSecondPoint(self, *args):
        """
        HasSecondPoint(HatchGen_Domain self) -> Standard_Boolean

        Returns True if the domain has a second point.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _HatchGen.HatchGen_Domain_HasSecondPoint(self, *args)


    def SecondPoint(self, *args):
        """
        Returns the second point of the domain.
        The exception DomainError is raised if
        HasSecondPoint returns False.

        :rtype: OCC.wrapper.HatchGen.HatchGen_PointOnHatching

        """
        res = _HatchGen.HatchGen_Domain_SecondPoint(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Dump(self, *args):
        """
        Dump(HatchGen_Domain self, Standard_Integer const Index=0)

        Dump of the domain.

        :type Index: int

        """
        return _HatchGen.HatchGen_Domain_Dump(self, *args)

    __swig_destroy__ = _HatchGen.delete_HatchGen_Domain
HatchGen_Domain_swigregister = _HatchGen.HatchGen_Domain_swigregister
HatchGen_Domain_swigregister(HatchGen_Domain)

class HatchGen_IntersectionPoint(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def SetIndex(self, *args):
        """
        SetIndex(HatchGen_IntersectionPoint self, Standard_Integer const Index)

        Sets the index of the supporting curve.

        :type Index: int

        """
        return _HatchGen.HatchGen_IntersectionPoint_SetIndex(self, *args)


    def Index(self, *args):
        """
        Index(HatchGen_IntersectionPoint self) -> Standard_Integer

        Returns the index of the supporting curve.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _HatchGen.HatchGen_IntersectionPoint_Index(self, *args)


    def SetParameter(self, *args):
        """
        SetParameter(HatchGen_IntersectionPoint self, Standard_Real const Parameter)

        Sets the parameter on the curve.

        :type Parameter: float

        """
        return _HatchGen.HatchGen_IntersectionPoint_SetParameter(self, *args)


    def Parameter(self, *args):
        """
        Parameter(HatchGen_IntersectionPoint self) -> Standard_Real

        Returns the parameter on the curve.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _HatchGen.HatchGen_IntersectionPoint_Parameter(self, *args)


    def SetPosition(self, *args):
        """
        SetPosition(HatchGen_IntersectionPoint self, TopAbs_Orientation const Position)

        Sets the position of the point on the curve.

        :type Position: OCC.wrapper.TopAbs.TopAbs_Orientation

        """
        return _HatchGen.HatchGen_IntersectionPoint_SetPosition(self, *args)


    def Position(self, *args):
        """
        Position(HatchGen_IntersectionPoint self) -> TopAbs_Orientation

        Returns the position of the point on the curve.

        :rtype: OCC.wrapper.TopAbs.TopAbs_Orientation

        """
        return _HatchGen.HatchGen_IntersectionPoint_Position(self, *args)


    def SetStateBefore(self, *args):
        """
        SetStateBefore(HatchGen_IntersectionPoint self, TopAbs_State const State)

        Sets the transition state before the intersection.

        :type State: OCC.wrapper.TopAbs.TopAbs_State

        """
        return _HatchGen.HatchGen_IntersectionPoint_SetStateBefore(self, *args)


    def StateBefore(self, *args):
        """
        StateBefore(HatchGen_IntersectionPoint self) -> TopAbs_State

        Returns the transition state before the intersection.

        :rtype: OCC.wrapper.TopAbs.TopAbs_State

        """
        return _HatchGen.HatchGen_IntersectionPoint_StateBefore(self, *args)


    def SetStateAfter(self, *args):
        """
        SetStateAfter(HatchGen_IntersectionPoint self, TopAbs_State const State)

        Sets the transition state after the intersection.

        :type State: OCC.wrapper.TopAbs.TopAbs_State

        """
        return _HatchGen.HatchGen_IntersectionPoint_SetStateAfter(self, *args)


    def StateAfter(self, *args):
        """
        StateAfter(HatchGen_IntersectionPoint self) -> TopAbs_State

        Returns the transition state after of the intersection.

        :rtype: OCC.wrapper.TopAbs.TopAbs_State

        """
        return _HatchGen.HatchGen_IntersectionPoint_StateAfter(self, *args)


    def SetSegmentBeginning(self, *args):
        """
        SetSegmentBeginning(HatchGen_IntersectionPoint self, Standard_Boolean const State)

        Sets the flag that the point is the beginning of a segment.

        :type State: bool

        """
        return _HatchGen.HatchGen_IntersectionPoint_SetSegmentBeginning(self, *args)


    def SegmentBeginning(self, *args):
        """
        SegmentBeginning(HatchGen_IntersectionPoint self) -> Standard_Boolean

        Returns the flag that the point is the beginning of a segment.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _HatchGen.HatchGen_IntersectionPoint_SegmentBeginning(self, *args)


    def SetSegmentEnd(self, *args):
        """
        SetSegmentEnd(HatchGen_IntersectionPoint self, Standard_Boolean const State)

        Sets the flag that the point is the end of a segment.

        :type State: bool

        """
        return _HatchGen.HatchGen_IntersectionPoint_SetSegmentEnd(self, *args)


    def SegmentEnd(self, *args):
        """
        SegmentEnd(HatchGen_IntersectionPoint self) -> Standard_Boolean

        Returns the flag that the point is the end of a segment.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _HatchGen.HatchGen_IntersectionPoint_SegmentEnd(self, *args)


    def Dump(self, *args):
        """
        Dump(HatchGen_IntersectionPoint self, Standard_Integer const Index=0)

        Dump of the point on element.

        :type Index: int

        """
        return _HatchGen.HatchGen_IntersectionPoint_Dump(self, *args)

HatchGen_IntersectionPoint_swigregister = _HatchGen.HatchGen_IntersectionPoint_swigregister
HatchGen_IntersectionPoint_swigregister(HatchGen_IntersectionPoint)

class HatchGen_PointOnHatching(HatchGen_IntersectionPoint):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(HatchGen_PointOnHatching self) -> HatchGen_PointOnHatching
        __init__(HatchGen_PointOnHatching self, HatchGen_PointOnHatching Point) -> HatchGen_PointOnHatching
        __init__(HatchGen_PointOnHatching self, IntRes2d_IntersectionPoint Point) -> HatchGen_PointOnHatching

        Creates a point from an intersection point.

        :type Point: OCC.wrapper.IntRes2d.IntRes2d_IntersectionPoint

        """
        this = _HatchGen.new_HatchGen_PointOnHatching(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def AddPoint(self, *args):
        """
        AddPoint(HatchGen_PointOnHatching self, HatchGen_PointOnElement Point, Standard_Real const Confusion)

        Adds a point on element to the point.

        :type Point: OCC.wrapper.HatchGen.HatchGen_PointOnElement
        :type Confusion: float

        """
        return _HatchGen.HatchGen_PointOnHatching_AddPoint(self, *args)


    def NbPoints(self, *args):
        """
        NbPoints(HatchGen_PointOnHatching self) -> Standard_Integer

        Returns the number of elements intersecting the
        hatching at this point.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _HatchGen.HatchGen_PointOnHatching_NbPoints(self, *args)


    def Point(self, *args):
        """
        Returns the Index-th point on element of the point.
        The exception OutOfRange is raised if
        Index > NbPoints.

        :type Index: int
        :rtype: OCC.wrapper.HatchGen.HatchGen_PointOnElement

        """
        res = _HatchGen.HatchGen_PointOnHatching_Point(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def RemPoint(self, *args):
        """
        RemPoint(HatchGen_PointOnHatching self, Standard_Integer const Index)

        Removes the Index-th point on element of the point.
        The exception OutOfRange is raised if
        Index > NbPoints.

        :type Index: int

        """
        return _HatchGen.HatchGen_PointOnHatching_RemPoint(self, *args)


    def ClrPoints(self, *args):
        """
        ClrPoints(HatchGen_PointOnHatching self)

        Removes all the points on element of the point.


        """
        return _HatchGen.HatchGen_PointOnHatching_ClrPoints(self, *args)


    def IsLower(self, *args):
        """
        IsLower(HatchGen_PointOnHatching self, HatchGen_PointOnHatching Point, Standard_Real const Confusion) -> Standard_Boolean

        Tests if the point is lower than an other.
        A point on hatching P1 is said to be lower than an
        other P2 if :
        P2.myParam - P1.myParam > Confusion

        :type Point: OCC.wrapper.HatchGen.HatchGen_PointOnHatching
        :type Confusion: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _HatchGen.HatchGen_PointOnHatching_IsLower(self, *args)


    def IsEqual(self, *args):
        """
        IsEqual(HatchGen_PointOnHatching self, HatchGen_PointOnHatching Point, Standard_Real const Confusion) -> Standard_Boolean

        Tests if the  point is equal to an other.
        A  point on hatching P1 is said to be equal to an
        other P2 if :
        | P2.myParam - P1.myParam | <= Confusion

        :type Point: OCC.wrapper.HatchGen.HatchGen_PointOnHatching
        :type Confusion: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _HatchGen.HatchGen_PointOnHatching_IsEqual(self, *args)


    def IsGreater(self, *args):
        """
        IsGreater(HatchGen_PointOnHatching self, HatchGen_PointOnHatching Point, Standard_Real const Confusion) -> Standard_Boolean

        Tests if the point is greater than an other.
        A point on hatching P1 is said to be greater than an
        other P2 if :
        P1.myParam - P2.myParam > Confusion

        :type Point: OCC.wrapper.HatchGen.HatchGen_PointOnHatching
        :type Confusion: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _HatchGen.HatchGen_PointOnHatching_IsGreater(self, *args)


    def Dump(self, *args):
        """
        Dump(HatchGen_PointOnHatching self, Standard_Integer const Index=0)

        Dump of the point.

        :type Index: int

        """
        return _HatchGen.HatchGen_PointOnHatching_Dump(self, *args)

    __swig_destroy__ = _HatchGen.delete_HatchGen_PointOnHatching
HatchGen_PointOnHatching_swigregister = _HatchGen.HatchGen_PointOnHatching_swigregister
HatchGen_PointOnHatching_swigregister(HatchGen_PointOnHatching)

class HatchGen_PointOnElement(HatchGen_IntersectionPoint):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(HatchGen_PointOnElement self) -> HatchGen_PointOnElement
        __init__(HatchGen_PointOnElement self, HatchGen_PointOnElement Point) -> HatchGen_PointOnElement
        __init__(HatchGen_PointOnElement self, IntRes2d_IntersectionPoint Point) -> HatchGen_PointOnElement

        Creates a point from an intersection point.

        :type Point: OCC.wrapper.IntRes2d.IntRes2d_IntersectionPoint

        """
        this = _HatchGen.new_HatchGen_PointOnElement(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def SetIntersectionType(self, *args):
        """
        SetIntersectionType(HatchGen_PointOnElement self, HatchGen_IntersectionType const Type)

        Sets the intersection type at this point.

        :type Type: OCC.wrapper.HatchGen.HatchGen_IntersectionType

        """
        return _HatchGen.HatchGen_PointOnElement_SetIntersectionType(self, *args)


    def IntersectionType(self, *args):
        """
        IntersectionType(HatchGen_PointOnElement self) -> HatchGen_IntersectionType

        Returns the intersection type at this point.

        :rtype: OCC.wrapper.HatchGen.HatchGen_IntersectionType

        """
        return _HatchGen.HatchGen_PointOnElement_IntersectionType(self, *args)


    def IsIdentical(self, *args):
        """
        IsIdentical(HatchGen_PointOnElement self, HatchGen_PointOnElement Point, Standard_Real const Confusion) -> Standard_Boolean

        Tests if the point is identical to an other.
        That is to say :
        P1.myIndex  = P2.myIndex
        Abs (P1.myParam - P2.myParam) <= Confusion
        P1.myPosit  = P2.myPosit
        P1.myBefore = P2.myBefore
        P1.myAfter  = P2.myAfter
        P1.mySegBeg = P2.mySegBeg
        P1.mySegEnd = P2.mySegEnd
        P1.myType   = P2.myType

        :type Point: OCC.wrapper.HatchGen.HatchGen_PointOnElement
        :type Confusion: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _HatchGen.HatchGen_PointOnElement_IsIdentical(self, *args)


    def IsDifferent(self, *args):
        """
        IsDifferent(HatchGen_PointOnElement self, HatchGen_PointOnElement Point, Standard_Real const Confusion) -> Standard_Boolean

        Tests if the point is different from an other.

        :type Point: OCC.wrapper.HatchGen.HatchGen_PointOnElement
        :type Confusion: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _HatchGen.HatchGen_PointOnElement_IsDifferent(self, *args)


    def Dump(self, *args):
        """
        Dump(HatchGen_PointOnElement self, Standard_Integer const Index=0)

        Dump of the point on element.

        :type Index: int

        """
        return _HatchGen.HatchGen_PointOnElement_Dump(self, *args)

    __swig_destroy__ = _HatchGen.delete_HatchGen_PointOnElement
HatchGen_PointOnElement_swigregister = _HatchGen.HatchGen_PointOnElement_swigregister
HatchGen_PointOnElement_swigregister(HatchGen_PointOnElement)

class NCollection_Sequence_HatchGen_Domain(NCollection.NCollection_BaseSequence):
    """
    Purpose:     Definition of a sequence of elements indexed by
    an Integer in range of 1..n
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Sequence_HatchGen_Domain self) -> NCollection_Sequence< HatchGen_Domain >::iterator

        Returns an iterator pointing to the first element in the sequence.

        :rtype: iterator

        """
        return _HatchGen.NCollection_Sequence_HatchGen_Domain_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Sequence_HatchGen_Domain self) -> NCollection_Sequence< HatchGen_Domain >::iterator

        Returns an iterator referring to the past-the-end element in the sequence.

        :rtype: iterator

        """
        return _HatchGen.NCollection_Sequence_HatchGen_Domain_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Sequence_HatchGen_Domain self) -> NCollection_Sequence< HatchGen_Domain >::const_iterator

        Returns a const iterator pointing to the first element in the sequence.

        :rtype: const_iterator

        """
        return _HatchGen.NCollection_Sequence_HatchGen_Domain_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Sequence_HatchGen_Domain self) -> NCollection_Sequence< HatchGen_Domain >::const_iterator

        Returns a const iterator referring to the past-the-end element in the sequence.

        :rtype: const_iterator

        """
        return _HatchGen.NCollection_Sequence_HatchGen_Domain_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     Definition of a sequence of elements indexed by
        an Integer in range of 1..n
        """
        this = _HatchGen.new_NCollection_Sequence_HatchGen_Domain(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Size(self, *args):
        """
        Size(NCollection_Sequence_HatchGen_Domain self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _HatchGen.NCollection_Sequence_HatchGen_Domain_Size(self, *args)


    def Length(self, *args):
        """
        Length(NCollection_Sequence_HatchGen_Domain self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _HatchGen.NCollection_Sequence_HatchGen_Domain_Length(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Sequence_HatchGen_Domain self) -> Standard_Integer

        Method for consistency with other collections.
        @return Lower bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _HatchGen.NCollection_Sequence_HatchGen_Domain_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Sequence_HatchGen_Domain self) -> Standard_Integer

        Method for consistency with other collections.
        @return Upper bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _HatchGen.NCollection_Sequence_HatchGen_Domain_Upper(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Sequence_HatchGen_Domain self) -> Standard_Boolean

        Empty query

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _HatchGen.NCollection_Sequence_HatchGen_Domain_IsEmpty(self, *args)


    def Reverse(self, *args):
        """
        Reverse(NCollection_Sequence_HatchGen_Domain self)

        Reverse sequence


        """
        return _HatchGen.NCollection_Sequence_HatchGen_Domain_Reverse(self, *args)


    def Exchange(self, *args):
        """
        Exchange(NCollection_Sequence_HatchGen_Domain self, Standard_Integer const I, Standard_Integer const J)

        Exchange two members

        :type I: int
        :type J: int

        """
        return _HatchGen.NCollection_Sequence_HatchGen_Domain_Exchange(self, *args)


    def delNode(*args):
        """
        delNode(NCollection_SeqNode theNode, Handle_NCollection_BaseAllocator theAl)

        Static deleter to be passed to BaseSequence

        :type theNode: OCC.wrapper.NCollection.NCollection_SeqNode
        :type theAl: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _HatchGen.NCollection_Sequence_HatchGen_Domain_delNode(*args)

    delNode = staticmethod(delNode)

    def Clear(self, *args):
        """
        Clear(NCollection_Sequence_HatchGen_Domain self, Handle_NCollection_BaseAllocator theAllocator=0)

        Clear the items out, take a new allocator if non null

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _HatchGen.NCollection_Sequence_HatchGen_Domain_Clear(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Sequence_HatchGen_Domain self, NCollection_Sequence_HatchGen_Domain theOther) -> NCollection_Sequence_HatchGen_Domain

        Replace this sequence by the items of theOther.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_Sequence
        :rtype: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _HatchGen.NCollection_Sequence_HatchGen_Domain_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Sequence_HatchGen_Domain self, NCollection_Sequence_HatchGen_Domain theOther) -> NCollection_Sequence_HatchGen_Domain

        Replacement operator

        :type theOther: OCC.wrapper.NCollection.NCollection_Sequence
        :rtype: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _HatchGen.NCollection_Sequence_HatchGen_Domain_assign(self, *args)


    def Remove(self, *args):
        """
        Remove(NCollection_Sequence_HatchGen_Domain self, NCollection_Sequence< HatchGen_Domain >::Iterator & thePosition)
        Remove(NCollection_Sequence_HatchGen_Domain self, Standard_Integer const theIndex)
        Remove(NCollection_Sequence_HatchGen_Domain self, Standard_Integer const theFromIndex, Standard_Integer const theToIndex)

        Remove range of items

        :type theFromIndex: int
        :type theToIndex: int

        """
        return _HatchGen.NCollection_Sequence_HatchGen_Domain_Remove(self, *args)


    def Append(self, *args):
        """
        Append(NCollection_Sequence_HatchGen_Domain self, HatchGen_Domain theItem)
        Append(NCollection_Sequence_HatchGen_Domain self, NCollection_Sequence_HatchGen_Domain theSeq)

        Append another sequence (making it empty)

        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _HatchGen.NCollection_Sequence_HatchGen_Domain_Append(self, *args)


    def Prepend(self, *args):
        """
        Prepend(NCollection_Sequence_HatchGen_Domain self, HatchGen_Domain theItem)
        Prepend(NCollection_Sequence_HatchGen_Domain self, NCollection_Sequence_HatchGen_Domain theSeq)

        Prepend another sequence (making it empty)

        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _HatchGen.NCollection_Sequence_HatchGen_Domain_Prepend(self, *args)


    def InsertBefore(self, *args):
        """
        InsertBefore(NCollection_Sequence_HatchGen_Domain self, Standard_Integer const theIndex, HatchGen_Domain theItem)
        InsertBefore(NCollection_Sequence_HatchGen_Domain self, Standard_Integer const theIndex, NCollection_Sequence_HatchGen_Domain theSeq)

        InsertBefore theIndex another sequence

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _HatchGen.NCollection_Sequence_HatchGen_Domain_InsertBefore(self, *args)


    def InsertAfter(self, *args):
        """
        InsertAfter(NCollection_Sequence_HatchGen_Domain self, NCollection_Sequence< HatchGen_Domain >::Iterator & thePosition, HatchGen_Domain theItem)
        InsertAfter(NCollection_Sequence_HatchGen_Domain self, Standard_Integer const theIndex, NCollection_Sequence_HatchGen_Domain theSeq)
        InsertAfter(NCollection_Sequence_HatchGen_Domain self, Standard_Integer const theIndex, HatchGen_Domain theItem)

        InsertAfter theIndex another sequence

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _HatchGen.NCollection_Sequence_HatchGen_Domain_InsertAfter(self, *args)


    def Split(self, *args):
        """
        Split(NCollection_Sequence_HatchGen_Domain self, Standard_Integer const theIndex, NCollection_Sequence_HatchGen_Domain theSeq)

        Split in two sequences

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _HatchGen.NCollection_Sequence_HatchGen_Domain_Split(self, *args)


    def First(self, *args):
        """
        First item access

        :rtype: const TheItemType &

        """
        res = _HatchGen.NCollection_Sequence_HatchGen_Domain_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Sequence_HatchGen_Domain self) -> HatchGen_Domain

        First item access

        :rtype: TheItemType &

        """
        return _HatchGen.NCollection_Sequence_HatchGen_Domain_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        Last item access

        :rtype: const TheItemType &

        """
        res = _HatchGen.NCollection_Sequence_HatchGen_Domain_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Sequence_HatchGen_Domain self) -> HatchGen_Domain

        Last item access

        :rtype: TheItemType &

        """
        return _HatchGen.NCollection_Sequence_HatchGen_Domain_ChangeLast(self, *args)


    def Value(self, *args):
        """
        Constant item access by theIndex

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _HatchGen.NCollection_Sequence_HatchGen_Domain_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Sequence_HatchGen_Domain self, Standard_Integer const theIndex) -> HatchGen_Domain

        Variable item access by theIndex

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _HatchGen.NCollection_Sequence_HatchGen_Domain_ChangeValue(self, *args)


    def __call__(self, *args):
        """
        Constant operator()

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _HatchGen.NCollection_Sequence_HatchGen_Domain___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetValue(self, *args):
        """
        SetValue(NCollection_Sequence_HatchGen_Domain self, Standard_Integer const theIndex, HatchGen_Domain theItem)

        Set item value by theIndex

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _HatchGen.NCollection_Sequence_HatchGen_Domain_SetValue(self, *args)


    def __iter__(self):
        return _HatchGen.NCollection_Sequence_HatchGen_Domain___iter__(self)
    __swig_destroy__ = _HatchGen.delete_NCollection_Sequence_HatchGen_Domain
NCollection_Sequence_HatchGen_Domain_swigregister = _HatchGen.NCollection_Sequence_HatchGen_Domain_swigregister
NCollection_Sequence_HatchGen_Domain_swigregister(NCollection_Sequence_HatchGen_Domain)

def NCollection_Sequence_HatchGen_Domain_delNode(*args):
    """
    NCollection_Sequence_HatchGen_Domain_delNode(NCollection_SeqNode theNode, Handle_NCollection_BaseAllocator theAl)

    Static deleter to be passed to BaseSequence

    :type theNode: OCC.wrapper.NCollection.NCollection_SeqNode
    :type theAl: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

    """
    return _HatchGen.NCollection_Sequence_HatchGen_Domain_delNode(*args)

class NCollection_Sequence_HatchGen_Domain_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _HatchGen.new_NCollection_Sequence_HatchGen_Domain_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _HatchGen.delete_NCollection_Sequence_HatchGen_Domain_IteratorHelper

    def __next__(self):
        return _HatchGen.NCollection_Sequence_HatchGen_Domain_IteratorHelper___next__(self)
NCollection_Sequence_HatchGen_Domain_IteratorHelper_swigregister = _HatchGen.NCollection_Sequence_HatchGen_Domain_IteratorHelper_swigregister
NCollection_Sequence_HatchGen_Domain_IteratorHelper_swigregister(NCollection_Sequence_HatchGen_Domain_IteratorHelper)


try:
	HatchGen_Domains = NCollection_Sequence_HatchGen_Domain
except NameError:
	pass # does not exist, probably ignored

class NCollection_Sequence_HatchGen_PointOnElement(NCollection.NCollection_BaseSequence):
    """
    Purpose:     Definition of a sequence of elements indexed by
    an Integer in range of 1..n
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Sequence_HatchGen_PointOnElement self) -> NCollection_Sequence< HatchGen_PointOnElement >::iterator

        Returns an iterator pointing to the first element in the sequence.

        :rtype: iterator

        """
        return _HatchGen.NCollection_Sequence_HatchGen_PointOnElement_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Sequence_HatchGen_PointOnElement self) -> NCollection_Sequence< HatchGen_PointOnElement >::iterator

        Returns an iterator referring to the past-the-end element in the sequence.

        :rtype: iterator

        """
        return _HatchGen.NCollection_Sequence_HatchGen_PointOnElement_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Sequence_HatchGen_PointOnElement self) -> NCollection_Sequence< HatchGen_PointOnElement >::const_iterator

        Returns a const iterator pointing to the first element in the sequence.

        :rtype: const_iterator

        """
        return _HatchGen.NCollection_Sequence_HatchGen_PointOnElement_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Sequence_HatchGen_PointOnElement self) -> NCollection_Sequence< HatchGen_PointOnElement >::const_iterator

        Returns a const iterator referring to the past-the-end element in the sequence.

        :rtype: const_iterator

        """
        return _HatchGen.NCollection_Sequence_HatchGen_PointOnElement_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     Definition of a sequence of elements indexed by
        an Integer in range of 1..n
        """
        this = _HatchGen.new_NCollection_Sequence_HatchGen_PointOnElement(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Size(self, *args):
        """
        Size(NCollection_Sequence_HatchGen_PointOnElement self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _HatchGen.NCollection_Sequence_HatchGen_PointOnElement_Size(self, *args)


    def Length(self, *args):
        """
        Length(NCollection_Sequence_HatchGen_PointOnElement self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _HatchGen.NCollection_Sequence_HatchGen_PointOnElement_Length(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Sequence_HatchGen_PointOnElement self) -> Standard_Integer

        Method for consistency with other collections.
        @return Lower bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _HatchGen.NCollection_Sequence_HatchGen_PointOnElement_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Sequence_HatchGen_PointOnElement self) -> Standard_Integer

        Method for consistency with other collections.
        @return Upper bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _HatchGen.NCollection_Sequence_HatchGen_PointOnElement_Upper(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Sequence_HatchGen_PointOnElement self) -> Standard_Boolean

        Empty query

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _HatchGen.NCollection_Sequence_HatchGen_PointOnElement_IsEmpty(self, *args)


    def Reverse(self, *args):
        """
        Reverse(NCollection_Sequence_HatchGen_PointOnElement self)

        Reverse sequence


        """
        return _HatchGen.NCollection_Sequence_HatchGen_PointOnElement_Reverse(self, *args)


    def Exchange(self, *args):
        """
        Exchange(NCollection_Sequence_HatchGen_PointOnElement self, Standard_Integer const I, Standard_Integer const J)

        Exchange two members

        :type I: int
        :type J: int

        """
        return _HatchGen.NCollection_Sequence_HatchGen_PointOnElement_Exchange(self, *args)


    def delNode(*args):
        """
        delNode(NCollection_SeqNode theNode, Handle_NCollection_BaseAllocator theAl)

        Static deleter to be passed to BaseSequence

        :type theNode: OCC.wrapper.NCollection.NCollection_SeqNode
        :type theAl: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _HatchGen.NCollection_Sequence_HatchGen_PointOnElement_delNode(*args)

    delNode = staticmethod(delNode)

    def Clear(self, *args):
        """
        Clear(NCollection_Sequence_HatchGen_PointOnElement self, Handle_NCollection_BaseAllocator theAllocator=0)

        Clear the items out, take a new allocator if non null

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _HatchGen.NCollection_Sequence_HatchGen_PointOnElement_Clear(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Sequence_HatchGen_PointOnElement self, NCollection_Sequence_HatchGen_PointOnElement theOther) -> NCollection_Sequence_HatchGen_PointOnElement

        Replace this sequence by the items of theOther.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_Sequence
        :rtype: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _HatchGen.NCollection_Sequence_HatchGen_PointOnElement_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Sequence_HatchGen_PointOnElement self, NCollection_Sequence_HatchGen_PointOnElement theOther) -> NCollection_Sequence_HatchGen_PointOnElement

        Replacement operator

        :type theOther: OCC.wrapper.NCollection.NCollection_Sequence
        :rtype: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _HatchGen.NCollection_Sequence_HatchGen_PointOnElement_assign(self, *args)


    def Remove(self, *args):
        """
        Remove(NCollection_Sequence_HatchGen_PointOnElement self, NCollection_Sequence< HatchGen_PointOnElement >::Iterator & thePosition)
        Remove(NCollection_Sequence_HatchGen_PointOnElement self, Standard_Integer const theIndex)
        Remove(NCollection_Sequence_HatchGen_PointOnElement self, Standard_Integer const theFromIndex, Standard_Integer const theToIndex)

        Remove range of items

        :type theFromIndex: int
        :type theToIndex: int

        """
        return _HatchGen.NCollection_Sequence_HatchGen_PointOnElement_Remove(self, *args)


    def Append(self, *args):
        """
        Append(NCollection_Sequence_HatchGen_PointOnElement self, HatchGen_PointOnElement theItem)
        Append(NCollection_Sequence_HatchGen_PointOnElement self, NCollection_Sequence_HatchGen_PointOnElement theSeq)

        Append another sequence (making it empty)

        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _HatchGen.NCollection_Sequence_HatchGen_PointOnElement_Append(self, *args)


    def Prepend(self, *args):
        """
        Prepend(NCollection_Sequence_HatchGen_PointOnElement self, HatchGen_PointOnElement theItem)
        Prepend(NCollection_Sequence_HatchGen_PointOnElement self, NCollection_Sequence_HatchGen_PointOnElement theSeq)

        Prepend another sequence (making it empty)

        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _HatchGen.NCollection_Sequence_HatchGen_PointOnElement_Prepend(self, *args)


    def InsertBefore(self, *args):
        """
        InsertBefore(NCollection_Sequence_HatchGen_PointOnElement self, Standard_Integer const theIndex, HatchGen_PointOnElement theItem)
        InsertBefore(NCollection_Sequence_HatchGen_PointOnElement self, Standard_Integer const theIndex, NCollection_Sequence_HatchGen_PointOnElement theSeq)

        InsertBefore theIndex another sequence

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _HatchGen.NCollection_Sequence_HatchGen_PointOnElement_InsertBefore(self, *args)


    def InsertAfter(self, *args):
        """
        InsertAfter(NCollection_Sequence_HatchGen_PointOnElement self, NCollection_Sequence< HatchGen_PointOnElement >::Iterator & thePosition, HatchGen_PointOnElement theItem)
        InsertAfter(NCollection_Sequence_HatchGen_PointOnElement self, Standard_Integer const theIndex, NCollection_Sequence_HatchGen_PointOnElement theSeq)
        InsertAfter(NCollection_Sequence_HatchGen_PointOnElement self, Standard_Integer const theIndex, HatchGen_PointOnElement theItem)

        InsertAfter theIndex another sequence

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _HatchGen.NCollection_Sequence_HatchGen_PointOnElement_InsertAfter(self, *args)


    def Split(self, *args):
        """
        Split(NCollection_Sequence_HatchGen_PointOnElement self, Standard_Integer const theIndex, NCollection_Sequence_HatchGen_PointOnElement theSeq)

        Split in two sequences

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _HatchGen.NCollection_Sequence_HatchGen_PointOnElement_Split(self, *args)


    def First(self, *args):
        """
        First item access

        :rtype: const TheItemType &

        """
        res = _HatchGen.NCollection_Sequence_HatchGen_PointOnElement_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Sequence_HatchGen_PointOnElement self) -> HatchGen_PointOnElement

        First item access

        :rtype: TheItemType &

        """
        return _HatchGen.NCollection_Sequence_HatchGen_PointOnElement_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        Last item access

        :rtype: const TheItemType &

        """
        res = _HatchGen.NCollection_Sequence_HatchGen_PointOnElement_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Sequence_HatchGen_PointOnElement self) -> HatchGen_PointOnElement

        Last item access

        :rtype: TheItemType &

        """
        return _HatchGen.NCollection_Sequence_HatchGen_PointOnElement_ChangeLast(self, *args)


    def Value(self, *args):
        """
        Constant item access by theIndex

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _HatchGen.NCollection_Sequence_HatchGen_PointOnElement_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Sequence_HatchGen_PointOnElement self, Standard_Integer const theIndex) -> HatchGen_PointOnElement

        Variable item access by theIndex

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _HatchGen.NCollection_Sequence_HatchGen_PointOnElement_ChangeValue(self, *args)


    def __call__(self, *args):
        """
        Constant operator()

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _HatchGen.NCollection_Sequence_HatchGen_PointOnElement___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetValue(self, *args):
        """
        SetValue(NCollection_Sequence_HatchGen_PointOnElement self, Standard_Integer const theIndex, HatchGen_PointOnElement theItem)

        Set item value by theIndex

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _HatchGen.NCollection_Sequence_HatchGen_PointOnElement_SetValue(self, *args)


    def __iter__(self):
        return _HatchGen.NCollection_Sequence_HatchGen_PointOnElement___iter__(self)
    __swig_destroy__ = _HatchGen.delete_NCollection_Sequence_HatchGen_PointOnElement
NCollection_Sequence_HatchGen_PointOnElement_swigregister = _HatchGen.NCollection_Sequence_HatchGen_PointOnElement_swigregister
NCollection_Sequence_HatchGen_PointOnElement_swigregister(NCollection_Sequence_HatchGen_PointOnElement)

def NCollection_Sequence_HatchGen_PointOnElement_delNode(*args):
    """
    NCollection_Sequence_HatchGen_PointOnElement_delNode(NCollection_SeqNode theNode, Handle_NCollection_BaseAllocator theAl)

    Static deleter to be passed to BaseSequence

    :type theNode: OCC.wrapper.NCollection.NCollection_SeqNode
    :type theAl: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

    """
    return _HatchGen.NCollection_Sequence_HatchGen_PointOnElement_delNode(*args)

class NCollection_Sequence_HatchGen_PointOnElement_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _HatchGen.new_NCollection_Sequence_HatchGen_PointOnElement_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _HatchGen.delete_NCollection_Sequence_HatchGen_PointOnElement_IteratorHelper

    def __next__(self):
        return _HatchGen.NCollection_Sequence_HatchGen_PointOnElement_IteratorHelper___next__(self)
NCollection_Sequence_HatchGen_PointOnElement_IteratorHelper_swigregister = _HatchGen.NCollection_Sequence_HatchGen_PointOnElement_IteratorHelper_swigregister
NCollection_Sequence_HatchGen_PointOnElement_IteratorHelper_swigregister(NCollection_Sequence_HatchGen_PointOnElement_IteratorHelper)


try:
	HatchGen_PointsOnElement = NCollection_Sequence_HatchGen_PointOnElement
except NameError:
	pass # does not exist, probably ignored

class NCollection_Sequence_HatchGen_PointOnHatching(NCollection.NCollection_BaseSequence):
    """
    Purpose:     Definition of a sequence of elements indexed by
    an Integer in range of 1..n
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Sequence_HatchGen_PointOnHatching self) -> NCollection_Sequence< HatchGen_PointOnHatching >::iterator

        Returns an iterator pointing to the first element in the sequence.

        :rtype: iterator

        """
        return _HatchGen.NCollection_Sequence_HatchGen_PointOnHatching_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Sequence_HatchGen_PointOnHatching self) -> NCollection_Sequence< HatchGen_PointOnHatching >::iterator

        Returns an iterator referring to the past-the-end element in the sequence.

        :rtype: iterator

        """
        return _HatchGen.NCollection_Sequence_HatchGen_PointOnHatching_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Sequence_HatchGen_PointOnHatching self) -> NCollection_Sequence< HatchGen_PointOnHatching >::const_iterator

        Returns a const iterator pointing to the first element in the sequence.

        :rtype: const_iterator

        """
        return _HatchGen.NCollection_Sequence_HatchGen_PointOnHatching_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Sequence_HatchGen_PointOnHatching self) -> NCollection_Sequence< HatchGen_PointOnHatching >::const_iterator

        Returns a const iterator referring to the past-the-end element in the sequence.

        :rtype: const_iterator

        """
        return _HatchGen.NCollection_Sequence_HatchGen_PointOnHatching_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     Definition of a sequence of elements indexed by
        an Integer in range of 1..n
        """
        this = _HatchGen.new_NCollection_Sequence_HatchGen_PointOnHatching(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Size(self, *args):
        """
        Size(NCollection_Sequence_HatchGen_PointOnHatching self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _HatchGen.NCollection_Sequence_HatchGen_PointOnHatching_Size(self, *args)


    def Length(self, *args):
        """
        Length(NCollection_Sequence_HatchGen_PointOnHatching self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _HatchGen.NCollection_Sequence_HatchGen_PointOnHatching_Length(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Sequence_HatchGen_PointOnHatching self) -> Standard_Integer

        Method for consistency with other collections.
        @return Lower bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _HatchGen.NCollection_Sequence_HatchGen_PointOnHatching_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Sequence_HatchGen_PointOnHatching self) -> Standard_Integer

        Method for consistency with other collections.
        @return Upper bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _HatchGen.NCollection_Sequence_HatchGen_PointOnHatching_Upper(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Sequence_HatchGen_PointOnHatching self) -> Standard_Boolean

        Empty query

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _HatchGen.NCollection_Sequence_HatchGen_PointOnHatching_IsEmpty(self, *args)


    def Reverse(self, *args):
        """
        Reverse(NCollection_Sequence_HatchGen_PointOnHatching self)

        Reverse sequence


        """
        return _HatchGen.NCollection_Sequence_HatchGen_PointOnHatching_Reverse(self, *args)


    def Exchange(self, *args):
        """
        Exchange(NCollection_Sequence_HatchGen_PointOnHatching self, Standard_Integer const I, Standard_Integer const J)

        Exchange two members

        :type I: int
        :type J: int

        """
        return _HatchGen.NCollection_Sequence_HatchGen_PointOnHatching_Exchange(self, *args)


    def delNode(*args):
        """
        delNode(NCollection_SeqNode theNode, Handle_NCollection_BaseAllocator theAl)

        Static deleter to be passed to BaseSequence

        :type theNode: OCC.wrapper.NCollection.NCollection_SeqNode
        :type theAl: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _HatchGen.NCollection_Sequence_HatchGen_PointOnHatching_delNode(*args)

    delNode = staticmethod(delNode)

    def Clear(self, *args):
        """
        Clear(NCollection_Sequence_HatchGen_PointOnHatching self, Handle_NCollection_BaseAllocator theAllocator=0)

        Clear the items out, take a new allocator if non null

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _HatchGen.NCollection_Sequence_HatchGen_PointOnHatching_Clear(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Sequence_HatchGen_PointOnHatching self, NCollection_Sequence_HatchGen_PointOnHatching theOther) -> NCollection_Sequence_HatchGen_PointOnHatching

        Replace this sequence by the items of theOther.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_Sequence
        :rtype: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _HatchGen.NCollection_Sequence_HatchGen_PointOnHatching_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Sequence_HatchGen_PointOnHatching self, NCollection_Sequence_HatchGen_PointOnHatching theOther) -> NCollection_Sequence_HatchGen_PointOnHatching

        Replacement operator

        :type theOther: OCC.wrapper.NCollection.NCollection_Sequence
        :rtype: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _HatchGen.NCollection_Sequence_HatchGen_PointOnHatching_assign(self, *args)


    def Remove(self, *args):
        """
        Remove(NCollection_Sequence_HatchGen_PointOnHatching self, NCollection_Sequence< HatchGen_PointOnHatching >::Iterator & thePosition)
        Remove(NCollection_Sequence_HatchGen_PointOnHatching self, Standard_Integer const theIndex)
        Remove(NCollection_Sequence_HatchGen_PointOnHatching self, Standard_Integer const theFromIndex, Standard_Integer const theToIndex)

        Remove range of items

        :type theFromIndex: int
        :type theToIndex: int

        """
        return _HatchGen.NCollection_Sequence_HatchGen_PointOnHatching_Remove(self, *args)


    def Append(self, *args):
        """
        Append(NCollection_Sequence_HatchGen_PointOnHatching self, HatchGen_PointOnHatching theItem)
        Append(NCollection_Sequence_HatchGen_PointOnHatching self, NCollection_Sequence_HatchGen_PointOnHatching theSeq)

        Append another sequence (making it empty)

        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _HatchGen.NCollection_Sequence_HatchGen_PointOnHatching_Append(self, *args)


    def Prepend(self, *args):
        """
        Prepend(NCollection_Sequence_HatchGen_PointOnHatching self, HatchGen_PointOnHatching theItem)
        Prepend(NCollection_Sequence_HatchGen_PointOnHatching self, NCollection_Sequence_HatchGen_PointOnHatching theSeq)

        Prepend another sequence (making it empty)

        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _HatchGen.NCollection_Sequence_HatchGen_PointOnHatching_Prepend(self, *args)


    def InsertBefore(self, *args):
        """
        InsertBefore(NCollection_Sequence_HatchGen_PointOnHatching self, Standard_Integer const theIndex, HatchGen_PointOnHatching theItem)
        InsertBefore(NCollection_Sequence_HatchGen_PointOnHatching self, Standard_Integer const theIndex, NCollection_Sequence_HatchGen_PointOnHatching theSeq)

        InsertBefore theIndex another sequence

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _HatchGen.NCollection_Sequence_HatchGen_PointOnHatching_InsertBefore(self, *args)


    def InsertAfter(self, *args):
        """
        InsertAfter(NCollection_Sequence_HatchGen_PointOnHatching self, NCollection_Sequence< HatchGen_PointOnHatching >::Iterator & thePosition, HatchGen_PointOnHatching theItem)
        InsertAfter(NCollection_Sequence_HatchGen_PointOnHatching self, Standard_Integer const theIndex, NCollection_Sequence_HatchGen_PointOnHatching theSeq)
        InsertAfter(NCollection_Sequence_HatchGen_PointOnHatching self, Standard_Integer const theIndex, HatchGen_PointOnHatching theItem)

        InsertAfter theIndex another sequence

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _HatchGen.NCollection_Sequence_HatchGen_PointOnHatching_InsertAfter(self, *args)


    def Split(self, *args):
        """
        Split(NCollection_Sequence_HatchGen_PointOnHatching self, Standard_Integer const theIndex, NCollection_Sequence_HatchGen_PointOnHatching theSeq)

        Split in two sequences

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _HatchGen.NCollection_Sequence_HatchGen_PointOnHatching_Split(self, *args)


    def First(self, *args):
        """
        First item access

        :rtype: const TheItemType &

        """
        res = _HatchGen.NCollection_Sequence_HatchGen_PointOnHatching_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Sequence_HatchGen_PointOnHatching self) -> HatchGen_PointOnHatching

        First item access

        :rtype: TheItemType &

        """
        return _HatchGen.NCollection_Sequence_HatchGen_PointOnHatching_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        Last item access

        :rtype: const TheItemType &

        """
        res = _HatchGen.NCollection_Sequence_HatchGen_PointOnHatching_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Sequence_HatchGen_PointOnHatching self) -> HatchGen_PointOnHatching

        Last item access

        :rtype: TheItemType &

        """
        return _HatchGen.NCollection_Sequence_HatchGen_PointOnHatching_ChangeLast(self, *args)


    def Value(self, *args):
        """
        Constant item access by theIndex

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _HatchGen.NCollection_Sequence_HatchGen_PointOnHatching_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Sequence_HatchGen_PointOnHatching self, Standard_Integer const theIndex) -> HatchGen_PointOnHatching

        Variable item access by theIndex

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _HatchGen.NCollection_Sequence_HatchGen_PointOnHatching_ChangeValue(self, *args)


    def __call__(self, *args):
        """
        Constant operator()

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _HatchGen.NCollection_Sequence_HatchGen_PointOnHatching___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetValue(self, *args):
        """
        SetValue(NCollection_Sequence_HatchGen_PointOnHatching self, Standard_Integer const theIndex, HatchGen_PointOnHatching theItem)

        Set item value by theIndex

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _HatchGen.NCollection_Sequence_HatchGen_PointOnHatching_SetValue(self, *args)


    def __iter__(self):
        return _HatchGen.NCollection_Sequence_HatchGen_PointOnHatching___iter__(self)
    __swig_destroy__ = _HatchGen.delete_NCollection_Sequence_HatchGen_PointOnHatching
NCollection_Sequence_HatchGen_PointOnHatching_swigregister = _HatchGen.NCollection_Sequence_HatchGen_PointOnHatching_swigregister
NCollection_Sequence_HatchGen_PointOnHatching_swigregister(NCollection_Sequence_HatchGen_PointOnHatching)

def NCollection_Sequence_HatchGen_PointOnHatching_delNode(*args):
    """
    NCollection_Sequence_HatchGen_PointOnHatching_delNode(NCollection_SeqNode theNode, Handle_NCollection_BaseAllocator theAl)

    Static deleter to be passed to BaseSequence

    :type theNode: OCC.wrapper.NCollection.NCollection_SeqNode
    :type theAl: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

    """
    return _HatchGen.NCollection_Sequence_HatchGen_PointOnHatching_delNode(*args)

class NCollection_Sequence_HatchGen_PointOnHatching_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _HatchGen.new_NCollection_Sequence_HatchGen_PointOnHatching_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _HatchGen.delete_NCollection_Sequence_HatchGen_PointOnHatching_IteratorHelper

    def __next__(self):
        return _HatchGen.NCollection_Sequence_HatchGen_PointOnHatching_IteratorHelper___next__(self)
NCollection_Sequence_HatchGen_PointOnHatching_IteratorHelper_swigregister = _HatchGen.NCollection_Sequence_HatchGen_PointOnHatching_IteratorHelper_swigregister
NCollection_Sequence_HatchGen_PointOnHatching_IteratorHelper_swigregister(NCollection_Sequence_HatchGen_PointOnHatching_IteratorHelper)


try:
	HatchGen_PointsOnHatching = NCollection_Sequence_HatchGen_PointOnHatching
except NameError:
	pass # does not exist, probably ignored



